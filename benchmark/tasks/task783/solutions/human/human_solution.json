[
  {
    "language": "Crystal",
    "code": "INF = 1i64 << 60\nn, a, b = read_line.split.map(&.to_i64)\np = read_line.split.map(&.to_i)\nprev = [INF] * (n + 1)\nprev[0] = 0i64\ncur = [INF] * (n + 1)\nused = [false] * (n + 1)\nn.times do |i|\n  cur.fill(INF)\n  uc = 0\n  1.upto(p[i] - 1) do |j|\n    if used[j]\n      uc += 1\n    end\n  end\n  0.upto(p[i] - 1) do |j|\n    if j != 0 && !used[j]\n      uc += 1\n    end\n    if uc == p[i] - 1\n      cur[j] = prev[j]\n      next\n    end\n    cur[j] = prev[j] + a\n    cur[p[i]] = {cur[p[i]], prev[j] + b * (p[i] - 1 - uc)}.min\n  end\n  cur[p[i]] = {cur[p[i]], prev[p[i]]}.min\n  (p[i] + 1).upto(n) do |j|\n    cur[j] = prev[j]\n  end\n  used[p[i]] = true\n  prev, cur = cur, prev\nend\nputs prev.min\n"
  },
  {
    "language": "Fortran",
    "code": "program rotation_sort\n  implicit none\n  integer :: n, p(5000) = 0, i, j\n  integer(8) :: a, b, dp(0:5000,0:5000) = 0_8\n  read(*,*) n, a, b\n  read(*,*) p(1:n)\n  do i = 1, n\n    do j = 0, n\n      dp(i,j) = dp(i-1,j)\n      if (j < p(i)) then\n        dp(i,j) = dp(i,j)+a\n      else if (j > p(i)) then\n        dp(i,j) = dp(i,j)+b\n      end if\n      if (j > 0) dp(i,j) = min(dp(i,j),dp(i,j-1))\n    end do\n  end do\n  write(*,'(i0)') dp(n,n)\nend program rotation_sort"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 5e3 + 5;\nconst ll INF = 1e18;\n\nint N, A, B;\nint perm[MAXN], inv[MAXN];\nll dp[MAXN][MAXN];\n\nvoid load() {\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\tfor (int i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", perm + i);\n\t\tinv[perm[i]] = i;\n\t}\n}\n\nll rec(int num, int mx) {\n\tll &ref = dp[num][mx];\n\tif (ref != INF)\n\t\treturn ref;\n\tif (num > N)\n\t\treturn ref = 0;\n\tif (mx > inv[num]) \n\t\treturn ref = rec(num + 1, mx) + A;\n\treturn ref = min(rec(num + 1, inv[num]), rec(num + 1, mx) + B);\n}\n\nll solve() {\n\tfor (int i = 0; i < MAXN; i++)\n\t\tfor (int j = 0; j < MAXN; j++)\n\t\t\tdp[i][j] = INF;\n\t\t\t\n\treturn rec(1, 0);\n}\n\nint main() {\n\tload();\n\tprintf(\"%lld\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 5005\ntypedef long long ll;\n\nint n, A, B;\nint a[N], b[N], s[N], g[N][N];\nll dp[N];\n\nint main() {\n    scanf(\"%d %d %d\", &n, &A, &B);\n    for (int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i ++) {\n        int j = i-1;\n        while (j>0&&a[j]<a[i]) j = b[j];\n        b[i] = j;\n    }\n    for (int i = 1; i <= n; i ++) {\n        int j = i-1;\n        while (j>0&&a[j]>a[i]) j = s[j];\n        s[i] = j;\n    }\n    for (int i = 1; i <= n; i ++) {\n        for (int j = 1; j <= n; j ++) g[i][j] = g[i-1][j];\n        for (int j = a[i]; j <= n; j ++) g[i][j] ++;\n    }\n    ll ans = 1e18;\n    dp[0] = 0;\n    for (int i = 1; i <= n; i ++) {\n\t\tdp[i] = 1e18;\n        for (int j = 0; j < i; j ++) if (a[j] < a[i]) {\n            int x = g[i-1][a[i]-1] - g[j][a[i]-1];\n            dp[i] = min(dp[i], dp[j] + 1ll * x * B + 1ll * (i-j-1-x) * A);\n        }\n        ans = min(ans, dp[i]+1ll*(n-i)*B);\n    }\n    printf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,f[5005];\nlong long dp[5005];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++)\n    {\n        int x;\n        scanf(\"%d\",&x);\n        f[x]=i;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        int pos=f[i];\n        long long t=1e18;\n        for(int j=1;j<=n;j++)\n        {\n            t=min(t,dp[j]);\n            if(pos==j) dp[j]=t;\n            else if(pos>j) dp[j]=t+b;\n            else dp[j]=t+a;\n        }\n    }\n    long long ans=1e18;\n    for(int i=1;i<=n;i++)\n        ans=min(ans,dp[i]);\n    printf(\"%lld\\n\",ans);\n}\n/*dp[i][j]表示将第i个数搬移到前j个位置的最小价值*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\tconst int N = 5005;\n\n\tint n, A, B, P[N];\n\tll F[N];\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d%d%d\", &n, &A, &B);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tscanf(\"%d\", &P[i]);\n\t\tP[n + 1] = n + 1;\n\t\tmemset(F, 0x3f, sizeof(F));\n\t\tF[0] = 0;\n\t\tfor (int i = 1; i <= n + 1; i++)\n\t\t{\n\t\t\tint cnt[2] = {0, 0};\n\t\t\tif (P[i - 1] < P[i])\n\t\t\t\tF[i] = F[i - 1];\n\t\t\tfor (int j = i - 1; j; j--)\n\t\t\t{\n\t\t\t\tcnt[P[j] < P[i]]++;\n\t\t\t\tif (P[j - 1] < P[i])\n\t\t\t\t\tF[i] = min(F[i], F[j - 1] + (ll)cnt[0] * A + (ll)cnt[1] * B);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", F[n + 1]);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst ll MAX_N = 5e3 + 15, inf = 1000000LL * 1000000LL * 1000000LL;\nll n, L, R, ans = inf, ind = 0;\nll index[MAX_N];\nll Arr[MAX_N];\nll cntl[MAX_N][MAX_N];\nll cntb[MAX_N][MAX_N];\n\nll dp[MAX_N];\nset <pii> Set, Set2;\n\nvoid processMin() {\n\tfor (ll i = 0; i < n; i++) {\n\t\tll l = 0, b = 0;\n\t\tfor (ll j = i - 1; 0 <= j; j--) {\n\t\t\tl += (Arr[j] < Arr[i]);\n\t\t\tb += (Arr[j] > Arr[i]);\n\t\t\t\n\t\t\tcntl[i][j] = l;\n\t\t\tcntb[i][j] = b;\n\t\t}\n\t}\n\t\n\tfor (ll i = 0; i < n; i++) {\n\t\tll l = 0, b = 0;\n\t\tfor (ll j = i + 1; j < n; j++) {\n\t\t\tl += (Arr[j] < Arr[i]);\n\t\t\tb += (Arr[j] > Arr[i]);\n\t\t\t\n\t\t\tcntl[i][j] = l;\n\t\t\tcntb[i][j] = b;\n\t\t}\n\t}\n}\n\nint main() {\n//\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> L >> R;\n\tswap(L, R);\n\t\n\tfor (ll i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\t\n\t\tindex[Arr[i]] = i;\n\t}\n\t\n\tprocessMin();\n\t\n\tind = Arr[0];\n\tfor (ll i = 1; i < n; i++) {\n\t\tif (ind > Arr[i]) {\n\t\t\tdp[i] = cntb[i][0] * R;\n\t\t\tind = Arr[i];\n\t\t}\n\t\telse\n\t\t\tdp[i] = inf;\n\t\t\t\n\t\tint Max = -1;\n\t\tfor (ll j = i - 1; ~j; j--)\n\t\t\tif (Arr[j] < Arr[i] && Arr[j] > Max) {\n\t\t\t\tll l = min(cntl[j][i - 1], cntl[i][j + 1]);\n\t\t\t\tll b = min(cntb[j][i - 1], cntb[i][j + 1]);\n\t\t\t\t\n\t\t\t\tdp[i] = min(dp[i], dp[j] + l * L + b * R);\n\t\t\t\tMax = Arr[j];\n\t\t\t}\n\t}\n\t\n\tind = -1;\n\tfor (ll i = n - 1; ~i; i--) {\n\t\tif (Arr[i] > ind) {\n\t\t\tans = min(ans, dp[i] + cntl[i][n - 1] * L);\n\t\t\tind = Arr[i];\n\t\t}\n\t}\n\t\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nint main() {\n    int n;\n    ll a, b;\n    cin >> n >> a >> b;\n    VL p(n), pos(n);\n    REP(i,n){\n        p[i] = n - in();\n        pos[p[i]] = i;\n    }\n\n    VL dp(n + 1, 1e4);\n    dp[0] = 0;\n    BIT bit(n);\n    REP(i,n-1){\n        bit.add(pos[i], 1);\n        if (bit.sum(pos[i + 1]) == 0) dp[i + 1] = min(dp[i + 1], dp[i]);\n        ll x = 1e18, cc = bit.sum(pos[i + 1]);\n        FOR(j,i+1,n-1){\n            if (pos[j] > x || bit.sum(pos[j]) != cc) break;\n            x = pos[j];\n            dp[j] = min(dp[j], dp[i] + (j - i) * b);\n            dp[j] = min(dp[j], dp[i] + cc * a);\n        }\n        dp[i + 1] = min(dp[i + 1], dp[i] + a * bit.sum(pos[i + 1]));\n    // REP(i,n) cout << dp[i] << \" \";\n    // cout << endl;\n    }\n\n    cout << dp[n - 1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\nusing namespace std;\nconst int maxN = 5000;\nint N, arr[maxN], sf[maxN], sb[maxN];\nlong long A, B, dptable[maxN][maxN];\nlong long dp(int l, int r) {\n\tif (dptable[l][r] != -1) return dptable[l][r];\n\tif (l == r) return dptable[l][r] = 0;\n\treturn dptable[l][r] = min(dp(l + 1, r) + (sf[l] > r ? 0 : B), dp(l, r - 1) + (sb[r] < l ? 0 : A));\n}\nint main() {\n\tmemset(dptable, -1, sizeof dptable);\n\tscanf(\"%d %lld %lld\", &N, &A, &B);\n\tfor (int i = 0; i < N; ++i) scanf(\"%d\", &arr[i]), --arr[i];\n\tfor (int i = 0; i < N; ++i) {\n\t\tsf[arr[i]] = N;\n\t\tsb[arr[i]] = -1;\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (arr[j] > arr[i]) sf[arr[i]] = min(sf[arr[i]], arr[j]);\n\t\t}\n\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\tif (arr[j] < arr[i]) sb[arr[i]] = max(sb[arr[i]], arr[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\", dp(0, N - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 5005\nlong long dp[N][N];\nint n,a,b,p[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)dp[i][j]=1e17;\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tlong long mn=1e18;\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tlong long tp=mn;\n\t\t\tif(p[i]>j)tp+=a;\n\t\t\tif(p[i]<j)tp+=b;\n\t\t\tif(dp[i][j]>tp)dp[i][j]=tp;\n\t\t\tif(mn>dp[i-1][j])mn=dp[i-1][j];\n\t\t\ttp=mn;\n\t\t\tif(p[i]>j)tp+=a;else tp+=b;\n\t\t\tif(dp[i][j]>tp)dp[i][j]=tp;\n\t\t}\n\t}\n\tlong long as=1e18;\n\tfor(int i=0;i<=n;i++)if(as>dp[n][i])as=dp[n][i];\n\tprintf(\"%lld\\n\",as);\n}//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 5010;\nint f[N], a[N], n, va, vb, mn[N][N];\nsigned main() {\n    scanf(\"%lld%lld%lld\", &n, &va, &vb);\n    for (int i = 1; i <= n; ++i) scanf(\"%lld\", a + i);\n    if (va > vb) {\n        swap(va, vb);\n        reverse(a + 1, a + n + 1);\n        for (int i = 1; i <= n; ++i) a[i] = n - a[i] + 1;\n    }\n    ++n; a[n] = n;\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j)\n            mn[i][j] = mn[i][j - 1] + bool(a[j] < a[i]);\n    for (int i = 1; i <= n; ++i) {\n        f[i] = 1e15;\n        for (int j = i - 1; ~j; --j) if (a[j] < a[i])\n            f[i] = min(f[i], f[j] + mn[j][i] * vb + (i - j - 1 - mn[j][i]) * va);\n    }\n    printf(\"%lld\\n\", f[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 5e3 + 10;\n\nint N, P[MAX_N], pre2d[MAX_N][MAX_N];\nll A, B, F[MAX_N];\n\nint count(int x1, int x2, int y1, int y2) {\n    return pre2d[x2][y2] - pre2d[x2][y1 - 1] - pre2d[x1 - 1][y2] + pre2d[x1 - 1][y1 - 1];\n}\n\nint main() {\n    scanf(\"%d%lld%lld\", &N, &A, &B);\n    for (int i = 1; i <= N; i++) scanf(\"%d\", &P[i]);\n    P[0] = 0; P[N + 1] = N + 1;\n    for (int i = 1; i <= N; i++) {\n        pre2d[i][P[i]] = 1;\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) pre2d[i][j] += pre2d[i][j - 1];\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) pre2d[i][j] += pre2d[i - 1][j];\n    }\n    for (int i = 1; i <= N + 1; i++) {\n        F[i] = LLONG_MAX;\n        for (int j = 0; j < i; j++) {\n            if (P[j] > P[i]) continue;\n            ll v = F[j];\n            int tot = i - j - 1, heavy;\n            if (A >= B) {\n                heavy = count(j + 1, i - 1, i, N);\n            } else {\n                heavy = count(j + 1, i - 1, 1, j);\n            }\n            v += max(A, B) * heavy + min(A, B) * (tot - heavy);\n            F[i] = min(F[i], v);\n        }\n    }\n    printf(\"%lld\\n\", F[N + 1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,p[5010];\nlong long dp[5010],Val;\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<=n+1;++i){\n\t\ti<=n?scanf(\"%d\",&p[i]):p[i]=n+1,dp[i]=1e18,Val=0;\n\t\tfor(int j=i-1;j>=0;--j){\n\t\t\tif(p[j]<p[i])dp[i]=min(dp[i],dp[j]+Val);\n\t\t\tVal+=(p[j]>p[i]?a:b);\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[n+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> A\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst LL INF = 9187201950435737471;\n\nint N; int a[MAXN+1],pos[MAXN+1];\nLL f[5010][5010]; LL A,B;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); A=read(),B=read();\n\tmemset(f,127,sizeof(f)); \n\tfor(int i=1;i<=N;i++) a[i]=read(),pos[a[i]]=i;\n\tf[0][0]=0; LL ans=INF;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(f[i][j]==INF) continue;\n\t\t\tf[i][j+1]=min(f[i][j+1],(pos[j+1]<=i?0:B)+f[i][j]);\n\t\t}\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(f[i][j]==INF) continue;\n\t\t\tif(j+1==a[i+1]){\n\t\t\t\tf[i+1][j+1]=min(f[i][j],f[i+1][j+1]);\n\t\t\t} else if(j<a[i+1]){\n\t\t\t\tf[i+1][j]=min(f[i][j]+A,f[i+1][j]);\n\t\t\t} else{\n\t\t\t\tf[i+1][j]=min(f[i][j],f[i+1][j]);\n\t\t\t}\n\t\t} \n\t} for(int i=0;i<=N;i++) ans=min(ans,f[N][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n#define int long long\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nint A, B;\n\nsigned main() {\n\tscan n, A, B;\n\tvector<int> p(n);\n\tscan p;\n\tapply(p, x--);\n\tvector<int> at(n);\n\tf(i, n) {\n\t\tat[p[i]] = i;\n\t}\n\n\tvector<vector<int>> dp(n, vector<int>(n, 1e18));\n\tvector<vector<int>> less(n, vector<int>(n, 0));\n\tvector<vector<int>> greater(n, vector<int>(n, 0));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tless[i][j] = less[i][j - 1] + (p[j] < p[i]);\n\t\t}\n\t}\n\tfor (int j = 0; j < n; j++) {\n\t\tfor (int i = j - 1; i > -1; i--) {\n\t\t\tgreater[i][j] = greater[i + 1][j] + (p[i] > p[j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i][i] = 0;\n\t}\n\tfor (int l = 2; l <= n; l++) {\n\t\tfor (int i = 0; i + l <= n; i++) {\n\t\t\tint j = i + l - 1;\n\t\t\t// int _min = *min_element(p.begin() + i, p.begin() + j + 1);\n\t\t\t// int _max = *max_element(p.begin() + i, p.begin() + j + 1);\n\t\t\t// int less = 0, greater = 0;\n\t\t\t// for (int k = i; k <= j; k++) {\n\t\t\t\t// less += (p[k] < p[i]);\n\t\t\t\t// greater += (p[k] > p[j]);\n\t\t\t// }\n\t\t\t{\n\t\t\t\tint w = A;\n\t\t\t\tw = min(w, less[i][j] * B);\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i + 1][j] + w);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint w = B;\n\t\t\t\tw = min(w, greater[i][j] * A);\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][j - 1] + w);\n\t\t\t}\n\t\t}\n\t}\n\tprint dp[0][n - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing LL = long long;\n\nint n, a, b;\nLL dp[5005][5005];\nint arr[5005], pos[5005], cnt[5005];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", arr + i);\n\t\tpos[arr[i]] = i;\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tfor (int i = 0; i <= n; ++i) dp[0][i] = dp[i][0] = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = arr[i] + 1; j <= n; ++j)\n\t\t\tif (pos[j] < i) ++cnt[j];\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (pos[j] <= i) {\n\t\t\t\tif (cnt[j] == 0)\n\t\t\t\t\tdp[i][j] = dp[i][j - 1];\n\t\t\t\telse\n\t\t\t\t\tdp[i][j] = min(dp[i][j - 1] + a, dp[pos[j] - 1][j] + 1LL * b * cnt[j]);\n\t\t\t} else {\n\t\t\t\tdp[i][j] = dp[i][j - 1];\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL>PL;\nconst LL INF=1e18;\nLL N,A,B,i,j;\nLL R[12345],dp[12345];\nLL pa[12345];\nLL mini;\nbool chk[12345];\nvector<LL>V[12345];\nLL cnt;\nLL D,ans;\nstruct fenwick\n{\n    LL data[12345];\n    inline void clear()\n    {\n        for(LL i=0;i<12345;i++)\n            data[i]=0;\n        return;\n    }\n    inline void FI(LL i,LL x)\n    {\n        for(i++;i<12345;i+=i&-i)\n            data[i]+=x;\n        return;\n    }\n    inline LL FS(LL i)\n    {\n        LL ret=0;\n        for(i++;i>0;i=i&i-1)\n            ret+=data[i];\n        return ret;\n    }\n}FT;\nLL t;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>N>>A>>B;\n    for(i=0;i<N;i++)\n    {\n        cin>>R[i];\n        dp[i]=1;\n        pa[i]=-1;\n        for(j=0;j<i;j++)\n        {\n            if(dp[j]+1>=dp[i]&&R[i]>R[j])\n            {\n                dp[i]=dp[j]+1;\n                pa[i]=j;\n            }\n        }\n    }\n    for(i=N;i-->0;)\n    {\n        if(!chk[i])\n        {\n            j=i;\n            while(j!=-1)\n            {\n                V[cnt].push_back(j);\n                chk[j]=true;\n                j=pa[j];\n            }\n            cnt++;\n        }\n    }\n    ans=INF;\n    for(i=0;i<cnt;i++)\n    {\n        for(j=0;j<N;j++)\n            chk[j]=false;\n        for(j=0;j<V[i].size();j++)\n            chk[V[i][j]]=true;\n        mini=-1;\n        D=0;\n        FT.clear();\n        for(j=0;j<N;j++)\n            if(chk[j])\n                FT.FI(j,1);\n        for(j=0;j<N;j++)\n        {\n            if(chk[j])\n            {\n                mini=R[j];\n                continue;\n            }\n            else if(mini>R[j])\n            {\n                t=FT.FS(i);\n                D+=min(t*A,B);\n            }\n            else\n            {\n                t=FT.FS(8192)-FT.FS(i);\n                D+=min(t*B,A);\n            }\n        }\n        ans=min(ans,D);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=5100;\nint n,A,B,p[N],mx[N][N],mn[N][N];\nll dp[N][N],inf;\nlong long dfs(int l,int r)\n{\n\tlong long &v=dp[l][r];\n\tif(v!=inf) return v;\n\tif(l==r) return v=0;\n\tif(p[l]<mn[l+1][r]) v=min(v,dfs(l+1,r));\n\telse v=min(v,dfs(l+1,r)+A);\n\tif(p[r]>mx[l][r-1]) v=min(v,dfs(l,r-1));\n\telse v=min(v,dfs(l,r-1)+B);\n\tfor(int i=l;i<r;i++)\n\t\tif(mx[l][i]<mn[i+1][r])\n\t\t\tv=min(v,dfs(l,i)+dfs(i+1,r));\n//\tprintf(\"dp[%d][%d]=%lld\\n\",l,r,dp[l][r]);\n\treturn v;\n}\nvoid Min(ll &a,ll b) {if(b<a) a=b;} \nint main()\n{\n\tcin>>n>>A>>B;\n\tmemset(dp,63,sizeof(dp));inf=dp[0][0];\n\tfor(int i=1;i<=n;i++) cin>>p[i];\n\tfor(int l=1;l<=n;l++)\n\t{\n\t\tmx[l][l]=mn[l][l]=p[l];\n\t\tfor(int r=l+1;r<=n;r++)\n\t\t{\n\t\t\tmx[l][r]=max(mx[l][r-1],p[r]);\n\t\t\tmn[l][r]=min(mn[l][r-1],p[r]);\n\t\t}\n\t}\n//\tcout<<dfs(1,n)<<endl;\n\tfor(int i=1;i<=n;i++) dp[i][i]=0;\n\tfor(int len=1;len<=n;len++)\n\t{\n\t\tfor(int l=1;l<=n-len+1;l++)\n\t\t{\n\t\t\tint r=l+len-1;\n\t\t\tll &v=dp[l][r];\n\t\t\tif(v==inf) continue;\n//\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",l,r,v);\n\t\t\tif(r<n)\tMin(dp[l][r+1],v+(mx[l][r]<p[r+1]?0:B));\n\t\t\tif(l>1)\tMin(dp[l-1][r],v+(mn[l][r]>p[l-1]?0:A));\n\n\t\t\tint L=1,R=min(n-r,len-1),p=0;\n\t\t\twhile(L<=R)\n\t\t\t{\n\t\t\t\tint mid=(L+R)>>1;\n\t\t\t\tif(mn[r+1][r+mid]>mx[l][r]) L=mid+1,p=mid;\n\t\t\t\telse R=mid-1;\n\t\t\t}\n//\t\t\tif(l==1&&r==7) printf(\"p=%d\\n\",p);\n\t\t\tif(p) Min(dp[l][r+p],dp[l][r]+dp[r+1][r+p]);\n\n\t\t\tL=1,R=min(l-1,len),p=0;\n\t\t\twhile(L<=R)\n\t\t\t{\n\t\t\t\tint mid=(L+R)>>1;\n\t\t\t\tif(mx[l-mid][l-1]<mn[l][r]) L=mid+1,p=mid;\n\t\t\t\telse R=mid-1;\n\t\t\t}\n\t\t\tif(p) Min(dp[l-p][r],dp[l-p][l-1]+dp[l][r]);\n\t\t}\n\t}\n\tcout<<dp[1][n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n;\nll a,b;\nint t[5010];\nll dp[5010][5010];\nint pos[5010];\n\nvoid solve(){\n  cin >> n >> a >> b;\n  vector<P> v;\n  rep(i,n){\n    cin >> t[i];\n    t[i]-=1;\n    pos[t[i]]=i;\n  }\n  \n  rep(i,n+1){\n    rep(j,n+1){\n      dp[i][j]=INF;\n    }\n  }\n  dp[0][0]=0;\n  rep(i,n+1){\n    rep(x,n+1){\n      if(pos[i]>=x)dp[i+1][x]=min(dp[i+1][x],dp[i][x]+b);\n      else dp[i+1][x]=min(dp[i+1][x],dp[i][x]+a);\n      if(t[x]==i)dp[i+1][x+1]=min(dp[i+1][x+1],dp[i][x]);\n      dp[i][x+1]=min(dp[i][x+1],dp[i][x]);\n    }\n  }\n  rep(i,n+1){\n    rep(j,n+1){\n      //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n    }\n  }\n  cout << dp[n][n] << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,A,B,i,j,ans,l,r,f[5010],mx,a[5010];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&A,&B);\n\tans=1e18;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i]);mx=0;\n\t\tf[i]=1e18;l=r=0;\n\t\tfor(j=i-1;j;j--){\n\t\t\tif(a[j]<a[i]&&a[j]>mx)f[i]=min(f[i],f[j]+l*B+r*A);\n\t\t\tif(a[j]>a[i])r++;\n\t\t\t else l++,mx=max(mx,a[j]);\n\t\t}\n\t\tif(mx==0)f[i]=r*A;\n\t\tfor(j=i+1;j<=n;j++)mx=max(mx,a[j]);\n\t\tif(mx<a[i])ans=min(ans,f[i]+B*(n-i));\n\t\t//printf(\"%lld\\n\",f[i]);\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';n?-x:x;})\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r){return l+rng()%(r-l+1);}\n#define fasty ios_base::sync_with_stdio(0),cin.tie(0);\n#define forinc(a,b,c) for(int a=b,_c=c;a<=_c;++a)\n#define fordec(a,b,c) for(int a=b,_c=c;a>=_c;--a)\n#define forv(a,b) for(auto&a:b)\n#define fi first\n#define se second\n#define pb push_back\n#define ii pair<int,int>\n#define mt make_tuple\n#define all(a) a.begin(),a.end()\n#define reset(f, x) memset(f, x, sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define on(x,i) (x|(1ll<<(i-1)))\n#define off(x,i) (x&~(1<<(i-1)))\n#define gg exit(0);\n\nconst int N=5010;\n\nint n,a,b;\nint p[N],f[N];\n\nmain(){\n    #define task \"Rotation\"\n    //freopen(task\".inp\",\"r\",stdin);\n    //freopen(task\".out\",\"w\",stdout);\n\n    n=in,a=in,b=in;\n    forinc(i,1,n) p[i]=in;\n    p[n+1]=n+1, n++;\n    reset(f,127);\n    f[0]=0;\n    forinc(i,1,n){\n        int cntx=0,cnty=0;\n        fordec(j,i-1,0){\n            if(p[j]<p[i]) f[i]=min(f[i],f[j]+cntx*b+cnty*a);\n            if(p[j]<p[i]) cntx++; else cnty++;\n        }\n    }\n    cout<<f[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 5050;\nconst Int INF = 1e17;\nInt dp[MAX][MAX];\nInt p[MAX];\nsigned main(){\n  Int n,a,b;\n  cin>>n>>a>>b;\n  for(Int i=0;i<n;i++) cin>>p[i];\n  \n  for(Int i=0;i<MAX;i++)\n    for(Int j=0;j<MAX;j++)\n      dp[i][j]=INF;\n\n  dp[0][n+1]=0;\n  for(Int w=n+1;w>0;w--){\n    for(Int i=0;i+w<=n+1;i++){      \n      Int j=i+w;\n      // use b\n      {\n        Int cnt=0;\n        for(Int k=0;k<n;k++){\n          if(p[k]==i+1) break;\n          if(p[k]<=i) continue;\n          if(p[k]>=j) continue;\n          cnt++;\n        }\n        chmin(dp[i+1][j],dp[i][j]+(cnt==0?0:b));\n      }\n      //use a      \n      {\n        Int cnt=0;\n        for(Int k=n-1;k>=0;k--){\n          if(p[k]==j-1) break;\n          if(p[k]<=i) continue;\n          if(p[k]>=j) continue;\n          cnt++;\n        }\n        chmin(dp[i][j-1],dp[i][j]+(cnt==0?0:a));\n      }\n    }\n  }\n  \n  Int ans=INF;\n  for(Int i=0;i<n;i++) chmin(ans,dp[i][i+1]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// khodaya khodet komak kon\n#include <bits/stdc++.h>\n#define pb push_back\n#define ers erase\n#define ins insert\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\n#define kill(x) return cout << x, 0;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<pll> vpl;\n\nconst ld Pi = 3.14159265359;\nconst ll MOD = 1000 * 1000 * 1000 + 7;\nconst ll N = 5e3 + 10;\nconst ll INF = 1e18;\nconst ll LOG = 20;\n\nll Place[N][N], a[N], n, A, B;/*Place[i][j] = where is the maximum number in first i element and max <= j*/\nll dp[N][N];/*dp[i][j] = int the first i element answer for the numbers who ai <= j*/\nll inv[N][N];\n\n\nint main(){\n\tIOS;\n\tcin >> n >> A >> B;\n\tfor (int i = 1; i<= n; i++){\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = i + 1; j <= n; j++){\n\t\t\tinv[i][j] = inv[i][j - 1];\n\t\t\tif (a[i] > a[j]) inv[i][j] ++;\n\t\t}\n\t}\n\t\n\t\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tPlace[i][j] = Place[i - 1][j];\n\t\t\tif (a[i] <= j){\n\t\t\t\tif (a[i] > a[Place[i - 1][j]]){\n\t\t\t\t\tPlace[i][j] = i;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t}\n\t\t\t//cout << i << ' ' << j << ' ' << Place[i][j] << '\\n';\t\t\t\t\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tif (Place[i][j] == 0) continue;\n\t\t\tdp[i][j] = min(dp[i][a[Place[i][j]] - 1] + A, dp[Place[i][j] - 1][j] + inv[Place[i][j]][i] * B);\n\t\t}\n\t}\n\tcout << dp[n][n];\n\t\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n/*\n     ,---,           ___                 ,--,\n    '  .' \\        ,--.'|_             ,--.'|                             ,--,\n   /  ;    '.      |  | :,'            |  | :                           ,--.'|    ,---.        ,---,\n  :  :       \\     :  : ' :            :  : '                 .--.--.   |  |,    '   ,'\\   ,-+-. /  |\n  :  |   /\\   \\  .;__,'  /    ,--.--.  |  ' |     ,--.--.    /  /    '  `--'_   /   /   | ,--.'|'   |\n  |  :  ' ;.   : |  |   |    /       \\ '  | |    /       \\  |  :  /`./  ,' ,'| .   ; ,. :|   |  ,\"' |\n  |  |  ;/  \\   \\:__,'| :   .--.  .-. ||  | :   .--.  .-. | |  :  ;_    '  | | '   | |: :|   | /  | |\n  '  :  | \\  \\ ,'  '  : |__  \\__\\/: . .'  : |__  \\__\\/: . .  \\  \\    `. |  | : '   | .; :|   | |  | |\n  |  |  '  '--'    |  | '.'| ,\" .--.; ||  | '.'| ,\" .--.; |   `----.   \\'  : |_|   :    ||   | |  |/\n  |  :  :          ;  :    ;/  /  ,.  |;  :    ;/  /  ,.  |  /  /`--'  /|  | '.'\\   \\  / |   | |--'\n  |  | ,'          |  ,   /;  :   .'   \\  ,   /;  :   .'   \\'--'.     / ;  :    ;`----'  |   |/\n  `--''             ---`-' |  ,     .-./---`-' |  ,     .-./  `--'---'  |  ,   /         '---'\n                            `--`---'            `--`---'                 ---`-'\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define S second\n#define pb push_back\n#define sz(x) ((int)(x).size())\n\ninline int in(){ int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = 5000 + 100;\nset<int> curr; \n\nint a[N]; \nint p[N];\n\nll dp[N][N];\n\nvoid smin(ll& a, ll b) { \n    a = min(a,b); \n}\n\nint main(){\n    int n; \n    ll A, B;\n    cin >> n >> A >> B;\n\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n        a[i]--; \n        p[a[i]] = i; \n    }\n    memset(dp, 63, sizeof dp); \n\n    for(int i = n-1; i >= 0; i--) { \n        dp[i][i+1] = 0;\n        curr.clear(); \n        curr.insert( p[i] ); \n        for(int j = i+2; j <= n; j++) {\n            curr.insert( p[j-1] ); \n\n            auto f = curr.find(p[i]); \n            auto s = curr.find(p[j-1]); \n\n            if( f == curr.begin() ) \n                smin(dp[i][j], dp[i+1][j]); \n            auto ss = s; ss++; \n            if( ss == curr.end() ) \n                smin(dp[i][j], dp[i][j-1]); \n\n            smin(dp[i][j], dp[i+1][j] + B);\n            smin(dp[i][j], dp[i][j-1] + A); \n\n            if( f != curr.begin() ) {\n                f--; \n                if( f == curr.begin() ) \n                    smin(dp[i][j], dp[i+1][j] + A); \n            } \n            if( ss != curr.end() ) {\n                ss++; \n                if( ss == curr.end() ) \n                    smin(dp[i][j], dp[i][j-1] + B); \n            }\n        }\n    }\n\n    cout << dp[0][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nll A, B;\n\nll dp[5010][5010];\nint P[5010];\n\nvoid solve() {\n\tcin >> N >> A >> B;\n\trep(i, 0, N) cin >> P[i];\n\trep(i, 0, N + 1) {\n\t\trep(j, 0, N + 1) {\n\t\t\tdp[i][j] = linf;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\trep(i, 0, N) {\n\t\trep(j, 0, N + 1) {\n\t\t\tif(dp[i][j] == linf) continue;\n\t\t\tif(j < P[i]) {\n\t\t\t\tMIN(dp[i + 1][P[i]], dp[i][j]);\n\t\t\t\tMIN(dp[i + 1][j], dp[i][j] + A);\n\t\t\t}\n\t\t\telse if(P[i] < j) {\n\t\t\t\tMIN(dp[i + 1][j], dp[i][j] + B);\n\t\t\t}\n\t\t}\n\t\t// debug(vl(dp[i + 1], dp[i + 1] + N + 1));\n\t}\n\tll res = linf;\n\trep(j, 0, N + 1) MIN(res, dp[N][j]);\n\tcout << res << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint n;\nconst int maxN = 5005;\nint where[maxN];\nint mn[maxN][maxN];\nint p[maxN];\nint a, b;\nll dp[maxN][maxN];\nconst ll INF = (ll)1e18;\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> a >> b;\n    for (int i = 1; i <= n; i++) {\n        cin >> p[i];\n        where[p[i]] = i;\n    }\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = INF;\n        }\n    }\n    dp[0][0] = 0;\n    ll best = INF;\n    for (int i = 0; i + 1 <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (dp[i][j] == INF) continue;\n            if (p[i + 1] > j) {\n                dp[i + 1][p[i + 1]] = min(dp[i + 1][p[i + 1]], dp[i][j]);\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + a);\n            }\n            else {\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + b);\n            }\n        }\n    }\n    for (int j = 0; j <= n; j++) {\n        best = min(best, dp[n][j]);\n    }\n    cout << best;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T, class S> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T> inline vector<T> cinv2(ll N){\n\tvector<T> v(N); REP(i, N){ll a, b; cin>>a>>b; v[i]={a,b};} return move(v);}\ntemplate<class T,class S,class R> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv3(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c; cin>>a>>b>>c; v[i]={a,b,c};} return move(v);}\ntemplate<class T,class S,class R,class Q> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv4(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c,d; cin>>a>>b>>c>>d; v[i]={a,b,c,d};} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\n\nvoid solve()\n{\n\tll n, a, b;  cin >> n >> a >> b;\n\tvector<ll> p = cinv<ll>(n);\n\tp.insert(p.begin(), -INF);\n\tp.push_back(INF);\n\n\tvll dp(n+2,INF);\n\tauto Dp = [&](ll i)->ll&{\n\t\treturn dp[i];\n\t};\n\tDp(0)=0;\n\n\trep(i, 1, n+1){\n\t\tll mx=-INF-1;\n\t\tll cost=0;\n\t\tdep(j, i-1, 0){\n\t\t\tif (mx<p[j] and p[j]<p[i]){\n\t\t\t\tchmin(Dp(i), Dp(j)+cost);\n\t\t\t}\n\t\t\tif (p[j]>p[i]) cost+=a;\n\t\t\telse cost+=b;\n\t\t\tif (mx<p[j] and p[j]<p[i]) mx=p[j];\n\t\t}\n\t}\n\t//Dump(dp);\n\tcout << Dp(n+1) << '\\n';\n}\n\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\ntypedef pair<LL,int> LP;\nconst LL INF=(LL)1<<50;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *a,int n,char middle=' '){\n\tfor(int i=0;i<n;i++)printf(\"%d%c\",a[i],(i!=n-1?middle:'\\n'));\n}\nvoid array_show(LL *a,int n,char middle=' '){\n\tfor(int i=0;i<n;i++)printf(\"%lld%c\",a[i],(i!=n-1?middle:'\\n'));\n}\nLL dp[5005][5005];\nint t[5005];\n\nint main(){\n\tint a,b,c;\n\tint n;\n\tint i,j,k;\n\tint p,q;\n\tcin>>n;\n\tcin>>p>>q;\n\tfor(i=0;i<n;i++){\n\t\tcin>>t[i];\n\t}\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=n;j++)dp[i][j]=INF;\n\t}\n\tdp[0][0]=0;\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(i==t[j])continue;\n\t\t\tif(i>t[j])dp[i][j+1]=min(dp[i][j+1],dp[i][j]+q);\n\t\t\telse{\n\t\t\t\tdp[i][j+1]=min(dp[i][j+1],dp[i][j]+p);\n\t\t\t\tdp[t[j]][j+1]=min(dp[t[j]][j+1],dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tLL s=INF;\n\tfor(i=0;i<=n;i++){\n\t\ts=min(s,dp[i][n]);\n\t}\n\tcout<<s<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \nconst int N=5005;\nint n,A,B,dp[N][N*2],g[N][N*2],p[N],q[N];\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&A,&B);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&p[i]);\n\tfor (int i=1;i<=n;i++)q[p[i]]=i;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=2*n+1;j++){\n\t\t\tif (j%2==0)dp[i][j]=g[i-1][j-1];\n\t\t\telse dp[i][j]=g[i-1][j];\n\t\t\tif (j<q[i]*2)dp[i][j]+=B;\n\t\t\telse if (j>q[i]*2)dp[i][j]+=A;\n\t\t\tg[i][j]=min(dp[i][j],(j==1?1000000000000000000ll:g[i][j-1]));\n\t\t}\n\tprintf(\"%lld\\n\",g[n][2*n+1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int N;\n    ll A,B;\n    cin >> N >> A >> B;\n    ll inf = 1e18;\n    vector<int> l(N+1,0),p(N+1,0);\n    for(int i=1;i<=N;i++) cin >> p[i];\n    vector<vector<ll>> dp(N+1,vector<ll>(N+1,inf));\n    for(int i=1;i<=N;i++) for(int j=1;j<=N;j++){\n        if(p[j]==i) break;\n        if(p[j]>i) l[i]++;\n    }\n    for(int j=0;j<=N;j++) dp[0][j] = 0;\n    for(int i=1;i<=N;i++) for(int j=0;j<=N;j++){\n        if(j<=l[i]){\n            dp[i][j] = min(dp[i][j],dp[i-1][j]+B);\n            dp[i][l[i]] = min(dp[i][l[i]],dp[i-1][j]);\n        }else dp[i][j-1] = min(dp[i][j-1],dp[i-1][j]+A);\n    }\n    cout << dp[N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i=0; i<(n); i++)\nconst ll INF = 1e15;\nint n, a, b, p;\nll dp[5005], ans = INF;\nint main(){\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\trep(i,n){\n\t\tscanf(\"%d\", &p);\n\t\tll m = INF;\n\t\trep(j,p){\n\t\t\tm = min(m,dp[j]);\n\t\t\tdp[j] += a;\n\t\t}\n\t\tdp[p] = m;\n\t\tfor(int j=p+1; j<=n; j++) dp[j] += b;\n\t}\n\trep(i,n+1) ans = min(ans, dp[i]);\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL A, B;\nint P[5011];\nint R[5011];\nLL dp[5011][5011]; // 200MB\n\nint low[5011];\n\nvoid MAIN() {\n    scanf(\"%d%lld%lld\", &N, &A, &B);\n    REP (i, N) scanf(\"%d\", P+i), P[i]--;\n    REP (i, N) R[P[i]] = i;\n\n    memset(dp, 0x3f, sizeof dp);\n    REP (i, N+1) dp[i][0] = 0;\n\n    for (int i=1; i<=N; i++) {\n\tREP (k, i) if (P[k] > P[i-1]) low[P[k]]++;\n\tfor (int h=1; h<N; h++) {\n\t    if (i-1 <= R[h]) {\n\t\tdp[i][h] = dp[i][h-1];\n\t    } else {\n\t\tamin(dp[i][h], dp[i][h-1] + A);\n\t\tamin(dp[i][h], dp[R[h]][h-1] + low[h] * B);\n\t    }\n\t}\n    }\n\n    printf(\"%lld\\n\", dp[N][N-1]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n#define mod 1000000007\n#define N 5005\nusing namespace std;\n\ntypedef long long ll;\n\nll n, A, B, a[N], dp[N][N], mn[N][N], mx[N][N];\n\nll f(ll bas, ll son){\n\tif(bas == son)\n\t\treturn 0;\n\tll &r = dp[bas][son];\n\tif(r != -1)\n\t\treturn r;\n\tif(a[bas] == mn[bas][son])\n\t\treturn r = f(bas + 1, son);\n\tif(a[son] == mx[bas][son])\n\t\treturn r = f(bas, son - 1);\n\treturn r = min(f(bas + 1, son) + min(A, B*(a[bas] - mn[bas + 1][son]) ), f(bas, son - 1) + min(B, A*(mx[bas][son - 1] - a[son]) ) );\n}\n\nint main() {\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n\n\tmemset(dp, -1, sizeof dp);\n\n\tscanf(\"%lld %lld %lld\",&n ,&A ,&B);\n\tfor(ll i = 1; i <= n; i++)\n\t\tscanf(\"%lld\",a + i);\n\n\tfor(ll i = 1; i <= n; i++){\n\t\tmx[i][i] = mn[i][i] = a[i];\n\t\tfor(ll j = i + 1; j <= n; j++){\n\t\t\tmn[i][j] = min(mn[i][j - 1], a[j]);\n\t\t\tmx[i][j] = max(mx[i][j - 1], a[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f(1, n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 5e3 + 7;\nconst ll inf = 1e18;\nint n, a, b, p[N];\nll f[N][N], ans = inf;\n\nint main() {\n\trd(n, a, b), rda(p, n);\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tf[i][j] = inf;\n\tf[0][0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tif (p[i] > j)\n\t\t\t\tf[i][j] = min(f[i][j], f[i-1][j] + a),\n\t\t\t\tf[i][p[i]] = min(f[i][p[i]], f[i-1][j]);\n\t\t\telse f[i][j] = min(f[i][j], f[i-1][j] + b);\n\tfor (int i = 0; i <= n; i++) ans = min(ans, f[n][i]);\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define nmax 5000\nusing namespace std;\nint n, mx[nmax+1], mn[nmax+1], a, b, p[nmax+1];\nlong long dp[nmax+2][nmax+2];\nint main()\n{\n    std::ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> a >> b;\n    for(int i = 1; i <= n; ++i)\n      cin >> p[i];\n    for(int i = 1; i <= n; ++i){\n      mn[p[i]] = n + 1;\n      for(int j = 1; j < i; ++j)\n        if(p[j] > p[i] && mn[p[i]] > p[j]) mn[p[i]] = p[j];\n    }\n    for(int i = n; i >= 1; --i){\n      mx[p[i]] = 0;\n      for(int j = n; j > i; --j)\n        if(p[j] < p[i] && mx[p[i]] < p[j]) mx[p[i]] = p[j];\n    }\n    dp[0][n + 1] = 0;\n    for(int j = n; j > 0; --j)\n      dp[0][j] = (mx[j] == 0) ? dp[0][j + 1] : dp[0][j + 1] + a;\n    for(int i = 1; i <= n; ++i){\n      dp[i][n + 1] = (mn[i] == n + 1) ? dp[i - 1][n + 1] : dp[i - 1][n + 1] + b;\n      for(int j = n; j > i; --j){\n        dp[i][j] = (mn[i] >= j) ? dp[i - 1][j] : dp[i - 1][j] + b;\n        dp[i][j] = min(dp[i][j], ((mx[j] <= i) ? dp[i][j + 1] : dp[i][j + 1] + a));\n      }\n    }\n    long long ans = dp[0][1];\n    for(int i = 0; i <= n; ++i)\n      ans = min(ans, dp[i][i + 1]);\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 5e3 + 10;\nconst long long max_val = 1LL << 62;\n\nlong long dp[maxn][maxn * 2];\nint p[maxn];\n\nlong long cost(int p1, int p2, int A, int B) {\n    if (p1 == p2) return 0;\n    else if (p1 > p2) return B;\n    else return A;\n}\n\nint main()\n{\n    int N, A, B, x;\n    cin >> N >> A >> B;\n    for (int i = 1; i <= N; i++) {\n        cin >> x;\n        p[x] = 2 * i - 1;\n    }\n    for (int i = 1; i <= N; i++) for (int j = 0; j <= 2 * N; j++) dp[i][j] = max_val;\n    //dp[i][j] = min{dp[i - 1][k] + (p[i] != k) * (A | B)}\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j <= 2 * N; j++) {\n            int tail = (j % 2 == 0 ? j + 1 : j);\n            if (i == 1)\n                tail = 2 * N;\n            for (int k = 0; k < tail; k++) {\n                //cout << j << ' ' << k << ' ' << dp[i - 1][k] << ' ' << cost(p[i], k, A, B) << endl;\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + cost(p[i], j, A, B));\n            }\n            //cout << i << ' ' << j << ' ' << dp[i][j] << endl;\n        }\n    }\n    long long res = max_val;\n    for (int j = 0; j <= 2 * N; j++) res = min(res, dp[N][j]);\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 5005;\n\nll n, a, b, x, y;\n\nint ara[MAX];\nll dp[MAX][MAX];\nint rngmx[MAX][MAX], rngmn[MAX][MAX];\nint boro[MAX][MAX], choto[MAX][MAX];\n\n\nll fnc(ll beg, ll ed){\n    if(beg == ed) return 0;\n    \n    if(dp[beg][ed] != -1) return dp[beg][ed];\n    \n    ll cc = 0;\n    if(rngmn[beg + 1][ed] < ara[beg]) cc = a;\n    \n    ll re1 = fnc(beg + 1, ed) + cc;\n    ll re3 = fnc(beg + 1, ed) + choto[beg+1][ed] * b;\n    re1 = min(re1,re3);\n    \n    cc = 0;\n    if(rngmx[beg][ed - 1] > ara[ed]) cc = b;\n    \n    ll re2 = fnc(beg, ed - 1) + cc;\n    ll re4 = fnc(beg,ed-1) + boro[beg][ed-1] * a;\n    re2 = min(re2,re4);\n    \n    return dp[beg][ed] = min(re1, re2);\n}\n\nint BIT[MAX];\nvoid update(int indx, int val){\n    while(indx<MAX){\n        BIT[indx]+=val;\n        indx+=(indx&-indx);\n    }\n}\n\nint sum(int indx){\n    ll ans=0;\n    while(indx!=0){\n        ans+=BIT[indx];\n        indx-=(indx&-indx);\n    }\n    return ans;\n}\n\nint main(){\n    cin >> n >> a >> b;\n    for(ll i = 1; i <= n; i++) scanf(\"%d\", &ara[i]);\n    \n    memset(dp, -1, sizeof(dp));\n    \n    for(int i = 1; i <= n; i++){\n        int mx = ara[i], mn = ara[i];\n        for(int j = i; j <= n; j++){\n            mx = max(mx, ara[j]);\n            mn = min(mn, ara[j]);\n            rngmx[i][j] = mx;\n            rngmn[i][j] = mn;\n            \n            update(ara[j],1);\n            boro[i][j] = j - i + 1 - sum(ara[j+1]);\n            choto[i][j] = sum(ara[i-1]);\n        }\n        \n        for(int j = i; j <= n; j++) update(ara[j],-1);\n    }\n    \n    ll ans = fnc(1, n);\n    \n    cout << ans << endl;\n    \n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\ntypedef long long LL;\n\nstruct Edge {\n  int u, v;\n  LL cap, flow;\n  Edge() {}\n  Edge(int u, int v, LL cap): u(u), v(v), cap(cap), flow(0) {}\n};\n\nstruct Dinic {\n  int N;\n  vector<Edge> E;\n  vector<vector<int>> g;\n  vector<int> d, pt;\n  \n  Dinic(int N): N(N), E(0), g(N), d(N), pt(N) {}\n\n  void AddEdge(int u, int v, LL cap) {\n    if (u != v) {\n      E.emplace_back(Edge(u, v, cap));\n      g[u].emplace_back(E.size() - 1);\n      E.emplace_back(Edge(v, u, 0));\n      g[v].emplace_back(E.size() - 1);\n    }\n  }\n\n  bool BFS(int S, int T) {\n    queue<int> q({S});\n    fill(d.begin(), d.end(), N + 1);\n    d[S] = 0;\n    while(!q.empty()) {\n      int u = q.front(); q.pop();\n      if (u == T) break;\n      for (int k: g[u]) {\n        Edge &e = E[k];\n        if (e.flow < e.cap && d[e.v] > d[e.u] + 1) {\n          d[e.v] = d[e.u] + 1;\n          q.emplace(e.v);\n        }\n      }\n    }\n    return d[T] != N + 1;\n  }\n\n  LL DFS(int u, int T, LL flow = -1) {\n    if (u == T || flow == 0) return flow;\n    for (int &i = pt[u]; i < g[u].size(); ++i) {\n      Edge &e = E[g[u][i]];\n      Edge &oe = E[g[u][i]^1];\n      if (d[e.v] == d[e.u] + 1) {\n        LL amt = e.cap - e.flow;\n        if (flow != -1 && amt > flow) amt = flow;\n        if (LL pushed = DFS(e.v, T, amt)) {\n          e.flow += pushed;\n          oe.flow -= pushed;\n          return pushed;\n        }\n      }\n    }\n    return 0;\n  }\n\n  LL MaxFlow(int S, int T) {\n    LL total = 0;\n    while (BFS(S, T)) {\n      fill(pt.begin(), pt.end(), 0);\n      while (LL flow = DFS(S, T))\n        total += flow;\n    }\n    return total;\n  }\n};\n\nconst int N = 5e3 + 10;\nconst ll inf = 1e15 + 42;\n\nint p[N];\n\nint main() {\n\tfast_cin();\n\tint n; ll a, b;\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> p[i];\n\t}\n\tDinic dinic(2 * n + 2);\n\tint source = 0, sink = 2 * n + 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdinic.AddEdge(source, i, a);\n\t\tdinic.AddEdge(i + n, sink, b);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tif (p[i] > p[j]) {\n\t\t\t\tdinic.AddEdge(i, j + n, inf);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dinic.MaxFlow(source, sink) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nusing ll = long long;\n\nconst int nax = 5005;\nconst ll INF = 1e18L + 5;\nint A, B;\nint p[nax], inv[nax];\nll dp[nax][nax];\n\nint memo[nax];\n\nint main() {\n    int n;\n    scanf(\"%d%d%d\", &n, &A, &B);\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &p[i]);\n      --p[i];\n      inv[p[i]] = i;\n    }\n    for(int value = n - 1; value >= 0; --value) {\n      int cnt = 0;\n      for(int pos = n - 1; pos >= 0; --pos) {\n        if(p[pos] >= value) {\n          ++cnt;\n        }\n        memo[pos] = cnt;\n        if(pos != n - 1) {\n          debug() << imie(value) imie(pos+1) imie(dp[value][pos+1]);\n        }\n        ll& me = dp[value][pos];\n        me = INF;\n        if(inv[value] < pos) {\n          me = dp[value+1][pos];\n          continue;\n        }\n        if(p[pos] < value) {\n          me = dp[value][pos+1];\n          continue;\n        }\n        if(p[pos] == value) {\n          me = dp[value+1][pos+1];\n          continue;\n        }\n        int where = inv[value];\n        assert(where > pos);\n        me = min(dp[value+1][pos] + B, dp[value+1][where+1] + (ll) A * (cnt - memo[where]));\n      }\n    }\n    printf(\"%lld\\n\", dp[0][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//constexpr long long MOD = 1000000007;\nconstexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nll dp[5050][5050];\nint L[5050][5050],R[5050][5050];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll N,A,B; cin >> N >> A >> B;\n    vector<int> p(N);\n    rep(i,N) {\n        cin >> p[i];\n        --p[i];\n    }\n\n    rep(i,N) rep(j,N-i) {\n        L[i][j] = -1;\n        R[i][j] = -1;\n    }\n    rep(i,N) {\n        L[p[i]][N-1-p[i]] = p[i];\n        int y = N-1-p[i]-1;\n        while (y >= 0 and L[p[i]][y]==-1) {\n            L[p[i]][y] = p[i];\n            y--;\n        }\n        int x = p[i]-1;\n        while (x >= 0 and L[x][N-1-p[i]]==-1) {\n            L[x][N-1-p[i]] = p[i];\n            x--;\n        }\n    }\n    for (int i = N-1; i >= 0; i--) {\n        R[p[i]][N-1-p[i]] = p[i];\n        int y = N-1-p[i]-1;\n        while (y >= 0 and R[p[i]][y]==-1) {\n            R[p[i]][y] = p[i];\n            y--;\n        }\n        int x = p[i]-1;\n        while (x >= 0 and R[x][N-1-p[i]]==-1) {\n            R[x][N-1-p[i]] = p[i];\n            x--;\n        }\n    }\n\n    rep(i,N+1) rep(j,N+1-i) dp[i][j] = 1e18;\n    dp[0][0] = 0;\n    rep(k,N) {\n        rep(i,k+1) {\n            if (L[i][k-i]==i) {\n                chmin(dp[i+1][k-i],dp[i][k-i]);\n            } else {\n                chmin(dp[i+1][k-i],dp[i][k-i]+B);\n            }\n            if (R[i][k-i]==N-1-(k-i)) {\n                chmin(dp[i][k-i+1],dp[i][k-i]);\n            } else {\n                chmin(dp[i][k-i+1],dp[i][k-i]+A);\n            }\n        }\n    }\n\n    ll ans = 1e18;\n    rep(i,N+1) chmin(ans,dp[i][N-i]);\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 5005\n#define INF 10000000000000LL\nusing namespace std;\nint n,A,B,p[N],pos[N],cnt[N][N];\nlong long f[N][N];\nint main(){\n    scanf(\"%d%d%d\",&n,&A,&B);\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",&p[i]);\n        pos[p[i]]=i;\n    }\n    for(int i=n;i;--i)\n        for(int j=1;j<=n;++j)\n            if(pos[j]>=i)cnt[i][j]=cnt[i+1][j]+(j<=p[i]);\n    for(int j=n;j;--j)\n        for(int i=n;i;--i)\n            if(!cnt[i][j])f[i][j]=f[i][j+1];\n            else{\n                f[i][j]=min(f[i][j+1]+B,f[pos[j]+1][j+1]+1LL*A*(cnt[i][j]-1));\n                //printf(\"cnt=%d f[%d][%d]=\",cnt[i][j]-1,i,j),cout<<f[i][j]<<endl;\n            }\n    cout<<f[1][1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, p[5005], A, B, dp[5005][5005];\nll pos[5005];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; ++i){\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 1; i <= N; ++i){\n\t\tpos[p[i]] = i;\n\t} \n\tfor (int i = 1; i <= N+1; ++i){\n\t\tif (i < pos[1]) dp[1][i] = A;\n\t\telse if (i > pos[1]) dp[1][i] = B;\n\t\telse dp[1][i] = 0;\n\t} \n\tfor (int i = 2; i <= N; ++i){\n\t\tdeque<pair<ll,int> > f;\n\t\tfor (int j = 1; j <= N+1; ++j){\n\t\t\twhile (!f.empty() && f.back().first > dp[i-1][j]){\n\t\t\t\tf.pop_back();\n\t\t\t}\n\t\t\tf.push_back(make_pair(dp[i-1][j],j));\n\t\t\tif (j == pos[i]) dp[i][j] = dp[i-1][j];\n\t\t\telse dp[i][j] = 1e16;\n\t\t\tif (!f.empty()){\n\t\t\t\tif (j > pos[i]) dp[i][j] = min(dp[i][j],B+f.front().first);\n\t\t\t\telse if (j < pos[i]) dp[i][j] = min(dp[i][j],A+f.front().first);\n\t\t\t\telse dp[i][j] = min(dp[i][j],f.front().first);\n\t\t\t}\n\t\t\t\n\t\t}\n\t} \n\tfor (int i = 1; i <= N; ++i){\n\t\tfor (int j = 1; j <= N+1; ++j){\n\t\t\t//cout << dp[i][j] << ' ';\n\t\t}\n\t\t//cout << '\\n';\n\t} \n\tll M = 1e16;\n\tfor (int i = 1; i <= N+1; ++i){\n\t\tM = min(M,dp[N][i]);\n\t}\n\tcout << M << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#define N 5001\n#include<bitset>\n#include<deque>\n#include<cstdlib>\n#include<set>\n#include<ctime>\n#define ll long long\n#define mp make_pair\nusing namespace std;\nll read()\n{\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile(c>'9'||c<'0')\n\t{\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\nint n,pos[N],A,B;\nll dp[N][N];\nint main()\n{\n\tn=read(),A=read(),B=read();\n\tmemset(dp,20,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=read();\n\t\tpos[x]=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tll mn=dp[i-1][0];\n\t\tfor(int j=0;j<=n;++j)\n\t\t{\n\t\t\tif(pos[i]==j) dp[i][j]=mn;\n\t\t\tmn=min(mn,dp[i-1][j]);\n\t\t\tdp[i][j]=min(dp[i][j],mn+(j<pos[i]?B:A));\n\t\t}\n\t}\n\tll ans=1e18;\n\tfor(int i=1;i<=n;++i) ans=min(ans,dp[n][i]);\n\tcout<<ans<<'\\n';\n\treturn 0;\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nconst int N = (5e3) + 5;\nint ft[N];\nll memo[N][N];\nint pos[N];\nint n, a[N];\nll A, B;\n\nvoid update(int idx, ll delta) {\n\twhile (idx <= n) {\n\t\tft[idx] += delta;\n\t\tidx += idx & -idx;\n\t}\n}\n\nvoid rangeUpdate(int l, int r, int delta) {\n\tupdate(l, delta); update(r + 1, -delta);\n}\n\nint query(int idx) {\n\tint ret = 0;\n\twhile (idx > 0) {\n\t\tret += ft[idx];\n\t\tidx -= idx & -idx;\n\t}\n\treturn ret;\n}\n\nll DP(int l, int r) {\n\tif (r - l == 1) return 0;\n\tll &ret = memo[l][r];\n\tif (ret != -1) return ret;\n\tll sum1 = 0;\n\tif (pos[l + 1] + query(pos[l + 1]) != l + 1) {\n\t\trangeUpdate(1, pos[l + 1], +1);\n\t\tsum1 = B + DP(l + 1, r);\n\t\trangeUpdate(1, pos[l + 1], -1);\n\t}  else {\n\t\tsum1 = DP(l + 1, r);\n\t}\n\tll sum2 = 0;\n\tif (pos[r - 1] + query(pos[r - 1]) != r - 1) {\n\t\trangeUpdate(pos[r - 1], n, -1);\n\t\tsum2 = A + DP(l, r - 1);\n\t\trangeUpdate(pos[r - 1], n, +1);\n\t} else {\n\t\tsum2 = DP(l, r - 1);\n\t}\n\treturn ret = min(sum1, sum2);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%lld %lld\", &A, &B);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tpos[a[i]] = i;\n\t}\n\tmemset(memo, -1, sizeof memo);\n\tll ans = DP(0, n + 1);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n\nint count(const vi& xs, int min, int max) {\n    auto it = lower_bound(all(xs), min);\n    auto it2 = upper_bound(all(xs), max);\n    return it2 - it;\n}\n\nconst int N = 5050;\n\nll dp[N][N];\nvi toL[N], toR[N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    ll L, R;\n    cin >> n >> L >> R;\n    vi p(n);\n    for (int i=0; i<n; i++) cin >> p[i], p[i]--;\n    for (int i=0; i<n; i++) toL[i].reserve(n), toR[i].reserve(n);\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<i; j++) {\n            toL[p[i]].pb(p[j]);\n        }\n        for (int j=i+1; j<n; j++) {\n            toR[p[i]].pb(p[j]);\n        }\n        sort(all(toL[p[i]]));\n        sort(all(toR[p[i]]));\n    }\n    for (int l=0; l<=n; l++) for (int r=!l; r<=n; r++) {\n        if (l+r>n) continue;\n        dp[l][r] = 1ll << 62;\n        if (l>0) {\n            int dist = count(toL[l-1], l-1, n-r-1);\n            ll cost = min(R, dist*L);\n            dp[l][r] = min(dp[l][r], dp[l-1][r]+cost);\n        }\n        if (r>0) {\n            int dist = count(toR[n-r], l, n-r);\n            ll cost = min(L, dist*R);\n            dp[l][r] = min(dp[l][r], dp[l][r-1]+cost);\n        }\n    }\n    ll ans=1ll<<62;\n    for (int l=0; l<=n; l++)\n        ans = min(ans, dp[l][n-l]);\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 5e3 + 5;\nconst int maxm = 1e7 + 5;\n\nconst int mod = 1e9 + 7;\nint n , A , B;\nint pos[maxn] , a[maxn];\nint m = 0;\nll f[maxn][maxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\"))\n        freopen(taskname\".INP\",\"r\",stdin),\n        freopen(taskname\".OUT\",\"w\",stdout);\n    cin >> n >> A >> B;\n    for(int i = 1 ; i <= n ; ++i){\n        cin >> a[i];\n        pos[a[i]] = i;\n    }\n    memset(f,123,sizeof  f);\n    f[1][0] = 0;\n    ll res = 1e18;\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = 0 ; j < i ; ++j){\n            if(pos[i] > pos[j]){\n                f[i + 1][j] = min(f[i + 1][j] , f[i][j] + B);\n                f[i + 1][i] = min(f[i][j] , f[i + 1][i]);\n            }else{\n                f[i + 1][j] = min(f[i + 1][j] , f[i][j] + A);\n            }\n        }\n    }\n    cout << *min_element(f[n+1],f[n+1]+n+1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll N = 5e3 + 15, inf = 1000000LL * 1000000LL * 10, LOG = 23;\nll n, R, L;\nint Arr[N];\nll dp[N], ans;\nvector <int> vec;\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> R >> L;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> Arr[i];\n\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (vec.size() && Arr[vec.back()] > Arr[i])\n\t\t\tvec.pop_back();\n\n\t\tdp[i] = inf;\n\t\tif (vec.empty())\n\t\t\tdp[i] = R * i;\n\n\t\tint cnt = 0, val = 0;\n\t\tfor (int j = i - 1; ~j; j--) {\n\t\t\tif (Arr[j] < Arr[i])\n\t\t\t\tval = max(val, Arr[j]);\n\n\t\t\tif (Arr[j] < Arr[i] && val == Arr[j])\n\t\t\t\tdp[i] = min(dp[i], dp[j] + L * (i - j - 1 - cnt) + R * cnt);\n\n\t\t\tcnt += (Arr[j] > Arr[i]);\n\t\t}\n\n\t\tvec.push_back(i);\n\t}\n\n\tvec.clear();\n\n\tans = inf;\n\tfor (int i = n - 1; ~i; i--) {\n\t\twhile (vec.size() && Arr[vec.back()] < Arr[i])\n\t\t\tvec.pop_back();\n\n\t\tif (vec.empty())\n\t\t\tans = min(ans, dp[i] + (n - i - 1) * L);\n\n\t\tvec.push_back(i);\n\t}\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\n#define int long long\n\nconst int N = 5e3 + 7;\n\nint dp[N][N];\nint n, a, b;\nint p[N], pnt[N];\n\nint32_t main() {\n\tmakefast;\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> p[i], pnt[p[i]] = i;\n\tset <int> s;\n\ts.insert(0);\n\tfor (int i = n; i >= 1; i--) {\n\t\ts.insert(p[i]);\n\t\tauto it = s.rbegin();\n\t\tint lst = *it;\n\t\tint mn = pnt[lst];\n\t\tint x = lst;\n\t\tint cnt = 0;\n\t\tit++;\n\t\twhile (it != s.rend()) {\n\t\t\t//\tcout << endl << endl << i << \" LST : \" << lst << \" X : \" << x << \" \" << cnt << endl;\n\t\t\tfor (int j = lst; j > *it; j--) {\n\t\t\t\tdp[i][j] = min(dp[mn + 1][lst] + a, dp[mn + 1][x + 1] + b * cnt);\n\t\t\t\t//\t\tcout << i << \" \" << j << \" > \" << dp[i][j] << \" \" << dp[mn + 1][1] + a << \" & \" << dp[mn + 1][x + 1] + b * cnt << endl;\n\t\t\t}\n\t\t\tlst = *it;\n\t\t\tif (lst == 0)\n\t\t\t\tbreak;\n\t\t\tif (pnt[lst] < mn) {\n\t\t\t\tmn = pnt[lst];\n\t\t\t\tx = lst;\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t\telse\t\n\t\t\t\tcnt++;\n\t\t\tit++;\n\t\t}\n\t}\n\tcout << dp[1][1];\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 5e3 + 10;\n\nint n, A, B, p[N];\nll dp[N];\n\nint main() {\n  scanf(\"%d %d %d\", &n, &A, &B);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &p[i]);\n  }\n  p[++n] = n;\n  for (int i = 1; i <= n; i++) {\n    dp[i] = (ll) 1e18;\n    ll tmp = 0;\n    for (int j = i - 1; j >= 0; j--) {\n      if (p[j] < p[i]) {\n        dp[i] = min(dp[i], dp[j] + tmp);\n        tmp += B;\n      } else {\n        tmp += A;\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <chrono>\n#include <vector>\n\nusing namespace std;\nlong long cost[5100][5100];\n\nint main()\n{\n    int n;\n    long long a, b;\n    cin >> n >> a >> b;\n    vector<int> p(n + 2);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> p[i];\n    }\n\n    long long inf = 1e18;\n    p[n + 1] = n + 1;\n    cost[0][0] = 0;\n    for (int i = 1; i <= n + 1; i++)\n    {\n        cost[i][i] = inf;\n        for (int j = 0; j < i; j++)\n        {\n            if (p[i] > p[j])\n            {\n                cost[i][i] = min(cost[i - 1][j], cost[i][i]);\n            }\n            cost[i][j] = cost[i - 1][j] + (p[i] > p[j] ? a : b);\n        }\n    }\n\n    cout << cost[n + 1][n + 1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n\tif (x.size() == 0) { return x; }\n\tsor(x);\n\tint n = x.size();\n\tvel ans(1, x[0]);\n\tfor (int j = 1; j < n; j++) {\n\t\tif (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n\t}\n\tx = ans;\n\treturn x;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nvoid sol(V<string> &t, int i, string u) {\n\tt.push_back(u);\n\tif (i < u.size()) {\n\t\tsol(t, i + 1, u);\n\t\tu[i] = '.';\n\t\tsol(t, i + 1, u);\n\t}\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff,V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans,pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nsigned main() {\n\tomajinai;\n\tint n,a,b; cin >> n>>a>>b;\n\tvel p(1);\n\trep(i, n) { int x; cin >> x; p.push_back(x); }\n\tp.push_back(n + 1);\n\tn += 2;\n\tint inf = (a + b) * n + 1;\n\tvel dp(n, inf); dp[0] = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint mn = n+2;\n\t\tint upp = 0;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (p[j] > p[i]) { \n\t\t\t\tif (p[j] < mn) {\n\t\t\t\t\tmn = p[j];\n\t\t\t\t\tint low = j - i-1 - upp;\n\t\t\t\t\tmmin(dp[j], dp[i] + upp * a + low * b);\n\t\t\t\t}\n\t\t\t\tupp++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp.back() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll N = 5e3 + 15, inf = 1000000LL * 1000000LL * 10, LOG = 13;\nint n, R, L;\nint Arr[N];\nll dp[N], ans;\nint seg[LOG][N];\n\nvoid build (int s = 0, int e = n, int lvl = 0) {\n\tfor (int i = s; i < e; i++)\n\t\tseg[lvl][i] = Arr[i];\n\tsort(seg[lvl] + s, seg[lvl] + e);\n\n\tif (e - s == 1)\n\t\treturn ;\n\n\tint mid = e + s >> 1;\n\tbuild(s, mid, lvl + 1);\n\tbuild(mid, e, lvl + 1);\n}\n\nint get (int l, int r, int val, int s = 0, int e = n, int lvl = 0) {\n\tif (l <= s && e <= r)\n\t\treturn upper_bound(seg[lvl] + s, seg[lvl] + e, val) - (seg[lvl] + s);\n\tif (r <= s || e <= l)\n\t\treturn 0;\n\n\tint mid = e + s >> 1;\n\treturn get(l, r, val, s, mid, lvl + 1) + get(l, r, val, mid, e, lvl + 1);\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> R >> L;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> Arr[i];\n\tbuild();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i] = inf;\n\t\tif (get(0, i + 1, Arr[i]) == 1)\n\t\t\tdp[i] = R * i;\n\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (Arr[j] < Arr[i] && get(j, i + 1, Arr[i]) - get(j, i + 1, Arr[j]) == 1) {\n\t\t\t\tint cnt = get(j, i + 1, Arr[j]) - 1;\n\t\t\t\tdp[i] = min(dp[i], dp[j] + L * cnt + R * (i - j - 1 - cnt));\n\t\t\t}\n\t}\n\n\tans = inf;\n\tfor (int i = 0; i < n; i++)\n\t\tif (Arr[i] - get(0, i + 1, Arr[i]) == n - i - 1)\n\t\t\tans = min(ans, dp[i] + (n - i - 1) * L);\n\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream &s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream &s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream &s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\nsigned main() {\n  int n, a, b; cin >> n >> a >> b;\n  vector<int> x(n);\n  REP (i, n) {\n    int p; cin >> p;\n    p--;\n    x[p] = i;\n  }\n  vector<vector<int>> dp(n + 1, vector<int>(n + 1, 1e18));\n  REP (k, n + 1) dp[0][k] = 0;\n  REP (i, n) {\n    REP (k, n + 1) {\n      if (k > 0) dp[i + 1][k] = dp[i + 1][k - 1];\n      if (x[i] < k - 1) {\n        chmin(dp[i + 1][k], dp[i][k] + a);\n      } else if (x[i] == k - 1) {\n        chmin(dp[i + 1][k], min(dp[i][k] + a, dp[i][k - 1]));\n      } else {\n        chmin(dp[i + 1][k], dp[i][k] + b);\n      }\n    }\n  }\n  cout << dp[n][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef long long s64;\ntypedef unsigned long long u64;\ntypedef unsigned int u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define rep0(i,l,r) for(int i=l;i<r;++i)\n#define gc (c=getchar())\nint read()\n{\n\tchar c;\n\twhile(gc<'-');\n\tif(c=='-')\n\t{\n\t\tint x=gc-'0';\n\t\twhile(gc>='0')x=x*10+c-'0';\n\t\treturn -x;\n\t}\n\tint x=c-'0';\n\twhile(gc>='0')x=x*10+c-'0';\n\treturn x;\n}\n#undef gc\n\nconst int N=5000+5;\t\ns64 dp[N][N];\nint p[N],mx[N][N],mn[N][N];\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);//freopen(\"1.out\",\"w\",stdout);\n#endif\n\tint n,A,B;\n\tcin>>n>>A>>B;\n\trep(i,1,n)p[i]=read();\n\trep(i,1,n)mx[1][p[i]]=mn[1][p[i]]=i;\n\trep(len,2,n)\n\trep(i,1,n-len+1)\n\t{\n\t\tmx[len][i]=max(mx[len-1][i],mx[len-1][i+1]);\n\t\tmn[len][i]=min(mn[len-1][i],mn[len-1][i+1]);\n\t\tif(p[mx[len][i]]==i+len-1)dp[len][i]=dp[len-1][i];\n\t\telse dp[len][i]=dp[len-1][i]+A;\n\t\tif(p[mn[len][i]]==i)dp[len][i]=dp[len-1][i+1];\n\t\telse chmin(dp[len][i],dp[len-1][i+1]+B);\n\t}\n\tcout<<dp[n][1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 5010\n\nll dp[SIZE][SIZE];\n\nint main(){\n  int N, A, B;\n  int p[SIZE];\n\n  cin >> N >> A >> B;\n\n  for(int i=0;i<N;i++)\n    cin >> p[i];\n\n  for(int i=0;i<=N;i++)\n    for(int j=0;j<=N;j++)\n      dp[i][j] = LLINF * (i != 0);\n\n\n  for(int i=0;i<N;i++){\n    ll minVal = LLINF;\n\n    for(int j=0;j<p[i];j++)\n      minVal = min(minVal, dp[i][j]);\n\n    for(int j=0;j<=N;j++){\n      if(j < p[i]) dp[i+1][j] = dp[i][j] + A;\n      if(j > p[i]) dp[i+1][j] = dp[i][j] + B;\n    }\n\n    dp[i+1][p[i]] = minVal;\n  }\n\n  ll ans = LLINF;\n\n  for(int i=0;i<=N;i++)\n    ans = min(ans, dp[N][i]);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"pch.h\"\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <bitset>\n\n#define ll long long\n#define fri(n) for(i=0;i<(n);i++)\n#define frj(n) for(j=0;j<(n);i++)\n#define min(p,q) ((p)<(q)?(p):(q))\n#define max(p,q) ((p)>(q)?(p):(q))\n#define INF 1000000000000000000//10^18\n#define INFINT 2000000001//2*10^9+1\n#define MOD 1000000007\n#define MODANOTHER 998244353\n#define PI acos(-1)\n\nusing namespace std;\n\nll int n,a,b;\nstatic int p[5010];\nstatic ll int dp[5010][5010];\nstatic int hanten[5010][5010][2];\n\nll search(int x, int y){\n\tint i;\n\tll ret;\n\tll temp1,temp2;\n\n\tif(dp[x][y]!=-1) return dp[x][y];\n\n\tif(x==y){\n\t\tdp[x][y]=0;\n\t\treturn 0;\n\t}\n\n\ttemp1=search(x+1,y);\n\ttemp2=search(x,y-1);\n\n\tret=min(temp1+b*hanten[x][y][0],temp2+a*hanten[x][y][1]);\n\n\tdp[x][y]=ret;\n\n\treturn ret;\n\n}\n\nint main(void)\n{\n\t//変数の宣言\n\n\t//よく使う変数\n\tint i,j,k,l;\n\tint flag=0;\n\tll int ans=0;\n\tint count=0;\n\tint temp=0;\n\tint temp1=0;\n\tint temp2=0;\n\tint max=0;\n\tint min=INFINT;\n\tint len=0;\n\tint sum=0;\n\tint ok=0;\n\tint ng=0;\n\n\n\n\t//データの読み込み\n\n\n\tscanf(\"%lld %lld %lld\",&n,&a,&b);\n//\tscanf_s(\"%d %d %d\",&n,&a,&b);\n\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&p[i]);\n//\t\tscanf_s(\"%d\",&p[i]);\n\t}\n\n\t//\tprintf(\"nは%dです\\n\", n);\n\t//\tprintf(\"データの読み込み終了\\n\");\n\t//実際の処理\n\n\tfor(i=0;i<5010;i++){\n\t\tfor(j=0;j<5010;j++){\n\t\t\thanten[i][j][0]=1;\n\t\t\thanten[i][j][1]=1;\n\t\t\tdp[i][j]=-1;\n\t\t}\n\t}\n\n\tfor(i=1;i<=n;i++){\n\t\ttemp=1;\n\t\thanten[i][i][0]=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(temp<=p[j]&&p[j]<=i){\n\t\t\t\ttemp=p[j];\n\t\t\t\thanten[p[j]][i][0]=0;\n\t\t\t}\n\t\t}\n\t\ttemp=n;\n\t\thanten[i][i][1]=0;\n\t\tfor(j=n-1;j>=0;j--){\n\t\t\tif(temp>=p[j]&&p[j]>=i){\n\t\t\t\ttemp=p[j];\n\t\t\t\thanten[i][p[j]][1]=0;\n\t\t\t}\n\t\t}\n\t}\n\n\tsearch(1,n);\n\n\t//\tprintf(\"計算部分終了\\n\");\n\n\t//出力\n\n\tprintf(\"%lld\",dp[1][n]);\n\n/*\tprintf(\"\\n\");\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=i;j<=n;j++){\n\t\t\tprintf(\"hanten[%d][%d]={%d,%d}\\n\",i,j,hanten[i][j][0],hanten[i][j][1]);\n\t\t}\n\t}*/\n\t\n\t//\tprintf(\"結果の出力終了\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\nconstexpr int kN = int(5E3 + 10);\nconstexpr ll kInf = ll(1E16 + 10);\nll dp[kN][kN];\nint p[kN], low[kN][kN], top[kN][kN];\nint main() {\n\tint n, a, b;\n\tll lcost, rcost;\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &p[i]);\n\tfor (int i = 1; i <= n; i++) dp[i][i] = 0;\n\tfor (int i = 1; i <= n; i++) low[i][i] = top[i][i] = p[i];\n\tfor (int i = 2; i <= n; i++) for (int j = 1; j + i - 1 <= n; j++) {\n\t\tlow[j][j + i - 1] = min(low[j][j + i - 2], p[j + i - 1]);\n\t\ttop[j][j + i - 1] = max(top[j][j + i - 2], p[j + i - 1]);\n\t\tlcost = low[j][j + i - 1] == p[j] ? 0 : a;\n\t\trcost = top[j][j + i - 1] == p[j + i - 1] ? 0 : b;\n\t\tdp[j][j + i - 1] = min(lcost + dp[j + 1][j + i - 1], rcost + dp[j][j + i - 2]);\n\t}\n\tprintf(\"%lld\\n\", dp[1][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL N=5010;\nLL n, a, b, p[N], id[N], dp[N][N], s[N][N];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\tfor(LL i=1; i<=n; ++i)scanf(\"%lld\",&p[i]), id[p[i]]=i;\n\tmemset(s,0x3f,sizeof(s));\n\tfor(LL i=0; i<=n; ++i)s[0][i]=0;\n\tfor(LL i=1; i<=n; ++i)\n\t\tfor(LL j=1; j<=n; ++j){\n\t\t\tdp[i][j]=s[i-1][j]+(j>=id[i]?a:b);\n\t\t\tif(j==id[i])dp[i][j]=min(dp[i][j],s[i-1][j-1]);\n\t\t\tif(j>1)s[i][j]=min(s[i][j-1],dp[i][j]);else s[i][j]=dp[i][j];\n\t\t}\n\tLL mn=0x3f3f3f3f3f3f3f3f;\n\tfor(LL i=1; i<=n; ++i)mn=min(mn,dp[n][i]);\n\tprintf(\"%lld\",mn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Binary Indexed Tree (BIT)\n// Verified: AOJ DSL_2_B: Range Sum Query (intのみ)\n\ntemplate <typename T>\nstruct BIT{\nprivate:\n    vector<T> array;\n    int n;\n\npublic:\n    // 初期化 (適当)\n    BIT() : array(11, 0), n(10) {}\n    BIT(int _n) : array(_n + 1, 0), n(_n) {}\n\n    // 他のクラスで BIT を呼び出すときに便利なので作った\n    void resize(int _n) {\n        array.resize(_n + 1);\n        n = _n;\n    }\n\n    // 1番目から i番目までの累積和を求める\n    T sum(int i) {\n        T s = 0;\n        while(i > 0) {\n            s += array[i];\n            i -= i & -i;      // LSB 減算\n        }\n        return s;\n    }\n\n    // [i, j] の要素の総和\n    T sum(int i, int j) {\n        T ret_i = sum(i-1);\n        T ret_j = sum(j);\n        return ret_j - ret_i;\n    }\n\n    // i 番目に 要素 x を追加\n    void add(int i, T x) {\n        while(i <= n) {\n            array[i] += x;\n            i += i & -i;      // LSB 加算\n        }\n    }\n};\n\nsigned main() {\n    int N, A, B; cin >> N >> A >> B;\n    vector<int> p(N);\n    vector< pair<int, int> > info;\n\n    int midx = -1;\n    for(int i=0; i<N; i++) {\n        cin >> p[i];\n        if(p[i] == 1) midx = i;\n    }\n\n    vector<int> take(N, 1), mul(N, 1);\n    for(int i=1; i<N; i++) {\n        int cidx = (midx + i) % N;\n        int pidx = (cidx + N - 1) % N;\n        if(p[pidx] + 1 == p[cidx]) {\n            take[cidx] = false;\n            while(p[pidx] + 1 == p[cidx]) {\n                mul[pidx] = mul[cidx] + 1;\n                pidx = (pidx + N - 1) % N;\n                cidx = (cidx + N - 1) % N;\n            }\n        }\n    }\n\n    for(int i=0; i<N; i++) {\n        info.emplace_back(p[i], i+1);\n    }\n    sort(info.rbegin(), info.rend());\n\n    int ans = 0;\n    BIT<int> bit(N);\n    const int SHIFT_A = 1, SHIFT_B = 2, SHIFT_AB = 3;\n    int pre_shift = 0;\n\n    int M = info.size();\n    for(int i=0; i<M; i++) {\n        int val, idx; tie(val, idx) = info[i];\n        int sum = bit.sum(idx);\n        int costA = A*sum, costB = B*mul[idx-1];\n        \n        /*\n        int shift = -1;\n        if(costA < costB) shift = SHIFT_A;\n        else if(costA > costB) shift = SHIFT_B;\n        else shift = SHIFT_AB;\n\n        if((shift & pre_shift & SHIFT_B) == 0) {\n            ans += min(costA, costB);\n        }\n        */\n        if(take[idx-1]) {\n            // fprintf(stderr, \"add: idx = %lld, cost = %lld\\n\", idx, min(costA, costB));\n            ans += min(costA, costB);\n        }\n        bit.add(idx, 1);\n        // pre_shift = shift;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n\nconst int N = 5005;\n\nint a[N];\nint b[N];\nint mn[N][N];\nint mx[N][N];\nlong long dp[N][N];\n\nint main() {\n\tint n, x, y;\n\tcin >> n >> x >> y;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tb[a[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmn[i][i] = b[i];\n\t\tmx[i][i] = b[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tset <int> s;\n\t\ts.insert(b[i]);\n\t\tfor (int l = 1; l + i <= n; l++) {\n\t\t\tint r = l + i;\n\t\t\tmn[l][r] = min(mn[l][r - 1], b[r]);\n\t\t\tmx[l][r] = max(mx[l][r - 1], b[r]);\n\t\t\tdp[l][r] = dp[l + 1][r];\n\t\t\tif (mn[l][r] == mn[l + 1][r]) {\n\t\t\t\tdp[l][r] += y;\n\t\t\t}\n\t\t\tset <int> :: iterator it = s.begin();\n\t\t\tit++;\n\t\t\tif (b[l] == *it) {\n\t\t\t\tdp[l][r] = min(dp[l][r], dp[l + 1][r] + x);\n\t\t\t}\n\t\t\tif (mx[l][r] == mx[l][r - 1]) {\n\t\t\t\tdp[l][r] = min(dp[l][r], dp[l][r - 1] + x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[l][r] = min(dp[l][r], dp[l][r - 1]);\n\t\t\t}\n\t\t\tit = s.end();\n\t\t\tit--;\n\t\t\tit--;\n\t\t\tif (b[r] == *it) {\n\t\t\t\tdp[l][r] = min(dp[l][r], dp[l][r - 1] + y);\n\t\t\t}\n\t\t//\tcout << \"73 \" << l << \" \" << r << \" \" << mn[l][r] << \" \" << mx[l][r] << \" \" << dp[l][r] << endl;\n\t\t}\n\t}\n\tcout << dp[1][n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5005;\nlong long n, a, b, x[N];\nlong long f[N][N], pos[N], p[N][N];\n\nmain() {\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> a >> b;\n\tfor(int i = 1; i <= n; ++i) cin >> x[i];\n\tmemset(f, 127, sizeof(f));\n\tlong long oo = f[0][0];\n\tf[0][0] = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tpos[x[i]] = i;\n\t}\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j <= n; ++j) {\n\t\t\tif(j < x[i + 1]) {\n\t\t\t\tf[i+1][j] = min(f[i+1][j], f[i][j] + a);\n\t\t\t\tf[i+1][x[i+1]] = min(f[i+1][x[i+1]], f[i][j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf[i+1][j] = min(f[i+1][j], f[i][j] + b);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; ++i) oo = min(oo, f[n][i]);\n\tcout << oo << '\\n'; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 5100;\nll n,l,r,f[N],a[N];\nint main()\n{\n\tmemset(f,0x3f,sizeof(f)); cin >> n >> r >> l;\n\tfor(int i = 1;i <= n;i ++) a[i] = read() + 1;\n\ta[0] = 1; f[0] = 0; a[n + 1] = n + 2;\n\tfor(int i = 1;i <= n + 1;i ++)\n\t{\n\t\tll sr = 0,sl = 0;\n\t\tfor(int j = i - 1;j >= 0;j --)\n\t\t{\n\t\t\tif(a[j] < a[i]) f[i] = min(f[i],f[j] + r * sr + l * sl);\n\t\t\tif(a[j] > a[i]) sr ++; else sl ++;\n\t\t}\n\t}\n\tcout << f[n + 1] << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (2)\n#pragma G++ optimize (2)\n#include<bits/stdc++.h>\n#define INF (1ll<<61)\n#define MAX 5005\nusing namespace std;\n//char nc()\n//{\n//\tstatic char buf[100000],*p1=buf,*p2=buf;\n//\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\nchar nc(){return getchar();}\nint read()\n{\n\tint x=0,y=1;\n\tchar c=nc();\n\twhile(!isdigit(c))\n\t{\n\t\tif(c=='-')y=-1;\n\t\tc=nc();\n\t}\n\twhile(isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=nc();\n\t}\n\treturn x*y;\n}\nint n,a[MAX];\nlong long A,B,f[MAX];\nint main()\n{\n\tn=read();A=read();B=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\ta[0]=0;a[n+1]=n+1;\n\tf[0]=0;\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tint s1=0,s2=0;\n\t\tf[i]=INF;\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t{\n\t\t\tif(a[j]<a[i]) f[i]=min(f[i],f[j]+A*s1+B*s2),s2++;\n\t\t\telse s1++;\n\t\t}\n\t}\n\tprintf(\"%lld\",f[n+1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-19 23:22:04\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<set>\n#define i64 long long\nconst int N=5010;\nconst i64 inf=1ll<<60;\nint n,pre[N],suf[N],a[N],id[N];\ni64 f[N][N],A,B;\nstd::set<int> s;\ni64 solve(int l,int r)\n{\n\tif(l>=r) return 0;\n\tif(f[l][r]!=inf) return f[l][r];\n\ti64 &ans=f[l][r];\n\tans=std::min(solve(l+1,r)+(pre[id[l]]>r?0:B),solve(l,r-1)+(suf[id[r]]<l?0:A));\n//\tprintf(\"%d %d  %I64d\\n\",l,r,ans);\n\treturn ans;\n}\nint main()\n{\n\tn=read(); A=read(); B=read();\n\tfr(i,1,n) id[a[i]=read()]=i;\n\ts.insert(n+1);\n\tfr(i,1,n)\n\t{\n\t\tpre[i]=*s.lower_bound(a[i]); s.insert(a[i]);\n\t}\n\ts.clear(); s.insert(0);\n\tfd(i,n,1)\n\t{\n\t\tsuf[i]=*(--s.lower_bound(a[i])); s.insert(a[i]);\n\t}\n//\tfr(i,1,n) printf(\"%d %d\\n\",pre[i],suf[i]);\n\tfr(i,1,n) fr(j,1,n) f[i][j]=inf;\n\tprintf(\"%lld\\n\",solve(1,n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <random>\n#include <tuple>\n#include <iomanip>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int,int> Pint;\n//typedef pair<ll, ll> P;\ntypedef pair<ll, pair<ll, ll>> P;\n//typedef tuple<int,int,int> T;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n-1); i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nconst ll INFL = 1LL << 60;//10^18 = 2^60\nconst int INF = 1 << 30;//10^9\nconst ll MOD = 1e9 + 7;\n//ll MOD  = 998244353;\nvector<ll> dy = {0, 0, 1, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, -1, 0, 0, 1, -1, 1, -1, 0};\n\nll max(ll a, ll b){return (a > b) ? a : b;}\nll min(ll a, ll b){return (a < b) ? a : b;}\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\nll pow_mod(ll x, ll k){\n  x %= MOD; x += MOD; x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\n//最大公約数\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\n//最小公倍数\nll lcm(ll x, ll y){return x / gcd(x, y) * y;};\n\n\n\nint main(void){\n   ll N, A, B;\n   cin >> N >> A >> B;\n   vector<ll> p(N);\n   rep(i, N) cin >> p[i];\n   ll dp[N+1][N+1];\n   rep(i, N+1)rep(j, N+1) dp[i][j] = INFL;\n   dp[0][0] = 0;\n   for(int i = 1; i <= N; i++){\n     ll x = p[i-1];\n     for(int j = 0; j <= N; j++){\n       if(x > j){\n         dp[i][x] = min(dp[i][x], dp[i-1][j]);\n         dp[i][j] = min(dp[i][j], dp[i-1][j] + A);\n       }\n       if(x < j){\n         dp[i][j] = min(dp[i][j], dp[i-1][j] + B);\n       }\n     }\n   }\n   ll ans = INFL;\n   for(int i = 1; i <= N; i++) ans = min(ans, dp[N][i]);\n   cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e9+7)\n#define INF (ll)1e15\nll N,A,B;\npll pp[101010];\nll dp[5050][10101],ans;\nll i, j;\nll aaa(const ll& a,const ll& b ){\n    return a - 1 == b * 2 ? 0 : a - 1 < b * 2 ? B : A;\n}\n\nint main(){\n    scanf(\"%lld%lld%lld\", &N,&A,&B);\n    fornum(i,0,N){\n        ll p;\n        scanf(\"%lld\", &p);\n        pp[i] = {p,i};\n    }\n    sort(pp, pp + N);\n    fornum(i,0,N){\n        ll minn = INF;\n        fornum(j,0,N*2+1){\n            if(j%2){\n                dp[i + 1][j] = minn + aaa(j, pp[i].second);\n                if(dp[i][j]<minn){\n                    minn = dp[i][j];\n                }\n            }else{\n                if(dp[i][j]<minn){\n                    minn = dp[i][j];\n                }\n                dp[i + 1][j] = minn + aaa(j, pp[i].second);\n            }\n        }\n    }\n    ans = INF;\n    fornum(i,0,N*2+1){\n        if(dp[N][i]<ans){\n            ans = dp[N][i];\n        }\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* Starry Sky Tree */\n//0-index\n\nstruct StarrySkyTree{\n  typedef ll Type;\n  int segn2;\n  vector<Type> data, s_data;\n  function<Type(Type, Type)> merge;\n\n  StarrySkyTree(function<Type(Type, Type)> merge, int n): merge(merge)\n  {\n    for(segn2=1; segn2<n; segn2*=2);\n    data.assign(segn2*2, 0);\n    s_data.assign(segn2*2, 0);\n  }\n\n  StarrySkyTree(int n): //Original Ver.\n    StarrySkyTree([](Type a, Type b){ return min(a, b); }, n) {}\n\n  //get value of [a,b)\n  Type query(int a, int b, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(r <= a || b <= l) return LLINF; //大きさに注意\n    if(a <= l && r <= b) return data[k] + s_data[k];\n    return min(query(a, b, l, (l+r)/2, k*2+1), query(a, b, (l+r)/2 , r, k*2+2)) + s_data[k];\n  }\n\n  //add x to [a,b)\n  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(a <= l && r <= b)\n      s_data[k] += x;\n    else if(a < r && l < b)\n      data[k] = min(add(a, b, x, l, (l+r)/2, k*2+1), add(a, b, x, (l+r)/2, r, k*2+2));\n\n    return data[k] + s_data[k];\n  }\n\n  Type val(int x){\n    Type res = 0;\n    x += segn2 - 1;\n\n    while(x){\n      res += s_data[x];\n      x = (x-1)/2;\n    }\n\n    return res;\n  }\n\n  void add(int a, Type x){\n    a += segn2 - 1;\n    s_data[a] += x;\n\n    while(a){\n      a = (a-1)/2;\n      data[a] = min(data[a*2+1] + s_data[a*2+1], data[a*2+2] + s_data[a*2+2]);\n    }\n  }\n};\n\nint main(){\n  int N, A, B, p;\n\n  scanf(\"%d%d%d\", &N, &A, &B);\n\n  StarrySkyTree seg(N+1);\n\n  for(int i=0;i<N;i++){\n    scanf(\"%d\", &p);\n    ll minVal = seg.query(0, p);\n\n    seg.add(0, p, A);\n    seg.add(p+1, N+1, B);\n\n    ll q = seg.val(p);\n    seg.add(p, minVal - q);\n  }\n\n  ll ans = seg.query(0, N+1);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nll dp[5010][5010];\nll sz[5010][5010];\nint main(){\n    int n;\n    cin >> n;\n    ll A,B;\n    cin >> A >> B;\n    vector<int>p(n+2);\n    vector<int>q(n+2);\n    rep(i,n)cin >> p[i+1];\n    rep(i,n){\n        q[p[i+1]] = i+1;\n        sz[i+1][p[i+1]]++;\n    }\n    for(int j=n-1;j>=1;j--){\n        for(int i=1;i<=n;i++){\n            sz[i][j] += sz[i][j+1];\n        }\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            sz[i][j] += sz[i-1][j];\n        }\n    }\n    // rep(i,n){\n    //     rep(j,n){\n    //         cerr << sz[i+1][j+1] << \" \" ;\n    //     }\n    //     cerr << endl;\n    // }\n    vector<ll> v(n+1);\n    Fill(dp,1LL<<60);\n    rep(i,n+3){\n        dp[n][i] = 0;\n    }\n    rep(i,n+3){\n        dp[i][n+1] = 0;\n        dp[i][n+2] = 0;\n    }\n    for(int x=n-1;x>=0;x--){\n        for(int y=1;y<=n;y++){\n            if(q[x+1]<=y){\n                dp[x][y] = dp[x+1][y];\n            }else{\n                ll cnt = sz[q[x+1]-1][x+1]-sz[y-1][x+1];\n                // cerr << x << \" \" << q[x+1] << endl;\n                // cerr << x << \" \" << y << \" \" <<  cnt << endl;\n                // cerr << x+1 << \" \" << q[x+1]+1 << endl;\n                dp[x][y] = min(dp[x+1][y]+B,dp[x+1][q[x+1]+1]+A*cnt);\n            }\n        }\n    }\n    // cerr << dp[9][10] << endl;\n    // cerr << dp[8][10] << endl;\n    // rep(i,n){\n    //     rep(j,n){\n    //         cerr << i << \" \" << j+1 << \" \" <<  dp[i][j+1] << endl;\n    //     }\n\n    // }\n    cout << dp[0][1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MAXN =5e3+5;\nlong long dp[MAXN][MAXN];\nlong long pos[MAXN];\nlong long p[MAXN];\nlong long mindp[MAXN];\nint main(){\n    long long n,a,b;\n    cin>>n>>a>>b;\n    for(long long i=1;i<=n;i++){\n        cin>>p[i];\n        pos[p[i]] = i;\n    }\n    for(long long i=1;i<=n;i++){\n        for(long long j=0;j<=n;j++){\n            dp[i][j] = 1e18;\n        }\n    }\n    dp[0][0] = 0; \n    for(long long i=1;i<=n;i++){\n        for(long long j=0;j<=n;j++){\n           \n            if(j==pos[i]){\n                dp[i][j] = dp[i-1][j-1];\n                continue;\n            }\n            long long cost;\n            if(pos[i]<j){\n                cost = a;\n            }else{\n                cost = b;\n            }\n            if(j){\n                dp[i][j] = min(dp[i][j],dp[i][j-1]);\n               \n            }\n             dp[i][j] = min(dp[i][j],dp[i-1][j]+(cost));\n            // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n        }\n    }\n    cout<<dp[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pa pair<int,int>\nusing namespace std;\nconst int N = 5001;\nconst int inf = 2147483647;\n\nint _max(int x, int y) {return x > y ? x : y;}\nLL _min(LL x, LL y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint a[N]; LL f[N][N];\n\nint main() {\n\tint n = read(), A = read(), B = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tmemset(f, 63, sizeof(f)); f[0][0] = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tif(a[i] > j) {\n\t\t\t\tf[i][j] = _min(f[i][j], f[i - 1][j] + A);\n\t\t\t\tf[i][a[i]] = _min(f[i][a[i]], f[i - 1][j]);\n\t\t\t} else f[i][a[i]] = _min(f[i][a[i]], f[i - 1][j] + B);\n\t\t}\n\t} LL ans = f[0][1];\n\tfor(int i = 0; i <= n; i++) ans = _min(ans, f[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 5056;\nconst ll inf = 1e18;\nint n,p[N];\nll dp[N],a,b;\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> a >> b;\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        --p[i];\n    }\n    ll ans = inf;\n    for (int i = 0; i < n; ++i) {\n        ll s = 0;\n        dp[i] = inf;\n        for (int j = i - 1; j >= 0; --j)  {\n            if (p[j] < p[i])\n                dp[i] = min(dp[i], dp[j] + s);\n            s += p[j] < p[i] ? b : a;\n        }\n        dp[i] = min(dp[i], s);\n        s = 0;\n        for (int j = i + 1; j < n; ++j)\n            if (p[j] < p[i])\n                s += b;\n            else\n                s = inf;\n//        cerr << i << ' ' << dp[i]  << ' '<< s << endl;\n        ans = min(ans, dp[i] + s);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 5001;\n\nint n, A, B, cnt[N];\nll dp[N][N];\nvector <int> a;\n\nll solve(int idx, int j){\n    if(idx == n) return 0;\n    ll &ret = dp[idx][j];\n    if(ret != -1) return ret;\n    if(a[idx] == j) return solve(idx + 1, j + 1);\n    if(a[idx] < j) return solve(idx + 1, j);\n    if(cnt[j]) return solve(idx, j + 1);\n    ret = solve(idx, j + 1) + B;\n    cnt[a[idx]]++;\n    ret = min(ret, solve(idx + 1, j) + A);\n    cnt[a[idx]]--;\n    return ret;\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    memset(dp, -1, sizeof dp);\n    cin >> n >> A >> B;\n    a.resize(n);\n    for(auto &i : a) cin >> i;\n    cout << solve(0, 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  lint A, B; cin >> A >> B;\n  V<> p(n); for (auto&& e : p) cin >> e;\n  auto fn = [&](const auto& fn, const V<>& p) -> lint {\n    int n = p.size();\n    if (n <= 1) return 0;\n    int s = max_element(begin(p), end(p)) - begin(p);\n    lint res = 1e18;\n    {\n      auto q = p;\n      q.erase(begin(q) + s);\n      res = min(res, A + fn(fn, q));\n    }\n    {\n      auto q = p;\n      q.erase(begin(q) + s, end(q));\n      res = min(res, B * (n - 1 - s) + fn(fn, q));\n    }\n    return res;\n  };\n  cout << fn(fn, p) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n, a, b, num[5007], dp[5007][5007], res = 1e18;\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nsigned main()\n{\n\tn = read();\n\ta = read();\n\tb = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tnum[i] = read();\n\tmemset(dp, 0x3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tif (num[i] > j)\n\t\t\t{\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + a);\n\t\t\t\tdp[i][num[i]] = min(dp[i][num[i]], dp[i - 1][j]);\n\t\t\t}\n\t\t\telse dp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n\tfor (int i = 0; i <= n; i++)\n\t\tres = min(res, dp[n][i]);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;typedef long long LL;LL v[6000],p[6000],d[2][6000];int main(){LL N,L,R,k,b;cin>>N>>R>>L;for(LL i=0;i<N;i++)cin>>v[i];for(LL i=0;i<N;i++)p[v[i]]=i;for(LL i=1;i<=N;i++){k=i&1;b=1e17;for(LL j=0;j<=N+1;j++){b=min(b,d[k^1][j]);if(p[i]+1>j)d[k][j]=b+L;else if(p[i]+1==j)d[i][j]=b;else d[k][j]=b+R;}}R=1e17;for(LL i=0;i<=N+1;i++)R=min(R,d[N&1][i]);cout<<R;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream &s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream &s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream &s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\nsigned main() {\n  int n, a, b; cin >> n >> a >> b;\n  vector<int> x(n);\n  REP (i, n) {\n    int p; cin >> p;\n    p--;\n    x[p] = i;\n  }\n  vector<vector<int>> dp(n + 1, vector<int>(n + 1, 1e18));\n  REP (k, n + 1) dp[0][k] = 0;\n  REP (i, n) {\n    REP (k, n + 1) {\n      if (k > 0) dp[i + 1][k] = dp[i + 1][k - 1];\n      chmin(dp[i + 1][k], dp[i][k] + (x[i] <= k - 1 ? a : b));\n      if (x[i] == k - 1) chmin(dp[i + 1][k], dp[i][k - 1]);\n    }\n  }\n  cout << dp[n][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n#include <memory.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\n#define N 5002\n#define mod 1000000007\n\nvector<int> segDS[N*4];\n\nint p[N];\n\nvoid init(int pos,int l,int r) {\n  if(l==r) {\n    segDS[pos].push_back(p[l]);\n    return;\n  }\n  int mid = (l+r)/2;\n  init(pos*2,l,mid);\n  init(pos*2+1,mid+1,r);\n  int lpos = 0,rpos = 0;\n  l = pos*2,r = pos*2+1;\n  while(lpos<segDS[l].size() && rpos<segDS[r].size()) {\n    if(segDS[l][lpos]<segDS[r][rpos]) {\n      segDS[pos].push_back(segDS[l][lpos++]);\n    } else {\n      segDS[pos].push_back(segDS[r][rpos++]);}\n  }\n  while(lpos<segDS[l].size()) {\n    segDS[pos].push_back(segDS[l][lpos++]);\n  }\n  while(rpos<segDS[r].size()) {\n    segDS[pos].push_back(segDS[r][rpos++]);\n  }\n}\n\nint query(int pos,int l,int r,int ql,int qr,int index) {\n  if(r<ql || qr<l) {\n    return 0;\n  }\n  if(ql<=l && r<=qr) {\n    return lower_bound(segDS[pos].begin(),segDS[pos].end(),index + 1) - segDS[pos].begin();\n  }\n  int mid = (l+r)/2;\n  return query(pos*2,l,mid,ql,qr,index) + query(pos*2+1,mid+1,r,ql,qr,index);\n}\nint getIndex(int l,int r,int findex,int n) {\n  int inputIndex = p[findex];\n  return query(1,1,n,l,r,inputIndex);\n}\nlong long dp[N][N];\nint leftMoveCost,rightMoveCost;\nlong long solveDp(int l,int r,int n) {\n  if(l==r) {\n    return 0LL;\n  }\n  long long &ret = dp[l][r];\n  if(ret!=-1) {\n    return ret;\n  }\n  ret = 1e18;\n  //l first\n  int lindex = getIndex(l,r,l,n) + l - 1;\n  int add = 0;\n  if(lindex!=l) {\n    add = leftMoveCost;\n  }\n  ret = min(ret, add + solveDp(l+1,r,n));\n  //r first\n  int rindex = getIndex(l,r,r,n) + l-1;\n  add = 0;\n  if(rindex!=r) {\n    add = rightMoveCost;\n  }\n  ret = min(ret, add + solveDp(l,r-1,n));\n  return ret;\n}\nvoid solve() {\n  int n,A,B;scanf(\"%d %d %d \", &n,&A,&B);\n  leftMoveCost = B;\n  rightMoveCost = A;\n  for(int i=1;i<=n;++i) {\n    int x;scanf(\"%d \", &x);\n    p[x] = i;\n  }\n  init(1,1,n);\n  memset(dp,-1,sizeof(dp));\n  printf(\"%lld\\n\", solveDp(1,n,n));\n}\n\nint main() {\n  //freopen(\"input.txt\",\"r\",stdin);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nll INF = 1000000000000000000;\nstruct segtree{\n  ll M=1, INIT;\n  vector<ll> dat;\n  segtree(ll N, ll num){\n    INIT = num;\n    while(M<N) M*=2;\n    for(int i=0;i<M*2-1;i++)  dat.push_back(num);\n  }\n  void update(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] += x;\n    while(k>0) k = (k-1)/2, dat[k] = dat[k*2+1] + dat[k*2+2];\n  }\n  ll query(ll a, ll b=-1, ll k=0, ll l=0, ll r=-1){\n    if(r==-1) r = M;\n    if(b==-1) b = M;\n    if(r<=a || b<=l) return INIT;\n    if(a<=l && r<=b) return dat[k];\n    ll A = query(a, b, k*2+1, l, (l+r)/2);\n    ll B = query(a, b, k*2+2, (l+r)/2, r);\n    return A + B;\n  }\n};\nint main(int argc, char const *argv[]) {\n  ll n, A, B;std::cin >> n >> B >> A;\n  vll p(n);re(i, n) scanf(\"%lld\", &p[i]);\n  vll comb(n+1), rcomb(n+1);\n\n  vll idx(n+1);\n  for(int i=0;i<n;i++) idx[p[i]] = i;\n  for(int i=0;i<n;i++){\n    ll cnt = 0;\n    for(int j=i;j<n;j++, cnt++) if(p[j]!=p[i]+cnt) break;\n    comb[p[i]] = cnt;\n    cnt = 0;\n    for(int j=i;j>=0;j--, cnt++) if(p[j]!=p[i]-cnt) break;\n    rcomb[p[i]] = cnt;\n  }\n  vll tento(n+1);\n  vll rtento(n+1);\n  segtree l(n+1, 0), r(n+1, 0);\n\n  for(int i=0;i<n;i++){\n    ll q = l.query(p[i], n+1);\n    tento[p[i]] = q;\n    l.update(1, p[i]);\n  }\n  for(int i=n-1;i>=0;i--){\n    ll q = r.query(0, p[i]);\n    rtento[p[i]] = q;\n    r.update(1, p[i]);\n  }\n\n  vvl dp = VV(n+1, n+1, INF, ll);\n  dp[0][0] = 0;\n\n  for(int i=0;i<n-1;i++){\n    for(int j=0;j<=i;j++){\n      ll x = comb[j+1], y = comb[n-(i-j)];\n      //if(idx[i+1+x]==i) x += comb[i+1+x];\n      //左詰め\n      dp[i+x][j+x] = min({dp[i+x][j+x],\n        dp[i][j]+A*comb[j+1], dp[i][j]+B*tento[j+1]});\n\n      //右詰め\n      dp[i+y][j] = min({dp[i+y][j],\n        dp[i][j]+B*comb[n-(i-j)], dp[i][j]+A*rtento[n-(i-j)]});\n    }\n  }\n\n  ll ans = 1000000000000000000;\n  for(int i=0;i<=n;i++) {\n    //std::cout << i << \" \" << dp[n-1][i] << '\\n';\n    ans = min(ans, dp[n-1][i]);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"d.in\", \"r\", stdin));\n#endif\n  int n, a, b;\n  cin >> n >> a >> b;\n  vector<int> p(n + 1);\n  vector<int> pos(n + 1);\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i];\n    --p[i];\n    pos[p[i]] = i;\n  }\n  p[n] = pos[n] = n;\n  vector<ll> d(n + 1);\n  for (int i = 0; i < n + 1; ++i) {\n    d[i] = 1e18;\n    ll cost = 0;\n    for (int j = i - 1; j >= 0; --j) {\n      if (pos[j] < pos[i]) {\n        d[i] = min(d[i], d[j] + cost);\n        cost += a;\n      } else {\n        cost += b;\n      }\n    }\n    d[i] = min(d[i], cost);\n  }\n  cout << d[n] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll int\nusing namespace std;\nll n,a[200005],d[5005][5005],aa,b,d1[5005][5005],d2[5005][5005];\nint main() {\n\tcin >> n >> b >> aa;\n\t\n\tfor(int i=1; i<=n; i++)\n\t\tcin >> a[i];\n\t\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=i+1; j<=n; j++){\n\t\t\td1[i][j] = d1[i][j-1] + (a[i] > a[j]);\n\t\t}\n\t}\n\t\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=i-1; j>=1; j--){\n\t\t\td2[i][j] = d2[i][j+1] + (a[j] > a[i]);\n\t\t}\n\t}\n\t\n\tfor(int i=2; i<=n; i++){\n\t\tfor(int j=1; j<=n-i+1; j++){\n\t\t\tll raod = 0;\n\t\t\td[j][j+i-1] = min(d[j][j+i-2] + d2[j+i-1][j] * b,d[j][j+i-2] + aa);\n\t\t\traod = 0;\n\t\t\td[j][i+j-1] = min(d[j][i+j-1],min(d[j+1][i+j-1] + aa * d1[j][i+j-1],d[j+1][i+j-1] + b));\n\t\t}\n\t}\n\t\n//\tcout << d[2][3] << endl;\n\t\n\tcout << d[1][n];\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int maxn = 5e3 + 10;\nconst long long max_val = 1LL << 62;\n \nlong long dp[maxn * 2], dp_min[maxn * 2];\nint p[maxn];\n \nlong long cost(int p1, int p2, int A, int B) {\n    if (p1 == p2) return 0;\n    else if (p1 > p2) return B;\n    else return A;\n}\n \nint main()\n{\n    int N, A, B, x;\n    cin >> N >> A >> B;\n    for (int i = 1; i <= N; i++) {\n        cin >> x;\n        p[x] = i;\n    }\n    for (int i = 1; i <= N; i++) for (int j = 0; j <= N; j++) dp[j] = max_val;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <=  i; j++) {\n            dp[j] = dp_min[j] + cost(p[i], j, A, B);\n        }\n        dp_min[0] = dp[0];\n        for (int j = 1; j <=  N; j++) dp_min[j] = min(dp_min[j - 1], dp[j]);\n    }\n    cout << dp_min[ N] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 5000 + 10;\nconst ll INF = 1LL << 50;\n\nint n, a[maxn], p[maxn]; ll A, B, dp[2][maxn], mn[maxn];\n\ninline void upmin(ll &x, ll y) { x = min(x,y); }\n\nll get_val(int i, int j) { return (p[i] <= j) ? (A) : (B); }\n\nint main() {\n\tscanf(\"%d%lld%lld\", &n, &A, &B);\n\tfor(int i = 1;i <= n;i ++) scanf(\"%d\", &a[i]), p[a[i]] = i;\n\tint cur = 1, pre = 0;\n\tfor(int i = 0;i < p[1];i ++) dp[cur][i] = B;\n\tdp[cur][p[1]] = 0;\n\tfor(int i = p[1] + 1;i <= n;i ++) dp[cur][i] = A;\n\tmn[0] = dp[cur][0];\n\tfor(int i = 1;i <= n;i ++) mn[i] = min(mn[i - 1],dp[cur][i]);\n\tfor(int i = 2;i <= n;i ++) {\n\t\tcur = pre; pre ^= 1;\n\t\tfor(int j = 0;j <= n;j ++) dp[cur][j] = INF;\n\t\tfor(int j = 0;j <= n;j ++) {\n\t\t\tupmin(dp[cur][j],mn[j] + get_val(i,j));\n\t\t\tif(j == p[i]) upmin(dp[cur][j],mn[j - 1]);\n\t\t}\n\t\tmn[0] = dp[cur][0];\n\t\tfor(int j = 1;j <= n;j ++) mn[j] = min(mn[j - 1],dp[cur][j]);\n\t}\n\tll Ans = mn[n];\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define LLINF ((long long) 1e18)//1234567890987654321\n#define INF 1234567890ll\n#define pb push_back\n#define ins insert\n#define f first\n#define s second\t\n#define db 0\n#define EPS (1e-7)    //0.0000001 the value\n#define PI (acos(-1))\n#define MAXN (300006)/3\n#define MAXK 26\n#define MAXX 15000006\n#define ll long long int \n#define ld long double\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\n#define FOR(ii, ss, ee) for(ll ii = ss; ii < ee; ++ii)\n#define space \" \"\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ((ll)x.size())\n#define ph push\n#define btinpct(x) __builtin_popcountll(x)\n#define p2(x) (1LL<<(x))\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\ntypedef pair <ll, ll> pi;\ntypedef pair <ll, pi> spi;\ntypedef pair <pi, pi> dpi;\ninline ll rand(ll x, ll y) { ++y; return (rng() % (y-x)) + x; } //inclusivesss\nll n,a,b,A[5002],dp[5002], prev_dp[5002], at[5002], co[5002];\n\nint main()\n{\n\tFAST\n\tcin>>n>>a>>b;\n\tfor(ll i=1;i<=n;++i){cin>>A[i];at[A[i]]=i;}\n\tFOR(k,1,n+1) {\n\t\tmmst(dp,0);\n\t\tll p = at[k];\n\t\tfor(ll i=1;i<p;i++)  dp[i] = prev_dp[i];\n\t\tfor(ll i=p;i<=n;i++) {\n\t\t\tdp[i] = min(prev_dp[i]+a, prev_dp[p-1] + b * (co[i] - co[p]));\n\t\t}\n\t\tfor(ll i=p;i<=n;i++) co[i] += 1;\n\t\tswap(dp,prev_dp);\n\t}\n\tcout<<prev_dp[n]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\ntypedef long double ld;\ntypedef long long ll;\n\nconst int M = 5050;\nconst ll inf = 1e18;\n\nint n, p[M];\nll d[M];\nll A, B;\nint f[M];\n\nvoid clear() {\n  fill(f, f + M, 0);\n}\n\nvoid add(int at, int val) {\n  for (int i = at; i < M; i |= (i + 1)) {\n    f[i] += val;\n  }\n}\n\nint get(int r) {\n  int ans = 0;\n  for (int i = r - 1; i >= 0; i = (i & (i + 1)) - 1) {\n    ans += f[i];\n  }\n  return ans;\n}\n\nvoid read() {\n  cin >> n;\n  cin >> A >> B;\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i];\n    --p[i];\n  }\n}\n\nvoid kill() {\n  d[0] = 0;\n  p[n] = n;\n  for (int i = 1; i <= n; ++i) {\n    clear();\n    d[i] = 1ll * i * A;\n    for (int j = i - 1; j >= 0; --j) {\n      if (p[j] < p[i]) {\n        ll x = get(p[j]);\n        ll y = (i - j - x - 1);\n        d[i] = min(d[i], x * B + y * A + d[j]);\n      }\n      add(p[j], 1);\n    }\n    cerr << i << \": -> \" << d[i] << \"\\n\";\n  }\n  cout << d[n] << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"d.in\", \"r\", stdin));\n#endif\n\n  ios_base::sync_with_stdio(false);\n\n  read();\n  kill();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> A\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst LL INF = 9187201950435737471;\n\nint N; int a[MAXN+1],pos[MAXN+1];\nLL f[5010][5010]; LL A,B;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); A=read(),B=read();\n\tmemset(f,127,sizeof(f)); \n\tfor(int i=1;i<=N;i++) a[i]=read(),pos[a[i]]=i;\n\tf[0][0]=0; LL ans=INF;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(f[i][j]==INF) continue;\n\t\t\tf[i][j+1]=min(f[i][j+1],(pos[j+1]<=i?0:B)+f[i][j]);\n\t\t}\n\t\tfor(int j=0;j<=N;j++){\n\t\t\tif(f[i][j]==INF) continue;\n\t\t\tif(j+1==a[i+1]){\n\t\t\t\tf[i+1][j+1]=min(f[i][j],f[i+1][j+1]);\n\t\t\t} else if(j<a[i+1]){\n\t\t\t\tf[i+1][j]=min(f[i][j]+A,f[i+1][j]);\n\t\t\t} else{\n\t\t\t\tf[i+1][j]=min(f[i][j],f[i+1][j]);\n\t\t\t}\n\t\t} \n\t} for(int i=0;i<=N;i++) ans=min(ans,f[N][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define FIR first\n#define SEC second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst ll inf=1e18;\nconst int N=5010;\nll dp[N][2*N],pre[N][2*N];\nint per[N],p[N],n;\nint A,B;\n\nint main() {\n\trd(n),rd(A),rd(B);\n\tfor(int i=1;i<=n;++i) rd(per[i]),p[per[i]]=i;\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][1]=0;\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=2*n+1;++j) pre[i-1][j]=min(j>1 ? pre[i-1][j-1] : inf,dp[i-1][j]);\n\t\tfor(int j=1;j<=2*n+1;++j)\n\t\t\tdp[i][j]=pre[i-1][j&1 ? j : j-1]+(j<p[i]*2)*B+(j>p[i]*2)*A;\n\t}\n\tll res=inf;\n\tfor(int j=1;j<=2*n+1;++j)\n\t\tres=min(res,dp[n][j]);\n\tprintf(\"%lld\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define FORqr(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int (x); SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long (x); SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\n#define M0(x) memset(x,0,sizeof(x))\n#define FILL(x,y) memset(x,y,sizeof(x))\n#define MM(x) memset(x,-1,sizeof(x))\n#define ALL(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef pair<long long,long long> PLL;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n///////////////////////////////////////////////\nconst ll MOD = 1000000007;\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////\n\n/*（๑•﹏•๑｀) */\n\n\nint main() {\n    static ll a[5002] = {};\n    static ll b[5002] = {};\n    int N;\n    ll A;\n    ll B;\n    ll ans = 0;\n\n\n    cin >> N >> A >> B;\n    FORq(i,1,N){\n        cin >> a[i];\n        b[a[i]] = i;\n    }\n\n    static ll dp[5002][10002] = {};\n    static ll dpS[5002][10002] = {};\n    REP(i,5002){\n        REP(j,10002){\n            if (i != 0) {\n                dp[i][j] = 1e15;\n                dpS[i][j] = 1e15;\n            }\n            else {\n                dp[i][j] = 0;\n                dpS[i][j] = 0;\n            }\n\n        }\n    }\n\n    FORq(i,1,N){\n        FORq(j,1,2*N+1){\n            ll mini = dpS[i-1][j-1];\n\n            if (j < b[i] * 2) dp[i][j] = mini + B;\n            if (j > b[i] * 2) dp[i][j] = mini + A;\n            if (j == b[i] * 2) dp[i][j] = mini;\n\n\n            dpS[i][j] = min(dpS[i][j-1],dp[i][j]);\n        }\n\n\n    }\n\n//    FORq(i,1,N){\n//        FORq(j,1,2*N+1){\n//            printf(\"dp[%d][%d] = %lld\\n\",i,j,dp[i][j]);\n//        }\n//    }\n    cout << dpS[N][2*N+1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Tenshi ni Fureta yo!\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\n// END tpl.\n\nconst LL INF = (LL) 1e18;\n\nconst int MAXN = (int) 5e3;\n\nint n, A, B;\n\nint p[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), A = read<int>(), B = read<int>();\n\tfor(int i = 1; i <= n; ++i) p[i] = read<int>();\n\tp[0] = 0, p[n + 1] = n + 1;\n}\n\ninline void solve()\n{\n\tstatic int g0[MAXN + 5][MAXN + 5], g1[MAXN + 5][MAXN + 5];\n\n\tfor(int i = 0; i <= n + 1; ++i)\n\t\tfor(int j = i + 2; j <= n + 1; ++j)\n\t\t\tg0[i][j] = g0[i][j - 1] + (p[j - 1] < p[i]);\n\n\tfor(int i = 0; i <= n + 1; ++i)\n\t\tfor(int j = i + 2; j <= n + 1; ++j)\n\t\t\tg1[i][j] = g1[i][j - 1] + (p[j - 1] > p[i]);\n\n\tstatic LL f[MAXN + 5];\n\tfor(int i = 0; i <= n + 1; ++i) f[i] = INF;\n\n\tf[0] = 0;\n\tfor(int i = 1; i <= n + 1; ++i)\n\t\tfor(int j = i <= n ? 0 : 1; j < i; ++j) if(p[j] < p[i])\n\t\t\tchkmin(f[i], f[j] + (LL) B * g0[j][i] + (LL) A * g1[j][i]);\n\n\tprintf(\"%lld\\n\", f[n + 1]);\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pa pair<int,int>\nusing namespace std;\nconst int N = 5001;\nconst int inf = 2147483647;\n\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint a[N], f[N][N];\n\nint main() {\n\tint n = read(), A = read(), B = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tmemset(f, 63, sizeof(f)); f[0][0] = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tif(a[i] > j) {\n\t\t\t\tf[i][j] = _min(f[i][j], f[i - 1][j] + A);\n\t\t\t\tf[i][a[i]] = _min(f[i][a[i]], f[i - 1][j]);\n\t\t\t} else f[i][a[i]] = _min(f[i][a[i]], f[i - 1][j] + B);\n\t\t}\n\t} int ans = f[0][1];\n\tfor(int i = 0; i <= n; i++) ans = _min(ans, f[n][i]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 5000 + 5 ; \nint n, A, B, p[N], dp[N][N], mx[N][N], mi[N][N] ; \nsigned main()\n{\n\tn = gi(), A = gi(), B = gi() ; \n\trep( i, 1, n ) p[i] = gi(), mx[i][i] = mi[i][i] = p[i] ;\n\trep( i, 1, n ) rep( j, i + 1, n ) \n\t\tmx[i][j] = max( mx[i][j - 1], p[j] ), mi[i][j] = min( mi[i][j - 1], p[j] ) ; \n\trep( k, 2, n ) {\n\t\trep( l, 1, n ) {\n\t\t\tint r = l + k - 1 ; \n\t\t\tif( r > n ) break ; \n\t\t\tdp[l][r] = min( dp[l + 1][r] + A, dp[l][r - 1] + B ) ;\n\t\t\tfor( re int j = l + 1; j <= r; ++ j ) \n\t\t\t\tif( mx[l][j - 1] < mi[j][r] ) \n\t\t\t\t\tdp[l][r] = min( dp[l][r], dp[l][j - 1] + dp[j][r] ) ; \n\t\t}\n\t}\n\tcout << dp[1][n] << endl ; \n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 320000\nusing namespace std;\nlong long n,A,B;\nlong long L[N],R[N];\nlong long f[5200][5200]; \nlong long a[5200];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&A,&B);\n\tif(n==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tlong long x;\n\t\tscanf(\"%d\",&x);\n\t\ta[x]=i;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tfor(long long j=i+1;j<=n;j++)if(a[j]<a[i]){L[i]=j;break;}\n\t\tfor(long long j=i-1;j>=1;j--)if(a[j]>a[i]){R[i]=j;break;}\n\t}\n\tfor(int i=0;i<=5100;i++){\n\t\tfor(int j=0;j<=5100;j++)f[i][j]=1000000000000000LL;\n\t}\n\tf[0][n+1]=0;\n\tfor(long long i=0;i<n;i++){\n\t\tfor(long long j=n+1;j>i;j--){\n\t\t\tif(L[i]<j)f[i+1][j]=min(f[i][j]+B,f[i+1][j]);\n\t\t\telse f[i+1][j]=min(f[i][j],f[i+1][j]);\n\t\t\tif(R[j]>i)f[i][j-1]=min(f[i][j]+A,f[i][j-1]);\n\t\t\telse f[i][j-1]=min(f[i][j],f[i][j-1]);\n\t\t}\n\t}\n\tlong long ans=1000000000000000LL;\n\tfor(long long i=0;i<=n;i++)ans=min(ans,f[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long Inf=1e18;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint main() {\n\tint n=gi(),a=gi(),b=gi();\n\tvector<int> p(n+1);\n\tfor(int i=1;i<=n;i++) p[i]=gi();\n\tvector<int> q(n+1);\n\tfor(int i=1;i<=n;i++) q[p[i]]=i;\n\tvector<long long> f(1,0);\n\tfor(int i=1;i<=n;i++) {\n\t\tvector<long long> new_f(i+1,Inf);\n\t\tfor(int j=0;j<i;j++) {\n\t\t\tif(q[i]>q[j]) {\n\t\t\t\tnew_f[i]=min(new_f[i],f[j]);\n\t\t\t\tnew_f[j]=min(new_f[j],f[j]+b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnew_f[j]=min(new_f[j],f[j]+a);\n\t\t\t}\n\t\t}\n\t\tswap(f,new_f);\n\t}\n\tprintf(\"%lld\\n\",*min_element(f.begin(),f.end()));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * This line was copied from template\n * This is dsol.cpp\n * \n * @author: Nikolay Kalinin\n * @date: Sat, 23 Mar 2019 16:34:52 +0300\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 5005;\nconst ll inf = 1e18;\n\nll ans[maxn];\nint a[maxn];\nint n, A, B;\n\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &A, &B);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 0; i <= n; i++) ans[i] = inf;\n    ans[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        ll ourbest = inf;\n        for (int t = 0; t < a[i]; t++)\n        {\n            ourbest = min(ourbest, ans[t]);\n            ans[t] += A;\n        }\n        ans[a[i]] = ourbest;\n        for (int t = a[i] + 1; t <= n; t++) ans[t] += B;\n//         for (int t = 0; t <= n; t++) cout << ans[t] << ' ';\n//         cout << endl;\n    }\n    cout << *min_element(ans, ans + n + 1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define N 5010\n#define inf 1000000000000000000ll\nint n,A,B;long long f[N][N],ans;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=0;i<=n;i++) for(int j=0;j<=n;j++) f[i][j]=inf; f[0][0]=0;\n\tfor(int i=1,x;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(x>j) f[i][j]=min(f[i][j],f[i-1][j]+A),f[i][x]=min(f[i][x],f[i-1][j]);\n\t\t\telse f[i][j]=min(f[i][j],f[i-1][j]+B);\n\t}\n\tans=inf;\n\tfor(int i=0;i<=n;i++) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int maxn = 5e3 + 10;\nconst long long max_val = 1LL << 62;\n \nlong long dp[maxn * 2], dp_min[maxn * 2];\nint p[maxn];\n \nlong long cost(int p1, int p2, int A, int B) {\n    if (p1 == p2) return 0;\n    else if (p1 > p2) return B;\n    else return A;\n}\n \nint main()\n{\n    int N, A, B, x;\n    cin >> N >> A >> B;\n    for (int i = 1; i <= N; i++) {\n        cin >> x;\n        p[x] = i;\n    }\n    for (int i = 1; i <= N; i++) for (int j = 0; j <= N; j++) dp[j] = max_val;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <=  N; j++) {\n            dp[j] = dp_min[j] + cost(p[i], j, A, B);\n        }\n        dp_min[0] = dp[0];\n        for (int j = 1; j <=  N; j++) dp_min[j] = min(dp_min[j - 1], dp[j]);\n    }\n    cout << dp_min[ N] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nusing Int = __int128_t;\nInt abs128(Int val){return val<0?-val:val;}\n\nostream &operator<<(ostream &os,Int val){\n  if(ostream::sentry(os)){\n    __uint128_t tmp=abs128(val);\n    char buf[64];\n    char *d=end(buf);\n    do{\n      --d;\n      *d=char(tmp%10+'0');\n      tmp/=10;\n    }while(tmp);\n    if(val<0) *--d='-';\n    Int len=end(buf)-d;\n    if(os.rdbuf()->sputn(d,len)!=len){\n      os.setstate(ios_base::badbit);\n    }\n  }\n  return os;\n}\n\nistream &operator>>(istream &is,Int &val){\n  string s;\n  is>>s;\n  val=0;\n  for(Int i=0;i<(Int)s.size();i++)\n    if(isdigit(s[i])) val=val*10+s[i]-'0';\n  if(s[0]=='-') val*=-1;\n  return is;\n}\n\n\n//INSERT ABOVE HERE\nconst Int MAX = 5050;\nconst Int INF = 1e30;\nInt dp[MAX][MAX];\nInt dp2[MAX][MAX];\nInt dp3[MAX][MAX];\n\nInt p[MAX];\nInt cnt1[MAX],cnt2[MAX];\n\nsigned main(){\n  Int n,a,b;\n  cin>>n>>a>>b;\n  for(Int i=0;i<n;i++) cin>>p[i];\n  \n  for(Int i=0;i<MAX;i++){\n    for(Int j=0;j<MAX;j++){\n      dp[i][j]=INF;\n      dp2[i][j]=0;\n      dp3[i][j]=0;\n    }    \n  }\n  \n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=0;i<n;i++){\n      for(Int j=p[i];j<=n+1;j++)\n        dp2[p[i]-1][j]=i-(cnt1[p[i]]+cnt2[j]);\n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=n-1;i>=0;i--){\n      for(Int j=0;j<=p[i];j++)\n        dp3[j][p[i]+1]=(n-(i+1))-(cnt2[p[i]]+cnt1[j]);\n      \n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  \n  dp[0][n+1]=0;\n  for(Int w=n+1;w>0;w--){\n    for(Int i=0;i+w<=n+1;i++){      \n      Int j=i+w;\n      // ikkai \n      chmin(dp[i+1][j],dp[i][j]+b);\n      chmin(dp[i][j-1],dp[i][j]+a);\n      \n      // mettya mawasu\n      chmin(dp[i+1][j],dp[i][j]+dp2[i][j]*a);\n      chmin(dp[i][j-1],dp[i][j]+dp3[i][j]*b);\n    }\n  }\n  \n  Int ans=INF;\n  for(Int i=0;i<=n;i++) chmin(ans,dp[i][i+1]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 100000000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define R(i,a,b) for (int i=(a);i<(b);i++)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define int ll\n#define N 5055\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,ans,A,B,sum[N][N],f[N],p[N];\ninline void cm(int &x,int k){x=(k<x)?k:x;}\nsigned main(){\n\tn=read();A=read();B=read();\n\tF(i,1,n){\n\t\tp[i]=read();\n\t\tF(j,1,n) sum[i][j]=sum[i-1][j];F(j,p[i],n) sum[i][j]++;\n\t}\n\tans=inf;\n\tF(i,1,n){\n\t\tf[p[i]]=(p[i]-1)*B;\n\t\tF(j,1,i-1){\n\t\t\tif (p[j]>p[i]) continue;\n\t\t\tint t=p[j],p1=(sum[j][p[i]]-sum[j][t]);\n\t\t\tcm(f[p[i]],f[t]+A*p1+B*(p[i]-t-p1-1));\n\t\t}\n\t\tint p1=sum[i][n]-sum[i][p[i]];\n\t\tcm(ans,f[p[i]]+A*p1+B*(n-p[i]-p1));\n\t}\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<math.h>\n#include<list>\n#include<complex>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll>\n#define vvll vector<vector<ll>>\n#define vvvll vector<vector<vector<ll>>>\n#define vtype(type) vector<type>\n#define vvtype(type) vector<vector<type>>\n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\nstruct wall\n{\n\tlong long r; ll c;\n\tbool operator<(const wall& rhs) const {\n\t\tif (r != rhs.r) {\n\t\t\treturn r < rhs.r;\n\t\t}\n\t\telse {\n\t\t\treturn c < rhs.c;\n\t\t}\n\t}\n};\n\n\nll const MOD = 1e9 + 7;\n\n\nll mod_p(ll x, ll y) {\n\tx %= MOD;\n\ty %= MOD;\n\treturn (x + y + MOD) % MOD;\n}\n\nll mod_m(ll x, ll y) {\n\tx %= MOD;\n\ty %= MOD;\n\treturn x * y%MOD;\n}\n\nll mod_pow(ll x, ll t) {\n\tx %= MOD;\n\tif (t == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tll v = mod_pow(x, t / 2);\n\t\tif (t % 2 == 0) {\n\t\t\treturn v * v % MOD;\n\t\t}\n\t\telse {\n\t\t\treturn v * v%MOD * x %MOD;\n\t\t}\n\t}\n}\n\nll mod_inv(ll x) {\n\treturn mod_pow(x, MOD - 2);\n}\n\nll const MAX = 5e3 + 5;\nvvll dp(MAX, vll(MAX, 1e17));\nvll p(MAX);\n\nint main() {\n\tll n;\n\tcin >> n;\n\tll a, b;\n\tcin >> a >> b;\n\tREP(i, 1, n) {\n\t\tcin >> p[i];\n\t}\n\tdp[0][0] = 0;\n\tREP(i, 1, n) {\n\t\tREP(j, 0, n) {\n\t\t\tif (j < p[i]) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + a);\n\t\t\t\tdp[i][p[i]] = min(dp[i][p[i]], dp[i - 1][j]);\n\t\t\t}\n\t\t\telse if (j >= p[i]) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1e17;\n\tREP(j, 1, n) {\n\t\tans = min(dp[n][j], ans);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\n// const int mod = 1e9 + 7;\n// inline int Add(int x) { return x >= mod ? x - mod : x; }\n// inline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\n// inline int Sub(int x) { return x < 0 ? x + mod : x; }\n// inline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\n// inline int Mul(int x, int y) { return (int)((li)x * y % mod); }\n\n// int Pow(int x, int y) {\n//   int z = 1;\n//   for (; y; y >>= 1) {\n//     if (y & 1) z = Mul(z, x);\n//     x = Mul(x, x);\n//   }\n//   return z;\n// }\n\n// ----------------------------------------\n\ntypedef long long li;\nconst int maxn = 5000;\nconst li inf = 1e18;\nint n, A, B;\nint p[maxn];\nli dp[maxn + 1], dp2[maxn + 1];\n\nvoid Min(li &a, li b) {\n  if (b < a) a = b;\n}\n\nint main(void) {\n  scanf(\"%d%d%d\", &n, &A, &B);\n  swap(A, B);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", p + i), --p[i];\n  }\n  FILL(dp, n + 1, 0);\n\n  for (int i = 0; i < n; ++i) {\n    FILL(dp2, n + 1, 0x3f);\n    for (int j = 0; j <= n; ++j) {\n      if (j < n) Min(dp[j + 1], dp[j]);\n      if (j == p[i]) {\n        Min(dp2[j + 1], dp[j]);\n      } else if (j < p[i]) {\n        Min(dp2[j], dp[j] + B);\n      } else {\n        Min(dp2[j], dp[j] + A);\n      }\n    }\n    COPY(dp2, n + 1, dp);\n    // for (int j = 0; j <= n; ++j) {\n    //   printf(\"dp[%d][%d] = %lld\\n\", i + 1, j, dp[j]);\n    // }\n  }\n  for (int j = 0; j < n; ++j) {\n    Min(dp[j + 1], dp[j]);\n  }\n\n  li ans = dp[n];\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst long long INF=1e18;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; ll A,B; cin >> N >> A >> B;\n    vector<int> p(N);\n    for (int i=0;i<N;++i) cin >> p[i];\n    vector<int> L(N+1,N+1),R(N+1,0);\n    for (int i=0;i<N;++i){\n        for (int j=0;j<N;++j){\n            if (j<i&&p[j]>p[i]) L[p[i]]=min(L[p[i]],p[j]);\n            if (j>i&&p[j]<p[i]) R[p[i]]=max(R[p[i]],p[j]);\n        }\n    }\n    vector<vector<ll>> dp(N+2,vector<ll>(N+2,INF));\n    dp[0][N+1]=0;\n    for (int i=0;i<=N;++i){\n        for (int j=N+1;j>i+1;--j){\n            dp[i+1][j]=min(dp[i+1][j],dp[i][j]+(L[i+1]>=j?0:B));\n            dp[i][j-1]=min(dp[i][j-1],dp[i][j]+(R[j-1]<=i?0:A));\n        }\n    }\n    ll ans=INF;\n    for (int i=0;i<=N;++i) ans=min(ans,dp[i][i+1]);\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n, a, b, num[5007], dp[5007][5007], res = 1e18;\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nsigned main()\n{\n\tn = read();\n\ta = read();\n\tb = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tnum[i] = read();\n\tmemset(dp, 0x3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tif (num[i] > j)\n\t\t\t{\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + a);\n\t\t\t\tdp[i][num[i]] = min(dp[i][num[i]], dp[i - 1][j]);\n\t\t\t}\n\t\t\telse dp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n\tfor (int i = 0; i <= n; i++)\n\t\tres = min(res, dp[n][i]);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint read(){\n\tint x=0,f=1;\n    char c=getchar();\n    while(c<'0'||c>'9'){\n    \tif(c=='-') f=-1;\n    \tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\n#define maxn 5005\ntypedef long long ll;\nint n,a[maxn],dp[maxn],pre[maxn],posi[maxn];\nll A,B;\nbool vis[maxn]; \nvoid init(){\n\tn=read();\n\tscanf(\"%lld%lld\",&A,&B);\n\tfor(int i=1;i<=n;i++) a[i]=read(),posi[a[i]]=i;\n\t\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tif(a[j]<a[i]){\n\t\t\t\tif(dp[j]+1>dp[i]){\n\t\t\t\t\tdp[i]=dp[j]+1;\n\t\t\t\t\tpre[i]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxx=0,maxid;\n    for(int i=1;i<=n;i++) if(dp[i]>maxx) maxx=dp[i],maxid=i;\n    int now=maxid;\n    if(maxx==0) vis[1]=1;\n    while(now){\n    \tvis[now]=1; \n    \tnow=pre[now];\n\t}\n\tll ans=0,calc;\n\tfor(int i=1;i<=n;i++){\n\t\tif(vis[i]) continue;\n\t\tcalc=10000000;\n\t    int pos=a[i];\n\t    while(!vis[posi[pos]]&&pos>=1) pos--;\n\t    if(vis[posi[pos]]){\n\t    \tint t=posi[pos];\n\t    \tif(t>i){\n\t    \tll val1=A;\n\t\t\tll val2=(posi[pos]-i)*B;\n\t\t\tcalc=min(val1,val2);\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll val1=B;\n\t\t\t\tll val2=(i-posi[pos]-1)*A;\n\t\t\t\tcalc=min(val1,val2);\n\t\t\t}\n\t\t}\n\t\tpos=a[i];\n\t    while(!vis[posi[pos]]&&pos<=n) pos++;\n\t    if(vis[posi[pos]]){\n\t    \tint t=posi[pos];\n\t    \tif(t>i){\n\t    \tll val1=A;\n\t\t\tll val2=(posi[pos]-i-1)*B;\n\t\t\tcalc=min(calc,val2);\n\t\t\tcalc=min(calc,val1);\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll val1=B;\n\t\t\t\tll val2=(i-posi[pos])*A;\n\t\t\t\tcalc=min(calc,val1);\n\t\t\t\tcalc=min(calc,val2);\n\t\t\t}\n\t\t}\n\t\tans+=calc;\n\t}\n\tprintf(\"%lld\",ans);\n}\nint main(){\n    init();\n    \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 5e3 + 5;\nconst int maxm = 1e7 + 5;\n\nconst int mod = 1e9 + 7;\nint n , A , B;\nint pos[maxn] , a[maxn];\nint m = 0;\nll f[maxn][maxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\"))\n        freopen(taskname\".INP\",\"r\",stdin),\n        freopen(taskname\".OUT\",\"w\",stdout);\n    cin >> n >> A >> B;\n    for(int i = 1 ; i <= n ; ++i){\n        cin >> a[i];\n        pos[a[i]] = i;\n    }\n    memset(f,123,sizeof  f);\n    f[1][0] = 0;\n    ll res = 1e18;\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = 0 ; j < i ; ++j){\n            if(pos[i] > pos[j]){\n                f[i + 1][j] = min(f[i + 1][j] , f[i][j] + B);\n                f[i + 1][i] = min(f[i][j] , f[i + 1][i]);\n            }else{\n                f[i + 1][j] = min(f[i + 1][j] , f[i][j] + A);\n            }\n        }\n    }\n    cout << *min_element(f[n+1],f[n+1]+n+1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 5011;\nint n, a[maxn], pos[maxn];\nll dp[maxn][maxn];\nint ia[maxn];\nint main()\n{\n\tint A, B;\n\tgeti(n);\n\tgetii(A, B);\n\tfor (int i=1; i<=n; i++) geti(a[i]), ia[a[i]] = i;\n\tmemset(dp, 20, sizeof(dp));\n\tdp[n+1][n] = 0;\n\tfor (int i=n; i>=1; i--)\n\t{\n\t\tdp[i][i-1] = 0;\n\t\tpair<int,int> mn = MP(ia[i], i);\n\t\tpair<int,int> mx = mn;\n\t\tfor (int j=i; j<=n; j++)\n\t\t{\n\t\t\tmx = max(mx, MP(ia[j], j));\n\t\t\tmn = min(mn, MP(ia[j], j));\n\t\t\tdp[i][j] = min(dp[i][j], dp[i+1][j]+B*(mn.SS!=i));\n\t\t\tdp[i][j] = min(dp[i][j], dp[i][j-1]+A*(mx.SS!=j));\n\t\t}\n\t}\n\tcout<<dp[1][n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 10000000000000002\n\n\n\n\nint main(){\n\n\tint N;\n\tcin>>N;\n\t\n\tlong long A,B;\n\tcin>>A>>B;\n\t\n\tvector<int> P(N);\n\tfor(int i=0;i<N;i++)cin>>P[i];\n\tP.insert(P.begin(),0);\n\tP.push_back(N+1);\n\t\n\tvector<long long> dp(P.size(),Inf);\n\tdp[0] = 0LL;\n\t\n\tfor(int i=1;i<P.size();i++){\n\t\tlong long t = 0LL;\n\t\tfor(int j=i-1;j>=0;j--){\n\t\t\tif(P[j]>P[i]){\n\t\t\t\tt += A;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i] = min(dp[i],dp[j]+t);\n\t\t\t\tt += B;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp.back()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: D.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nll inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint s[5005][5005];\nint a[5005],at[5005];\nll dp[5005][5005];\nint have(int lim,int l,int r){\n\treturn s[lim][r]-s[lim][l-1];\n}\nint notall(int lim,int l,int r){\n\treturn (s[lim][r]-s[lim][l-1])!=(r-l+1);\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint n,x,y;\n\tread(n,x,y);\n\tfor(int i=1;i<=n;++i){\n\t\tread(a[i]);\t\n\t\tat[a[i]]=i;\n\t\tfor(int j=1;j<=n;++j)s[i][j]=s[i-1][j];\n\t\tfor(int j=a[i];j<=n;++j)++s[i][j];\n\t}\n\tfor(int i=0;i<=n;++i)for(int j=i+1;j<=n+1;++j)dp[i][j]=inf;\n\tdp[0][n+1]=0;\n\tll ans=inf;\n\tfor(int i=0;i<=n;++i){\n\t\tfor(int j=n+1;j>=i+2;--j){\n\t\t\tchkmin(dp[i+1][j],dp[i][j]+(have(at[i+1],i+2,j-1)?y:0));\t\t\n\t\t\tchkmin(dp[i][j-1],dp[i][j]+(notall(at[j-1],i+1,j-2)?x:0));\t\t\n\t\t}\n\t\tchkmin(ans,dp[i][i+1]);\n\t}\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e+18\nusing namespace std;\n\nclass BIT{\n\tvector<int> bit;\npublic:\n\tBIT(int siz){\n\t\tbit.resize(siz + 1,0);\n\t}\n\tvoid add(int i,int x){\n\t\twhile(i < bit.size()){\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i){\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n};\n\nsigned main(){\n\tint n,a,b,ans = INF,p[5010],ind[5010];\n\tcin >> n >> a >> b;\n\tBIT bit(n + 10);\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> p[i];\n\t\tbit.add(i + 1,1);\n\t\tind[p[i] - 1] = i;\n\t}\n\tint dp[5010][5010];\n\tfor(int i = 0;i <= n;i++){\n\t\tfor(int j = 0;j <= n;j++) dp[i][j] = INF;\n\t}\n\tdp[0][n - 1] = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = n - 1;j >= i;j--){\n\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\tif(i == j) ans = min(ans,dp[i][j]);\n\t\t\telse{\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j],dp[i][j] + (bit.sum(ind[i]) ? b : 0));\n\t\t\t\tdp[i][j - 1] = min(dp[i][j - 1],dp[i][j] + ((j - i - bit.sum(ind[j])) ? a : 0));\n\t\t\t}\n\t\t\tbit.add(ind[j] + 1,-1);\n\t\t}\n\t\tfor(int j = n - 1;j >= i;j--) bit.add(ind[j] + 1,1);\n\t\tbit.add(ind[i] + 1,-1);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL A, B;\nint P[5011];\nint R[5011];\nLL dp[5011][5011]; // 200MB\n\nint low[5011];\n\nvoid MAIN() {\n    scanf(\"%d%lld%lld\", &N, &A, &B);\n    REP (i, N) scanf(\"%d\", P+i), P[i]--;\n    REP (i, N) R[P[i]] = i;\n\n    memset(dp, 0x3f, sizeof dp);\n    REP (i, N+1) {\n\tdp[i][0] = 0;\n\tdp[0][i] = 0;\n\tdp[1][i] = 0;\n    }\n\n    for (int i=1; i<=N; i++) {\n\tREP (k, i) if (P[k] > P[i-1]) low[P[k]]++;\n\n\tfor (int h=1; h<N; h++) {\n\t    if (i-1 <= R[h]) {\n\t\tdp[i][h] = dp[i][h-1];\n\t    } else {\n\t\tamin(dp[i][h], dp[i][h-1] + A);\n\t\tamin(dp[i][h], dp[R[h]][h-1] + low[h] * B);\n\t    }\n\t}\n    }\n\n    printf(\"%lld\\n\", dp[N][N-1]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=5010;\nconst LL INF=1e15;\nint n,cl,cr,a[N],c[N];\nLL dp[N][N];\nvoid main() {\n    R(n,cl,cr);\n    REP1(i,1,n) R(a[i]);\n    REP1(i,1,n) c[i]=(a[i]>i?cl:cr);\n    REP1(i,1,n+1) REP1(j,1,n) dp[i][j]=INF;\n    dp[1][1]=0;\n    REP1(i,1,n) REP1(j,1,n) {\n        auto me=dp[i][j];\n        if ( me==INF) continue;\n        chkmin(dp[i+1][j],me+c[i]);\n        if ( j<=a[i] ) chkmin(dp[i+1][a[i]],me);\n    }\n    LL ans=INF;\n    REP1(i,1,n) chkmin(ans,dp[n+1][i]);\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\n\nconst int N=5050;\nint n, a, b, p[N];\ns64 f[N];\nint main() {\n\tn=rd(), a=rd(), b=rd();\n\tfor(int i=1; i<=n; ++i) p[i]=rd();\n\tp[n+1]=n+1;\n\tfor(int i=1; i<=n+1; ++i) {\n\t\ts64 sum=0;\n\t\tf[i]=1e18;\n\t\tfor(int j=i; j--; ) {\n\t\t\tif(p[j]<p[i]) cmin(f[i], f[j]+sum);\n\t\t\tsum+=p[j]<p[i]?b:a;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n+1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ull=unsigned long long;\nusing uint=unsigned int;\nusing pcc=pair<char,char>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing pdd=pair<double,double>;\nusing tuplis=pair<ll,pll>;\nusing tuplis2=pair<pll,ll>;\ntemplate<class T> using pq=priority_queue<T,vector<T>,greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MOD=1000000007;\nconst ll MODD=998244353;\nconst int INF=0x3fffffff;\nconst double DINF=numeric_limits<double>::infinity();\nconst double EPS=1e-7;\nconst vector<ll> four={0,1,0,-1,0};\nconst vector<ll> eight={0,1,1,-1,1,0,-1,-1,0};\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep1(n) for(ll i=0;i<n;++i)\n#define _rep2(i,n) for(ll i=0;i<n;++i)\n#define _rep3(i,a,b) for(ll i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_rep4,_rep3,_rep2,_rep1)(__VA_ARGS__)\n#define _rrep1(n) for(ll i=n-1;i>=0;i--)\n#define _rrep2(i,n) for(ll i=n-1;i>=0;i--)\n#define _rrep3(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrep4,_rrep3,_rrep2,_rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto& i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(range(__VA_ARGS__),double(0))\n#define _range(i) (i).begin(),(i).end()\n#define _range2(i,k) (i).begin(),(i).begin()+k\n#define _range3(i,a,b) (i).begin()+a,(i).begin()+b\n#define range(...) _overload3(__VA_ARGS__,_range3,_range2,_range)(__VA_ARGS__)\n#define _rrange(i) (i).rbegin(),(i).rend()\n#define _rrange2(i,k) (i).rbegin(),(i).rbegin()+k\n#define _rrange3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rrange(...) _overload3(__VA_ARGS__,_rrange3,_rrange2,_rrange)(__VA_ARGS__)\n#define yes(i) out(i?\"yes\":\"no\")\n#define Yes(i) out(i?\"Yes\":\"No\")\n#define YES(i) out(i?\"YES\":\"NO\")\n#define Possible(i) out(i?\"Possible\":\"Impossible\")\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\n__attribute__((constructor)) void SETTINGS(){cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(20);};\ninline constexpr ll gcd(ll a,ll b){if(!a||!b)return 0;if(a<b){ll c=a;a=b;b=c;}while(b){ll c=b;b=a%b;a=c;}return a;}\ninline constexpr ll lcm(ll a,ll b){if(!a||!b)return 0;return a*b/gcd(a,b);}\ntemplate<class T>inline constexpr T min(vector<T>& v){return *min_element(range(v));}\ninline char min(string& v){return *min_element(range(v));}\ntemplate<class T>inline constexpr T max(vector<T>& v){return *max_element(range(v));}\ninline char max(string& v){return *max_element(range(v));}\ninline constexpr ll intpow(const ll&a,const ll&b){if(b==0)return 1;ll ans=intpow(a,b/2);return ans*ans*(b&1?a:1);}\ninline constexpr ll modpow(const ll&a,const ll&b,const ll&mod=MOD){if(b==0)return 1;ll ans=modpow(a,b/2,mod);ans=ans*ans%mod;if(b&1)ans=ans*a%mod;return ans;}\ntemplate<typename T>\ninline constexpr bool update_min(T& mn,const T& cnt){if(mn>cnt){mn=cnt;return 1;}else return 0;}\ntemplate<typename T>\ninline constexpr bool update_max(T& mx,const T& cnt){if(mx<cnt){mx=cnt;return 1;}else return 0;}\ninline void in() {}\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator >> (istream& is, array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p);\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec);\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p);\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& vec){for(T& x: vec) is >> x;return is;}\ntemplate<class T,class L>\nistream& operator >> (istream& is, pair<T,L>& p){is >> p.first;is >> p.second;return is;}\ntemplate<class T>\nostream& operator << (ostream& os, vector<T>& vec){os << vec[0];rep(i,1,vec.size()){os << ' ' << vec[i];}return os;}\ntemplate<class T>\nostream& operator << (ostream& os, deque<T>& deq){os << deq[0];rep(i,1,deq.size()){os << ' ' << deq[i];}return os;}\ntemplate<class T,class L>\nostream& operator << (ostream& os, pair<T,L>& p){os << p.first << \" \" << p.second;return os;}\ntemplate<class T,class L>\npair<T,L> operator + (pair<T,L> a, pair<T,L> b){return {a.first + b.first, a.second + b.second};}\ntemplate <class Head, class... Tail>\ninline void in(Head&& head,Tail&&... tail){cin>>head;in(move(tail)...);}\ntemplate <class T>\ninline bool out(T t){cout<<t<<'\\n';return 0;}\ninline bool out(){cout<<'\\n';return 0;}\ntemplate <class Head, class... Tail>\ninline bool out(Head head,Tail... tail){cout<<head<<' ';out(move(tail)...);return 0;}\ntemplate <class T>\ninline void err(T t){cerr<<t<<'\\n';}\ninline void err(){cerr<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void err(Head head,Tail... tail){cerr<<head<<' ';out(move(tail)...);}\n\nll n=5001,a,b;\nvector<ll>p;\nvv(ll,mem,n,n,LINF);\nll dp(ll at,ll max){\n    if(mem[at][max]!=LINF)return mem[at][max];\n    if(at==n)return mem[at][max]=0;\n    if(max<p[at])return mem[at][max]=min(dp(at+1,p[at]),dp(at+1,max)+a);\n    else return mem[at][max]=dp(at+1,max)+b;\n}\nsigned main(){\n    in(n,a,b);\n    p.resize(n);\n    in(p);\n    out(dp(0,0));\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int, int >\n#define F first\n#define S second\n#define int  long long int\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\nusing namespace std;\n/// age ye mosh dp ro baze dashti dp tedad baz shodeye baste nashode yadet nare !!\n/// joooob zadam\nconst int N=5003;\nll dp[N][N];\nll a[N];\nint32_t main(){\n    ll n,a1,b;\n    cin >> n >> a1 >> b ;\n    for (int i=1;i<=n;i++){\n        cin >> a[i];\n    }\n    a[0]=0;\n    memset(dp,69,sizeof dp);\n    for (int i=0;i<N;i++){\n        dp[0][i]=0;\n    }\n    for (int i=1;i<=n;i++){\n        for (int j=0;j<N;j++){\n            ll l=0;\n            for (int k=i;k>0;k--){\n                if (a[k]<j){\n                    l=k;\n                    break;\n                }\n            }\n            if (!l){\n                dp[i][j]=0;\n                continue;\n            }\n            dp[i][j]=dp[l-1][j]+b;\n            ll z=0;\n            for (int k=1;k<l;k++){\n                if (a[k]>a[l] && a[k]<j){\n                    z++;\n                }\n            }\n            dp[i][j]=min(dp[i][j],dp[l-1][a[l]]+z*a1);\n            //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n    }\n    cout << dp[n][N-1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint a;\nlong long int b,c;\nint x[5010];\nstd::pair<int,int> start[5010][5010];\nlong long int check[5010][5010];\nlong long int func(int s, int t)\n{\n\tif(s==t) return 0;\n\tif(check[s][t]!=-1) return check[s][t];\n\t\n\tif(start[s][t].first==0)\n\t{\n\t\tif(start[s][t+1].first!=0) start[s][t].first = start[s][t+1].first;\n\t\telse\n\t\t{\n\t\t\tfor(int i=start[s-1][t].first;i<=a;i++)\n\t\t\t{\n\t\t\t\tif(x[i]<s) continue;\n\t\t\t\tif(x[i]>t) continue;\n\t\t\t\tstart[s][t].first = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(start[s][t].second==0)\n\t{\n\t\tif(start[s-1][t].second!=0) start[s][t].second = start[s-1][t].second;\n\t\telse\n\t\t{\n\t\t\tfor(int i=start[s][t+1].second;i>=1;i--)\n\t\t\t{\n\t\t\t\tif(x[i]<s) continue;\n\t\t\t\tif(x[i]>t) continue;\n\t\t\t\tstart[s][t].second = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(x[start[s][t].first]==s) return func(s+1,t);\n\tif(x[start[s][t].second]==t) return func(s,t-1);\n\tlong long int s1 = func(s+1,t)+c;\n\tlong long int s2 = func(s,t-1)+b;\n\treturn check[s][t] = s1<s2?s1:s2;\n}\nint main()\n{\n\tscanf(\"%d%lld%lld\",&a,&b,&c);\n\tstart[1][a].first = 1;\n\tstart[1][a].second = a;\n\tfor(int i=1;i<=a;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=a;i++) for(int j=1;j<=a;j++) check[i][j] = -1;\n\tprintf(\"%lld\",func(1,a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MOD = 1e9+7;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nint n;\nll a, b;\nint arr[5010];\nll D[5010][5010];\n\nint main() {\n    int i, j;\n\n    scanf(\"%d%lld%lld\",&n,&a,&b);\n    for (i=1;i<=n;i++) {\n        scanf(\"%d\",&arr[i]);\n    }\n    memset(D,0x3f,sizeof(D));\n    D[0][0] = 0;\n    for (i=1;i<=n;i++) {\n        for (j=0;j<arr[i];j++) {\n            D[i][arr[i]] = min(D[i][arr[i]],D[i-1][j]);\n            D[i][j] = min(D[i][j],D[i-1][j]+a);\n        }\n        for (j=arr[i]+1;j<=n;j++) {\n            D[i][j] = min(D[i][j],D[i-1][j]+b);\n        }\n    }\n    ll mini = LINF;\n    for (i=0;i<=n;i++) mini=min(mini,D[n][i]);\n    printf(\"%lld\\n\",mini);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<sstream>\n#include<set>\n#include<vector>\n#include<stack>\n#include<map>\n#include<queue>\n#include<deque>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<functional>\nusing namespace std;\n\n#define N 10005\n#define INF ((long long)1<<60)\n\nint a[N],n;\n\nstruct Edge\n{\n    int from,to;long long cap,flow;\n    Edge(int u,int v,long long c,long long f):from(u),to(v),cap(c),flow(f){}\n};\n\nstruct Dinic\n{\n\tint n,m,s,t;//结点数，边数（包括反向弧），源点编号，汇点编号\n\tvector<Edge>edges;//边表，dges[e]和dges[e^1]互为反向弧\n\tvector<int>G[N];//邻接表，G[i][j]表示结点i的第j条边在e数组中的编号\n\tbool vis[N]; //BFS的使用\n\tint d[N]; //从起点到i的距离\n\tint cur[N]; //当前弧下标\n\t\n\tvoid addedge(int from,int to,long long cap)\n\t{\n\t    edges.push_back(Edge(from,to,cap,0));\n\t    edges.push_back(Edge(to,from,0,0));\n\t    int  m=edges.size();\n\t    G[from].push_back(m-2);\n\t    G[to].push_back(m-1);\n\t}\n\t\n\tbool bfs()\n\t{\n\t    memset(vis,0,sizeof(vis));\n\t    queue<int>Q;\n\t    Q.push(s);\n\t    d[s]=0;\n\t    vis[s]=1;\n\t    while(!Q.empty())\n\t    {\n\t        int x=Q.front();Q.pop();\n\t        for(int i=0;i<G[x].size();i++)\n\t        {\n\t            Edge&e=edges[G[x][i]];\n\t            if(!vis[e.to]&&e.cap>e.flow)//只考虑残量网络中的弧\n\t            {\n\t                vis[e.to]=1;\n\t                d[e.to]=d[x]+1;\n\t                Q.push(e.to);\n\t            }\n\t        }\n\t\n\t    }\n\t    return vis[t];\n\t}\n\t\n\tlong long dfs(int x,long long a)//x表示当前结点，a表示目前为止的最小残量\n\t{\n\t    if(x==t||a==0)return a;//a等于0时及时退出，此时相当于断路了\n\t    long long flow=0,f;\n\t    for(int&i=cur[x];i<G[x].size();i++)//从上次考虑的弧开始，注意要使用引用，同时修改cur[x]\n\t    {\n\t        Edge&e=edges[G[x][i]];//e是一条边\n\t        if(d[x]+1==d[e.to]&&(f=dfs(e.to,min(a,e.cap-e.flow)))>0)\n\t        {\n\t            e.flow+=f;\n\t            edges[G[x][i]^1].flow-=f;\n\t            flow+=f;\n\t            a-=f;\n\t            if(!a)break;//a等于0及时退出，当a!=0,说明当前节点还存在另一个曾广路分支。\n\t\n\t        }\n\t    }\n\t    return flow;\n\t}\n\t\n\tlong long Maxflow(int s,int t)//主过程\n\t{\n\t    this->s=s,this->t=t;\n\t    long long flow=0;\n\t    while(bfs())//不停地用bfs构造分层网络，然后用dfs沿着阻塞流增广\n\t    {\n\t        memset(cur,0,sizeof(cur));\n\t        flow+=dfs(s,INF);\n\t    }\n\t    return flow;\n\t}\n}A;\ninline int read(){\n\tint ret=0;bool f=0;char ch=getchar();\n\twhile(ch>'9'||ch<'0') f^=ch=='-',ch=getchar();\n\twhile(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();\n\treturn f?-ret:ret;\n}\nint main(){\n\tA.n=(n=read())<<1|1;int X=read(),Y=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\tfor (int i=1;i<=n;i++)\n\tA.addedge(0,i,X),A.addedge(n+i,A.n,Y);\n\tfor (int i=1;i<n;i++)\n\tfor (int j=i+1;j<=n;j++) if(a[i]>a[j])\n\tA.addedge(i,n+j,INF);\n\tprintf(\"%lld\\n\",A.Maxflow(0,A.n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 5010;\nconst int MOD = 1e9 + 7;\n\nint n, A, B;\nint p[N], pos[N], dp[N];\nint ca[N][N], cb[N][N], t[N][N];\nint tree[N];\n\nvoid Add(int pos)\n{\n    while (pos < N)\n    {\n        tree[pos]++;\n        pos = (pos | (pos - 1)) + 1;\n    }\n}\n\nint Get(int pos)\n{\n    int res = 0;\n    while (pos > 0)\n    {\n        res += tree[pos];\n        pos = (pos & (pos - 1));\n    }\n    return res;\n}\n\n#define Get(l, r) Get(r) - Get(l - 1)\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) cin >> p[i], pos[p[i]] = i;\n    n++;\n    pos[n] = n, p[n] = n;\n    for (int j = 0; j <= n; j++)\n    {\n        fill(tree, tree + N, 0);\n        for (int i = j + 1; i <= n; i++)\n        {\n            ca[j][i] = Get(0, pos[j]);\n            cb[j][i] = Get(pos[i], N);\n            t[j][i] = (Get(pos[j], pos[i]) == 0);\n            Add(pos[i]);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n    \tdp[i] = 1e18;\n    \tfor (int j = i - 1; j >= 0; j--)\n    \t{\n    \t\tif (pos[j] < pos[i])\n    \t\t{\n    \t\t    int CA = ca[j][i], CB = cb[j][i], T = t[j][i];\n    \t\t\tif (T)\n    \t\t\t{\n    \t\t\t\tdp[i] = min(dp[i], dp[j] + CA * A + CB * B);\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    cout << dp[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int N=5022;\nLL dp[N][N];\nint n,a,b,x[N],pos[N];\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]), pos[x[i]]=i;\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)dp[i][j]=1e18;\n    dp[0][0]=0;\n    for(int i=1;i<=n;i++){\n        LL mn=dp[i-1][0];\n        for(int j=0;j<=n+1;j++){\n            mn=min(mn,dp[i-1][j]);\n\n            if(j==pos[i]) dp[i][j]=mn;\n            else if(j<pos[i]) dp[i][j]=mn+min(1LL*b,1LL*a*(pos[i]-j));\n            else dp[i][j]=mn+min(1LL*a,1LL*b*(j-pos[i]));\n    \n            //printf(\"dp[%d][%d]=%lld\\n\", i,j,dp[i][j]);\n        }\n    }\n    LL ans=1e18;\n    for(int i=0;i<=n+1;i++)ans=min(ans,dp[n][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nint64_t dp[5005][5005];\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n = input<int>();\n    int X = input<int>();\n    int Y = input<int>();\n\n    vector<int> seq(n);\n\n    for (int i = 0; i != n; ++i) {\n        seq[i] = input<int>();\n    }\n\n    for (int i = 0; i != n + 3; ++i)\n        for (int j = 0; j != n + 3; ++j)\n            dp[i][j] = TYPEMAX(int64_t) / 3;\n\n    dp[0][0] = 0;\n    \n    for (int prefix = 0; prefix != n; ++prefix) {\n        for (int cur_max = 0; cur_max <= n; ++cur_max) {\n            if (seq[prefix] >= cur_max) {\n                dp[prefix + 1][seq[prefix]] = min(dp[prefix + 1][seq[prefix]], dp[prefix][cur_max]);\n                dp[prefix + 1][cur_max] = min(dp[prefix + 1][cur_max], dp[prefix][cur_max] + X);\n            } else {\n                dp[prefix + 1][cur_max] = min(dp[prefix + 1][cur_max], dp[prefix][cur_max] + Y);\n            }\n        }\n    }\n    // for (int a = n; a >= 0; --a)\n    //     for (int b = n; b >= 0; --b)\n    //         if (a + b >= n)\n    //             dp[a][b] = 0;\n    //         else {\n    //             dp[a][b] = TYPEMAX(int64_t);\n\n    //             bool cheap_a = true, cheap_b = true;\n\n    //             if (preca[a] < n - b)\n    //                 cheap_a = false;\n                \n    //             // for (int i = 0; i < where[a]; ++i)\n    //             //     if (seq[i] > a and seq[i] < n - b)\n    //             //         cheap_a = false;\n\n    //             if (precb[b] >= a)\n    //                 cheap_b = false;\n                \n    //             // for (int i = where[n - 1 - b] + 1; i < n; ++i)\n    //             //     if (seq[i] < n - 1 - b and seq[i] >= a)\n    //             //         cheap_b = false;\n                \n    //             if (cheap_a)\n    //                 dp[a][b] = dp[a + 1][b];\n    //             else if (cheap_b)\n    //                 dp[a][b] = dp[a][b + 1];\n    //             else\n    //                 dp[a][b] = min(dp[a + 1][b] + Y, dp[a][b + 1] + X);                    \n    //         }\n\n    int64_t ans = TYPEMAX(int64_t);\n    for (int i = 0; i <= n; ++i)\n        ans = min(ans, dp[n][i]);\n    \n    cout << ans << \"\\n\";\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nll INF = 1000000000000000000;\nstruct segtree{\n  ll M=1, INIT;\n  vector<ll> dat;\n  segtree(ll N, ll num){\n    INIT = num;\n    while(M<N) M*=2;\n    for(int i=0;i<M*2-1;i++)  dat.push_back(num);\n  }\n  void update(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] += x;\n    while(k>0) k = (k-1)/2, dat[k] = dat[k*2+1] + dat[k*2+2];\n  }\n  ll query(ll a, ll b=-1, ll k=0, ll l=0, ll r=-1){\n    if(r==-1) r = M;\n    if(b==-1) b = M;\n    if(r<=a || b<=l) return INIT;\n    if(a<=l && r<=b) return dat[k];\n    ll A = query(a, b, k*2+1, l, (l+r)/2);\n    ll B = query(a, b, k*2+2, (l+r)/2, r);\n    return A + B;\n  }\n};\nint main(int argc, char const *argv[]) {\n  ll n, A, B;std::cin >> n >> B >> A;\n  vll p(n);re(i, n) scanf(\"%lld\", &p[i]);\n  vll comb(n+1), rcomb(n+1);\n\n  vll idx(n+1);\n  for(int i=0;i<n;i++) idx[p[i]] = i;\n  for(int i=0;i<n;i++){\n    ll cnt = 0;\n    for(int j=i;j<n;j++, cnt++) if(p[j]!=p[i]+cnt) break;\n    comb[p[i]] = cnt;\n    cnt = 0;\n    for(int j=i;j>=0;j--, cnt++) if(p[j]!=p[i]-cnt) break;\n    rcomb[p[i]] = cnt;\n  }\n  vll tento(n+1);\n  vll rtento(n+1);\n  segtree l(n+1, 0), r(n+1, 0);\n  for(int i=0;i<n;i++){\n    ll q = l.query(p[i], n+1);\n    tento[p[i]] = q;\n    l.update(1, p[i]);\n  }\n  for(int i=n-1;i>=0;i--){\n    ll q = r.query(0, p[i]);\n    rtento[p[i]] = q;\n    r.update(1, p[i]);\n  }\n  vvl dp = VV(n+5000, n+5000, INF, ll);\n  dp[0][0] = 0;\n\n  for(int i=0;i<-1+n;i++){\n    for(int j=0;j<=i;j++){\n      if(dp[i][j]==INF) continue;\n      ll x = comb[j+1], y = comb[n-(i-j)];\n      x = min(x, n-i);\n      y = min(y, n-i);\n      /*\n      //左詰め\n      dp[i+x][j+x] = min({dp[i+x][j+x],\n        dp[i][j]+A*comb[j+1], dp[i][j]+B*tento[j+1]});\n      //右詰め\n      dp[i+y][j] = min({dp[i+y][j],\n        dp[i][j]+B*comb[n-(i-j)], dp[i][j]+A*rtento[n-(i-j)]});\n      */\n      //左詰め\n      dp[i+x][j+x] = min({dp[i+x][j+x],\n        dp[i][j]+A*x, dp[i][j]+B*tento[j+1]});\n      //右詰め\n      dp[i+y][j] = min({dp[i+y][j],\n        dp[i][j]+B*y, dp[i][j]+A*rtento[n-(i-j)]});\n    }\n  }\n  ll ans = 1000000000000000000;\n  for(int i=0;i<=n;i++) ans = min(ans, dp[n-1][i]);\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmax(a,b) a=max(a,b);\n#define chmin(a,b) a=min(a,b);\n#define N 5010\nll f[N][N],n,a,b,p[N];\nint main(){\n    cin>>n>>a>>b;\n    for(int i=0;i<n;i++)cin>>p[i];\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)f[i][j]=1e17;\n    f[0][0]=0;\n    for(int i=0;i<n;i++){\n\tfor(int j=0;j<=n;j++){\n\t    if(j<p[i]){\n\t\tchmin(f[i+1][p[i]],f[i][j]);\n\t\tchmin(f[i+1][j],f[i][j]+a);\n\t    }\n\t    else chmin(f[i+1][j],f[i][j]+b);\n\t}\n    }\n    ll ans=1e17;\n    for(int i=0;i<=n;i++)chmin(ans,f[n][i]);\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n#define flush fflush(stdout) \n#define primeDEN 727999983\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// find_by_order()  // order_of_key\ntypedef tree<\nint,\nnull_type,\nless<int>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n#define int ll\nint a,b;\nint p[12345],pre[5123][5123],suf[5123][5123];\nint dp[5123][5123],visit[5123][5123];\nint pos[12345];\n\nint compute(int st,int en){\n\tif(st==en)\n\t\treturn 0;\n\tif(visit[st][en])\n\t\treturn dp[st][en];\n\tvisit[st][en]=1;\n\tint val;\n\tval=pos[en];\n\tdp[st][en]=inf;\n\tdp[st][en]*=inf;\n\t//cout<<st<<\" \"<<en<<endl;\n\t//cout<<suf[1][1]<<endl;\n\tif(suf[val][en-1]-suf[val][st-1]>0){\n\t\tdp[st][en]=min(compute(st,en-1)+a,dp[st][en]);\n\t}\n\telse{\n\t\tdp[st][en]=min(compute(st,en-1),dp[st][en]);\n\t}\n\tval=pos[st];\n\tif(pre[val][en]-pre[val][st]>0){\n\t\tdp[st][en]=min(compute(st+1,en)+b,dp[st][en]);\n\t}\n\telse{\n\t\tdp[st][en]=min(compute(st+1,en),dp[st][en]);\n\t}\n\treturn dp[st][en];\n\n}\nmain(){\n    std::ios::sync_with_stdio(false); cin.tie(NULL);\n  \tint n;\n  \tcin>>n>>a>>b;\n  \tint i;\n  \tf(i,1,n+1){\n  \t\tcin>>p[i];\n  \t\tpos[p[i]]=i;\n  \t}\n  \tint j;\n  \tf(i,1,n+1){\n  \t\tf(j,1,n+1){\n  \t\t\tpre[i][j]=pre[i-1][j];\n  \t\t}\n  \t\tf(j,p[i],n+1){\n  \t\t\tpre[i][j]++;\n  \t\t}\n  \t}\n  \tfd(i,n,1){\n  \t\tf(j,1,n+1){\n  \t\t\tsuf[i][j]=suf[i+1][j];\n  \t\t}\n  \t\tf(j,p[i],n+1){\n  \t\t\tsuf[i][j]++;\n  \t\t}\n  \t}\n  \tcout<<compute(1,n)<<endl;\n\n    return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#ifndef  _TB\n#define _TB\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define RFOR(i, b, a) for(int i = b - 1; i >= a; --i)\n#define REP(i, N) FOR(i, 0, N)\n#define RREP(i, N) RFOR(i, N, 0)\n\n#define MIN(A, B) ((A) < (B) ? (A) : (B))\n#define MAX(A, B) ((A) > (B) ? (A) : (B))\n#define ABS(A) ((A) < 0 ? (-(A)) : (A))\n#define ALL(V) V.begin(), V.end()\n#define SIZE(V) (int)V.size()\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-7\n#define Pi 3.14159265358979\n#define FILL(a,v) memset(a,v,sizeof(a))\n\nusing namespace std;\n\ntypedef long long Long;\ntypedef unsigned long long ULong;\ntypedef unsigned int Uint;\ntypedef unsigned char Uchar;\ntypedef vector <int> VI;\ntypedef pair <int, int> PII;\n\n#define X first\n#define Y second\n\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.X >> p.Y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.X << ' ' << p.Y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\nvoid fastIO(){ios::sync_with_stdio(false);cin.tie(nullptr); cout.tie(nullptr); }\n\n#endif\n\n\nint a,b;\nint n;\nVI p;\n\n\nconst int MAXN = 5050;\n\nLong dp[MAXN];\n\nLong solve() {\n    VI q = p;\n    q.push_back(MAXN);\n    q.insert(q.begin(), -MAXN);\n\n    int m = q.size();\n    REP(i,m)\n        dp[i] = 1e17;\n\n    dp[0] = 0;\n\n    REP(i,m) {\n        Long cur = dp[i];\n        int cm = MAXN+5;\n\n        FOR(j,i+1,m) {\n            if (q[j] < q[i])\n                cur += b;\n            else {\n                if (q[j] < cm) {\n                    dp[j] = min(dp[j], cur);\n                }\n                cm = min(cm, q[j]);\n                cur += a;\n            }\n        }\n    }\n\n    return dp[m-1];\n}\n\nclass DRotationSort {\npublic:\n    void solve(std::istream& in, std::ostream& out) {\n        in >> n >> a >> b;\n        p.resize(n);\n        in >> p;\n        Long a1 = ::solve();\n        reverse(ALL(p));\n        for(auto &pv: p)\n            pv *= -1;\n\n        swap(a,b);\n        Long a2 = ::solve();\n        out << min(a1,a2) << endl;\n\n    }\n};\n\n\nint main() {\n\tDRotationSort solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 5e3 + 5;\n\nint C[maxn];\nll dp[maxn][maxn], A, B;\nint n, where[maxn], a[maxn];\n\nint main(int argc, char const *argv[])\n{\n\t// freopen(\"in\", \"r\", stdin);\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\twhere[a[i]] = i;\n\t}\n\tfor(int i = 1; i <= n; i++) {\n\t\tint c = 0;\n\t\tfor(int j = 1; j < i; j++) {\n\t\t\tif(where[j] < where[i])\n\t\t\t\tc++;\n\t\t}\n\t\tC[i] = c + 1;\n\t}\n\tfor(int i = 0; i <= n; i++) dp[i][0] = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= i; j++) {\n\t\t\tif(C[i] > j) {\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t} else {\n\t\t\t\tdp[i][j] = min(dp[i - 1][j - 1] + A, dp[i - 1][C[i] - 1] + (j - C[i]) * B);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=5010;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint n,A,B;\nLL f[N][N];\n\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n),sc(A),sc(B);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x; sc(x);\n\t\tmemset (f[i],127,sizeof (LL)*(n+1));\n\t\tfor (int j=0; j<=n; j++)\n\t\t{\n\t\t\tif (x< j) f[i][j]=f[i-1][j]+B;\n\t\t\telse if (x> j) f[i][j]=f[i-1][j]+A;\n\t\t}\n\t\tfor (int j=0; j<=x; j++)\n\t\t\tchkmin (f[i][x],f[i-1][j]);\n\t}\n\tLL ans=1e18;\n\tfor (int i=0; i<=n; i++)\n\t\tchkmin (ans,f[n][i]);\n\tpr(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define MAX_V 15000\n\n//rev: G[to][rev]で逆辺にアクセスできるようにしている\nstruct edge {int to;ll cap;int rev;};\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, ll cap){\n\tG[from].push_back((edge){to, cap, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nvoid bfs(int s){\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap>0 && level[e.to] <0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//vからtに流せたフローの量を返す　fはvが保持しているフローの量\nll dfs(int v, int t, ll f){\n\tif(v == t) return f;\n\tfor(ll &i = iter[v]; i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap>0 && level[v] < level[e.to]){\n\t\t\tll d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nll max_flow(int s, int t){\n\tll flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t] < 0) return flow;\n\t\tmemset(iter,0,sizeof(iter));//usedを0で初期化してるだけ\n\t\tll f;\n\t\twhile((f = dfs(s,t,LINF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\nint main(void){\n\tint n,p;\n\tll a,b;\n\tcin>>n>>a>>b;\n\tvector<int> P;\n\trep(i,n){\n\t\tcin>>p;\n\t\tP.push_back(p);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i>=j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(P[i]>P[j]){\n\t\t\t\tadd_edge(i+1,n+j+1,LINF);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n){\n\t\tadd_edge(0,i+1,a);\n\t}\n\trep(i,n){\n\t\tadd_edge(n+i+1,2*n+1,b);\n\t}/*\n\trep(i,2*n+2){\n\t\tcout<<i<<\" \";\n\t\trep(j,G[i].size()){\n\t\t\tcout << G[i][j].to << \" \" << G[i][j].cap<<\", \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\n\n\tcout<<max_flow(0,2*n+1)<<endl;;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long N, A, B, C[5009];\nlong long dp[5009][5009];\n\nint main() {\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; i++) cin >> C[i];\n\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 0; j <= N; j++) dp[i][j] = (1LL << 60);\n\t}\n\t\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tlong long r = (1LL << 60);\n\t\tfor (int j = 0; j <= C[i] - 1; j++) r = min(r, dp[i - 1][j]);\n\t\tdp[i][C[i]] = r;\n\t\tfor (int j = 0; j <= C[i] - 1; j++) { dp[i][j] = dp[i - 1][j] + A; }\n\t\tfor (int j = C[i] + 1; j <= N; j++) { dp[i][j] = dp[i - 1][j] + B; }\n\t}\n\n\tlong long ret = (1LL << 60);\n\tfor (int i = 0; i <= N; i++) ret = min(ret, dp[N][i]);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n;\nlong a,b,ans;\nvector<int>p;\nmain()\n{\n\tlong A,B;\n\tcin>>n>>A>>B;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint u;cin>>u;p.push_back(u);\n\t}\n\twhile(!p.empty())\n\t{\n\t\tint id=0;\n\t\tfor(;p[id]==1;id++);\n\t\tint r=1;\n\t\tfor(;id+r<p.size()&&p[id+r]==1+r;r++);\n\t\tlong L=id,R=r;\n\t\tvector<int>now;\n\t\tif(L*A<R*B)\n\t\t{\n\t\t\tans+=A*L;\n\t\t\tfor(int i=0;i<p.size();i++)\n\t\t\t{\n\t\t\t\tif(i<id)now.push_back(p[i]+r);\n\t\t\t\telse if(i>=id+r)now.push_back(p[i]-id);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=R*B;\n\t\t\tfor(int i=0;i<p.size();i++)\n\t\t\t{\n\t\t\t\tif(i<id)now.push_back(p[i]+r);\n\t\t\t\telse if(i>=id+r)now.push_back(p[i]-id);\n\t\t\t}\n\t\t}\n\t\tp=now;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 5001;\nconst int INF = 1e18 + 7;\nint n, A, B;\nint a[N];\nint p[N][N];\nint sum(int x1, int y1, int x2, int y2) {\n    if (x2 < x1 || y2 < y1) return 0;\n    return p[x2][y2] - p[x2][y1 - 1] - p[x1 - 1][y2] + p[x1 - 1][y1 - 1];\n}   \nint dp[N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    cin >> n >> A >> B;\n    int R = A; \n    int L = B;\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n        p[i][a[i]] = 1;\n    }   \n    bool sorted = 1;\n    for (int i = 1; i <= n - 1; ++i) {\n        sorted &= a[i] < a[i + 1];\n    }   \n    if (sorted) {\n        cout << \"0\\n\";\n        exit(0);\n    }   \n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            p[i][j] += p[i - 1][j] + p[i][j - 1] - p[i - 1][j - 1];\n        }   \n    }   \n    for (int i = 1; i <= n; ++i) {\n        dp[i] = 0;\n        for (int j = 1; j < i; ++j) {\n            if (a[j] < a[i]) {\n                dp[i] += min(L, R);\n            }   \n            else {\n                dp[i] += R;\n            }   \n        }\n        for (int j = 1; j < i; ++j) {\n            if (a[j] < a[i]) {\n                dp[i] = min(dp[i], dp[j] + sum(j + 1, a[j], i - 1, a[i]) * min(L, R) + sum(j + 1, 1, i - 1, a[j]) * L + sum(j + 1, a[i], i - 1, n) * R);\n            }   \n        }   \n    }  \n    int ans = INF;\n    for (int i = 1; i <= n; ++i) {\n        int nn = dp[i];\n        for (int j = i + 1; j <= n; ++j) {\n            if (a[j] < a[i]) {\n                nn += L;\n            }   \n            else {\n                nn += min(L, R);\n            }   \n        }   \n        ans = min(ans, nn);\n    }   \n    cout << ans << '\\n';\n}   "
  },
  {
    "language": "C++",
    "code": "/*\n * \tThe way if it's all predetermined\n * \t\tAnd the way i should go all my life\n * \t\t\tI swear to go wherever will be\n * \t\t\t\t'Cause there'll be something to see and to find\n * \tI don't know the meaning of life\n * \t\tBut i know what's truly precious\n * \t\t\tThe way it's leading me to be in love\n * \t\t\t\tNo fear i can find me always in my heart\n * \tThe life it's not for comparing things\n * \t\tSo i hold both of light and shadow\n * \t\t\tThe rays of stars will bring me to you\n * \t\t\t\tThrought the dark night skies\n * \t\t\t\t\tSee the way to be shined\n * \tI dont know what's right for our lives\n * \t\tBut i know the truth of my love\n * \t\t\tThe way it feels our breaths at the wind\n * \t\t\t\tAnd the way i should go all my life\n * \t\t\t\t\tI swear to go wherever will be\n * \t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\tWill always in my heart\n * \t\t\t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\t\t\tWill always in my heart\n */\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#ifndef rd\n#define endl '\\n'\n#endif\n#ifdef rd\n#define trace(...) cout<<\"Line:\"<<__LINE__<<\" \"; __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n\tcout<<name<<\" : \"<<arg1<<endl;\n}\ntemplate<typename Arg1, typename ... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n\tconst char* comma=strchr(names+1,',');\n\tcout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";\n\t__f(comma+1,args...);\n}\n#else\n#define trace(...)\n#endif\n#define deb cout<<\"Line: \"<<__LINE__<<\" plz \"\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double f80;\n#define double long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define sz(x) ((long long)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\nconst ll infl=2e18;\nconst int infi=2e9;\nconst int mod=1e9+7;\ntypedef vector<int> vi;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;\nmt19937 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nauto clk=clock();\nint rng(int lim) {\n\tuniform_int_distribution<int> uid(0,lim-1);\n\treturn uid(rang);\n}\n\nint dp[5005][5005];\nint p[5005];\nint peb[5005];\nint bac[5005];\nvoid solve() {\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tfr(i,1,n) {\n\t\tcin>>p[i];\n\t\tpeb[i]=n+1;\n\t}\n\tfr(j,1,n) {\n\t\tfr(i,j,n) {\n\t\t\tif(p[i]<p[j]) {\n\t\t\t\tpeb[p[i]]=min(peb[p[i]],p[j]);\n//\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfr(j,1,n) {\n\t\tfr(i,j,n) {\n\t\t\tif(p[j]<p[i]) {\n\t\t\t\tbac[p[i]]=max(bac[p[i]],p[j]);\n//\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n+1; i++)\n\t\tfill(dp[i],dp[i]+n+2,infl);\n\tdp[0][n+1]=0;\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=n+1; j>1; j--) {\n\t\t\tif(peb[i+1]>=j) {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\t} else {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n\t\t\t}\n\t\t\tif(bac[j-1]<=i) {\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\t} else\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]+a);\n\t\t}\n\t}\n\n//\tcout<<dp[]\n\tint ans=infl;\n\tfor(int i=0; i<=n; i++) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tif(i+1>=j)\n\t\t\t\tans=min(ans,dp[i][i+1]);\n\t\t}\n\t}\n\tassert(ans<infl);\n\tassert(ans<=(n-1)*a);\n\tassert(ans<=(n-1)*b);\n\tcout<<ans<<endl;\n}\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::high_resolution_clock::now().time_since_epoch().count());\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t\tsolve();\n#ifdef rd\n\tcerr<<endl<<endl<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, a, b;\n\tcin >> n >> a >> b;\n\tvi p(n);\n\ttrav(x, p) cin >> x, --x;\n\tvi q(n);\n\trep(i,0,n) q[p[i]] = i;\n\n\tvector<vi> cnt(n+1, vi(n+1));\n\trep(i,0,n) cnt[p[i]+1][i+1] = 1;\n\trep(h,1,n+1) rep(r,0,n+1) cnt[h][r] += cnt[h-1][r];\n\trep(r,1,n+1) rep(h,1,n+1) cnt[h][r] += cnt[h][r-1];\n\tvector<vi> que(n+1, vi(n+1,-1));\n\trep(h,1,n+1) rep(r,1,n+1){\n\t\tif(q[h-1] < r){\n\t\t\tque[h][r] = h-1;\n\t\t} else {\n\t\t\tque[h][r] = que[h-1][r];\n\t\t}\n\t}\n\tvector<vector<ll>> dp(n+1, vector<ll>(n+1, 0));\n\trep(h,1,n+1) rep(r,1,n+1){\n\t\tint m = que[h][r];\n\t\tif(m == -1) continue;\n\t\tint i = q[m];\n\t\tdp[h][r] = min(a + dp[m][r],\n\t\t\tll(b) * (cnt[h][r] - cnt[h][i+1])\n\t\t\t\t+ dp[m][i]);\n\t\t\t\n\t}\n\tcout << dp[n][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst ll INF = 1e18;\n\nint n;\nll l, r;\n\nint a[5100];\nll dp[5100];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> r >> l;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tdp[i] = INF;\n\tfor (int i = 0; i < n; ++i) {\n\t\tll mn = INF;\n\t\tfor (int j = 0; j < a[i]; ++j) {\n\t\t\tmn = min(mn, dp[j]);\n\t\t\tdp[j] += r;\n\t\t}\n\t\tdp[a[i]] = mn;\n\t\tfor (int j = a[i] + 1; j <= n; ++j)\n\t\t\tdp[j] += l;\n\t}\n\tll ans = INF;\n\tfor (int i = 0; i <= n; ++i)\n\t\tans = min(ans, dp[i]);\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define fio ios_base::sync_with_stdio(false)\n#define pdl cout << \"*\" << endl\n#define MOD 1000000007\n#define INF 1000000000\n#define INFLL 1000000000000000000ll\n#define mp make_pair\n#define pb push_back\n#define ff first\n#define ss second\n#define long int64_t\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef priority_queue<pii, vector<pii>, greater<pii>> min_pq;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> OST;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<> dis(0, INF<<1);\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1> void __f(const char* name, Arg1&& arg1){ cerr << name << \" : \" << arg1 << endl; }\ntemplate <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args)\n{ const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1 << \" | \"; __f(comma+1, args...); }\n\nconst int N = 5001;\n\nlong dp[N];\nint b[N];\n\nint main()\n{\n\tfio;\n\tint n, A, B;\n\tcin >> n >> A >> B;\n\tfor(int i=1; i<=n; i++)\n\t\tcin >> b[i];\n\tlong ans = INFLL;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tdp[i] = INFLL;\n\t\tint c = 0;\n\t\tfor(int j=i-1; j>=0; j--)\n\t\t{\n\t\t\tif(b[i] > b[j])\n\t\t\t\tdp[i] = min(dp[i], dp[j] + c * 1ll * A + (i - j - 1 - c) * 1ll * B);\n\t\t\telse\n\t\t\t\tc++;\n\t\t}\n\t\tans = min(ans, dp[i] + (n - i) * 1ll * B);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\n// edge class (for network-flow)\ntemplate<class FLOWTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    Edge(int r, int f, int t, FLOWTYPE c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// graph class (for network-flow)\ntemplate<class FLOWTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE> &redge(Edge<FLOWTYPE> e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, 0));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, cap));\n    }\n\n    /* \n    // debug\n    friend ostream& operator << (ostream& s, const Graph& G) {\n        s << endl; for (int i = 0; i < G.size(); ++i) { s << i << \" : \" << G.list[i] << endl; }return s;\n    }\n    */\n};\n\ntemplate<class FLOWTYPE> struct Dinic {\n    const FLOWTYPE INF = 1LL<<60; // to be set\n    vector<int> level, iter;\n\n    Dinic() { }\n    void dibfs(Graph<FLOWTYPE> &G, int s) {\n        level.assign((int)G.size(), -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge<FLOWTYPE> &e = G[v][i];\n                if (level[e.to] < 0 && e.cap > 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    FLOWTYPE didfs(Graph<FLOWTYPE> &G, int v, int t, FLOWTYPE f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge<FLOWTYPE> &e = G[v][i], &re = G.redge(e);\n            if (level[v] < level[e.to] && e.cap > 0) {\n                FLOWTYPE d = didfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    re.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    FLOWTYPE solve(Graph<FLOWTYPE> &G, int s, int t) {\n        level.assign((int)G.size(), -1); iter.assign((int)G.size(), 0);\n        FLOWTYPE res = 0;\n        while (true) {\n            dibfs(G, s);\n            if (level[t] < 0) return res;\n            for (int i = 0; i < (int)iter.size(); ++i) iter[i] = 0;\n            FLOWTYPE flow = 0;\n            while ((flow = didfs(G, s, t, INF)) > 0) {\n                res += flow;\n            }\n        }\n    }\n};\n\n\n\n\nint N;\nlong long A, B;\nvector<int> P;\n\nint main() {\n    while (cin >> N >> A >> B) {\n        P.resize(N);\n        for (int i = 0; i < N; ++i) cin >> P[i], --P[i];\n\n        Graph<long long> G(N*2 + 2);\n        int s = N*2, t = s+1;\n        for (int i = 0; i < N; ++i) {\n            G.addedge(s, i, A);\n            G.addedge(i+N, t, B);\n        }\n        for (int i = 0; i < N; ++i) {\n            for (int j = i+1; j < N; ++j) {\n                int u = P[i], v = P[j];\n                if (P[i] > P[j]) {\n                    G.addedge(u, v+N, 1LL<<59);\n                }\n            }\n        }\n        Dinic<long long> din;\n        long long res = din.solve(G, s, t);\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=5005;\nll a[N],dp[N][N];\ninline void cmn(ll&a,ll b){if(a>b)a=b;}\nint main()\n{\n\tll n,A,B,ans=1ll<<60;scanf(\"%lld%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tmemset(dp,0x3f,sizeof(dp));dp[0][0]=0;\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=n;j++)if(a[i]>j)cmn(dp[i][j],dp[i-1][j]+A),cmn(dp[i][a[i]],dp[i-1][j]);else cmn(dp[i][j],dp[i-1][j]+B);\n\tfor(int i=0;i<=n;i++)cmn(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nusing pi = pair< int, int >;\n\nstruct UnionFind {\n  vector< int > data;\n\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k) {\n    return (-data[find(k)]);\n  }\n};\n\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  int deg[100000] = {};\n  int X[100000], Y[100000];\n  for(int i = 0; i < M; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    deg[x]++;\n    deg[y]++;\n    X[i] = x, Y[i] = y;\n  }\n  int a = 0, b = 0;\n  vector< int > add;\n  for(int i = 0; i < N; i++) {\n    if(deg[i] % 2) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n    if(deg[i] == 2) {\n      ++a;\n    }\n    if(deg[i] == 4) {\n      add.emplace_back(i);\n      ++b;\n    }\n  }\n  if(b == 2 && a == N - 2) {\n    UnionFind uf(N);\n    for(int i = 0; i < M; i++) {\n      if(add[0] == X[i] || add[1] == X[i]) continue;\n      if(add[0] == X[i] || add[1] == Y[i]) continue;\n      uf.unite(X[i], Y[i]);\n    }\n    set< int > rot;\n    for(int i = 0; i < N; i++) {\n      if(add[0] == i || add[1] == i) continue;\n      rot.emplace(uf.find(i));\n    }\n    if(rot.size() <= 4) {\n      cout << \"No\" << endl;\n    } else {\n      cout << \"Yes\" << endl;\n    }\n    return 0;\n  }\n  if(a == N || (b == 2 && a == N - 2)) {\n    cout << \"No\" << endl;\n  } else {\n    cout << \"Yes\" << endl;\n  }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){ll res=1;a%=mod;while(b){if(b&1)res=res*a%mod;a=a*a%mod;b>>=1;}return res;}\nvi seg;\nll N;\nvoid init(vi v){\n    N=1;\n    while(N<v.size())N*=2;\n    seg=vi(N*2-1);\n    rep(i,v.size())seg[i+N-1]=v[i];\n    for(int i=N-2;i>=0;i--)seg[i]=seg[i*2+1]+seg[i*2+2];\n}\nvoid add(ll i,ll x){\n    i=N+i-1;\n    seg[i]+=x;\n    while(i>0){\n        i=(i-1)/2;\n        seg[i]=seg[i*2+1]+seg[i*2+2];\n    }\n}\nll getsum(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return seg[k];\n    ll c1=getsum(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getsum(a,b,k*2+2,(l+r)/2,r);\n    return c1+c2;\n}\nvoid chr(ll k,ll x){\n    ll s=getsum(0,k+1,0,0,N);\n    if(s<=x)return;\n    add(k,x-s);\n    add(k+1,s-x);\n}\nint main(){\n    ll n,l,r;cin>>n>>r>>l;\n    vi dp(n);\n    rep(i,n){\n        ll a;cin>>a;\n        a--;\n        vi ndp(n,inf);\n        rep(j,n){\n            if(j<=a)chmin(ndp[a],dp[j]);\n            if(j<=a)chmin(ndp[j],dp[j]+r);\n            if(j>a)chmin(ndp[j],dp[j]+l);\n        }\n        dp=ndp;\n    }\n    ll ans=inf;\n    rep(i,n)chmin(ans,dp[i]);\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<ld> vld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    ll A, B;\n    cin >> N >> A >> B;\n    vi p(N+1);\n    for (int n = 1; n <= N; ++n) {\n        cin >> p[n];\n    }\n    vi q(N+1);\n    for (int n = 1; n <= N; ++n) {\n        q[p[n]] = n;\n    }\n    \n    vvll dp(N+1, vll(N+1));\n    for (int n = 0; n <= N; ++n) {\n        dp[0][n] = 0;\n    }\n    for (int m = 1; m <= N; ++m) {\n        dp[m][0] = dp[m-1][0];\n        for (int n = 1; n <= N; ++n) {\n            dp[m][n] = min(dp[m-1][n], dp[m][n-1]);\n        }\n        \n        for (int n = 0; n < q[m]; ++n) {\n            dp[m][n] += B;\n        }\n        for (int n = q[m]+1; n <= N; ++n) {\n            dp[m][n] += A;\n        }\n        \n    }\n    \n    ll ans = INFLL;\n    for (int n = 0; n <= N; ++n) {\n        if (ans > dp[N][n]) {\n            ans = dp[N][n];\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 5055, inf = 1000111222;\n\nint n, c1, c2, a[max_n], pos[max_n], mn[max_n][max_n], mx[max_n][max_n];\nlong long dp[2][max_n];\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    cin >> n >> c1 >> c2;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        --a[i];\n        pos[a[i]] = i;\n    }\n    int q1 = 0, q2 = 1;\n    for (int l = 0; l < n; ++l) {\n        mn[l][l] = mx[l][l] = pos[l];\n        for (int r = l + 1; r < n; ++r) {\n            mn[l][r] = min(mn[l][r - 1], pos[r]);\n            mx[l][r] = max(mx[l][r - 1], pos[r]);\n        }\n        dp[q1][l] = 0;\n    }\n    for (int len = 2; len <= n; ++len) {\n        for (int l = 0; l + len <= n; ++l) {\n            int r = l + len - 1;\n            if (mn[l][r] == pos[l]) {\n                dp[q2][l] = dp[q1][l + 1];\n            } else if (mx[l][r] == pos[r]) {\n                dp[q2][l] = dp[q1][l];\n            } else {\n                dp[q2][l] = min(dp[q1][l] + c1, dp[q1][l + 1] + c2);\n            }\n        }\n        swap(q1, q2);\n    }\n    printf(\"%lld\\n\", dp[q1][0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#define NDEBUG 1\n#endif\n#include<bits/stdc++.h>\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint number, leftMoveCost, rightMoveCost; std::cin>>number>>rightMoveCost>>leftMoveCost;\n\tstd::vector<int> data(number), pos(number);\n\tfor(int index=0;index<number;++index) {\n\t\tauto& item=data[index];\n\t\tstd::cin>>item;--item; \n\t\tpos[item]=index;\n\t}\n\n\tstd::vector<std::vector<int64_t>> f(number+1, std::vector<int64_t>(number+1, INT64_MAX));\n\tf[0][0]=0;\n\n\t// f[a][b]=minimum cost to move a smallest numbers to the left, and\n\t// b numbers at first indices(including those that may be moved to the left)\n\t// to an arbitrary position to the right)\n\tfor(int a=0;a<number;++a) {\n\t\tstd::vector<int> uncoveredSuffix(number+1);\n\t\tfor(int cur=0,index=number; index--;){\n\t\t\tuncoveredSuffix[index]=cur+=(data[index]>=a);\n\t\t}\n\n\n\t\tfor(int b=0;b<=number;++b) if(f[a][b]!=INT64_MAX) {\n\t\t\tauto const cur=f[a][b];\n\t\t\tf[a+1][b]=std::min(f[a+1][b], cur+leftMoveCost);\n\t\t\tauto const rightMoveCount=std::max(0,uncoveredSuffix[b]-uncoveredSuffix[pos[a]]);\n\t\t\tauto& next2=f[a+1][std::max(b, pos[a]+1)];\n\t\t\tnext2=std::min(next2, cur+(int64_t)rightMoveCost*rightMoveCount);\n\t\t}\n\t}\n\n\tstd::cout<<*std::min_element(begin(f[number]),end(f[number]))<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n    *Makacha\n**/\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> inline void read (T &x) {bool b = 0; char c; while (!isdigit (c = getchar()) && c != '-');\nif (c == '-') c = getchar(), b = 1; x = c - 48; while (isdigit(c = getchar())) x = (x<<3) + (x<<1) + c - 48; if (b)x=-x;}\ntemplate <typename T> inline void wrip(T x) {if (x > 9) wrip(x / 10); putchar(x%10 + 48); }\n\ntemplate <typename T> inline void write(T x) {if (x < 0) putchar('-'), x = -x; wrip(x); putchar(' ');}\ntemplate <typename T> inline void writeln(T x) {if (x < 0) putchar('-'), x = -x; wrip(x); putchar('\\n');}\ninline char readch() {char c; do c = getchar(); while (c == '\\n' || c == ' '); return c;}\ninline void reads(string &s) {char c; while((c=getchar())==' '||c =='\\n'); s=c; while((c=getchar())!=' '&&c!='\\n') s+=c;}\ninline void getlines(string &s) {char c; while((c=getchar())=='\\n'); s=c; while((c=getchar())!='\\n') s+=c;}\ntypedef const int csint;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> ii;\ntypedef vector <int> vi;\n\nconst ld pi = acos(-1);\nconst ll inf = 1e16;\nconst int mod = 1e9 + 7,\nN = 5055;\nint n, a[N];\nll A, B, f[N][N];\nint main() {\n    #ifdef makacha\n        freopen(\"m.inp\", \"r\", stdin);\n        freopen(\"m.out\", \"w\", stdout);\n    #endif // makacha\n    read(n);\n    read(A);\n    read(B);\n    for (int i = 1; i <= n; i++)\n        read(a[i]);\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j <= n; j++)\n            f[i][j] = inf;\n    f[1][a[1]] = 0;\n    f[1][0] = A;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) {\n            f[i][j] = min(f[i][j], f[i][j - 1]);\n            if (a[i + 1] >= j) {\n                f[i + 1][a[i + 1]] = min(f[i + 1][a[i + 1]], f[i][j]);\n                f[i + 1][j] = min(f[i + 1][j], f[i][j] + A);\n            }\n            else\n                f[i + 1][j] = min(f[i + 1][j], f[i][j] + B);\n        }\n    cout << f[n][n];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long inf = 1ll << 60;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, a, b;\n  cin >> n >> a >> b;\n  vector<int> p(n + 1);\n  for (int i = 1; i <= n; ++i) {\n    cin >> p[i];\n  }\n  vector<int> q(n + 1);\n  for (int i = 1; i <= n; ++i) {\n    q[p[i]] = i;\n  }\n  vector<long long> dp(n + 1, inf);\n  dp[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    vector<long long> new_dp(n + 1, inf);\n    for (int j = 0; j < i; ++j) {\n      if (dp[j] != inf) {\n        if (q[i] > q[j]) {\n          new_dp[i] = min(new_dp[i], dp[j]);\n          new_dp[j] = min(new_dp[j], dp[j] + b);\n        } else {\n          new_dp[j] = min(new_dp[j], dp[j] + a);\n        }\n      }\n    }\n    swap(dp, new_dp);\n  }\n  cout << *min_element(dp.begin(), dp.end()) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 5005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 +c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N;\nint64 A,B;\nint64 dp[MAXN][2 * MAXN],s[MAXN][2 * MAXN];\nint p[MAXN],pos[MAXN];\nvoid Solve() {\n    read(N);read(A);read(B);\n    for(int i = 1 ; i <= N ; ++i) {read(p[i]);pos[p[i]] = i;}\n    for(int i = 1 ; i <= N ; ++i) {\n        s[i][0] = 1e18;\n        for(int j = 1 ; j <= 2 * N + 1 ; ++j) {\n            if(j & 1) {\n                dp[i][j] = s[i - 1][j] + (j < pos[i] * 2 ? B : A);\n            }\n            else {\n                dp[i][j] = s[i - 1][j - 1] + (j != pos[i] * 2 ? (j < pos[i] * 2 ? B : A): 0);\n            }\n            s[i][j] = min(s[i][j - 1],dp[i][j]);\n        }\n    }\n    out(s[N][2 * N + 1]);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 5001;\ntypedef long long ll;\nint p[maxn], n;\nll dp[maxn], a, b;\nint main()\n{\n\tstd::cin >> n >> a >> b;\n\tfor(int i = 1;i <= n;++i) std::cin >> p[i], dp[i] = (i - 1) * a;\n\tll ans = 1e18;\n\tfor(int i = 1;i <= n;++i) {\n\t\tll s = 0; int min = 1e9;\n\t\tfor(int j = i + 1;j <= n;++j) {\n\t\t\tif(p[i] < p[j] && p[j] < min) {\n\t\t\t\tmin = p[j];\n\t\t\t\tdp[j] = std::min(dp[j], dp[i] + s);\n\t\t\t}\n\t\t\ts += p[j] < p[i] ? b : a;\n\t\t}\n\t\tans = std::min(ans, dp[i] + (n - i) * b);\n\t}\n\tstd::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 3/23/2019, 10:52:02 PM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(10101010));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll infty = 10000000000000007;\n\nll N, A, B;\nint p[5010];\nll R[5010][5010];\nll L[5010][5010];\nll cost[5010][5010];\n\nll calc(int l, int r)\n{\n  if (cost[l][r] < infty)\n  {\n    return cost[l][r];\n  }\n  else if (l + 1 == r)\n  {\n    cost[l][r] = 0;\n  }\n  else\n  {\n    cost[l][r] = min(A, B * max(0LL, R[l][r - 1])) + calc(l + 1, r);\n    cost[l][r] = min(cost[l][r], min(B, A * max(0LL, L[r - 1][l])) + calc(l, r - 1));\n  }\n#if DEBUG == 1\n  cerr << \"cost[\" << l << \"][\" << r << \"] = \" << cost[l][r] << endl;\n#endif\n  return cost[l][r];\n}\n\nint main()\n{\n  cin >> N >> A >> B;\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> p[i];\n    p[i]--;\n  }\n  fill(&cost[0][0], &cost[0][0] + 5010 * 5010, infty);\n  for (auto i = 0; i < N; i++)\n  {\n    R[i][i] = 0;\n    for (auto j = i + 1; j < N; j++)\n    {\n      R[i][j] = R[i][j - 1];\n      if (p[i] > p[j])\n      {\n        R[i][j]++;\n      }\n#if DEBUG == 1\n      cerr << \"R[\" << i << \"][\" << j << \"] = \" << R[i][j] << endl;\n#endif\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    L[i][i] = 0;\n    for (auto j = i - 1; j >= 0; j--)\n    {\n      L[i][j] = L[i][j + 1];\n      if (p[i] < p[j])\n      {\n        L[i][j]++;\n      }\n#if DEBUG == 1\n      cerr << \"L[\" << i << \"][\" << j << \"] = \" << L[i][j] << endl;\n#endif\n    }\n  }\n  cout << calc(0, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fio() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pi;\ntypedef pair<pi, ll> pii;\n\nconst ll mod = 1e9 + 7;\nconst ll maxn = 1e5 + 6;\nconst ll N = 1e5 + 10;\nconst ll inf = 1e12;\nconst ld eps = 1e-16;\n\n\nll A, B;\nint n, a[N];\nbool mark[N];\n\nll calc (int r) {\n\tll res = A * r;\n\t\n\tfill (mark, mark + n + 3, false);\n\t\n\tint toBe = r + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] <= r)\n\t\t\tcontinue;\n\t\tif (a[i] != toBe) {\n\t\t\tmark[a[i]] = true;\n\t\t\tres += B;\n\t\t} else {\n\t\t\ttoBe++;\n\t\t\twhile (mark[toBe])\n\t\t\t\ttoBe++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\tfio();\n\tcin >> n >> B >> A;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\n\tll ans = inf;\n\tfor (int r = 0; r <= n; r++)\n\t\tans = min(ans, calc(r));\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL N=5010;\nLL n, a, b, p[N], id[N], dp[N][N], s[N][N];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\tfor(LL i=1; i<=n; ++i)scanf(\"%lld\",&p[i]), id[p[i]]=i;\n\tmemset(s,0x3f,sizeof(s));\n\tfor(LL i=0; i<=n; ++i)s[0][i]=0;\n\tfor(LL i=1; i<=n; ++i)\n\t\tfor(LL j=0; j<=n; ++j){\n\t\t\tdp[i][j]=s[i-1][j]+(j>=id[i]?a:b);\n\t\t\tif(j==id[i])dp[i][j]=min(dp[i][j],s[i-1][j-1]);\n\t\t\tif(j>0)s[i][j]=min(s[i][j-1],dp[i][j]);else s[i][j]=dp[i][j];\n\t\t}\n\tLL mn=0x3f3f3f3f3f3f3f3f;\n\tfor(LL i=1; i<=n; ++i)mn=min(mn,dp[n][i]);\n\tprintf(\"%lld\",mn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 3/23/2019, 10:52:02 PM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(10101010));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll infty = 100000000000000007;\n\nll N, A, B;\nint p[5010];\nll R[5010][5010];\nll L[5010][5010];\nll cost[5010][5010];\n\nll calc(int l, int r)\n{\n  if (cost[l][r] < infty)\n  {\n    return cost[l][r];\n  }\n  else if (l == r)\n  {\n    cost[l][r] = 0;\n  }\n  else if (l + 1 == r)\n  {\n    cost[l][r] = 0;\n  }\n  else if (l + 2 == r)\n  {\n    if (p[l] < p[l + 1])\n    {\n      cost[l][r] = 0;\n    }\n    else\n    {\n      cost[l][r] = min(A, B);\n    }\n  }\n  else\n  {\n    cost[l][r] = min(A, B * R[l][r - 1]) + calc(l + 1, r);\n    cost[l][r] = min(cost[l][r], min(B, A * L[r - 1][l]) + calc(l, r - 1));\n  }\n#if DEBUG == 1\n  cerr << \"cost[\" << l << \"][\" << r << \"] = \" << cost[l][r] << endl;\n#endif\n  return cost[l][r];\n}\n\nint main()\n{\n  cin >> N >> A >> B;\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> p[i];\n    p[i]--;\n  }\n  fill(&R[0][0], &R[0][0] + 5010 * 5010, N + 1);\n  fill(&L[0][0], &L[0][0] + 5010 * 5010, N + 1);\n  fill(&cost[0][0], &cost[0][0] + 5010 * 5010, infty);\n  for (auto i = 0; i < N; i++)\n  {\n    R[i][i] = 0;\n    for (auto j = i + 1; j < N; j++)\n    {\n      R[i][j] = R[i][j - 1];\n      if (p[i] > p[j])\n      {\n        R[i][j]++;\n      }\n#if DEBUG == 1\n      cerr << \"R[\" << i << \"][\" << j << \"] = \" << R[i][j] << endl;\n#endif\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    L[i][i] = 0;\n    for (auto j = i - 1; j >= 0; j--)\n    {\n      L[i][j] = L[i][j + 1];\n      if (p[i] < p[j])\n      {\n        L[i][j]++;\n      }\n#if DEBUG == 1\n      cerr << \"L[\" << i << \"][\" << j << \"] = \" << L[i][j] << endl;\n#endif\n    }\n  }\n  cout << calc(0, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define itrep(i, a) for (auto i = (a).begin(); i != (a).end(); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n#define mp(a, b) make_pair((a), (b))\n\nusing namespace std;\n\ntemplate<class T> void inputVector(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\n\nint leftBig[5010], rightSmall[5010];\n\nint N, A, B;\nvector<int> p;\n\nvoid makeLeftBig() {\n    set<int> st;\n    rep(i, N) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.end()) leftBig[p[i]] = N + 1;\n        else leftBig[p[i]] = *it;\n        st.insert(p[i]);\n    }\n    //cerr << \"leftBig:\";\n    //REP(i, 1, N) cerr << \" \" << leftBig[i];\n    //cerr << endl;\n}\nvoid makeRightSmall() {\n    set<int> st;\n    st.insert(p[N - 1]);\n    for (int i = N - 2; i >= 0; i--) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.begin()) rightSmall[p[i]] = 0;\n        else {\n            it--;\n            rightSmall[p[i]] = *it;\n        }\n        st.insert(p[i]);\n    }\n    //cerr << \"rightSmall:\";\n    //REP(i, 1, N) cerr << \" \" << rightSmall[i];\n    //cerr << endl;\n}\n\nstruct Info {\n    int left, right;\n    int dist;\n\n    Info(int left, int right, int dist) : left(left), right(right), dist(dist) {\n    }\n\n    bool operator< (const Info& a) const {\n        return dist > a.dist;\n    }\n};\n\nsigned main() {\n    cin >> N >> A >> B;\n\n    inputVector(p, N);\n\n    makeLeftBig();\n    makeRightSmall();\n\n    priority_queue<Info> q;\n    q.push(Info(0, N + 1, 0));\n    while (!q.empty()) {\n        auto info = q.top(); q.pop();\n        //cerr << \"Info: [left:\" << info.left << \" right:\" << info.right << \" dist:\" << info.dist << \"]\" << endl;\n        if (info.left + 1 == info.right) {\n            cout << info.dist << endl;\n            break;\n        }\n\n        {\n            int nextNum = info.left + 1;\n            int ndist = info.dist;\n            if (leftBig[nextNum] < info.right) {\n                ndist += B;\n            }\n            q.push(Info(info.left + 1, info.right, ndist));\n        }\n        {\n            int nextNum = info.right - 1;\n            int ndist = info.dist;\n            if (rightSmall[nextNum] > info.left) {\n                ndist += A;\n            }\n            q.push(Info(info.left, info.right - 1, ndist));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nint N;\nll A,B;\nint p[5010],where[5010];\nll dp[5010][5010];\nconst ll inf = 1e18;\nint AA[5010][5010];\nint BB[5010][5010];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tcin >> N >> A >> B;\n\trep(i,N) cin >> p[i],p[i]--,where[p[i]] = i;\n\n\trep(i,N+1) rep(j,N+1) dp[i][j] = inf;\n\n\trep(a,N){\n\t\tint now = 0;\n\t\tfor(int b=a+1;b<N;b++){\n\t\t\tif(where[b]<where[a]) now++;\n\t\t\tAA[a][b] = now;\n\t\t}\n\t}\n\trep(b,N){\n\t\tint now = 0;\n\t\tfor(int a=b-1;a>=0;a--){\n\t\t\tif(where[b]<where[a]) now++;\n\t\t\tBB[a][b] = now;\n\t\t}\n\t}\n\n\tauto getAA = [&](int a,int b){\n\t\tint res = 0;\n\t\trep(i,N){\n\t\t\tif(p[i] == a) break;\n\t\t\tif(a<=p[i] && p[i]<=b) res++;\n\t\t}\n\t\treturn res;\n\t};\n\tauto getBB = [&](int a,int b){\n\t\tint res = 0;\n\t\tfor(int i=N-1;i>=0;i--){\n\t\t\tif(p[i] == b) break;\n\t\t\tif(a<=p[i] && p[i]<=b) res++;\n\t\t}\n\t\treturn res;\n\t};\n\n\tdp[0][N-1] = 0;\n\tfor(int d=N-1;d>0;d--){\n\t\trep(a,N+1){\n\t\t\tint b = a+d;\n\t\t\tif(b>N-1) break;\n\t\t\t// assert(getAA(a,b) == AA[a][b]);\n\t\t\t// assert(getBB(a,b) == BB[a][b]);\n\t\t\tint aa = AA[a][b];\n\t\t\tint bb = BB[a][b];\n\t\t\tll costA = min(B,A*aa);\n\t\t\tll costB = min(A,B*bb);\n\t\t\tchmin(dp[a+1][b],dp[a][b]+costA);\n\t\t\tchmin(dp[a][b-1],dp[a][b]+costB);\n\t\t}\n\t}\n\tll ans = inf;\n\trep(i,N) chmin(ans,dp[i][i]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define pb push_back\n#define X first\n#define Y second\n\n#define SZ(a) ((LL)(a).size())\n#define all(a) (a).begin(),a.end()\n#define forn(i, n) for(LL i = 0; i < n; ++i)\n#define ALL(x) x.begin(), x.end()\n#define ll long long\n#define MAXN 100\n#define INF 1000 * 1000 * 1000\n#define LINF INF * (LL)INF;\nint n , m , A , B;\nint a[5005];\nint de[5005];\nLL dpT[5005][5005];\nint inL [5005];\nint inR [5005];\nLL dp(int l , int r , int freeL , int freeR)\n{\n\tif(l == r)\n\t\treturn 0;\n\tif(dpT[l][r] != -1)\n\t\treturn dpT[l][r];\n\tLL ans = LINF;\n\tint newFreeL = freeL;\n\tint newFreeR = freeR;\n\twhile(newFreeL <= n && (a[newFreeL + 1] < l || a[newFreeL + 1] > r))\n\t{\n\t\tnewFreeL++;\n\t}\n\twhile(newFreeR > 0 && (a[newFreeR - 1] > r || a[newFreeR - 1] < l))\n\t{\n\t\tnewFreeR--;\n\t}\n\tLL cost = B , cost2 = A;\n\tif(a[newFreeR - 1] == r)\n\t{\n\t\tcost2 = 0;\n\t}\n\tif(a[newFreeL + 1] == l)\n\t{\n\t\tcost = 0;\n\t}\n\t//cout << l << \" \" << r << \" \" << newFreeL << \" \" << newFreeR << endl;\n\tans = min(ans , cost + dp(l + 1 , r , newFreeL , newFreeR));\n\tans = min(ans , cost2 + dp(l  , r - 1 , newFreeL , newFreeR));\n\treturn dpT[l][r] = ans;\n}\nint main()\n{\n\tmemset(dpT , -1 , sizeof dpT);\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\t\n\tcout << dp(1 , n , 0 , n + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <sstream>\n#include <math.h>\n#include <map>\n#include <set>\n#include <ios>     // std::left, std::right\n#include <iomanip> // std::setw(int), std::setfill(char)\nusing namespace std;\n\n\nint main(){\nlong long N,A,B,p,x;\ncin>>N>>A>>B;\nlong long line[N+1];\nfor(int i=0;i<N;++i){\n  //pの座標はline[p]となる\n  cin>>p;\n  line[p]=i*2+1;\n}\n//考える区間は-inf~1,1~2・・・・n-1~n、n~infのn+1この空間と1~nのnこの点\n//dp[i][x]要素iをすでに置いていて、要素iの座標がx以下である時の最小のコスト\nlong long dp[N+1][2*N+1]={};\nfor(int i=1;i<=N;++i){\n  //iのもともとの座標は\n  x=line[i];\n  for(int j=0;j<2*N+1;++j){\n    if(j%2==0){\n      //開空間だから被ってOK\n      //左に動かす時\n      if(x>j){\n        dp[i][j]=dp[i-1][j]+B;\n      }\n      else{\n        dp[i][j]=dp[i-1][j]+A;\n      }\n      //最小更新\n      if(j>0){\n      if(dp[i][j]>dp[i][j-1]){\n        dp[i][j]=dp[i][j-1];\n      }}\n    }\n    else{\n      //被り厳禁\n      if(x>j){\n        dp[i][j]=dp[i-1][j-1]+B;\n      }\n      else if(x==j){\n        dp[i][j]=dp[i-1][j-1];\n      }\n      else{\n        dp[i][j]=dp[i-1][j-1]+A;\n      }\n      //最小更新\n      if(j>0){\n      if(dp[i][j]>dp[i][j-1]){\n        dp[i][j]=dp[i][j-1];\n      }}\n    }\n  }\n}\n\nlong long ans=10000000000;\nfor(int i=0;i<2*N+1;++i){\n  if(dp[N][i]<ans){\n    ans=dp[N][i];\n  }\n}\ncout<<ans<<\"\\n\";\nreturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nstruct UnionFind {\n  private:\n  vector<int> child,tree,sum;\n\npublic:\n  UnionFind(int v) {\n    tree.resize(v);\n    sum.resize(v);\n    REP(i,v) tree[i] = i, sum[i] = 1;\n  }\n\n  int root(int i){\n    if(i == tree[i]){\n      REP(j,child.size()) tree[child[j]] = i;\n      child.clear(); \n      return i;\n    }\n    else{\n      child.push_back(i);\n      return i = root(tree[i]);\n    }\n  }\n\n  int size(int i){\n    return sum[root(i)];\n  }\n\n  int unit(int x, int y){\n    x = root(x);\n    y = root(y);\n    sum[min(x,y)] += sum[max(x,y)];\n    tree[max(x,y)] = min(x,y);\n  }\n\n  bool isUnit(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m;\n  cin >> n >> m;\n\n  vec d(n,0),x(m),y(m);\n  REP(i,m){\n    cin >> x[i] >> y[i];\n    x[i]--; y[i]--;\n    d[x[i]]++;\n    d[y[i]]++;\n  }\n\n  int sum = 0;\n  REP(i,n){\n    if(d[i]%2 == 0){\n      if(d[i] > 2) sum += d[i];\n    }\n    else{\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n\n  UnionFind uf(n);\n  REP(i,m){\n    if(d[x[i]] == 2 && d[y[i]] == 2) uf.unit(x[i],y[i]);\n  }\n\n  map<int,int> cnt[n];\n  REP(i,m){\n    if(d[x[i]] > 2) cnt[x[i]][uf.root(y[i])]++;\n    if(d[y[i]] > 2) cnt[y[i]][uf.root(x[i])]++;\n  }\n\n  int calc = 0;\n  REP(i,n){\n    ITR(itr,cnt[i]){\n      if(itr->sc == 1) calc += 1;\n      if(itr->sc == 2) calc += 2;\n    }\n  }\n\n  //debug(sum);\n  //debug(cnt);\n  //debug(calc);\n  if(calc >= 6 && sum >= 2){\n    assert(n == -1);\n    cout << \"Yes\" << endl;\n  }\n  else cout << \"No\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (5010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,wa,wb,a[N]; LL f[N][N],ans=1e18;\nint main(){\n\tread(n),read(wa),read(wb);\n\tfor(int i=1;i<=n;i++)read(a[i]);\n\tmemset(f,inf,sizeof(f)),f[0][0]=0;\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=n;j++)\n\tif(a[i]>j)f[i][j]=min(f[i-1][j]+wa,f[i][j]),f[i][a[i]]=min(f[i][a[i]],f[i-1][j]);\n\telse f[i][j]=min(f[i-1][j]+wb,f[i][j]);\n\tfor(int i=0;i<=n;i++)ans=min(ans,f[n][i]); cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\nll dp[5010][10101];\n\nint main(){\n   int n,a,b; cin>>n>>a>>b;\n   vector<int> p(n); rep(i,0,n)cin>>p[i],p[i]--;\n   vector<int> rev(n); rep(i,0,n)rev[p[i]]=i*2+1;\n   rep(i,0,n+1)rep(j,0,2*n+1)dp[i][j]=INF;\n   rep(j,0,2*n+1)dp[0][j]=0;\n   rep(i,0,n){\n      rep(j,0,2*n+1){\n         int add;\n         if(j==rev[i])add=0;\n         if(j>rev[i])add=a;\n         if(j<rev[i])add=b;\n         if(j)chmin(dp[i+1][j],dp[i][j-1]+add);\n      }\n      rep(j,0,2*n)chmin(dp[i+1][j+1],dp[i+1][j]);\n   }\n   cout<<dp[n][2*n]<<endl;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n, a, b, num[3007], dp[3007][3007], res = 1e18;\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nsigned main()\n{\n\tn = read();\n\ta = read();\n\tb = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tnum[i] = read();\n\tmemset(dp, 0x3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tif (num[i] > j)\n\t\t\t{\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + a);\n\t\t\t\tdp[i][num[i]] = min(dp[i][num[i]], dp[i - 1][j]);\n\t\t\t}\n\t\t\telse dp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n\tfor (int i = 0; i <= n; i++)\n\t\tres = min(res, dp[n][i]);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nint main(){\n    int N, A, B;\n    cin >> N >> A >> B;\n    vector<int> p(N);\n    for(int i=0; i<N; i++)\n        cin >> p[i];\n    vector<int> pinv(N+1);\n    for(int i=0; i<N; i++)\n        pinv[p[i]] = 2*i+1;\n\n    vector<long long> dp0(2*(N+1), 1LL<<60);\n    dp0[0] = 0;\n    for(int i=1; i<=N; i++){\n        vector<long long> dp1(2*(N+1), 1LL<<60);\n        long long mn = 1LL<<60;\n\n        for(int j=0; j<pinv[i]; j+=2){\n            mn = min(mn, dp0[j]);\n            dp1[j] = mn + B;\n            mn = min(mn, dp0[j+1]);\n        }\n\n        dp1[pinv[i]] = mn;\n\n        for(int j=pinv[i]+1; j<=2*N; j+=2){\n            mn = min(mn, dp0[j]);\n            dp1[j] = mn + A;\n            mn = min(mn, dp0[j+1]);\n        }\n        dp0 = dp1;\n    }\n    long long ans = 1LL<<60;\n    for(int i=0; i<2*(N+1); i++)\n        ans = min(ans, dp0[i]);\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define X first\n#define Y second\n#define FOR(i, a, b) for(int i = a; i <= b; i++)\n#define FOD(i, a, b) for(int i = a; i >= b; i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int N = 5010;\nconst ll INF = 1e18;\n\n/// x ->\n/// y <-\n\nint n, a[N];\nint cnt[N][N];\nll x, y, F[N][N];\n\nint main(){\n    if (fopen(\"inp.txt\", \"r\")){\n        freopen(\"inp.txt\", \"r\", stdin);\n        freopen(\"out.txt\", \"w\", stdout);\n    }\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> x >> y;\n    FOR(i, 1, n)\n        cin >> a[i];\n\n    FOR(i, 0, n)\n        FOR(j, 0, n)\n            F[i][j] = INF;\n\n    F[0][0] = 0;\n    FOR(i, 0, n - 1)\n        FOR(val, 0, n)\n            if (val < a[i + 1]){\n                F[i + 1][val] = min(F[i + 1][val], F[i][val] + x);\n                F[i + 1][a[i + 1]] = min(F[i + 1][a[i + 1]], F[i][val]);\n            } else {\n                F[i + 1][val] = min(F[i + 1][val], F[i][val] + y);\n            }\n\n    ll ans = INF;\n\n    FOR(i, 0, n)\n        ans = min(ans, F[n][i]);\n    cout << ans;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 5010;\nconst int MOD = 1e9 + 7;\n\nint n, A, B;\nint p[N], pos[N], dp[N];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) cin >> p[i], pos[p[i]] = i;\n    n++;\n    pos[n] = n, p[n] = n;\n    for (int i = 1; i <= n; i++)\n    {\n    \tdp[i] = 1e18;\n    \tfor (int j = i - 1; j >= 0; j--)\n    \t{\n    \t\tif (pos[j] < pos[i])\n    \t\t{\n    \t\t\tint ca = 0, cb = 0, t = 1;\n    \t\t\tfor (int k = j + 1; k < i; k++)\n    \t\t\t{\n    \t\t\t\tif (pos[k] > pos[j]) cb++;\n    \t\t\t\telse if (pos[k] < pos[i]) ca++;\n    \t\t\t\telse t = 0;\n    \t\t\t}\n    \t\t\tif (t)\n    \t\t\t{\n    \t\t\t\tdp[i] = min(dp[i], dp[j] + ca * A + cb * B);\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    cout << dp[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define loop(i, a, b, inc) for(int i = a; i < (b); i += inc)\n#define rep(i, n) loop(i, 0, n, 1)\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nll total = 0;\nll l;\nll r;\n\npair<pii, bool> merge(pii a, pii b) { // assume b lower than a, and a is left of b\n\t// bool = shift right\n\tll al = a.second-a.first+1;\n\tll bl = b.second-b.first+1;\n\n\ttotal += min(al*l, bl*r);\n\n\treturn {{b.first, a.second}, bl*r < al*l};\n}\n\nvoid fn(vector<pii> &arr) {\n\tint n = arr.size();\n\n\twhile (n != 1) {\n\t\tmap<int, int> seenprev;\n\t\tseenprev[arr[0].first] = 0;\n\t\tloop(i, 1, n, 1) {\n\t\t\tif (arr[i].first == arr[i-1].second + 1) {\n\t\t\t\tarr[i] = {arr[i-1].first, arr[i].second};\n\t\t\t\ti--;\n\t\t\t\tarr.erase(arr.begin() + i);\n\t\t\t\tn--;\n\t\t\t\tcontinue;\t\n\t\t\t}\n\t\t\tif (seenprev.count(arr[i].second+1) == 0) {\n\t\t\t\tseenprev[arr[i].first] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint j = seenprev[arr[i].second+1];\n\t\t\tauto res = merge(arr[j], arr[i]);\n\t\t\tif (res.second) {\n\t\t\t\tarr[j] = res.first;\n\t\t\t\tarr.erase(arr.begin()+i);\n\t\t\t} else {\n\t\t\t\tarr[i] = res.first;\n\t\t\t\tarr.erase(arr.begin()+j);\n\t\t\t}\n\t\t\tn--;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n >> l >> r;\n\n\tvector<pii> arr(n);\n\trep(i, n) {\n\t\tint x;\n\t\tcin >> x;\n\t\tarr[i] = {x, x};\n\t}\n\n\tfn(arr);\n\tcout << total << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 5000;\nll dp[N + 1][N + 1];\nint x[N + 1], in[N + 1];\n\ninline void up(ll &x, ll y) { if (y < x)x = y; }\n\nint main(){\n\tint n, a, b;\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tf(i, 1, n + 1)scanf(\"%d\", x + i);\n\tf(i, 1, n + 1)in[x[i]] = i;\n\tf(i, 0, n + 1)f(j, 0, n + 1)dp[i][j] = 1e18;\n\tdp[0][0] = 0;\n\tf(p, 0, n + 1)f(i, 0, n){\n\t\tint lc = in[i + 1];\n\t\tup(dp[p][i + 1], dp[p][i] + (lc < p ? a : b));\n\t\tif (lc >= p)up(dp[lc][i + 1], dp[p][i]);\n\t}\n\tll an = 1e18;\n\tf(i, 0, n + 1)up(an, dp[i][n]);\n\tprintf(\"%lld\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = uint64_t;\nusing ll = int64_t;\nusing ld = long double;\n\nconst int N = 5228;\nll f[N][N];\nint p[N];\n\nconst ll INF = (1ll << 60);\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif  \n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n    int n;\n    ll a, b;\n    cin >> n >> a >> b;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        --p[i];\n    }\n\n    p[n] = n;\n\n    for (int i = 0; i <= n + 1; ++i) {\n        fill(f[i], f[i] + n + 1, INF);\n    }\n\n    f[0][0] = 0;\n   \n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            ll cf = f[i][j];\n            if (p[i] >= j) {\n                f[i + 1][p[i]] = min(f[i + 1][p[i]], cf);\n                f[i + 1][j] = min(f[i + 1][j], cf + a);\n            } else {\n                f[i + 1][j] = min(f[i + 1][j], cf + b);\n            }\n        }\n    }\n\n    cout << f[n + 1][n] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nint main(){\n    ll n,a,b;\n    cin>>n>>a>>b;\n    vector<pll> A(n);\n    for(int i=0;i<n;i++){cin>>A[i].F; A[i].S=i;}\n    sort(A.begin(),A.end());\n    vector<ll> dp(n+1,0);\n    vector<ll> next(n+1,0);\n    for(auto &I:A){\n        ll mi=E;\n        for(int i=0;i<=n;i++){\n            mi=min(mi,dp[i]);\n            if(i<=I.S){next[i]=mi+b;}\n            else if(i==I.S+1){next[i]=mi;}\n            else{next[i]=mi+a;}\n        }\n        dp=next;\n    }\n    ll ans=E;\n    for(auto &I:dp){ans=min(ans,I);}\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, A, B;\nint p[5005];\nint rev[5005];\nlong long memo[5005][5005];\n\nbool skipLeft[5005][5005];\nbool skipRight[5005][5005];\n\nlong long dp(int i, int j){\n    if(i > j){\n        return 0;\n    }else if(memo[i][j] != -1){\n        return memo[i][j];\n    }else{\n        /*vector<int> p2;\n        for(int k = 1; k <= N; k ++){\n            if(p[k] >= i && p[k] <= j){\n                p2.push_back(p[k]);\n            }\n        }*/\n\n        /*if(p2[0] == i){\n            return dp(i+1, j);\n        }else if(p2[j-i] == j){\n            return dp(i, j-1);\n        }*/\n\n        if(skipLeft[i][j]){\n            return dp(i+1, j);\n        }else if(skipRight[j][i]){\n            return dp(i, j-1);\n        }\n\n        return memo[i][j] = min(B + dp(i+1, j), A + dp(i, j-1));\n    }\n}\n\nint main(){\n    scanf(\"%d%d%d\", &N, &A, &B);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &p[i]);\n        rev[p[i]] = i;\n    }\n\n    for(int i = 1; i <= N; i ++){\n        skipLeft[i][i] = true;\n        for(int j = i+1; j <= N; j ++){\n            if(rev[j] < rev[i]){\n                // if j comes before i, then everything is false\n                skipLeft[i][j] = false;\n            }else{\n                skipLeft[i][j] = skipLeft[i][j-1];\n            }\n        }\n    }\n\n    for(int i = 1; i <= N; i ++){\n        skipRight[i][i] = true;\n        for(int j = i-1; j >= 1; j --){\n            if(rev[j] > rev[i]){\n                // if j comes before i, then everything is false\n                skipRight[i][j] = false;\n            }else{\n                skipRight[i][j] = skipRight[i][j+1];\n            }\n        }\n    }\n\n    /*for(int i = 1; i <= N; i ++){\n        for(int j = 1; j <= N; j ++){\n            printf(\"skipRight[%d][%d]\",)\n        }\n    }*/\n\n    memset(memo, -1, sizeof(memo));\n    printf(\"%lld\", dp(1, N));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int N=5002;\nLL dp[N][N];\nint n,a,b,x[N],pos[N];\nint mn[N][N],mx[N][N];\n\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]), pos[x[i]]=i;\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)dp[i][j]=1e18;\n    dp[0][n+1]=0;\n    for(int i=1;i<=n;i++){\n        mx[i][i]=mn[i][i]=pos[i];\n        for(int j=i+1;j<=n;j++){\n            mx[i][j]=max(mx[i][j-1],pos[j]);\n            mn[i][j]=min(mn[i][j-1],pos[j]);\n        }\n    }\n    for(int len=0;len<n;len++)\n    for(int i=0;i<=n;i++){\n        int lef=i,rig=n+1-(len-i);\n        // [1,lef], [rig,n]\n        if(lef+1<rig){\n            //printf(\"len=%d,lef=%d,rig=%d %lld\\n\", len,lef,rig,dp[lef][rig]);\n            dp[lef+1][rig]=min(dp[lef+1][rig], dp[lef][rig]+(LL)(pos[lef+1]==mn[lef+1][rig-1]?0:b));\n            dp[lef][rig-1]=min(dp[lef][rig-1], dp[lef][rig]+(LL)(pos[rig-1]==mx[lef+1][rig-1]?0:a));\n        }\n    }\n    LL ans=1e18;\n    for(int i=0;i<=n;i++)ans=min(ans,dp[i][i+1]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEBUG\n#include \"better_io.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\nconstexpr int MAXN = 5042;\n\nint N, A, B;\nint V[MAXN];\nint pos[MAXN];\nint le[MAXN];\nll gt[MAXN][MAXN];\nll dp[MAXN][MAXN];\n\nll solve(int i, int x) {\n\tif(i >= N-1) return 0;\n\tif(x >= N-1) return 0;\n\tif(dp[i][x] != -1) return dp[i][x];\n\tdp[i][x] = min(solve(i, x + 1) + B, solve(pos[x] + 1, le[x+1]) + A * gt[i][pos[x]]);\n\treturn dp[i][x];\n}\n\nint main() {\n\tmemset(dp, -1, sizeof dp);\n    memset(le, 0x3f3f3f, sizeof dp);\n\n\tcin >> N >> A >> B;\n\n\tfor(int i=0; i<N; i++) {\n\t\tcin >> V[i];\n\t\tV[i]--;\n\t\tpos[V[i]] = i;\n\t}\n\n    for(int i=N-1; i>=0; i--) {\n        le[i] = min(V[i], le[i+1]);\n    }\n\n\tfor(int j=0; j<N; j++) {\n\t\tfor(int i=j-1; i>=0; i--) {\n\t\t\tgt[i][j] = gt[i+1][j] + (V[i] > V[j]);\n\t\t}\n\t}\n\n\tcout << solve(0, 0) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n#define int long long\nconst int N = 3e5 + 233;\nint n, A, B, a[N], dp[N];\nsigned main(void) {\n    read(n); read(A); read(B);\n    rep (i, n) read(a[i]);\n    memset(dp, 38, sizeof dp);\n    dp[0] = 0;\n    rep (i, n) {\n        int f = 0;\n        for (int k = 1; k < i; k++)\n            f += a[k] < a[i];\n        dp[i] = dp[i - 1] + (f == n - 1 ? 0 : B);\n        int p = 0;\n        for (int k = i - 1; k >= 1; k--) {\n            p += a[k] > a[i];\n            dp[i] = min(dp[i], dp[k - 1] + p * A);\n        }\n    }\n    cout << dp[n] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nint n,p[5005],a,b,l=1,r;ll inf=1ll<<60ll,f[5005][5005],mi[5005][5005],mx[5005][5005];\nll dfs(int l,int r){\n    if(l>=r) return 0;\n    if(f[l][r]) return f[l][r];\n    ll ans=inf;\n    ans=min(dfs(l+1,r)+a,dfs(l,r-1)+b);\n    if(p[l]<mi[l+1][r]) ans=min(ans,dfs(l+1,r));\n    if(p[r]>mx[l][r-1]) ans=min(ans,dfs(l,r-1));\n    for(int i=l+1;i<r;i++) if(mx[l][i]<mi[i+1][r]) ans=min(ans,dfs(l,i)+dfs(i+1,r));\n    return f[l][r]=ans;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++)scanf(\"%d\",p+i);\n    for(int i=1;i<=n;i++) mi[i][i]=mx[i][i]=p[i];\n    for(int i=1;i<=n;i++)\n    for(int j=1;j+i<=n;j++){\n        mi[j][i+j]=min(mi[j][j],mi[j+1][i+j]);mx[j][i+j]=max(mx[j][j],mx[j+1][i+j]);\n    }\n    printf(\"%lld\\n\",dfs(1,n));\n    //for(int i=1;i<=n;i++)\n    //for(int j=1;j<=n;j++)\n    //printf(\"%6lld%c\",f[i][j],j==n?'\\n':' ');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;long long n,aa,i,j,b,f[5005],pos[5005],ans,a[5005],c[5005];int main(){ans=12345678912345678ll;cin>>n>>aa>>b;for (i=1;i<=n;i++) f[i]=ans;for (i=1;i<=n;i++){\tcin>>a[i];pos[a[i]]=i;\t}\tfor (i=1;i<=n;i++){\t\tc[i]=c[i-1]+(i<a[i]?aa:b);\t}\tfor (i=1;i<=n;i++){\t\tlong long s=0;\t\tfor (j=i-1;j>=0;j--){\t\t\tif (a[j]<a[i]){\t\t\t\tf[i]=min(f[i],f[j]+s);\t\t\t}\t\t\tif (a[j]<a[i]){\t\t\t\ts+=b;\t\t\t} else {\t\t\t\ts+=aa;\t\t\t}\t\t}\t\tans=min(ans,f[i]+(n-i)*b);\t}\tcout<<ans<<endl;return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nlong long dp[5005][5005][2];\nint a[5005],id[5005];\nint main(){\n\tint n;\n\tlong long A,B;\n\tcin>>n>>A>>B;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tid[a[i]]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(j)dp[i][j][0]=min(min(dp[i-1][j][0],dp[i-1][j][1]),dp[i][j-1][0]);\n\t\t\telse dp[i][j][0]=dp[i-1][j][0];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(j>=id[i])dp[i][j][0]+=A; else dp[i][j][0]+=B;\n\t\t\tdp[i][j][1]=dp[i][j][0];\n\t\t}\n\t\tlong long mi=1e18;\n\t\tfor(int j=0;j<id[i];j++){\n\t\t\tmi=min(mi,min(dp[i-1][j][0],dp[i-1][j][1]));\n\t\t}\n\t\tdp[i][id[i]][1]=mi;\n\t//\tcout<<dp[i][id[i]][1]<<\" \";\n\t}\n\tlong long mi=1e18;\n\tfor(int i=0;i<=n;i++){\n\t\tmi=min(min(dp[n][i][0],dp[n][i][1]),mi);\n\t}\n\tcout<<mi;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (size_t NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (size_t NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n#define VEC(TYPE, A, NAME, INIT) vector<TYPE> NAME(A, INIT)\n#define VEC2(TYPE, A, B, NAME, INIT) vector<vector<TYPE>> NAME(A, vector<TYPE>(B, (INIT)))\n\nint main()\n{\n\tll n, a, b;\n\tcin >> n>>a>>b;\n\tVEC(ll,n,p,0);\n\tVEC(ll,n,q,0);\n\tREP(i,n)\n\t{\n\t\tcin>>p[i];\n\t\tq[p[i]-1] = i;\n\t}\n\tVEC2(ll,n+1,n,dp,0);\n\n\tREP(i,n) REP(j,n)\n\t{\n\t\tll cost = 0;\n\t\tif( q[i] < j ) cost = a;\n\t\telse if( q[i] > j ) cost = b;\n\t\tdp[i+1][j] = j == 0\n\t\t\t? dp[i][j] + cost\n\t\t\t: min( dp[i+1][j-1], dp[i][j] + cost );\n\t}\n\n\tcout << dp[n][n-1] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nll n,a,b;\nint p[5005];\nll d[10005],s[10005];\n\nint main(){\n\tn=readint(); a=readint(); b=readint();\n\tfor(int i=1;i<=n;i++) p[readint()]=i;\n\tmemset(d,0x3f,sizeof(d));\n\td[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=2*n;j++){\n\t\t\tif(j&1) d[j]=s[j-1]+(p[i]==(j+1)/2?0:p[i]<(j+1)/2?a:b);\n\t\t\telse d[j]=s[j]+(p[i]>=(j+1)/2?b:a);\n\t\t}\n\t\ts[0]=d[0];\n\t\tfor(int j=1;j<=2*n;j++) s[j]=min(s[j-1],d[j]);\n\t}\n\tprintf(\"%lld\\n\",s[2*n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int3(n, mm, mmn);\n    vector<int> data(n);\n    for (int i = 0; i < n; i++) {\n        cin >> data[i];\n    }\n    \n    vvi mmnmm(n+2, vi(n+2, INF));\n    mmnmm[0][0] = 0;\n\n    rep(i, n+1) {\n        rep(j, n+1) {\n            if (i != n && data[i] == j+1) {\n                mmnmm[i+1][j+1] = min(mmnmm[i+1][j+1], mmnmm[i][j]);\n            }\n            if (i != n && data[i] > j) {\n                mmnmm[i+1][j] = min(mmnmm[i+1][j], mmnmm[i][j] + mm);\n            } else if (i != n) {\n                mmnmm[i+1][j] = min(mmnmm[i+1][j], mmnmm[i][j] + mmn);\n            }\n            mmnmm[i][j+1] = min(mmnmm[i][j+1], mmnmm[i][j]);\n            mmnmm[i][j+1] = min(mmnmm[i][j+1], mmnmm[i][j]);\n        }\n    }\n    /*\n    rep(i, n+1) {\n        rep(j, n+1) {\n            cout << mmnmm[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n    cout << mmnmm[n][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n    const int l=1<<20;\n    char buf[l],*s,*t,c;\n    inline void gc(){\n        if(s==t){\n            t=(s=buf)+fread(buf,1,l,stdin);\n            c=s==t?EOF:*s++;\n        }else c=*s++;\n    }\n    template<class IT>inline void gi(IT &x){\n        x=0;gc();while(c<'0'||c>'9')gc();\n        while('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n    }\n    char buf0[20];int a;\n    template<class IT>inline void pi(IT x){\n        if(x<0){putchar('-');x=-x;}\n        do buf0[++a]=x%10+48;while(x/=10);\n        while(a)putchar(buf0[a--]);\n        putchar('\\n');\n    }\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=5005;\nll d[N][N];int x[N];\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n,i,j,lp,rp,xi,xj;ll a,b;\n    scanf(\"%d%lld%lld\",&n,&a,&b);\n    rep(i,1,n){scanf(\"%d\",&xi);x[xi]=i;}\n\tper(i,n,1){\n\t\tlp=rp=xi=x[i];\n\t\trep(j,i+1,n){\n\t\t\tcmin(lp,xj=x[j]);\n\t\t\tcmax(rp,xj     );\n\t\t\tif(lp==xi)d[i][j]=d[i+1][j  ];else\n\t\t\tif(rp==xj)d[i][j]=d[i  ][j-1];else\n\t\t\td[i][j]=min(d[i+1][j]+b,d[i][j-1]+a);\n\t\t}\n\t}\n\tprintf(\"%lld\",d[1][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<int> p(n + 2);\n    for (int i = 1; i <= n; ++i)\n        cin >> p[i];\n    p.back() = n + 1;\n    vector<LL> dp(n + 2, 1E18);\n    dp[0] = 0;\n    for (int i = 1; i <= n + 1; ++i) {\n        for (int j = i - 1, c = 0; j >= 0; --j) {\n            if (p[j] > p[i])\n                ++c;\n            else\n                dp[i] = min(dp[i], dp[j] + 1LL * c * a + 1LL * (i - j - 1 - c) * b);\n        }\n    }\n    cout << dp.back() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//!link: m,stdc++\n//!flag: -g,-DWAAUTOMATON\n// failed\n/*+lmake\n * DEFINE += WAAUTOMATON\n */\n#include <bits/stdc++.h>\n#ifdef WAAUTOMATON\n#define debug(args...)                                                                             \\\n    {                                                                                              \\\n        dbg, args;                                                                                 \\\n        cerr << endl;                                                                              \\\n    }\n#define massert(x) assert(x)\n#else\n#define debug(args...) // Just strip off all debug tokens\n#define massert(x)\n#endif\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef std::pair<int, int> pii;\ntypedef std::pair<LL, LL> pll;\nstruct debugger\n{\n    template <typename T>\n    debugger &operator,(const T &v)\n    {\n        std::cerr << v << \" \";\n        return *this;\n    }\n} dbg;\n\ntemplate <typename T>\ninline void chmax(T &a, T b)\n{\n    a = std::max(a, b);\n}\n\ntemplate <typename T>\ninline void chmin(T &a, T b)\n{\n    a = std::min(a, b);\n}\n\ntemplate <typename T>\ninline T sqr(const T& x)\n{\n\treturn x*x;\n}\n\ntemplate <size_t _I_Buffer_Size = 1 << 23, size_t _O_Buffer_Size = 1 << 23>\nstruct IO_Tp\n{\n    char _I_Buffer[_I_Buffer_Size];\n    char *_I_pos;\n    const char *_I_end;\n\n    char _O_Buffer[_O_Buffer_Size];\n    char *_O_pos;\n    const char *_O_end;\n\n    IO_Tp()\n        : _I_pos(_I_Buffer)\n        , _O_pos(_O_Buffer)\n        , _I_end(_I_Buffer + _I_Buffer_Size)\n        , _O_end(_O_Buffer + _O_Buffer_Size)\n    {\n    }\n\n    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }\n\n    inline char getchar()\n    {\n        char res = *_I_pos;\n        nextchar();\n        return res;\n    }\n\n    inline bool is_digit(const char ch) { return '0' <= ch && ch <= '9'; }\n\n    inline void nextchar()\n    {\n        ++_I_pos;\n        if (_I_pos == _I_end) {\n            fread(_I_Buffer, 1, _I_Buffer_Size, stdin);\n            _I_pos = _I_Buffer;\n        }\n    }\n\n    template <typename Int>\n    inline IO_Tp &operator>>(Int &res)\n    {\n        res = 0;\n        int k = 1;\n        while (!is_digit(*_I_pos)) {\n            if (*_I_pos == '-')\n                k = -1;\n            nextchar();\n        }\n        do {\n            (res *= 10) += (*_I_pos) - '0';\n            nextchar();\n        } while (is_digit(*_I_pos));\n        res *= k;\n        return *this;\n    }\n\n    inline IO_Tp &operator>>(char &res)\n    {\n        do {\n            res = *_I_pos;\n            nextchar();\n        } while (res == ' ' || res == '\\0' || res == '\\t' || res == '\\n' || res == '\\r');\n        return *this;\n    }\n\n    inline void putchar(char x)\n    {\n        if (_O_pos == _O_end) {\n            fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout);\n            _O_pos = _O_Buffer;\n        }\n        *_O_pos++ = x;\n    }\n    template <typename Int>\n    inline IO_Tp &operator<<(Int n)\n    {\n        if (n < 0) {\n            putchar('-');\n            n = -n;\n        }\n        static char _buf[20];\n        char *_pos(_buf);\n        do\n            *_pos++ = '0' + n % 10;\n        while (n /= 10);\n        while (_pos != _buf)\n            putchar(*--_pos);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(char ch)\n    {\n        putchar(ch);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(const char *s)\n    {\n        while (*s != 0) {\n            putchar(*s);\n            ++s;\n        }\n        return *this;\n    }\n};\nIO_Tp<> IO;\n\nconst int MAXN=5000;\nint a[MAXN+10];\nLL A,B;\nvector<int> in[MAXN+10],out[MAXN+10];\nint icnt[MAXN+10],ocnt[MAXN+10];\nvoid add(int x)\n{\n\tfor(auto v:out[x]) {\n\t\ticnt[v]++;\n\t}\n}\nbool b[MAXN+10];\nint main()\n{\n#ifdef WAAUTOMATON\n    //freopen(\"./in_D_5.txt\", \"r\", stdin);\n#endif\n\tLL ans=LLONG_MAX/3;\n\tint n;\n\tIO>>n>>A>>B;\n\tfor(int i=1; i<=n; ++i) {\n\t\tIO>>a[i];\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=i+1; j<=n; ++j) {\n\t\t\tif (a[i]>a[j]) {\n\t\t\t\tin[a[i]].push_back(a[j]);\n\t\t\t\tout[a[j]].push_back(a[i]);\n\t\t\t\tocnt[a[j]]++;\n\t\t\t}\n\t\t}\n\t}\t\n\tLL cntb=n;\n\tfor(int i=1; i<=n; ++i) {\n\t\tif (ocnt[i]==0) --cntb;\n\t\telse if (ocnt[i]==1) {\n\t\t\tadd(i);\n\t\t}\n\t}\n\tchmin(ans,cntb*B);\n\tfor(LL cnta=1; cnta<=n; ++cnta) {\n\t\tint p=0;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tif (!b[i] && icnt[i]>=icnt[p]) {\n\t\t\t\tp=i;\n\t\t\t}\n\t\t}\n\t\tif (p==0 || icnt[p]==0) break;\n\t\tcntb-=icnt[p];\n\t\tchmin(ans,cnta*A+cntb*B);\n\t\tif (cntb==0) break;\n\t\tb[p]=true;\n\t\tfor(auto v:in[p]) {\n\t\t\tocnt[v]--;\n\t\t\tif (ocnt[v]==1) {\n\t\t\t\tadd(v);\n\t\t\t}\n\t\t}\n\t}\n\tIO<<ans<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"vector\"\n\nusing namespace std;\n\nint main(){\n\tint N,L,R;\n\tcin>>N>>R>>L;\n\tvector<int>v(N);\n\tfor(auto &i:v)cin>>i;\n\tvector<int>place(N+1);\n\tfor(int i=0;i<N;i++){\n\t\tplace[v[i]]=i;\n\t}\n\tvector<vector<long long int>>dp(2,vector<long long int>(N+2));\n\tfor(int i=1;i<=N;i++){\n\t\tint index =i&1;\n\t\tlong long int box=dp[index^1][0];\n\t\tfor(int j=0;j<=N+1;j++){\n\t\t\tbox=min(box,dp[index^1][j]);\n\t\t\tif(place[i]+1>j)dp[index][j]=box+L;\n\t\t\telse if(place[i]+1==j)dp[index][j]=box;\n\t\t\telse dp[index][j]=box+R;\n\t\t}\n\t}\n\tlong long int ans=1000000000000000000;\n\tfor(int i=0;i<=N+1;i++)ans=min(ans,dp[N&1][i]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong DP[5001*5001];\nint P[5000];\nvoid Calc(){\n\tint N = rei();\n\tlong A = rei();\n\tlong B = rei();\n\tfor(int i=0;i<N;i++){\n\t\tint p = rei()-1;\n\t\tP[p] = i+1;\n\t}\n\tfill(DP,DP+5001*5001,1000000000000000000);\n\tDP[0] = 0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<=N;j++){\n\t\t\tif(P[i] < j){\n\t\t\t\tDP[(i+1)*5001+j] = min(DP[(i+1)*5001+j],DP[i*5001+j]+A);\n\t\t\t}\n\t\t\telse if(P[i] > j){\n\t\t\t\tDP[(i+1)*5001+j] = min(DP[(i+1)*5001+j],DP[i*5001+j]+B);\n\t\t\t\tDP[(i+1)*5001+P[i]] = min(DP[(i+1)*5001+P[i]],DP[i*5001+j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tDP[(i+1)*5001+j] = min(DP[(i+1)*5001+j],DP[i*5001+j]);\n\t\t\t}\n\t\t}\n\t}\n\tlong ans = 1000000000000000000;\n\tfor(int i=0;i<=N;i++){\n\t\tans = min(ans,DP[N*5001+i]);\n\t}\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n// #include <bits/extc++.h>\nusing namespace std;\n\n#define debug(s) cout << #s << \" = \" << s << endl\n#define all(v) (v).begin(), (v).end()\n#define KeepUnique(v) (v).erase( unique(all(v)), v.end() )\n#define MEMSET(a, val) memset(a, val, sizeof (a))\n#define PB push_back\n#define endl '\\n'\ntypedef long long ll;\n\ninline int myrand(int l, int r) {\n\tint ret = rand(); ret <<= 15; ret ^= rand();\n\tif(ret < 0) ret = -ret; ret %= (r-l+1); ret += l;\n\treturn ret;\n}\n\ntemplate <typename F, typename S>\nostream& operator << (ostream &os, const pair<F, S> &p) {\n\treturn os << \"(\" << p.first << \", \" << p.second << \")\"; }\n\ntypedef pair<int, int> ii;\n\ntemplate<typename T> using min_pq =\n\tstd::priority_queue<T, vector<T>, greater<T> >;\n\n//int dx[] = {-1, +0, +1, +0};\n//int dy[] = {+0, +1, +0, -1};\n\nconst int maxn = 5005;\n\nll A, B;\nint n, a[maxn], where[maxn];\nll dp[maxn];\n\nll f(int x) {\n\tif(x == 1) return 0;\n\tll &ret = dp[x];\n\tif(ret != -1) return ret;\n\tret = LLONG_MAX;\n\tint less = 0;\n\tfor(int i = 1; i < x; i++) {\n\t\tif(where[i] > where[x]) less++;\n\t}\n\tret = min(ret, f(x - 1) + A);\n\tret = min(ret, f(x - less - 1) + (ll)less * B);\n\treturn ret;\n}\n\nint32_t main () {\n\t// freopen(\"in\", \"r\", stdin);\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i]; where[a[i]] = i;\n\t}\n\tmemset(dp, -1, sizeof dp);\n\tcout << f(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"-O3\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* Starry Sky Tree */\n//0-index\n\nstruct StarrySkyTree{\n  typedef ll Type;\n  int segn2;\n  vector<Type> data, s_data;\n\n  StarrySkyTree(int n) {\n    for(segn2=1; segn2<n; segn2*=2);\n    data.assign(segn2*2, 0);\n    s_data.assign(segn2*2, 0);\n  }\n\n  //get value of [a,b)\n  Type query(int a, int b, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(r <= a || b <= l) return LLINF; //大きさに注意\n    if(a <= l && r <= b) return data[k] + s_data[k];\n    return min(query(a, b, l, (l+r)/2, k*2+1), query(a, b, (l+r)/2 , r, k*2+2)) + s_data[k];\n  }\n\n  //add x to [a,b)\n  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(a <= l && r <= b)\n      s_data[k] += x;\n    else if(a < r && l < b)\n      data[k] = min(add(a, b, x, l, (l+r)/2, k*2+1), add(a, b, x, (l+r)/2, r, k*2+2));\n\n    return data[k] + s_data[k];\n  }\n\n  Type val(int x){\n    Type res = 0;\n    x += segn2 - 1;\n\n    while(x){\n      res += s_data[x];\n      x = (x-1)/2;\n    }\n\n    return res;\n  }\n\n  void add(int a, Type x){\n    a += segn2 - 1;\n    s_data[a] += x;\n\n    while(a){\n      a = (a-1)/2;\n      data[a] = min(data[a*2+1] + s_data[a*2+1], data[a*2+2] + s_data[a*2+2]);\n    }\n  }\n};\n\nint main(){\n  int N, A, B, p;\n\n  scanf(\"%d%d%d\", &N, &A, &B);\n\n  StarrySkyTree seg(N+1);\n\n  for(int i=0;i<N;i++){\n    scanf(\"%d\", &p);\n\n    seg.add(p, seg.query(0, p) - seg.val(p));\n    seg.add(0, p, A);\n    seg.add(p+1, N+1, B);\n  }\n\n  ll ans = seg.query(0, N+1);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll A,B;\nint n;\nconst int N=2010;\nint a[N],pos[N];\nll f[N][N];\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tpos[a[i]]=i;\n\t}\n\tfor(int i=0;i<=n;i++)f[0][i]=B*i;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j) f[i][j]=min(f[i][j],f[i][j-1]+(pos[j]>i ? B:A) );\n\t\t\tif(j&&pos[j]==i) f[i][j]=min(f[i][j],f[i-1][j-1]);\n//\t\t\tcout<<i<<\" \"<<j<<\" :: \"<<f[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<f[n][n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nll dp[5001][5001];\n\nint a[5001];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,A,B;\n\tcin>>n>>A>>B;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tdp[i][j]=1e18;\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(a[i]>j){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+A);\n\t\t\t\tdp[i][a[i]]=min(dp[i][a[i]],dp[i-1][j]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n\tcout<<*min_element(dp[n]+1,dp[n]+n+1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 998244353LL;// (ll)(1e9 + 7);\n\n\nvoid solve()\n{\n\tll N, A, B;\n\tcin >> N >> A >> B;\n\tauto p = cinv(N);\n\n\tvvll dp(N, vll(N+1, INF));\n\n\tauto Dp = [&](ll i, ll j)->ll &{\n\t\treturn dp[i][j];\n\t};\n\n\tDp(0, 0) = A;\n\tDp(0, p[0]) = 0;\n\n\tREP(i, N-1){\n\t\tREP(j, N+1){\n\t\t\tif (Dp(i, j) == INF) continue;\n\n\t\t\tll k = p[i+1];\n\t\t\tif (j < k){\n\t\t\t\tchmin(Dp(i+1, j), Dp(i, j) + A);\n\t\t\t\tchmin(Dp(i+1, k), Dp(i, j));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchmin(Dp(i+1, j), Dp(i, j) + B);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << MinE(dp[N-1]) << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=5005;\nconst ll INF=1LL<<60;\nll dp[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    ll A,B;cin>>A>>B;\n    vector<int> S(N);\n    for(int i=0;i<N;i++) cin>>S[i];\n    \n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            dp[i][j]=INF;\n        }\n    }\n    dp[0][0]=0;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            if(j<S[i]){\n                dp[i+1][S[i]]=min(dp[i+1][S[i]],dp[i][j]);\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+A);\n            }else{\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+B);\n            }\n        }\n    }\n    \n    ll ans=INF;\n    \n    for(int i=1;i<=N;i++) ans=min(ans,dp[N][i]);\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\ntemplate<typename T> inline LL squ(T x) { return (LL) x * x; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T> inline T read()\n{\n\tT sum = 0, fg = 1; char c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') fg = -1;\n\tfor (; isdigit(c); c = getchar()) sum = (sum << 3) + (sum << 1) + (c ^ 0x30);\n\treturn fg * sum;\n}\n\nconst int maxn = 5e3 + 10;\nconst LL inf = 0x3f3f3f3f3f3f3f3f;\n\nint n, R, L, a[maxn];\nLL dp[maxn];\n\nint main()\n{\n\n\tn = read<int>(), R = read<int>(), L = read<int>();\n\tfor (int i = 1; i <= n; i++) a[i] = read<int>();\n\n\tmemset(dp, 0x3f, sizeof dp), dp[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tLL sum = 0;\n\t\tfor (int j = i - 1; ~j; j--)\n\t\t{\n\t\t\tif (a[j] < a[i]) chkmin(dp[i], dp[j] + sum), sum += L;\n\t\t\telse sum += R;\n\t\t}\n\t}\n\n\tcout << dp[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n//#define int long long\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define loop(s, v, it) for (s::iterator it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = e[i].nxt)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, sum) memset(a, sum, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(#x\".in\", \"r\", stdin),freopen(#x\".out\", \"w\", stdout)\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int N = 5010 ;\nconst int INF = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int MOD = 1000000007 ;\nconst double eps = 1e-7 ;\nvoid print(int x) { cout << x << endl ; exit(0) ; }\nvoid PRINT(string x) { cout << x << endl ; exit(0) ; }\nvoid douout(double x){ printf(\"%lf\\n\", x + 0.0000000001) ; }\ntemplate <class T> void chmin(T &a, T b) { if (a > b) a = b ; }\ntemplate <class T> void chmax(T &a, T b) { if (a < b) a = b ; }\ntemplate <class T> void upd(T &a, T b) { (a += b) %= MOD ; }\ntemplate <class T> void mul(T &a, T b) { a = (ll) a * b % MOD ; }\n\nint a[N], vis[N][N] ;\nll dp[N][N] ; // dp[i][j] 表示将第 i 个数搬移到前 j 个位置的最小价值\nint n, ca, cb ;\n\nll dfs(int i, int j) {\n\tif (i == n + 1) return 0 ;\n\tif (vis[i][j]) return dp[i][j] ;\n\tvis[i][j] = 1 ; dp[i][j] = linf ;\n\tif (j == 1 || a[j - 1] < a[i]) {\n\t\tchmin(dp[i][j], dfs(i + 1, i + 1)) ;\n\t\tchmin(dp[i][j], dfs(i + 1, j) + ca) ;\n\t} else {\n\t\tchmin(dp[i][j], dfs(i + 1, j) + cb) ;\n\t}\n\treturn dp[i][j] ;\n}\n\nsigned main(){\n//\tfreopen(\"test.in\", \"r\", stdin) ;\n//\tfreopen(\"test.out\", \"w\", stdout) ;\n\tscanf(\"%d%d%d\", &n, &ca, &cb) ;\n\trep(i, 1, n) scanf(\"%d\", &a[i]) ;\n\tprintf(\"%lld\\n\", dfs(1, 1)) ;\n\treturn 0 ;\n}\n\n/*\n写代码时请注意：\n\t1.ll？数组大小，边界？数据范围？\n\t2.精度？\n\t3.特判？\n\t4.至少做一些\n思考提醒：\n\t1.最大值最小->二分？\n\t2.可以贪心么？不行dp可以么\n\t3.可以优化么\n\t4.维护区间用什么数据结构？\n\t5.统计方案是用dp？模了么？\n\t6.逆向思维？\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define inf 1e18\nusing namespace std;\nconst int N=5100;\nint n,a,b,p[N],dp[N][N];\nsigned main()\n{\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&p[i]);\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=n;j++)\n\t\t{\n\t\t\tif (p[i]>j)\n\t\t\t{\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+a);\n\t\t\t\tdp[i][p[i]]=min(dp[i][p[i]],dp[i-1][j]);\n\t\t\t}\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+b);\n\t\t}\n\t}\n\tint ans=inf;\n\tfor (int i=0;i<=n;i++) ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#define _LIBCPP_DEBUG 0\n#else\n#define DEB 0\n#define NDEBUG\n#endif\n\n#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){cout << \"{\"; for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\nvoid _main();\nint main(){ cin.tie(0); ios::sync_with_stdio(false); _main(); return 0;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-5,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nvoid _main(){\n  int N;\n  ll A,B;\n  cin >> N >> A >> B ;\n  vvl dp(N+1,vl(N,LINF));\n  dp[0][0] = 0;\n  vl pos(N);\n  rep(i,N){\n    ll p;\n    cin >> p ;\n    pos[p-1] = i;\n  }\n  rep(i,N){\n    vl mi(N+1,LINF);\n    rep(j,N) mi[j+1] = min(mi[j],dp[i][j]);\n    rep(j,N){\n      // dp[i+1][j] = min_{k<=j}(dp[i][j]) + cost\n      ll co;\n      if(j==pos[i]) co = 0;\n      else if(j>pos[i]) co = A;\n      else co = B;\n      dp[i+1][j] = mi[j+1] + co;\n    }\n  }\n  cout << *min_element(ALL(dp[N])) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\n\nstruct BIT {\nprivate:\n\tvector<ll> node; int n;\npublic:\n\tBIT(int n_) {\n\t\tn = n_; node.resize(n, 0);\n\t}\n\t//0-indexed\n\tvoid add(int a, ll w) {\n\t\tfor (int i = a; i < n; i |= i + 1)node[i] += w;\n\t}\n\t//[0,a)\n\tll sum(int a) {\n\t\tll ret = 0;\n\t\tfor (int i = a - 1; i >= 0; i = (i&(i + 1)) - 1)ret += node[i];\n\t\treturn ret;\n\t}\n\t//[a,b)\n\tll sum(int a, int b) {\n\t\treturn sum(b) - sum(a);\n\t}\n};\nint p[5000];\nint invp[5001];\n\n//左がl,右が次r\nint le[5000][5000];\nint ri[5000][5000];\n\nbool used[5000][5000];\nll ans[5000][5000];\nll a, b;\nll dfs(int l, int r) {\n\tif (used[l][r])return ans[l][r];\n\tused[l][r] = true;\n\tif (l == r)return 0;\n\tll lef = min(b, a*le[l][r]) + dfs(l + 1, r);\n\tll rif = min(a, b*ri[r][l]) + dfs(l, r - 1);\n\tll ff = min(a, b)*(r - l);\n\treturn ans[l][r] = min({ lef, rif,ff });\n}\nvoid solve() {\n\tint n; cin >> n >> a >> b;\n\tBIT ble(n + 1), bri(n + 1);\n\trep(i, n) {\n\t\tcin >> p[i]; p[i]--; invp[p[i]] = i;\n\t}\n\trep(i, n) {\n\t\tint id = invp[i];\n\t\tint loc = ble.sum(id);\n\t\tle[i][n - 1] = id - loc;\n\t\tfor (int j = n - 2; j >= i; j--) {\n\t\t\tle[i][j] = le[i][j + 1];\n\t\t\tint nid = invp[j + 1];\n\t\t\tif (nid < id) {\n\t\t\t\tle[i][j]--;\n\t\t\t}\n\t\t}\n\t\tble.add(id, 1);\n\t}\n\tper(i, n) {\n\t\tint id = invp[i];\n\t\tint loc = bri.sum(id);\n\t\tint cnt = n - 1 - id;\n\t\tcnt -= n - 1 - i - loc;\n\t\tri[i][0] = cnt;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tri[i][j] = ri[i][j - 1];\n\t\t\tint nid = invp[j - 1];\n\t\t\tif (nid > id) {\n\t\t\t\tri[i][j]--;\n\t\t\t}\n\t\t}\n\t\tbri.add(id, 1);\n\t}\n\tcout << dfs(0, n - 1) << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\nconst int maxn=5005;\nint n,a,b;\nll dp[maxn];\nint main(){\n    ios::sync_with_stdio(0);\n    memset(dp,0x3f,sizeof(dp));dp[0]=0;\n    cin>>n>>a>>b;\n    rep(i,1,n){\n        int num;cin>>num;\n        ll mi=1e18;\n        rep(j,0,num)mi=min(mi,dp[j]);\n        rep(j,0,num-1)dp[j]+=a;\n        rep(j,num+1,n)dp[j]+=b;\n        dp[num]=mi;\n    }\n    ll ans=1e18;\n    rep(i,1,n)ans=min(ans,dp[i]);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 5005;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, a, b;\nint seq[MX];\nll f[MX];\nint les[MX][MX], gre[MX][MX];\n\nint main()\n{\n\tread(n), read(a), read(b);\n\tfor(int i=1; i<=n; i++) read(seq[i+1]);\n\tn += 2;\n\tseq[n] = n;\n\tseq[1] = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int l=1; l+i-1<=n; l++)\n\t\t{\n\t\t\tint r = l+i-1;\n\t\t\tles[l][r] = les[l][r-1] + (seq[r]<seq[l]);\n\t\t\tgre[l][r] = gre[l+1][r] + (seq[l]>seq[r]);\n\t\t}\n\t}\n\tmemset(f, 0x3f, sizeof(f));\n\tf[1] = 0;\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<i; j++)\n\t\t\tif(seq[j]<seq[i] && les[j][i]+gre[j][i]==i-j-1)\n\t\t\t\tcmin(f[i], f[j] + 1ll*les[j][i]*b + 1ll*gre[j][i]*a);\n\tprintf(\"%lld\\n\", f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,mmx,avx,tune=native\")\n#include \"bits/stdc++.h\"\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\nconst int MOD=1000000007;\n#define endl \"\\n\"\n#define fst first\n#define snd second\nconst int UNDEF = -1;\nconst int INF=1<<30;\ntemplate<typename T> inline bool chkmax(T &aa, T bb) { return aa < bb ? aa = bb, true : false; }\ntemplate<typename T> inline bool chkmin(T &aa, T bb) { return aa > bb ? aa = bb, true : false; }\ntypedef pair<ll,ll> pll;typedef vector<ll> vll;typedef pair<int,int> pii;typedef vector<int> vi;typedef vector<vi> vvi;\n#ifdef ONLINE_JUDGE\n#define assert(...) /* nothing */\n#endif\n#define DEBUG_CAT\n#ifdef DEBUG_CAT\n#define dbg(...)   printf( __VA_ARGS__ )\n#else \n#define dbg(...)   /****nothing****/\n#endif\nconst int mn=5004;\nint a[mn];\nll dp[mn][mn];\nint Lcost, Rcost;\nll f(int l, int r) {\n\tif (l>=r) return 0;\n\tif (dp[l][r]!=-1) return dp[l][r];\n\tvector<pii> b;\n\tfor (int p=l;p<=r;p++) b.PB(MP(a[p],p-l));\n\tsort(b.begin(),b.end());\n\tpll ans=MP(LLONG_MAX,-1);\n\tint n=b.size();\n\tvector<int> p2v(n),v2p(n);\n\tfor (int v=0;v<n;v++) {\n\t\tint p=b[v].snd;\n\t\tv2p[v]=p;p2v[p]=v;\n\t}\n\tset<int, greater<int> > smax; smax.insert(INT_MIN);\n\tset<int> smin; smin.insert(INT_MAX); for (int v=0;v<n;v++) smin.insert(v);\n\tvector<int> goodp;\n\tfor (int p=0;p<n;p++) {\n\t\tsmin.erase(p2v[p]);\n\t\tif ((*smax.begin()) < (*smin.begin())) {\n\t\t\t//if(l==0&&r==3)printf(\"p:%d. before:%d after:%d\\n\",p,(*smax.begin()) , (*smin.begin()));\n\t\t\tgoodp.PB(p);\n\t\t}\n\t\tsmax.insert(p2v[p]);\n\t}\n\tfor (auto &p:goodp) {\n\t\tint v=p2v[p];\n\t\t// Swap v from position=p to position=v.\n\t\tll base=f(l+0,l+p-1)+f(l+p+1,l+n-1); ll extra;\n\t\tif (p<v) extra=Lcost;\n\t\telse if (p>v) extra=Rcost;\n\t\telse extra=0;\n\t\tll cand=base+extra;\n\t\tchkmin(ans,MP(cand,(ll)p));\n\t}\n\t//printf(\"l:%d r:%d ans:%lld split p:%lld\\n\",l,r,ans.fst, ans.snd);\n\treturn dp[l][r]=ans.fst;\n}\nint main(){\t\n\tios::sync_with_stdio(false);\n\tmemset(dp,-1,sizeof dp);\n\tint n; cin>>n>>Lcost>>Rcost;\n\tfor (int p=0;p<n;p++) {\n\t\tcin>>a[p];\n\t\t--a[p];\n\t}\n\tll final=f(0,n-1);\n\tprintf(\"%lld\\n\",final);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\nconstexpr int64_t inf = (1ll << 60);\n\nint main() {\n  int N;\n  int A, B;\n  std::cin >> N >> A >> B;\n  std::vector<int> P(N);\n  for (int &x: P) {\n    std::cin >> x;\n  }\n  std::array<std::vector<int64_t>, 2> dp;\n  dp.fill(std::vector<int64_t>(N + 1, inf));\n  dp[0][0] = 0;\n  for (int i = 0; i < N; ++i) {\n    auto &cur = dp[i & 1];\n    auto &next = dp[(i & 1) ^ 1];\n    for (int j = 0; j <= N; ++j) {\n      if(j < P[i]) {\n        chmin(next[j], cur[j] + A);\n        chmin(next[P[i]], cur[j]);\n      }\n      if(j > P[i]) {\n        chmin(next[j], cur[j] + B);\n      }\n      cur[j] = inf;\n    }\n  }\n  auto &ans = dp[N & 1];\n  std::cout << *std::min_element(ans.begin(), ans.end()) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll A,B;\nint P[5050];\nll dp[5050][5050];\nint num[5050][5050];\n\nll hoge(int nex,int id) {\n\tif(id>N) return 0;\n\tif(P[id]<nex) return hoge(nex,id+1);\n\tif(dp[nex][id]>=0) return dp[nex][id];\n\t\n\tint ma=5050;\n\tint tar=-1;\n\tint i;\n\tfor(i=id;i<=N;i++) {\n\t\tif(P[i]>=nex) {\n\t\t\tif(P[i]<ma) ma=P[i],tar=i;\n\t\t}\n\t}\n\tif(tar==-1) return dp[nex][id]=0;\n\tint num=0;\n\tfor(i=id;i<tar;i++) if(P[i]>ma) num++;\n\t\n\tll ret=min(B+hoge(ma+1,id),A*num+hoge(ma+1,tar+1));\n\t\n\treturn dp[nex][id]=ret;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A>>B;\n\tassert(N<300);\n\tFOR(i,N) cin>>P[i+1];\n\tMINUS(dp);\n\t\n\t\n\tcout<<hoge(1,1)<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll n,L,R;\nvl a;\n\nint main(){\n\tcin>>n>>R>>L;\n\ta=vl(n);\n\tfor(auto &i:a) cin>>i;\n\tif(L<R){\n\t\tswap(L,R);\n\t\treverse(a.begin(),a.end());\n\t\tfor(int i=0;i<n;i++) a[i]=n-a[i]+1;\n\t}\n\tvl dp(n+1,INF);\n\tdp[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tll x=a[i];\n\t\tvl DP(n+1,INF);\n\t\tDP[0]=0;\n\t\tfor(int j=0;j<x;j++) DP[x]=min(DP[x],dp[j]);\n\t\tfor(int j=0;j<=n;j++) if(j!=x) DP[j]=dp[j]+(j<x?R:L);\n\t\tdp=DP;\n\t}\n\tll res=INF;\n\tfor(int i=0;i<=n;i++) res=min(res,dp[i]);\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\n#define Mod 1000000007\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\n\nint main(){\n    ll i,j;\n    ll n,m;\n    cin>>n>>m;\n    vector<ll> v(n,0),vv(n,0);\n    vector<vector<ll> > ss(n);\n    ll a,b;\n    ll q=0;\n    ll r=0;\n    ll x;\n    for(i=0;i<m;i++){\n        cin>>a>>b;\n        a--;\n        b--;\n        v[a]++;\n        v[b]++;\n        ss[a].pb(b);\n        ss[b].pb(a);\n    }\n    for(i=0;i<n;i++){\n        if(v[i]%2==1){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n        if(v[i]>=4) {\n            q++;\n            vv[i]=1;\n        }   \n        if(v[i]>=6) r++;\n    }\n\n    if(r>=1){\n        cout<<\"Yes\"<<endl;\n        return 0;\n    }\n    if(q<=1){\n        cout<<\"No\"<<endl;\n        return 0;\n    }\n    if(q>=3){\n        cout<<\"Yes\"<<endl;\n        return 0;\n    }\n    \n    \n        for(i=0;i<n;i++){\n            if(vv[i]==1) x=i;\n        }\n        for(i=0;i<ss[x].size();i++){\n            ll p=ss[x][i];\n            ll back=x;\n            while(vv[p]==0){\n                if(ss[p][0]==back) {\n                    back=p;\n                    p=ss[p][1];\n                }\n                else {\n                    back=p;\n                    p=ss[p][0];\n                }\n            }\n            if(p==x) {\n                cout<<\"Yes\"<<endl;\n                return 0;\n            }\n        }\n    \n\n    cout<<\"No\"<<endl;\n    \n    \n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate< typename T >\nstruct SparseTableMin {\n  vector< vector< T > > st;\n  vector< int > lookup;\n\n  SparseTableMin(const vector< T > &v) {\n    int b = 0;\n    while((1 << b) <= v.size()) ++b;\n    st.assign(b, vector< T >(1 << b));\n    for(int i = 0; i < v.size(); i++) {\n      st[0][i] = v[i];\n    }\n    for(int i = 1; i < b; i++) {\n      for(int j = 0; j + (1 << i) <= (1 << b); j++) {\n        st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n    lookup.resize(v.size() + 1);\n    for(int i = 2; i < lookup.size(); i++) {\n      lookup[i] = lookup[i >> 1] + 1;\n    }\n  }\n\n  inline T rmq(int l, int r) {\n    int b = lookup[r - l];\n    return min(st[b][l], st[b][r - (1 << b)]);\n  }\n};\n\ntemplate< typename T >\nstruct SparseTableMax {\n  vector< vector< T > > st;\n  vector< int > lookup;\n\n  SparseTableMax(const vector< T > &v) {\n    int b = 0;\n    while((1 << b) <= v.size()) ++b;\n    st.assign(b, vector< T >(1 << b));\n    for(int i = 0; i < v.size(); i++) {\n      st[0][i] = v[i];\n    }\n    for(int i = 1; i < b; i++) {\n      for(int j = 0; j + (1 << i) <= (1 << b); j++) {\n        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n    lookup.resize(v.size() + 1);\n    for(int i = 2; i < lookup.size(); i++) {\n      lookup[i] = lookup[i >> 1] + 1;\n    }\n  }\n\n  inline T rmq(int l, int r) {\n    int b = lookup[r - l];\n    return max(st[b][l], st[b][r - (1 << b)]);\n  }\n};\n\nconst size_t SIZE = 5010;\nconst ll inf = 5e15;\nll dp[SIZE][SIZE];\nbool calced[SIZE][SIZE];\n\nint main() {\n    ll N, A, B;\n    cin >> N >> A >> B;\n    V<ll> P(N), idx(N);\n    for (ll i = 0; i < N; i++) {\n        ll e;\n        cin >> e;\n        e--;\n        P[i] = e;\n        idx[e] = i;\n    }\n\n    SparseTableMin<ll> smin(idx);\n    SparseTableMax<ll> smax(idx);\n    \n    function<ll(ll, ll)> rec = [&](ll l, ll r) {\n        if (calced[l][r]) return dp[l][r];\n        calced[l][r] = true;\n        if (l == r) return (ll)0;\n        ll lidx = idx[l], ridx = idx[r];\n        ll val = inf;\n        if (smin.rmq(l, r + 1) == lidx) chmin(val, rec(l + 1, r));\n        else chmin(val, rec(l + 1, r) + B);\n        if (smax.rmq(l, r + 1) == ridx) chmin(val, rec(l, r - 1));\n        else chmin(val, rec(l, r - 1) + A);\n        return dp[l][r] = val;\n    };\n\n    cout << rec(0, N - 1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint n,A,B;\nLL f[N][N];\n\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n),sc(A),sc(B);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x; sc(x);\n\t\tmemset (f[i],127,sizeof (LL)*(n+1));\n\t\tfor (int j=0; j<=n; j++)\n\t\t{\n\t\t\tif (x< j) f[i][j]=f[i-1][j]+B;\n\t\t\telse if (x> j) f[i][j]=f[i-1][j]+A;\n\t\t}\n\t\tfor (int j=0; j<=x; j++)\n\t\t\tchkmin (f[i][x],f[i-1][j]);\n\t}\n\tLL ans=1e18;\n\tfor (int i=0; i<=n; i++)\n\t\tchkmin (ans,f[n][i]);\n\tpr(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<ctime>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include <cstdio>\n#include <string>\n#include <unordered_map>\nusing namespace std;\nconst int N = 5001;\nint n, A, B;\nint a[N];\nlong long f[N][N + 1];\nint main(){\n    scanf(\"%d %d %d\", &n, &A, &B);\n    for (int i = 1; i <= n ;  i ++) {\n        int x;\n        scanf(\"%d\", &x);\n        a[x] = i;\n    }\n    for (int i = 1; i <= n ; i ++)\n        for (int j  = 0; j <= n + 1; j ++)\n            f[i][j] = 1e18;\n    for (int i = 0; i < n ; i ++) {\n        for (int j = 0; j <= n ; j ++)\n            f[i][j + 1] = min(f[i][j + 1], f[i][j]);\n        for (int j = 0; j <= n + 1; j++) {\n            if (j == a[i + 1])\n                f[i + 1][j]= min(f[i][j], f[i + 1][j]);\n            else\n                if (a[i + 1] > j)\n                    f[i + 1][j]= min(f[i][j] + B, f[i + 1][j]);\n                else    f[i + 1][j]= min(f[i][j] + A, f[i + 1][j]);\n\n        }\n    }\n    long long ans =1e18;\n    for (int i = 0; i <= n + 1; i ++)\n        ans = min(ans, f[n][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define itrep(i, a) for (auto i = (a).begin(); i != (a).end(); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n#define mp(a, b) make_pair((a), (b))\n\nusing namespace std;\n\ntemplate<class T> void inputVector(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\n\nint leftBig[5010], rightSmall[5010];\n\nint N, A, B;\nvector<int> p;\n\nvoid makeLeftBig() {\n    set<int> st;\n    rep(i, N) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.end()) leftBig[p[i]] = N + 1;\n        else leftBig[p[i]] = *it;\n        st.insert(p[i]);\n    }\n    //cerr << \"leftBig:\";\n    //REP(i, 1, N) cerr << \" \" << leftBig[i];\n    //cerr << endl;\n}\nvoid makeRightSmall() {\n    set<int> st;\n    st.insert(p[N - 1]);\n    for (int i = N - 2; i >= 0; i--) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.begin()) rightSmall[p[i]] = 0;\n        else {\n            it--;\n            rightSmall[p[i]] = *it;\n        }\n        st.insert(p[i]);\n    }\n    //cerr << \"rightSmall:\";\n    //REP(i, 1, N) cerr << \" \" << rightSmall[i];\n    //cerr << endl;\n}\n\nstruct Info {\n    int left, right;\n    int dist;\n\n    Info(int left, int right, int dist) : left(left), right(right), dist(dist) {\n    }\n\n    bool operator< (const Info& a) const {\n        return dist > a.dist;\n    }\n};\n\nint memo[5010][5010];\n\nsigned main() {\n    cin >> N >> A >> B;\n\n    inputVector(p, N);\n\n    makeLeftBig();\n    makeRightSmall();\n\n    rep(i, N + 5) rep(j, N + 5) memo[i][j] = LLONG_MAX;\n\n    priority_queue<Info> q;\n    q.push(Info(0, N + 1, 0));\n    while (!q.empty()) {\n        auto info = q.top(); q.pop();\n        if (info.dist > memo[info.left][info.right]) continue;\n        //cerr << \"Info: [left:\" << info.left << \" right:\" << info.right << \" dist:\" << info.dist << \"]\" << endl;\n        if (info.left + 1 == info.right) {\n            cout << info.dist << endl;\n            break;\n        }\n\n        {\n            int nextNum = info.left + 1;\n            int ndist = info.dist;\n            if (leftBig[nextNum] < info.right) {\n                ndist += B;\n            }\n            if (ndist < memo[info.left + 1][info.right]) {\n                memo[info.left + 1][info.right] = ndist;\n                q.push(Info(info.left + 1, info.right, ndist));\n            }\n        }\n        {\n            int nextNum = info.right - 1;\n            int ndist = info.dist;\n            if (rightSmall[nextNum] > info.left) {\n                ndist += A;\n            }\n            if (ndist < memo[info.left][info.right - 1]) {\n                memo[info.left][info.right - 1] = ndist;\n                q.push(Info(info.left, info.right - 1, ndist));\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N; LL A,B; cin >> N >> A >> B;\n\tvector<int> p(N);\n\trepp(i,0,N) cin >> p[i];\n\tvector<vector<LL>> c(N+1,vector<LL>(N+2,A*N));\n\tvector<vector<int>> l(N+1,vector<int>(N+2,0)),r(N+1,vector<int>(N+2,N-1));\n\tc[1][N] = 0;\n\trepp(i,1,N+1) repm(j,N,i-1) if(i != 1 || j != N){\n\t\tl[i][j] = max(l[i-1][j],l[i][j+1]);\n\t\tr[i][j] = min(r[i-1][j],r[i][j+1]);\n\t\twhile(p[l[i][j]] < i || j < p[l[i][j]]) ++l[i][j];\n\t\twhile(p[r[i][j]] < i || j < p[r[i][j]]) --r[i][j];\n\t\tc[i][j] = min(c[i-1][j]+(p[l[i-1][j]]==i-1?0:B),c[i][j+1]+(p[r[i][j+1]]==j+1?0:A));\n\t}\n\tLL ans = c[N][N];\n\trepp(i,1,N) ans = min(ans,c[i][i]);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\nconstexpr double EPS = 1e-10;\n//constexpr int INF = 1001001001;\nconstexpr ll INF = 1001001001001001001ll;\n\n\nint main() {\n    ll N, A, B; cin >> N >> A >> B;\n    vi p(N);\n    rep(i, N) cin >> p[i];\n\n    /*dp[i][j] := i 個まで見て、右にうごさないことを確定した最大の値が j である状態を実現する\n    最小コスト LISのO(N^2)解放にちょっと類似*/\n    vector<vll> dp(N + 1, vll(N + 1, INF));\n    dp[0][0] = 0;\n    rep(i, N) {\n        rep(j, N + 1) {\n            if (dp[i][j] == INF) continue;\n            if (p[i] > j) {\n                chmin(dp[i + 1][p[i]], dp[i][j]);\n                chmin(dp[i + 1][j], dp[i][j] + A);\n            }\n            else {\n                chmin(dp[i + 1][j], dp[i][j] + B);\n            }\n        }\n    }\n\n    ll ans = INF;\n    rep(j, N + 1) chmin(ans, dp[N][j]);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,A,B;\nint P[5555];\n\nint uku[5010][5010];\n\nint dp[5555];\n\nsigned main(){\n\tcin>>N>>A>>B;\n\trep(i,N)cin>>P[i+1],P[i+1]++;\n\tN+=2;\n\tP[0]=1;P[N-1]=N;\n\trep(i,N){\n\t\tuku[i+1][P[i]]++;\n\t\trep(j,N)uku[i+1][j+1]+=uku[i][j+1]+uku[i+1][j]-uku[i][j];\n\t}\n\n\tfill_n(dp,5555,INF);\n\tdp[0]=0;\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(P[j]>P[i])continue;\n\t\t\tint tmp=dp[j];\n\n\t\t\ttmp+=(uku[i][N]-uku[i][P[i]]-uku[j+1][N]+uku[j+1][P[i]])*A;\n\t\t\ttmp+=(uku[i][P[i]]-uku[i][P[j]]-uku[j+1][P[i]]+uku[j+1][P[j]])*min(A,B);\n\t\t\ttmp+=(uku[i][P[j]]-uku[j+1][P[j]])*B;\n\t\t\tchmin(dp[i],tmp);\n\t\t}\n\t}\n\tcout<<dp[N-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){ll res=1;a%=mod;while(b){if(b&1)res=res*a%mod;a=a*a%mod;b>>=1;}return res;}\nll N=1;\nvi segmi,lazy;\nvoid init(vi v){\n    while(N<v.size())N*=2;\n    segmi=vi(N*2-1,inf);\n    lazy=vi(N*2-1);\n    rep(i,v.size())segmi[i+N-1]=v[i];\n    for(int i=N-2;i>=0;i--)segmi[i]=min(segmi[i*2+1],segmi[i*2+2]);\n}\nvoid eval(int k,int l,int r){\n    if(lazy[k]==0)return;\n    segmi[k]+=lazy[k];\n    if(r-l>1){\n        lazy[k*2+1]+=lazy[k];\n        lazy[k*2+2]+=lazy[k];\n    }\n    lazy[k]=0;\n}\nvoid add(int a,int b,int k,int l,int r,ll x){\n    eval(k,l,r);\n    if(r<=a||b<=l)return;\n    if(a<=l&&r<=b){\n        lazy[k]+=x;\n        eval(k,l,r);\n    }\n    else{\n        add(a,b,k*2+1,l,(l+r)/2,x);\n        add(a,b,k*2+2,(l+r)/2,r,x);\n        segmi[k]=min(segmi[k*2+1],segmi[k*2+2]);\n    }\n}\nll getmi(int a,int b,int k,int l,int r){\n    eval(k,l,r);\n    if(a<=l&&r<=b)return segmi[k];\n    if(r<=a||b<=l)return inf;\n    ll c1=getmi(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getmi(a,b,k*2+2,(l+r)/2,r);\n    return min(c1,c2);\n}\nvoid update(ll i,ll x){\n    ll t=getmi(i,i+1,0,0,N);\n    add(i,i+1,0,0,N,x-t);\n}\nvoid solve(){\n    ll n,l,r;cin>>n>>r>>l;\n    vi dp(n);\n    init(dp);\n    rep(i,n){\n        ll a;cin>>a;\n        a--;\n        update(a,getmi(0,a+1,0,0,N));\n        add(0,a,0,0,N,r);\n        add(a+1,N,0,0,N,l);\n    }\n    out(getmi(0,N,0,0,N));\n}\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr ll INF=1000000000000000000;\nvoid solve(){\n    int n,a,b,p[5010],q[5010];\n    ll dp[5010][10010];\n    cin>>n>>a>>b;\n    rep(i,n){\n        cin>>p[i];\n        q[p[i]-1]=i+1;\n    }\n    rep(i,n+1)rep(j,2*n+2)dp[i][j]=INF;\n    dp[0][1]=0;\n    rep(i,n){\n        ll cur=INF;\n        for(int j=1;j<=2*n+1;j++){\n            if(j%2==1){\n                chmin(cur,dp[i][j]);\n                chmin(cur,dp[i][j-1]);\n            }\n            if(j>q[i]*2)chmin(dp[i+1][j],cur+a);\n            if(j<q[i]*2)chmin(dp[i+1][j],cur+b);\n            if(j==q[i]*2)chmin(dp[i+1][j],cur);\n        }\n    }\n    cout<<*min_element(dp[n],dp[n]+2*n+2)<<endl;\n}\nsigned main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    //int t;cin>>t;while(t--)\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=5005;\nconst LL INF=1e16;\nint n;\nint p[N];\nLL a,b;\nint c[N][N][2];\nLL dp[N];\nint main(){\n\tn=read(),a=read(),b=read();\n\tFor(i,1,n)\n\t\tp[i]=read();\n\tp[n+1]=n+1;\n\tFor(i,0,n+1){\n\t\tFod(j,i-1,0)\n\t\t\tc[i][j][0]=c[i][j+1][0]+(p[j]>p[i]);\n\t\tFor(j,i+1,n+1)\n\t\t\tc[i][j][1]=c[i][j-1][1]+(p[j]<p[i]);\n\t}\n\tFor(i,0,N-1)\n\t\tdp[i]=INF;\n\tdp[0]=0;\n\tFor(i,0,n){\n\t\tif (dp[i]==INF)\n\t\t\tcontinue;\n\t\tFor(j,i+1,n+1)\n\t\t\tif (p[j]>p[i]&&c[j][i][0]+c[i][j][1]==j-i-1)\n\t\t\t\tdp[j]=min(dp[j],dp[i]+b*c[i][j][1]+a*c[j][i][0]);\n\t}\n\tcout<<dp[n+1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N=5005;\nint pos[N],g[N],a[N];\nLL f[N][N],ans;\nint n,A,B;\n\nvoid upmin(LL &x,const LL &y){if(y<x) x=y;}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",a+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpos[a[i]]=i;\n\t\tfor(int j=i-1;j;j--)\n\t\t\tif(a[j]>a[i]) g[i]++;\n\t}\n\tmemset(f,0x3f,sizeof(f));f[0][0]=0;\n\tfor(int i=0,tmp;i<n;i++)\n\t{\n\t\ttmp=pos[i+1];\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(j>g[tmp]) upmin(f[i+1][j-1],f[i][j]+A);\n\t\t\telse upmin(f[i+1][j],f[i][j]+B),upmin(f[i+1][g[tmp]],f[i][j]);\n\t}\n\tans=INT64_MAX;\n\tfor(int i=0;i<=n;i++)\n\t\tupmin(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC target (\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nvoid pre(){\n\n\n}\nvoid solve(){\n\n\n}\nll dp[5009][5009];\nint p[5009];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint n;cin>>n;\n\tint a,b;cin>>a>>b;\n\tvi v;\n\trepA(i,1,n){\n\t\tint x;cin>>x;\n\t\tfill(p);\n\t\ttrav(j,v) if(j>x) p[j]++;\n\t\trepA(j,1,n) p[j]+=p[j-1];\n\t\trep(j,x) dp[i][j] = dp[i-1][j];\n\t\trepA(j,x,n) {\n\t\t\tdp[i][j] = dp[i-1][j]+b;\n\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][x-1]+1ll*p[j]*a);\n\t\t}\n\t\tv.pb(x);\n\t}\n\tcout<<dp[n][n];\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 5e3 + 5, inf = 1e18;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nint n, L, R, a[N], f[N];\nsigned main() {\n\tn = read(); R = read(); L = read();\n\tfor(int i = 1; i <= n; ++ i) a[i] = read(), f[i] = 1e18;\n\ta[0] = 0; a[n + 1] = n + 1; f[0] = 0; f[n + 1] = 1e18;\n\tfor(int i = 1; i <= n + 1; ++ i) {\n\t\tint cl = 0, cr = 0;\n\t\tfor(int j = i - 1; j >= 0; -- j) {\n\t\t\tif(a[j] < a[i]) f[i] = min(f[i], f[j] + cl * L + cr * R);\n\t\t\tif(a[j] < a[i]) cl ++;\n\t\t\tif(a[j] > a[i]) cr ++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n + 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define pb push_back\n#define X first\n#define Y second\n\n#define SZ(a) ((LL)(a).size())\n#define all(a) (a).begin(),a.end()\n#define forn(i, n) for(LL i = 0; i < n; ++i)\n#define ALL(x) x.begin(), x.end()\n#define ll long long\n#define MAXN 100\n#define INF 1000 * 1000 * 1000\n#define LINF INF * (LL)INF;\nint n , m , A , B;\nint a[5005];\nint de[5005];\nLL dpT[5005][5005];\nint inL [5005];\nint inR [5005];\nLL dp(int l , int r , int freeL , int freeR)\n{\n\tif(l == r)\n\t\treturn 0;\n\tif(dpT[l][r] != -1)\n\t\treturn dpT[l][r];\n\tLL ans = LINF;\n\tint newFreeL = freeL;\n\tint newFreeR = freeR;\n\twhile(newFreeL <= n && (a[newFreeL + 1] < l || a[newFreeL + 1] > r))\n\t{\n\t\tnewFreeL++;\n\t}\n\twhile(newFreeR > 0 && (a[newFreeR - 1] > r || a[newFreeR - 1] < l))\n\t{\n\t\tnewFreeR--;\n\t}\n\tLL cost = B , cost2 = A;\n\tif(a[newFreeR - 1] == r)\n\t{\n\t\tcost = 0;\n\t}\n\tif(a[newFreeL + 1] == l)\n\t{\n\t\tcost2 = 0;\n\t}\n\t//cout << l << \" \" << r << \" \" << newFreeL << \" \" << newFreeR << endl;\n\tans = min(ans , cost + dp(l + 1 , r , newFreeL , newFreeR));\n\tans = min(ans , cost2 + dp(l  , r - 1 , newFreeL , newFreeR));\n\treturn dpT[l][r] = ans;\n}\nint main()\n{\n\tmemset(dpT , -1 , sizeof dpT);\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\t\n\tcout << dp(1 , n , 0 , n + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int N=5100;\nint n,A,B,p[N],mx[N][N],mn[N][N];\nlong long dp[N][N],inf;\nlong long dfs(int l,int r)\n{\n\tlong long &v=dp[l][r];\n\tif(v!=inf) return v;\n\tif(l==r) return v=0;\n\tif(p[l]<mn[l+1][r]) v=min(v,dfs(l+1,r));\n\telse v=min(v,dfs(l+1,r)+A);\n\tif(p[r]>mx[l][r-1]) v=min(v,dfs(l,r-1));\n\telse v=min(v,dfs(l,r-1)+B);\n\tfor(int i=l;i<r;i++)\n\t\tif(mx[l][i]<mn[i+1][r])\n\t\t\tv=min(v,dfs(l,i)+dfs(i+1,r));\n//\tprintf(\"dp[%d][%d]=%lld\\n\",l,r,dp[l][r]);\n\treturn v;\n}\nint main()\n{\n\tcin>>n>>A>>B;\n\tmemset(dp,63,sizeof(dp));inf=dp[0][0];\n\tfor(int i=1;i<=n;i++) cin>>p[i];\n\tfor(int l=1;l<=n;l++)\n\t{\n\t\tmx[l][l]=mn[l][l]=p[l];\n\t\tfor(int r=l+1;r<=n;r++)\n\t\t{\n\t\t\tmx[l][r]=max(mx[l][r-1],p[r]);\n\t\t\tmn[l][r]=min(mn[l][r-1],p[r]);\n\t\t}\n\t}\n\tcout<<dfs(1,n)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nProblem Source : agc-034F\nAuthor : oier_hzy\nTime : Nov 24 2019\n*/\n\n/*\n\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename _tp> inline void cmin(_tp&x, const _tp y) {if(x > y) x = y;}\n\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst int N = 5001;\nint a[N];\nll f[N], g[N];\nint n, A, B;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%d\", a+i);\n\t\n\tfor(int i = 0; i <= n; ++ i) f[i] = g[i] = +oo;\n\tf[0] = 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 0; j < a[i]; ++ j) {\n\t\t\tcmin(g[j], f[j] + A);\n\t\t\tcmin(g[a[i]], f[j]);\n\t\t}\n\t\tfor(int j = a[i]; j <= n; ++ j)\n\t\t\tcmin(g[j], f[j] + B);\n\t\tfor(int j = 0; j <= n; ++ j) f[j] = g[j], g[j] = +oo;\n\t}\n\t\n\tll Ans = +oo;\n\tfor(int i = 0; i <= n; ++ i)\n\t\tcmin(Ans, f[i]);\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// Be Kind :)\n#include <bits/stdc++.h>\nusing namespace std;\n \n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"Os\")\n\n/*\t\t\t\tI take you to the candy shop\t\t\t\t\t\t\t\t*/\n\n/*\t\t\t\tOoooh, it's me, myself and I\n\t\t\t\tSolo ride until I die, cause I got me for life\t\t\t\t*/\n\n/*\t\t\t\tSo I ball So hard, muh'fuckas wanna find me\t\t\t\t\t*/\n \n/*\t\t\t\tBitch, where you when I was walkin'?\n\t\t\t\tNow I run the game, got the whole world talkin'\t\t\t\t*/\n \n/*\t\t\t\tNiggas been counting me out\n\t\t\t\tI'm counting my bullets, I'm loading my clips\n\t\t\t\tI'm writing down names, I'm making a list\t\t\t\t\t*/\n \n/*\t\t\t\tYou never liked us anyway, fuck your friendship, I meant it */\n \n/*\t\t\t\tThe Chanel or Balenciaga, Louis and Vuitton\n\t\t\t\tShe know I got Fendi, Prada when I hit Milan\t\t\t\t*/\n \n/*\t\t\t\tI ran away, I don't think I'm coming back home\t\t\t\t*/\n \n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n \n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst ll maxn=5e3+10, maxm=1e5+10, lg=17, mod=1e9+7, inf=1e18;\n\nll n,a,b,p[maxn],we[maxn],dp[maxn][maxn],ps[maxn][maxn];\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n>>a>>b;\n\tfor(int i=1;i<=n;i++) cin>>p[i], we[p[i]]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(j==we[i]) dp[i][j]=dp[i-1][j-1];\n\t\t\telse dp[i][j]=ps[i-1][j]+(j<we[i] ? b:a);\n\t\t\tps[i][j]=dp[i][j];\n\t\t\tif(j) ps[i][j]=min(ps[i][j],ps[i][j-1]);\n\t\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<ps[n][n];\n\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint p[5000];\nlong long dp[5001][5001];\n\nint main() {\n    int n, a, b, i, j;\n    long long ans = 1e18;\n    \n    scanf(\"%d %d %d\", &n, &a, &b);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    \n    for (i = 0; i < n; i++) {\n        int x = p[i];\n        \n        for (j = 0; j < x; j++) dp[i + 1][j] = dp[i][j] + a;\n        for (j = x + 1; j <= n; j++) dp[i + 1][j] = dp[i][j] + b;\n        \n        dp[i + 1][x] = 1e18;\n        for (j = 0; j < x; j++) dp[i + 1][x] = min(dp[i + 1][x], dp[i][j]);\n    }\n    \n    for (i = 0; i <= n; i++) ans = min(ans, dp[n][i]);\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define all(x)  x.begin(),x.end()\n#define sz(x)   (int)x.size()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 5005;\nconst ll    inf = 1e18;\n\ntypedef pair<int,int>   ii;\n\nint p[N];\nll  f[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int A;  cin >> A;\n    int B;  cin >> B;\n\n    p[++n] = n;\n\n    for(int i = 1 ; i <  n ; ++i)   cin >> p[i];\n    for(int i = 1 ; i <= n ; ++i)   {\n        f[i] = inf;\n        int cnt = 0;\n\n        for(int j = i - 1 ; j >= 0 ; --j)   {\n            if (p[j] > p[i])\n                cnt++;\n            else    {\n                ll  nxt = f[j] + 1ll * A * cnt + 1ll * B * (i - j - 1 - cnt);\n\n                if (f[i] > nxt)\n                    f[i] = nxt;\n            }\n        }\n    }\n    cout << f[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 200000;\nint a[N], A, B, p[N];\nint used[5002][5002];\nlong long dp[5002][5002];\nint f[5002][5002];\nlong long solve(int l, int r) {\n    if (used[l][r]) {\n        return dp[l][r];\n    }\n    if (l == r) {\n        return 0;\n    }\n    used[l][r] = 1;\n    dp[l][r] = 1e18;\n    int i = p[l];\n    int cnt = f[i][r] - f[i][l - 1];\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r) + B);\n    }\n    i = p[r];\n    cnt = f[n][r] - f[n][l - 1] - (f[i - 1][r] - f[i - 1][l - 1]);\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1) + A);\n    }\n    return dp[l][r];\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        p[a[i]] = i;\n    }\n    for (int j = 1; j <= n; j++) {\n        for (int i = 1; i <= n; i++) {\n            f[i][j] = f[i - 1][j];\n            if (a[i] <= j) {\n                f[i][j]++;\n            }\n        }\n    }\n    cout << solve(1, n) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\ni64 memo[5050][5050];\nint ll[5050], rr[5050];\nint n;\ni64 a, b;\n\ni64 rec(int l, int r) {\n    if (l >= r) return 0;\n    if (memo[l][r] >= 0) return memo[l][r];\n    i64 cl = (l < ll[l] && ll[l] <= r) ? b : 0,\n        cr = (l <= rr[r] && rr[r] < r) ? a : 0;\n    return memo[l][r] = std::min(cl + rec(l + 1, r), cr + rec(l, r - 1));\n}\n\nint main() {\n    std::cin >> n >> a >> b;\n    std::vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> p[i];\n    }\n    for (int i = 1; i <= n; i++) for (int j = i; j <= n; j++) memo[i][j] = -1;\n    std::set<int> s;\n    for (int i = 0; i < n; i++) {\n        auto it = s.upper_bound(p[i]);\n        if (it != s.end()) ll[p[i]] = *it;\n        else ll[p[i]] = -1;\n        s.insert(p[i]);\n    }\n    s.clear();\n    for (int i = n - 1; i >= 0; i--) {\n        auto it = s.lower_bound(p[i]);\n        if (it != s.begin()) rr[p[i]] = *--it;\n        else rr[p[i]] = -1;\n        s.insert(p[i]);\n    }\n    std::cout << rec(1, n) << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e9+7)\n#define INF (ll)1e15\nll N,A,B;\npll pp[101010];\nll dp[5050][10101],ans;\nll i, j;\nll aaa(const ll& a,const ll& b ){\n    return a - 1 == b * 2 ? 0 : a - 1 < b * 2 ? B : A;\n}\n\nint main(){\n    scanf(\"%lld%lld%lld\", &N,&A,&B);\n    fornum(i,0,N){\n        ll p;\n        scanf(\"%lld\", &p);\n        pp[i] = {p,i};\n    }\n    sort(pp, pp + N);\n    fornum(i,0,N){\n        ll minn = INF;\n        fornum(j,0,N*2+1){\n            if(j%2){\n                dp[i + 1][j] = minn + aaa(j, pp[i].second);\n                minn = min(dp[i][j],minn);\n\n            }else{\n                minn = min(dp[i][j],minn);\n                dp[i + 1][j] = minn + aaa(j, pp[i].second);\n            }\n        }\n    }\n    ans = INF;\n    fornum(i,0,N*2+1){\n        ans = min(ans, dp[N][i]);\n    }\n    printf(\"%lld\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef __GNUC__ \n#pragma GCC optimize(2)\n#endif\n\n#include <cassert>\n#include <iostream>\n#include <functional>\n#include <iomanip>\n#include <set>\n#include <unordered_map>\n#include <map>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <vector>\n#include <deque>\n#include <algorithm>\n#include  <cstring>\n#include <string>\n#include <cmath> \n#include <random>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\n \nnamespace Bigcat {\n\ttemplate <typename T> inline void max_s(T&a, const T&b) { a = max(a, b); }\n\ttemplate <typename T> inline void min_s(T&a, const T&b) { a = min(a, b); }\n\n\ttemplate <typename T>  void sort_v(T & x) { sort(x.begin(), x.end()); }\n\ttemplate <typename T>  void erase_dup(T & x) { x.erase(unique(x.begin(), x.end()), x.end()); }    // erase duplicate\n\ttemplate <typename T, typename V>  int pos_l(const T & x, const V & v) { return lower_bound(x.begin(), x.end(), v) - x.begin(); }\n\ttemplate <typename T, typename V>  int pos_u(const T & x, const V & v) { return upper_bound(x.begin(), x.end(), v) - x.begin(); }\n\n\tinline unsigned rand_g() {\n\t\tstatic mt19937 mt_rand((int)time(0));\n\t\treturn mt_rand();\n\t}\n\tusing LL = long long;\n\tusing VI = vector<int>;\n\tusing VVI = vector< VI >;\n\tusing VL = vector<LL>;\n\tusing PII = pair<int, int>;\n\tusing VPII = vector< PII >;\n}\n#define Rep(i, a) for(int i = 0; i < (int)(a); i++)\n#define Loop(i, a, b) for(int i = (int)(a); i < (int)(b); i++)\n#define Loop_r(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n\n    using namespace Bigcat;\nconst LL base = LL(1e9 + 7);\nconst LL INFL =  1LL << 62;\nconst int INF = 1 << 30 ;\nconst int MAX = int ( 5e3 + 100 ) ;\n\nstruct Node {\n\tint x, y, w;\n};\nbool operator < (const Node & n0, const Node & n1) {\n\treturn n0.x< n1.y;\n}\n\nLL dp[MAX];\n\nvoid solve1() {\n\n\tLL result = 0;\n\tint n;\n\n\tcin >> n;\n\tint fa, fb;\n\tcin >> fa >> fb;\n\tVI zp(n+2);\n\tRep(i, n) {\n\t\tcin >> zp[i+1];\n\t}\n\tzp[0] = 0;\n\tzp[n + 1] = n + 1;\n\tdp[0] = 0;\n\n\tLoop(i, 1, n + 2) {\n\t\tLL totf = 0;\n\t\tdp[i] = INFL;\n\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\tif (zp[j] < zp[i]) {\n\t\t\t\tmin_s(dp[i], dp[j] + totf);\n\t\t\t}\n\t\t\tif (zp[j] > zp[i]) {\n\t\t\t\ttotf += fa;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttotf += fb;\n\t\t\t}\n\t\t}\n\t}\n\tresult = dp[n+1];\n\tcout << result << endl;\n\n}\n\nvoid io_init() {\n   \tconst int inId = 0;\n\tconst int outId = 0;\n\tif (inId>0) {\n\t\tcerr << \"redirect stdin to input \" << inId << endl;\n\t\tstring s = \"input\";\n\t\ts += to_string(inId);\n\t\ts += \".txt\";\n\t\tauto r = freopen(s.c_str(), \"r\", stdin);\n\t\tif (r == nullptr) {\n\t\t\tcerr << \"invalid input file \" << s << endl;;\n\t\t\tr = freopen(\"CON\", \"r\", stdin); // to do  con??\n\t\t}\n\t}\n\tif (outId>0) {\n\t\tcerr << \"redirect stdout to stdout \" << outId << endl;\n\t\tstring s = \"stdout\";\n\t\ts += to_string(outId);\n\t\ts += \".txt\";\n\t\tauto r = freopen(s.c_str(), \"w\", stdout);\n\t\tif (r == nullptr) {\n\t\t\tcerr << \"invalid output file \" << s << endl;;\n\t\t\tr = freopen(\"CON\", \"w\", stdout);\n\t\t}\n\t}\n}\nvoid solve() {\n\tint t = 1;\n\t//cin >> t;\n#ifdef _DEBUG\n\tcerr << \" now base \"<< base << endl;\n#endif\n\tfor (int i = 0; i < t; ++i) {\n #ifdef _DEBUG\n    cerr<<\" tasks: \" << i+1<<endl;\n#endif       \n\t\tsolve1();\n\t}\n    int x = 1;\n}\n\nint main(int argc,  char * argv[]) {\n    \n#ifdef _DEBUG    \n\tif (argc ==1) {\n\t\tio_init();\n\t}\n#endif\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); // close sync between cout and printf\n\tcout.precision(11); \n    \n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//constexpr long long MOD = 1000000007;\nconstexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nll dp[5050][5050];\npii mael[5050][5050],maer[5050][5050];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll N,A,B; cin >> N >> A >> B;\n    vector<int> p(N);\n    rep(i,N) {\n        cin >> p[i];\n        --p[i];\n    }\n\n    rep(i,N) {\n        int l = p[i];\n        int r = 0;\n        int cnt = 1;\n        rep(j,i) {\n            if (p[j] > p[i]) {\n                mael[p[i]][N-1-p[j]].second = 1;\n            }\n        }\n        for (int j = i+1; j < N; j++) {\n            if (p[j] < p[i]) continue;\n            if (p[j] > l+1) {\n                for (int k = r; k < N-p[j]; k++) {\n                    mael[p[i]][k].first = cnt;\n                }\n                chmax(r,N-p[j]);\n            } else {\n                l++;\n                cnt++;\n            }\n        }\n        for (int k = r; k < N-l; k++) {\n            mael[p[i]][k].first = cnt;\n        }\n        for (int j = N-1-p[i]+1; j > 0; j--) {\n            mael[p[i]][j-1].second += mael[p[i]][j].second;\n        }\n    }\n\n    for (int i = N-1; i >= 0; i--) {\n        int r = p[i];\n        int l = 0;\n        int cnt = 1;\n        for (int j = N-1; j > i; j--) {\n            if (p[j] < p[i]) {\n                maer[p[j]][N-1-p[i]].second = 1;\n            }\n        }\n        for (int j = i-1; j >= 0; j--) {\n            if (p[j] > p[i]) continue;\n            if (p[j] < r-1) {\n                for (int k = l; k <= p[j]; k++) {\n                    maer[k][N-1-p[i]].first = cnt;\n                }\n                chmax(l,p[j]+1);\n            } else {\n                r--;\n                cnt++;\n            }\n        }\n\n        for (int k = l; k <= p[i]; k++) {\n            maer[k][N-1-p[i]].first = cnt;\n        }\n        for (int j = p[i]+1; j > 0; j--) {\n            maer[j-1][N-1-p[i]].second += maer[j][N-1-p[i]].second;\n        }\n\n    }\n\n    rep(i,N+1) rep(j,N+1) dp[i][j] = 1e18;\n    dp[0][0] = 0;\n    rep(k,N) {\n        for (int l = 0; l <= k; l++) {\n            if (dp[l][k-l]==1e18) continue;\n\n            auto [dl,cl] = mael[l][k-l];\n            chmin(dp[l+dl][k-l],dp[l][k-l]+A*cl);\n            chmin(dp[l+1][k-l],dp[l][k-l]+B);\n\n            auto[dr,cr] = maer[l][k-l];\n            chmin(dp[l][k-l+dr],dp[l][k-l]+B*cr);\n            chmin(dp[l][k-l+1],dp[l][k-l]+A);\n        }\n    }\n\n    ll ans = 1e18;\n    rep(i,N+1) {\n        chmin(ans,dp[i][N-i]);\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INFL = 1e18;\nconst int MN = 5050;\nll dp[MN][MN];\nll dt[MN];\nll ord[MN];\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tll n,a,b;\n\tcin >> n >> a >> b;\n\tfor(int i=0;i<n;i++) {\n\t\tint t;\n\t\tcin >> t;t--;\n\t\tord[t] = i+1;\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tfor(int i=0;i<n;i++) {\n\t\tll ma = INFL;\n\t\tfor(int j=0;j<=n;j++) {\n\t\t\tif(i > 0) {\n\t\t\t\tif(j >= ord[i-1]) {\n\t\t\t\t\tma = min(ma,dt[i-1]);\n\t\t\t\t}\n\t\t\t\tma = min(ma,dp[i-1][j]);\n\t\t\t} else {\n\t\t\t\tma = 0;\n\t\t\t}\n\t\t\tif(j == ord[i]) {\n\t\t\t\tdt[i] = ma;\n\t\t\t}\n\t\t\tdp[i][j] = ma+(j >= ord[i]?a:b);\n\t\t}\n\t}\n\tll res = INFL;\n\tfor(int i=0;i<=n;i++) {\n\t\tres = min(res,dp[n-1][i]);\n\t}\n\tres = min(res,dt[n-1]);\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define LL long long\nusing namespace std;\nconst int maxn = 5e3 + 5;\nLL f[maxn], mn, ans;\nint a[maxn], n, A, B, pos[maxn];\nint main() {\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor(register int i = 1; i <= n; ++i) \n\t\tscanf(\"%d\", &a[i]), pos[a[i]] = i;\n\tmemset(f, 0x3f, sizeof(f)), f[0] = 0;\n\tans = 0x3f3f3f3f3f3f3f3f;\n\tfor(register int i = 1; i <= n; ++i) {\n\t\tmn = 0x3f3f3f3f3f3f3f3f;\n\t\tfor(register int j = 0; j <= n; ++j) {\n\t\t\tmn = min(mn, f[j]);\n\t\t\tif(pos[i] < j) f[j] = mn + A;\n\t\t\telse if(pos[i] > j) f[j] = mn + B;\n\t\t\telse f[j] = mn;\n\t\t}\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tans = min(f[i], ans);\n\tprintf(\"%lld\", ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 5050;\nconst Int INF = 1e18;\nInt dp[MAX][MAX];\nInt dp2[MAX][MAX];\nInt dp3[MAX][MAX];\n\nInt p[MAX];\nInt cnt1[MAX],cnt2[MAX];\n\nsigned main(){\n  Int n,a,b;\n  cin>>n>>a>>b;\n  for(Int i=0;i<n;i++) cin>>p[i];\n  \n  for(Int i=0;i<MAX;i++){\n    for(Int j=0;j<MAX;j++){\n      dp[i][j]=INF;\n      dp2[i][j]=0;\n      dp3[i][j]=0;\n    }\n  }\n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=0;i<n;i++){\n      for(Int j=p[i];j<=n+1;j++)\n        dp2[p[i]-1][j]=i-(cnt1[p[i]]+cnt2[j]);\n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=n-1;i>=0;i--){\n      for(Int j=0;j<=p[i];j++)\n        dp3[j][p[i]+1]=(n-(i+1))-(cnt2[p[i]]+cnt1[j]);\n      \n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  \n  dp[0][n+1]=0;\n  for(Int w=n+1;w>0;w--){\n    for(Int i=0;i+w<=n+1;i++){      \n      Int j=i+w;\n      // ikkai \n      chmin(dp[i+1][j],dp[i][j]+b);\n      chmin(dp[i][j-1],dp[i][j]+a);\n      \n      // mettya mawasu\n      chmin(dp[i+1][j],dp[i][j]+dp2[i][j]*a);\n      chmin(dp[i][j-1],dp[i][j]+dp3[i][j]*b);\n    }\n  }\n  \n  Int ans=INF;\n  for(Int i=0;i<n;i++) chmin(ans,dp[i][i+1]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n    *Makacha\n**/\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> inline void read (T &x) {bool b = 0; char c; while (!isdigit (c = getchar()) && c != '-');\nif (c == '-') c = getchar(), b = 1; x = c - 48; while (isdigit(c = getchar())) x = (x<<3) + (x<<1) + c - 48; if (b)x=-x;}\ntemplate <typename T> inline void wrip(T x) {if (x > 9) wrip(x / 10); putchar(x%10 + 48); }\n\ntemplate <typename T> inline void write(T x) {if (x < 0) putchar('-'), x = -x; wrip(x); putchar(' ');}\ntemplate <typename T> inline void writeln(T x) {if (x < 0) putchar('-'), x = -x; wrip(x); putchar('\\n');}\ninline char readch() {char c; do c = getchar(); while (c == '\\n' || c == ' '); return c;}\ninline void reads(string &s) {char c; while((c=getchar())==' '||c =='\\n'); s=c; while((c=getchar())!=' '&&c!='\\n') s+=c;}\ninline void getlines(string &s) {char c; while((c=getchar())=='\\n'); s=c; while((c=getchar())!='\\n') s+=c;}\ntypedef const int csint;\n\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> ii;\ntypedef vector <int> vi;\n\nconst ld pi = acos(-1);\nconst ll inf = 1e16;\nconst int mod = 1e9 + 7,\nN = 5055;\nint n, a[N];\nll A, B, f[N][N];\nint main() {\n    #ifdef makacha\n        freopen(\"m.inp\", \"r\", stdin);\n        freopen(\"m.out\", \"w\", stdout);\n    #endif // makacha\n    read(n);\n    read(A);\n    read(B);\n    for (int i = 1; i <= n; i++)\n        read(a[i]);\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j <= n; j++)\n            f[i][j] = inf;\n    f[1][a[1]] = 0;\n    f[1][0] = A;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) {\n            f[i][j] = min(f[i][j], f[i][j - 1]);\n            if (a[i + 1] >= j) {\n                f[i + 1][a[i + 1]] = min(f[i + 1][a[i + 1]], f[i][j]);\n                f[i + 1][j] = min(f[i + 1][j], f[i][j] + A);\n            }\n            else\n                f[i + 1][j] = min(f[i + 1][j], f[i][j] + B);\n        }\n    cout << f[n][n];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\n#define N 5000 + 5\n#define INF 1234567890987654321LL\n\nint n, a, b, P[N], Pos[N], Max[N][N], Min[N][N];\nLL ans = INF, Dp[N][N];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tscanf(\"%d\", P + i);\n\t\tPos[P[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tMin[i][i] = Max[i][i] = Pos[i];\n\t\tfor (int j = i + 1; j <= n; j ++)\n\t\t{\n\t\t\tMin[i][j] = min(Min[i][j - 1], Pos[j]);\n\t\t\tMax[i][j] = max(Max[i][j - 1], Pos[j]);\n\t\t}\n\t}\n\tfor (int l = n - 1; l; l --)\n\t\tfor (int i = 1; i + l - 1 <= n; i ++)\n\t\t{\n\t\t\tint j = i + l - 1;\n\t\t\tDp[i][j] = INF;\n\t\t\tif (j < n)\n\t\t\t\tDp[i][j] = min(Dp[i][j], Dp[i][j + 1] + a * (Max[i][j] > Pos[j + 1]));\n\t\t\tif (i > 1)\n\t\t\t\tDp[i][j] = min(Dp[i][j], Dp[i - 1][j] + b * (Min[i][j] < Pos[i - 1]));\n\t\t}\n\tfor (int i = 1; i <= n; i ++)\n\t\tans = min(ans, Dp[i][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register\n#define int long long\nusing namespace std; const int N=5010;\ninline int read()\n{\n    int s=0,w=1; char ch=getchar();\n    while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar(); return s*w;\n}\nint n,X,Y;\nint dp[N][N],p[N];\nsigned main()\n{\n\tn=read(), X=read(), Y=read();\n\tfor(ri int i=1;i<=n;i++) {int x=read(); p[x]=i; }\n\tfor(ri int i=1;i<=n;i++) for(ri int j=0;j<=n;j++) dp[i][j]=LONG_LONG_MAX/2;\n\tfor(ri int i=1;i<=n;i++)\n\t{\n\t\tfor(ri int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(p[i]==j) dp[i][j]=min(dp[i-1][j-1],dp[i][j]);\n\t\t\tif(j<p[i]) dp[i][j]=min(dp[i][j],dp[i-1][j]+Y);\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+X);\n\t\t}\n\t\tfor(ri int j=1;j<=n;j++) dp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\n\nusing namespace std;\n\nconst long long N = 5000 + 5;\nmap< vector <int>, int> mp;\nmap < vector<int>, bool> mark;\nvector<int> p;\nlong long a;\nlong long b;\nint n;\n\nlong long solver(vector<int> vec)\n{\n    if (vec.size() <= 1)\n    {\n        return 0;\n    }\n    int mini = vec[0];\n    int ind = 0;\n    for (int i = 0; i < vec.size(); i++)\n    {\n        if (mini > vec[i])\n        {\n            mini = vec[i];\n            ind = i;\n        }\n    }\n    vector<int> v;\n    //only pay for minimum and take it to left;\n    for (int i = 0; i < vec.size(); i++)\n    {\n        if (vec[i] == mini)\n        {\n            continue;\n        }\n        v.push_back(vec[i]);\n    }\n    int t1 = 0;\n    if (mark[v])\n    {\n        t1 = mp[v];\n    }\n    else\n    {\n        t1 = mp[v] = solver(v);\n        mark[v] = true;\n    }\n    long long tmp1 = b + t1;\n    v.clear();\n    long long tmp2 = ind * a;\n    //pay for all of the bigger than minimum and take them to the right place;\n    for (int i = ind + 1; i < vec.size(); i++)\n    {\n        v.push_back(vec[i]);\n    }\n    t1 = 0;\n    if (mark[v])\n    {\n        t1 = mp[v];\n    }\n    else\n    {\n        t1 = mp[v] = solver(v);\n        mark[v] = true;\n    }\n    tmp2 += t1;\n    return min(tmp1, tmp2);\n}\n\n \nint main() \n{\n    cin >> n >> a >> b;\n    for (long long i = 0; i < n; i++)\n    {\n        long long tmp;\n        cin >> tmp;\n        p.push_back(tmp);\n    }\n    cout << solver(p);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n  \n  int n,a,b;\n  cin >> n >> a >> b;\n\n  vector<int> p(n+2);\n  REP(i,n) cin >> p[i+1];\n  p[0] = 0; p[n+1] = n+1;\n  \n  vec dp(n+2,INF);\n  dp[0] = 0;\n  FOR(i,1,n+2){\n    int cnt = 0;\n    RREP(j,i){\n      if(p[j] < p[i]){\n        dp[i] = min(dp[i],dp[j] + cnt*a + (i-j-1-cnt)*b);\n      }\n      else cnt++;\n    }\n  }\n\n  cout << dp[n+1] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int N=5005;\nint n,p[N],a,b,dp[N][N];\n\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>n>>a>>b;\n    for(int i=1;i<=n;i++) cin>>p[i];\n    for(int i=0;i<=n;i++)\n    {\n        for(int j=0;j<=n;j++) dp[i][j]=1e18;\n    }\n    dp[0][0]=0;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<=n;j++)\n        {\n            if(p[i+1]>j)\n            {\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+a);\n                dp[i+1][p[i+1]]=min(dp[i+1][p[i+1]],dp[i][j]);\n            }\n            else dp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n        }\n    }\n    int res=1e18;\n    for(int i=0;i<=n;i++) res=min(res,dp[n][i]);\n    cout<<res;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll inf = (ll)2e16;\nconst ll maxn = (ll)5e3 + 10;\n\nll dp[maxn];\nll inv[maxn];\nll p[maxn];\nll n, a, b;\n\n\nvoid solve(){\n    fill(dp, dp + maxn, inf);\n    cin >> n >> a >> b;\n    for(ll i = 0; i < n; ++i){\n        cin >> p[i];\n        p[i]--;\n    }\n    p[n] = n;\n    for(ll i = 0; i <= n; ++i){\n        inv[p[i]] = i;\n    }\n    for(ll i = 0; i <= n; ++i){\n        ll adda = 0, addb = 0;\n        for(ll j = p[i] - 1; j >= -1; --j){\n            if(j == -1){\n                dp[i] = min(dp[i], adda * a + addb * b);\n            }\n            dp[i] = min(dp[i], dp[inv[j]] + adda * a + addb * b);\n            if(j != p[i]){\n                if(inv[j] < i){\n                    adda++;\n                } else if(inv[j] > i) {\n                    addb++;\n                }\n            }\n        }\n    }\n    cout << dp[n] << \"\\n\";\n}\n\nsigned main(){\n    srand(time(0));\n    ll t = 1;\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    #ifdef DEBUG\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    #else\n\n    #endif// DEBUG\n    while(t--){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 10000000000000;\n\tvector<long long> P, DP;\n\tcin >> N >> A >> B;\n\tP.resize(N);\n\tDP.assign(N + 1, INF);\n\tDP[0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long MIN = INF;\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (DP[j] >= INF && j != P[i]) continue;\n\t\t\tif (j == 0) {\n\t\t\t\tMIN = min(MIN, DP[j]);\n\t\t\t\tDP[j] += min(A, B);\n\t\t\t}\n\t\t\telse if (0 < j && j < P[i]) {\n\t\t\t\tMIN = min(MIN, DP[j]);\n\t\t\t\tDP[j] += A;\n\t\t\t}\n\t\t\telse if (j == P[i]) {\n\t\t\t\tDP[j] = MIN;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDP[j] += B;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nint main(){\n    ll n,a,b;cin>>n>>a>>b;\n    vi v(n);\n    rep(i,n)cin>>v[i];\n    rep(i,n)v[i]--;\n    vi l(n,inf),r(n,-inf);\n    rep(i,n)REP(j,i+1,n)if(v[i]>v[j])chmin(l[j],v[i]);\n    rep(i,n)rep(j,i)if(v[i]<v[j])chmax(r[j],v[i]);\n    vvi dp(n+1,vi(n+1,inf));\n    dp[0][0]=0;\n    vi id(n);\n    rep(i,n)id[v[i]]=i;\n    rep(i,n+1){\n        rep(j,n+1){\n            if(i+j>=n)break;\n            if(i<n){\n                if(l[id[i]]<n-j)chmin(dp[i+1][j],dp[i][j]+b);\n                else chmin(dp[i+1][j],dp[i][j]);\n            }\n            if(j<n){\n                if(r[id[n-j-1]]>=i)chmin(dp[i][j+1],dp[i][j]+a);\n                else chmin(dp[i][j+1],dp[i][j]);\n            }\n        }\n    }\n    ll ans=inf;\n    rep(i,n+1)chmin(ans,dp[i][n-i]);\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//constexpr ll MOD=1e9+7;\n//\nconstexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        if(A<0) return B;\n        if(B<0) return A;\n        return std::min(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vector<vector<int>> dp;\n    vector<int> dist;\n    Tree(vector<vector<int>> edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,A,B; cin>>N>>A>>B;\n    vi P(N);\n    rep(i,0,N){\n        cin>>P[i];\n        P[i]--;\n    }\n    vii front(N,vi(N+1)),back(N,vi(N+1));\n    rep(i,0,N){\n        ll cnt=0;\n        rep(j,0,i){\n            if(P[j]>P[i]){\n                cnt++;\n                front[P[i]][N-P[j]]--;\n            }\n        }\n        front[P[i]][0]=cnt;\n        REP(j,1,N) front[P[i]][j]+=front[P[i]][j-1];\n        REP(j,0,N) front[P[i]][j]=std::min(B,A*front[P[i]][j]);\n        cnt=0;\n        rep(j,i+1,N){\n            if(P[j]<P[i]){\n                cnt++;\n                back[P[i]][P[j]+1]--;\n            }\n        }\n        back[P[i]][0]=cnt;\n        REP(j,1,N) back[P[i]][j]+=back[P[i]][j-1];\n        REP(j,0,N) back[P[i]][j]=std::min(A,B*back[P[i]][j]);\n    }\n    vii dp(N+1,vi(N+1,inf));\n    dp[0][0]=0;\n    rep(a,0,N){\n        REP(j,0,a){\n            ll i=a-j;\n            dp[i+1][j]=std::min(dp[i+1][j],dp[i][j]+front[i][j]);\n            dp[i][j+1]=std::min(dp[i][j+1],dp[i][j]+back[N-1-j][i]);\n        }\n    }\n    ll ans=inf;\n    REP(i,0,N){\n        ans=std::min(ans,dp[i][N-i]);\n    }\n    cout<<ans<<endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 5002\nusing namespace std;\nlong long n,a,b,i,j,vt[N],ma[N][N],mi[N][N],x,f[N][N];\nint main()\n{\n  //  freopen(\"ntu.inp\",\"r\",stdin);\n   // freopen(\"ntu.out\",\"w\",stdout);\n    cin>>n>>a>>b;\n    for(i=1;i<=n;i++) { cin>>x; vt[x]=i; mi[x][x]=i; ma[x][x]=i; }\n    for(i=n-1;i>=1;i--)\n        for(j=i+1;j<=n;j++)\n        {\n            mi[i][j]=min(mi[i][j-1],vt[j]);\n            ma[i][j]=max(ma[i][j-1],vt[j]);\n            f[i][j]=round(1e18);\n            if(vt[i]==mi[i][j]) f[i][j]=min(f[i][j],f[i+1][j]);\n            else f[i][j]=min(f[i][j],f[i+1][j]+b);\n            if(vt[j]==ma[i][j]) f[i][j]=min(f[i][j],f[i][j-1]);\n            else f[i][j]=min(f[i][j],f[i][j-1]+a);\n        }\n    cout<<f[1][n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=5000;\n\nint n; ll A,B;\nint p[MAXN];\n\nint pos[MAXN];\n\nll dp[MAXN][MAXN]; // dp[i][j] = minimum cost to place [0..j] so that i is the last one of them that stays in place\n\nvoid upd(ll &a,ll b) { a=min(a,b); }\nll solve() {\n\tREP(i,n) pos[p[i]]=i;\n\t//printf(\"pos:\"); REP(i,n) printf(\" %d\",pos[i]); puts(\"\");\n\t\n\tREP(i,n) REP(j,n) dp[i][j]=LLONG_MAX;\n\tREP(i,n) dp[i][i]=i*B;\n\tREP(j,n-1) REPE(i,j) if(dp[i][j]!=LLONG_MAX) {\n\t\tint k=j+1;\n\t\t// let k stay in same place\n\t\tif(pos[k]>pos[i]) upd(dp[k][k],dp[i][j]);\n\t\t// move k left\n\t\tif(pos[k]>pos[i]) upd(dp[i][k],dp[i][j]+B);\n\t\t// move k right\n\t\tif(pos[k]<pos[i]) upd(dp[i][k],dp[i][j]+A);\n\t}\n\t//REP(i,n) REP(j,n) if(dp[i][j]!=LLONG_MAX) printf(\"(%d,%d) = %lld\\n\",i,j,dp[i][j]);\n\tll ret=LLONG_MAX; REP(i,n) ret=min(ret,dp[i][n-1]); return ret;\n}\n\nvoid run() {\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tREP(i,n) scanf(\"%d\",&p[i]),--p[i];\n\tprintf(\"%lld\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n;\nlong a,b,ans;\nvector<int>p;\nmain()\n{\n\tlong A,B;\n\tcin>>n>>A>>B;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint u;cin>>u;p.push_back(u);\n\t}\n\twhile(!p.empty())\n\t{\n\t\tint id=0;\n\t\tfor(;p[id]!=1;id++);\n\t\tint r=1;\n\t\tfor(;id+r<p.size()&&p[id+r]==1+r;r++);\n\t\tlong L=id,R=r;\n\t\tvector<int>now;\n\t\tif(L*A<R*B)\n\t\t{\n\t\t\tans+=A*L;\n\t\t\tfor(int i=0;i<p.size();i++)\n\t\t\t{\n\t\t\t\tif(i<id)now.push_back(p[i]-r);\n\t\t\t\telse if(i>=id+r)now.push_back(p[i]-r);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=R*B;\n\t\t\tfor(int i=0;i<p.size();i++)\n\t\t\t{\n\t\t\t\tif(i<id)now.push_back(p[i]-r);\n\t\t\t\telse if(i>=id+r)now.push_back(p[i]-r);\n\t\t\t}\n\t\t}\n\t\tp=now;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\n#define PB push_back\n#define MP make_pair\n#define all(x) x.begin(),x.end()\n/*\nint N,M;\nLL c[100005] = {};\nint main(){\n\tcin >> N >> M;\n\tfor(int i=0; i<M; i++){\n\t\tint A,B;\n\t\tcin >> A >> B;\n\t\tA--; B--;\n\t\tc[A]++;\n\t\tc[B]++;\n\t}\n\n\tLL f = 0;\n\tfor(int i=0; i<N; i++){\n\t\tif(c[i] > 0 && c[i]%2 == 0){\n\t\t\tf += c[i]/2-1;\n\t\t}\n\t\telse{\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(f < 2){\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << \"Yes\" << endl;\n\n\treturn 0;\n}*/\n\nLL N,A,B;\nint p[5000];\nLL dp[5000][5001];\nLL solve(int now, int hidari){\n\tif(now == N) return 0;\n\tif(dp[now][hidari] != -1) return dp[now][hidari];\n\tLL ans = 0;\n\tif(p[now] < hidari){\n\t\tans = B+solve(now+1,hidari);\n\t}\n\telse{\n\t\tans = min(A+solve(now+1, hidari), solve(now+1,max(hidari,p[now])));\n\t}\n\treturn dp[now][hidari] = ans;\n}\nint main(){\n\tcin >> N >> A >> B;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> p[i];\n\t\tfor(int j=0; j<=N; j++) dp[i][j] = -1;\n\t}\n\tcout << solve(0, 0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst ll INF = 1e9, MOD = 1e9 + 7;\n\nll n, d[5001][5001], A, B;\n\nint main ()\n{\n\tcin >> n >> A >> B;\n\n\tfor (ll i = 1; i <= n; i++)\n\t{\n\t\tll a;\n\n\t\tscanf (\"%lld\", &a);\n\n\t\tfor (ll j = 0; j <= n; j++)\n\t\t{\n\t\t\tif (j < a) d[i][j] = d[i-1][j] + A;\n\t\t\telse if (j == a) d[i][j] = d[i-1][j];\n\t\t\telse d[i][j] = d[i-1][j] + B;\n\t\t\tif (j) d[i][j] = min (d[i][j], d[i][j-1]);\n\t\t}\n\t}\n\n\tcout << d[n][n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MN = 5005;\nll A, B, N, arr[MN], dp[MN][MN], i, j;\nll solve(ll n,ll lim){\n    if(n==0) return 0;\n    else if(dp[n][lim]!=-1) return dp[n][lim];\n    if(arr[n]>lim) dp[n][lim]=A+solve(n-1,lim);\n    else dp[n][lim]=min(solve(n-1,arr[n]),solve(n-1,lim)+B);\n    return dp[n][lim];\n}\nint main(){\n    for(scanf(\"%lld%lld%lld\",&N,&A,&B),i=1;i<=N;i++)\n        scanf(\"%lld\",&arr[i]);\n    memset(dp,-1,sizeof(dp));\n    printf(\"%lld\\n\",solve(N,N+1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define MAX 5005\nusing namespace std;\n\nint n, a[MAX];\nll f[MAX], A, B;\n\nint main()\n{\n    cin >> n >> A >> B;\n    for(int i = 1; i <= n; i++){\n        scanf(\"%d\", &a[i]);\n    }\n    memset(f, 0x3f, sizeof(f));\n    f[0] = 0;\n    for(int i = 1; i <= n; i++){\n        ll s = 0;\n        for(int j = i-1; j >= 0; j--){\n            if(a[i] > a[j]){\n                f[i] = min(f[i], f[j]+s);\n                s += B;\n            }\n            else s += A;\n        }\n    }\n    cout << f[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvoid amin(int &a, const int &b) {\n\ta = min(a, b);\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, A, B;\n\tcin >> N >> A >> B;\n\tvector<int> P(N);\n\tvector<int> rev(N);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> P[i]; P[i]--;\n\t\trev[P[i]] = i;\n\t}\n\tint INF = (int)1 << 60;\n\tvector<vector<int> > dp(N + 1, vector<int>(N + 1, INF));\n\n\tdp[0][0] = 0;\n\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (dp[i][j] < INF) {\n\t\t\t\tif (i < N) {\n\t\t\t\t\tif (P[i] < j) {\n\t\t\t\t\t\tamin(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin(dp[i + 1][j], dp[i][j] + A);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j < N) {\n\t\t\t\t\tif (rev[j] <= i) {\n\t\t\t\t\t\tamin(dp[i][j + 1], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tamin(dp[i][j + 1], dp[i][j] + B);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcout << dp[N][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nlong long A, B;\nint p[5005];\nint rev[5005];\nlong long memo[5005][5005];\n\nbool skipLeft[5005][5005];\nbool skipRight[5005][5005];\n\nlong long dp(int i, int j){\n    if(i > j){\n        return 0;\n    }else if(memo[i][j] != -1){\n        return memo[i][j];\n    }else{\n        /*vector<int> p2;\n        for(int k = 1; k <= N; k ++){\n            if(p[k] >= i && p[k] <= j){\n                p2.push_back(p[k]);\n            }\n        }*/\n\n        /*if(p2[0] == i){\n            return dp(i+1, j);\n        }else if(p2[j-i] == j){\n            return dp(i, j-1);\n        }*/\n\n        if(skipLeft[i][j]){\n            return dp(i+1, j);\n        }else if(skipRight[j][i]){\n            return dp(i, j-1);\n        }\n\n        return memo[i][j] = min(min(B, (j-i)*A) + dp(i+1, j), min(A, (j-i)*B) + dp(i, j-1));\n    }\n}\n\nint main(){\n    scanf(\"%d%lld%lld\", &N, &A, &B);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &p[i]);\n        rev[p[i]] = i;\n    }\n\n    for(int i = 1; i <= N; i ++){\n        skipLeft[i][i] = true;\n        for(int j = i+1; j <= N; j ++){\n            if(rev[j] < rev[i]){\n                // if j comes before i, then everything is false\n                skipLeft[i][j] = false;\n            }else{\n                skipLeft[i][j] = skipLeft[i][j-1];\n            }\n        }\n    }\n\n    for(int i = 1; i <= N; i ++){\n        skipRight[i][i] = true;\n        for(int j = i-1; j >= 1; j --){\n            if(rev[j] > rev[i]){\n                // if j comes before i, then everything is false\n                skipRight[i][j] = false;\n            }else{\n                skipRight[i][j] = skipRight[i][j+1];\n            }\n        }\n    }\n\n    /*for(int i = 1; i <= N; i ++){\n        for(int j = 1; j <= N; j ++){\n            printf(\"skipRight[%d][%d]\",)\n        }\n    }*/\n\n    memset(memo, -1, sizeof(memo));\n    printf(\"%lld\", dp(1, N));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n#define mod 1000000007\n#define N 5005\nusing namespace std;\n\ntypedef long long ll;\n\nll pmn[N][N], pmx[N][N];\nll dp[N][N], n, A, B, a[N];\n\nll qu(ll bas, ll son, ll ne){\n\t// cout << bas << \" \" << son << \" \" << ne << \" den buyuk olanlar = \" <<n - ne - smx[son + 2][ne] - pmx[bas - 1][ne] << \"  \" <<  smx[son + 2][ne] << \" \" << pmx[bas - 1][ne]<< endl;\n\treturn pmx[son][ne] - pmx[bas - 1][ne];\n}\n\nll quu(ll bas, ll son, ll ne){\n\treturn pmn[son][ne] - pmn[bas - 1][ne];\n}\n\nll f(ll bas, ll son){\n\tif(bas == son)\n\t\treturn 0;\n\tll &r = dp[bas][son];\n\tif(r != -1)\n\t\treturn r;\n\treturn r = min(f(bas + 1, son) + min(A, B*(quu(bas + 1, son, a[bas])) ), f(bas, son - 1) + min(B, A*(qu(bas, son - 1, a[son])) ) );\n}\n\nint main() {\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n\n\tmemset(dp, -1, sizeof dp);\n\n\tscanf(\"%lld %lld %lld\",&n ,&A ,&B);\n\tfor(ll i = 1; i <= n; i++)\n\t\tscanf(\"%lld\",a + i);\n\n\tfor(ll i = 1; i <= n; i++){\n\t\tfor(ll j = 1; j <= n; j++){\n\t\t\tpmn[j][i] = pmn[j - 1][i] + (a[j] <= i);\n\t\t\tpmx[j][i] = pmx[j - 1][i] + (a[j] >= i);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f(1, n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vector<long long> > vvll;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n#define INF 1000000000\n#define MOD 1000000007\n#define EPSILON 0.00001\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define p_q priority_queue\n\n#define FOR(i, a, b) for (int i=(a); i<=(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 5005\nint n;\nll a, b;\nint p[MN];\nll cst;\n\nvoid shf(int l, int r, int amt){ //amt = amt right, so i -> i+amt\n    int rnj = (r-l)+1; //(i-l)%rnj+l\n    amt = (amt+rnj)%rnj; //so i can do -1\n\n    int cl = r;\n    int val = p[r];\n    F0R(i, rnj){\n        cl = cl+amt;\n        cl = (cl-l)%rnj+l;\n\n        swap(val, p[cl]);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> a >> b;\n    FOR(i, 1, n){\n        cin >> p[i];\n    }\n    FOR(i, 1, n){\n        if(p[i] == i) continue;\n\n        int iind = find(p, p+n, i)-p;\n        //cout << i << \" found at \" << iind << \"\\n\";\n        if(iind == i+1){\n            int lst = i+1;\n            while(lst < n && (p[lst+1] == p[lst]+1)) lst++;\n            //cout << \"last val is \" << lst << \"\\n\";\n            int dist = (lst-i)+1;\n            ll ccst = min(b*(dist-1), a);\n            cst+=ccst;\n            shf(i, lst, -1);\n        } else{\n            int dist = (iind-i)+1;\n            ll ccst = min(a*(dist-1), b);\n            cst += ccst;\n            shf(i, iind, 1);\n        }\n    }\n\n    cout << cst << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int N;\n    ll A, B;\n    cin >> N >> A >> B;\n    vector<int> X(N);\n    map<int, int> M;\n    rep(i, N) {\n        cin >> X[i];\n        M[X[i]] = i;\n    }\n    vector<vector<ll>> dp(N + 1, vector<ll>(N + 1));\n    rep(i, N + 1) dp[i][0] = B * i;\n    rep(i, 1, N + 1) {\n        ll mi = dp[i - 1][1];\n        rep(j, 1, N + 1) {\n            if(j - 1 < M[i]) dp[i][j] = mi + B;\n            else if(j - 1 > M[i]) dp[i][j] = mi + A;\n            else dp[i][j] = mi;\n            if(j != N) mi = min(mi, dp[i - 1][j + 1]);\n        }\n    }\n    ll ans = dp[N][0];\n    rep(i, N + 1) {\n        ans = min(ans, dp[N][i]);\n    }\n    output(ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <class T> bool minimize(T &x, const T &y) {\n    if (x > y) x = y; else return false; return true;\n}\n\ntypedef long long ll;\n\nconst int N = 5e3 + 10;\n\nint n;\nll A, B;\nint a[N];\nll f[N][N];\n\nint main() {\n    if (fopen(\"B.inp\", \"r\"))\n        freopen(\"B.inp\", \"r\", stdin),\n        freopen(\"B.out\", \"w\", stdout);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    memset(f, 60, sizeof(f));\n    f[0][0] = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j <= n; j++) {\n            if (f[i][j] > (ll)(1e14)) continue;\n            if (a[i + 1] > j) {\n                /// not move\n                minimize(f[i + 1][a[i + 1]], f[i][j]);\n                /// move a[i + 1]\n                minimize(f[i + 1][j], f[i][j] + A);\n            } else\n                minimize(f[i + 1][j], f[i][j] + B);\n        }\n    ll ret = f[0][1];\n    for (int j = 0; j <= n; j++)\n        minimize(ret, f[n][j]);\n    cout << ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEBUG\n#include \"better_io.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\nconstexpr int MAXN = 5042;\n\nint N, A, B;\nint V[MAXN];\nint pos[MAXN];\nll gt[MAXN][MAXN];\nll dp[MAXN][MAXN];\n\nll solve(int i, int x) {\n\tif(i >= N-1) return 0;\n\tif(x >= N-1) return 0;\n\tif(dp[i][x] != -1) return dp[i][x];\n\tdp[i][x] = min(solve(i, x + 1) + B, solve(pos[x] + 1, x + 1) + A * gt[i][pos[x]]);\n\treturn dp[i][x];\n}\n\nint main() {\n\tmemset(dp, -1, sizeof dp);\n\t\n\tcin >> N >> A >> B;\n\t\n\tfor(int i=0; i<N; i++) {\n\t\tcin >> V[i];\n\t\tV[i]--;\n\t\tpos[V[i]] = i;\n\t}\n\t\n\tfor(int j=0; j<N; j++) {\n\t\tfor(int i=j-1; i>=0; i--) {\n\t\t\tgt[i][j] = gt[i+1][j] + (V[i] > V[j]);\n\t\t}\n\t}\n\t\n\tcout << solve(0, 0) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint a[5010], b[5010], c[5010];\nll mem[5010][5010], rt, lf, n;\nll dp(int  x, int y){\n    if(x+1==y || x==n || y==1){\n        return 0;\n    }\n    if(mem[x][y]!=-1)\n        return  mem[x][y];\n    ll res;\n    int tmp=x+1;\n    if(b[tmp]>=y){\n        res=dp(x+1, y);\n    }\n    else{\n        res=rt+dp(x+1, y);\n    }\n    tmp=y-1;\n    if(c[tmp]<=x){\n        res=min(res, dp(x, y-1));\n    }\n    else{\n        res=min(res, lf+dp(x, y-1));\n    }\n    mem[x][y]=res;\n    return res;\n}\nint main(){\n    while(cin>>n>>lf>>rt){\n        ll ans=0;\n        int tmp;\n        for(int i=0; i<n; ++i){\n            scanf(\"%d\",a+i);\n            tmp=n+1;\n            for(int j=0; j<i; ++j){\n                  if(a[j]>a[i])\n                        tmp=min(tmp, a[j]);\n            }\n            b[a[i]]=tmp;\n        }\n        for(int i=0; i<n; ++i){\n            tmp=0;\n            for(int j=n-1; j>i; --j){\n                if(a[j]<a[i]){\n                    tmp=max(tmp, a[j]);\n                }\n            }\n            c[a[i]]=tmp;\n        }\n        memset(mem, -1, sizeof mem);\n        ans=dp(0,n+1);\n        cout<<ans<<endl;\n    }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint num[5005],pos[5005],cnt[5005];\nll f[5005][5005];\n\nint main() {\n  memset(f,0x3f,sizeof(f));\n  int n,a,b;\n  scanf(\"%d%d%d\",&n,&a,&b);\n  for(int i=1;i<=n;i++) {\n  \tscanf(\"%d\",&num[i]);\n  \tpos[num[i]]=i;\n  }\n  for(int i=0;i<=n;i++) f[i][0]=f[0][i]=0;\n  for(int i=1;i<=n;i++) {\n  \tfor(int j=num[i]+1;j<=n;j++)\n  \t  if (pos[j]<i) cnt[j]++;\n    for(int j=1;j<=n;j++)\n      if (pos[j]<=i) {\n      \tif (!cnt[j]) f[i][j]=f[i][j-1];\n      \telse f[i][j]=min(f[i][j-1]+a,f[pos[j]-1][j]+(ll)b*cnt[j]);\n\t  }\n      else f[i][j]=f[i][j-1];\n  }\n  printf(\"%lld\\n\",f[n][n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 5002\nusing namespace std;\nlong long n,a,b,i,j,vt[N],ma[N][N],mi[N][N],x,f[N][N];\nint main()\n{\n   // freopen(\"ntu.inp\",\"r\",stdin);\n   // freopen(\"ntu.out\",\"w\",stdout);\n    cin>>n>>a>>b;\n    for(i=1;i<=n;i++) { cin>>x; vt[x]=mi[x][x]=ma[x][x]=i; }\n    for(i=n-1;i>=1;i--)\n        for(j=i+1;j<=n;j++)\n        {\n            mi[i][j]=min(mi[i][j-1],vt[j]);\n            ma[i][j]=max(ma[i][j-1],vt[j]);\n            f[i][j]=round(1e18);\n            if(vt[i]==mi[i][j]) f[i][j]=min(f[i][j],f[i+1][j]);\n            else f[i][j]=min(f[i][j],f[i+1][j]+b);\n            if(vt[j]==ma[i][j]) f[i][j]=min(f[i][j],f[i][j-1]);\n            else f[i][j]=min(f[i][j],f[i][j-1]+a);\n        }\n    cout<<f[1][n];\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n#define int long long\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nint A, B;\n\nsigned main() {\n\tscan n, A, B;\n\tvector<int> p(n);\n\tscan p;\n\tapply(p, x--);\n\tvector<int> at(n);\n\tf(i, n) {\n\t\tat[p[i]] = i;\n\t}\n\n\tvector<vector<int>> dp(n, vector<int>(n, 1e18));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i][i] = 0;\n\t}\n\tfor (int l = 2; l <= n; l++) {\n\t\tfor (int i = 0; i + l <= n; i++) {\n\t\t\tint j = i + l - 1;\n\t\t\t// int _min = *min_element(p.begin() + i, p.begin() + j + 1);\n\t\t\t// int _max = *max_element(p.begin() + i, p.begin() + j + 1);\n\t\t\tint less = 0, greater = 0;\n\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\tless += (p[k] < p[i]);\n\t\t\t\tgreater += (p[k] > p[j]);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint w = A;\n\t\t\t\tw = min(w, less * B);\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i + 1][j] + w);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint w = B;\n\t\t\t\tw = min(w, greater * A);\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][j - 1] + w);\n\t\t\t}\n\t\t}\n\t}\n\tprint dp[0][n - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.03.2019 14:09:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  long long A, B;\n  cin >> n >> A >> B;\n  vector<int> a(n + 2);\n  a[0] = 0; a[n + 1] = n + 1;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> dp(n + 2);\n  dp[0] = 0;\n  for (int i = 1; i <= n + 1; i++) {\n    dp[i] = (long long) 1e18;\n    int bigger = 0;\n    for (int j = i - 1; j >= 0; j--) {\n      if (a[j] < a[i]) {\n        dp[i] = min(dp[i], dp[j] + bigger * A + (i - 1 - j - bigger) * B);\n      } else {\n        bigger++;\n      }\n    }\n  }\n  cout << dp[n + 1] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int N = 5005;\nint dp[N][N], p[N], cnt[N][N], a, b, n;\n\nint solve(int i, int j) {\n  if (i == 0 || j == 0) {\n    return 0;\n  }\n  if (~dp[i][j]) {\n    return dp[i][j];\n  }\n  if (p[i - 1] >= j) {\n    return solve(i - 1, j);\n  }\n  int cur = cnt[i][j] - cnt[i][p[i - 1] + 1];\n  return dp[i][j] = min(solve(i - 1, j) + b, solve(i - 1, min(p[i - 1], j)) + cur * a);\n}\n\nsigned main() {\n  memset(dp, -1, sizeof dp);\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < N; j++) {\n      cnt[i + 1][j] = cnt[i][j] + (p[i] < j);\n    }\n  }\n  cout << solve(n, n) << '\\n';\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint INF = 1e18;\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<int> v(n+2);\n    v[0] = 0;\n    for (int i=1; i <= n; i++) cin>> v[i];\n    v[n+1] = n+1;\n    if (a > b){\n        for (int i=0;i<n+2;i++) v[i] = n+1-v[i];\n        reverse(v.begin(), v.end());\n        swap(a, b);\n    }\n    vector<int> pos(n+2);\n    for (int i=0; i < n+2;i++) pos[v[i]] = i;\n    int dp[n+2];\n    dp[0] = 0;\n    for (int i=1; i < n+2; i++){\n        dp[i] = INF;\n        int value = v[i];\n        int more = 0;\n        for (int j=value-1; j >= 0; j--){\n            if (pos[j] > i){\n                more++;\n                continue;\n            }\n            int total = value - j - 1;\n            dp[i] = min(dp[i], dp[pos[j]] + more*b + (total-more)*a);\n        }\n    }\n    cout << dp[n+1];\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 5005, mod = (int) 0;\nlong long dp[N];\nint sum[N][N], p[N];\nint main() {\n\tint n, cl, cr;\n\tcin >> n >> cl >> cr;\n\tp[n + 1] = n + 1;\n\tswap(cl, cr);\n\tfor (int j = 1; j <= n; ++j)\n\t\tcin >> p[j];\n\tn += 2;\n\tfor (int j = 0; j <= n; ++j) {\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tsum[j][i + 1] = sum[j][i] + (p[i] < j);\n\t}\n\tmemset(dp, 63, sizeof dp);\t\n\tdp[1] = dp[0] = 0;\n\tfor (int j = 1; j < n; ++j) {\n\t\tfor (int i = 0; i < j; ++i) {\n\t\t\tif (p[i] < p[j]) {\n\t\t\t\tint less = sum[p[i]][j] - sum[p[i]][i + 1];\n\t\t\t\tint betw = (sum[p[j]][j] - sum[p[j]][i + 1]) - less;\n\t\t\t\tint more = (j - i - 1) - less - betw;\n\t\t\t\tlong long cost = (LL) less * cl + (LL) more * cr + (LL) betw * min(cl, cr);\n\t\t\t\tdp[j + 1] = min(dp[j + 1], dp[i + 1] + cost);\n\t\t\t}\n\t\t}\n//\t\tcout << \" hi \" << j << ' ' << dp[j + 1] << endl;\n\t}\n\tcout << dp[n] << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\n#define MOD 1000000007LL\n#define endl \"\\n\"\n#define fst first\n#define snd second\nconst ll UNDEF = -1;\nconst ll INF=1e18;\ntemplate<typename T> inline bool chkmax(T &aa, T bb) { return aa < bb ? aa = bb, true : false; }\ntemplate<typename T> inline bool chkmin(T &aa, T bb) { return aa > bb ? aa = bb, true : false; }\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\nint Lcost,Rcost;\nconst int mn=5004;\nint p2v[mn],v2p[mn];\nll dp[mn][mn];\nint lo[mn][mn],hi[mn][mn];\nll f(int l, int r) {\n\tif (l>=r) return 0;\n\tif (dp[l][r]!=-1) return dp[l][r];\n\tll ans=min(f(l+1,r)+Lcost, f(l,r-1)+Rcost);\n\tif (p2v[l]==lo[l][r]) chkmin(ans,f(l+1,r));\n\tif (p2v[r]==hi[l][r]) chkmin(ans,f(l,r-1));\n\tint lopos=v2p[lo[l][r]];\n\tif (hi[l][lopos-1]<lo[lopos+1][r]) {\n\t\tans=min(ans, f(l,lopos-1)+f(lopos+1,r)+Rcost);\n\t}\n\tint hipos=v2p[hi[l][r]];\n\tif (hi[l][hipos-1]<lo[hipos+1][r]) {\n\t\tans=min(ans, f(l,hipos-1)+f(hipos+1,r)+Lcost);\n\t}\n\treturn dp[l][r]=ans;\n}\n\nint main(){\t\n\tios::sync_with_stdio(false);\n\tmemset(dp,-1,sizeof dp);\n\tint n; cin>>n>>Lcost>>Rcost;\n\tfor (int p=1;p<=n;p++) {\n\t\tcin>>p2v[p];\n\t\tv2p[p2v[p]]=p;\n\t}\n\tfor (int l=0;l<mn;l++) for (int r=0;r<mn;r++) {\n\t\thi[l][r]=INT_MIN;\n\t\tlo[l][r]=INT_MAX;\n\t}\n\tfor (int l=1;l<=n;l++) {\n\t\tlo[l][l]=p2v[l];\n\t\tfor (int r=l+1;r<=n;r++) lo[l][r]=min(lo[l][r-1],p2v[r]);\n\t\thi[l][l]=p2v[l];\n\t\tfor (int r=l+1;r<=n;r++) hi[l][r]=max(hi[l][r-1],p2v[r]);\n\t}\n\tll final=f(1,n);\n\tprintf(\"%lld\\n\",final);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N=5002;\nint n,a,b,p[N];\nLL f[N],g[N][N],h[N][N];\nint main()\n{\n    \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>n>>a>>b;\n    for (int i=1;i<=n;i++) cin>>p[i];\n    p[n+1]=n+1;\n    for (int i=0;i<n;i++)\n    for (int j=i+2;j<=n+1;j++)\n    {\n        g[i][j]+=g[i][j-1];\n        if (p[i]>p[j-1]) g[i][j]+=b;\n    }\n    for (int i=2;i<=n+1;i++)\n    for (int j=i-2;j>=0;j--)\n    {\n        h[j][i]+=h[j+1][i];\n        if (p[i]<p[j+1]) h[j][i]+=a;\n    }\n    //cout<<g[0][2]<<\"\\n\";\n    for (int i=1;i<=n+1;i++) f[i]=1e18;\n    for (int i=1;i<=n+1;i++)\n    {\n        int mx=-1;\n        for (int j=i-1;j>=0;j--)\n        if (p[i]>p[j]&&p[j]>mx)\n        {\n            mx=p[j];\n            f[i]=min(f[i],f[j]+g[j][i]+h[j][i]);\n            //cout<<i<<\" \"<<j<<\" \"<<f[i]<<\"\\n\";\n        }\n    }\n    cout<<f[n+1];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n#define MAX_N 5000\n#define INF 0x3f3f3f3f3f3f3f3f\n\nlong dp[MAX_N + 1][MAX_N + 1];\nint x0[MAX_N + 1], P[MAX_N];\n\nlong rotation_sort( int N, int A, int B )\n{\n    for ( int i = 0; i < N; i++ ) x0[P[i]] = i;\n\n    memset( dp, INF, sizeof( dp ) );\n    memset( dp[0], 0, sizeof( dp[0] ) );\n\n    for ( int k = 1; k <= N; k++ )\n    {\n        long min_prev = INF;\n\n        for ( int x = 0; x <= N; x++ )\n        {\n            int cost;\n            if ( x == x0[k] )\n                cost = 0;\n            else if ( x < x0[k] )\n                cost = B;\n            else\n                cost = A;\n\n            min_prev = min( min_prev, dp[k - 1][x] );\n            dp[k][x] = min_prev + cost;\n        }\n    }\n\n    long ans = INF;\n    for ( auto v : dp[N] ) ans = min( ans, v );\n\n    return ans;\n}\n\nint main( int argc, char **argv )\n{\n    long N, A, B;\n    cin >> N >> A >> B;\n\n    for ( int i = 0; i < N; i++ ) cin >> P[i];\n\n    cout << rotation_sort( N, A, B ) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nbool chmin(T& a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nbool chmax(T& a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n    for(int i = 0; i < v.size(); i++) {\n        os << v[i] << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T& t, const V& v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T& t, const V& v) {\n    for(auto& e : t) {\n        fill_v(e, v);\n    }\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, a, b;\n    cin >> n >> a >> b;\n    vector<ll> p(n + 10);\n    auto co = make_v<ll>(n + 10, n + 10);  // j番目までの、iより大きい要素数\n    for(int i = 1; i <= n; i++) {\n        int k;\n        cin >> k;\n        p[k] = i;\n        for(int j = 1; j < k; j++) {\n            co[j][i]++;\n        }\n    }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++) {\n            co[i][j] += co[i][j - 1];\n        }\n    }\n    auto dp = make_v<ll>(n + 10, n + 10);\n    fill_v(dp, LINF);\n    dp[0][0] = 0;\n    ll ans = LINF;\n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(j < p[i] - 1) {\n                chmin(dp[i][j], dp[i - 1][j] + b);\n                chmin(dp[i][p[i]], dp[i - 1][j] + (co[i][p[i]] - co[i][j]) * a);\n            } else {\n                chmin(dp[i][j], dp[i - 1][j]);\n            }\n            if(i == n) {\n                chmin(ans, dp[i][j]);\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, A, B;\nvector<ll> p;\nvector<ll> inv;\nll mini[5001][5001], maxi[5001][5001];\nll dp[5001][5001];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> A >> B;\n    p.resize(N);\n    inv.resize(N);\n    for(int i = 0; i < N; i++) {\n        cin >> p[i];\n        p[i]--;\n        inv[p[i]] = i;\n    }\n    for(int l = 0; l < N; l++) {\n        ll num = 0;\n        mini[l][l+1] = 0;\n        for(int r = l + 1; r < N; r++) {\n            if(inv[r] < inv[l]) num++;\n            mini[l][r+1] = num;\n        }\n    }\n    for(int r = N - 1; r >= 0; r--) {\n        ll num = 0;\n        maxi[r][r+1] = num;\n        for(int l = r - 1; l >= 0; l--) {\n            if(inv[l] > inv[r]) num++;\n            maxi[l][r+1] = num;\n        }\n    }\n    /*\n    for(int i = 0; i < N; i++) cerr << p[i] << \" \";\n    cerr << endl;\n    for(int l = 0; l <= N; l++) {\n        for(int r = l + 1; r <= N; r++) {\n            cerr << l << \" \" << r << \" \" << mini[l][r] << \" \" << maxi[l][r] << endl;\n        }\n    }\n    */\n    for(int delta = 2; delta <= N; delta++) {\n        for(int l = 0; l + delta <= N; l++) {\n            ll tmp1 = maxi[l][l+delta] * B + dp[l][l+delta-1];\n            ll tmp2 = A + dp[l][l+delta-1];\n            ll tmp3 = mini[l][l+delta] * A + dp[l+1][l+delta];\n            ll tmp4 = B + dp[l+1][l+delta];\n            dp[l][l+delta] = 1e18;\n            chmin(dp[l][l+delta], tmp1);\n            chmin(dp[l][l+delta], tmp2);\n            chmin(dp[l][l+delta], tmp3);\n            chmin(dp[l][l+delta], tmp4);\n            //cerr << l << \" \" << l + delta << \" \" << dp[l][l+delta] << endl;\n        }\n    }\n    cout << dp[0][N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int N = 5005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\ntemplate <typename T> inline void cmin(T &x, T y) {\n\tif (x > y) x = y;\n}\n\nint n, A, B, p[N];\nLL dp[2][N], ans;\n\nvoid init() {\n\tread(n); read(A); read(B);\n\tfor (int i = 1; i <= n; ++i) {\n        read(p[i]);\n\t}\n}\n\nvoid solve() {\n\tmset(dp[0], 0x3f);\n\tans = dp[0][0];\n\tdp[0][0] = 0;\n\tint cur = 0, pre = 1;\n\tfor (int i = 1; i <= n; ++i) {\n        swap(cur, pre);\n        mset(dp[cur], 0x3f);\n        for (int j = 0; j < i; ++j) {\n            if (p[i] > p[j]) {\n                cmin(dp[cur][i], dp[pre][j]);\n                cmin(dp[cur][j], dp[pre][j] + A);\n            } else {\n                cmin(dp[cur][j], dp[pre][j] + B);\n            }\n        }\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n        cmin(ans, dp[cur][i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nint main() {\n    int n;\n    ll a, b;\n    cin >> n >> a >> b;\n    VL p(n), pos(n);\n    REP(i,n){\n        p[i] = n - in();\n        pos[p[i]] = i;\n    }\n\n    VL dp(n + 1, 1e18);\n    dp[0] = 0;\n    BIT bit(n);\n    REP(i,n-1){\n        bit.add(pos[i], 1);\n        if (bit.sum(pos[i + 1]) == 0) dp[i + 1] = min(dp[i + 1], dp[i]);\n        ll x = 1e18, cc = bit.sum(pos[i + 1]);\n        FOR(j,i+1,n-1){\n            if (pos[j] > x || bit.sum(pos[j]) != cc) continue;\n            x = pos[j];\n            dp[j] = min(dp[j], dp[i] + (j - i) * b);\n            dp[j] = min(dp[j], dp[i] + cc * a);\n        }\n        dp[i + 1] = min(dp[i + 1], dp[i] + a * bit.sum(pos[i + 1]));\n    }\n\n    // REP(i,n) cout << dp[i] << \" \";\n    // cout << endl;\n    cout << dp[n - 1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n#define int LL\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 5005;\nint a[MAXN];\nint f[MAXN][MAXN];\n\nsigned main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, A, B; read(n), read(A), read(B);\n  for (RI i = 1; i <= n; ++i) read(a[i]);\n  memset(f, 0x3f, sizeof(f));\n  f[0][0] = 0;\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 0; j <= n; ++j)\n      if (a[i] > j) {\n        f[i][j] = min(f[i][j], f[i - 1][j] + A);\n        f[i][a[i]] = min(f[i][a[i]], f[i - 1][j]);\n      }\n      else {\n        f[i][j] = min(f[i][j], f[i - 1][j] + B);\n      //  f[i][a[i]] = min(f[i][a[i]], f[i - 1][j] + A);\n      }\n  int ans = 0x7f7f7f7f;\n  for (RI i = 0; i <= n; ++i)\n    ans = min(ans, f[n][i]);\n  printf(\"%d\\n\", ans);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 5005;\n\nll n, a, b, x, y;\n\nll ara[MAX];\nll dp[MAX][MAX];\nll rngmx[MAX][MAX], rngmn[MAX][MAX];\nll boro[MAX][MAX], choto[MAX][MAX];\n\n\nll fnc(ll beg, ll ed){\n    if(beg == ed) return 0;\n    \n    if(dp[beg][ed] != -1) return dp[beg][ed];\n    \n    ll cc = 0;\n    if(rngmn[beg + 1][ed] < ara[beg]) cc = a;\n    \n    ll re1 = fnc(beg + 1, ed) + cc;\n    ll re3 = fnc(beg + 1, ed) + choto[beg+1][ed] * b;\n    re1 = min(re1,re3);\n    \n    cc = 0;\n    if(rngmx[beg][ed - 1] > ara[ed]) cc = b;\n    \n    ll re2 = fnc(beg, ed - 1) + cc;\n    ll re4 = fnc(beg,ed-1) + boro[beg][ed-1] * a;\n    re2 = min(re2,re4);\n    \n    return dp[beg][ed] = min(re1, re2);\n}\n\nll BIT[MAX];\nvoid update(ll indx, ll val){\n    while(indx<MAX){\n        BIT[indx]+=val;\n        indx+=(indx&-indx);\n    }\n}\n\nll sum(ll indx){\n    ll ans=0;\n    while(indx!=0){\n        ans+=BIT[indx];\n        indx-=(indx&-indx);\n    }\n    return ans;\n}\n\nint main(){\n    cin >> n >> a >> b;\n    for(ll i = 1; i <= n; i++) scanf(\"%lld\", &ara[i]);\n    \n    memset(dp, -1, sizeof(dp));\n    \n    for(int i = 1; i <= n; i++){\n        ll mx = ara[i], mn = ara[i];\n        for(int j = i; j <= n; j++){\n            mx = max(mx, ara[j]);\n            mn = min(mn, ara[j]);\n            rngmx[i][j] = mx;\n            rngmn[i][j] = mn;\n            \n            update(ara[j],1);\n            boro[i][j] = j - i + 1 - sum(ara[j+1]);\n            choto[i][j] = sum(ara[i-1]);\n        }\n        \n        for(int j = i; j <= n; j++) update(ara[j],-1);\n    }\n    \n    ll ans = fnc(1, n);\n    \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 5e3 + 10, INF = 1e15 + 10;\nint n, A, B, ans = INF, ar[N], dp[N];\n\nint32_t main() {\n\tcin >> n >> A >> B;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> ar[i];\n\t\n\tfor (int i = 0; i < n; i++) \n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (ar[j] > ar[i])\n\t\t\t\tdp[i] += A;\n\t\t\telse\n\t\t\t\tdp[i] += B;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\tif (ar[j] < ar[i])\n\t\t\t\tdp[i] = min(dp[i], dp[j] + sum);\n\t\t\t\n\t\t\tif (ar[j] > ar[i])\n\t\t\t\tsum += A;\n\t\t\telse\n\t\t\t\tsum += B;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (ar[j] < ar[i])\n\t\t\t\tsum += B;\n\t\t\telse\n\t\t\t\tsum += A;\n\t\tans = min(ans, sum + dp[i]);\n\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<ctime>\n#include<cmath>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<string>\n#include<vector>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\n#define Rep(i,s,t) for(register int i=s;i<t;++i)\n#define go(x) for(register int e=las[x];e;e=nxt[e])\n#define re register\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define is insert\n#define es erase\n#define pii pair<int,int>\n#define ms(f,x) memset(f,x,sizeof f)\n#define mc(f,x) memcpy(f,x,sizeof f)\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define gi(x) read(x)\n#define gii(x,y) read(x),read(y)\n#define giii(x,y,z) read(x),read(y),read(z)\nnamespace IO{\n    #define gc getchar()\n    #define pc(x) putchar(x)\n    template<typename T>inline void read(T &x){\n        x=0;int f=1;char ch=gc;while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc;x*=f;return;\n    }\n    template<typename T>inline void write(T x=0){\n        T wr[51];wr[0]=0;if(x<0)pc('-'),x=-x;if(!x)pc(48);\n        while(x)wr[++wr[0]]=x%10,x/=10;while(wr[0])pc(48+wr[wr[0]--]);return;\n    }\n}\nusing IO::read;\nusing IO::write;\ntypedef long long ll;\ntypedef double db;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nconst int N=5011;\nint n,A,B;\nint p[N],b[N],c[N],s[N],pos[N];\nll dp[N][N];\ninline void ins(int x){\n\t++x;\n\tfor(;x<=n+2;x+=x&-x)\n\t\t--s[x];\n}\ninline int query(int x){\n\tint res=0;\n\t++x;\n\tfor(;x;x-=x&-x)\n\t\tres+=s[x];\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\trep(i,1,n)\n\t\tscanf(\"%d\",p+i),pos[p[i]]=i;\n\trep(i,0,n+1)\n\t\trep(j,0,n+1)\n\t\t\tdp[i][j]=1e18;\n\tdp[0][n+1]=0;\n\tll ans=1e18;\n\trep(i,0,n){\n\t\tif(i)\n\t\t\t--c[pos[i]],++c[1];\n\t\trep(j,1,n+2)\n\t\t\tb[j]=b[j-1]+c[j],s[j]=0;\n\t\t_rep(j,n+1,i+2){\n\t\t\tif(j!=n+1)ins(pos[j]);\n\t\t\t\t//printf(\"%d %d %d\\n\",i,j-1,pos[j-1]+b[pos[j-1]]+query(pos[j-1]));\n\t\t\t\tif(pos[j-1]+b[pos[j-1]]+query(pos[j-1])==j-1)\n\t\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\t\telse\n\t\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]+A);\n\t\t\t\n\t\t\t\tif(pos[i+1]+b[pos[i+1]]+query(pos[i+1])==i+1)\n\t\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\t\telse\n\t\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+B);\n\t\t\t\n\t\t}\n\t}\n\t//rep(i,0,n)\n\t//\trep(j,i+1,n)\n\t//\t\tprintf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\trep(i,0,n)\n\t\tans=min(ans,dp[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <boost/container/static_vector.hpp>\n//#include <boost/unordered_set.hpp>\n//#include <boost/unordered_map.hpp>\n//#include <unistd.h>\n\n//#include <cv.h>\n//#include <highgui.h>\n#include <stdlib.h>\n#include <string>\n\nconst int MAX_N = 5050;\nint N;\nlong long A, B;\nint p[MAX_N], pos[MAX_N];\nlong long dp[MAX_N][MAX_N];\n\n//std::set<int> st;\nint left_greater_min[MAX_N], right_lesser_max[MAX_N];\n\nlong long calc(int l, int r) {\n    if (dp[l][r] != -1) {\n        return dp[l][r];\n    }\n\n    long long ret = 0;\n    if (l + r == N) {\n        // nothing to do\n    } else if (left_greater_min[pos[l+1]] >= N - r + 1) {\n        ret = calc(l + 1, r);\n    } else if (right_lesser_max[pos[N-r]] <= l) {\n        ret = calc(l, r + 1);\n    } else {\n        ret = std::min(B + calc(l + 1, r), A + calc(l, r + 1));\n    }\n\n    dp[l][r] = ret;\n    return ret;\n\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N >> A >> B;\n\n    for (int i = 1; i <= N; i++) {\n        std::cin >> p[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        pos[p[i]] = i;\n    }\n\n    for (int i = 1; i <= N; i++) {\n        left_greater_min[i] = N;\n        right_lesser_max[i] = 0;\n        for (int j = i - 1; 1 <= j; j--) {\n            if (p[j] > p[i]) {\n                left_greater_min[i] = std::min(left_greater_min[i], p[j]);\n            }\n        }\n        for (int j = i + 1; j <= N; j++) {\n            if (p[j] < p[i]) {\n                right_lesser_max[i] = std::max(right_lesser_max[i], p[j]);\n            }\n        }\n        //std::cout << left_greater_min[i] << \" \" << right_lesser_max[i] << std::endl;\n    }\n\n\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            dp[i][j] = -1;\n        }\n    }\n\n    std::cout << calc(0, 0) << std::endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nint main() {\n    ll n, a, b;\n    cin >> n >> a >> b;\n    VI p(n);\n    REP(i,n) p[i] = in() - 1;\n    VL c(n, b);\n\n    VVL dp(n + 1, VL(n + 1, 1e18));\n    dp[0][0] = 0;\n    REP(i,n+1){\n        REP(j,n) dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + c[j]);\n        if (i < n){\n            REP(j,n+1) dp[i+1][j] = dp[i][j];\n            dp[i+1][p[i]+1] = dp[i][p[i]];\n            c[p[i]] = a;\n        }\n    }\n    cout << dp[n][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ts cout<<\"ok\"<<endl\n#define ll long long\n#define hh puts(\"\")\n#define pc putchar\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\n//char buf[1<<21],*p1=buf,*p2=buf;\nusing namespace std;\nconst int N=5005;\nint n,A,B,a[N],pos[N],dp[N][N],s[N][N];\ninline int read(){\n    int ret=0,ff=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}\n    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}\n    return ret*ff;\n}\nvoid write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}\nvoid writeln(int x){write(x),hh;}\nvoid writesp(int x){write(x),pc(' ');}\nsigned main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=1;i<=n;i++) a[i]=read(),pos[a[i]]=i;\n\tmemset(dp,0x3f,sizeof(dp));\n\tmemset(s,0x3f,sizeof(s));\n\tfor(int i=1;i<=n;i++) s[0][i]=dp[0][i]=0;\n\tfor(int i=1;i<=n;i++){//从小到大放 \n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(pos[i]==j) dp[i][j]=min(dp[i][j],s[i-1][j-1]);\n\t\t\tdp[i][j]=min(dp[i][j],s[i-1][j]+(j<pos[i]?B:A));\n\t\t}\n\t\ts[i][0]=dp[i][0];\n\t\tfor(int j=1;j<=n;j++) s[i][j]=min(s[i][j-1],dp[i][j]);\n\t}\n\twrite(s[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,a,b;\nll mem[5005][5005];\nint p[5005], pos[5005];\nll dp(int id, int cur){\n    if (mem[id][cur] != -1) return mem[id][cur];\n    if (id == 0) return mem[id][cur] = 0;\n    if (pos[id] > cur) {\n        //printf(\"%d at %d needs to move to %d, cost %d\\n\",id,pos[id],cur,b);\n        return mem[id][cur] = dp(id-1,cur)+b; ///move id to cur.\n    }\n    //printf(\"%d at %d, can move to %d, cost %d\\n\",id,pos[id],cur,a);\n    return mem[id][cur] =  min(dp(id-1,pos[id]),dp(id-1,cur)+a);;\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for (int i = 1; i <= n; i++){\n        scanf(\"%d\",&p[i]);\n        pos[p[i]] = i;\n    }\n    memset(mem,-1,sizeof(mem));\n    printf(\"%lld\",min(dp(n,n),dp(n,pos[n])));\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 5050;\nconst Int INF = 1e18;\nInt dp[MAX][MAX];\nInt dp2[MAX][MAX];\nInt dp3[MAX][MAX];\n\nInt p[MAX];\nInt cnt1[MAX],cnt2[MAX];\n\nsigned main(){\n  Int n,a,b;\n  cin>>n>>a>>b;\n  for(Int i=0;i<n;i++) cin>>p[i];\n  \n  for(Int i=0;i<MAX;i++){\n    for(Int j=0;j<MAX;j++){\n      dp[i][j]=INF;\n      dp2[i][j]=0;\n      dp3[i][j]=0;\n    }    \n  }\n  \n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=0;i<n;i++){\n      for(Int j=p[i];j<=n+1;j++)\n        dp2[p[i]-1][j]=i-(cnt1[p[i]]+cnt2[j]);\n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=n-1;i>=0;i--){\n      for(Int j=0;j<=p[i];j++)\n        dp3[j][p[i]+1]=(n-(i+1))-(cnt2[p[i]]+cnt1[j]);\n      \n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  \n  dp[0][n+1]=0;\n  for(Int w=n+1;w>0;w--){\n    for(Int i=0;i+w<=n+1;i++){      \n      Int j=i+w;\n      // ikkai \n      chmin(dp[i+1][j],dp[i][j]+b);\n      chmin(dp[i][j-1],dp[i][j]+a);\n      \n      // mettya mawasu\n      chmin(dp[i+1][j],dp[i][j]+dp2[i][j]*a);\n      chmin(dp[i][j-1],dp[i][j]+dp3[i][j]*b);\n    }\n  }\n  \n  Int ans=INF;\n  for(Int i=0;i<=n;i++) chmin(ans,dp[i][i+1]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n/*\n    the problem is:\n        insert p[l] after position r cost A if l < r\n        else cost B\n    does the order of operators matter?\n    dp[i][last] -> sort all 1 2 3 ... i and the last time move the current permultation is last\n    how to insert i+1:\n        use cost A or B to move i+1 after i\n        use i * (cost B or A) to move (1...i) before i+1\n*/\nusing namespace std;\n#ifdef LDT\nconst int maxn = 50;\n#else\nconst int maxn = 5005;\n#endif\nint n, A, B;\nint p[maxn];\nint pos[maxn];\nlong long f[maxn][maxn];\nint best[maxn][maxn];\nint s[maxn][maxn];\nvoid optimize(long long &x, long long a) {\n    if (x > a) x = a;\n}\nint main() {\n#ifdef LDT\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; ++i)\n        cin >> p[i];\n    for (int i = 1; i <= n; ++i)\n        pos[p[i]] = i;\n    for (int i = 1; i <= n; ++i) {\n        best[i][i] = p[i];\n        for (int j = i + 1; j <= n; ++j)\n            best[i][j] = max(best[i][j - 1], p[j]);\n        s[i][0] = 0;\n        for (int j = 1; j <= n; ++j)\n            s[i][j] = s[i][j - 1] + (p[j] > i);\n    }\n    memset(f, 63, sizeof(f));\n    f[1][pos[1]] = 0;\n    for (int i = 1; i <= n; ++i) \n        for (int l = 1; l <= n; ++l) {\n            int nxt = pos[i + 1];\n            if (l < nxt && best[l][nxt] <= i + 1) {\n                optimize(f[i + 1][l], f[i][l]);\n                optimize(f[i + 1][nxt], f[i][l]);\n            }\n            else if (nxt < l) {\n                //move i + 1 after (1..i)\n                optimize(f[i + 1][l], f[i][l] + A);\n                //move (1..i) before i + 1\n                optimize(f[i + 1][nxt], f[i][l] + 1ll * i *  B);\n\n            }\n            else {\n                optimize(f[i + 1][l], f[i][l] + \n                    min(1ll * B, 1ll * A * (s[i][nxt - 1] - s[i][l])));\n                \n                optimize(f[i + 1][nxt], f[i][l] + 1ll * i *  A);\n            }\n        }\n    cout << *min_element(f[n] + 1, f[n] + 1 + n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\nusing ll = long long;\ntypedef pair<int, int> P;\nll Mod = 1000000007;\n\nint N;\nll A,B;\nint p[5012];\nll C[5012];\nbool Graph[5012][5012];\nbool Tr[5012];\nbool exist[5012];\n\nll DFS(int a) {\n  Tr[a] = true;\n  ll f = 0;\n  for (int i = a+1; i < N; i++) {\n    if (Graph[a][i]) {\n      f = max(f,DFS(i) + C[i]); \n      Tr[i] = true;\n    }\n  }\n  return f;\n}\n\nint main() {\n  cin >> N >> A >> B;\n  for (int i = 0; i < N; i++) {\n    cin >> p[i];\n    p[i]--;\n    \n  }\n  ll normal_cost = 0;\n  for (int i = 0; i < N; i++) {\n    if (p[i] > i) {\n      normal_cost += A;\n      C[i] = A;\n    } else if (p[i] < i) {\n      normal_cost += B;\n      C[i] = B;\n    } else {\n      C[i] = 0;\n    }\n  }\n  \n  for (int i = 0; i < N; i++) {\n    for (int j = i; j < N; j++) {\n      if (p[i] < p[j]) {\n        exist[i] = true;\n        Graph[i][j] = true;\n      }\n    } \n  }\n  ll ans = normal_cost;\n  ans = min(ans,A*(N-1));\n  ans = min(ans,B*(N-1));\n  for (int i = 0; i < N; i++) {\n    if (Tr[i]) {\n      continue;\n    }\n    ll res = normal_cost;\n    if (!exist[i]) {\n      continue;\n    }\n    res -= C[i];\n    res -= DFS(i);\n    ans = min(ans,res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 5005\n#define INF 1000000000000000000LL\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nll n,a,b,p[MAXN];\nll dp[MAXN];\nint main()\n{\n    scanf(\"%lld%lld%lld\",&n,&a,&b);\n    for(ll i=1;i<=n;i++) scanf(\"%lld\",&p[i]);\n    fill(dp+1,dp+n+1,INF);\n    dp[0]=0;\n    for(ll i=1;i<=n;i++)\n    {\n        ll cntx=0,cnty=0;\n        for(ll j=i-1;j>=0;j--)        \n        {\n            if(p[j]<p[i]) dp[i]=min(dp[i],dp[j]+cntx*b+cnty*a);\n            if(p[j]<p[i]) cntx++; else cnty++;\n        }\n    }\n    ll ans=INF;\n    for(ll i=1;i<=n;i++) ans=min(ans,dp[i]+(n-i)*b);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ll N, A, B;\n  cin >> N >> A >> B;\n  vector<ll> P;\n  P.push_back(0);\n  for(int i = 0; i < N; i++) {\n    ll p;\n    cin >> p;\n    P.push_back(p);\n  }\n  P.push_back(N + 1);\n  N = A.size();\n  vector<ll> dp(N, 1LL << 62);\n  dp[0] = 0;\n  for(int i = 0; i < N; i++) {\n    ll acc = 0;\n    for(int j = i - 1; j >= 0; j--) {\n      if (P[j] < P[i]) {\n        dp[i] = min(dp[i], dp[j] + acc);\n        acc += B;\n      } else {\n        acc += A;\n      }\n    }\n  }\n  cout << dp.back() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nint gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n\n#define ll int\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=5100;\nconst long long inf=1e18+800;\nlong long A,B;\n\nll a[maxn];\nll bish[maxn][maxn];\nll kamt[maxn][maxn];\n\nlong long price(ll i,ll j){\n\tif(a[i]>a[j])return inf;\n\tif(kamt[i][j-1]+bish[i+1][j]!=(j-i-1))return inf;\n\treturn kamt[i][j-1]*B+bish[i+1][j]*A;\n}\nlong long dp[maxn];\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\tll n;\n\tcin>>n>>A>>B;\n\tfor(ll i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\ta[0]=0;\n\ta[n+1]=n+1;\n\tn+=2;\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=i+1;j<n;j++){\n\t\t\tkamt[i][j]=kamt[i][j-1];\n\t\t\tif(a[j]<a[i]){\n\t\t\t\tkamt[i][j]++;\n\t\t\t}\t\n\t\t}\t\t\n\t}\n\tfor(ll j=0;j<n;j++){\n\t\tfor(ll i=j-1;i>=0;i--){\n\t\t\tbish[i][j]=bish[i+1][j];\n\t\t\tif(a[j]<a[i]){\n\t\t\t\tbish[i][j]++;\n\t\t\t}\t\n\t\t}\t\t\n\t}\n\tdp[0]=0;\n\tfor(ll i=1;i<n;i++){\n\t\tdp[i]=inf;\n\t\tfor(ll j=0;j<i;j++){\n\t\t\tdp[i]=min(dp[i],dp[j]+price(j,i));\n\t\t}\n\t}\n\tcout<<dp[n-1];\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,aa,bb,i,j,ans,f[5001][5001],a[5001],la;\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&aa,&bb);\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tfor(i=0;i<=n;i++)\n\t for(j=0;j<=n;j++)f[i][j]=1e16;\n\tf[0][0]=0;\n\tfor(i=1;i<=n;i++)\n\t for(j=0;j<=n;j++){\n\t \tla=f[i-1][j];\n\t \tif(la==1e16)continue;\n\t \tif(a[i]>j){\n\t \t\tf[i][j]=min(f[i][j],la+aa);\n\t \t\tf[i][a[i]]=min(f[i][a[i]],la);\n\t \t}\n\t \t else f[i][j]=min(f[i][j],la+bb);\n\t }\n\t ans=1e16;\n\t for(i=0;i<=n;i++)ans=min(ans,f[n][i]);\n\t printf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n#define LL long long\n\nint n;\nLL a,b;\nint p[5000],inv[5000];\nLL dp[5001][10001],mindp[5001][10002];\n\nint main(){\n  cin>>n>>a>>b;\n  REP(i,n){cin>>p[i];p[i]--;}\n  REP(i,n)inv[p[i]]=i;\n  REP(i,n+1)mindp[i][0]=0LL;\n  REP(i,2*n+1){dp[0][i]=0LL;mindp[0][i+1]=0LL;}\n  \n  FOR(i,1,n+1){\n    REP(j,2*n+1){\n      if(2*inv[i-1]+1==j)\n\tdp[i][j]=mindp[i-1][j];\n      else if(2*inv[i-1]+1 < j)\n\tdp[i][j]=mindp[i-1][j]+a;\n      else\n\tdp[i][j]=mindp[i-1][j]+b;\n\n      if(j==0){\n\tdp[i][j]=mindp[i-1][j]+b;\n\tmindp[i][j+1] = dp[i][j];\n\tmindp[i][j] = dp[i][j];\n      }else\n\tmindp[i][j+1] = min(dp[i][j],mindp[i][j]);\n    }\n  }\n\n  /*\n  REP(i,n+1){\n    REP(j,2*n+1)\n      cerr<<dp[i][j]<<\" \";\n    cerr<<endl;\n  }\n\n  REP(i,n+1){\n    REP(j,2*n+2)\n      cerr<<mindp[i][j]<<\" \";\n    cerr<<endl;\n  }\n  */\n  \n  \n  cout<<*min_element(dp[n],dp[n]+2*n+1)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\t//     . .. ... ..... be naame khodaa ..... .... ... .. .     \\\\\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x;}\n\nconst int N = 5005;\nconst ll INF = 1e18;\n\nll dp[N][N], best[N];\nint p[N], q[N];\n\nint main() {\n\tint n = in();\n\tll R = in(), L = in();\n\tfor(int i = 1; i <= n; i++) {\n\t\tq[p[i] = in()] = i;\n\t}\n\tfor(int j = 0; j <= n; j++) {\n\t\tdp[0][j] = j*R;\n\t}\n\tfill(best, best + n + 1, INF);\n\tbest[0] = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tint pos = q[i];\n\t\t\tll &res = dp[i][j];\n\t\t\tres = INF;\n\t\t\tif(j >= pos - 1)\n\t\t\t\tres = dp[i - 1][j];\n\t\t\tif(j) {\n\t\t\t\tif(p[j] <= i)\n\t\t\t\t\tres = min(res, dp[i][j - 1]);\n\t\t\t\tif(p[j] == i)\n\t\t\t\t\tres = min(res, dp[i - 1][j - 1]);\n\t\t\t\tres = min(res, dp[i][j - 1] + R);\n\t\t\t}\n\t\t\tres = min(res, dp[i - 1][j] + L);\n\t\t\t//res = min(min(dp[i - 1][pos - 1], best[i - 1] + L), res);\n\t\t\tbest[i] = min(best[i], dp[i][j]);\n//\t\t\tcerr << i << \", \" << j << \": \" << res << endl;\n\t\t}\n\tcout << best[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nnamespace my_std{\n\tusing namespace std;\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define templ template<typename T>\n\t#define sz 5050\n\ttypedef long long ll;\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n}\nusing namespace my_std;\n\nint n;\nll A,B;\nint pos[sz];\n\nll dp[sz][sz],mn[sz][sz];\n\nint main()\n{\n\tread(n,A,B);\n\tint x;\n\trep(i,1,n) read(x),pos[x]=i;\n\tmemset(dp,0x3f,sizeof(dp));memset(mn,0x3f,sizeof(mn));\n\trep(i,0,n) dp[0][i]=mn[0][i]=0;\n\trep(i,1,n) rep(j,0,n)\n\t{\n\t\tif (pos[i]==j) dp[i][j]=min(mn[i-1][j-1],dp[i-1][j]+A);\n\t\telse if (pos[i]>j) dp[i][j]=mn[i-1][j]+B;\n\t\telse dp[i][j]=mn[i-1][j]+A;\n\t\tmn[i][j]=min(dp[i][j],j?mn[i][j-1]:ll(1e15));\n\t}\n\tcout<<mn[n][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inf 2333333333333333333LL\n\nll mn[5010][5010],mx[5010][5010];\nll num[5010],p[5010],f[5010][5010],n,a,b;\n\ninline ll rd()\n{\n\tll x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nint main()\n{\n\tn=rd();a=rd();b=rd();\n\tfor (int i=1;i<=n;i++) num[i]=rd(),p[num[i]]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tmn[i][i]=mx[i][i]=p[i];\n\t\tfor (int j=i+1;j<=n;j++) mn[i][j]=min(mn[i][j-1],p[j]),mx[i][j]=max(mx[i][j-1],p[j]);\n\t}\n\tfor (int len=2;len<=n;len++) for (int i=1;i+len-1<=n;i++)\n\t{\n\t\tint j=i+len-1;f[i][j]=inf;\n\t\tif (p[i]==mn[i][j]) f[i][j]=min(f[i][j],f[i+1][j]);\n\t\telse f[i][j]=min(f[i][j],f[i+1][j]+b);\n\t\tif (p[j]==mx[i][j]) f[i][j]=min(f[i][j],f[i][j-1]);\n\t\telse f[i][j]=min(f[i][j],f[i][j-1]+a);\n\t}\n\tprintf(\"%lld\\n\",f[1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define ll long long\nconst int Q=5005;\nll f[Q][Q];\nint ml[Q],mr[Q],p[Q];\nint st[Q];\nint main()\n{\n\tint n;\n\tll a,b;\n\tscanf(\"%d%lld%lld\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&p[i]);\n\tint tp=0;\n\tfor(int i=n;i;--i){\n\t\twhile(p[i]<st[tp])--tp;\n\t\tmr[p[i]]=st[tp];\n\t\tst[++tp]=p[i];\n\t}\n\ttp=0;\n\tst[0]=998244353;\n\tfor(int i=1;i<=n;i++){\n\t\tint x=p[i];\n\t\tml[x]=998244353,mr[x]=-1;\n\t\tfor(int j=1;j<i;j++)\n\t\t\tif(p[j]>x)ml[x]=min(ml[x],p[j]);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(p[j]<x)mr[x]=max(mr[x],p[j]);\n\t}\n\tfor(int len=1;len<=n;len++)\n\t\tfor(int i=1;i+len-1<=n;i++){\n\t\t\tint j=i+len-1;\n\t\t\tif(i==j)f[i][j]=0;\n\t\t\telse f[i][j]=min(f[i][j-1]+(mr[j]<i?0:a),f[i+1][j]+(ml[i]>j?0:b));\n\t\t}\n\tprintf(\"%lld\\n\",f[1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nll dp[5001][5001];\nll A, B;\nint N;\nint p[5001];\nconst ll INF = 1e+18;\n\nint main(){\n    cin >> N >> A >> B;\n    for(int i = 0; i < N; i++) cin >> p[i];\n    for(int i = 0; i <= N; i++){\n        for(int j = 0; j <= N; j++){\n            dp[i][j] = INF;\n        }\n    }\n    dp[0][0] = 0;\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j <= N; j++){\n            if(dp[i][j] == INF) continue;\n            if(j < p[i]){\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j]+A);\n                dp[i+1][p[i]] = min(dp[i+1][p[i]], dp[i][j]);\n            }else{\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j]+B);\n            }\n        }\n    }\n    ll ans = INF;\n    for(int i = 0; i <= N; i++) ans = min(ans, dp[N][i]);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nint n,A,B;\nint a[5005];\nlong long dp[5005];\nint main()\n{\n\tn=read(),A=read(),B=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\ta[n+1]=0x3f3f3f3f;memset(dp,0x3f,sizeof(dp));dp[0]=0;\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tint sl=0,sr=0;\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t{\n\t\t\tif(a[j]<a[i]) dp[i]=min(dp[i],dp[j]+1ll*sl*A+1ll*sr*B);\n\t\t\tif(a[j]>a[i]) sl++;if(a[j]<a[i]) sr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n+1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ll N, A, B;\n  cin >> N >> A >> B;\n  vector<ll> P;\n  P.push_back(0);\n  for(int i = 0; i < N; i++) {\n    ll p;\n    cin >> p;\n    P.push_back(p);\n  }\n  P.push_back(N + 1);\n  N = P.size();\n  vector<ll> dp(N, 1LL << 62);\n  dp[0] = 0;\n  for(int i = 0; i < N; i++) {\n    ll acc = 0;\n    for(int j = i - 1; j >= 0; j--) {\n      if (P[j] < P[i]) {\n        dp[i] = min(dp[i], dp[j] + acc);\n        acc += B;\n      } else {\n        acc += A;\n      }\n    }\n  }\n  cout << dp.back() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 5010\n#define LL long long\nLL dp[MAXN][MAXN],A,B;\nint n,a[MAXN],c[MAXN][MAXN][2];\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1,cnt=0;j<=n;j++)\n\t\t{\n\t\t\tif(a[j]<a[i]) cnt++;\n\t\t\tc[i+1][j][0]=cnt;\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i-1,cnt=0;j>0;j--)\n\t\t{\n\t\t\tif(a[j]>a[i]) cnt++;\n\t\t\tc[j][i-1][1]=cnt;\n\t\t}\n\tfor(int len=2;len<=n;len++)\n\t\tfor(int i=1,j=i+len-1;j<=n;i++,j++)\n\t\t\tdp[i][j]=min(dp[i][j-1]+min(B,A*c[i][j-1][1]),dp[i+1][j]+min(A,B*c[i+1][j][0]));\n\tprintf(\"%lld\\n\",dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\n#define pb           push_back\n#define ff           first\n#define ss           second\n#define gcd(a, b)    __gcd(a, b)\n#define lcm(a, b)    ((a)*((b)/gcd(a,b)))\n#define all(v)       v.begin(),v.end()\n#define lllim        2147483648\n#define Pi           2*acos(0.0)\n#define sci(n)\t     scanf(\"%d\",&n)\n#define scii(n,m)    scanf(\"%d%d\",&n,&m)\n#define scl(n)       scanf(\"%lld\",&n)\n#define scll(n,m)    scanf(\"%lld%lld\",&n,&m)\n#define pii          pair<int,int>\n#define pll \t     pair<ll,ll>\n#define mem(a,b)     memset(a, b, sizeof(a))\n#define fill_(a,b)   fill(a,a+n,b);\n#define MOD          1000000007\n#define fast_cin     ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define filein       freopen(\"input.txt\",\"r\", stdin)\n#define watch(x)   \t cerr << __LINE__ << \": \" << #x << \" = \" << (x) << '\\n'\n\n/*------------------------------Graph Moves----------------------------*/\n//const int fx[]= {+1,-1,+0,+0};\n//const int fy[]= {+0,+0,+1,-1};\n//const int fx[]= {+0,+0,+1,-1,-1,+1,-1,+1};  // Kings Move\n//const int fy[]= {-1,+1,+0,+0,+1,+1,-1,-1}; // Kings Move\n//const int fx[]={-2, -2, -1, -1,  1,  1,  2,  2};  // Knights Move\n//const int fy[]={-1,  1, -2,  2, -2,  2, -1,  1}; // Knights Move\n/*---------------------------------------------------------------------*/\n\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int maxn=3000005;\nint ara[maxn];\nint tree[maxn*3];\nint lazy[maxn*3];\n\nvoid init(int node,int b, int e)\n{\n    if(b==e)\n    {\n        tree[node]=ara[b];\n        return ;\n    }\n    int mid=(b+e)>>1;\n    int left=node<<1;\n    int right=left+1;\n    init(left, b,mid);\n    init(right,mid+1,e);\n    tree[node]=tree[left]+tree[right];\n}\nvoid update(int node,int b, int e, int i, int j,int value)\n{\n    if(lazy[node])\n    {\n        tree[node]+=(e-b+1)*lazy[node];\n        if(b!=e)\n        {\n            lazy[node*2]+=lazy[node];\n            lazy[node*2+1]+=lazy[node];\n        }\n        lazy[node]=0;\n    }\n    if(e<i or b>j) return ;\n    if(b>=i and e<=j)\n    {\n        tree[node]+=(e-b+1)*value;\n        if(b!=e)\n        {\n            lazy[node*2]+=value;\n            lazy[node*2+1]+=value;\n        }\n        return ;\n    }\n    int mid=(b+e)>>1;\n    int left=node<<1;\n    int right=left+1;\n    update(left, b,mid,i,j,value);\n    update(right,mid+1,e,i,j,value);\n    tree[node]=tree[left]+tree[right];\n}\nint  query(int node,int b, int e, int i,int j)\n{\n    if(lazy[node])\n    {\n        tree[node]+=(e-b+1)*lazy[node];\n        if(b!=e)\n        {\n            lazy[node*2]+=lazy[node];\n            lazy[node*2+1]+=lazy[node];\n        }\n        lazy[node]=0;\n    }\n    if(e<i or b>j) return 0;\n    if(b>=i and e<=j)\n    {\n        return tree[node];\n    }\n    int mid=(b+e)>>1;\n    int left=node<<1;\n    int right=left+1;\n    int x=query(left, b,mid,i,j);\n    int y=query(right,mid+1,e,i,j);\n    return x+y;\n}\nint  main()\n{\n    int n,a,b;\n    scanf(\"%d%d%d\",&n,&a,&b);\n\n    for(int i=1;i<=n;i++)\n    {\n        int num;\n        scanf(\"%d\",&num);\n        ara[num]=i;\n    }\n\n   // cout<<\" done\"<<endl;\n    init(1,1,n);\n\n    int ans=0;\n\n    for(int i=n;i>=1;i--)\n    {\n        int pos1=query(1,1,n,i,i);\n\n        if(pos1<=0)\n        {\n            pos1=n+pos1;\n        }\n        if(pos1>n)\n        {\n            pos1=pos1-n;\n        }\n\n        //cout<<pos1<<\" \"<<i<<endl;\n\n        int ans1,ans2;\n\n        if(pos1==i)\n        continue;\n        if(pos1<i)\n        {\n            ans1=(i-pos1)*b;\n            ans2=(pos1 + n-i)*a;\n\n            if(ans1<ans2)\n            {\n                update(1,1,n,1,n,(i-pos1));\n            }\n            else\n            {\n                 update(1,1,n,1,n,(i-n-pos1));\n            }\n            ans+=min(ans1,ans2);\n        }\n\n    }\n\n    printf(\"%d\",ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n,A,B,a[MAXN];ll F[MAXN];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),A=read(),B=read();Rep(i,1,n)a[i]=read()+1;a[0]=1,a[n+1]=n+2,memset(F,0x3f,sizeof(F)),F[0]=0;\n\tRep(i,1,n+1){ll tmp=0;Red(j,i-1,0)(a[j]<a[i]?F[i]=min(F[i],F[j]+tmp):0),(a[j]<a[i]?tmp+=B:0),(a[j]>a[i]?tmp+=A:0);}\n\tcout<<F[n+1]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define dep(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(i,x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n    ll f=1,x=0;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n//******head by yjjr******\nconst int maxn=5e3+6;\nint n,p[maxn];\nll f[maxn][maxn],A,B;\nint main(){\n    n=read(),A=read(),B=read();\n    rep(i,1,n){int x=read();p[x]=i;}\n    mem(f,0x20);\n    f[0][0]=0;\n    rep(i,1,n+1)rep(j,0,i)\n        if(p[i]>p[j]){\n            f[i][i]=min(f[i][i],f[i-1][j]);\n            f[i][j]=min(f[i][j],f[i-1][j]+B);\n        }else f[i][j]=min(f[i][j],f[i-1][j]+A);\n    cout<<*min_element(f[n],f[n]+n+1)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 998244353LL;// (ll)(1e9 + 7);\n\n\nvoid solve()\n{\n\tll N, A, B;\n\tcin >> N >> A >> B;\n\tauto p = cinv(N);\n\n\tif (A > B){\n\t\tstd::swap(A, B);\n\t\tstd::reverse(p.begin(), p.end());\n\t}\n\n\tmap<ll, ll> dp;\n\tdp[0] = A;\n\tdp[p[0]] = 0;\n\n\tREP(i, N-1){\n\t\tll k = p[i+1];\n\n\t\tll x;\n\t\tfor (auto it = dp.begin(); it != dp.end(); ){\n\t\t\tll j = it->first;\n\t\t\tif (j < k){\n\t\t\t\tx = it->second;\n\t\t\t\tit->second += A;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tit->second += B;\n\t\t\t\tif (it->second >= x) it = dp.erase(it);\n\t\t\t\telse                 it++;\n\t\t\t}\n\t\t}\n\t\tdp[k] = x;\n\t}\n\tcout << ((--dp.end())->second) << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long dp[5100][5100];\nint p[5100];\nint at[5100];\nint RT[5100][5100];\nint LT[5100][5100];\nint X,Y;\nlong long calc(int a,int b){\n\tif(a>=b)return 0;\n\tif(~dp[a][b])return dp[a][b];\n\tif(at[b]==RT[a][b]){\n\t\treturn dp[a][b]=calc(a,b-1);\n\t}\n\tif(at[a]==LT[a][b]){\n\t\treturn dp[a][b]=calc(a+1,b);\n\t}\n\treturn dp[a][b]=min(calc(a,b-1)+X,calc(a+1,b)+Y);\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);X=b;Y=c;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);p[i]--;\n\t\tat[p[i]]=i;\n\t}\n\tfor(int i=0;i<=a;i++)for(int j=0;j<=a;j++)\n\t\tdp[i][j]=-1;\n\tfor(int i=0;i<a;i++){\n\t\tint cur1=0;\n\t\tint cur2=a;\n\t\tfor(int j=i;j<a;j++){\n\t\t\tcur1=max(cur1,at[j]);\n\t\t\tcur2=min(cur2,at[j]);\n\t\t\tRT[i][j]=cur1;\n\t\t\tLT[i][j]=cur2;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",calc(0,a-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ( (int)(x).size() )\nusing LL = long long;\n\ntemplate<class T>\ninline bool asMn(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<class T>\ninline bool asMx(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst LL infLL = 1e18;\nmt19937 rng( (int)chrono::steady_clock::now().time_since_epoch().count() );\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n  #ifdef FourLeafClover\n  freopen(\"input\", \"r\", stdin);\n  #endif // FourLeafClover\n\n  int n, a, b; cin >> n >> a >> b;\n  vector<int> p(n);\n  for (auto &i : p) cin >> i, --i;\n\n  vector<vector<LL> > f(n + 1, vector<LL>(n + 1, infLL) );\n  f[0][0] = 0;\n  for (int i = 0; i + 1 < sz(f); ++i) {\n    for (int j = 0; j < sz(f[i]); ++j) if (f[i][j] ^ infLL) {\n      if (p[i] >= j) {\n        asMn(f[i + 1][ p[i] + 1 ], f[i][j]);\n        asMn(f[i + 1][j], f[i][j] + a);\n      }\n      else asMn(f[i + 1][j], f[i][j] + b);\n    }\n  }\n\n  cout << *min_element(all(f.back() ) ) << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=5005;\nll f[N],res,ret;int a[N],n,A,B;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\t++n,a[n]=n;\n\tfp(i,1,n){\n\t\tf[i]=1e18,ret=0;\n\t\tfd(j,i-1,0)a[j]<a[i]?(cmin(f[i],f[j]=ret),ret+=B):ret+=A;\n\t}\n\tprintf(\"%lld\\n\",f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll            long long\n#define pb            emplace_back\n#define fi            first\n#define se            second\n#define mp            make_pair\n//#define int           int64_t\n\nusing namespace std;\n\ntypedef pair<ll, int> pii;\nconst int N = (int)5e3 + 5;\nconst ll inf = (ll)1e18;\n\nint n, A, B, a[N], pos[N];\nll f[N][N], mn;\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    #define FileName      \"test\"\n    if(fopen(FileName\".inp\", \"r\")) {\n       freopen(FileName\".inp\", \"r\", stdin);\n       freopen(FileName\".out\", \"w\", stdout);\n    }\n    cin >> n >> A >> B;\n    fill_n(&f[0][0], N * N, inf);\n    for(int i = 1; i <= n; ++i) cin >> a[i], pos[a[i]] = i - 1;\n    ///(0, 1], (1, 2], (2, 3], ..., (n - 1, n], (n, n + 1]\n    ///to the right A, to the left B\n    for(int i = 0; i <= n; ++i) f[1][i] = (i == pos[1]? 0: (i < pos[1]? B: A));\n    for(int i = 2; i <= n; ++i) { /// f(i, j) = sort 1 -> i, pos(i) in range (j, j + 1]\n        mn = inf;\n        for(int j = 0; j <= n; ++j) {\n            /// f(i, j) min f(i - 1, k) k < j\n            mn = min(mn, f[i - 1][j]);\n            f[i][j] = mn + (j == pos[i]? 0: (j < pos[i]? B: A));\n        }\n    }\n    cout << *min_element(f[n], f[n] + n + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int N = 5005;\n\nint a[N];\nint b[N];\nint mn[N][N];\nint mx[N][N];\nlong long dp[N][N];\n\nint main() {\n\tint n, x, y;\n\tcin >> n >> x >> y;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tb[a[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmn[i][i] = b[i];\n\t\tmx[i][i] = b[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int l = 1; l + i <= n; l++) {\n\t\t\tint r = l + i;\n\t\t\tmn[l][r] = min(mn[l][r - 1], b[r]);\n\t\t\tmx[l][r] = max(mx[l][r - 1], b[r]);\n\t\t\tdp[l][r] = dp[l + 1][r];\n\t\t\tif (mn[l][r] == mn[l + 1][r]) {\n\t\t\t\tdp[l][r] += y;\n\t\t\t}\n\t\t\tif (mx[l][r] == mx[l][r - 1]) {\n\t\t\t\tdp[l][r] = min(dp[l][r], dp[l][r - 1] + x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[l][r] = min(dp[l][r], dp[l][r - 1]);\n\t\t\t}\n\t\t//\tcout << \"73 \" << l << \" \" << r << \" \" << mn[l][r] << \" \" << mx[l][r] << \" \" << dp[l][r] << endl;\n\t\t}\n\t}\n\tcout << dp[1][n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint p[8192],wz[8192];\nlong long dp[5005][5005];\nint main()\n{\n\tint n,a,b;\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&p[i]);\n\t\twz[p[i]]=i;\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(i==0&&j==0)\n\t\t\t{\n\t\t\t\tdp[i][j]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i][j]=1000000000000000000LL;\n\t\t\tif(i)\n\t\t\t{\n\t\t\t\tif(dp[i-1][j]<dp[i][j])\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j)\n\t\t\t{\n\t\t\t\tint inc=a;\n\t\t\t\tif(wz[j]>i)\n\t\t\t\t{\n\t\t\t\t\tinc=b;\n\t\t\t\t}\n\t\t\t\tif(dp[i][j-1]+inc<dp[i][j])\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i][j-1]+inc;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i&&j)\n\t\t\t{\n\t\t\t\tif(wz[j]==i)\n\t\t\t\t{\n\t\t\t\t\tif(dp[i-1][j-1]<dp[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j]=dp[i-1][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSR(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nll A,B;\nint p[5005];\nvector<P>vec;\nll up[5005],dw[5005];\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t}\n\tint cur = -1;\n\tint pre = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i == 1){\n\t\t\tcur = p[i];\n\t\t}\n\t\telse if(cur+1 != p[i]){\n\t\t\tvec.pb(mp(pre+1,i-1));\n\t\t\tpre = i-1;\n\t\t\tcur = p[i];\n\t\t}\n\t\telse cur++;\n\t}\n\tvec.pb(mp(pre+1,n));\n\tll ans = 1e18;\n\tll C = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = 0;\n\t\tll R = vec[i].sc-vec[i].fi+1;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t    if(i == j) continue;\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] < p[y]){\n\t\t\t\tif(j < i) L += vec[j].sc-vec[j].fi+1;\n\t\t\t\telse R += vec[j].sc-vec[j].fi+1;\n\t\t\t}\n\t\t}\n\t\tC += min(L*A,R*B);\n\t//\tcout << i << \" \" << L << \" \" << R<< endl;\n\t}\n\tll D = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = 0;\n\t\tll R = vec[i].sc-vec[i].fi+1;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t    if(i == j) continue;\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] < p[y]){\n\t\t\t\tif(j < i) L += vec[j].sc-vec[j].fi+1;\n\t\t\t\telse;\n\t\t\t}\n\t\t}\n\t\tD += min(L*A,R*B);\n\t}\n\tcout << D << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N = 5005;\nconst LL inf = 0x3f3f3f3f3f3f3f3f;\n\nint n, a, b;\nLL dp[N][N], ans = inf;\n\nvoid down(LL &x, LL y) { x = std::min(x, y); }\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::memset(dp, 0x3f, sizeof dp), std::cin >> n >> a >> b;\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x; std::cin >> x;\n\t\tfor (int j = 0; j <= n; ++j) if (dp[i][j] < inf) {\n\t\t\tif (x < j)\n\t\t\t\tdown(dp[i + 1][j], dp[i][j] + b);\n\t\t\telse\n\t\t\t\tdown(dp[i + 1][x], dp[i][j]),\n\t\t\t\tdown(dp[i + 1][j], dp[i][j] + a);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; ++i) down(ans, dp[n][i]);\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\nconst LL N = 1000000007;\n\nLL n,l,r;\nLL a[5005],dp[5005];\n\nint main(){\n\tmemset(dp,0x3f,sizeof(dp));\n\tcin >> n >> r >> l;\n\tfor(LL i = 1;i <= n;i ++){\n\t\tcin >> a[i];\n\t\ta[i] ++;\n\t}\n\ta[0] = 1; dp[0] = 0; a[n + 1] = n + 2;\n\tfor(LL i = 1;i <= n + 1;i ++){\n\t\tLL sr = 0,sl = 0;\n\t\tfor(LL j = i - 1;j >= 0;j --){\n\t\t\tif(a[j] < a[i]) dp[i] = min(dp[i],dp[j] + r * sr + l * sl);\n\t\t\tif(a[j] > a[i]) sr ++; if(a[j] < a[i]) sl ++;\n\t\t}\n\t}\n\tcout << dp[n + 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<deque>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define double long double\n    const int INF=0x3f3f3f3f;\n    const ll LLINF=0x3f3f3f3f3f3f3f3fll;\n    ll qread()\n    {\n        ll ans=0;char c=getchar();int f=1;\n        while(c<'0' or c>'9') {if(c=='-') f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) {num=-num;putchar('-');}\n        if(num>9) write(num/10);\n        putchar('0'+num%10);\n    }\n    void writeln(ll num){write(num);puts(\"\");}\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define pr pair<int,int>\n    #define PB push_back\n    #define vc vector\n    void chmax(int &x,const int y) {x=x>y?x:y;}\n    void chmin(ll &x,const ll y) {x=x<y?x:y;}\n    const int MAX_N=5e3+10;\n    const ll MOD=1e13;\n    void add(int &x,int y) {x+=y;if(x>=MOD) x-=MOD;if(x<0) x+=MOD;}\n\n    ll f[MAX_N];//前缀和\n    int a[MAX_N];\n    void main()\n    {\n        int n=qread(),A=qread(),B=qread();\n        for(int i=1;i<=n;i++) a[qread()]=i;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=n;j>=0;j--)\n            {\n                f[j]=f[j]+A*(a[i]<=j)+B*(a[i]>j);\n                if(j==a[i]) chmin(f[j],f[j-1]);\n                else if(j) chmin(f[j],f[j-1]+A*(a[i]<j)+B*(a[i]>j));\n            }\n            for(int j=1;j<=n;j++) chmin(f[j],f[j-1]);\n            // puts(\"\");\n        }\n\n        ll ans=LLINF;for(int j=0;j<=n;j++) chmin(ans,f[j]);write(ans);\n    }\n};\nint main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,p[10005],i,j;\nlong long f[5005],s,ans=100000000000000ll;\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&a,&b);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&p[i]);\n\t\tf[i]=100000000000000ll;\n\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\ts=0;\n\t\tfor(j=i-1;j>=0;--j)\n\t\t{\n\t\t\tif(p[i]>p[j])\n\t\t\t\tf[i]=min(f[i],f[j]+s);\n\t\t\tif(p[j]>p[i])\n\t\t\t\ts+=a;\n\t\t\telse\n\t\t\t\ts+=b;\n\t\t}\n\t}\n\tfor(i=n;i>=0;--i)\n\t{\n\t\ts=0;\n\t\tfor(j=i+1;j<=n;++j)\n\t\t\ts+=b;\n\t\tans=min(ans,f[i]+s);\n\t}\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define loop(i, a, b, inc) for(int i = a; i < (b); i += inc)\n#define rep(i, n) loop(i, 0, n, 1)\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nll total = 0;\nll l;\nll r;\n\npii merge(pii a, pii b) { // assume b lower than a, and a is left of b\n\tll al = a.second-a.first+1;\n\tll bl = b.second-b.first+1;\n\n\ttotal += min(al*l, bl*r);\n\n\treturn {b.first, a.second};\n}\n\nvoid fn(vector<pii> &vec) {\n\tlist<pii> arr;\n\tarr.insert(arr.begin(), vec.begin(), vec.end());\n\n\twhile (arr.size() != 1) {\n\t\tfor (auto it = arr.begin(); it != arr.end(); it++) {\n\t\t\tif (it->first == prev(it)->second + 1) {\n\t\t\t\t*it = {prev(it)->first, it->second};\n\t\t\t\tarr.erase(prev(it));\n\t\t\t} else if (prev(it)->first == it->second + 1) {\n\t\t\t\t*it = merge(*prev(it), *it);\n\t\t\t\tarr.erase(prev(it));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n >> l >> r;\n\n\tvector<pii> arr(n);\n\trep(i, n) {\n\t\tint x;\n\t\tcin >> x;\n\t\tarr[i] = {x, x};\n\t}\n\n\tfn(arr);\n\tcout << total << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 5e3 + 5;\nconst int kInf = 1e18;\nint dp[N][N];\nint min_pos[N][N];\nint max_pos[N][N];\n\nint p[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, a, b;\n  cin>>n>>a>>b;\n  RE (i, n) {\n    cin>>p[i];\n    min_pos[p[i]][p[i]] = i;\n    max_pos[p[i]][p[i]] = i;\n  }\n  FOR (len, 2, n) {\n    RE (i, n - len + 1) {\n      int j = i + len - 1;\n      dp[i][j] = min(dp[i + 1][j] + b, dp[i][j - 1] + a);\n      if (min_pos[i][i] < min_pos[i + 1][j]) {\n        mini(dp[i][j], dp[i + 1][j]);\n      }\n      if (max_pos[j][j] > max_pos[i][j - 1]) {\n        mini(dp[i][j], dp[i][j - 1]);\n      }\n      max_pos[i][j] = max(max_pos[i][j - 1], max_pos[j][j]);\n      min_pos[i][j] = min(min_pos[i][i], min_pos[i + 1][j]);\n    }\n  }\n  cout<<dp[1][n]<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//constexpr long long MOD = 1000000007;\nconstexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nll dp[5050][5050];\nint L[5050][5050],R[5050][5050];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll N,A,B; cin >> N >> A >> B;\n    vector<int> p(N);\n    rep(i,N) {\n        cin >> p[i];\n        --p[i];\n    }\n\n    rep(i,N) rep(j,N-i) {\n        L[i][j] = -1;\n        R[i][j] = -1;\n    }\n    rep(i,N) {\n        L[p[i]][N-1-p[i]] = p[i];\n        int y = N-1-p[i]-1;\n        while (y >= 0 and L[p[i]][y]==-1) {\n            L[p[i]][y] = p[i];\n            y--;\n        }\n        int x = p[i]-1;\n        while (x >= 0 and L[x][N-1-p[i]]==-1) {\n            L[x][N-1-p[i]] = p[i];\n            x--;\n        }\n    }\n    rep(i,N) rep(j,N-i) {\n        if (L[i][j]==-1) {\n            L[i][j] = L[i+1][j];\n        }\n    }\n    for (int i = N-1; i >= 0; i--) {\n        R[p[i]][N-1-p[i]] = p[i];\n        int y = N-1-p[i]-1;\n        while (y >= 0 and R[p[i]][y]==-1) {\n            R[p[i]][y] = p[i];\n            y--;\n        }\n        int x = p[i]-1;\n        while (x >= 0 and R[x][N-1-p[i]]==-1) {\n            R[x][N-1-p[i]] = p[i];\n            x--;\n        }\n    }\n    rep(i,N) rep(j,N-i) {\n        if (R[i][j]==-1) {\n            R[i][j] = R[i+1][j];\n        }\n    }\n\n    rep(i,N+1) rep(j,N+1-i) dp[i][j] = 1e18;\n    dp[0][0] = 0;\n    rep(k,N) {\n        rep(i,k+1) {\n            if (L[i][k-i]==i) {\n                chmin(dp[i+1][k-i],dp[i][k-i]);\n            } else {\n                chmin(dp[i+1][k-i],dp[i][k-i]+B);\n            }\n            if (R[i][k-i]==N-1-(k-i)) {\n                chmin(dp[i][k-i+1],dp[i][k-i]);\n            } else {\n                chmin(dp[i][k-i+1],dp[i][k-i]+A);\n            }\n        }\n    }\n\n    ll ans = 1e18;\n    rep(i,N+1) chmin(ans,dp[i][N-i]);\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\ni64 memo[5050][5050];\nint ll[5050], rr[5050];\nint n;\ni64 a, b;\n\ni64 rec(int l, int r) {\n    if (l == r) return 0;\n    if (memo[l][r] > 0) return memo[l][r];\n    i64 cl = (l < ll[l] && ll[l] <= r) ? b : 0,\n        cr = (l <= rr[r] && rr[r] < r) ? a : 0;\n    return memo[l][r] = std::min(cl + rec(l + 1, r), cr + rec(l, r - 1));\n}\n\nint main() {\n    std::cin >> n >> a >> b;\n    std::vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> p[i];\n    }\n    std::set<int> s;\n    for (int i = 0; i < n; i++) {\n        auto it = s.upper_bound(p[i]);\n        if (it != s.end()) ll[p[i]] = *it;\n        else ll[p[i]] = -1;\n        s.insert(p[i]);\n    }\n    s.clear();\n    for (int i = n - 1; i >= 0; i--) {\n        auto it = s.lower_bound(p[i]);\n        if (it != s.begin()) rr[p[i]] = *--it;\n        else rr[p[i]] = -1;\n        s.insert(p[i]);\n    }\n    std::cout << rec(1, n) << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nLL N, X, Y;\nvector<int> A;\nint P[5003][5003];\n\nvoid pre() {\n\tREP(i, 1, N + 1) {\n\t\tint sum = 0;\n\t\tREP(j, 0, N + 1) {\n\t\t\tsum += P[i][j];\n\t\t\tP[i][j] = P[i - 1][j] + sum;\n\t\t}\n\t}\n}\n\nint rect(int li, int lj, int ri, int rj) {\n\treturn P[li][lj] - P[li][rj] - P[ri][lj] + P[ri][rj];\n}\n\nLL DP[5002];\nint main() {\n\tcin >> N >> X >> Y;\n\tA.push_back(0);\n\tREP(i, 0, N) A.push_back(Next<int>());\n\tA.push_back(N + 1);\n\n\tN += 2;\n\tREP(i, 0, N) {\n\t\t++P[i + 1][A[i] + 1];\n\t}\n\tpre();\n\n\tFill(DP, INFLL);\n\tDP[0] = 0;\n\tREP(i, 1, N) {\n\t\tLL mn = INFLL;\n\t\tREP(li, 0, i) {\n\t\t\tif (A[li] > A[i]) continue;\n\t\t\tint L = rect(li, A[li], i, N) - 1;\n\t\t\tint R = rect(i, A[li], N, A[i]);\n\n\t\t\tmn = min(mn, DP[li] + L * X + R * Y);\n\t\t}\n\t\tDP[i] = mn;\n\t}\n\tcout << DP[N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL N=5010;\nLL n, a, b, p[N], id[N], dp[N][N], s[N][N];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\tfor(LL i=1; i<=n; ++i)scanf(\"%lld\",&p[i]), id[p[i]]=i;\n\tmemset(s,0x3f,sizeof(s));\n\tfor(LL i=0; i<=n; ++i)s[0][i]=0;\n\tfor(LL i=1; i<=n; ++i)\n\t\tfor(LL j=1; j<=n; ++j){\n\t\t\tdp[i][j]=s[i-1][j]+(j>=id[i]?a:b);\n\t\t\tif(j==id[i])dp[i][j]=min(dp[i][j],s[i-1][j-1]);\n\t\t\tif(j>0)s[i][j]=min(s[i][j-1],dp[i][j]);else s[i][j]=dp[i][j];\n\t\t}\n\tLL mn=0x3f3f3f3f3f3f3f3f;\n\tfor(LL i=1; i<=n; ++i)mn=min(mn,dp[n][i]);\n\tprintf(\"%lld\",mn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2e3 + 10;\n\nint n, A, B, p[N];\nll dp[N];\n\nint main() {\n  scanf(\"%d %d %d\", &n, &A, &B);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &p[i]);\n  }\n  p[++n] = n;\n  for (int i = 1; i <= n; i++) {\n    dp[i] = (ll) 1e18;\n    ll tmp = 0;\n    for (int j = i - 1; j >= 0; j--) {\n      if (p[j] < p[i]) {\n        dp[i] = min(dp[i], dp[j] + tmp);\n        tmp += A;\n      } else {\n        tmp += B;\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pa pair<int,int>\nusing namespace std;\nconst int N = 5001;\nconst int inf = 2147483647;\n\nint _max(int x, int y) {return x > y ? x : y;}\nLL _min(LL x, LL y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint a[N]; LL f[N][N];\n\nint main() {\n\tint n = read(), A = read(), B = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tmemset(f, 63, sizeof(f)); f[0][0] = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tif(a[i] > j) {\n\t\t\t\tf[i][j] = _min(f[i][j], f[i - 1][j] + A);\n\t\t\t\tf[i][a[i]] = _min(f[i][a[i]], f[i - 1][j]);\n\t\t\t} else f[i][a[i]] = _min(f[i][a[i]], f[i - 1][j] + B);\n\t\t}\n\t} LL ans = f[0][1];\n\tfor(int i = 0; i <= n; i++) ans = _min(ans, f[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int N=5022;\nLL dp[N][N];\nint n,a,b,x[N],pos[N];\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]), pos[x[i]]=i;\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)dp[i][j]=1e18;\n    dp[0][0]=0;\n    for(int i=1;i<=n;i++){\n        LL mn=dp[i-1][0];\n        for(int j=0;j<=n+1;j++){\n            mn=min(mn,dp[i-1][j]);\n\n            if(j==pos[i]) dp[i][j]=mn;\n            else if(j<pos[i]) dp[i][j]=mn+b;\n            else dp[i][j]=mn+a;\n    \n            //printf(\"dp[%d][%d]=%lld\\n\", i,j,dp[i][j]);\n        }\n    }\n    LL ans=1e18;\n    for(int i=0;i<=n+1;i++)ans=min(ans,dp[n][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 5e3 + 5;\nconst int maxm = 1e7 + 5;\n\nconst int mod = 1e9 + 7;\nint n , A , B;\nint pos[maxn] , a[maxn];\nint m = 0;\nll f[maxn][maxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\"))\n        freopen(taskname\".INP\",\"r\",stdin),\n        freopen(taskname\".OUT\",\"w\",stdout);\n    cin >> n >> A >> B;\n    for(int i = 1 ; i <= n ; ++i){\n        cin >> a[i];\n        pos[a[i]] = i;\n    }\n    memset(f,123,sizeof  f);\n    f[1][0] = 0;\n    ll res = 1e18;\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = 0 ; j < i ; ++j){\n            if(pos[i] > pos[j]){\n                f[i + 1][j] = min(f[i + 1][j] , f[i][j] + B);\n                f[i + 1][i] = min(f[i][j] , f[i + 1][i]);\n            }else{\n                f[i + 1][j] = min(f[i + 1][j] , f[i][j] + A);\n            }\n        }\n    }\n    cout << *min_element(f[n+1],f[n+1]+n);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll dp[5005][5005],a,b;\nint p[5005],n;\nint mx[5005][5005],mn[5005][5005];\nint f[5005][5005];\n\nint calc(int x1,int x2,int y1,int y2){\n\treturn f[x2][y2]+f[x1-1][y1-1]-f[x1-1][y2]-f[x2][y1-1];\n}\n\nint main(){\n\tscanf(\"%d %lld %lld\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&p[i]),f[i][p[i]]=1;\n\tfor(int l=1;l<=n;l++){\n\t\tmx[l][l]=mn[l][l]=p[l];\n\t\tfor(int r=l+1;r<=n;r++){\n\t\t\tmx[l][r]=max(mx[l][r-1],p[r]);\n\t\t\tmn[l][r]=min(mn[l][r-1],p[r]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) f[i][j]=f[i][j-1]+f[i-1][j]-f[i-1][j-1]+f[i][j];\n\t}\n\tfor(int len=2;len<=n;len++){\n\t\tfor(int l=1,r;l<=n-len+1;l++){\n\t\t\tr=l+len-1;\n\t\t\tdp[l][r]=min(dp[l][r-1]+min(b*(p[r]<mx[l][r-1]),1ll*a*calc(l,r-1,p[r],n)),dp[l+1][r]+min(a*(p[l]>mn[l+1][r]),1ll*b*calc(l+1,r,1,p[r])));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[1][n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define MOD 998244353LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tvector<ll> p(n);\n\tREP(i, n) cin >> p[i];\n\tvector<vector<ll>> dp(n, vector<ll>(n + 1, INF * INF));\n\tdp[0][0] = a;\n\tdp[0][p[0]] = 0;\n\tFOR(i, 1, n) {\n\t\tvector<ll> mn1(n + 1, INF * INF);\n\t\tvector<ll> mn2(n + 1, INF * INF);\n\t\tREP(j, n + 1) {\n\t\t\tif(j == 0) mn1[j] = dp[i - 1][0];\n\t\t\telse mn1[j] = min(dp[i - 1][j], mn1[j - 1]);\n\t\t}\n\t\tfor(ll j = n; j >= 0; j--) {\n\t\t\tif(j == n) mn2[j] = dp[i - 1][n];\n\t\t\telse mn2[j] = min(dp[i - 1][j], mn2[j + 1]);\n\t\t}\n\t\tREP(j, n + 1) {\n\t\t\tif(j == 0) {\n\t\t\t\tdp[i][j] = a + dp[i - 1][j];\n\t\t\t} else if(j == p[i]) {\n\t\t\t\tdp[i][j] = mn1[j];\n\t\t\t} else if(j < p[i]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + a;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + b;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = INF * INF;\n\tREP(i, n + 1) {\n\t\tans = min(ans, dp[n - 1][i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long ll;\n\nll gcd(ll x, ll y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y) {\n\treturn x / gcd(x, y)*y;\n}\nll kai(ll x, ll y, ll m) {\n\tll res = 1;\n\tfor (ll i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nll mod_pow(ll x, ll y, ll m) {\n\tll res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll comb(ll x, ll y, ll m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nconst ll INF = 1000000000000000000;\n\nint n, a, b, p[5010], x[5010];\nint cum[5010][5010];\nll d[5010][5010];\nll ans = INF;\n\nsigned main() {\n\tstd::random_device rnd;\n\tstd::mt19937_64 mt(rnd());\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; i++)cin >> p[i], x[p[i]] = i;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\tif (i < p[j])cum[i][j] = cum[i][j - 1] + 1;\n\t\telse cum[i][j] = cum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= n; i++)for (int j = 1; j <= i; j++)d[i][j] = INF;\n\td[1][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tll k = d[i][j];\n\t\t\tif (x[i + 1] < x[j])k += a;\n\t\t\tif (x[j] + 1 < x[i + 1])k += min((ll)b, (ll)a*(cum[i + 1][x[i + 1]] - cum[i + 1][x[j]]));\n\t\t\td[i + 1][j] = min(d[i + 1][j], k);\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tif (x[j] < x[i + 1])d[i + 1][i + 1] = min(d[i + 1][i + 1], d[i][j] + (ll)a*(cum[i + 1][x[i + 1]] - cum[i + 1][x[j]]));\n\t\t\tif (x[j] < x[i + 1])cnt++;\n\t\t}\n\t\td[i + 1][i + 1] = min(d[i + 1][i + 1], (ll)cnt*a + (ll)(i - cnt)*b);\n\t}\n\tfor (int i = 1; i <= n; i++)ans = min(ans, d[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define loop(i, a, b, inc) for(int i = a; i < (b); i += inc)\n#define rep(i, n) loop(i, 0, n, 1)\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nll total = 0;\nll l;\nll r;\n\npii merge(pii a, pii b) { // assume b lower than a, and a is left of b\n\tll al = a.second-a.first+1;\n\tll bl = b.second-b.first+1;\n\n\ttotal += min(al*l, bl*r);\n\n\treturn {b.first, a.second};\n}\n\nvoid fn(vector<pii> &arr) {\n\tint n = arr.size();\n\n\tif (n == 1) {\n\t\treturn;\n\t}\n\n\tloop(i, 1, n, 1) {\n\t\tif (arr[i].first == arr[i-1].second + 1) {\n\t\t\tarr[i] = {arr[i-1].first, arr[i].second};\n\t\t\ti--;\n\t\t\tarr.erase(arr.begin() + i);\n\t\t\tn--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (arr[i-1].first == arr[i].second + 1) {\n\t\t\tarr[i] = merge(arr[i-1], arr[i]);\n\t\t\ti--;\n\t\t\tarr.erase(arr.begin() + i);\n\t\t\tn--;\n\t\t}\n\t}\n\tfn(arr);\n}\n\nint main() {\n\t// freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n >> l >> r;\n\n\tvector<pii> arr(n);\n\trep(i, n) {\n\t\tint x;\n\t\tcin >> x;\n\t\tarr[i] = {x, x};\n\t}\n\n\tfn(arr);\n\tcout << total << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 1000000000000000000;\n\tcin >> N >> A >> B;\n\tvector<long long> P(N);\n\tvector<vector<long long> > DP(N + 1, vector<long long>(N + 1, INF));\n\tDP[0][0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (DP[i][j] >= INF) continue;\n\t\t\tif (j < P[i]) {\n\t\t\t\tDP[i + 1][P[i]] = min(DP[i + 1][P[i]], DP[i][j]);\n\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + A);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + B);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[N][i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n\nusing namespace std;\n\nconst int maxn = 5000 + 7;\n\nint n, A, B, pos[maxn], dp[maxn][maxn], a[maxn];\n\nint le[maxn][maxn], ri[maxn][maxn];\n\nint DP(int pos, int val)\n{\n    if(dp[pos][val] != -1) return dp[pos][val];\n    if(pos > n || pos < 1) return 1e18;\n    if(val > n || val < 1) return 1e18;\n    if(val == 1)\n    {\n        if(pos == ::pos[1]) return 0;\n        if(pos < ::pos[1]) return B;\n        else return A;\n    }\n    int ans = 1e18;\n    int posval;\n    if(::pos[val] <= pos)\n    {\n        ans = min(ans, DP(pos + 1, val - 1) + A);\n    }\n    if(::pos[val] >= pos && le[val][::pos[val]] - le[val][pos - 1] == 1)\n    {\n        ans = min(ans, DP(pos, val - 1));\n    }\n    if(::pos[val] >= pos && le[val][::pos[val]] - le[val][pos - 1] > 1)\n    {\n        ans = min(ans, DP(pos, val - 1) + B);\n    }\n    return dp[pos][val] = ans;\n}\n\nint32_t main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(\"test.inp\", \"r\")) freopen(\"test.inp\", \"r\", stdin);\n    fill_n(&dp[0][0], maxn * maxn, -1);\n    cin >> n >> A >> B;\n    for(int i = 1; i <= n; i++)\n    {\n        int x;\n        cin >> x;\n        pos[x] = i;\n        a[i] = x;\n    }\n    for(int id = 1; id <= n; id++)\n    {\n        int cnt = 0;\n        for(int j = 1; j <= n; j++)\n        {\n            if(a[j] >= id) cnt++;\n            le[id][j] = cnt;\n        }\n    }\n    cout << DP(1, n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register\n#define int long long\nusing namespace std; const int N=5010;\ninline int read()\n{\n    int s=0,w=1; char ch=getchar();\n    while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar(); return s*w;\n}\nint n,A,B,val[N];\nint dp[N][N],p[N];\nsigned main()\n{\n\tn=read(), A=read(), B=read();\n\tfor(ri int i=1;i<=n;i++) {int x=read(); p[x]=i; }\n\tfor(ri int i=1;i<=n;i++) for(ri int j=0;j<=n;j++) dp[i][j]=LONG_LONG_MAX/2;\n\tfor(ri int i=1;i<=n;i++)\n\t{\n\t\tfor(ri int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(p[i]==j) dp[i][j]=min(dp[i-1][j-1],dp[i][j]);\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+(j<p[i]?B:A));\n\t\t}\n\t\tfor(ri int j=1;j<=n;j++) dp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){ll res=1;a%=mod;while(b){if(b&1)res=res*a%mod;a=a*a%mod;b>>=1;}return res;}\nvi seg;\nll N;\nvoid init(vi v){\n    N=1;\n    while(N<v.size())N*=2;\n    seg=vi(N*2-1);\n    rep(i,v.size())seg[i+N-1]=v[i];\n    for(int i=N-2;i>=0;i--)seg[i]=seg[i*2+1]+seg[i*2+2];\n}\nvoid add(ll i,ll x){\n    i=N+i-1;\n    seg[i]+=x;\n    while(i>0){\n        i=(i-1)/2;\n        seg[i]=seg[i*2+1]+seg[i*2+2];\n    }\n}\nll getsum(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return seg[k];\n    ll c1=getsum(a,b,k*2+1,l,(l+r)/2);\n    ll c2=getsum(a,b,k*2+2,(l+r)/2,r);\n    return c1+c2;\n}\nvoid chr(ll k,ll x){\n    ll s=getsum(0,k+1,0,0,N);\n    if(s<=x)return;\n    add(k,x-s);\n    add(k+1,s-x);\n}\nint main(){\n    ll n,l,r;cin>>n>>r>>l;\n    vi dp(n);\n    rep(i,n){\n        ll a;cin>>a;\n        a--;\n        vi ndp(n,inf);\n        rep(j,n){\n            if(j<=a)chmin(ndp[a],dp[j]);\n            if(j<=a)chmin(ndp[j],dp[j]+r);\n            if(j>a)chmin(ndp[j],dp[j]+l);\n        }\n        dp=ndp;\n    }\n    ll ans=inf;\n    rep(i,n)chmin(ans,dp[i]);\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ll,ii>\n#define endl '\\n'\n\nint n,a,b;\nint arr[5005];\nint pos[5005];\n\nll memo[5005][10005];\n\nint main(){\n\tios::sync_with_stdio(0);\n    cin.tie(0);\n\t\n\tmemset(memo,127,sizeof(memo));\n\t\n\tcin>>n>>a>>b;\n\tfor (int x=1;x<=n;x++) cin>>arr[x];\n\tfor (int x=1;x<=n;x++) pos[arr[x]]=x*2;\n\n\tfor (int x=0;x<=2*n;x++) memo[0][x]=0;\n\t\n\tfor (int x=1;x<=n;x++){\n\t\tfor (int y=1;y<=2*n+1;y++){\n\t\t\tif (y%2==0 && pos[x]==y){\n\t\t\t\tmemo[x][y]=min(memo[x][y-1],memo[x-1][y-1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo[x][y]=min(memo[x][y-1],memo[x-1][y-1]+(pos[x]<y?a:b));\n\t\t\t}\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<memo[x][y]<<endl;\n\t\t}\n\t}\n\t\n\tcout<<memo[n][2*n+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n    // return getchar();\n    static char buf[100000],*l=buf,*r=buf;\n    return l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x)\n{\n    x=0; int f=1,ch=nc();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n    while(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n    x*=f;\n}\ntemplate<class T> inline bool Cmin(T &x,T y) {return x>y?x=y,1:0;}\ntypedef long long ll;\nconst ll INF=1e18;\nconst int inf=1e9;\nconst int maxn=5000+50;\nint n,A,B;\nint p[maxn];\nll f[maxn];\nint main()\n{\n    read(n),read(A),read(B);\n    for(int i=1;i<=n;++i)\n    {\n        read(p[i]);\n    }\n    ++n; p[n]=n;\n    for(int i=1;i<=n;++i) f[i]=INF;\n    for(int i=0;i<n;++i)\n    {\n        ll cost=0; int mn=inf;\n        for(int j=i+1;j<=n;++j)\n        {\n            if(p[j]<p[i])\n            {\n                cost+=B;\n            }\n            else\n            {\n                if(p[j]<mn) \n                {\n                    Cmin(f[j],f[i]+cost);\n                    mn=p[j];\n                }\n                cost+=A;\n            }\n        }\n    }\n    printf(\"%lld\\n\",f[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 998244353ll;\nconst ll MAXN = (ll) 5e3 + 100;\nconst ll INF = (ll) 9223372036854775;\nconst ld EPS = (ld) 1e-8;\n\nll a[MAXN], dp[MAXN], ind[MAXN];\nvector<ll> fr;\n\n\nll BS2(ll x){\n\tll l = -1, r = fr.size();\n\tll mid;\n\twhile(l + 1 < r){\n\t\tmid = (l + r) / 2;\n\t\tif(fr[mid] < x) l = mid;\n\t\telse r = mid;\n\t}\n\treturn fr.size() - r;\n}\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tll n, A, B;\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t\tind[a[i]] = i;\n\t}\n\t\n\tmemset(dp, 31, sizeof dp);\n\tdp[0] = 0;\n\ta[0] = -1;\n\tll ans = n * A;\n\tfor(int i = 1; i <= n; i++){\n\t\tll ca = 0;\n\t\tll cb = 0;\n\t\tfr.clear();\n\t\tfor(int j = i + 1; j <= n; j++) fr.pb(a[j]);\n\t\tfor(int j = i - 1; j > 0; j--){\n\t\t\tif(a[j] < a[i]){\n\t\t\t\tll cnt = BS2(a[j]) - BS2(a[i]);\n\t\t\t\tdp[i] = min(dp[i], dp[j] + cnt * B + ((a[i] - a[j] - 1) - cnt) * A);\n\t\t\t}\n\t\t\tif(j == 0) break;\n\t\t}\n\t\tdp[i] = min(dp[i], B * (a[i] - 1));\n\t\tans = min(ans, dp[i] + (n - a[i]) * A);\n\t}\n\tcout << ans;\n \t\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, A, B;\nvector<ll> p;\nvector<ll> inv;\nll mini[5001][5001], maxi[5001][5001];\nll dp[5001][5001];\nvector<ll> lovermini, rundermaxi;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> A >> B;\n    p.resize(N);\n    inv.resize(N);\n    lovermini.resize(N);\n    rundermaxi.resize(N);\n    for(int i = 0; i < N; i++) {\n        cin >> p[i];\n        p[i]--;\n        inv[p[i]] = i;\n    }\n    for(int i = 0; i < N; i++) {\n        lovermini[i] = 1e9;\n        rundermaxi[i] = -1e9;\n        for(int j = 0; j < i; j++) {\n            if(p[j] > p[i]) chmin(lovermini[i], p[j]);\n        }\n        for(int j = i + 1; j < N; j++) {\n            if(p[j] < p[i]) chmax(rundermaxi[i], p[j]);\n        }\n    }\n    for(int delta = 2; delta <= N; delta++) {\n        for(int l = 0; l + delta <= N; l++) {\n            dp[l][l+delta] = 1e18;\n            if(lovermini[inv[l]] <= l + delta - 1) {\n                chmin(dp[l][l+delta], dp[l+1][l+delta] + A);\n            } else {\n                chmin(dp[l][l+delta], dp[l+1][l+delta]);\n            }\n            if(rundermaxi[inv[l+delta-1]] >= l) {\n                chmin(dp[l][l+delta], dp[l][l+delta-1] + B);\n            } else {\n                chmin(dp[l][l+delta], dp[l][l+delta-1]);\n            }\n        }\n    }\n    cout << dp[0][N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\n//i未満左端、j未満はignore\nll dp[5001][5001];\n\nstruct BIT {\nprivate:\n\tvector<int> node; int n;\npublic:\n\tBIT(int n_) {\n\t\tn = n_; node.resize(n, 0);\n\t}\n\t//0-indexed\n\tvoid add(int a, int w) {\n\t\tfor (int i = a; i < n; i |= i + 1)node[i] += w;\n\t}\n\t//[0,a)\n\tint sum(int a) {\n\t\tint ret = 0;\n\t\tfor (int i = a - 1; i >= 0; i = (i&(i + 1)) - 1)ret += node[i];\n\t\treturn ret;\n\t}\n\t//[a,b)\n\tint sum(int a, int b) {\n\t\treturn sum(b) - sum(a);\n\t}\n};\n\nvoid solve() {\n\tint n; ll a, b; cin >> n >> a >> b;\n\tvector<int> p(n),invp(n);\n\trep(i, n) {\n\t\tcin >> p[i]; p[i]--; invp[p[i]] = i;\n\t}\n\tBIT bi(n);\n\trep(i, 5001) {\n\t\trep(j, 5001) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\trep(i, n) {\n\t\tint id = invp[i];\n\t\trep(j, n+1) {\n\t\t\t//right\n\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]+b);\n\t\t\t//left\n\t\t\tif (j <= id) {\n\t\t\t\tint num = bi.sum(j, id);\n\t\t\t\tnum = id - j - num;\n\t\t\t\t//cout << i << \" \" << j << \" \" << num << endl;\n\t\t\t\tdp[i + 1][id+1] = min(dp[i + 1][id+1], dp[i][j] + a * num);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t}\n\t\t}\n\t\tbi.add(id, 1);\n\t}\n\tll ans = INF;\n\trep(i, n + 1) {\n\t\tans = min(ans, dp[n][i]);\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=5005;\nint n,A,B,a[N];\nll f[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) f[i]=1ll<<60;\n\tFor(i,1,n){\n\t\tll S=0;\n\t\tRep(j,i-1,1){\n\t\t\tif (a[j]<a[i])\n\t\t\t\tf[i]=min(f[i],f[j]+S);\n\t\t\tS+=(a[j]<a[i]?B:A);\n\t\t}\n\t\tf[i]=min(f[i],S);\n\t}\n\tll ans=1ll<<60;\n\tFor(i,1,n){\n\t\tll S=0;\n\t\tFor(j,i+1,n)\n\t\t\tS+=(a[j]<a[i]?B:A);\n\t\tans=min(ans,f[i]+S);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 5000 + 20 , inf = 3e18 + 20 ;\nint n , a , b , p[N] ;\nint cnt[N][N] , dp[N] , ans = inf ;\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n >> a >> b ;\n\n\tfor (int i = 0 ; i < n ; i ++) cin >> p[i] , p[i] -- , dp[i] = inf ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tfor (int j = 0 ; j <= n ; j ++) cnt[i + 1][j] = cnt[i][j] ;\n\t\tfor (int j = p[i] + 1; j <= n; j ++) cnt[i + 1][j] ++ ;\n\t}\n\n\tfor (int i = 0 , mn = inf ; i < n ; i ++) {\n\t\tmn = min(mn , p[i]) ;\n\n\t\tif (p[i] == mn) {\n\t\t\tdp[i] = a * (i - cnt[i][p[i]]) + b * (cnt[n][p[i]] - cnt[i][p[i]]) ;\t\n\t\t}\n\n\t\tint mx = -1 ;\n\n\t\tfor (int j = i - 1 ; j >= 0 ; j --) {\n\t\t\tif (p[j] < mx || p[i] < p[j]) continue ;\n\t\t\tmx = p[j] ;\n\n\t\t\tint val = dp[j] ;\n\n\t\t\tval += a * ((i - cnt[i][p[i]]) - (j - cnt[j][p[i]])) + b * (cnt[n][p[i]] - cnt[n][p[j]] - cnt[i][p[i]] + cnt[i][p[j]]) ;\n\n\t\t\tdp[i] = min(dp[i] , val) ;\n\t\t}\n\n\t\tmx = -1 ;\n\n\t\tfor (int j = n - 1 ; j > i ; j --) mx = max(mx , p[j]) ;\n\n\t\tif (mx < p[i]) ans = min(ans , dp[i]) ;\n\t}\n\n\tcout << ans << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define FORD(i,a,b) for(int i=(a);i>=(b);--i)\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\ninline int msbp(int x) {return 31-__builtin_clz(x);}\ninline int msb(int x) {return 1 << msbp(x);}\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 0x3f3f3f3f3f3f3f3fLL;\n// const int INF = 0x3f3f3f3f;\n// const int INF = INT_MAX;\n// const int nINF = INT_MIN;\n// const ll INF = LLONG_MAX;\n// const ll nINF = LLONG_MIN;\n\n/////////////////////////////////////////////////////////////////////\n\nconst int N = 5e3+10;\n\nint n, p[N], id[N];\nll dp[N][N], a, b;\n// dp[i][j] - min cost to sort elts 1..i and leave elt i at [j-1, j)\n// dp[i][j] = (min(dp[i-1][k]), k <= j) + (a when j <= id[i], 0 when j == id[i]-1, b when j > id[i])\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    //cout << fixed << setprecision(7);\n    memset(dp, INF, sizeof(dp));\n    cin >> n >> a >> b;\n    REP(i, n) {\n    \tcin >> p[i];\n    \tid[p[i]] = i;\n    }\n    FOR(i, 0, n) dp[0][i] = 0;\n    FOR(i, 1, n) {\n    \tll mn = INF;\n    \tint cur_id = id[i];\n    \tFOR(j, 0, n) {\n    \t\tmn = min(mn, dp[i-1][j]);\n    \t\tll cost;\n    \t\tif(cur_id == j-1) cost = 0;\n    \t\telse if(cur_id > j-1) cost = b;\n    \t\telse cost = a;\n    \t\tdp[i][j] = mn+cost;\n    \t}\n    }\n    ll ans = INF;\n    FOR(i, 0, n) ans = min(ans, dp[n][i]);\n    cout << ans << endl;\n\n    return 0;\n}\n\n// Easy things to check:\n// - LONG LONGS (WA)\n// - const int N is correct (WA, RTE) CHECK IF IT SHOULD BE 2*N!!!!\n// - .size()-k underflow (WA, RTE, TLE)\n// - small n edge cases (WA)\n\n// Rare mistakes made in the past:\n// - division by 0 (WA)\n// - negative arithmetic, ceiling division, modulo (WA)\n// - setprecision (WA)\n// - INF not big enough using ll (WA)\n// - setting max to 0 instead of -INF/min to 0 instead of INF (WA)\n// - outputting debug (WA)\n// - allocating too much memory (locRTE, MLE)\n// - stack size (locRTE)\n// - round announcements (WA)\n// - multiset::erase (WA)\n// - forgetting to rename recursive call when copy/pasting recursive function (WA)\n// - not clearing DS between test cases EVEN FOR INPUT (WA, RTE, TLE, MLE)\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)(1e18)\nusing namespace std;\n\nlong long n, a, b;\nvector<int> p;\nvector<vector<long long>> dp;\n\nlong long solve();\n\nint main() {\n  cin >> n >> a >> b;\n  p.resize(n);\n  for (auto &x : p) cin >> x;\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long res = inf;\n  dp.assign(n + 1, vector<long long>(n + 1, inf));\n  dp[0][0] = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j <= n; ++j)\n      if (p[i] < j)\n        dp[i + 1][j] = dp[i][j] + b;\n      else if (p[i] > j)\n        dp[i + 1][j] = dp[i][j] + a;\n      else\n        for (int k = 0; k < j; ++k) dp[i + 1][j] = min(dp[i + 1][j], dp[i][k]);\n  for (int i = 0; i <= n; ++i) res = min(res, dp[n][i]);\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 5005\n#define inf 0x3f3f3f3f3f3f3f3fll\ninline long long min(long long x,long long y){return x<y?x:y;}\ninline long long max(long long x,long long y){return x<y?y:x;}\nint a[N],b[N],i,j,n,o,p;long long f[2][N],x;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&o,&p),x=f[1][0]=inf;\n\tfor(i=1;i<=n;i++)scanf(\"%d\",a+i),f[0][b[a[i]]=i]=f[1][i]=inf;\n\tfor(i=1;i<=n;i++)for(j=0;j<=n;f[i&1^1][j++]=inf)\n\tif(a[i]>j)f[i&1][a[i]]=min(f[i&1][a[i]],f[i&1^1][j]),f[i&1][j]=min(f[i&1][j],f[i&1^1][j]+o);\n\telse f[i&1][j]=min(f[i&1][j],f[i&1^1][j]+p);\n\tfor(i=0;i<=n;i++)x=min(x,f[n&1][i]);\n\treturn 0*printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll; \nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=5005;\nconst ll inf=1e18;\nint p[N],f[N],a[N][N];\nll dp[N];\ninline int query(ri x1,ri x2,ri y1,ri y2){\n\treturn x1<=x2&&y1<=y2?a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]:0;\n}\nint main(){\n\tri n,A,B,i,j;\n\tgi(n);gi(A);gi(B);\n\tfor(i=1;i<=n;++i) gi(p[i]),a[i][p[i]]=1;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n\tp[n+1]=n+1;\n\tfor(i=1;i<=n+1;++i){\n\t\tdp[i]=inf;\n\t\tfor(j=i-1;j>=0;--j)\n\t\t\tif(p[j]<p[i])\n\t\t\t\tdp[i]=min(dp[i],dp[j]+(ll)A*query(j+1,i-1,p[i]+1,n)+(ll)B*query(j+1,i-1,1,p[i]-1));\n\t}\n\tprintf(\"%lld\\n\",dp[n+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL n,a,b,ans,p[10000],f[5200][5200];\n\nvoid upd(LL &x,LL y){x=min(x,y);}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\tfor (LL i=1;i<=n;++i) scanf(\"%lld\",p+i);\n\tmemset(f,0x3f,sizeof f); f[0][0]=0;\n\tfor (LL i=1;i<=n;++i)\n\t\tfor (LL j=0;j<=n;++j)\n\t\t\tif (j<=p[i]){\n\t\t\t\tupd(f[i][p[i]],f[i-1][j]);\n\t\t\t\tupd(f[i][j],f[i-1][j]+a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tupd(f[i][j],f[i-1][j]+b);\n\t\t\t}\n\tans=0x3f3f3f3f3f3f3f3fLL;\n\tfor (LL i=0;i<=n;++i) upd(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 5003\n#define ll long long\n\nusing namespace std;\n\nint n, m, a, b;\nint pos[N];\nll f[N][N << 1];\n\nint main(){\n\tcin >> n >> a >> b; m = n * 2 + 1;\n\tfor(int i = 1; i <= n; ++i){\n\t\tint x; scanf(\"%d\", &x);\n\t\tpos[x] = i * 2;\n\t}\n\tmemset(f, 127, sizeof f);\n\tfor(int j = 1; j <= m; ++j) f[0][j] = 0;\n\tfor(int i = 1; i <= n; ++i){\n\t\tfor(int j = 1; j <= m; ++j){\n\t\t\tll tmp = (j != pos[i]) * (j < pos[i] ? b : a);\n\t\t\tif(j & 1) tmp += f[i - 1][j];\n\t\t\telse tmp += f[i - 1][j - 1];\n\t\t\tf[i][j] = tmp;\n\t\t}\n\t\tfor(int j = 2; j <= m; ++j)\n\t\t\tf[i][j] = min(f[i][j], f[i][j - 1]);\n\t}\n\tcout << f[n][m] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint pl[5050],g[5050],a[5050];\nlong long f[5050][5050];\nvoid mn(long long &x,long long y)\n{\n\tx=min(x,y);\n}\nint main()\n{\n\tint tmp,n,i,j,A,B;\n\tlong long ans;\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tpl[a[i]]=i;\n\t\tfor(j=i-1;j;j--)\n\t\t\tif(a[j]>a[i])\n\t\t\t\tg[i]++;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=0;j<=n;j++)\n\t\t\tf[i][j]=1e18;\n\tf[0][0]=0; \n\tfor(i=0;i<n;i++)\n\t{\n\t\ttmp=pl[i+1];\n\t\tfor(j=0;j<=n;j++)\n\t\t{\n\t\t\tif(j>g[tmp])\n\t\t\t\tmn(f[i+1][j-1],f[i][j]+A);\n\t\t\telse\n\t\t\t\tmn(f[i+1][j],f[i][j]+B),mn(f[i+1][g[tmp]],f[i][j]);\n\t\t}\n\t}\n\tans=1e18;\n\tfor(i=0;i<=n;i++)\n\t\tmn(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\ntemplate<typename T> inline LL squ(T x) { return (LL) x * x; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T> inline T read()\n{\n\tT sum = 0, fg = 1; char c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') fg = -1;\n\tfor (; isdigit(c); c = getchar()) sum = (sum << 3) + (sum << 1) + (c ^ 0x30);\n\treturn fg * sum;\n}\n\nconst int maxn = 5e3 + 10;\nconst LL inf = 0x3f3f3f3f3f3f3f3f;\n\nint n, R, L, a[maxn];\nLL dp[maxn];\n\nint main()\n{\n\n\tn = read<int>(), R = read<int>(), L = read<int>();\n\tfor (int i = 1; i <= n; i++) a[i] = read<int>();\n\ta[n + 1] = n + 1;\n\n\tmemset(dp, 0x3f, sizeof dp), dp[0] = 0;\n\tfor (int i = 1; i <= n + 1; i++)\n\t{\n\t\tLL sum = 0;\n\t\tfor (int j = i - 1; ~j; j--)\n\t\t{\n\t\t\tif (a[j] < a[i]) chkmin(dp[i], dp[j] + sum), sum += L;\n\t\t\telse sum += R;\n\t\t}\n\t}\n\n\tcout << dp[n + 1] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nconst double EPS = 1e-10;\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\n\n#define MAX_N (1<<17)\n\nstruct segtree{\n    int n, dat[2*MAX_N-1]; //(1<<17) = 130000\n\n    void init(int n_){\n        n = 1;\n        while(n < n_) n *= 2;\n        for(int i = 0; i < 2*n-1; i++) dat[i] = 0;\n    }\n\n    void update(int k, int a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = dat[k*2+1]+dat[k*2+2];\n        }\n    }\n\n    //(a,b,0,0,seg.n)で呼ぶ\n    int query(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            int vl = query(a,b,k*2+1,l,(l+r)/2);\n            int vr = query(a,b,k*2+2,(l+r)/2,r);\n            return vl+vr;\n        }\n    }\n} seg;\n\nint n;\nll dp[5000][5000];\nll A, B;\nint p[5000];\nint r[5000], l[5000];\n\nint main() {\n    cin >> n;\n    cin >> A >> B;\n    rep(i,n) cin >> p[i];\n    rep(i,n) p[i]--;\n    rep(i,n) {\n        l[p[i]] = INF;\n        rep(j,i) {\n            if (p[j] > p[i] && p[j] < l[p[i]]) {\n                l[p[i]] = p[j];\n            }\n        }\n    }\n    if (n == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    rep(i,n) {\n        r[p[i]] = -1;\n        for (int j = i+1; j < n; j++) {\n            if (p[j] < p[i] && p[j] > r[p[i]]) {\n                r[p[i]] = p[j];\n            }\n        }\n    }\n    /*\n    for (int i = 0; i < n; i++) {\n        cout << r[i] << \" \" << l[i] << endl;\n    }\n    */\n    rep(i,n+1) rep(j,n+1) dp[i][j] = MOD*MOD;\n    ll ans = MOD*MOD;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            //dp[i][j] -> dp[i+1][j], dp[i][j+1]\n            if (l[i] >= n-j) dp[i+1][j] = min(dp[i+1][j], dp[i][j]);\n            else dp[i+1][j] = min(dp[i+1][j], dp[i][j]+B);\n            if (r[n-1-j] < i) dp[i][j+1] = min(dp[i][j+1], dp[i][j]);\n            else dp[i][j+1] = min(dp[i][j+1], dp[i][j]+A);\n            if (i+j+1 == n-1) {\n                ans = min(ans, dp[i+1][j]);\n                ans = min(ans, dp[i][j+1]);\n            }\n        }\n    }\n    /*\n    rep(i,n) {\n        rep(j,n) {\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll INF = 1e18;\nconst int MAXN = 5007;\nll dp[MAXN][MAXN];\nint a[MAXN], p[MAXN];\nint main()\n{\n    int n; ll A, B; scanf(\"%d%lld%lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), p[a[i]] = i;\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j <= n; j++)\n            dp[i][j] = INF;\n    dp[0][0] = 0;\n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j <= i; j++) \n        {\n            if (j <= p[i]) \n            {\n                dp[i][p[i]] = min(dp[i][p[i]], dp[i - 1][j]);\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + B);\n            }\n            else dp[i][j] = min(dp[i][j], dp[i - 1][j] + A);\n        }\n    // for (int i = 0; i <= n; i++)\n    //     for (int j = 0; j <= n; j++) printf(\"%lld%c\", dp[i][j], \" \\n\"[j == n]);\n    ll ans = INF;\n    for (int i = 0; i <= n; i++) ans = min(ans, dp[n][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \n/*\n// ordered_set \n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n# define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n*/\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define Sort(x)                                         sort(all(x))\n# define InTheNameOfGod                                  ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 5e3 + 10;\nconst int xm = - 20 + 10;\nconst int SQ = 320;\nconst int sq = 320 + 10;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst int mod = 1e9 + 7;\nconst int TM = 3;\nconst int base = 257;\n\nll n, p[xn], x, y, part[xn][xn], dp[xn][xn], a[xn][xn], b[xn];\n\nint main(){\n    InTheNameOfGod;\n    \n\tcin >> n >> x >> y;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tcin >> p[i];\n\t\tb[p[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; ++ i) for (int j = 1; j <= n; ++ j) part[i][j] = part[i][j - 1] + (p[j] < i);\n\tfor (int i = 1; i <= n; ++ i){\n\t\tfor (int j = 1; j < i; ++ j) a[i][j] = a[i - 1][j];\n\t\tfor (int j = i; j >= 1; -- j){\n\t\t\tif (a[i][j - 1] > p[i]) a[i][j] = a[i][j - 1];\n\t\t\telse{\n\t\t\t\ta[i][j] = p[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i){\n\t\tfor (int j = 1; j <= i; ++ j){\n\t\t\tdp[i][j] = dp[i][j - 1] + x;\n\t\t\tint ind = b[a[i][j]];\n\t\t\tint ted = part[a[i][j]][i] - part[a[i][j]][ind];\n\t\t\tdp[i][j] = min(dp[i][j], dp[ind - 1][j - ted - 1] + ted * y);\n\t\t}\n\t}\n\tcout << dp[n][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DEBUG_OUTPUT_ENABLED 1\n\t#define DBG(X) dout << #X << \"=\" << (X) << '\\n';\n\t#define SAY(X) dout << (X) << '\\n';\n#else\n\t#define DEBUG_OUTPUT_ENABLED 0\n\t#define DBG(X) 42;\n\t#define SAY(X) 42;\n#endif\n\n#define dout   __debug::instance\nusing namespace std;\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const set<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const multiset<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\nnamespace __debug {\n\tstruct DebugStream {\n\t\tprivate:\n\t\t\tbool is_first;\n\t\tpublic:\n\t\t\tDebugStream(bool _is_first): is_first(_is_first) {}\n\t\t\ttemplate<typename T> DebugStream operator<<(const T& value) const {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\tcout << value;\n\t\t\t\treturn DebugStream(false);\n\t\t\t};\n\n\t\t\ttemplate<typename T> DebugStream printArray(T* l, T* r) {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\twhile(l != r) {\n\t\t\t\t\tcout << (*l);\n\t\t\t\t\t++l;\n\t\t\t\t\tif(l == r) {\n\t\t\t\t\t\tcout << '\\n';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn DebugStream(false);\n\t\t\t}\n\t};\n\tDebugStream instance(true);\n};\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for(auto& elem: ret) cin >> elem; return ret; }\nconst int MAXN = 5007;\nll dp[MAXN][MAXN], A, B;\nint mn[MAXN][MAXN], mx[MAXN][MAXN], a[MAXN], b[MAXN], n;\ninline ll ge(int l, int r) {\n\tif(l <= r) return dp[l][r];\n\telse return 0;\n}\nvoid solve() {\n\tcin >> n >> A >> B;\n\tfor(int i = 0; i < n; ++i) a[i] = fetch<int>() - 1;\n\tfor(int i = 0; i < n; ++i) b[a[i]] = i;\n\tfor(int l = n - 1; l >= 0; --l) {\n\t\tint low = INT_INF, high = -INT_INF;\n\t\tfor(int r = l; r < n; ++r) {\n\t\t\tint v = b[r];\n\t\t\tif(v > high) {\n\t\t\t\thigh = v;\n\t\t\t\tmx[l][r] = r;\n\t\t\t} else {\n\t\t\t\tmx[l][r] = mx[l][r - 1];\n\t\t\t}\n\t\t\tif(v < low) {\n\t\t\t\tlow = v;\n\t\t\t\tmn[l][r] = r;\n\t\t\t} else {\n\t\t\t\tmn[l][r] = mn[l][r - 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int l = n - 1; l >= 0; --l) for(int r = l + 1; r < n; ++r) {\n\t\tdp[l][r] = LL_INF;\n\t\tdp[l][r] = min(dp[l][r], dp[l][r - 1] + A * (mx[l][r] != r));\n\t\tdp[l][r] = min(dp[l][r], dp[l + 1][r] + B * (mn[l][r] != l));\n\t}\n\t//for(int l = 0; l < n; ++l) for(int r = l; r < n; ++r) dout << l << ' ' << r << ' ' << mx[l][r] << '\\n';\n\t//for(int l = 0; l < n; ++l) for(int r = l; r < n; ++r) dout << l << ' ' << r << ' ' << mn[l][r] << '\\n';\n\t//for(int l = 0; l < n; ++l) for(int r = l; r < n; ++r) dout << l << ' ' << r << ' ' << dp[l][r] << '\\n';\n\tcout << dp[0][n - 1] << '\\n';\n}\n\nint main() {\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll n,A,B;\nll a[5001];\nll dp[5001][5002];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>n>>A>>B;\n  rep(i,n){\n    cin>>a[i];\n  }\n\n  rep(i,n+1)rep(j,n+1)dp[i][j]=INF;\n  dp[0][0]=0;\n  rep(i,n)rep(j,n+1){\n    if(a[i]>j){\n      minch(dp[i+1][a[i]],dp[i][j]);\n      minch(dp[i+1][j],dp[i][j]+A);\n    }else{\n      minch(dp[i+1][j],dp[i][j]+B);\n    }\n  }\n  ll res=INF;\n  rep(j,n+1)minch(res,dp[n][j]);\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,x,y,a[5005],f[5005];\nll dp[5005];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&x,&y);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]),f[a[i]]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int pos=f[i];\n        ll t=1e18;\n        for(int j=1;j<=n;j++)\n        {\n            t=min(t,dp[j]);\n            if(pos>j)\n                dp[j]=t+y;\n            else if(pos==j)\n                dp[j]=t;\n            else dp[j]=t+x;\n        }\n    }\n    ll ans=1e18;\n    for(int i=1;i<=n;i++)\n        ans=min(ans,dp[i]);\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n\nint p[5002];\nLLI num[5002][5002],dp[5002];\nint x[5002][5002];\nint main() {\n    int i;\n    int N,A,B;\n    scanf(\"%d %d %d\",&N,&A,&B);\n    for (i = 1; i <= N; i++) scanf(\"%d\",&p[i]);\n    p[0] = 0,p[N+1] = N+1,N += 2;\n\n    int j;\n    for (i = 0; i < N; i++) {\n        int c = 0;\n        for (j = i; j < N; j++) {\n            if (p[j] < p[i]) c++;\n            num[i][j] += (LLI) B*c,x[i][j] += c;\n        }\n    }\n    for (i = 0; i < N; i++) {\n        int c = 0;\n        for (j = i; j >= 0; j--) {\n            if (p[j] > p[i]) c++;\n            num[j][i] += (LLI) A*c,x[j][i] += c;\n            if (x[j][i] != i-j-1) num[j][i] = 1e18;\n        }\n    }\n    for (i = 0; i < N; i++) {\n        dp[i] = num[0][i];\n        for (j = 0; j < i; j++) {\n            if (p[j] < p[i]) dp[i] = min(dp[i],dp[j]+num[j][i]);\n        }\n    }\n    printf(\"%lld\\n\",dp[N-1]);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 320000\nusing namespace std;\nlong long n,A,B;\nlong long L[N],R[N];\nlong long f[5200][5200]; \nlong long a[5200];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&A,&B);\n\tif(n==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tlong long x;\n\t\tscanf(\"%d\",&x);\n\t\ta[x]=i;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tfor(long long j=i+1;j<=n;j++)if(a[j]<a[i]){L[i]=j;break;}\n\t\tfor(long long j=i-1;j>=1;j--)if(a[j]>a[i]){R[i]=j;break;}\n\t}\n\tfor(int i=0;i<=5100;i++){\n\t\tfor(int j=0;j<=5100;j++)f[i][j]=1000000000000000LL;\n\t}\n\tf[0][n+1]=0;\n\tfor(long long i=0;i<n;i++){\n\t\tfor(long long j=n+1;j>i;j--){\n\t\t\tif(L[i]<j)f[i+1][j]=min(f[i][j]+A,f[i+1][j]);\n\t\t\telse f[i+1][j]=min(f[i][j],f[i+1][j]);\n\t\t\tif(R[j]>i)f[i][j-1]=min(f[i][j]+B,f[i][j-1]);\n\t\t\telse f[i][j-1]=min(f[i][j],f[i][j-1]);\n\t\t}\n\t}\n\tlong long ans=1000000000000000LL;\n\tfor(long long i=0;i<=n;i++)ans=min(ans,f[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n#define int long long\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nint A, B;\n\nsigned main() {\n\tscan n, A, B;\n\tvector<int> p(n);\n\tscan p;\n\tapply(p, x--);\n\tvector<int> at(n);\n\tf(i, n) {\n\t\tat[p[i]] = i;\n\t}\n\n\tvector<vector<int>> less(n, vector<int>(n + 1));\n\tfor (int i = 0; i < n; i++) {\n\t\tint offset = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (p[j] < p[i]) {\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\tless[i][n] = offset;\n\t\tfor (int j = n - 1; j > -1; j--) {\n\t\t\tless[i][j] = less[i][j + 1] + (at[j] < i);\n\t\t}\n\t}\n\n\tvector<vector<int>> greater(n, vector<int>(n + 1));\n\tfor (int i = 0; i < n; i++) {\n\t\tint offset = 0;\n\t\tfor (int j = n - 1; j > i; j--) {\n\t\t\tif (p[j] > p[i]) {\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\tgreater[i][0] = offset;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tgreater[i][j] = greater[i][j - 1] + (at[j - 1] > i);\n\t\t}\n\t}\n\n\n\tvector<vector<int>> dp(n + 2, vector<int>(n + 2, 1e18));\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\t{\n\t\t\t\tint w = B;\n\t\t\t\tif (at[i] == less[at[i]][n - j]) {\n\t\t\t\t\tw = 0;\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j] = min(dp[i][j] + w, dp[i + 1][j]);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint w = A;\n\t\t\t\tif (n - 1 - at[n - j - 1] == greater[at[n - j - 1]][i]) {\n\t\t\t\t\tw = 0;\n\t\t\t\t}\n\t\t\t\tdp[i][j + 1] = min(dp[i][j] + w, dp[i][j + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tint final = 1e18;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfinal = min(final, dp[i][n - i]);\n\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nll f[2][5010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),R=gi(),L=gi();\n\tmemset(f,63,sizeof f);\n\tf[0][0]=0;int t=0;\n\tfor(int i=1,a;i<=n;++i){\n\t\ta=gi();memset(f[!t],63,sizeof f[!t]);\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tif(j<a)cnk(f[!t][a],f[t][j]),cnk(f[!t][j],f[t][j]+R);\n\t\t\tcnk(f[!t][std::max(j,a)],f[t][j]+L);\n\t\t}\n\t\tt^=1;\n\t}\n\tll ans=9e18;for(int i=0;i<=n;++i)cnk(ans,f[t][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int MN = 5005;\n\nint A, B, N, pos[MN];\nLL f[MN * 2], g[MN * 2];\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\tfor (int i = 1, x; i <= N; ++i)\n\t\tscanf(\"%d\", &x), pos[x] = i;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 1; j <= N * 2 + 1; ++j)\n\t\t\tg[j] = j & 1 ? j > 1 ? std::min({g[j - 2], f[j - 1], f[j]}) : f[1] : g[j - 1];\n\t\tfor (int j = 1; j <= N * 2 + 1; ++j)\n\t\t\tg[j] += j > 2 * pos[i] ? A : j < 2 * pos[i] ? B : 0;\n\t\tstd::swap(f, g);\n\t}\n\tprintf(\"%lld\\n\", *std::min_element(f + 1, f + 2 * N + 2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    long a, b;\n    cin >> n >> a >> b;\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n        p[i]--;\n    }\n    vector<int> r(n);\n    for (int i = 0; i < n; i++) {\n        r[p[i]] = i;\n    }\n    vector<vector<long>> d(n + 1, vector<long>(n, MAX_LONG));\n    d[0][0] = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (d[i][j] == MAX_LONG) continue;\n//            cout << i << \" \" << j << \" \" << d[i][j] << \"\\n\";\n            int jj = std::max(j, r[i]);\n//            cout << \"-> \" << i + 1 << \" \" << jj << \" \" << d[i][j] + a << \"\\n\";\n            d[i + 1][jj] = std::min(d[i + 1][jj], d[i][j] + a);\n            if (j <= r[i]) {\n                d[i + 1][jj] = std::min(d[i + 1][jj], d[i][j]);\n//                cout << \"-> \" << i + 1 << \" \" << jj << \" \" << d[i][j] << \"\\n\";\n                d[i + 1][j] = std::min(d[i + 1][j], d[i][j] + b);\n//                cout << \"-> \" << i + 1 << \" \" << j << \" \" << d[i][j] + b << \"\\n\";\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (d[i][j] == MAX_LONG) continue;\n        }\n    }\n    long res = MAX_LONG;\n    for (int j = 0; j < n; j++) {\n        res = std::min(res, d[n][j]);\n    }\n    cout << res << \"\\n\";\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define inf 9982443530000000\n#define maxn 5001\n#define int long long\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint n, A, B, a[maxn], b[maxn], pos[maxn], ans = inf, dp[maxn][maxn];\nsigned main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn = read(); A = read(); B = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read(), pos[a[i]] = i;\n\tmemset(dp, 0x3f3f3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < i; j++)\n\t\t{\n\t\t\tif(pos[i] > pos[j]) {\n\t\t\t\tdp[i][i] = min(dp[i - 1][j], dp[i][i]);\n\t\t\t\tdp[i][j] = dp[i - 1][j] + B;\n\t\t\t}\n\t\t\telse dp[i][j] = dp[i - 1][j] + A;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) ans = min(ans, dp[n][i]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,A,B,cr,Poz[5005],x,i,j;\nlong long Dp[5005][5005],cost;\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n    cin>>n>>A>>B;\n    for(i=1; i<=n; i++)\n    {\n        cin>>x;\n        Poz[x]=i;\n    }\n    for(i=1; i<=n; i++)\n    {\n        cr=1-cr;\n        for(j=0; j<=n; j++)\n        {\n            if(j<Poz[i])\n                cost=B;\n            if(j==Poz[i])\n                cost=0;\n            if(j>Poz[i])\n                cost=A;\n            if(j==0)\n                Dp[cr][j]=cost+Dp[1-cr][j];\n            else\n                Dp[cr][j]=min(Dp[cr][j-1],cost+Dp[1-cr][j]);\n        }\n    }\n\tcout<<Dp[cr][n]<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define rrep(i,n) for(int i=1; i<=(n); ++i)\n#define drep(i,n) for(int i=(n)-1; i>=0; --i)\n#define foreach(it, v) for(typeof(v.begin()) it=v.begin(); it!=v.end(); ++it)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define fi first\n#define se second\n\ntypedef unsigned int uint;\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\ntypedef set<int> si;\n\n//MOD//\nconst ll MOD = 1000000007;\nstruct big;\nbig ex(big a, ll tms);\ntypedef struct big{\n  ll val;\n  big():val(0){}\n  big(ll val):val((val%MOD+MOD)%MOD){}\n  big& operator += (const big& obj){ (val+=obj.val)%=MOD; return *this;}\n  big& operator -= (const big& obj){ (val+=MOD-obj.val)%=MOD; return *this;}\n  big& operator *= (const big& obj){ (val*=obj.val)%=MOD; return *this;}\n  big& operator /= (const big& obj){ (val*=ex(obj,MOD-2).val)%=MOD; return *this;}\n  big operator + (const big& obj)const{ return big(*this) += obj;}\n  big operator - (const big& obj)const{ return big(*this) -= obj;}\n  big operator * (const big& obj)const{ return big(*this) *= obj;}\n  big operator / (const big& obj)const{ return big(*this) /= obj;}\n  bool operator < (const big& obj)const{ return val < obj.val;}\n  bool operator == (const big& obj)const{ return val == obj.val;}\n} big;\nistream& operator >> (istream& i, big& obj){ i>>obj.val; return i;}\nostream& operator << (ostream& o, const big& obj){ o<<obj.val; return o;}\nbig ex(big obj, ll tms){\n  if(!tms) return 1;\n  big ret = ex(obj, tms/2);\n  ret *= ret;\n  return (tms&1) ? ret*obj : ret;\n}\n//MOD//\n\nll pow(ll n, int m){\n  if(!m) return 1;\n  ll ret = pow(n, m/2);\n  ret *= ret;\n  return (m&1) ? ret*n : ret;\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n  stringstream ss;\n  ss << f;\n  ss >> t;\n}\n\nint N;\nll A, B;\n\nll ma[5010];\n\nint main(){\n  scanf(\"%d%lld%lld\",&N,&A,&B);\n  vi p(N);\n  rep (i, N) scanf(\"%d\", &p[i]);\n  rep (i, N) ma[i+1] = 999999999999999;\n  rep (i, N) {\n    int x = p[i];\n    ll mai = 999999999999999;\n    for (int j=0; j<x; ++j) {\n      mai = min(mai, ma[j]);\n      ma[j] = ma[j]+A;\n    }\n    for (int j=x+1; j<=N; ++j) ma[j] = ma[j]+B;\n    ma[x] = mai;\n  }\n  ll ans = 999999999999999;\n  rep (i, N+1) ans = min(ans, ma[i]);\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n#else\n#define dbg(...) {}\n#endif\n\nconst long INF = 1L<<60;\n\nlong dp[500005];\n\nint main(){\n  int n;\n  long a,b;\n  cin>>n>>a>>b;\n  vector<int> v(n);\n  rep(i,n) cin>>v[i];\n\n  fill(dp, dp+n+2, INF);\n  dp[0] = 0;\n\n  rep(i,n) rep(j,n+1) if(dp[j]< INF && j != v[i]){\n    if(j < v[i]){\n      dp[v[i]] = min(dp[v[i]], dp[j]);\n      dp[j] += a;\n    } else {\n      dp[j] += b;\n    }\n  }\n\n  long ans = INF;\n  rep(i,n+1) ans = min(ans, dp[i]);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int maxn = 5e3 + 5;\n\nint N, A, B, p[maxn];\nll f[maxn];\n\nsigned main(void)\n{\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  #ifdef LOCAL\n    freopen(\"A.INP\", \"r\", stdin);\n    freopen(\"A.OUT\", \"w\", stdout);\n  #endif // LOCAL\n  cin >> N >> A >> B;\n  for(int i = 1; i <= N; ++i)\n    cin >> p[i];\n  p[N + 1] = N + 1;\n  for(int i = 1; i <= N + 1; ++i){\n    int le = 0, ri = 0;\n    f[i] = 1e18;\n    for(int j = i - 1; j >= 0; --j){\n      if(p[j] < p[i]) f[i] = min(f[i], f[j] + 1ll * B * le + 1ll * A * ri);\n      le += p[j] < p[i], ri += p[j] > p[i];\n    }\n  }\n  cout << f[N + 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Binary Indexed Tree (BIT)\n// Verified: AOJ DSL_2_B: Range Sum Query (intのみ)\n\ntemplate <typename T>\nstruct BIT{\nprivate:\n    vector<T> array;\n    int n;\n\npublic:\n    // 初期化 (適当)\n    BIT() : array(11, 0), n(10) {}\n    BIT(int _n) : array(_n + 1, 0), n(_n) {}\n\n    // 他のクラスで BIT を呼び出すときに便利なので作った\n    void resize(int _n) {\n        array.resize(_n + 1);\n        n = _n;\n    }\n\n    // 1番目から i番目までの累積和を求める\n    T sum(int i) {\n        T s = 0;\n        while(i > 0) {\n            s += array[i];\n            i -= i & -i;      // LSB 減算\n        }\n        return s;\n    }\n\n    // [i, j] の要素の総和\n    T sum(int i, int j) {\n        T ret_i = sum(i-1);\n        T ret_j = sum(j);\n        return ret_j - ret_i;\n    }\n\n    // i 番目に 要素 x を追加\n    void add(int i, T x) {\n        while(i <= n) {\n            array[i] += x;\n            i += i & -i;      // LSB 加算\n        }\n    }\n};\n\nint dp[5010][2];\nsigned main() {\n    int N, A, B; cin >> N >> A >> B;\n    vector<int> p(N);\n    vector< pair<int, int> > info;\n\n    int midx = -1;\n    for(int i=0; i<N; i++) {\n        cin >> p[i];\n        if(p[i] == 1) midx = i;\n    }\n\n    vector<int> take(N, 1), mul(N, 1);\n    for(int i=1; i<N; i++) {\n        int cidx = (midx + i) % N;\n        int pidx = (cidx + N - 1) % N;\n        if(p[pidx] + 1 == p[cidx]) {\n            take[cidx] = false;\n            while(p[pidx] + 1 == p[cidx]) {\n                mul[pidx] = mul[cidx] + 1;\n                pidx = (pidx + N - 1) % N;\n                cidx = (cidx + N - 1) % N;\n            }\n        }\n    }\n\n    for(int i=0; i<N; i++) {\n        info.emplace_back(p[i], i+1);\n    }\n    sort(info.rbegin(), info.rend());\n\n    int ans = 0;\n    BIT<int> bit(N);\n    const int SHIFT_A = 1, SHIFT_B = 2, SHIFT_AB = 3;\n\n    fill(dp[0], dp[N+1], INF);\n    dp[0][0] = dp[0][1] = 0;\n    int M = info.size();\n    int pre_val = -1;\n    for(int i=0; i<M; i++) {\n        int val, idx; tie(val, idx) = info[i];\n        int sum = bit.sum(idx);\n        // 左、右\n        int costA = A*sum, costB = B;\n        \n        /*\n        int shift = -1;\n        if(costA < costB) shift = SHIFT_A;\n        else if(costA > costB) shift = SHIFT_B;\n        else shift = SHIFT_AB;\n\n        if((shift & pre_shift & SHIFT_B) == 0) {\n            ans += min(costA, costB);\n        }\n        */\n        bit.add(idx, 1);\n\n        // 左の場合は、転倒数？が同じ場合は節約できる (左シフトをまとめてやったと考える)\n        int valA = (pre_val == sum ? dp[i][0] : INF);\n        valA = min(valA, min(dp[i][0], dp[i][1]) + costA);\n        dp[i+1][0] = valA;\n        // 右の場合はいかなる場合に置いてもコストがかかる\n        dp[i+1][1] = min(dp[i][0], dp[i][1]) + costB;\n        // pre_shift = shift;\n        pre_val = sum;\n    }\n    ans = min(dp[N][0], dp[N][1]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//constexpr ll MOD=1e9+7;\n//\nconstexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        if(A<0) return B;\n        if(B<0) return A;\n        return std::min(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vector<vector<int>> dp;\n    vector<int> dist;\n    Tree(vector<vector<int>> edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,A,B; cin>>N>>A>>B;\n    vi P(N);\n    rep(i,0,N){\n        cin>>P[i];\n        P[i]--;\n    }\n    vii front(N,vi(N+1)),back(N,vi(N+1));\n    rep(i,0,N){\n        ll cnt=0;\n        rep(j,0,i){\n            if(P[j]>P[i]){\n                cnt++;\n                front[P[i]][N-P[j]]--;\n            }\n        }\n        front[P[i]][0]=cnt;\n        REP(j,1,N) front[P[i]][j]+=front[P[i]][j-1];\n        REP(j,0,N) front[P[i]][j]=std::min(B,A*front[P[i]][j]);\n        cnt=0;\n        rep(j,i+1,N){\n            if(P[j]<P[i]){\n                cnt++;\n                back[P[i]][P[j]+1]--;\n            }\n        }\n        back[P[i]][0]=cnt;\n        REP(j,1,N) back[P[i]][j]+=back[P[i]][j-1];\n        REP(j,0,N) back[P[i]][j]=std::min(A,B*back[P[i]][j]);\n    }\n    vii dp(N+1,vi(N+1,inf));\n    dp[0][0]=0;\n    REP(i,0,N){\n        REP(j,0,N){\n            if(i+j>=N) continue;\n            dp[i+1][j]=std::min(dp[i+1][j],dp[i][j]+front[i][j]);\n            dp[i][j+1]=std::min(dp[i][j+1],dp[i][j]+back[N-1-j][i]);\n        }\n    }\n    ll ans=inf;\n    REP(i,0,N){\n        ans=std::min(ans,dp[i][N-i]);\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll n,x,y,res=INF;\nvl a;\nvvl dp,L,R;\n\nvvl f(){\n\tvvl b(n,vl(n+1));\n\tfor(int i=0;i<n;i++){\n\t\tfor(auto j:a){\n\t\t\tif(j==i) break;\n\t\t\tb[i][j+1]++;\n\t\t}\n\t\tfor(int j=1;j<=n;j++) b[i][j]+=b[i][j-1];\n\t}\n\treverse(a.begin(),a.end());\n\treturn b;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n>>x>>y;\n\ta=vl(n);\n\tdp=vvl(n+1,vl(n+1,INF));\n\tfor(auto &i:a) cin>>i,i--;\n\tL=f(),R=f();\n\tdp[0][0]=0;\n\tfor(int r=0;r<n;r++){\n\t\tfor(int l=0;l<n-r;l++){\n\t\t\tll t=dp[l][r];\n\t\t\tdp[l+1][r]=min(dp[l+1][r],t+(L[l][n-r]-L[l][l]==0?0:y));\n\t\t\tdp[l][r+1]=min(dp[l][r+1],t+(R[n-r-1][n-r]-R[n-r-1][l]==0?0:x));\n\t\t}\n\t\tres=min(res,dp[n-r][r]);\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nll INF = 1000000000000000000;\nstruct segtree{\n  ll M=1, INIT;\n  vector<ll> dat;\n  segtree(ll N, ll num){\n    INIT = num;\n    while(M<N) M*=2;\n    for(int i=0;i<M*2-1;i++)  dat.push_back(num);\n  }\n  void update(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] += x;\n    while(k>0) k = (k-1)/2, dat[k] = dat[k*2+1] + dat[k*2+2];\n  }\n  ll query(ll a, ll b=-1, ll k=0, ll l=0, ll r=-1){\n    if(r==-1) r = M;\n    if(b==-1) b = M;\n    if(r<=a || b<=l) return INIT;\n    if(a<=l && r<=b) return dat[k];\n    ll A = query(a, b, k*2+1, l, (l+r)/2);\n    ll B = query(a, b, k*2+2, (l+r)/2, r);\n    return A + B;\n  }\n};\nint main(int argc, char const *argv[]) {\n  ll n, A, B;std::cin >> n >> B >> A;\n  vll p(n);re(i, n) scanf(\"%lld\", &p[i]);\n  vll comb(n+1), rcomb(n+1);\n\n  vll idx(n+1);\n  for(int i=0;i<n;i++) idx[p[i]] = i;\n  for(int i=0;i<n;i++){\n    ll cnt = 0;\n    for(int j=i;j<n;j++, cnt++) if(p[j]!=p[i]+cnt) break;\n    comb[p[i]] = cnt;\n    cnt = 0;\n    for(int j=i;j>=0;j--, cnt++) if(p[j]!=p[i]-cnt) break;\n    rcomb[p[i]] = cnt;\n  }\n  vll tento(n+1);\n  vll rtento(n+1);\n  segtree l(n+1, 0), r(n+1, 0);\n  for(int i=0;i<n;i++){\n    ll q = l.query(p[i], n+1);\n    tento[p[i]] = q;\n    l.update(1, p[i]);\n  }\n  for(int i=n-1;i>=0;i--){\n    ll q = r.query(0, p[i]);\n    rtento[p[i]] = q;\n    r.update(1, p[i]);\n  }\n  vvl dp = VV(n+5000, n+5000, INF, ll);\n  dp[0][0] = 0;\n\n  for(int i=0;i<n-1;i++){\n    for(int j=0;j<=i;j++){\n      if(dp[i][j]==INF) continue;\n      ll x = comb[j+1], y = comb[n-(i-j)];\n      //左詰め\n      dp[i+x][j+x] = min({dp[i+x][j+x],\n        dp[i][j]+A*comb[j+1], dp[i][j]+B*tento[j+1]});\n      //右詰め\n      dp[i+y][j] = min({dp[i+y][j],\n        dp[i][j]+B*comb[n-(i-j)], dp[i][j]+A*rtento[n-(i-j)]});\n    }\n  }\n  ll ans = 1000000000000000000;\n  //for(int i=0;i<=n;i++) ans = min(ans, dp[n][i]);\n  for(int i=n-1;i<n+5000;i++){\n    for(int j=0;j<=i;j++) ans = min(ans, dp[i][j]);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//constexpr long long MOD = 1000000007;\nconstexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nll dp[5050][5050];\npii mael[5050][5050],maer[5050][5050];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll N,A,B; cin >> N >> A >> B;\n    vector<int> p(N);\n    rep(i,N) {\n        cin >> p[i];\n        --p[i];\n    }\n\n    rep(i,N) {\n        int l = p[i];\n        int r = 0;\n        int cnt = 1;\n        rep(j,i) {\n            if (p[j] > p[i]) {\n                mael[p[i]][N-1-p[j]].second = 1;\n            }\n        }\n        for (int j = i+1; j < N; j++) {\n            if (p[j] < p[i]) continue;\n            if (p[j] > l+1) {\n                for (int k = r; k < N-p[j]; k++) {\n                    mael[p[i]][k].first = cnt;\n                }\n                chmax(r,N-p[j]);\n            } else {\n                l++;\n                cnt++;\n            }\n        }\n        for (int k = r; k < N-l; k++) {\n            mael[p[i]][k].first = cnt;\n        }\n        for (int j = N-1; j > 0; j--) {\n            mael[p[i]][j-1].second += mael[p[i]][j].second;\n        }\n    }\n\n    for (int i = N-1; i >= 0; i--) {\n        int r = p[i];\n        int l = 0;\n        int cnt = 1;\n        for (int j = N-1; j > i; j--) {\n            if (p[j] < p[i]) {\n                maer[p[j]][N-1-p[i]].second = 1;\n            }\n        }\n        for (int j = i-1; j >= 0; j--) {\n            if (p[j] > p[i]) continue;\n            if (p[j] < r-1) {\n                for (int k = l; k <= p[j]; k++) {\n                    maer[k][N-1-p[i]].first = cnt;\n                }\n                chmax(l,p[j]+1);\n            } else {\n                r--;\n                cnt++;\n            }\n        }\n\n        for (int k = l; k < p[i]; k++) {\n            maer[k][N-1-p[i]].first = cnt;\n        }\n        for (int j = N-1; j > 0; j--) {\n            maer[j-1][N-1-p[i]].second += maer[j][N-1-p[i]].second;\n        }\n\n    }\n\n    rep(i,N+1) rep(j,N+1) dp[i][j] = 1e18;\n    dp[0][0] = 0;\n    rep(k,N) {\n        for (int l = 0; l <= k; l++) {\n            if (dp[l][k-l]==1e18) continue;\n            auto [dl,cl] = mael[l][k-l];\n            chmin(dp[l+dl][k-l],dp[l][k-l]+A*cl);\n            chmin(dp[l+1][k-l],dp[l][k-l]+B);\n            auto[dr,cr] = maer[l][k-l];\n            chmin(dp[l][k-l+dr],dp[l][k-l]+B*cr);\n            chmin(dp[l][k-l+1],dp[l][k-l]+A);\n        }\n    }\n\n    ll ans = 1e18;\n    rep(i,N+1) {\n        chmin(ans,dp[i][N-i]);\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nconstexpr int N = 5009;\n\nll n, a, b, p[N], dp[N];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> a >> b;\n    rep(i, n) cin >> p[i];\n    fill(ALL(dp), inf);\n    dp[0] = 0;\n    rep(i, n) {\n        ll x = *min_element(dp, dp + p[i]);\n        dp[p[i]] = x;\n        rep(j, p[i]) dp[j] += a;\n        FOR(j, p[i] + 1, n + 1) dp[j] += b;\n    }\n    cout << *min_element(dp, dp + n + 1) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n\nconst int MAX_N = 5000 + 7;\n\nint n;\nint A[MAX_N];\nint lmin[MAX_N], rmax[MAX_N];\nll l, r;\nll dp[MAX_N][MAX_N];\n\n\nint main() {\n    scanf(\"%d%lld%lld\", &n, &r, &l);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &A[i]);\n    lmin[A[1]] = 87878787;\n    for (int i = 2; i <= n; i++)\n        lmin[A[i]] = min(lmin[A[i - 1]], A[i - 1]);\n    rmax[A[n]] = -1;\n    for (int i = n - 1; i >= 0; i--)\n        rmax[A[i]] = max(rmax[A[i + 1]], A[i + 1]);\n\n    /*for (int i = 1; i <= n; i++)\n        printf(\"%d \", lmin[i]);\n    printf(\"\\n\");\n    for (int i = 1; i <= n; i++)\n        printf(\"%d \", rmax[i]);\n    printf(\"\\n\");*/\n\n    for (int i = 0; i <= n; i++)\n        dp[i][n - i] = 0;\n    for (int sum = n - 1; sum >= 0; sum--)\n        for (int i = 0; i <= sum; i++) {\n            int j = sum - i;\n            dp[i][j] = l + dp[i + 1][j];\n            if (lmin[i + 1] >= n - j + 1)\n                dp[i][j] = min(dp[i][j], dp[i + 1][j]);\n            dp[i][j] = min(dp[i][j], r + dp[i][j + 1]);\n            if (rmax[n - j] <= i)\n                dp[i][j] = min(dp[i][j], dp[i][j + 1]);\n            //printf(\"!!!!!%d %d: %lld\\n\", i, j, dp[i][j]);\n        }\n    printf(\"%lld\\n\", dp[0][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst long long INF=4557430888798830399;\nint n,A,B;\nint a[5001];\nlong long dp[5001][5001];\nlong long ans=INF;\nint main()\n{\n    memset(dp,63,sizeof(dp));\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n        \tif(a[i]>j) dp[i][j]=min(dp[i][j],dp[i-1][j]+A),dp[i][a[i]]=min(dp[i][a[i]],dp[i-1][j]);\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n\tfor(int i=0;i<=n;i++)\n\t\tans=min(ans,dp[n][i]);\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL N=5010;\nLL n, a, b, p[N], id[N], dp[N][N], s[N][N];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\tfor(LL i=1; i<=n; ++i)scanf(\"%lld\",&p[i]), id[p[i]]=i;\n\tmemset(s,0x3f,sizeof(s));\n\tfor(LL i=0; i<=n; ++i)s[0][i]=0;\n\tfor(LL i=1; i<=n; ++i)\n\t\tfor(LL j=0; j<=n; ++j){\n\t\t\tdp[i][j]=s[i-1][j]+(j>=id[i]?a:b);\n\t\t\tif(j==id[i])dp[i][j]=min(dp[i][j],s[i-1][j-1]);\n\t\t\tif(j>0)s[i][j]=min(s[i][j-1],dp[i][j]);else s[i][j]=dp[i][j];\n\t\t}\n\tLL mn=0x3f3f3f3f3f3f3f3f;\n\tfor(LL i=1; i<=n; ++i)mn=min(mn,dp[n][i]);\n\tprintf(\"%lld\",mn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1LL<<60\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a,b;\nint p[5005];\nll dp[5005][5005];\nbool chl[5005][5005];\nbool chr[5005][5005];\nint cntr[5005];\nint cntl[5005];\nbool used[5005];\n\nint main(void){\n    scanf(\"%d%lld%lld\",&n,&a,&b);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&p[i]);\n        p[i]--;\n    }\n    memset(used,false,sizeof(used));\n    for(int i=0;i<n;i++){\n        used[p[i]]=true;\n        for(int j=0;j<p[i];j++){\n            if(!used[j]){\n                cntl[j]++;\n                chl[j][p[i]]=true;\n            }\n        }\n    }\n    memset(used,false,sizeof(used));\n    for(int i=n-1;i>=0;i--){\n        used[p[i]]=true;\n        for(int j=p[i];j<n;j++){\n            if(!used[j]){\n                cntr[j]++;\n                chr[j][p[i]]=true;\n            }\n        }\n    }\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            dp[i][j]=INF;\n        }\n    }\n    dp[0][n]=0;\n    for(int i=0;i<n;i++){\n        for(int j=n;j>i;j--){\n            int lv=i;\n            if(cntl[lv]==0){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n            }else if(cntl[lv]==1){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+min(a,b));\n            }else{\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n            }\n            if(chl[lv][j-1]){\n                cntl[lv]--;\n            }\n            int rv=j-1;\n            if(cntr[rv]==0){\n                dp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n            }else if(cntr[rv]==1){\n                dp[i][j-1]=min(dp[i][j-1],dp[i][j]+min(a,b));\n            }else{\n                dp[i][j-1]=min(dp[i][j-1],dp[i][j]+a);\n            }\n            //printf(\"%d %d %d %d %lld\\n\",i,j,cntl[lv],cntr[rv],dp[i][j]);\n\n        }\n        for(int j=0;j<n;j++){\n            if(chr[j][i]){\n                cntr[j]--;\n            }\n        }\n    }\n    ll ans=INF;\n    for(int i=0;i<n;i++){\n        ans=min(ans,dp[i][i]);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 5050;\nlong long f[2 * maxn], nf[2 * maxn];\nint p[maxn];\nint main(){\n\tint n, A, B; scanf(\"%d %d %d\", &n, &A, &B);\n\tfor(int i = 1; i <= n; i++){\n\t\tint x; scanf(\"%d\", &x);\n\t\tp[x] = 2 * i;\n\t}\n\tint l = 2 * n + 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tlong long mi = f[1];\n\t\tf[1] += B;\n\t\tfor(int j = 2; j <= l; j++){\n\t\t\tlong long nmi = min(mi, f[j]);\n\t\t\tlong long cost = (p[i] < j) * A + (p[i] > j) * B;\n\t\t\tf[j] = mi + cost;\n\t\t\tmi = nmi;\n\t\t}\n\t}\n\tlong long ans = 1ll<<62;\n\tfor(int j = 1; j <= l; j++) ans = min(ans, f[j]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long ll;\n\nll gcd(ll x, ll y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y) {\n\treturn x / gcd(x, y)*y;\n}\nll kai(ll x, ll y, ll m) {\n\tll res = 1;\n\tfor (ll i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nll mod_pow(ll x, ll y, ll m) {\n\tll res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll comb(ll x, ll y, ll m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nconst ll INF = 1000000000000000000;\n\nint n, a, b, p[5010], x[5010];\nint cum[5010][5010];\nll d[5010][5010];\nll ans = INF;\n\nsigned main() {\n\tstd::random_device rnd;\n\tstd::mt19937_64 mt(rnd());\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; i++)cin >> p[i], x[p[i]] = i;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\tif (i < p[j])cum[i][j] = cum[i][j - 1] + 1;\n\t\telse cum[i][j] = cum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= n; i++)for (int j = 1; j <= i; j++)d[i][j] = INF;\n\td[1][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tll k = d[i][j];\n\t\t\tif (x[i + 1] < x[j])k += a;\n\t\t\tif (x[j] + 1 < x[i + 1])k += min((ll)b, (ll)a*(cum[i + 1][x[i + 1]] - cum[i + 1][x[j]]));\n\t\t\td[i + 1][j] = min(d[i + 1][j], k);\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tif (x[j] + 1 == x[i + 1])d[i + 1][i + 1] = d[i][j];\n\t\t\tif (x[j] < x[i + 1])cnt++;\n\t\t}\n\t\td[i + 1][i + 1] = min(d[i + 1][i + 1], (ll)cnt*a + (ll)(i - cnt)*b);\n\t}\n\tfor (int i = 1; i <= n; i++)ans = min(ans, d[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint T, n, a, b;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> a >> b){\n        vector<ll> dp(n + 1, 1ll << 60);\n        dp[0] = 0;\n        REP(i, n) {\n            int x;\n            cin >> x;\n            vector<ll> nxt(n + 1, 1ll << 60);\n            REP(j, n + 1) {\n                if (j < x) {\n                    chmin(nxt[j], dp[j] + a);\n                    chmin(nxt[x], dp[j]);\n                } else {\n                    chmin(nxt[j], dp[j] + b);\n                }\n            }\n            swap(dp, nxt);\n        }\n        cout << *min_element(ALL(dp)) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int maxN = 5000 + 5;\nconst LL maxA = 1000000000 + 233;\nint n, p[maxN];\nLL A, B;\nLL f[maxN];\n\nint main() {\n\tcin >> n >> A >> B;\n\tp[0] = 0; p[n + 1] = n + 1;\n\tfor(int i = 1; i <= n; ++i) cin >> p[i];\n\tf[0] = 0;\n\tfor(int i = 1; i <= n + 1; ++i) {\n\t\tint mx = -1;\n\t\tint bigger = 0, smaller = 0;\n\t\tf[i] = maxN * maxA;\n\t\tfor(int j = i - 1; j >= 0; --j) {\n\t\t\tif(p[j] > p[i]) {\n\t\t\t\tbigger ++;\n\t\t\t} else {\n\t\t\t\tif(p[j] > mx) {\n\t\t\t\t\tmx = p[j];\n\t\t\t\t\tf[i] = min(f[i], f[j] + bigger * A + smaller * B);\n\t\t\t\t}\n\t\t\t\tsmaller ++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << f[n + 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//copy from https://atcoder.jp/contests/agc037/submissions/7059910\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn=5005;\nint dp[maxn][maxn],a[maxn];\nint n,A,B,ans;\nint main(){\n\tn = read(),A = read(),B = read();\n\tans = 1ll << 30;\n\tRep(i,1,n) a[i] = read();\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0] = 0;\n\tRep(i,1,n)Rep(j,0,n){\n\t\tif(a[i] > j)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j] + A),\n\t\t\tdp[i][a[i]]=min(dp[i][a[i]],dp[i-1][j]);\n\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n\t}\n\tRep(i,0,n) ans=min(ans,dp[n][i]);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\n#include \"bits/stdc++.h\"\n\nstruct RARS {\n\tstruct t1 {\n\t\tlong long val, size;\n\t\tconstexpr t1(long long v, long long s) :val(v), size(s) {}\n\t};\n\tusing t2 = long long;\n\tstatic constexpr t1 id1() {\n\t\treturn t1(0, 0);\n\t}\n\tstatic constexpr t2 id2() {\n\t\treturn 0ll;\n\t}\n\tstatic t1 op1(const t1 &a, const t1 &b) {\n\t\treturn t1(a.val + b.val, a.size + b.size);\n\t}\n\tstatic t1 op2(const t1 &a, const t2 &b) {\n\t\treturn t1(a.val + b * a.size, a.size);\n\t}\n\tstatic t2 op3(const t2 &a, const t2 &b) {\n\t\treturn a + b;\n\t}\n};\n\nstruct RARm {\n\tusing t1 = long long;\n\tusing t2 = long long;\n\tstatic constexpr t1 id1() {\n\t\treturn std::numeric_limits<t1> ::max() / 2;\n\t}\n\tstatic constexpr t2 id2() {\n\t\treturn 0ll;\n\t}\n\tstatic t1 op1(const t1 &a, const t1 &b) {\n\t\treturn std::min(a, b);\n\t}\n\tstatic t1 op2(const t1 &a, const t2 &b) {\n\t\treturn a + b;\n\t}\n\tstatic t2 op3(const t2 &a, const t2 &b) {\n\t\treturn a + b;\n\t}\n};\n\nstruct RARM {\n\tusing t1 = long long;\n\tusing t2 = long long;\n\tstatic constexpr t1 id1() {\n\t\treturn std::numeric_limits<t1> ::min() / 2;\n\t}\n\tstatic constexpr t2 id2() {\n\t\treturn 0ll;\n\t}\n\tstatic t1 op1(const t1 &a, const t1 &b) {\n\t\treturn std::max(a, b);\n\t}\n\tstatic t1 op2(const t1 &a, const t2 &b) {\n\t\treturn a + b;\n\t}\n\tstatic t2 op3(const t2 &a, const t2 &b) {\n\t\treturn a + b;\n\t}\n};\ntemplate<typename M>\nstruct LazySegmentTree {\n\n\tint n;\n\tusing T1 = typename M::t1;\n\tusing T2 = typename M::t2;\n\tstd::vector<T1> nodes;\n\tstd::vector<T2> lazy;\n\n\tLazySegmentTree(std::vector<T1> v) {\n\t\tint sz = (int)v.size();\n\t\tn = 1; while (n < sz) n *= 2;\n\t\tnodes.resize(2 * n - 1, M::id1());\n\t\tlazy.resize(2 * n - 1, M::id2());\n\n\t\tfor (int i = 0; i < sz; i++) nodes[i + n - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--) nodes[i] = M::op1(nodes[i * 2 + 1], nodes[i * 2 + 2]);\n\t}\n\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazy[k] != M::id2()) {\n\t\t\tnodes[k] = M::op2(nodes[k], lazy[k]);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[2 * k + 1] = M::op3(lazy[2 * k + 1], lazy[k]);\n\t\t\t\tlazy[2 * k + 2] = M::op3(lazy[2 * k + 2], lazy[k]);\n\t\t\t}\n\t\t\tlazy[k] = M::id2();\n\t\t}\n\t}\n\tvoid update(int a, int b, T2 x) {\n\t\tupdate(a, b, x, 0, 0, n);\n\t}\n\tvoid update(int pos, T1 x) {\n\t\tint k = pos + n - 1;\n\t\tvi v;\n\t\twhile (k >= 0) {\n\t\t\tk /= 2;\n\t\t\tv.push_back(k);\n\t\t\tif (k == 0)break;\n\t\t}\n\t\tRREP(i, v.size())eval(v[i], 0, 2);\n\t\tlazy[pos + n - 1] = M::id2();\n\t\tnodes[pos + n - 1] = x;\n\t}\n\tT1 query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\nprivate:\n\tvoid update(int a, int b, T2 x, int k, int l, int r) {\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = M::op3(lazy[k], x);\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnodes[k] = M::op1(nodes[2 * k + 1], nodes[2 * k + 2]);\n\t\t}\n\t}\n\n\tT1 query(int a, int b, int k, int l, int r) {\n\t\tif (b <= l || r <= a)return M::id1();\n\t\teval(k, l, r);\n\t\tif (a <= l && r <= b)return nodes[k];\n\t\treturn M::op1(query(a, b, 2 * k + 1, l, (l + r) / 2), query(a, b, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tvi v(n);\n\tREP(i, n) {\n\t\tcin >> v[i];\n\t}\n\tvl init(n + 1, INF*INF);\n\tinit[0] = 0;\n\tLazySegmentTree<RARm> seg(init);\n\n\tREP(i, n) {\n\t\tll m = seg.query(0, v[i]);\n\t\tseg.update(v[i], m);\n\t\tseg.update(0, v[i], a);\n\t\tseg.update(v[i] + 1, n + 1, b);\n\t}\n\tcout << seg.query(0, n + 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\n// pythonのrangeのような範囲for文用のclass for(const auto& i : Range<>(10)) のように書く\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\n// lambda式を用いた再帰\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\n// 多次元vectorの一斉初期化 makeVector<i64, 0>(a, b, ...)のように書く\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\n// 最大値を更新し、更新できた時にはtrueを返す\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// 同様に最小値を更新する\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// 行数と変数名、値をclogに表示するデバッグ用print\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n// 同様の配列向けデバッグ用print\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\n// input用の関数群\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    i64 n, x, y;\n    input(n, x, y);\n    vector<i64> a(n);\n    input(a);\n    for(auto& x : a)\n        --x;\n    list<i64> s;\n    for(const auto& i : Range<>(n))\n        s.push_back(a[i]);\n    i64 ind = 0;\n    i64 sum = 0;\n    // [0, ind) is sorted\n    while(ind != n){\n        if(*s.begin() == ind){\n            s.erase(s.begin());\n            ++ind;\n            continue;\n        }\n        auto it = s.begin();\n        for(; *it != ind; ++it);\n        auto it2 = next(it);\n        i64 nex = ind + 1;\n        while(it2 != s.end() && *it2 == nex){\n            ++nex;\n            ++it2;\n        }\n        // ここ線形\n        // dist回だけ前に移動する\n        i64 dist = distance(s.begin(), it);\n        // その後、length回だけ回転させる\n        i64 length = distance(s.begin(), it2) - dist;\n        i64 cost_a = dist * x;\n        i64 cost_b = length * y;\n        sum += min(cost_a, cost_b);\n        for(i64 i = 0; i < length; ++i)\n            it = s.erase(it);\n        ind += length;\n    }\n\n    cout << sum << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<P, ll> T;\n \nlong long int INF = 2e18;\nconst ll fact_table = 1200008;\ndouble Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//↓,→,↑,←\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n    #undef endl\n#endif\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n#define pc(x) cout << x << \",\";\n \nconst ll mod = 998244353ll;\n// const ll mod = 1000000007ll;\n  \nll mypow(ll number1,ll number2, ll mod){\n    if(number2 == 0){\n        return 1ll;\n    }else{\n        ll number3 = mypow(number1,number2 / 2, mod);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n\nll fact[fact_table + 5],rfact[fact_table + 5]; \n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table],mod - 2, mod);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n\nbool multicase = false;\n\nll n,m,num,a,b,c,d,e,h,q;\nll w, k;\nll dp[5015];\nll x[5005];\nll table[5015][5015];\n\nll cost(ll lidx, ll ridx, ll lvalue, ll rvalue){\n\n    ll large = table[ridx - 1][rvalue] - table[lidx][rvalue];\n    ll small = ridx - lidx - 1 - (table[ridx - 1][lvalue] - table[lidx][lvalue]);\n    ll middle = ridx - lidx - 1 - large - small;\n\n    ll tmp = 0;\n    if(middle >= 2){\n        tmp = min(a, b) * (middle - 1);\n    }\n    return a * large + b * small + tmp;\n}\n\nvoid solve(){\n    cin >> n >> a >> b;\n    for(ll i=1;i<=n;i++){\n        cin >> x[i];\n    }\n    for(ll i=1;i<=n;i++){\n        for(ll j=0;j<=n;j++){\n            if(x[i] >= j){\n                table[i][j] = table[i-1][j] + 1;\n            }else{\n                table[i][j] = table[i-1][j];\n            }\n        }\n    }\n\n    for(ll i=1;i<=5000;i++){\n        dp[i] = INF;\n    }\n\n    dp[0] = 0;\n    for(ll i=1;i<=n;i++){\n        for(ll j=0;j<i;j++){\n            if(x[j] < x[i]){\n                dp[i] = min(dp[i], dp[j] + cost(j, i, x[j], x[i]));\n                if(i == n && dp[i] == 40)p(j);\n            }\n        }\n    }\n    ll ans = INF;\n    for(ll i=1;i<=n;i++){\n        ll large = n - i;\n        ll res = large * b + dp[i];\n        ans = min(ans, res);\n    }\n    p(ans);\n    return;\n}\n\n\nint main(){\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll q, testcase = 1;\n    if(multicase){\n        cin >> q;\n    }else{\n        q = 1; \n    }\n    while(q--){\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n    // solve();\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MaxN = 5e3 + 5;\n\nint n, A, B;\nint pos[MaxN], a[MaxN];\nlong long f[MaxN][MaxN];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> a[i];\n        pos[a[i]] = i;\n    }\n    memset(f, 100, sizeof(f));\n    f[1][0] = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        for (int j = 0; j < i; ++j)\n        {\n            if (pos[i] > pos[j])\n            {\n                f[i + 1][j] = min(f[i + 1][j], f[i][j] + B);\n                f[i + 1][i] = min(f[i][j], f[i + 1][i]);\n            }\n            else\n            {\n                f[i + 1][j] = min(f[i + 1][j], f[i][j] + A);\n            }\n        }\n    }\n    long long res = *min_element(f[n + 1], f[n + 1] + n + 1);\n    cout << res;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, p[5005], A, B, dp[5005][5005];\nll pos[5005];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; ++i){\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 1; i <= N; ++i){\n\t\tpos[p[i]] = i;\n\t} \n\tfor (int i = 1; i <= N+1; ++i){\n\t\tif (i < pos[1]) dp[1][i] = B;\n\t\telse if (i > pos[1]) dp[1][i] = A;\n\t\telse dp[1][i] = 0;\n\t} \n\tfor (int i = 2; i <= N; ++i){\n\t\tdeque<pair<ll,int> > f;\n\t\tfor (int j = 1; j <= N+1; ++j){\n\t\t\twhile (!f.empty() && f.back().first > dp[i-1][j]){\n\t\t\t\tf.pop_back();\n\t\t\t}\n\t\t\tf.push_back(make_pair(dp[i-1][j],j));\n\t\t\tif (j == pos[i]) dp[i][j] = dp[i-1][j];\n\t\t\telse dp[i][j] = 1e16;\n\t\t\tif (!f.empty()){\n\t\t\t\tif (j > pos[i]) dp[i][j] = min(dp[i][j],A+f.front().first);\n\t\t\t\telse if (j < pos[i]) dp[i][j] = min(dp[i][j],B+f.front().first);\n\t\t\t\telse dp[i][j] = min(dp[i][j],f.front().first);\n\t\t\t}\n\t\t\t\n\t\t}\n\t} \n\tfor (int i = 1; i <= N; ++i){\n\t\tfor (int j = 1; j <= N+1; ++j){\n\t\t\t//cout << dp[i][j] << ' ';\n\t\t}\n\t\t//cout << '\\n';\n\t} \n\tll M = 1e16;\n\tfor (int i = 1; i <= N+1; ++i){\n\t\tM = min(M,dp[N][i]);\n\t}\n\tcout << M << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, A, B;\nvector<ll> p;\nvector<ll> inv;\nll mini[5001][5001], maxi[5001][5001];\nll dp[5001][5001];\nvector<ll> lovermini, rundermaxi;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> A >> B;\n    p.resize(N);\n    inv.resize(N);\n    lovermini.resize(N);\n    rundermaxi.resize(N);\n    for(int i = 0; i < N; i++) {\n        cin >> p[i];\n        p[i]--;\n        inv[p[i]] = i;\n    }\n    for(int i = 0; i < N; i++) {\n        lovermini[i] = 1e9;\n        rundermaxi[i] = -1e9;\n        for(int j = 0; j < i; j++) {\n            if(p[j] > p[i]) chmin(lovermini[i], p[j]);\n        }\n        for(int j = i + 1; j < N; j++) {\n            if(p[j] < p[i]) chmax(rundermaxi[i], p[j]);\n        }\n    }\n    for(int delta = 2; delta <= N; delta++) {\n        for(int l = 0; l + delta <= N; l++) {\n            dp[l][l+delta] = 1e18;\n            if(lovermini[inv[l]] <= l + delta - 1) {\n                chmin(dp[l][l+delta], dp[l+1][l+delta] + B);\n            } else {\n                chmin(dp[l][l+delta], dp[l+1][l+delta]);\n            }\n            if(rundermaxi[inv[l+delta-1]] >= l) {\n                chmin(dp[l][l+delta], dp[l][l+delta-1] + A);\n            } else {\n                chmin(dp[l][l+delta], dp[l][l+delta-1]);\n            }\n        }\n    }\n    cout << dp[0][N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::min;\nusing std::max;\nconst int N=5005;\nlong long dp[N][N];\nint n,x,y,a[N],m,f[N],f2[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<i;j++)\n\t\t\tif (a[j]>a[i]) f[a[i]]=min(f[a[i]],a[j]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (a[j]<a[i]) f2[a[i]]=max(a[j],f2[a[i]]);\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][n+1]=0;\n\tfor (int l=0;l<n;l++)\n\t\tfor (int i=0;i<=l;i++)\n\t\t{\n\t\t\tint j=n-(l-i)+1;\n\t\t\tif (f[i+1]>=j) dp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\telse dp[i+1][j]=min(dp[i+1][j],dp[i][j]+y);\n\t\t\tif (f2[j-1]<=i) dp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\telse dp[i][j-1]=min(dp[i][j-1],dp[i][j]+x);\n\t\t} \n\tlong long ans=1ll*x*n;\n\tfor (int i=0;i<=n;i++)\n\t\tans=min(dp[i][i+1],ans);\n\tprintf(\"%lld\\n\",ans);\t\t \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=5e3+10;\nint D[N];\nint n,A,B;\nll sol(int idx)\n{\n\tif(idx>=n-1)return 0;\n\tint j=idx;\n\tfor(int i=idx+1;i<n;i++){\n\t\tif(D[i]<D[j])j=i;\n\t}\n\tll res=sol(j+1)+1LL*(j-idx)*A;\n\tint u=D[j];\n\tfor(int i=j;i>idx;i--)D[i]=D[i-1];\n\tres=min(res,sol(idx+1)+B);\n\tfor(int i=idx;i<j;i++)D[i]=D[i+1];\n\tD[j]=u;\n\treturn res;\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"/home/zz7/CFInput\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tll ans=0;\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&D[i]);\n\tcout<<sol(0)<<'\\n';\n\t/*\n\tfor(int i=0;i<n;i++){\n\t\tint j=0;\n\t\tfor(;j<i;j++)if(D[j]>D[i])break;\n\t\tif(j!=i)ans+=min(1LL*A*(i-j),1LL*B);\n\t\tint u=D[i];\n\t\tfor(int k=i;k>j;k--)D[k]=D[k-1];\n\t\tD[j]=u;\n\t}cout<<ans<<'\\n';*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define FORqr(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int (x); SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long (x); SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\n#define M0(x) memset(x,0,sizeof(x))\n#define FILL(x,y) memset(x,y,sizeof(x))\n#define MM(x) memset(x,-1,sizeof(x))\n#define ALL(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef pair<long long,long long> PLL;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n///////////////////////////////////////////////\nconst ll MOD = 1000000007;\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////\n\n/*（๑•﹏•๑｀) */\n\n\nint main() {\n    static ll a[5002] = {};\n    int N;\n    ll A;\n    ll B;\n    ll ans = 0;\n    static bool move[5002] = {};\n\n    cin >> N >> A >> B;\n    FORq(i,1,N){\n        cin >> a[i];\n    }\n\n\n    FORq(target,1,N){\n        int index;\n\n        FORq(i,1,N){\n            if (a[i] == target){\n                index = i;\n                break;\n            }\n        }\n\n        int lcount = 0;\n        FORq(i,1,index-1){\n            if ((a[i] > target) and (!move[i])) lcount++;\n        }\n\n        ll nans = min(B,lcount * A);\n        if (lcount * A <= B){\n            FORq(i,1,index-1){\n                if (a[i] > target) move[i] = true;\n            }\n        }\n\n        ans = nans + ans;\n    }\n\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define mo 1000000007\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,a,b,i,j,p[5005],f[5005][5005],g[5005][5005];\nlong long minn(long long u,long long v){\n\treturn u<v?u:v;\n}\nint main(){\n\t//freopen(\"buinss.in\",\"r\",stdin);\n\t//freopen(\"buinss.out\",\"w\",stdout);\n\tn=read();a=read();b=read();\n\tfor(i=1;i<=n;i++)\n\t\tp[read()]=i;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(p[i]==j)\n\t\t\t\tf[i][j]=g[i-1][j];\n\t\t\tif(p[i]<j)\n\t\t\t\tf[i][j]=g[i-1][j]+a;\n\t\t\tif(p[i]>j)\n\t\t\t\tf[i][j]=g[i-1][j]+b;\n\t\t\tif(j==0)\n\t\t\t\tg[i][j]=f[i][j];\n\t\t\telse\n\t\t\t\tg[i][j]=minn(g[i][j-1],f[i][j]);\n\t\t}\n\tpus(g[n][n],2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst ll MAX_N = 5e3 + 15, inf = 1000000LL * 1000000LL * 1000000LL;\nll n, L, R, ans = inf, ind = 0;\nll index[MAX_N];\nll Arr[MAX_N];\nll cntl[MAX_N][MAX_N];\nll cntb[MAX_N][MAX_N];\n\nll dp[MAX_N];\nset <pii> Set, Set2;\n\nvoid processMin() {\n\tfor (ll i = 0; i < n; i++) {\n\t\tll l = 0, b = 0;\n\t\tfor (ll j = i - 1; 0 <= j; j--) {\n\t\t\tl += (Arr[j] < Arr[i]);\n\t\t\tb += (Arr[j] > Arr[i]);\n\t\t\t\n\t\t\tcntl[i][j] = l;\n\t\t\tcntb[i][j] = b;\n\t\t}\n\t}\n\t\n\tfor (ll i = 0; i < n; i++) {\n\t\tll l = 0, b = 0;\n\t\tfor (ll j = i + 1; j < n; j++) {\n\t\t\tl += (Arr[j] < Arr[i]);\n\t\t\tb += (Arr[j] > Arr[i]);\n\t\t\t\n\t\t\tcntl[i][j] = l;\n\t\t\tcntb[i][j] = b;\n\t\t}\n\t}\n}\n\nint main() {\n//\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> L >> R;\n\tswap(L, R);\n\t\n\tfor (ll i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\t\n\t\tindex[Arr[i]] = i;\n\t}\n\t\n\tprocessMin();\n\t\n\tind = Arr[0];\n\tfor (ll i = 1; i < n; i++) {\n\t\tif (ind > Arr[i]) {\n\t\t\tdp[i] = cntb[i][0] * R;\n\t\t\tind = Arr[i];\n\t\t}\n\t\telse\n\t\t\tdp[i] = inf;\n\t\t\t\n\t\tint Max = -1;\n\t\tfor (ll j = i - 1; ~j; j--)\n\t\t\tif (Arr[j] < Arr[i] && Arr[j] > Max) {\n\t\t\t\tll l = min(cntl[j][i - 1], cntl[i][j + 1]);\n\t\t\t\tll b = min(cntb[j][i - 1], cntb[i][j + 1]);\n\t\t\t\t\n\t\t\t\tdp[i] = min(dp[i], dp[j] + l * L + b * R);\n\t\t\t\tMax = Arr[j];\n\t\t\t}\n\t}\n\t\n\tind = -1;\n\tfor (ll i = n - 1; ~i; i--) {\n\t\tif (Arr[i] > ind) {\n\t\t\tans = min(ans, dp[i] + cntl[i][n - 1] * L);\n\t\t\tind = Arr[i];\n\t\t}\n\t}\n\t\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Take me to church\n    I'll worship like a dog at the shrine of your lies\n    I'll tell you my sins and you can sharpen your knife\n    Offer me that deathless death\n    Good God, let me give you my life\n*/\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 5005;\nint n, L, R, A[N];\nlong long dp[N];\nint main()\n{\n    scanf(\"%d%d%d\", &n, &R, &L);\n    for (int i = 1; i <= n; i ++)\n        scanf(\"%d\", &A[i]);\n    n ++; A[n] = n;\n    for (int i = 1; i <= n; i ++)\n    {\n        int cnt = 0;\n        dp[i] = LLONG_MAX;\n        for (int j = i - 1; ~ j; j --)\n            if (A[j] < A[i])\n                dp[i] = min(dp[i], dp[j] + cnt * 1LL * L + (i - j - 1 - cnt) * 1LL * R), cnt ++;\n    }\n    return !printf(\"%lld\\n\", dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=5050,OO=1e18;\nint dp[N][N];\nint a[N],w[N];\nint32_t main(){\n\n\tint n,A,B;\n\tcin>>n>>A>>B;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tw[a[i]]=i;\n\t}\n\tfor(int i=0;i<=n+1;++i)for(int j=0;j<=n+1;++j)dp[i][j]=OO;\n\tdp[0][0]=0;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=0;j<=n;++j)\n\t\t{\n\t\t\tif(w[j+1]<=i)upn(dp[i][j+1],dp[i][j]);\n\t\t\telse upn(dp[i][j+1],dp[i][j]+B);\n\t\t\tif(a[i+1]<=j)upn(dp[i+1][j],dp[i][j]);\n\t\t\telse upn(dp[i+1][j],dp[i][j]+A);\n\t\t\tif(a[i+1]==j+1)upn(dp[i+1][j+1],dp[i][j]);\n\t\t}\n\tint ans=OO;\n\tforn(i,n+1)upn(ans,dp[i][n]);\n\tcout<<ans<<'\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<ctime>\n#include<cmath>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<string>\n#include<vector>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\n#define Rep(i,s,t) for(register int i=s;i<t;++i)\n#define go(x) for(register int e=las[x];e;e=nxt[e])\n#define re register\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define is insert\n#define es erase\n#define pii pair<int,int>\n#define ms(f,x) memset(f,x,sizeof f)\n#define mc(f,x) memcpy(f,x,sizeof f)\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define gi(x) read(x)\n#define gii(x,y) read(x),read(y)\n#define giii(x,y,z) read(x),read(y),read(z)\nnamespace IO{\n    #define gc getchar()\n    #define pc(x) putchar(x)\n    template<typename T>inline void read(T &x){\n        x=0;int f=1;char ch=gc;while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc;x*=f;return;\n    }\n    template<typename T>inline void write(T x=0){\n        T wr[51];wr[0]=0;if(x<0)pc('-'),x=-x;if(!x)pc(48);\n        while(x)wr[++wr[0]]=x%10,x/=10;while(wr[0])pc(48+wr[wr[0]--]);return;\n    }\n}\nusing IO::read;\nusing IO::write;\ntypedef long long ll;\ntypedef double db;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nconst int N=5011;\nint n,A,B;\nint p[N],b[N],c[N],s[N],pos[N];\nll dp[N][N];\ninline void ins(int x){\n\t++x;\n\tfor(;x<=n+1;x+=x&-x)\n\t\t--s[x];\n}\ninline int query(int x){\n\tint res=0;\n\t++x;\n\tfor(;x;x-=x&-x)\n\t\tres+=s[x];\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&B,&A);\n\trep(i,1,n)\n\t\tscanf(\"%d\",p+i),pos[p[i]]=i;\n\trep(i,0,n+1)\n\t\trep(j,0,n+1)\n\t\t\tdp[i][j]=1e18;\n\tdp[0][n+1]=0;\n\tll ans=1e18;\n\trep(i,0,n){\n\t\tif(i)\n\t\t\t--c[pos[i]+1],++c[i];\n\t\trep(j,1,n)\n\t\t\tb[j]=b[j-1]+c[j],s[j]=0;\n\t\t_rep(j,n+1,i+2){\n\t\t\t\t//printf(\"%d %d %d\\n\",i,j-1,pos[j-1]+b[pos[j-1]]+query(pos[j-1]));\n\t\t\t\tif(pos[j-1]+b[pos[j-1]]+query(pos[j-1])==j-1)\n\t\t\t\t\tdp[i][j-1]=min(dp[i][j],dp[i][j-1]);\n\t\t\t\telse\n\t\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]+B);\n\t\t\t\n\t\t\t\tif(pos[i+1]+b[pos[i+1]]+query(pos[i+1])==i+1)\n\t\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\t\telse\n\t\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+A);\n\t\t\t\n\t\t\tins(pos[j-1]);\n\t\t}\n\t}\n\t//rep(i,0,n)\n\t//\trep(j,i+1,n)\n\t//\t\tprintf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\trep(i,0,n)\n\t\tans=min(ans,dp[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\tlong long A,B;\n\tcin>>n>>A>>B;\n\tvector<int>a(n+2);\n\ta[n+1]=n+1;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tvector<long long>dp(n+2);\n\tdp[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i]=(long long) 1e18;\n\t\tint bigger=0;\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t\tif(a[j]>a[i])\n\t\t\t\tbigger++;\n\t\t\telse{\n\t\t\t\tdp[i]=min(dp[i],dp[j]+bigger*A+(i-1-j-bigger)*B);\n\t\t\t}\n\t}\n\tcout<<dp[n]<<endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nconst int maxn = 5005;\n\nll dp[maxn][maxn];\nll A, B;\nint n;\nint p[maxn];\n\nint c[maxn];\n\nint st[maxn], tot;\nint pre[maxn], suf[maxn];\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    cin >> A >> B;\n    p[0] = n + 1;\n    p[n + 1] = 0;\n    tot = 0;\n    st[++tot] = n + 1; \n    for(int i = 1;i <= n;i++){\n        cin >> p[i];\n        while(tot > 0 and p[i] > st[tot]){\n            tot--;\n        }\n        pre[p[i]] = st[tot];\n        st[++tot] = p[i];\n    }\n    tot = 0;\n    st[++tot] = 0;\n    for(int i = n;i >= 1;i--){\n        while(tot > 0 and p[i] < st[tot]){\n            tot--;\n        }\n        suf[p[i]] = st[tot];\n        st[++tot] = p[i];\n    }\n    for(int i = 0;i <= n;i++){\n        for(int j = i + 1;j <= n + 1;j++){\n            dp[i][j] = 1e18;\n        }\n    }\n    dp[0][n + 1] = 0;\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j <= i;j++){\n            int k = n + 1 - i - j;\n            ll val;\n            if(pre[j + 1] >= k){\n                val = dp[j][k];\n            }else{\n                val = dp[j][k] + B;\n            }\n            dp[j + 1][k] = min(val, dp[j + 1][k]);\n            if(suf[k - 1] <= j){\n                val = dp[j][k];\n            }else{\n                val = dp[j][k] + A;\n            }\n            dp[j][k - 1] = min(val, dp[j][k - 1]);\n        }\n    }\n    ll ans = 1e18;\n    for(int i = 0;i <= n;i++){\n        ans = min(ans, dp[i][i + 1]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define go(i,a,b) for(int i=(a);i<=(b);++(i))\n#define com(i,a,b) for(int i=(a);i>=(b);--(i))\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define inf 0x3f3f3f3f\n#define fin freopen(\"input.txt\",\"r\",stdin)\n#define fout freopen(\"output.txt\",\"w\",stdout)\ntypedef long long ll;\nint n,A,B,x,p[5005];\nll f[5005][5005],pre[5005][5005];\n\nvoid gmin(ll &a,ll b){if(a>b) a=b;}\n\nint main()\n{\n\t//fin;\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tgo(i,1,n) scanf(\"%d\",&x),p[x]=i;\n\tmem(f,0x3f),mem(pre,0x3f);\n\tgo(i,1,n) pre[0][i]=0;\n\tgo(i,1,n)\n\tgo(j,1,n){\n\t\tif(p[i]>j) gmin(f[i][j],pre[i-1][j]+B);\n\t\telse if(p[i]==j) gmin(f[i][j],pre[i-1][j]);//允许i-1在自己左边的空格或者和自己一个空格\n\t\t//保证了对于任意数比它小一的的数都在它左边，即升序排列 \n\t\telse gmin(f[i][j],pre[i-1][j]+A);\n\t\tpre[i][j]=pre[i][j-1];\n\t\tgmin(pre[i][j],f[i][j]); \n\t}\n\tll ans=1e18;\n\tgo(i,1,n) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MOD 1000000007\n#define inf 0x3f3f3f3f\n#define linf 0x3f3f3f3f3f3f3f3fll\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\nint n,a,b;\nint p[5050];\nint rev[5050];\nll dp[5050][5050];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&p[i]);\n\t\tp[i]--;\n\t\trev[p[i]]=i;\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\tif(rev[0]!=0)dp[0][n]=b;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tdp[i][i]=min(dp[i][i],dp[i-1][n]);\n\t\tdp[i][n]=min(dp[i][n],dp[i-1][n]+b);\n\t//\tcout<<i<<endl;\n\t\tfor(int lst=0;lst<i;lst++)\n\t\t{\n\t\t\tif(rev[lst]<rev[i])\n\t\t\t{\n\t\t\t\tdp[i][i]=min(dp[i][i],dp[i-1][lst]);\n\t\t\t\tdp[i][lst]=min(dp[i][lst],dp[i-1][lst]+b);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][lst]=min(dp[i][lst],dp[i-1][lst]+a);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=linf;\n\tfor(int i=0;i<=n;i++)\n\t\tans=min(ans,dp[n-1][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define MN 20010\n\ntypedef long long ll;\n\nll Min[MN], lazy[MN];\n\nvoid add(int x, ll v) {lazy[x] += v; Min[x] += v;}\nvoid pushdown(int x)\n{\n\tif(lazy[x]) \n\t{\n\t\tadd(x << 1, lazy[x]);\n\t\tadd(x << 1 | 1, lazy[x]);\n\t\tlazy[x] = 0;\n\t}\n}\n\nvoid modify(int x, int l, int r, int L, int R, ll v, int t)\n{\n\tif(L > R) return;\n\tif(l == L && r == R)\n\t{\n\t\tif(t == 0) add(x, v);\n\t\telse Min[x] = v;\n\t\treturn;\n\t}\n\tpushdown(x); int mid = l + r >> 1;\n\tif(R <= mid) modify(x << 1, l, mid, L, R, v, t);\n\telse if(L > mid) modify(x << 1 | 1, mid + 1, r, L, R, v, t);\n\telse modify(x << 1, l, mid, L, mid, v, t), modify(x << 1 | 1, mid + 1, r, mid + 1, R, v, t);\n\tMin[x] = std::min(Min[x << 1], Min[x << 1 | 1]);\n}\n\nll query(int x, int l, int r, int L, int R)\n{\n\tif(l == L && r == R) return Min[x];\n\tpushdown(x); int mid = l + r >> 1;\n\tif(R <= mid) return query(x << 1, l, mid, L, R);\n\telse if(L > mid) return query(x << 1 | 1, mid + 1, r, L, R);\n\telse return std::min(query(x << 1, l, mid, L, mid), query(x << 1 | 1, mid + 1, r, mid + 1, R));\n}\n\nint main()\n{\n\tint n, a, b; \n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tmodify(1, 0, n, 0, n, 1e18, 0);\n\tmodify(1, 0, n, 0, 0, 0, 1);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint x; scanf(\"%d\", &x);\n\t\tmodify(1, 0, n, x, x, query(1, 0, n, 0, x), 1);\n\t\tmodify(1, 0, n, 0, x - 1, a, 0);\n\t\tmodify(1, 0, n, x + 1, n, b, 0);\n\t}\n\tprintf(\"%lld\\n\", query(1, 0, n, 0, n));\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=5007;\nconst ll inf=1e18;\n\nint n;\nll wl, wp;\n\nint tab[nax];\n\nll dp[nax];\n\nint main()\n{\n\tscanf(\"%d%lld%lld\", &n, &wp, &wl);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\ttab[n+1]=n+1;\n\tfor (int i=1; i<=n+1; i++)\n\t\tdp[i]=inf;\n\tfor (int i=0; i<=n; i++)\n\t{\n\t\tint naj=n+7;\n\t\tint mniej=0;\n\t\tfor (int j=i+1; j<=n+1; j++)\n\t\t{\n\t\t\tif (tab[j]<tab[i])\n\t\t\t\tmniej++;\n\t\t\tif (tab[j]<naj && tab[j]>tab[i])\n\t\t\t{\n\t\t\t\tnaj=tab[j];\n\t\t\t\tdp[j]=min(dp[j], dp[i]+(j-i-1-mniej)*wp+mniej*wl);\n\t\t\t}\n\t\t\t//~ debug() << i << \" \" << j << \" \" << mniej;\n\t\t}\n\t}\n\tdebug() << range(dp, dp+2+n);\n\t\n\t\n\tprintf(\"%lld\\n\", dp[n+1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, p[5005], A, B, dp[5005][5005];\nll pos[5005];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; ++i){\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 1; i <= N; ++i){\n\t\tpos[p[i]] = i;\n\t} \n\tfor (int i = 1; i <= N+1; ++i){\n\t\tif (i < pos[1]) dp[1][i] = B;\n\t\telse if (i > pos[1]) dp[1][i] = A;\n\t\telse dp[1][i] = 0;\n\t} \n\tfor (int i = 2; i <= N; ++i){\n\t\tdeque<pair<ll,int> > f;\n\t\tfor (int j = 1; j <= N+1; ++j){\n\t\t\twhile (!f.empty() && f.back().first > dp[i-1][j]){\n\t\t\t\tf.pop_back();\n\t\t\t}\n\t\t\tf.push_back(make_pair(dp[i-1][j],j));\n\t\t\tif (j == pos[i]) dp[i][j] = dp[i-1][j];\n\t\t\telse dp[i][j] = 1e16;\n\t\t\tif (!f.empty()){\n\t\t\t\tif (j > pos[i]) dp[i][j] = min(dp[i][j],A+f.front().first);\n\t\t\t\telse if (j < pos[i]) dp[i][j] = min(dp[i][j],B+f.front().first);\n\t\t\t\telse dp[i][j] = min(dp[i][j],f.front().first);\n\t\t\t}\n\t\t\t\n\t\t}\n\t} \n\tfor (int i = 1; i <= N; ++i){\n\t\tfor (int j = 1; j <= N+1; ++j){\n\t\t\t//cout << dp[i][j] << ' ';\n\t\t}\n\t\t//cout << '\\n';\n\t} \n\tll M = 1e16;\n\tfor (int i = N; i <= N+1; ++i){\n\t\tM = min(M,dp[N][i]);\n\t}\n\tcout << M << '\\n';\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nlong A,B,dp[5555];\nint p[5555];\nmain()\n{\n\tcin>>n>>A>>B;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong c=0;\n\t\tcin>>p[i];\n\t\tdp[i]=9e18;\n\t\tfor(int j=i;j--;)\n\t\t{\n\t\t\tif(p[j]>p[i])\n\t\t\t{\n\t\t\t\tc+=A;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i]=min(dp[i],dp[j]+c);\n\t\t\t\tc+=B;\n\t\t\t}\n\t\t}\n\t\tdp[i]=min(dp[i],c);\n\t}\n\tcout<<dp[n-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nconst int MAX_M = 1e5 + 5;\n\nstruct edge {\n    int u, v;\n    int other(int x) { return x ^ u ^ v; }\n};\n\nint n, m;\nedge ed[MAX_M];\nset<int> g[MAX_N];\n\nbool mk[MAX_N];\n\nbool remove1() {\n    int u;\n    for (u = 1; u <= n && g[u].empty(); u++);\n    if (u == n + 1) return 1;\n    \n    fill_n(mk, n + 1, 0);\n    vector<pair<int, int>> rec{{-1, u}};\n    while (1) {\n        if (mk[u]) {\n            //cout << \"re \" << u << endl;\n            break;\n        }\n        mk[u] = 1;\n        //cout << \"cyc \" << u << endl;\n        if (g[u].empty()) return 1;\n        int e = *g[u].begin();\n        int v = ed[e].other(u);\n        g[u].erase(e);\n        g[v].erase(e);\n        rec.push_back({e, v});\n        u = v;\n    }\n    for (auto &p : rec) {\n        int e, v; tie(e, v) = p;\n        if (e != -1) {\n            g[ed[e].u].insert(e);\n            g[ed[e].v].insert(e);\n        }\n        if (v == u) break;\n    }\n    return 0;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(nullptr);\n\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        cin >> ed[i].u >> ed[i].v;\n        g[ed[i].u].insert(i);\n        g[ed[i].v].insert(i);\n    }\n\n    int odd = 0;\n    for (int u = 1; u <= n; u++) odd += g[u].size() % 2;\n\n    if (odd) cout << \"No\\n\";\n    else {\n        bool ok = 0;\n        mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n        for (int iter = 0; iter < 25; iter++) {\n            shuffle(ed, ed + m, rng);\n            fill_n(g + 1, n, set<int>());\n            for (int i = 0; i < m; i++) {\n                g[ed[i].u].insert(i);\n                g[ed[i].v].insert(i);\n            }\n            if (remove1()) continue;\n            if (remove1()) continue;\n            if (remove1()) continue;\n            ok = 1; break;\n        }\n        cout << (ok ? \"Yes\\n\" : \"No\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nconst int maxn = 5005;\n\nll dp[maxn][maxn];\nll A, B;\nint n;\nint p[maxn];\n\nint c[maxn];\n\nint pre[maxn], suf[maxn];\nset<int> s;\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    cin >> A >> B;\n    p[0] = n + 1;\n    p[n + 1] = 0;\n    s.insert(n + 1);\n    for(int i = 1;i <= n;i++){\n        cin >> p[i];\n        auto it = s.lower_bound(p[i]);\n        pre[p[i]] = *it;\n        s.insert(p[i]);\n    }\n    s.clear();\n    s.insert(0);\n    for(int i = n;i >= 1;i--){\n        auto it = s.lower_bound(p[i]);\n        it--;\n        suf[p[i]] = *it;\n        s.insert(p[i]);\n    }\n    for(int i = 0;i <= n;i++){\n        for(int j = i + 1;j <= n + 1;j++){\n            dp[i][j] = 1e18;\n        }\n    }\n    dp[0][n + 1] = 0;\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j <= i;j++){\n            int k = n + 1 - (i - j);\n            ll val;\n            if(pre[j + 1] >= k){\n                val = dp[j][k];\n            }else{\n                val = dp[j][k] + B;\n            }\n            dp[j + 1][k] = min(val, dp[j + 1][k]);\n            if(suf[k - 1] <= j){\n                val = dp[j][k];\n            }else{\n                val = dp[j][k] + A;\n            }\n            dp[j][k - 1] = min(val, dp[j][k - 1]);\n        }\n    }\n    ll ans = 1e18;\n    for(int i = 0;i <= n;i++){\n        ans = min(ans, dp[i][i + 1]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//!link: m,stdc++\n//!flag: -g,-DWAAUTOMATON\n// failed\n/*+lmake\n * DEFINE += WAAUTOMATON\n */\n#include <bits/stdc++.h>\n#ifdef WAAUTOMATON\n#define debug(args...)                                                                             \\\n    {                                                                                              \\\n        dbg, args;                                                                                 \\\n        cerr << endl;                                                                              \\\n    }\n#define massert(x) assert(x)\n#else\n#define debug(args...) // Just strip off all debug tokens\n#define massert(x)\n#endif\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef std::pair<int, int> pii;\ntypedef std::pair<LL, LL> pll;\nstruct debugger\n{\n    template <typename T>\n    debugger &operator,(const T &v)\n    {\n        std::cerr << v << \" \";\n        return *this;\n    }\n} dbg;\n\ntemplate <typename T>\ninline void chmax(T &a, T b)\n{\n    a = std::max(a, b);\n}\n\ntemplate <typename T>\ninline void chmin(T &a, T b)\n{\n    a = std::min(a, b);\n}\n\ntemplate <typename T>\ninline T sqr(const T& x)\n{\n\treturn x*x;\n}\n\ntemplate <size_t _I_Buffer_Size = 1 << 23, size_t _O_Buffer_Size = 1 << 23>\nstruct IO_Tp\n{\n    char _I_Buffer[_I_Buffer_Size];\n    char *_I_pos;\n    const char *_I_end;\n\n    char _O_Buffer[_O_Buffer_Size];\n    char *_O_pos;\n    const char *_O_end;\n\n    IO_Tp()\n        : _I_pos(_I_Buffer)\n        , _O_pos(_O_Buffer)\n        , _I_end(_I_Buffer + _I_Buffer_Size)\n        , _O_end(_O_Buffer + _O_Buffer_Size)\n    {\n    }\n\n    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }\n\n    inline char getchar()\n    {\n        char res = *_I_pos;\n        nextchar();\n        return res;\n    }\n\n    inline bool is_digit(const char ch) { return '0' <= ch && ch <= '9'; }\n\n    inline void nextchar()\n    {\n        ++_I_pos;\n        if (_I_pos == _I_end) {\n            fread(_I_Buffer, 1, _I_Buffer_Size, stdin);\n            _I_pos = _I_Buffer;\n        }\n    }\n\n    template <typename Int>\n    inline IO_Tp &operator>>(Int &res)\n    {\n        res = 0;\n        int k = 1;\n        while (!is_digit(*_I_pos)) {\n            if (*_I_pos == '-')\n                k = -1;\n            nextchar();\n        }\n        do {\n            (res *= 10) += (*_I_pos) - '0';\n            nextchar();\n        } while (is_digit(*_I_pos));\n        res *= k;\n        return *this;\n    }\n\n    inline IO_Tp &operator>>(char &res)\n    {\n        do {\n            res = *_I_pos;\n            nextchar();\n        } while (res == ' ' || res == '\\0' || res == '\\t' || res == '\\n' || res == '\\r');\n        return *this;\n    }\n\n    inline void putchar(char x)\n    {\n        if (_O_pos == _O_end) {\n            fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout);\n            _O_pos = _O_Buffer;\n        }\n        *_O_pos++ = x;\n    }\n    template <typename Int>\n    inline IO_Tp &operator<<(Int n)\n    {\n        if (n < 0) {\n            putchar('-');\n            n = -n;\n        }\n        static char _buf[20];\n        char *_pos(_buf);\n        do\n            *_pos++ = '0' + n % 10;\n        while (n /= 10);\n        while (_pos != _buf)\n            putchar(*--_pos);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(char ch)\n    {\n        putchar(ch);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(const char *s)\n    {\n        while (*s != 0) {\n            putchar(*s);\n            ++s;\n        }\n        return *this;\n    }\n};\nIO_Tp<> IO;\n\nconst int MAXN=5000;\nint a[MAXN+10];\nLL A,B;\nvector<int> in[MAXN+10],out[MAXN+10];\nint icnt[MAXN+10],ocnt[MAXN+10];\nvoid add(int x)\n{\n\tfor(auto v:out[x]) {\n\t\ticnt[v]++;\n\t}\n}\nbool b[MAXN+10];\nint main()\n{\n#ifdef WAAUTOMATON\n    freopen(\"./in_D_5.txt\", \"r\", stdin);\n#endif\n\tLL ans=LLONG_MAX/3;\n\tint n;\n\tIO>>n>>A>>B;\n\tfor(int i=1; i<=n; ++i) {\n\t\tIO>>a[i];\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=i+1; j<=n; ++j) {\n\t\t\tif (a[i]>a[j]) {\n\t\t\t\tin[a[i]].push_back(a[j]);\n\t\t\t\tout[a[j]].push_back(a[i]);\n\t\t\t\tocnt[a[j]]++;\n\t\t\t}\n\t\t}\n\t}\t\n\tLL cntb=n;\n\tfor(int i=1; i<=n; ++i) {\n\t\tif (ocnt[i]==0) --cntb;\n\t\telse if (ocnt[i]==1) {\n\t\t\tadd(i);\n\t\t}\n\t}\n\tchmin(ans,cntb*B);\n\tfor(LL cnta=1; cnta<=n; ++cnta) {\n\t\tint p=0;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tif (!b[i] && icnt[i]>icnt[p]) {\n\t\t\t\tp=i;\n\t\t\t}\n\t\t}\n\t\tif (p==0) break;\n\t\tcntb-=icnt[p];\n\t\tb[p]=true;\n\t\tfor(auto v:in[p]) {\n\t\t\tocnt[v]--;\n\t\t\tif (ocnt[v]==1) {\n\t\t\t\tadd(v);\n\t\t\t}\n\t\t}\n\t\tchmin(ans,cnta*A+cntb*B);\n\t}\n\tIO<<ans<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n\nusing namespace std;\n\nstruct TFenwickTree {\n  vector<int> t;\n  int n;\n  \n  void init(int nn)\n  {\n    n = nn;\n    t.assign (n, 0);\n  }\n  \n  int sum(int r)\n  {\n    int result = 0;\n    for (; r >= 0; r = (r & (r+1)) - 1)\n      result += t[r];\n    return result;\n  }\n  \n  void inc(int i, int delta)\n  {\n    for (; i < n; i = (i | (i+1)))\n      t[i] += delta;\n  }\n  \n  int sum (int l, int r)\n  {\n    if (l > r) return 0;\n    return sum(r) - sum(l-1);\n  }\n};\n\ntypedef long long ll;\n\nconst int maxn = 5000;\n\nll cnt[maxn][maxn];\nll ans[maxn][maxn];\n\nll Solve(int k, int n, int a, int b, const vector<int>& pos) {\n  if (k <= 0 || n == 0) return 0;\n  ll& res = ans[k][n];\n  if (res != -1) return res;\n\n  if (pos[n] > k) {\n    res = Solve(k, n - 1, a, b, pos);\n    return res;\n  }\n\n  res = min(a + Solve(k, n - 1, a, b, pos), cnt[k][n] * b + Solve(pos[n] - 1, n, a, b, pos));\n  return res;\n}\n\nint main()\n{\n  int n;\n  ll a, b;\n  cin >> n >> a >> b;\n  vector<int> p(n), pos(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i];\n    p[i]--;\n    pos[p[i]] = i;\n  }\n\n  for (int k = 0; k < n; ++k) {\n    TFenwickTree tree;\n    tree.init(k + 1);\n    for (int r = 0; r < n; ++r) {\n      if (pos[r] > k) continue;\n      cnt[k][r] = tree.sum(pos[r], k);\n      tree.inc(pos[r], 1);\n    }\n  }\n\n\n  memset(ans, -1, sizeof(ans));\n\n  cout << Solve(n - 1, n - 1, a, b, pos) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n#define int LL\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 5005;\nint a[MAXN];\nint f[MAXN][MAXN];\n\nsigned main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, A, B; read(n), read(A), read(B);\n  for (RI i = 1; i <= n; ++i) read(a[i]);\n  memset(f, 0x3f, sizeof(f));\n  f[0][0] = 0;\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 0; j <= n; ++j)\n      if (a[i] > j) {\n        f[i][j] = min(f[i][j], f[i - 1][j] + A);\n        f[i][a[i]] = min(f[i][a[i]], f[i - 1][j]);\n      }\n      else {\n        f[i][j] = min(f[i][j], f[i - 1][j] + B);\n      //  f[i][a[i]] = min(f[i][a[i]], f[i - 1][j] + A);\n      }\n  int ans = 0x7f7f7f7f7f7f7f7f;\n  for (RI i = 0; i <= n; ++i)\n    ans = min(ans, f[n][i]);\n  printf(\"%d\\n\", ans);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 5500;\nll c[maxn],f[maxn],ans;\nint n,a[maxn];\nll A,B,C;\n#define lson (o<<1)\n#define rson (o<<1|1)\n#define mid ((l+r)>>1)\nll tag[maxn<<2],T[maxn<<2];\nll query(int o,int l,int r,int x,int y){\n\tif(l==x && r==y) return T[o];\n\tif(y<=mid) return query(lson,l,mid,x,y) + tag[o]; else\n\tif(mid+1<=x) return query(rson,mid+1,r,x,y) + tag[o]; else\n\treturn min(query(lson,l,mid,x,mid),query(rson,mid+1,r,mid+1,y)) + tag[o];\n}\nvoid modify(int o,int l,int r,int x,int y,ll v){\n\tif(l==x && r==y){\n\t\tT[o] += v;\n\t\ttag[o] += v;\n\t\treturn ;\n\t}\n\tif(y<=mid) modify(lson,l,mid,x,y,v); else\n\tif(mid+1<=x) modify(rson,mid+1,r,x,y,v); else\n\tmodify(lson,l,mid,x,mid,v),modify(rson,mid+1,r,mid+1,y,v);\n\tT[o] = min(T[lson],T[rson]) + tag[o];\n}\nvoid M(int o,int l,int r,int x,ll v){\n\tif(l==r){\n\t\tT[o] = v;\n\t\treturn ;\n\t}\n\tif(x<=mid) M(lson,l,mid,x,v - tag[o]); else\n\t\t\t   M(rson,mid+1,r,x,v - tag[o]);\n\tT[o] = min(T[lson],T[rson]) + tag[o];\n}\nint main(){\n    n = read(),A = read(),B = read();\n    Rep(i,1,n) a[i] = read();\n    if(A>B){\n        swap(A,B);\n        reverse(a+1,a+1+n);\n        Rep(i,1,n) a[i] = n-a[i]+1;\n    }\n    C = min(A,B);\n    ans = 1ll << 60;\n    memset(T,0x3f,sizeof(T));\n    memset(tag,0,sizeof(tag));\n    Rep(i,1,n){//A是右移，B是左移 \n    \tf[i] = min((i - 1) * A,query(1,1,n,1,a[i]) + i * C - C);\n        if(a[i]+1<=n) modify(1,1,n,a[i]+1,n,B-C);\n        M(1,1,n,a[i],f[i]-i*C);\n        ans = min(ans,f[i] + B * (n - i));\n    }writeln(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdlib.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<P, ll> T;\n \nlong long int INF = 2e18;\nconst ll fact_table = 1200008;\ndouble Pi = 3.1415926535897932384626;\n\npriority_queue <ll> pql;\npriority_queue <P> pqp;\npriority_queue <P> bag;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//↓,→,↑,←\n\n#define endl \"\\n\"\n#ifdef ENJAPMA\n    #undef endl\n#endif\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n#define pc(x) cout << x << \",\";\n \nconst ll mod = 998244353ll;\n// const ll mod = 1000000007ll;\n  \nll mypow(ll number1,ll number2, ll mod){\n    if(number2 == 0){\n        return 1ll;\n    }else{\n        ll number3 = mypow(number1,number2 / 2, mod);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n\nll fact[fact_table + 5],rfact[fact_table + 5]; \n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = mypow(fact[fact_table],mod - 2, mod);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n\nbool multicase = false;\n\nll n,m,num,a,b,c,d,e,h,q;\nll w, k;\nll dp[5015];\nll x[5005];\nll table[5015][5015];\n\nll cost(ll lidx, ll ridx, ll lvalue, ll rvalue){\n\n    ll large = table[ridx - 1][rvalue] - table[lidx][rvalue];\n    ll small = ridx - lidx - 1 - (table[ridx - 1][lvalue] - table[lidx][lvalue]);\n    ll middle = ridx - lidx - 1 - large - small;\n\n    if (middle >= 1){\n        return INF;\n    }\n\n    return a * large + b * small;\n}\n\nvoid solve(){\n    cin >> n >> a >> b;\n    for(ll i=1;i<=n;i++){\n        cin >> x[i];\n    }\n    for(ll i=1;i<=n;i++){\n        for(ll j=0;j<=n;j++){\n            if(x[i] >= j){\n                table[i][j] = table[i-1][j] + 1;\n            }else{\n                table[i][j] = table[i-1][j];\n            }\n        }\n    }\n\n    for(ll i=1;i<=5000;i++){\n        dp[i] = INF;\n    }\n\n    dp[0] = 0;\n    for(ll i=1;i<=n;i++){\n        for(ll j=0;j<i;j++){\n            if(x[j] < x[i]){\n                dp[i] = min(dp[i], dp[j] + cost(j, i, x[j], x[i]));\n                if(i == n && dp[i] == 40)p(j);\n            }\n        }\n    }\n    ll ans = INF;\n    for(ll i=1;i<=n;i++){\n        ll large = n - i;\n        ll res = large * b + dp[i];\n        ans = min(ans, res);\n    }\n    p(ans);\n    return;\n}\n\n\nint main(){\n    // init();\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll q, testcase = 1;\n    if(multicase){\n        cin >> q;\n    }else{\n        q = 1; \n    }\n    while(q--){\n        // pu(\"Case \");pu(\"#\");pu(testcase);pu(\": \");\n        solve();\n        testcase++;\n    }\n    // solve();\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 5e3 + 10;\nconst ll inf = 1e15 + 42;\n\nint p[N];\nll dp[N][N];\n\nint main() {\n\tfast_cin();\n\tint n; ll a, b;\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tif (dp[i][j] == inf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j >= p[i + 1]) {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + b);\n\t\t\t} else {\n\t\t\t\tdp[i + 1][p[i + 1]] = min(dp[i + 1][p[i + 1]], dp[i][j]);\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + a);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = inf;\n\tfor (int j = 0; j <= n; ++j) {\n\t\tans = min(ans, dp[n][j]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define int long long\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nll INF=1e18;\n\nll dp[5123][5123];\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,R,L;\n\t// n=5000; R=L=1000000000; --L;\n\tcin>>n>>R>>L;\n\tINF=ll(n-1)*min(L,R);\n\tvector<int> a(n); //rep(i,n) a[i]=n-1-i;\n\trep(i,n) cin>>a[i], --a[i];\n\tvector<int> toL(n),toR(n);\n\t{\n\t\tset<int> st{(ll)1e15};\n\t\trep(i,n){\n\t\t\ttoL[a[i]]=*st.lower_bound(a[i]);\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\t{\n\t\tset<int> st{-(ll)1e15};\n\t\trrep(i,n){\n\t\t\tauto it=st.lower_bound(a[i]); --it;\n\t\t\ttoR[a[i]]=*it;\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\t// out(toL,toR,1);\n\tfill(dp[0],dp[5123],INF);\n\tdp[0][n-1]=0;\n\trreps(d,2,n+1)rep(l,n+1-d){\n\t\tint r=l+d-1;\n\t\tMN(dp[l+1][r],dp[l][r]+(toL[l]>r?0:L));\n\t\tMN(dp[l][r-1],dp[l][r]+(toR[r]<l?0:R));\n\t}\n\t// rep(i,n){rep(j,n) cout<<dp[i][j]<<\",\";cout<<endl;}\n\tll re=INF;\n\trep(i,n) MN(re,dp[i][i]);\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 200000;\nint a[N], A, B, p[N];\nint used[5002][5002];\nlong long dp[5002][5002];\nint f[5002][5002];\nlong long solve(int l, int r) {\n    if (used[l][r]) {\n        return dp[l][r];\n    }\n    if (l == r) {\n        return 0;\n    }\n    used[l][r] = 1;\n    dp[l][r] = 1e18;\n    int i = p[l];\n    int cnt = f[i][r] - f[i][l - 1];\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r) + B);\n    }\n    i = p[r];\n    cnt = f[n][r] - f[i - 1][l - 1];\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1) + A);\n    }\n    return dp[l][r];\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        p[a[i]] = i;\n    }\n    for (int j = 1; j <= n; j++) {\n        for (int i = 1; i <= n; i++) {\n            f[j][i] = f[j][i - 1];\n            if (a[i] <= j) {\n                f[j][i]++;\n            }\n        }\n    }\n    cout << solve(1, n) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e18\n#define N 5010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nll n,yo,zu,mi[N],a[N],dp[N][N];\nint main(){\n\tread(n);read(yo);read(zu);mi[0]=INF;\n\tfor (int i=1;i<=n;i++) read(a[i]);\n\tfor (int i=1;i<=n+1;i++){\n\t\tfor (int j=1;j<=n;j++) mi[j]=min(mi[j-1],dp[i-1][j]);\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tdp[i][j]=mi[j];\n\t\t\tif (j<a[i])dp[i][j]+=yo;\n\t\t\tif (j>a[i])dp[i][j]+=zu;\n\t\t}\n\t}\n\tcout<<mi[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\tlong long A,B;\n\tcin>>n>>A>>B;\n\tvector<int>a(n+2);\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tvector<long long>dp(n+2);\n\tdp[0]=0;\n\tfor(int i=1;i<=n+1;i++){\n\t\tdp[i]=(long long) 1e18;\n\t\tint bigger=0;\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t\tif(a[j]>a[i])\n\t\t\t\tbigger++;\n\t\t\telse{\n\t\t\t\tdp[i]=min(dp[i],dp[j]+bigger*A+(i-1-j-bigger)*B);\n\t\t\t}\n\t}\n\tcout<<dp[n]<<endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\nnamespace mydef {\nconst int INF = 1ll << 60;\nconst int MOD = 1e9 + 7;\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T& val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\nbool dbg = false;\n}  // namespace mydef\nusing namespace mydef;\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vp vector<pair<int, int>>\n#define vvp vector<vector<pair<int, int>>>\n#define pi pair<int, int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define asn ans\n\nint N, A, B, P[5050];\nint rev[5050];\nint memo[5050][5050];\nint L[5050], R[5050];\n\n\nint f(int l, int r) {\n    if (memo[l][r] != -1) {\n        return memo[l][r];\n    }\n    if (l == r) {\n        return 0;\n    }\n    int left = f(l, r - 1);\n    if (l <= R[r])\n        left += A;\n    int right = f(l + 1, r);\n    if (r >= L[l])\n        right += B;\n    return memo[l][r] = min(left, right);\n}\n\nvoid solve() {\n    Fill(memo, -1);\n    P[N + 1] = N + 1;\n    rev[N + 1] = N + 1;\n    FOR (i, 1, N + 1) {\n        int r = -1;\n        FOR (a, 0, i) {\n            if (rev[i] < rev[a])\n                r = a;\n        }\n        int l = N + 2;\n        for (int a = N + 1; a > i; a--) {\n            if (rev[i] > rev[a])\n                l = a;\n        }\n        L[i] = l;\n        R[i] = r;\n        //cout << i << \" \" << L[i] << \" \" << R[i] << endl;\n    }\n    cout << f(1, N) << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> A >> B;\n    FOR (N) {\n        cin >> P[i + 1];\n        rev[P[i + 1]] = i + 1;\n    }\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int N;\n    ll A,B;\n    cin >> N >> A >> B;\n    ll inf = 1e18;\n    vector<int> l(N+1,0),p(N+1,0);\n    for(int i=1;i<=N;i++) cin >> p[i];\n    vector<vector<ll>> dp(N+1,vector<ll>(N+1,inf));\n    for(int i=1;i<=N;i++) for(int j=1;j<=N;j++){\n        if(p[j]==i) break;\n        if(p[j]>i) l[i]++;\n    }\n    for(int j=0;j<=N;j++) dp[0][j] = 0;\n    for(int i=1;i<=N;i++) for(int j=0;j<=N;j++){\n        if(j<=l[i]){\n            dp[i][j] = min(dp[i][j],dp[i-1][j]+B);\n            dp[i][l[i]] = min(dp[i][l[i]],dp[i-1][j]);\n        }else dp[i][j-1] = min(dp[i][j-1],dp[i-1][j]+A);\n    }\n//    for(int i=0;i<=N;i++) for(int j=0;j<=N;j++) cerr << dp[i][j] << (j!=N? \" \":\"\\n\");\n    cout << dp[N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ll,ii>\n#define endl '\\n'\n\nint n,a,b;\nint arr[5005];\nint pos[5005];\n\nll memo[5005][10005];\n\nint main(){\n\tios::sync_with_stdio(0);\n    cin.tie(0);\n\t\n\tmemset(memo,127,sizeof(memo));\n\t\n\tcin>>n>>a>>b;\n\tfor (int x=1;x<=n;x++) cin>>arr[x];\n\tfor (int x=1;x<=n;x++) pos[arr[x]]=x*2;\n\n\tfor (int x=0;x<=2*n;x++) memo[0][x]=0;\n\t\n\tfor (int x=1;x<=n;x++){\n\t\tfor (int y=1;y<=2*n+1;y++){\n\t\t\tif (y%2==0 && pos[x]==y){\n\t\t\t\tmemo[x][y]=min(memo[x][y-1],memo[x-1][y]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmemo[x][y]=min(memo[x][y-1],memo[x-1][y]+(pos[x]<y?a:b));\n\t\t\t}\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<memo[x][y]<<endl;\n\t\t}\n\t}\n\t\n\tcout<<memo[n][2*n+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define ll long long\nconst int Q=5005;\nll f[Q][Q];\nint p[Q];\nint main()\n{\n\tint n;\n\tll a,b;\n\tscanf(\"%d%lld%lld\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++){\n        f[i][p[i]]=998244353;\n        for(int j=p[i];j;--j)\n            f[i][j]=f[i-1][j]+a,f[i][p[i]]=min(f[i][p[i]],f[i-1][j]);\n        for(int j=p[i]+1;j<=n;j++)\n            f[i][j]=f[i-1][j]+b;\n    }\n    ll als=100000000000000000LL;\n    for(int j=1;j<=n;j++)\n        als=min(als,f[n][j]);\n    printf(\"%lld\\n\",als);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <functional>\n#include <map>\n#include <cmath>\n#include <deque>\n#include <string>\n#define SIZE 5005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint pos[SIZE],X[SIZE];\nint cnt[SIZE][SIZE];\nll dp[SIZE][SIZE];\nint n;\nll A,B;\n\nll solve(int i,int j)\n{\n\tif(i==n||j==n) return 0;\n\tif(dp[i][j]!=-1) return dp[i][j];\n\tif(pos[i]<j) return solve(i+1,j);\n\treturn dp[i][j]=min(B+solve(i+1,j),A*(ll) cnt[i][j]+solve(i+1,pos[i]));\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%lld %lld\",&A,&B);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);x--;\n\t\tpos[x]=i;\n\t\tX[i]=x;\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=pos[i];j>=0;j--)\n\t\t{\n\t\t\tcnt[i][j]=cnt[i][j+1]+(X[j]>i?1:0);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",solve(0,0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nclass SegmentTree {\npublic:\n    ll size;\n    vector<T> node;\n    function<T(T, T)> comp;\n    T identity_ele;  //comp(x, identity_ele) == x\n\n    SegmentTree(const vector<T> &v, function<T(T, T)> comp, T identity_ele) \n        : comp(comp),\n          identity_ele(identity_ele)\n    {\n        ll tmp = 1;\n        while(tmp < v.size()) tmp = (tmp << 1);\n        this->size = tmp;\n        this->identity_ele = identity_ele;\n        this->comp = comp;\n        node = V<T>(2 * size - 1, identity_ele);\n        for(ll i = 0; i < v.size(); i++) {\n            node[i + size - 1] = v[i];\n        }\n        for(ll i = size - 2; 0 <= i; i--) {\n            node[i] = comp(node[i * 2 + 1], node[i * 2 + 2]);\n        }\n    }\n\n    void update(ll pos, T value) {\n        pos += size - 1;\n        node[pos] = value;\n        while(pos > 0) {\n            pos = (pos - 1) / 2;\n            node[pos] = comp(node[2 * pos + 1], node[2 * pos + 2]);\n        }\n    }\n\n    T query(ll a, ll b) {\n        if (b <= a) return identity_ele;\n        return sub_query(a, b, 0, 0, size);\n    }\n\n    T sub_query(ll a, ll b, ll k, ll l, ll r) {\n        if(r <= a || b <= l) {\n            return identity_ele;\n        } else if(a <= l && r <= b) {\n            return node[k];\n        } else {\n            T left = sub_query(a, b, k * 2 + 1, l, (l + r) / 2);\n            T right = sub_query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return comp(left, right);\n        }\n    }\n};\n\nconst size_t SIZE = 5010;\nconst ll inf = 5e15;\nll dp[SIZE][SIZE];\nbool calced[SIZE][SIZE];\n\nint main() {\n    ll N, A, B;\n    cin >> N >> A >> B;\n    V<ll> P(N), idx(N);\n    for (ll i = 0; i < N; i++) {\n        ll e;\n        cin >> e;\n        e--;\n        P[i] = e;\n        idx[e] = i;\n    }\n    SegmentTree<ll> seg_min(idx, [](ll a, ll b) { return min(a, b); }, inf), seg_max(idx, [](ll a, ll b) { return max(a, b); }, -inf);\n    \n    function<ll(ll, ll)> rec = [&](ll l, ll r) {\n        if (calced[l][r]) return dp[l][r];\n        calced[l][r] = true;\n        if (l == r) return (ll)0;\n        ll lidx = idx[l], ridx = idx[r];\n        ll val = inf;\n        if (seg_min.query(l, r + 1) == lidx) chmin(val, rec(l + 1, r));\n        else chmin(val, rec(l + 1, r) + B);\n        if (seg_max.query(l, r + 1) == ridx) chmin(val, rec(l, r - 1));\n        else chmin(val, rec(l, r - 1) + A);\n        return dp[l][r] = val;\n    };\n\n    cout << rec(0, N - 1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\n#define lowbit(x) (x)&(-x)\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define per(i,a,b) for (int i=a;i>=b;i--)\n#define maxd (ll)10000000000007\ntypedef long long ll;\nconst int N=100000;\nconst double pi=acos(-1.0);\nint n,a,b,num[5050];\nll dp[5050][5050];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n\twhile ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n\treturn x*f;\n}\n\nint main()\n{\n\tn=read();a=read();b=read();\n\trep(i,1,n) num[i]=read();\n\trep(i,0,n)\n\t\trep(j,0,n) dp[i][j]=maxd;\n\tdp[0][0]=0;\n\trep(i,1,n)\n\t{\n\t\trep(j,0,n)\n\t\t{\n\t\t\tif (dp[i-1][j]==maxd) continue;\n\t\t\tif (num[i]>j)\n\t\t\t{\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+a);\n\t\t\t\tdp[i][num[i]]=min(dp[i][num[i]],dp[i-1][j]);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+b);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=maxd;\n\trep(i,1,n) ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<cmath>\n#include<stack>\n#include<algorithm>\n#define rg register\n#define ll long long\n#define LDB long double\n#define ull unsigned long long\n#define view(i,x) for(rg int i=hd[x];i!=-1;i=e[i].nt)\n#define go(i,x,a) for(rg int i=a;i<x;i++)\n#define inf 0x3f3f3f3f\n#define INF 0x7fffffff\nusing namespace std;\n\nconst int maxn=5e3+5;\nint n,a[maxn];\nll A,B,f[maxn][maxn],sf[maxn][maxn];\n\ninline int rd(){\n\tint ret=0,af=1; char gc=getchar();\n\twhile(gc < '0' || gc > '9'){ if(gc=='-') af=-af; gc=getchar(); }\n\twhile(gc >= '0' && gc <= '9') ret=ret*10+gc-'0',gc=getchar();\n\treturn ret*af;\n}\n\ninline void gmin(ll &a,ll b){\n\tif(a > b) a=b; return ;\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\t#endif\n\tn=rd(); A=rd(); B=rd(); int x;\n\tgo(i,n+1,1) x=rd(),a[x]=i;\n\tmemset(sf,7,sizeof(sf)); memset(f,7,sizeof(f));\n\tgo(i,n+1,1) sf[0][i]=0;\n\tgo(i,n+1,1){\n\t\tgo(j,n+1,1){\n\t\t\tif(j < a[i]) gmin(f[i][j],sf[i-1][j]+B);\n\t\t\tif(j == a[i]) gmin(f[i][j],sf[i-1][j]);\n\t\t\tif(j > a[i]) gmin(f[i][j],sf[i-1][j]+A);\n\t\t\tsf[i][j]=sf[i][j-1];\n\t\t\tgmin(sf[i][j],f[i][j]);\n\t\t}\n\t}\n\tll ans=1e18;\n\tgo(i,n+1,1) gmin(ans,f[n][i]);\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}//Faze\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define ll long long\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nint read(){\n    R int res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\nconst int N=5005;\nint p[N],n,A,B;ll dp[N],tmp;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read(),A=read(),B=read();\n\tfp(i,1,n)p[i]=read();\n\t++n,p[n]=n;\n\tfp(i,1,n){\n\t\tdp[i]=1e18,tmp=0;\n\t\tfd(j,i-1,0)p[j]<p[i]?(cmin(dp[i],dp[j]+tmp),tmp+=B):tmp+=A; \n\t}\n\tprintf(\"%lld\\n\",dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<ctime>\n#include<cmath>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<string>\n#include<vector>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\n#define Rep(i,s,t) for(register int i=s;i<t;++i)\n#define go(x) for(register int e=las[x];e;e=nxt[e])\n#define re register\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define is insert\n#define es erase\n#define pii pair<int,int>\n#define ms(f,x) memset(f,x,sizeof f)\n#define mc(f,x) memcpy(f,x,sizeof f)\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define gi(x) read(x)\n#define gii(x,y) read(x),read(y)\n#define giii(x,y,z) read(x),read(y),read(z)\nnamespace IO{\n    #define gc getchar()\n    #define pc(x) putchar(x)\n    template<typename T>inline void read(T &x){\n        x=0;int f=1;char ch=gc;while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc;x*=f;return;\n    }\n    template<typename T>inline void write(T x=0){\n        T wr[51];wr[0]=0;if(x<0)pc('-'),x=-x;if(!x)pc(48);\n        while(x)wr[++wr[0]]=x%10,x/=10;while(wr[0])pc(48+wr[wr[0]--]);return;\n    }\n}\nusing IO::read;\nusing IO::write;\ntypedef long long ll;\ntypedef double db;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nconst int N=1e5+11;\nll tot,ans;\nint n,A,B;\nint p[N],las[N],nxt[N],s[N],pos[N],t[N];\ninline void ins(int x,int v){\n\tfor(;x;x-=x&-x)\n\t\ts[x]+=v;\n}\ninline int query(int x){\n\tint res=0;\n\tfor(;x<=n;x+=x&-x)\n\t\tres+=s[x];\n\treturn res;\n}\ninline void add(int x,int v){\n\tfor(;x<=n;x+=x&-x)\n\t\tt[x]+=v;\n}\ninline int ask(int x){\n\tint res=0;\n\tfor(;x;x-=x&-x)\n\t\tres+=t[x];\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&B,&A);\n\trep(i,1,n)\n\t\tscanf(\"%d\",p+i);\n\tans=1e18;\n\trep(i,0,n){\n\t\ttot=0;\n\t\trep(j,1,n)\n\t\t\tpos[p[j]]=j,t[j]=s[j]=0;\n\t\t//printf(\"now %d\\n\",i);\n\t\trep(j,1,i){\n\t\t\tint v=query(pos[j])+pos[j];\n\t\t\t//printf(\"%d %d\\n\",j,v);\n\t\t\tif(v!=j)tot+=A,ins(pos[j],1);\n\t\t}\n\t\t_rep(j,n,i+1){\n\t\t\tint v=ask(pos[j])+query(pos[j])+pos[j];\n\t\t\t//printf(\"%d %d\\n\",j,v);\n\t\t\tif(v!=j)tot+=B,add(pos[j],-1);\n\t\t}\n\t\tans=min(ans,tot);\n\t\ttot=0;\n\t\trep(j,1,n)\n\t\t\tpos[p[j]]=j,t[j]=s[j]=0;\n\t\t\n\t\t_rep(j,n,i+1){\n\t\t\tint v=ask(pos[j])+pos[j];\n\t\t\t//printf(\"%d %d\\n\",j,v);\n\t\t\tif(v!=j)tot+=B,add(pos[j],-1);\n\t\t}\n\t\trep(j,1,i){\n\t\t\tint v=query(pos[j])+query(pos[j])+pos[j];\n\t\t\t//printf(\"%d %d\\n\",j,v);\n\t\t\tif(v!=j)tot+=A,ins(pos[j],1);\n\t\t}\n\t\t//printf(\"%lld\\n\",tot);\n\t\tans=min(ans,tot);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=5e3+10;\nint D[N];\nint n,A,B;\nll sol(int idx)\n{\n\tif(idx>=n-1)return 0;\n\tint j=idx;\n\tfor(int i=idx+1;i<n;i++){\n\t\tif(D[i]<D[j])j=i;\n\t}\n\tll res=sol(j+1)+1LL*(j-idx)*A;\n\tint u=D[j];\n\tfor(int i=j;i>idx;i--)D[i]=D[i-1];\n\tres=min(res,sol(idx+1)+B);\n\treturn res;\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"/home/zz7/CFInput\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tll ans=0;\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&D[i]);\n\tcout<<sol(0)<<'\\n';\n\t/*\n\tfor(int i=0;i<n;i++){\n\t\tint j=0;\n\t\tfor(;j<i;j++)if(D[j]>D[i])break;\n\t\tif(j!=i)ans+=min(1LL*A*(i-j),1LL*B);\n\t\tint u=D[i];\n\t\tfor(int k=i;k>j;k--)D[k]=D[k-1];\n\t\tD[j]=u;\n\t}cout<<ans<<'\\n';*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = 5005;\nint n, a, b;\nint p[maxn];\n\nbool read() {\n  if (scanf(\"%d%d%d\", &n, &a, &b) < 3) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &p[i]);\n    p[i]--;\n  }\n  return true;\n}\n\nlong long dp[maxn][maxn];\n\nvoid solve() {\n  for (int i = 0; i <= n; i++) {\n    dp[0][i] = 0;\n    dp[i][0] = 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    int mx = -1;\n    int cnt = 0;\n    for (int j = 0; j < n; j++) {\n      if (p[j] < i) {\n        if (mx == -1 || p[j] > p[mx]) {\n          mx = j;\n          cnt = 0;\n        } else {\n          cnt++;\n        }\n      }\n      auto &cur = dp[i][j + 1];\n      if (mx == -1) {\n        cur = 0;\n        continue;\n      }\n      if (cnt == 0) {\n        cur = dp[i][mx];\n        continue;\n      }\n      cur = a + dp[p[mx]][j + 1];\n      cur = min(cur, dp[i][mx] + (long long) b * cnt);\n    }\n  }\n  printf(\"%lld\\n\", dp[n][n]);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * \tThe way if it's all predetermined\n * \t\tAnd the way i should go all my life\n * \t\t\tI swear to go wherever will be\n * \t\t\t\t'Cause there'll be something to see and to find\n * \tI don't know the meaning of life\n * \t\tBut i know what's truly precious\n * \t\t\tThe way it's leading me to be in love\n * \t\t\t\tNo fear i can find me always in my heart\n * \tThe life it's not for comparing things\n * \t\tSo i hold both of light and shadow\n * \t\t\tThe rays of stars will bring me to you\n * \t\t\t\tThrought the dark night skies\n * \t\t\t\t\tSee the way to be shined\n * \tI dont know what's right for our lives\n * \t\tBut i know the truth of my love\n * \t\t\tThe way it feels our breaths at the wind\n * \t\t\t\tAnd the way i should go all my life\n * \t\t\t\t\tI swear to go wherever will be\n * \t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\tWill always in my heart\n * \t\t\t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\t\t\tWill always in my heart\n */\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#ifndef rd\n#define endl '\\n'\n#endif\n#ifdef rd\n#define trace(...) cout<<\"Line:\"<<__LINE__<<\" \"; __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n\tcout<<name<<\" : \"<<arg1<<endl;\n}\ntemplate<typename Arg1, typename ... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n\tconst char* comma=strchr(names+1,',');\n\tcout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";\n\t__f(comma+1,args...);\n}\n#else\n#define trace(...)\n#endif\n#define deb cout<<\"Line: \"<<__LINE__<<\" plz \"\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double f80;\n#define double long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define sz(x) ((long long)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\nconst ll infl=2e18;\nconst int infi=2e9;\nconst int mod=1e9+7;\ntypedef vector<int> vi;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;\nmt19937 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nauto clk=clock();\nint rng(int lim) {\n\tuniform_int_distribution<int> uid(0,lim-1);\n\treturn uid(rang);\n}\n\nint dp[5005][5005];\nint p[5005];\nint peb[5005];\nint bac[5005];\nvoid solve() {\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tfr(i,1,n) {\n\t\tcin>>p[i];\n\t}\n\tfr(i,1,n) {\n\t\tpeb[p[i]]=n+1;\n\t\tfr(j,1,i) {\n\t\t\tif(p[i]<p[j]) {\n\t\t\t\tpeb[p[i]]=min(peb[p[i]],p[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfr(i,1,n) {\n\t\tbac[p[i]]=0;\n\t\tfr(j,i,n) {\n\t\t\tif(p[j]<p[i]) {\n\t\t\t\tbac[p[i]]=max(bac[p[i]],p[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n+1; i++)\n\t\tfill(dp[i],dp[i]+n+2,infl);\n\tdp[0][n+1]=0;\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=n+1; j>1; j--) {\n\t\t\tif(peb[i+1]>=j) {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\t} else {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n\t\t\t}\n\t\t\tif(bac[j-1]<=i) {\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\t} else\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]+a);\n\t\t}\n\t}\n//\tcout<<dp[]\n\tint ans=infl;\n\tfor(int i=0; i<=n; i++) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tif(i+1>=j)\n\t\t\t\tans=min(ans,dp[i][i+1]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::high_resolution_clock::now().time_since_epoch().count());\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t\tsolve();\n#ifdef rd\n\tcerr<<endl<<endl<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define qwq(x) cerr<<\"# \"<<#x<<\" = \"<<x<<endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=5005;\nconst ll inf=1e18;\nint s[N][N],a[N],n,m,A,B;\nll f[N][N],ans;\n\nint S(int l,int r,int d,int u){\n\treturn l>r?0:s[r][u]-s[l-1][u]-s[r][d-1]+s[l-1][d-1];\n}\n\nint main(){\n\tread(n),read(A),read(B);\n\trep(i,1,n)read(a[i]),s[i][a[i]]=1;\n\trep(i,1,n)rep(j,1,n)\n\t\ts[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];\n\tans=(ll)min(A,B)*(n-1);\n\tmemset(f,0x3f,sizeof f);\n\ta[0]=1,f[0][0]=0;\n\trep(i,1,n){\n\t\trep(j,0,i-1)\n\t\t\tif(f[i-1][j]<inf){\n\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\t\tif(a[j]<=a[i]){\n\t\t\t\t\tf[i][i]=min(f[i][i],f[i-1][j]\n\t\t\t\t\t\t\t+(ll)A*S(j+1,i-1,a[j],n)\n\t\t\t\t\t\t\t+(ll)B*S(j+1,i-1,1,a[i]));\n\t\t\t\t}\n\t\t\t}\n\t\tans=min(ans,f[i][i]\t+(ll)A*S(i+1,n,a[i],n)\n\t\t\t\t\t\t\t+(ll)B*S(i+1,n,1,a[i]));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll n, a, b, dp[5010][5010], p[5010], ans;\nint main(void){\n    // Your code here!\n    cin >> n >> a >> b;\n    for (int i = 0; i < n; i++) cin >> p[i];\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 1; j < p[i]; j++)\n        {\n            dp[i + 1][j] = dp[i][j] + a;\n        }\n        dp[i + 1][p[i]] = dp[i][0];\n        for (int j = 1; j < p[i]; j++)\n        {\n            dp[i + 1][p[i]] = min(dp[i][j], dp[i + 1][p[i]]);\n        }\n        for (int j = p[i] + 1; j <= n; j++)\n        {\n            dp[i + 1][j] = dp[i][j] + b;\n        }\n    }\n    ans = 1000000000000;\n    for (int i = 1; i <= n; i++)\n    {\n        ans = min(dp[n][i], ans);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5005;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nll dp[MAXN][MAXN]; int n, f, b;\nint a[MAXN], l[MAXN], r[MAXN];\nint main() {\n\tread(n), read(f), read(b);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tl[a[i]] = n + 1, r[a[i]] = 0;\n\t\tfor (int j = 1; j <= i - 1; j++)\n\t\t\tif (a[j] > a[i]) chkmin(l[a[i]], a[j]);\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tif (a[j] < a[i]) chkmax(r[a[i]], a[j]);\n\t}\n\tfor (int len = 2; len <= n; len++)\n\tfor (int i = 1, j = len; j <= n; i++, j++) {\n\t\tif (l[i] > j) dp[i][j] = dp[i + 1][j];\n\t\telse if (r[j] < i) dp[i][j] = dp[i][j - 1];\n\t\telse dp[i][j] = min(dp[i + 1][j] + b, dp[i][j - 1] + f);\n\t}\n\twriteln(dp[1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 5e3 + 5;\n\nint P[N], C[N][N], M[N][N];\nll DP[N][N];\n// C[i][j] : # k : i <= k <= j && A[i] > A[k] \n// M[i][j] : index maximum A[k] <= j && k <= i\n// DP[i][j] : answer for first i element and numbers less than j\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tint n, A, B; cin >> n >> A >> B;\n\tfor (int i = 1; i <= n; i++) cin >> P[i];\n\tfor (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) C[i][j] = C[i][j - 1] + (P[i] > P[j]);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) M[i][j] = (P[i] <= j && P[i] > P[M[i - 1][j]]) ?  i : M[i - 1][j];\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\tif (!M[i][j]) continue;\n\t\tDP[i][j] = min(A + DP[i][P[M[i][j]] - 1], DP[M[i][j] - 1][j] + 1LL * C[M[i][j]][i] * B);\n\t}\n\tcout << DP[n][n] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define bp __builtin_popcountll\n#define pb push_back\n#define in(s) freopen(s, \"r\", stdin);\n#define out(s) freopen(s, \"w\", stdout);\n#define inout(s, end1, end2) freopen((string(s) + \".\" + end1).c_str(), \"r\", stdin),\\\n\t\tfreopen((string(s) + \".\" + end2).c_str(), \"w\", stdout);\n#define fi first\n#define se second\n#define bw(i, r, l) for (int i = r - 1; i >= l; i--)\n#define fw(i, l, r) for (int i = l; i < r; i++)\n#define fa(i, x) for (auto i: x)\nusing namespace std;\nconst int mod = 1e9 + 7, inf = 1061109567;\nconst long long infll = 4557430888798830399;\nconst int N = 5005;\nint n, a[N], dp[N][N][2], pos[N], A, B;\nsigned main() {\n\t#ifdef BLU\n\tin(\"blu.inp\");\n\t#endif\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> A >> B;\n\tfw (i, 0, n) {\n\t\tcin >> a[i], a[i]--;\n\t\tpos[a[i]] = i;\n\t}\n\tmemset(dp, 63, sizeof dp);\n\tdp[0][0][0] = 0;\n\tfw (i, 0, n) fw (j, 0, n + 1) fw (k, 0, 2) {\n\t\t//i - 1 was in segment j - 1...j, including j - 1. Was j - 1 filled?\n\t\tdp[i][j + 1][0] = min(dp[i][j + 1][0], dp[i][j][k]);\n\t\tif (pos[i] == j - 1) {\n\t\t\tint cost = 0;\n\t\t\tif (k) cost = A;\n\t\t\tdp[i + 1][j][1] = min(dp[i + 1][j][1], dp[i][j][k] + cost);\n\t\t} else if (pos[i] >= j) {\n\t\t\tdp[i + 1][j][1] = min(dp[i + 1][j][1], dp[i][j][k] + B);\n\t\t} else if (pos[i] < j - 1) {\n\t\t\tdp[i + 1][j][1] = min(dp[i + 1][j][1], dp[i][j][k] + A);\n\t\t}\n\t}\n\tint ans = infll;\n\tfw (j, 0, n + 1) fw (k, 0, 2) ans = min(ans, dp[n][j][k]);\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint n;\nll a, b;\nint p[5000];\n\nll dp[5001][5001];\n\n// smin, smax {{{\ntemplate < class T, class U >\ninline void smin(T &a, const U &b) {\n  a = a < (T) b ? a : b;\n}\ntemplate < class T, class U >\ninline void smax(T &a, const U &b) {\n  a = a < (T) b ? b : a;\n}\n// }}}\n\nconstexpr ll inf = 1e18;\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> a >> b;\n  for(int i = 0; i < n; i++) cin >> p[i];\n  for(int i = 0; i <= n; i++) for(int j = 0; j <= n; j++) dp[i][j] = inf;\n \n  dp[0][0] = 0;\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j <= n; j++) {\n      if(j < p[i]) {\n        smin(dp[i + 1][p[i]], dp[i][j]);\n        smin(dp[i + 1][j], dp[i][j] + a);\n      } else {\n        smin(dp[i + 1][j], dp[i][j] + b);\n      }\n    }\n  }\n\n  ll ans = inf;\n\n  for(int j = 0; j <= n; j++) smin(ans, dp[n][j]);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vector<long long> > vvll;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n#define INF 1000000000\n#define MOD 1000000007\n#define EPSILON 0.00001\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define p_q priority_queue\n\n#define FOR(i, a, b) for (int i=(a); i<=(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 5005\nint n;\nll a, b;\nint p[MN];\nint cpy[MN];\nll cst;\n\nvoid shf(int l, int r, int amt){ //amt = amt right, so i -> i+amt\n    int rnj = (r-l)+1; //(i-l)%rnj+l\n    amt = (amt+rnj)%rnj; //so i can do -1\n\n    memcpy(cpy, p, sizeof cpy);\n    /*cout << \"cpy: \";\n    FOR(i, 1, n){\n        cout << cpy[i] << \" \";\n    }\n    cout << \"\\n\";*/\n\n    FOR(i, l, r){\n        int cl = (i+amt-l)%rnj+l;\n        //cout << \"cl is \" << cl << \"\\n\";\n\n        p[cl] = cpy[i];\n    }\n}\n\nint main(){\n    //ios_base::sync_with_stdio(false);\n    //cin.tie(NULL);\n\n    cin >> n >> a >> b;\n    FOR(i, 1, n){\n        cin >> p[i];\n    }\n    FOR(i, 1, n){\n        if(p[i] == i) continue;\n\n        int iind = find(p, p+n, i)-p;\n        //cout << i << \" found at \" << iind << \"\\n\";\n        /*if(iind == i+1){\n            int lst = i+1;\n            while(lst < n && (p[lst+1] == p[lst]+1)) lst++;\n            //cout << \"last val is \" << lst << \"\\n\";\n            int dist = (lst-i)+1;\n            ll ccst = min(b*(dist-1), a);\n            cst+=ccst;\n            shf(i, lst, -1);\n        } else{\n            int dist = (iind-i)+1;\n            ll ccst = min(a*(dist-1), b);\n            cst += ccst;\n            shf(i, iind, 1);\n        }*/\n        int lst = iind;\n        while(lst < n && (p[lst+1] == p[lst]+1)) lst++;\n        //cout << \"last is \" << lst << \"\\n\";\n        int totd = (lst-i)+1;\n        int lshd = (iind-i);\n        ll ccst = min(a*lshd, b*(totd-lshd));\n        cst += ccst;\n        //cout << \"shifting \" << i << \" \" << lst << \" \" << -lshd << \"\\n\";\n        shf(i, lst, -lshd);\n\n        /*FOR(i, 1, n){\n            cout << p[i] << \" \";\n        }\n        cout << \"\\n\";*/\n    }\n\n    cout << cst << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,a,b;\nll mem[5005][5005];\nint p[5005], pos[5005];\nll dp(int id, int cur){\n    if (mem[id][cur] != -1) return mem[id][cur];\n    if (id == 0) return mem[id][cur] = 0;\n    if (pos[id] > cur) {\n        //printf(\"%d at %d needs to move to %d, cost %d\\n\",id,pos[id],cur,b);\n        return mem[id][cur] = dp(id-1,cur)+b; ///move id to cur.\n    }\n    //printf(\"%d at %d, can move to %d, cost %d\\n\",id,pos[id],cur,a);\n    return mem[id][cur] =  min(dp(id-1,pos[id]),dp(id-1,cur)+a);;\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for (int i = 1; i <= n; i++){\n        scanf(\"%d\",&p[i]);\n        pos[p[i]] = i;\n    }\n    memset(mem,-1,sizeof(mem));\n    printf(\"%lld\",dp(n,n));\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\n\nll cost[5100][5100];\n// cost first i elements, cur max\n\nint main(){\n\tint n;\n\tcin >> n;\n\tll a, b;\n\tcin >> a >> b;\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> p[i];\n\t}\n\tif(a > b){\n\t\tswap(a, b);\n\t\treverse(p.begin(), p.end());\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tp[i] = n + 1 - p[i];\n\t\t}\n\t}\n\tfor(int i = 0; i < 5100; i++) for(int j = 0; j < 5100; j++) cost[i][j] = 1e17;\n\tcost[0][0] = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tif(cost[i][j] >= ll(1e17)) continue;\n\t\t\tif(p[i] >= j){\n\t\t\t\tcost[i+1][j] = min(cost[i+1][j], cost[i][j] + a);\n\t\t\t\tcost[i+1][p[i]] = min(cost[i+1][p[i]], cost[i][j]);\n\t\t\t}\n\t\t\tcost[i+1][j] = min(cost[i+1][j], cost[i][j] + b);\n\t\t}\n\t}\n\tll ans = 1e17;\n\tfor(int j = 0; j <= n; j++){\n\t\tans = min(ans, cost[n][j]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing PII = pair<int, int>;\nusing TI3 = tuple<int, int, int>;\nusing LL = long long;\nusing ULL = unsigned long long;\nusing MAT = array<array<LL, 2>, 2>;\n\ntemplate<class T> constexpr inline T begin(const T&) {return 0;}\ntemplate<class T> constexpr inline T end(const T& x) {return max(T(0), x);}\n\n#define SZ(x) int((x).size())\n#define PB push_back\n#define EB emplace_back\n#define GET_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define CHECK(a,b) static_assert(std::is_same<decltype(a), decltype(b)>::value, \"REP diff types\");\n\n#define REPPP(i,s,c,t) for(i; ((s) and (c)) or (putchar(\"\\n \"[c]) and (c)); (t))\n#define REPP2(i,n) REPPP(auto i=begin(n),i==begin(n),i!=end(n),++i)\n#define REPP3(i,m,n) CHECK(m,n) REPPP(auto i=(m),i==(m),i<(n),++i)\n#define REPP4(i,m,n,s) CHECK(m,n) REPPP(auto i=(m),i==(m),((s)>0 and i<(n)) or ((s)<0 and i>(n)),i+=(s))\n#define REPP(...) GET_MACRO(__VA_ARGS__, REPP4, REPP3, REPP2)(__VA_ARGS__)\n\n#define REP2(i,n) for(auto i=begin(n);i!=end(n);++i)\n#define REP3(i,m,n) CHECK(m,n) for(auto i=(m);i<(n);++i)\n#define REP4(i,m,n,s) CHECK(m,n) for(auto i=(m);((s)>0 and i<(n)) or ((s)<0 and i>(n));i+=(s))\n#define REP(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2)(__VA_ARGS__)\n\ntemplate<class T> void _read(T &x) {cin >> x;}\nvoid _read(size_t &x) {scanf(\"%zu\", &x);}\nvoid _read(int &x) {scanf(\"%d\", &x);}\nvoid _read(LL &x) {scanf(\"%lld\", &x);}\nvoid _read(ULL &x) {scanf(\"%llu\", &x);}\nvoid _read(double &x) {scanf(\"%lf\", &x);}\nvoid _read(char &x) {scanf(\" %c\", &x);}\nvoid _read(char *x) {scanf(\"%s\", x);}\nvoid read() {}\ntemplate<class T, class... U>\nvoid read(T& head, U&... tail) {\n    _read(head);\n    read(tail...);\n}\n\ntemplate<class T> void _print(const T &x) {cout << x;}\nvoid _print(const size_t &x) {printf(\"%zu\", x);}\nvoid _print(const int &x) {printf(\"%d\", x);}\nvoid _print(const LL &x) {printf(\"%lld\", x);}\nvoid _print(const ULL &x) {printf(\"%llu\", x);}\nvoid _print(const double &x) {printf(\"%.16lf\", x);}\nvoid _print(const char &x) {putchar(x);}\nvoid _print(const char *x) {printf(\"%s\", x);}\nvoid _print(const string &x) {printf(\"%s\", x.c_str());}\ntemplate<class T> void _print(const vector<T> &x) {\n    for(auto i = x.begin(); i != x.end(); _print(*i++)) {\n        if (i != x.cbegin()) putchar(' ');\n    }\n}\nvoid print() {putchar('\\n');}\ntemplate<class T, class... U> void print(const T& head, const U&... tail) {\n    _print(head);\n    if(sizeof...(tail)) putchar(' ');\n    print(tail...);\n}\n\n\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define INF 0x3f3f3f3f\n\nconst int MOD = 1000000007;\n\n//}}}\n#define MAX_N 5005\n\nint q[MAX_N];\nLL dp[MAX_N][MAX_N];\n\nint main()\n{\n    int N, A, B;\n    read(N, A, B);\n    REP(i, 1, N + 1) {\n        int k;\n        read(k);\n        q[k] = i;\n    }\n\n    REP(i, 1, N + 1) {\n        LL m = LLINF;\n        REP(j, N + 1) {\n            m = min(m, dp[i - 1][j]);\n\n            LL cost;\n            if(q[i] == j) {\n                cost = 0;\n            } else if(q[i] < j) {\n                cost = A;\n            } else {\n                cost = B;\n            }\n            dp[i][j] = m + cost;\n            //_print(dp[i][j]);\n        }\n    }\n    LL ans = LLINF;\n    REP(j, N + 1) {\n        ans = min(ans, dp[N][j]);\n    }\n    print(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 5002;\n\nint a[MX], l[MX][MX], r[MX][MX];\nlong long dp[MX];\n\nint main() {\n\tint n, A, B;\n\tignore = scanf(\"%d %d %d\", &n, &A, &B);\n\tfor (int i = 1; i <= n; i++) ignore = scanf(\"%d\", a + i);\n\t\n\tn += 2;\n\ta[n - 1] = n - 1;\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i][i] = 0;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tl[i][j] = l[i][j - 1] + (a[j] < a[i] ? 1 : 0);\n\t\t}\n\t\t\n\t\tr[i][i] = 0;\n\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\tr[j][i] = r[j + 1][i] + (a[j] > a[i] ? 1 : 0);\n\t\t}\n\t}\n\t\n\tdp[0] = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tdp[i] = 1e16;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (a[j] < a[i] && l[j][i] + r[j][i] == i - j - 1)\n\t\t\t\tdp[i] = min(dp[i], dp[j] + l[j][i] * 1LL * B + r[j][i] * 1LL * A);\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n - 1]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 5000;\nll dp[N][N];\nint x[N];\n\ninline void up(ll &x, ll y) { if (y < x)x = y; }\n\nint main(){\n\tint n, a, b;\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tf(i, 0, n)scanf(\"%d\", x + i);\n\tf(i, 0, n)f(j, i, n)dp[i][j] = 1e18;\n\tdp[0][n - 1] = 0;\n\tdeque<int> q0(x, x + n);\n\tf(i, 0, n){\n\t\tdeque<int> q = q0;\n\t\tfor (int j = n - 1; j > i; --j){\n\t\t\twhile (q.front() <= i || q.front() > j + 1)q.pop_front();\n\t\t\twhile (q.back() > j + 1 || q.back() <= i)q.pop_back();\n\t\t\tup(dp[i + 1][j], dp[i][j] + (i + 1 == q.front() ? 0 : b));\n\t\t\tup(dp[i][j - 1], dp[i][j] + (j + 1 == q.back() ? 0 : a));\n\t\t}\n\t}\n\tll an = 1e18;\n\tf(i, 0, n)up(an, dp[i][i]);\n\tprintf(\"%lld\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n#define mod 1000000007\n#define N 5005\nusing namespace std;\n\ntypedef long long ll;\n\nll n, A, B, a[N], yer[N], dp[N][N];\n\nll f(ll ind, ll x){\n\tll &r = dp[ind][x];\n\tif(r != -1)\n\t\treturn r;\n\tif(ind == n + 1)\n\t\treturn 0;\n\tll ek = (yer[ind] > x)? B : (yer[ind] < x) ? A : 0;\n\tr = f(ind + 1, x) + ek;\n\tif(yer[ind] > x)\n\t\tr = min(r, f(ind + 1, yer[ind]));\n\t// cout << ind << \" \" << x << \" = \" << r << endl;\n\treturn r;\n}\n\nint main() {\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n\n\tmemset(dp, -1, sizeof dp);\n\n\tscanf(\"%lld %lld %lld\",&n ,&A ,&B);\n\n\tfor(ll i = 1; i <= n; i++){\n\t\tscanf(\"%lld\",a + i);\n\t\tyer[a[i]] = i;\n\t}\n\n\tprintf(\"%lld\\n\", f(1, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEBUG\n#include \"better_io.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\nconstexpr int MAXN = 5042;\n\nint N, A, B;\nint V[MAXN];\nint pos[MAXN];\nint le[MAXN];\nll gt[MAXN][MAXN];\nll dp[MAXN][MAXN];\n\nll solve(int i, int x) {\n\tif(i >= N-1) return 0;\n\tif(x >= N-1) return 0;\n\tif(dp[i][x] != -1) return dp[i][x];\n\tdp[i][x] = min(solve(i, x + 1) + B, solve(pos[x] + 1, le[pos[x]+1  ]) + A * gt[i][pos[x]]);\n\treturn dp[i][x];\n}\n\nint main() {\n\tmemset(dp, -1, sizeof dp);\n    memset(le, 0x3f3f3f, sizeof le);\n    \n\tcin >> N >> A >> B;\n\n\tfor(int i=0; i<N; i++) {\n\t\tcin >> V[i];\n\t\tV[i]--;\n\t\tpos[V[i]] = i;\n\t}\n\n    for(int i=N-1; i>=0; i--) {\n        le[i] = min(V[i], le[i+1]);\n    }\n\n\tfor(int j=0; j<N; j++) {\n\t\tfor(int i=j-1; i>=0; i--) {\n\t\t\tgt[i][j] = gt[i+1][j] + (V[i] > V[j]);\n\t\t}\n\t}\n\n\tcout << solve(0, 0) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nint n, p[5010], pos[5010];\nll A, B, ans;\n\nint main() {\n    scanf(\"%d %lld %lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) if (p[j] == i) {\n            ans += min(A * (j - i), B);\n            if (A * (j - i) > B) {\n                for (int k = j; k > i; k--) p[k] = p[k - 1];\n                p[i] = i;\n            } else {\n                for (int k = i; k < j; k++) {\n                    pos[k - i + 1] = k;\n                }\n                for (int k = j - i; k; k--) {\n                    int num = p[pos[k]];\n                    for (int t = pos[k]; t < num; t++) p[t] = p[t + 1];\n                    p[num] = num;\n                }\n            }\n            break;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n#include <iterator>\n#include <cmath>\n#include <stack>\n#include <random>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  ll n, a, b; cin >> n >> a >> b;\n  vector<int> p(n);\n  rep(i, n) {\n    int pos; cin >> pos;\n    pos--;\n    p[pos] = 2*i+1;\n  }\n\n  int k = 2*n+1;\n  vector<ll> dp(k);\n\n  rep(i, n) {\n    ll mi = LLONG_MAX;\n    rep(j, k) {\n      chmin(mi, dp[j]);\n      if (j < p[i]) {\n        dp[j] = mi+b;\n      } else if (j == p[i]) {\n        dp[j] = mi;\n      } else {\n        dp[j] = mi+a;\n      }\n    }\n  }\n\n  ll ans = LLONG_MAX;\n  rep(i, k) {\n    chmin(ans, dp[i]);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 998244353ll;\nconst ll MAXN = (ll) 5e3 + 100;\nconst ll INF = (ll) 9223372036854775;\nconst ld EPS = (ld) 1e-8;\n\nll a[MAXN], dp[MAXN], ind[MAXN];\nvector<ll> w1[MAXN], w2[MAXN];\n\nll BS1(ll ind, ll x){\n\tll l = -1, r = w1[ind].size();\n\tll mid;\n\twhile(l + 1 < r){\n\t\tmid = (l + r) / 2;\n\t\tif(w1[ind][mid] < x) l = mid;\n\t\telse r = mid;\n\t}\n\treturn r;\n}\n\nll BS2(ll ind, ll x){\n\tll l = -1, r = w2[ind].size();\n\tll mid;\n\twhile(l + 1 < r){\n\t\tmid = (l + r) / 2;\n\t\tif(w2[ind][mid] < x) l = mid;\n\t\telse r = mid;\n\t}\n\treturn w2[ind].size() - r;\n}\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tll n, A, B;\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t\tind[a[i]] = i;\n\t}\n\t\n\tmemset(dp, 31, sizeof dp);\n\tdp[0] = 0;\n\ta[0] = -1;\n\tll ans = n * A;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tw1[i].pb(a[j]);\n\t\t}\n\t\tfor(int j = i + 1; j<=n; j++) w2[i].pb(a[j]);\n\t\tsort(all(w1[i]));\n\t\tsort(all(w2[i]));\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tll ca = 0;\n\t\tll cb = 0;\n\t\tfor(int j = i - 1; j > 0; j--){\n\t\t\tif(a[j] < a[i]){\n\t\t\t\tll cnt = BS1(j, a[i]) - BS1(j, a[j]);\n\t\t\t\tdp[i] = min(dp[i], dp[j] + cnt * A + ((a[i] - a[j] - 1) - cnt) * B);\n\t\t\t}\n\t\t\tif(j == 0) break;\n\t\t}\n\t\tdp[i] = min(dp[i], B * (a[i] - 1));\n\t\tans = min(ans, dp[i] + (n - a[i]) * A);\n\t\t//debug(dp[i]);debug(i);\n\t}\n\tcout << ans;\n \t\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 5e3 + 10;\nconst long long max_val = 1LL << 62;\n\nlong long dp[maxn][maxn * 2];\nint p[maxn];\n\nlong long cost(int p1, int p2, int A, int B) {\n    if (p1 * 2 - 1 == p2) return 0;\n    else if (p1 * 2 - 1 > p2) return B;\n    else return A;\n}\n\nint main()\n{\n    int N, A, B;\n    cin >> N >> A >> B;\n    for (int i = 1; i <= N; i++) {\n        cin >> p[i];\n    }\n    for (int i = 1; i <= N; i++) for (int j = 0; j < 2 * N; j++) dp[i][j] = max_val;\n    //dp[i][j] = min{dp[i - 1][k] + (p[i] != k) * (A | B)}\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j < 2 * N; j++) {\n            int tail = (j % 2 == 0 ? j + 1 : j);\n            for (int k = 0; k < tail; k++) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + cost(p[i], k, A, B));\n            }\n        }\n    }\n    long long res = max_val;\n    for (int j = 0; j < 2 * N; j++) res = min(res, dp[N][j]);\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#define MAXN 5005\n#define P 998244353\n#define G 3\n#define INF 0x3f3f3f3f\n#define rint register int\n#define LL long long\n#define LD long double\n#define fuck printf(\"FUCK!!\\n\");\nusing namespace std;\n\nint n, a, b, num[MAXN];\nLL ans=1e18, f[MAXN][MAXN];\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &a, &b);\n    for(rint i=1; i<=n; ++i) scanf(\"%d\", &num[i]);\n    memset(f, 0x3f, sizeof(f));\n    for(rint i=1; i<=n; ++i) f[0][i]=0;\n    for(rint i=1; i<=n; ++i)\n        for(rint j=1; j<=n; ++j)\n        {\n            if(num[i]>=j)\n            {\n                f[i][num[i]]=min(f[i][num[i]], f[i-1][j]);\n                f[i][j]=min(f[i][j], f[i-1][j]+a);\n            }\n            else f[i][j]=min(f[i][j], f[i-1][j]+b);\n        }\n    for(rint i=1; i<=n; ++i) ans=min(ans, f[n][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " /*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n\nusing namespace std;\ntemplate<typename T1, typename T2> inline void chkmin(T1 &a, T2 b) {if (a > b) a = b;}\ntemplate<typename T1, typename T2> inline void chkmax(T1 &a, T2 b) {if (a < b) a = b;}\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define all(c) (c).begin(), (c).end()\n#define sz(c) (int)(c).size()\n#define left left228\n#define right right228\n#define y1 y1228\n#define mp update_pair\n#define pb push_back\n#define y2 y2228\nconst string FILENAME = \"input\";\nconst int MAXN = 5005;\n\n\nint n, a, b;\nint p[MAXN];\nint where[MAXN];\nlong long dp[MAXN][MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n  \t//read(FILENAME);\n\tcin >> n >> a >> b;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> p[i];\n\t\twhere[p[i]] = i;\n\t}\n\tfor (int i = n; i >= 1; i--) {\n\t\tint curmi = 1e9, curmx = -1;\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tchkmin(curmi, where[j]);\n\t\t\tchkmax(curmx, where[j]);\n\t\t\tif (i == j) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = 1e18;\n\t\t\t\tif (curmi == where[i]) {\n\t\t\t\t\tchkmin(dp[i][j], dp[i + 1][j]);\n\t\t\t\t} else {\n\t\t\t\t\tchkmin(dp[i][j], dp[i + 1][j] + b);\n\t\t\t\t}\n\t\t\t\tif (curmx == where[j]) {\n\t\t\t\t\tchkmin(dp[i][j], dp[i][j - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tchkmin(dp[i][j], dp[i][j - 1] + a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[1][n] << '\\n';\n\treturn 0; \t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nll INF = 1000000000000000000;\n\nint main(int argc, char const *argv[]) {\n  ll n, A, B;std::cin >> n >> B >> A;\n  vll p(n);re(i, n) scanf(\"%lld\", &p[i]);\n  vll comb(n+1), rcomb(n+1);\n  vll idx(n+1);\n  for(int i=0;i<n;i++) idx[p[i]] = i;\n  for(int i=0;i<n;i++){\n    ll cnt = 0;\n    for(int j=i;j<n;j++, cnt++) if(p[j]!=p[i]+cnt) break;\n    comb[p[i]] = cnt;\n    cnt = 0;\n    for(int j=i;j>=0;j--, cnt++) if(p[j]!=p[i]-cnt) break;\n    rcomb[p[i]] = cnt;\n  }\n  vvl tento = VV(n+1, n+2, 0, ll); //iの左側かつj以上の値の数\n  vvl rtento = VV(n+1, n+2, 0, ll); //iの右側かつj以下の値の数\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(p[i]>p[j]){\n        tento[p[j]][p[i]]++;\n        rtento[p[i]][p[j]]++;\n      }\n    }\n  }\n  for(int i=0;i<=n;i++) for(int j=n-1;j>=0;j--) tento[i][j] += tento[i][j+1];\n  for(int i=0;i<=n;i++) for(int j=1;j<=n;j++) rtento[i][j] += rtento[i][j-1];\n\n\n  vvl dp = VV(n+1, n+1, INF, ll);\n  dp[0][0] = 0;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=i;j++){\n      if(dp[i][j]==INF) continue;\n      ll x = comb[j+1], y = comb[n-(i-j)];\n      x = min(x, n-i);\n      y = min(y, n-i);\n      ll L = tento[j+1][j+1] - tento[j+1][n-(i-j)+1];\n      ll R = rtento[n-(i-j)][n-(i-j)] - rtento[n-(i-j)][j];\n      //左詰め\n      dp[i+x][j+x] = min({dp[i+x][j+x],\n        dp[i][j]+A*x, dp[i][j]+B*L});\n      //右詰め\n      dp[i+y][j] = min({dp[i+y][j],\n        dp[i][j]+B*y, dp[i][j]+A*R});\n    }\n  }\n  ll ans = 1000000000000000000;\n  for(int i=0;i<=n;i++) ans = min(ans, dp[n][i]);\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N; long long A, B;\n\nint p[5005];\nint rev[5005];\nlong long dp[2][5005];\n\nint main(){\n    scanf(\"%d%lld%lld\", &N, &A, &B);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &p[i]);\n        rev[p[i]] = i;\n    }\n\n    for(int j = 1; j <= N+1; j ++){\n        dp[0][j] = 0;\n    }\n\n    for(int i = 1; i <= N; i ++){\n        long long ans = 1LL << 61;\n        for(int j = 1; j <= N+1; j ++){\n            if(j < rev[i]){\n                ans = min(ans, B + dp[(i-1)&1][j]);\n            }else if(j == rev[i]){\n                ans = min(ans, dp[(i-1)&1][j]);\n            }else{\n                ans = min(ans, A + dp[(i-1)&1][j]);\n            }\n\n            dp[i&1][j] = ans;\n        }\n    }\n\n    printf(\"%lld\", dp[N&1][N+1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n#define LL long long\n\nint n;\nLL a,b;\nint p[5000];\nLL score[5001][5001];\nint left_[5000][5000],right_[5000][5000];\n\nint main(){\n  cin>>n>>a>>b;\n  REP(i,n){cin>>p[i];p[i]--;}\n\n  REP(i,n){\n    left_[i][i]=0;\n    FOR(j,1,i+1){\n      left_[i][i-j]=(p[i-j]<p[i])?left_[i][i-j+1]:left_[i][i-j+1]+1;\n    }\n  }\n\n  REP(i,n){\n    right_[i][i]=0;\n    FOR(j,1,n-i){\n      right_[i][i+j]=(p[i+j]>p[i])?right_[i][i+j-1]:right_[i][i+j-1]+1;\n    }\n  }\n\n  \n  FOR(del,1,n+1){\n    REP(i,n+1-del){\n      if(del==1){\n\tscore[i][i+del]=0LL;\n      }else{\n\tscore[i][i+del]=min(score[i][i+del-1]+min(b,a*left_[i+del-1][i]),score[i+1][i+del]+min(a,b*right_[i][i+del-1]));\n      }\n    }\n  }\n  /*\n  REP(i,n){\n    REP(j,n+1){\n      cerr<<score[i][j]<<\" \";\n    }\n    cerr<<endl;\n  }\n  */\n  cout<<score[0][n]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nlong A,B,L[5555],R[5555];\nint p[5555];\nmain()\n{\n\tcin>>n>>A>>B;\n\tfor(int i=0;i<n;i++)cin>>p[i];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong c=0;\n\t\tL[i]=9e18;\n\t\tfor(int j=i;j--;)\n\t\t{\n\t\t\tif(p[j]>p[i])\n\t\t\t{\n\t\t\t\tc+=A;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tL[i]=min(L[i],L[j]+c);\n\t\t\t\tc+=B;\n\t\t\t}\n\t\t}\n\t\tL[i]=min(L[i],c);\n\t}\n\tfor(int i=n;i--;)\n\t{\n\t\tlong c=0;\n\t\tR[i]=9e18;\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tif(p[j]>p[i])\n\t\t\t{\n\t\t\t\tR[i]=min(R[i],R[j]+c);\n\t\t\t\tc+=A;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc+=B;\n\t\t\t}\n\t\t}\n\t\tR[i]=min(R[i],c);\n\t}\n\tlong ans=9e18;\n\tfor(int i=0;i<n;i++)ans=min(ans,L[i]+R[i]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define maxn 5001\n#define inf 1000000000000000000\nll p[maxn], pos[maxn], dp[maxn][maxn];\nusing namespace std;\nint main()\n{\n    ll n, a, b, ans=inf;\n    cin>>n>>a>>b;\n    for(int i=1; i<=n; i++) cin>>p[i], pos[p[i]]=i;\n    memset(dp, 1000000, sizeof dp);\n    dp[0][0]=0;\n    for(int i=1; i<=n; i++){\n        for(int j=0; j<i; j++){\n            if(pos[i]>pos[j]){\n                dp[i][i]=min(dp[i-1][j], dp[i][i]);\n                dp[i][j]=dp[i-1][j]+b;\n            }\n            else dp[i][j]=dp[i-1][j]+a;\n        }\n    }\n    for(int i=1; i<=n; i++) ans=min(ans, dp[n][i]);\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll n,L,R;\nvl a;\n\nint main(){\n\tcin>>n>>R>>L;\n\ta=vl(n);\n\tfor(auto &i:a) cin>>i;\n\tif(L<R){\n\t\tswap(L,R);\n\t\treverse(a.begin(),a.end());\n\t}\n\tvl dp(n+1,INF);\n\tdp[0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tll x=a[i];\n\t\tvl DP(n+1,INF);\n\t\tDP[0]=0;\n\t\tfor(int j=0;j<x;j++) DP[x]=min(DP[x],dp[j]);\n\t\tfor(int j=0;j<=n;j++) if(j!=x) DP[j]=dp[j]+(j<x?R:L);\n\t\tdp=DP;\n\t}\n\tll res=INF;\n\tfor(int i=0;i<=n;i++) res=min(res,dp[i]);\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 1000000000000000000LL\nusing namespace std;\n#define Maxn 5007\nint n,a,b;\nint p[Maxn],pos[Maxn];\nint mx[Maxn][16],mn[Maxn][16];\nint bin[Maxn];\nlong long f[Maxn][Maxn];\nint get_max(int lx,int rx)\n{\n    int k=bin[rx-lx+1];\n    return max(mx[lx][k],mx[rx-(1<<k)+1][k]);\n}\nint get_min(int lx,int rx)\n{\n    int k=bin[rx-lx+1];\n    return min(mn[lx][k],mn[rx-(1<<k)+1][k]);\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for (int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&p[i]);\n        pos[p[i]]=i;\n    }\n    bin[1]=0;\n    for (int i=2;i<=n;i++)\n        bin[i]=bin[i/2]+1;\n    for (int i=1;i<=n;i++)\n        mx[i][0]=pos[i],mn[i][0]=pos[i];\n    for (int k=1;k<=15;k++)\n        for (int i=1;i<=n;i++)\n        {\n            mx[i][k]=mx[i][k-1];\n            if (i+(1<<(k-1))<=n) mx[i][k]=max(mx[i][k],mx[i+(1<<(k-1))][k-1]);\n            mn[i][k]=mn[i][k-1];\n            if (i+(1<<(k-1))<=n) mn[i][k]=min(mn[i][k],mn[i+(1<<(k-1))][k-1]);\n        }\n    for (int i=1;i<=n;i++)\n        for (int j=i;j<=n;j++)\n            f[i][j]=inf;\n    for (int i=1;i<=n;i++)\n        f[i][i]=0LL;\n    for (int len=1;len<n;len++)\n        for (int i=1;i+len<=n;i++)\n        {\n            int j=i+len;\n            if (pos[j]>get_max(i,j-1)) f[i][j]=min(f[i][j],f[i][j-1]); else f[i][j]=min(f[i][j],f[i][j-1]+a);\n            if (pos[i]<get_min(i+1,j)) f[i][j]=min(f[i][j],f[i+1][j]); else f[i][j]=min(f[i][j],f[i+1][j]+b);\n        }\n    printf(\"%lld\\n\",f[1][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ll N, A, B;\n  cin >> N >> A >> B;\n  vector<ll> A;\n  A.push_back(0);\n  for(int i = 0; i < N; i++) {\n    ll a;\n    cin >> a;\n    A.push_back(a);\n  }\n  A.push_back(N + 1);\n  N = A.size();\n  vector<ll> dp(N, 1LL << 62);\n  dp[0] = 0;\n  for(int i = 0; i < N; i++) {\n    ll acc = 0;\n    for(int j = i - 1; j >= 0; j--) {\n      if (A[j] < A[i]) {\n        dp[i] = min(dp[i], dp[j] + acc);\n        acc += B;\n      } else {\n        acc += A;\n      }\n    }\n  }\n  cout << dp.back() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 5200\nusing namespace std;\nlong long f[N][N];\nint p[N],a[N];\nint n,l,r;\nint main(){\t\n\tscanf(\"%d%d%d\",&n,&r,&l);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)p[a[i]]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tlong long now=f[i-1][0];\n\t\tfor(int j=0;j<=n+1;j++){\n\t\t\tnow=min(now,f[i-1][j]);\n\t\t\tif(p[i]+1>j)f[i][j]=now+l;\n\t\t\telse if(p[i]+1==j)f[i][j]=now;\n\t\t\telse f[i][j]=now+r;\n\t\t}\n\t}\n\tlong long ans=1000000000000000000LL;\n\tfor(int i=0;i<=n+1;i++)ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * \tThe way if it's all predetermined\n * \t\tAnd the way i should go all my life\n * \t\t\tI swear to go wherever will be\n * \t\t\t\t'Cause there'll be something to see and to find\n * \tI don't know the meaning of life\n * \t\tBut i know what's truly precious\n * \t\t\tThe way it's leading me to be in love\n * \t\t\t\tNo fear i can find me always in my heart\n * \tThe life it's not for comparing things\n * \t\tSo i hold both of light and shadow\n * \t\t\tThe rays of stars will bring me to you\n * \t\t\t\tThrought the dark night skies\n * \t\t\t\t\tSee the way to be shined\n * \tI dont know what's right for our lives\n * \t\tBut i know the truth of my love\n * \t\t\tThe way it feels our breaths at the wind\n * \t\t\t\tAnd the way i should go all my life\n * \t\t\t\t\tI swear to go wherever will be\n * \t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\tWill always in my heart\n * \t\t\t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\t\t\tWill always in my heart\n */\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#ifndef rd\n#define endl '\\n'\n#endif\n#ifdef rd\n#define trace(...) cout<<\"Line:\"<<__LINE__<<\" \"; __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n\tcout<<name<<\" : \"<<arg1<<endl;\n}\ntemplate<typename Arg1, typename ... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n\tconst char* comma=strchr(names+1,',');\n\tcout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";\n\t__f(comma+1,args...);\n}\n#else\n#define trace(...)\n#endif\n#define deb cout<<\"Line: \"<<__LINE__<<\" plz \"\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double f80;\n#define double long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define sz(x) ((long long)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\nconst ll infl=2e18;\nconst int infi=2e9;\nconst int mod=1e9+7;\ntypedef vector<int> vi;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;\nmt19937 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nauto clk=clock();\nint rng(int lim) {\n\tuniform_int_distribution<int> uid(0,lim-1);\n\treturn uid(rang);\n}\n\nint dp[5005][5005];\nint n;\nint p[5005];\nint peb[5005];\nint bac[5005];\nvoid solve() {\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tfr(i,1,n) {\n\t\tcin>>p[i];\n\t}\n\tfr(i,1,n) {\n\t\tpeb[p[i]]=n+1;\n\t\tfr(j,1,i) {\n\t\t\tif(p[i]<p[j]) {\n\t\t\t\tpeb[p[i]]=min(peb[p[i]],p[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfr(i,1,n) {\n\t\tbac[p[i]]=0;\n\t\tfr(j,i+1,n) {\n\t\t\tif(p[j]<p[i]) {\n\t\t\t\tbac[p[i]]=max(bac[p[i]],p[j]);\n\t\t\t}\n\t\t}\n\t}\n//\tfr(i,1,n) {\n//\t\tcout<<peb[i]<<\" \";\n//\t}\n//\tcout<<endl;\n//\tfr(i,1,n) {\n//\t\tcout<<bac[i]<<\" \";\n//\t}\n//\tcout<<endl;\n\n\tfor(int i=0; i<=n+1; i++)\n\t\tfill(dp[i],dp[i]+n+2,infl);\n\tdp[0][n+1]=0;\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=n+1; j>1; j--) {\n\t\t\tif(peb[i+1]>=j) {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\t} else {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n\t\t\t}\n\t\t\tif(bac[j-1]<=i) {\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\t} else\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]+a);\n\t\t}\n\t}\n//\tcout<<dp[]\n\tint ans=infl;\n\tfor(int i=0; i<=n; i++) {\n\t\tans=min(ans,dp[i][i+1]);\n\t}\n\tcout<<ans<<endl;\n}\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::high_resolution_clock::now().time_since_epoch().count());\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t\tsolve();\n#ifdef rd\n\tcerr<<endl<<endl<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 5e5 + 5;\nconst int maxm = 1e7 + 5;\n\nconst int mod = 1e9 + 7;\nint n , A , B;\nint pos[maxn];\nint m = 0;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\"))\n        freopen(taskname\".INP\",\"r\",stdin),\n        freopen(taskname\".OUT\",\"w\",stdout);\n    cin >> n >> A >> B;swap(A,B);\n    vector<int> a(n);\n    for(auto & c : a){\n        cin >> c;\n        --c;\n    }\n    ll res = 1e18;\n    for(int i = 0 ; i <= n - 1 ; ++i){\n        for(int j = 0 ; j < n ; ++j){\n            pos[a[j]] = j;\n        }\n        int tot = 0;\n        int cur = -1;\n        for(int j = 0 ; j < n ; ++j){\n            if(pos[j] < cur){\n                tot++;\n            }else cur = pos[j];\n//            cout << a[j] << \" \";\n        }\n        res = min(res,1ll*A*i+1ll * tot * B);\n//        cout << pos[0] << \" \" << tot << endl;\n        for(int j = 0 ; j < n ; ++j)pos[a[i]] = i;\n        int fix = -1;\n        for(int j = 0 ; j < n ; ++j){\n            if(a[j] != j){\n                fix = j;break;\n            }\n        }\n        if(fix == -1)break;\n        a.erase(a.begin()+pos[fix]);\n        a.insert(a.begin()+fix,fix);\n    }\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\n#define Mod 1000000007\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\n#define INF 1ll<<59\n\nint main(){\n  ll i,j;\n  ll n,a,b;\n  cin>>n>>b>>a;\n  ll p[n+1];\n  for(i=0;i<n;i++) cin>>p[i];\n  p[n]=n+1;\n  vector<ll> dp(n+1,INF);\n\n  dp[0]=0;\n  for(i=1;i<=n;i++){\n    ll tmp=0;\n    for(j=i-1;j>=0;j--){\n      if(p[j]>p[i]) tmp+=b;\n      else {\n        dp[i]=min(dp[i],dp[j]+tmp);\n        tmp+=a;\n      }\n    }\n    dp[i]=min(dp[i],tmp);\n  }\n  cout<<dp[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N, A, B;\n    cin >> N >> A >> B;\n\n    vi vals(N), loc(N);\n    for (int i = 0; i < N; i++) {\n        cin >> vals[i];\n        loc[vals[i] - 1] = i;\n    }\n\n    vvll dp(N + 1, vll(N + 1, LLONG_MAX));\n    dp[0][0] = 0;\n\n    auto put_min = [&](ll &a, ll b) {\n        a = min(a, b);\n    };\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= N; j++) {\n            if (dp[i][j] == LLONG_MAX) continue;\n\n            if (loc[i] < j) {\n                put_min(dp[i+1][j], dp[i][j] + A);\n            } else if (loc[i] >= j) {\n                put_min(dp[i+1][j], dp[i][j] + B);\n                put_min(dp[i+1][loc[i]+1], dp[i][j]);\n            }\n        }\n    }\n\n    ll ans = LLONG_MAX;\n    for (ll v : dp[N])\n        ans = min(ans, v);\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n\nint main() {\n    int N; cin >> N;\n    ll a[300100]; FOR(i, 0, 3 * N) cin >> a[i];\n\n    priority_queue<ll> pque_front;\n    priority_queue<ll, vector<ll>, greater<ll>> pque_back;\n\n    ll ans = -1e14;\n\n    FOR(i, N , 2 * N ){\n\n        ll sum = 0;\n\n        FOR(j, 0, N) {\n            sum += a[j];\n            pque_front.push(a[j]);\n        }\n\n        FOR(j, N , i) {\n            pque_front.push(a[j]);\n            sum += a[j];\n        }\n\n        FOR(j, N, i) {\n            sum -= pque_front.top();\n            pque_front.pop();\n        }\n\n        FOR(j, 2 * N , 3 * N) {\n            sum -= a[j];\n            pque_back.push(a[j]);\n        }\n\n        FOR(j, i, 2 * N) {\n            sum -= a[j];\n            pque_back.push(a[j]);\n        }\n\n        FOR(j, i, 2 * N) {\n            sum += pque_back.top();\n            pque_back.pop();\n        }\n\n        ans = max(ans, sum);\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 5e3 + 5;\nconst ll INF = 1e14;\n\nll dp [MAX_N][MAX_N];\nint arr [MAX_N];\nll premin [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  ll A, B;\n  cin >> A >> B;\n\n  for (int i = 1; i <= n; i++) {\n    cin >> arr[i];\n  }\n\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= n; j++) {\n      dp[i][j] = INF;\n    }\n  }\n  dp[0][0] = 0;\n  \n  for (int i = 1; i <= n; i++) {\n    premin[0] = dp[i - 1][0];\n    for (int j = 1; j <= n; j++) {\n      premin[j] = min(premin[j - 1], dp[i - 1][j]);\n    }\n    \n    for (int j = 0; j <= n; j++) {\n      if (arr[i] < j) {\n\tdp[i][j] = dp[i - 1][j] + B;\n      } else if (arr[i] == j) {\n\tdp[i][j] = premin[j - 1];\n      } else if (arr[i] > j) {\n\tdp[i][j] = dp[i - 1][j] + A;\n      }\n    }\n  }\n\n  ll ans = INF;\n  for (int j = 1; j <= n; j++) {\n    ans = min(ans, dp[n][j]);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nLL N, A, B;\nint P[5001];\nint inv[5001];\nLL DP[5002][5001];\nint main() {\n\tcin >> N >> A >> B;\n\tREP(i, 0, N) {\n\t\tcin >> P[i];\n\t\tinv[P[i]] = i;\n\t}\n\tP[N] = N + 1;\n\n\tFill(DP, INFLL);\n\tREP(i, 0, N + 1) {\n\t\tDP[i][0] = 0;\n\t}\n\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 2) {\n\t\t\tif (j == P[i]) {\n\t\t\t\tLL mn = INFLL;\n\t\t\t\tREP(k, 0, j) {\n\t\t\t\t\tint pos = k == 0 ? -1 : inv[k];\n\t\t\t\t\tif (pos >= i) continue;\n\n\t\t\t\t\tint Lcost = 0;\n\t\t\t\t\tREP(q, pos, i) {\n\t\t\t\t\t\tif (P[q] > k) ++Lcost;\n\t\t\t\t\t}\n\t\t\t\t\tint Rcost = 0;\n\t\t\t\t\tREP(q, i, N) {\n\t\t\t\t\t\tif (P[q] > k && P[q] < j) ++Rcost;\n\t\t\t\t\t}\n\n\t\t\t\t\tmn = min(mn, DP[i][k] + Lcost * A + Rcost * B);\n\t\t\t\t}\n\t\t\t\tDP[i + 1][j] = mn;\n\t\t\t} else {\n\t\t\t\tDP[i + 1][j] = DP[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[N + 1][N + 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define LLINF ((long long) 1e18)//1234567890987654321\n#define INF 1234567890ll\n#define pb push_back\n#define ins insert\n#define f first\n#define s second\t\n#define db 0\n#define EPS (1e-7)    //0.0000001 the value\n#define PI (acos(-1))\n#define MAXN (300006)/3\n#define MAXK 26\n#define MAXX 15000006\n#define ll long long int \n#define ld long double\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\n#define FOR(ii, ss, ee) for(ll ii = ss; ii < ee; ++ii)\n#define space \" \"\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ((ll)x.size())\n#define ph push\n#define btinpct(x) __builtin_popcountll(x)\n#define p2(x) (1LL<<(x))\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\ntypedef pair <ll, ll> pi;\ntypedef pair <ll, pi> spi;\ntypedef pair <pi, pi> dpi;\ninline ll rand(ll x, ll y) { ++y; return (rng() % (y-x)) + x; } //inclusivesss\nll n,a,b,A[5002],dp[5002], prev_dp[5002], at[5002], co[5002];\n\nint main()\n{\n\tFAST\n\tcin>>n>>a>>b;\n\tfor(ll i=1;i<=n;++i){cin>>A[i];at[A[i]]=i;}\n\tFOR(k,1,n+1) {\n\t\tmmst(dp,0);\n\t\tll p = at[k];\n\t\tfor(ll i=1;i<p;i++)  dp[i] = prev_dp[i];\n\t\tfor(ll i=p;i<=n;i++) {\n\t\t\tdp[i] = min((i==p?LLINF:prev_dp[i]+a), prev_dp[p-1] + b * (co[i] - co[p]));\n\t\t}\n\t\tfor(ll i=p;i<=n;i++) co[i] += 1;\n\t\tswap(dp,prev_dp);\n\t}\n\tcout<<prev_dp[n]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 320000\nusing namespace std;\nint n,A,B;\nint L[N],R[N];\nlong long f[5200][5200]; \nint a[5200];\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif(n==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ta[x]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++)if(a[j]<a[i]){L[i]=j;break;}\n\t\tfor(int j=i-1;j>=1;j--)if(a[j]>a[i]){R[i]=j;break;}\n\t}\n\tmemset(f,0x4f,sizeof(f));\n\tf[0][n+1]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=n+1;j>i;j--){\n\t\t\tif(L[i]<j)f[i+1][j]=min(f[i][j]+B,f[i+1][j]);\n\t\t\telse f[i+1][j]=min(f[i][j],f[i+1][j]);\n\t\t\tif(R[j]>i)f[i][j-1]=min(f[i][j]+A,f[i][j-1]);\n\t\t\telse f[i][j-1]=min(f[i][j],f[i][j-1]);\n\t\t}\n\t}\n\tlong long ans=100000000000000LL;\n\tfor(int i=0;i<=n;i++)ans=min(ans,f[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 100000000000000000;\n\nll dp[5002][5002];\n\nint main()\n{\n    int n;\n    ll a, b;\n    cin >> n >> a >> b;\n    int p[5002], q[5002];\n    for(int i = 0; i < n; i++){\n        cin >> p[i];\n        p[i]--;\n        q[p[i]] = i;\n    }\n    int left[5002], right[5002];\n    fill(left, left + n, n);\n    fill(right, right + n, -1);\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < q[i]; j++){\n            if(p[j] > i) left[i] = min(left[i], p[j]);\n        }\n        for(int j = q[i] + 1; j < n; j++){\n            if(p[j] < i) right[i] = max(right[i], p[j]);\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++) dp[i][j] = INF;\n    }\n    dp[0][0] = 0;\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; i + j <= n; j++){\n            if(i){\n                if(left[i - 1] >= n - j) dp[i][j] = min(dp[i][j], dp[i - 1][j]);\n                else dp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n            }\n            if(j){\n                if(right[n - j] < i) dp[i][j] = min(dp[i][j], dp[i][j - 1]);\n                else dp[i][j] = min(dp[i][j], dp[i][j - 1] + a);\n            }\n        }\n    }\n    ll ans = INF;\n    for(int i = 0; i <= n; i++) ans = min(ans, dp[i][n - i]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (2)\n#include<cstdio>\n#include<cstring>\n#define int long long\n#define rep(i, a, b) for (register int i=(a); i<=(b); ++i)\n#define per(i, a, b) for (register int i=(a); i>=(b); --i)\nusing namespace std;\ntypedef long long ll;\ninline void chkmax(int &x, int y){x<y?(x=y):0;}\ninline void chkmin(int &x, int y){x>y?(x=y):0;}\nconst int N=5005;\nint dp[N][N], a[N];\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*f;\n}\n\nsigned main()\n{\n\tint n=read(), A=read(), B=read(), ans=1ll<<60;\n\trep(i, 1, n) a[i]=read();\n\tmemset(dp, 0x3f, sizeof(dp)); dp[0][0]=0;\n\trep(i, 1, n) rep(j, 0, n)\n\t\tif (a[i]>j) \n\t\t\tchkmin(dp[i][j], dp[i-1][j]+A), \n\t\t\tchkmin(dp[i][a[i]], dp[i-1][j]);\n\t\telse\n\t\t\tchkmin(dp[i][j], dp[i-1][j]+B);\n\trep(i, 0, n) chkmin(ans, dp[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nint main() {\n  int N, A, B;\n  cin >> N >> A >> B;\n  vector< int > P(N + 2);\n  for(int i = 1; i <= N; i++) {\n    cin >> P[i];\n  }\n  P[0] = 0, P[N + 1] = N + 1;\n\n  vector< int > po(N + 2);\n  for(int i = 0; i < P.size(); i++) po[P[i]] = i;\n\n  vector< int64 > dp(N + 2, infll);\n  dp[0] = 0;\n\n  for(int i = 1; i <= N + 1; i++) {\n    vector< int64 > dp2(N + 2, infll);\n    int64 sm = infll;\n    for(int j = 0; j <= N + 1; j++) {\n      chmin(sm, dp[j]);\n      if(po[i] == j) chmin(dp2[j], sm);\n      else if(po[i] > j) chmin(dp2[j], sm + B);\n      else chmin(dp2[j], sm + A);\n    }\n    dp.swap(dp2);\n  }\n  cout << dp[N + 1] << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=5100;\nint n,A,B,p[N],mx[N][N],mn[N][N];\nll dp[N][N],inf;\nlong long dfs(int l,int r)\n{\n\tlong long &v=dp[l][r];\n\tif(v!=inf) return v;\n\tif(l==r) return v=0;\n\tif(p[l]<mn[l+1][r]) v=min(v,dfs(l+1,r));\n\telse v=min(v,dfs(l+1,r)+A);\n\tif(p[r]>mx[l][r-1]) v=min(v,dfs(l,r-1));\n\telse v=min(v,dfs(l,r-1)+B);\n\tfor(int i=l;i<r;i++)\n\t\tif(mx[l][i]<mn[i+1][r])\n\t\t\tv=min(v,dfs(l,i)+dfs(i+1,r));\n//\tprintf(\"dp[%d][%d]=%lld\\n\",l,r,dp[l][r]);\n\treturn v;\n}\nint v1[N],v2[N],pos[N];\nvoid Min(ll &a,ll b) {if(b<a) a=b;}\nvoid DP()\n{\n\tdp[0][0]=0;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;i+j<n;j++)\n\t\t{\n\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\t\tMin(dp[i][j+1],dp[i][j]+(v2[pos[n-j]]<=i?0:A));\n\t\t\tMin(dp[i+1][j],dp[i][j]+(v1[pos[i+1]]>=n-j+1?0:B));\n\t\t}\n\tll Ans=inf;\n\tfor(int i=0;i<=n;i++)\n\t\tMin(Ans,dp[i][n-i]);\n\tcout<<Ans<<endl;\n\texit(0);\n}\nint main()\n{\n\tcin>>n>>A>>B;\n\tmemset(dp,63,sizeof(dp));inf=dp[0][0];\n\tfor(int i=1;i<=n;i++) cin>>p[i],pos[p[i]]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tv2[i]=1e9;\n\t\tfor(int j=1;j<i;j++) if(p[i]<p[j]) v1[i]=min(v1[i],p[j]);\n\t\tfor(int j=i+1;j<=n;j++) if(p[i]>p[j]) v2[i]=max(v2[i],p[j]);\n\t\tprintf(\"v1[%d]=%d,v2[%d]=%d\\n\",i,v1[i],i,v2[i]);\n\t}\n//\tcout<<dfs(1,n)<<endl;\n\tDP();\n\tfor(int i=1;i<=n;i++) dp[i][i]=0;\n\tfor(int len=1;len<=n;len++)\n\t{\n\t\tfor(int l=1;l<=n-len+1;l++)\n\t\t{\n\t\t\tint r=l+len-1;\n\t\t\tll &v=dp[l][r];\n\t\t\tif(v==inf) continue;\n//\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",l,r,v);\n\t\t\tif(r<n)\tMin(dp[l][r+1],v+(mx[l][r]<p[r+1]?0:B));\n\t\t\tif(l>1)\tMin(dp[l-1][r],v+(mn[l][r]>p[l-1]?0:A));\n\n\t\t\tint L=1,R=min(n-r,len-1),p=0;\n\t\t\twhile(L<=R)\n\t\t\t{\n\t\t\t\tint mid=(L+R)>>1;\n\t\t\t\tif(mn[r+1][r+mid]>mx[l][r]) L=mid+1,p=mid;\n\t\t\t\telse R=mid-1;\n\t\t\t}\n//\t\t\tif(l==1&&r==7) printf(\"p=%d\\n\",p);\n\t\t\tif(p) Min(dp[l][r+p],dp[l][r]+dp[r+1][r+p]);\n\n\t\t\tL=1,R=min(l-1,len),p=0;\n\t\t\twhile(L<=R)\n\t\t\t{\n\t\t\t\tint mid=(L+R)>>1;\n\t\t\t\tif(mx[l-mid][l-1]<mn[l][r]) L=mid+1,p=mid;\n\t\t\t\telse R=mid-1;\n\t\t\t}\n\t\t\tif(p) Min(dp[l-p][r],dp[l-p][l-1]+dp[l][r]);\n\t\t}\n\t}\n\tcout<<dp[1][n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nll INF = 1000000000000000000;\nint main(int argc, char const *argv[]) {\n  ll n, A, B;std::cin >> n >> A >> B;\n  vll p(n);re(i, n) scanf(\"%lld\", &p[i]);\n  vll idx(n+1); for(int i=0;i<n;i++) idx[p[i]] = i+1;\n  vvl dp = VV(n+1, 2*n+2, INF, ll);\n\n  vll prev(2*n+2, 0);\n  for(int i=1;i<=n;i++){\n    for(int j=1;j<2*n+2;j++){\n      if(j==2*idx[i]){\n        dp[i][j] = min(dp[i][j], prev[j-1]);\n      }else if(j%2==0){\n        dp[i][j] = min(dp[i][j], prev[j-1]+ (j<2*idx[i]?B:A));\n      }else{\n        dp[i][j] = min(dp[i][j], prev[j] + (j<2*idx[i]?B:A));\n      }\n    }\n    for(int j=0;j<2*n+2;j++) prev[j] = INF;\n    for(int j=1;j<2*n+2;j++) prev[j] = min(prev[j-1], dp[i][j]);\n  }\n\n  ll ans = INF;\n  for(int i=1;i<2*n+2;i++) ans = min(ans, dp[n][i]);\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N; long long A, B;\n\nint p[5005];\nint rev[5005];\nlong long dp[5005][5005];\n\nint main(){\n    scanf(\"%d%lld%lld\", &N, &A, &B);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &p[i]);\n        rev[p[i]] = i;\n    }\n\n    for(int j = 1; j <= N+1; j ++){\n        dp[0][j] = 0;\n    }\n\n    for(int i = 1; i <= N; i ++){\n        long long ans = 1LL << 61;\n        for(int j = 1; j <= N+1; j ++){\n            if(j < rev[i]){\n                ans = min(ans, B + dp[i-1][j]);\n            }else if(j == rev[i]){\n                ans = min(ans, dp[i-1][j]);\n            }else{\n                ans = min(ans, A + dp[i-1][j]);\n            }\n\n            dp[i][j] = ans;\n        }\n    }\n\n    printf(\"%lld\", dp[N][N+1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 1000001;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) *b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\n\n///////////////////////////\n\n\n\n\nint main() {\n\tll N, A, B;\n\tcin >> N >> A >> B;\n\n\tvector<ll> p(N + 1,0);\n\trepn(i, N) cin >> p[i];\n\n\tvector<vector<ll>> dp(N + 1, vector<ll>(N + 1, INF));\n\n\tdp[0][0] = 0;\n\t\n\trepn(i, N) {\n\t\tdp[i][0] = dp[i - 1][0] + A;\n\n\t\trepn(j, i - 1) {\n\t\t\tif (p[i] > p[j]) { dp[i][j] = dp[i - 1][j] + A; }\n\t\t\telse { dp[i][j] = dp[i - 1][j] + B; }\n\t\t}\n\n\t\trep(j, i) {\n\t\t\tif (p[i] > p[j]) { dp[i][i] = min(dp[i - 1][j], dp[i][i]); }\n\t\t}\n\t}\n\n\tll ans = INF;\n\trep(i, N + 1) {\n\t\tans = min(ans, dp[N][i]);\n\t}\n\n\tcout << ans;\n\t\n\t\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define pb push_back\n#define X first\n#define Y second\n\n#define SZ(a) ((LL)(a).size())\n#define all(a) (a).begin(),a.end()\n#define forn(i, n) for(LL i = 0; i < n; ++i)\n#define ALL(x) x.begin(), x.end()\n#define ll long long\n#define MAXN 100\n#define INF 1000 * 1000 * 1000\n#define LINF INF * (LL)INF;\nint n , m , A , B;\nint a[5005];\nint de[5005];\nLL dpT[5005][5005];\nint inL [5005];\nint inR [5005];\nint freeL = -1, freeR = n;\nint dp(int l , int r , int freeL , int freeR)\n{\n\tif(l == r)\n\t\treturn 0;\n\tif(dpT[l][r] != -1)\n\t\treturn dpT[l][r];\n\tLL ans = LINF;\n\tint newFreeL = freeL;\n\tint newFreeR = freeR;\n\twhile(newFreeL < n && (a[newFreeL + 1] < l || a[newFreeL + 1] > r))\n\t{\n\t\tnewFreeL++;\n\t}\n\twhile(newFreeR > -1 && (a[newFreeR - 1] > r || a[newFreeR - 1] < l))\n\t{\n\t\tnewFreeR--;\n\t}\n\tLL cost = B , cost2 = A;\n\tif(newFreeL >= 0 && a[newFreeL] == l || newFreeR < n && a[newFreeR] == l)\n\t{\n\t\tcost = 0;\n\t}\n\tif(newFreeL >= 0 && a[newFreeL] == l || newFreeR < n && a[newFreeR] == r)\n\t{\n\t\tcost2 = 0;\n\t}\n\tans = min(ans , cost + dp(l + 1 , r , newFreeL , newFreeR));\n\tans = min(ans , cost2 + dp(l  , r - 1 , newFreeL , newFreeR));\n\treturn dpT[l][r] = ans;\n}\nint main()\n{\n\tmemset(dpT , -1 , sizeof dpT);\n\tcin >> n >> A >> B;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\n\tcout << dp(1 , n , -1 , n + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n#define int LL\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 5005;\nint a[MAXN];\nint f[MAXN][MAXN];\n\nsigned main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, A, B; read(n), read(A), read(B);\n  for (RI i = 1; i <= n; ++i) read(a[i]);\n  memset(f, 0x3f, sizeof(f));\n  f[0][0] = 0;\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 0; j <= n; ++j)\n      if (a[i] > j) {\n        f[i][j] = min(f[i][j], f[i - 1][j] + A);\n        f[i][a[i]] = min(f[i][a[i]], f[i - 1][j]);\n      }\n      else {\n        f[i][j] = min(f[i][j], f[i - 1][j] + B);\n      //  f[i][a[i]] = min(f[i][a[i]], f[i - 1][j] + A);\n      }\n  int ans = 0x7f7f7f7f7f7f7f7f;\n  for (RI i = 0; i <= n; ++i)\n    ans = min(ans, f[n][i]);\n  printf(\"%lld\\n\", ans);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=s;i<t;i++)\ntypedef long long ll;\nconst ll inf=1e18;\nll dp[2][5555];int num[5555];\nint main()\n{\n    int n,a,b;scanf(\"%d%d%d\",&n,&a,&b);\n    rep(i,1,n+1)scanf(\"%d\",&num[i]);\n    rep(i,1,n+1)dp[0][i]=inf;\n    int type=1;dp[0][0]=0;\n    rep(i,1,n+1)\n    {\n        rep(i,0,n+1)dp[type][i]=1e18;\n        rep(j, 0, n+1)if(dp[!type][j]!=inf)\n        {\n            if(num[i]<j)dp[type][j]=min(dp[type][j],dp[!type][j]+b);\n            else dp[type][j]=min(dp[type][j],dp[!type][j]+a),dp[type][num[i]]=min(dp[type][num[i]],dp[!type][j]);\n        }\n        type=!type;\n    }\n    ll res=inf;\n    rep(i,1,n+1)res=min(res,dp[!type][i]);\n    printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "/*----------------by syr----------------*/\n/*\n\n         iii                  ii\n     rBQBBBBBBE       BBR iBBBBQBBL     XBBBBBBQBBBBB\n   iBBQJ    7BBB      BBsSBBr   BBQ      i      cBBB\n  rBBU       iBBw     BBBQi     HBBi           KBBi\n  BBH         BB5    iBBB       isL          wBB5\n GBB         iBBi    6BB                   iBBB\n BBQ         BQB     BBD                  QBBi\n BBB        BQB     iQBi                1BBv\n sBBg     wBBB      QBB               iBBB\n  7BBBBBBBBBi       BBR              wBBBBBBBBBBBBB\n     irvi           ii               ii    i i iii\n                i5U\n               BBB\n               BB7\n              1BB\n      iPBBBBBKBBR    JBR1       rQBO   BR  UBQP  iBBQi\n    7BBBGs7sXBBBi     QBBr     gBBE   rBB BB2BB7HBZQBB\n   QBBi      sBQ       BBB   iBBB     SQBBR  BBBB  cBQ\n  gBQ        BBg        BBB KBBi      MBBH   BBB   BBs\n iBBv       iBBi         QBBBL        BBR   pBB   iBB\n pBB        BBB         iBBBB        iBB    BBL   KBB\n MBB       BBBR        BBB JBBi      DBR   iBQ    BBL\n GBB     7BBBB2      PBBH   BBBi     BQr   DBB   iBB\n  BQBXwgBBP BB7    1BBB      BBQ7   1BB    BBc   BBB\n   2BBBBw   BB    EBBS        QBBi  HBa   iBB    BB7\n*/\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i,x,y) for(int i=(x);i<(y);++i)\n#define REP(i,x,y) for(int i=(x);i<=(y);++i)\n#define x0 x0123456789\n#define y0 y0123456789\n#define x1 x1234567890\n#define y1 y1234567890\n#define x2 x2345678901\n#define y2 y2345678901\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst ll INF=1e18+7;\nconst int maxn=5e3+5;\n\nint n;\nint a[maxn],pos[maxn];\nll f[maxn][maxn],g[maxn][maxn];\nll A,B;\n\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tREP(i,1,n) scanf(\"%d\",a+i),pos[a[i]]=i;\n\tREP(i,1,n) REP(j,0,n) g[i][j]=INF;\n\tREP(i,1,n) REP(j,1,n){\n\t\tf[i][j]=g[i-1][j];\n\t\tif(j>pos[i]) f[i][j]+=A;\n\t\telse if(j<pos[i]) f[i][j]+=B;\n\t\tg[i][j]=min(g[i][j-1],f[i][j]);\n\t}\n\t//REP(i,1,n){\n\t\t//REP(j,1,n) printf(\"%lld \",f[i][j]);\n\t\t//puts(\"\");\n\t//}\n\tprintf(\"%lld\\n\",g[n][n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSR(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nll A,B;\nint p[5005];\nvector<P>vec;\nll up[5005],dw[5005];\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t}\n\tint cur = -1;\n\tint pre = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i == 1){\n\t\t\tcur = p[i];\n\t\t}\n\t\telse if(cur+1 != p[i]){\n\t\t\tvec.pb(mp(pre+1,i-1));\n\t\t\tpre = i-1;\n\t\t\tcur = p[i];\n\t\t}\n\t\telse cur++;\n\t}\n\tvec.pb(mp(pre+1,n));\n\t\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = vec[i].sc-vec[i].fi+1;\n\t\tll R = 0;\n\t\tfor(int j=i+1;j<vec.size();j++){\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] > p[y]){\n\t\t\t\t//need to swap\n\t\t\t\tR += (vec[j].sc-vec[j].fi+1);\n\t\t\t}\n\t\t}\n\t\tdw[i] = min(L*A,R*B);\n\t}\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = 0;\n\t\tll R = vec[i].sc-vec[i].fi+1;\n\t\tfor(int j=i-1;j>=0;j--){\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] < p[y]){\n\t\t\t\t//need to swap\n\t\t\t\tL += (vec[j].sc-vec[j].fi+1);\n\t\t\t}\n\t\t}\n\t\tup[i] = min(L*A,R*B);\n\t}\n\t//cout<<up[0]<<dw[0]<<endl;\n\t//cout<<up[1]<<dw[1]<<endl;\n\tll ans = 1e18;\n\tfor(int i=0;i<=n;i++){\n\t    ll A = 0;\n\t    for(int j=0;j<vec.size();j++){\n\t        if(p[vec[j].fi] <= i) A += up[j];\n\t        else A += dw[j];\n\t    }\n\t    ans = min(ans,A); //cout << A << endl;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n\n\n\n#if 0\nconst int MOD = ;\n\ninline int lgput(int a, int b) {\n    int ans = 1;\n    while(b > 0) {\n        if(b & 1) ans = (1LL * ans * a) % MOD;\n        b >>= 1;\n        a = (1LL * a * a) % MOD;\n    }\n    return ans;\n}\n\ninline void mod(int &x) {\n    if(x >= MOD)\n        x -= MOD;\n}\n\ninline void add(int &x, int y) {\n    x += y;\n    mod(x);\n}\n\ninline void sub(int &x, int y) {\n    x += MOD - y;\n    mod(x);\n}\n\ninline void mul(int &x, int y) {\n    x = (1LL * x * y) % MOD;\n}\n\ninline int inv(int x) {\n    return lgput(x, MOD - 2);\n}\n#endif\n\n#if 0\nint fact[], invfact[];\n\ninline void prec(int n) {\n    fact[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        fact[i] = (1LL * fact[i - 1] * i) % MOD;\n    }\n    invfact[n] = lgput(fact[n], MOD - 2);\n    for(int i = n - 1; i >= 0; i--) {\n        invfact[i] = (1LL * invfact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\ninline int comb(int n, int k) {\n    if(n < k) return 0;\n    return (1LL * fact[n] * (1LL * invfact[k] * invfact[n - k] % MOD)) % MOD;\n}\n#endif\n\nusing namespace std;\n\nconst int MAXN = 5000;\n\nll dp[2][MAXN + 1];\nll mn[2][MAXN + 1];\n\nint main() {\n#if 0\n    ifstream cin(\"A.in\");\n    ofstream cout(\"A.out\");\n#endif\n    int i, j, n, a, b;\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    cin >> n >> a >> b;\n    vector <int> pos(n + 1);\n    for(i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        pos[x] = i;\n    }\n\n    auto get = [&](int x, int y) {\n        if(x == y) return 0;\n        if(x < y) return a;\n        return b;\n    };\n\n    const ll INF = 1e18;\n\n    for(i = 1; i <= n; i++) {\n        for(j = 0; j <= n; j++) {\n            dp[i & 1][j] = INF;\n            mn[i & 1][j] = INF;\n        }\n        for(j = 1; j <= n; j++) {\n            dp[i & 1][j] = mn[1 - i & 1][j] + get(pos[i], j);\n            mn[i & 1][j] = min(dp[i & 1][j], mn[i & 1][j - 1]);\n        }\n    }\n\n    ll ans = INF;\n    for(i = 1; i <= n; i++) {\n        ans = min(ans, dp[n & 1][i]);\n    }\n\n    cout << ans;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=5000 +117;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL dp[NN][NN]={};\nint p[NN]={};\nint a,b;\nint main(){\n\t//open();\n\tn=read();\n\ta=read(),b=read();\n\tfor(int i=1;i<=n;++i)p[i]=read();\n\t\n\tmemset(dp,60,sizeof dp);\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tif(j<p[i]){\n\t\t\t\tdp[i][p[i]]=min(dp[i][p[i]],dp[i-1][j]);\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+b);\n\t\t\t}\n\t\t}\n\t}\n\tLL ans=1e18;\n\tfor(int j=0;j<=n;++j){\n\t\tans=min(dp[n][j],ans);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5010;\ntypedef long long ll;\nll dp[N][N];\nint f[N][N],n,A,B,a[N],b[N];\nint main(){\n\tcin>>n>>A>>B;\n\tfor(int i=1;i<=n;++i)cin>>a[i],b[a[i]]=i;\n\tfor(int i=n;i;--i)\n\t\tfor(int j=1;j<=n;++j)f[i][j]=f[i+1][j]+(a[i]>j);\n\tmemset(dp,0x3f,sizeof dp);memset(dp[n+1],0,sizeof dp[n+1]);\n\tfor(int i=n;i;--i){\n\t\tdp[i][n+1]=0;\n\t\tfor(int j=n;j;--j)\n\t\t\tif(a[i]<j)dp[i][j]=dp[i+1][j];\n\t\t\telse if(b[j]<i)dp[i][j]=dp[i][j+1];\n\t\t\telse{\n\t\t\t\tint u=b[j];\n\t\t\t\tif(u==i)dp[i][j]=dp[i+1][j+1];\n\t\t\t\telse dp[i][j]=min(dp[i][j+1]+B,dp[u+1][j+1]+(ll)A*(f[i][j]-f[u][j]));\n\t\t\t}\n\t}\n\tcout<<dp[1][1]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//constexpr long long MOD = 1000000007;\nconstexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nll dp[5050][5050];\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll N,A,B; cin >> N >> A >> B;\n    vector<int> p(N);\n    rep(i,N) cin >> p[i];\n\n    rep(i,N+1) rep(j,N+1) dp[i][j] = 1e18;\n    dp[0][0] = 0;\n    rep(i,N) {\n        rep(j,N+1) {\n            if (dp[i][j]==1e18) continue;\n            if (j < p[i]) {\n                chmin(dp[i+1][p[i]],dp[i][j]);\n                chmin(dp[i+1][j],dp[i][j]+A);\n            } else {\n                chmin(dp[i+1][j],dp[i][j]+B);\n            }\n\n        }\n    }\n\n    ll ans = 1e18;\n    rep(i,N+1) chmin(ans,dp[N][i]);\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\tlong long A,B;\n\tcin>>n>>A>>B;\n\tvector<int>a(n+2);\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tvector<long long>dp(n+2);\n\tdp[0]=0;\n\tfor(int i=1;i<=n+1;i++){\n\t\tdp[i]=(long long) 1e18;\n\t\tint bigger=0;\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t\tif(a[j]>a[i])\n\t\t\t\tbigger++;\n\t\t\telse{\n\t\t\t\tdp[i]=min(dp[i],dp[j]+bigger*A+(i-1-j-bigger)*B);\n\t\t\t}\n\t}\n\tcout<<dp[n+1]<<endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<int> p(n + 2);\n    for (int i = 1; i <= n; ++i)\n        cin >> p[i];\n    p.back() = n + 1;\n    vector<LL> dp(n + 2, 1E18);\n    dp[0] = 0;\n    for (int i = 1; i <= n + 1; ++i) {\n        for (int j = i - 1, c = 0; j >= 0; --j) {\n            if (p[j] > p[i])\n                ++c;\n            else\n                dp[i] = min(dp[i], dp[j] + 1LL * c * a + 1LL * (i - j - 1 - c) * b);\n        }\n    }\n    cout << dp.back() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\nconst int MAX = 5e3 + 41;\nconst ll INF = 1e18;\n\nint n, A, B;\nint a[MAX];\nint cnt[MAX][MAX];\nll d[MAX][MAX];\nint p[MAX];\n\nint getq(int x, int l, int r) {\n\tint res = cnt[x][r];\n\tif (l > 0) res -= cnt[x][l - 1];\n\treturn res;\n}\n\nvoid solve () {\t\n\tfi(0, n - 1) p[a[i]] = i;\n\tfi(0, n - 1) {\n\t\tint cur = 0;\n\t\tfj(0, n - 1) {\n\t\t\tif (a[j] > i) {\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\tcnt[i][j] = cur;\n\t\t}\n\t}\n\tfill_n(&d[0][0], MAX * MAX, INF);\t\n\td[0][0] = 0;\n\tfi(0, n - 1) {\n\t\tfj(0, n) {\n\t\t\tif (j > p[i]) {\n\t\t\t\td[i + 1][j] = min(d[i + 1][j], d[i][j]);\n\t\t\t}\telse {\n\t\t\t\tint q = getq(i, j, p[i] - 1);\n\t\t\t\tll v1 = d[i][j] + (ll) q * A;\n\t\t\t\tll v2 = d[i][j] + B;\n\t\t\t\td[i + 1][j] = min(d[i + 1][j], v2);\n\t\t\t\td[i + 1][p[i] + 1] = min(d[i + 1][p[i] + 1], v1);\n//\t\t\t\tdbg(v1);\n//\t\t\t\tdbg(v2);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfi(0, n - 1) {\n\t\tfj(0, n - 1) {\n\t\t\terr(\"%d %d %lld\\n\", i, j, d[i][j]);\n\t\t}\n\t}\n\t*/\n\tll ans = INF;\n\tfi(0, n) ans = min(ans, d[n][i]);\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\n\tscanf(\"%d %d %d\", &n, &A, &B);\t\t\n\tfi(0, n - 1) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, j, k) for (int i = j; i < (int)k; i++)\n#define pb push_back\n#define mt make_tuple\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef complex<ld> point;\ntypedef vector<int> vi;\n\ninline void fileIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n\ntemplate <class T, class S>\ninline bool smin(T &a, S b) {\n  return (T)b < a ? a = b, 1 : 0;\n}\ntemplate <class T, class S>\ninline bool smax(T &a, S b) {\n  return a < (T)b ? a = b, 1 : 0;\n}\n\nconstexpr int MOD = 998244353;\nconstexpr int N = 5e3 + 10;\n\ntemplate <typename T>\ninline T mod(T &v) {\n  return v = (v % MOD + MOD) % MOD;\n}\ntemplate <typename S, typename T>\ninline S add(S &l, T r) {\n  return mod(l += r);\n}\nll po(ll v, ll u) {\n  return u ? po(v * v % MOD, u >> 1) * (u & 1 ? v : 1) % MOD : 1;\n}\n\nll n, A, B, p[N], q[N], dp[N][N], psum[N][N];\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n\n#ifndef LOCAL\n  // fileIO(\"superposition\");\n#endif\n\n  cin >> n >> A >> B;\n  rep(i, 0, n) {\n    cin >> p[i];\n    rep(j, p[i] + 1, n + 1) psum[j][i]++;\n    q[p[i]] = i;\n  }\n\n  rep(i, 1, n + 1) partial_sum(psum[i], psum[i] + n + 1, psum[i]);\n\n  for (int i = n - 1; ~i; i--)\n    for (int j = n; j; j--) {\n      if (q[j] < i)\n        dp[i][j] = dp[i][j + 1];\n      else\n        dp[i][j] = min(dp[q[j] + 1][j + 1] +\n                           (q[j] - i - (psum[j][q[j]] - psum[j][i - 1])) * A,\n                       dp[i][j + 1] + B);\n    }\n  cout << dp[0][1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint pos[5010];\nlong long f[2][5010];\nint n;\nint a,b;\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tpos[x]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(i<pos[1])f[1][i]=b;\n\t\telse if(i>pos[1])f[1][i]=a;\n\t\telse f[1][i]=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint now=i&1;\n\t\tint lst=now^1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j<pos[i])\n\t\t\t\tf[now][j]=f[lst][j]+b;\n\t\t\telse if(j==pos[i])\n\t\t\t{\n\t\t\t\tf[now][j]=1e18;\n\t\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t\t\tf[now][j]=min(f[now][j],f[lst][k]);\n\t\t\t}\n\t\t\telse f[now][j]=f[lst][j]+a;\n\t}\n\tlong long ans=1e18;\n\tfor(int i=1;i<=n;i++)\n\t\tans=min(ans,f[n&1][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\n#define N 5010\nll f[N][N]; int a[N];\nvoid upd(ll &x,ll y){x=x<y?x:y;}\nint main()\n{\n\tint n=read(),A=read(),B=read();\n\tfor(int i=1;i<=n;i++)\ta[i]=read();\n\tmemset(f,48,sizeof(f)); f[0][0]=0;\n\tfor(int i=1;i<=n;i++)\tfor(int j=0;j<=n;j++)\n\t\tif(a[i]>j)\tupd(f[i][j],f[i-1][j]+A),upd(f[i][a[i]],f[i-1][j]);\n\t\telse\tupd(f[i][j],f[i-1][j]+B);\n\tfor(int i=1;i<=n;i++)\tupd(f[n][0],f[n][i]);\n\tprintf(\"%lld\\n\",f[n][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vector<long long> > vvll;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n#define INF 100000000000000LL\n#define MOD 1000000007\n#define EPSILON 0.00001\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define p_q priority_queue\n\n#define FOR(i, a, b) for (int i=(a); i<=(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 5005\nint n;\nll a, b;\nint p[MN];\nint inv[MN];\nll dp[MN][MN]; //cost to get the first i to be in order and less than the jth thing\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    memset(dp, 0x3f, sizeof dp);\n\n    cin >> n >> a >> b;\n    FOR(i, 1, n){\n        cin >> p[i];\n        inv[p[i]] = i;\n    }\n\n    dp[0][1] = 0;\n    F0R(i, n){\n        FOR(j, 1, n+1){\n            //cout << \"best ans at \" << i << \" \" << j << \" is \" << dp[i][j] << \"\\n\";\n            int loc = inv[i+1];\n            //cout << \"loc is \" << loc << \"\\n\";\n            if(j <= loc){\n                dp[i+1][loc+1] = min(dp[i+1][loc+1], dp[i][j]);\n            }\n\n            ll val = j <= loc ? b : a;\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j] + val);\n        }\n    }\n    ll mnv = INF;\n    FOR(i, 1, n+1){\n        mnv = min(mnv, dp[n][i]);\n    }\n\n    cout << mnv << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\nconstexpr int kN = int(5E3 + 10);\nconstexpr ll kInf = ll(1E16 + 10);\nll dp[kN][kN];\nint p[kN], low[kN][kN], top[kN][kN];\nint main() {\n\tint n, a, b, lst = 1;\n\tll lcost, rcost, ans = 0;\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &p[i]);\n\tfor (int i = 1; i <= n; i++) dp[i][i] = 0;\n\tfor (int i = 1; i <= n; i++) low[i][i] = top[i][i] = p[i];\n\tfor (int i = 2; i <= n; i++) for (int j = 1; j + i - 1 <= n; j++) {\n\t\tlow[j][j + i - 1] = min(low[j][j + i - 2], p[j + i - 1]);\n\t\ttop[j][j + i - 1] = max(top[j][j + i - 2], p[j + i - 1]);\n\t\tlcost = low[j][j + i - 1] == p[j] ? 0 : a;\n\t\trcost = top[j][j + i - 1] == p[j + i - 1] ? 0 : b;\n\t\tdp[j][j + i - 1] = min(lcost + dp[j + 1][j + i - 1], rcost + dp[j][j + i - 2]);\n\t}\n\tfor (int i = 1; i < n; i++) if (top[lst][i] < low[i + 1][n]) {\n\t\tans += dp[lst][i];\n\t\tlst = i + 1;\n\t}\n\tans += dp[lst][n];\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 5e3 + 5;\n\nlong long dp[N], n, a, b, P[N], S[N][N];\n\nint calc(int L, int R, int l, int r) {\n\tL = max(L, 1); l = max(l, 1);\n\treturn S[R][r] - S[L - 1][r] - S[R][l - 1] + S[L - 1][l - 1];\n}\n\nint main() {\n\tcin >> n >> a >> b;\n\tfor(int i = 1; i <= n; ++ i) cin >> P[i], S[P[i]][i] = 1;\n\tS[n + 1][n + 1] = 1;\n\tP[n + 1] = n + 1;\n\tfor(int i = 1; i <= n + 1; ++ i) {\n\t\tfor(int j = 1; j <= n + 1; ++ j)\n\t\tS[i][j] = S[i - 1][j] + S[i][j - 1] + S[i][j] - S[i - 1][j - 1];\n\t}\n\tfor(int i = 0; i <= n + 1; ++ i) dp[i] = 1e18;\n\tdp[0] = 0;\n\tfor(int i = 0; i <= n; ++ i) {\n\t\tfor(int j = i + 1; j <= n + 1; ++ j) if(P[j] > P[i]) {\n\t\t\t// [P[i] + 1, P[j] - 1], [1, i - 1], [j + 1, n]\n\t\t\tint now = calc(P[i] + 1, P[j] - 1, i + 1, j - 1);\n\t\t\tif(now) continue;\n\t\t\tdp[j] = min(dp[j], dp[i] + calc(1, P[i], i + 1, j - 1) * b + calc(P[j], n, i + 1, j - 1) * a);\n\t\t}\n\t}\n\tcout << dp[n + 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 5010;\n\nint n;\nint pos[N];\nbool fl[N][N], fr[N][N];\nll dp[N][N];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n\n  int a, b; scanf(\"%d%d%d\", &n, &a, &b);\n  for (int i = 1; i <= n; ++i) {\n    int p; scanf(\"%d\", &p);\n    pos[p] = i;\n  }\n  for (int i = 1; i <= n; ++i) {\n    int myn = pos[i], mex = pos[i];\n    for (int j = i; j <= n; ++j) {\n      myn = min(myn, pos[j]); mex = max(mex, pos[j]);\n      if (myn == pos[i])\n        fl[i][j] = true;\n      if (mex == pos[j])\n        fr[i][j] = true;\n    }\n  }\n  for (int len = 2; len <= n; ++len)\n    for (int l = 1, r = len; r <= n; ++l, ++r) {\n      if (fl[l][r])\n        dp[l][r] = dp[l + 1][r];\n      else if (fr[l][r])\n        dp[l][r] = dp[l][r - 1];\n      else\n        dp[l][r] = min(dp[l + 1][r] + b, dp[l][r - 1] + a);\n    }\n  printf(\"%lld\\n\", dp[1][n]);\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n\nusing namespace std;\n\nconst int maxn = 5000 + 7;\n\nint n, A, B, pos[maxn], dp[maxn], a[maxn], ans;\n\nint32_t main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(\"test.inp\" ,\"r\")) freopen(\"test.inp\", \"r\", stdin);\n    cin >> n >> A >> B;\n    for(int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    a[n + 1] = 1e15;\n    for(int i = 1; i <= n + 1; i++)\n    {\n        dp[i] = 1e15;\n        ans = 0;\n        for(int j = i - 1; j >= 0; j--)\n        {\n            if(a[j] > a[i]) ans++;\n            else\n            {\n                dp[i] = min(dp[i], dp[j] + ans * A + (i - j - 1 - ans) * B);\n            }\n        }\n    }\n    cout << dp[n + 1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N;\n  LL cost_right, cost_left;\n  cin >> N >> cost_right >> cost_left;\n\n  vector<int> nums(N + 2);\n  for (int i = 1; i <= N; ++i) { cin >> nums[i]; }\n  nums.back() = N + 1;\n\n  N += 2;\n\n  vector<LL> dp(N, 1e18);\n  dp[0] = 0;\n\n  for (int from = 0; from < N; ++from) {\n    int min_occur = 1e9;\n    LL cur_cost = 0;\n\n    for (int to = from + 1; to < N; ++to) {\n      if (nums[to] < nums[from]) {\n        cur_cost += cost_left;\n      } else if (nums[to] > min_occur) {\n        cur_cost += cost_right;\n      } else {\n        mini(min_occur, nums[to]);\n        mini(dp[to], dp[from] + cur_cost);\n        cur_cost += cost_right;\n      }\n    }\n  }\n\n  cout << dp.back() << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n    int N;\n    long long A, B;\n    while(cin >> N >> A >> B){\n        vector<int> p(N);\n        for(auto& t : p) cin >> t;\n        vector<int> left(N+1, N+1), right(N+1, 0);\n        for(int i=0;i<N;i++){\n            for(int j=0;j<i;j++) if(p[j] > p[i]) left[p[i]] = min(left[p[i]], p[j]);\n            for(int j=i+1;j<N;j++) if(p[j] < p[i]) right[p[i]] = max(right[p[i]], p[j]);\n        }\n        vector<vector<long long>> dp(N+2, vector<long long>(N+2, 1LL << 60));\n        dp[0][N+1] = 0;\n        for(int d=N+1;d>=2;d--){\n            for(int i=0;i+d<=N+1;i++){\n                auto costL = (i+d <= left[i+1] ? 0 : B);\n                auto costR = (i >= right[i+d-1] ? 0 : A);\n                dp[i+1][i+d] = min(dp[i+1][i+d], dp[i][i+d] + costL);\n                dp[i][i+d-1] = min(dp[i][i+d-1], dp[i][i+d] + costR);\n            }\n        }\n        auto res = (1LL << 60);\n        for(int i=0;i<=N;i++) res = min(res, dp[i][i+1]);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\n//#define int __int128\n//#define ll __int128\n//typedef __int128 long long;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nconst int N = 5009;\nconst ll oo = 1e18;\n\nll a, b;\n\nint p[N];\nint n;\nll dp[N][2];\n\nvoid smain() {\n\n    cin >> n >> a >> b;\n    fori (i, n) {\n        cin >> p[i + 1];\n    }\n    int pr = 0, cr = 1;\n    fori (i, N) fori (j, 2) dp[i][j] = oo;\n\n    dp[0][0] = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int mx = 0; mx <= n; ++mx) {\n            if (dp[mx][pr] < oo) {\n                if (mx > p[i]) {\n                    inmin(dp[mx][cr], dp[mx][pr] + b);\n                } else {\n                    inmin(dp[p[i]][cr], dp[mx][pr]);\n                    inmin(dp[mx][cr], dp[mx][pr] + a);\n                }\n            }\n            dp[mx][pr] = oo;\n        }\n        swap(pr, cr);\n    }\n    ll ans = oo;\n    fori (mx, n + 1) {\n        inmin(ans, dp[mx][pr]);\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1LL<<60\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a,b;\nint p[5005];\nll dp[5005][5005];\nbool chl[5005][5005];\nbool chr[5005][5005];\nint cntr[5005];\nint cntl[5005];\nbool used[5005];\n\nint main(void){\n    scanf(\"%d%lld%lld\",&n,&a,&b);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&p[i]);\n        p[i]--;\n    }\n    memset(used,false,sizeof(used));\n    for(int i=0;i<n;i++){\n        used[p[i]]=true;\n        for(int j=0;j<p[i];j++){\n            if(!used[j]){\n                cntl[j]++;\n                chl[j][p[i]]=true;\n            }\n        }\n    }\n    memset(used,false,sizeof(used));\n    for(int i=n-1;i>=0;i--){\n        used[p[i]]=true;\n        for(int j=p[i];j<n;j++){\n            if(!used[j]){\n                cntr[j]++;\n                chr[j][p[i]]=true;\n            }\n        }\n    }\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            dp[i][j]=INF;\n        }\n    }\n    dp[0][n]=0;\n    for(int i=0;i<n;i++){\n        for(int j=n;j>i;j--){\n            int lv=i;\n            if(cntl[lv]==0){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n            }else{\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+min(b,(ll)a*cntl[lv]));\n            }\n            if(chl[lv][j-1]){\n                cntl[lv]--;\n            }\n            int rv=j-1;\n            if(cntr[rv]==0){\n                dp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n            }else{\n                dp[i][j-1]=min(dp[i][j-1],dp[i][j]+min(a,(ll)b*cntr[rv]));\n            }\n            //printf(\"%d %d %d %d %lld\\n\",i,j,cntl[lv],cntr[rv],dp[i][j]);\n\n        }\n        for(int j=0;j<n;j++){\n            if(chr[j][i]){\n                cntr[j]--;\n            }\n        }\n    }\n    ll ans=INF;\n    for(int i=0;i<=n;i++){\n        ans=min(ans,dp[i][i]);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nconst int maxN = 5005;\n\nint n;\nint cnt[maxN + 1], a[maxN + 1], pos[maxN + 1];\nLL A, B;\nLL f[maxN + 1][maxN + 1];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%lld %lld\", &A, &B);\n\tfor(int i = 1; i <= n; i++) \n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tpos[ a[i] ] = i;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = a[i] + 1; j <= n; j++)\n\t\t\tif(pos[j] <= i) cnt[j] ++;\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tif(pos[j] <= i)\n\t\t\t{\n\t\t\t\tif(!cnt[j]) f[i][j] = f[i][j - 1];\n\t\t\t\telse f[i][j] = min(f[i][j - 1] + A, f[ pos[j] - 1 ][j] + B * cnt[j]);\n\t\t\t}\n\t\t\telse f[i][j] = f[i][j - 1];\n\t}\n\tprintf(\"%lld\", f[n][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ncs ll INF = 1e18;\ncs int N = 5e3 + 50;\nint n, A, B; ll dp[N];\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tmemset(dp,0x3f,sizeof(dp));dp[0]=0;\n\tfor(int i=1,x; i<=n; i++){\n\t\tscanf(\"%d\",&x);ll mn=INF;\n\t\tfor(int j=0; j<=x; j++)mn=min(mn,dp[j]);\n\t\tfor(int j=0; j<x; j++)dp[j]+=A;\n\t\tfor(int j=x+1; j<=n; j++)dp[j]+=B;dp[x]=mn;\n\t} ll ans=INF;\n\tfor(int i=0;i<=n;i++)ans=min(ans,dp[i]);\n\tcout<<ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n#define llong long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0; bool f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=0;\n\tfor(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n\tif(f) return x;\n\treturn -x;\n}\n\nconst int N = 5000;\nconst llong INF = 10000000000000000ll;\nint p[N+3],pp[N+3];\nllong dp[N+3][N+5],sdp[N+3][N+5];\nint n; llong arga,argb;\n\nvoid update(llong &x,llong y) {x = x<y?x:y;}\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&arga,&argb);\n\tfor(int i=1; i<=n; i++) {scanf(\"%d\",&p[i]); pp[p[i]] = i;}\n\tfor(int i=0; i<=n; i++) for(int j=0; j<=n; j++) dp[i][j] = sdp[i][j] = INF;\n\tfor(int i=0; i<=n; i++) sdp[0][i] = dp[0][i] = 0ll;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tif(j==pp[i]) {update(dp[i][j],sdp[i-1][j-1]);}\n\t\t\tllong tmp = sdp[i-1][j]+(j<pp[i]?argb:arga);\n\t\t\tupdate(dp[i][j],tmp);\n//\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\t}\n\t\tsdp[i][0] = dp[i][0];\n\t\tfor(int j=1; j<=n; j++) sdp[i][j] = min(sdp[i][j-1],dp[i][j]);\n\t}\n\tllong ans = sdp[n][n];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)1000000007\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique priority_queue\nusing namespace std;\nint gcd(int a, int b) {\n\tif (!b)return a;\n\treturn gcd(b, a % b);\n}\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b % 2)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b / 2);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b % 2)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value += T(modulo) * max((int)1, -value / modulo + 1);\n\t\tthis->value %= T(modulo);\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % mod;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tstatic modInt pow(modInt x, int y) {\n\t\tif (!y)return 1;\n\t\tif (y & 1)return pow(x, y - 1) * x;\n\t\tmodInt memo = pow(x, y / 2);\n\t\treturn memo * memo;\n\t}\n\tinline modInt inv() {\n\t\treturn pow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nclass UnionFind {\nprotected:\n\tint* par, * rank, * size;\npublic:\n\tUnionFind(unsigned int size) {\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tthis->size = new int[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tthis->size[i] = 1;\n\t\t}\n\t}\n\tint find(int n) {\n\t\tif (par[n] == n)return n;\n\t\treturn par[n] = find(par[n]);\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m)return;\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t}\n\tbool same(int n, int m) {\n\t\treturn find(n) == find(m);\n\t}\n\tint getsize(int n) {\n\t\treturn size[find(n)];\n\t}\n};\nclass PerpetualUnionFind :UnionFind {\n\tP* notparent;\n\tvector<P>* sizevec;\n\tint opcount = 0;\npublic:\n\tPerpetualUnionFind(unsigned int size) :UnionFind(size) {\n\t\tthis->sizevec = new vector<P>[size];\n\t\tnotparent = new P[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsizevec[i].push_back(make_pair(-1, 1));\n\t\t\tnotparent[i] = make_pair(INF, i);\n\t\t}\n\t}\n\tint find(int n, int t = INF) {\n\t\tif (opcount <= t) {\n\t\t\tif (par[n] == n)return n;\n\t\t\treturn par[n] = find(par[n]);\n\t\t}\n\t\tif (notparent[n].first <= t)return find(notparent[n].second, t);\n\t\treturn n;\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m) {\n\t\t\topcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tnotparent[n] = make_pair(opcount, m);\n\t\t\tsizevec[m].push_back(make_pair(opcount, sizevec[m].back().second + sizevec[n].back().second));\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tnotparent[m] = make_pair(opcount, n);\n\t\t\tsizevec[n].push_back(make_pair(opcount, sizevec[n].back().second + sizevec[m].back().second));\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t\topcount++;\n\t}\n\tbool same(int n, int m, int t = INF) {\n\t\treturn find(n, t) == find(m, t);\n\t}\n\tint getsize(int n, int t = INF) {\n\t\tn = find(n, t);\n\t\tauto ite = lower_bound(sizevec[n].begin(), sizevec[n].end(), make_pair(t, (int)0));\n\t\tif (ite == sizevec[n].end())ite--;\n\t\tif (t < (*ite).first)ite--;\n\t\treturn (*ite).second;\n\t}\n};\nclass RollingHash {\n\tstring s;\n\tint n, m, base;\n\tdeque<int> has;\npublic:\n\tRollingHash(string s, int m, int b) : n(s.size()), m(m), base(b) { init(s, m, b); }\n\tvoid init(string s, int m, int b) {\n\t\tn = s.size();\n\t\thas.resize(n);\n\t\tbase = b;\n\t\tthis->s = s;\n\t\tthis->m = m;\n\t\trep(i, n) {\n\t\t\thas[i] = (int)s[i];\n\t\t\tif (i)has[i] += base * has[i - 1] % m;\n\t\t\thas[i] %= m;\n\t\t}\n\t}\n\toperator int() const {\n\t\treturn has.back();\n\t}\n\tvoid cut(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\trep(i, a)has.pop_front();\n\t\trep(i, n - b)has.pop_back();\n\t\ts = s.substr(a, b);\n\t\tint memo = modpow(modpow(base, n - b, m), m - 2, m);\n\t\trep(i, b - a) {\n\t\t\thas[i] *= memo;\n\t\t\thas[i] %= mod;\n\t\t}\n\t\tn = b - a;\n\t}\n\tint query(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\treturn (has[b - 1] - modpow(base, b - a, m) * (!a ? 0 : has[a - 1]) % m + m) % m;\n\t}\n\tint operator+(RollingHash t) {\n\t\tassert(m == t.m && base == t.base);\n\t\treturn (has[n - 1] * modpow(base, t.n, m) % m + t.has[t.n - 1]) % m;\n\t}\n\tRollingHash& operator+=(string t) {\n\t\ts += t;\n\t\thas.resize(n + t.size());\n\t\tfor (int i = n; i < n + t.size(); i++) {\n\t\t\thas[i] = (int)t[i] * base % m;\n\t\t\thas[i] += base * has[i - 1] % m;\n\t\t\thas[i] %= m;\n\t\t}\n\t\tn += t.size();\n\t\treturn *this;\n\t}\n};\ntemplate<typename T, typename U>\nclass SegTree {\n\tint n = 1;\n\tT* node = NULL;\n\tU* lazy = NULL;\n\tbool* lazyflag = NULL;\n\tT nodee;\n\tfunction<T(T, T)> nodef;\n\tfunction<U(U, U)> lazyf;\n\tfunction<T(int, T, U)> updf;\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazyflag[k]) {\n\t\t\tnode[k] = updf(r - l, node[k], lazy[k]);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazyflag[2 * k + 1] = lazyflag[2 * k + 2] = true;\n\t\t\t\tlazy[2 * k + 1] = lazyf(lazy[2 * k + 1], lazy[k]);\n\t\t\t\tlazy[2 * k + 2] = lazyf(lazy[2 * k + 2], lazy[k]);\n\t\t\t}\n\t\t\tlazyflag[k] = false;\n\t\t}\n\t}\npublic:\n\tSegTree(int m, int init, T nodee, function<T(T, T)> nodef, function<U(U, U)> lazyf, function<T(int, T, U)> updf) :nodee(nodee), nodef(nodef), lazyf(lazyf), updf(updf) {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t\twhile (n < m)n *= 2;\n\t\tnode = new T[2 * n], lazy = new U[2 * n], lazyflag = new bool[2 * n];\n\t\trep(i, 2 * n) {\n\t\t\tnode[i] = init;\n\t\t\tlazyflag[i] = false;\n\t\t}\n\t}\n\t~SegTree() {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t}\n\tvoid update(int a, int b, U x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazyflag[k] = true;\n\t\t\tlazy[k] = x;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = nodef(node[2 * k + 1], node[2 * k + 2]);\n\t\t}\n\t}\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return nodee;\n\t\tif (a <= l && r <= b)return node[k];\n\t\tT vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn nodef(vl, vr);\n\t}\n};\ntemplate<typename T>\nclass Matrix {\n\tint n;\n\tT zero, e;\n\tvector<vector<T>> vec;\n\tvoid letmeasure() {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i != j)vec[i][j] = zero;\n\t\t\t\telse vec[i][j] = e;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tMatrix(int n, T zero, T e) :n(n), zero(zero), e(e) {\n\t\tvec.resize(n, vector<T>(n));\n\t}\n\tMatrix(int n, T zero, T e, vector<int> vec) :n(n), zero(zero), e(e) {\n\t\tif (vec.size() != n * n) {\n\t\t\tcerr << \"Invalid construct of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tthis->vec.resize(n, vector<T>(n));\n\t\trep(i, n) {\n\t\t\trep(j, n)this->vec[i][j] = vec[i * n + j];\n\t\t}\n\t}\n\tT& operator[](int a) {\n\t\treturn vec[a / n][a % n];\n\t}\n\tunsigned int size() { return n; }\n\tMatrix operator*(const Matrix a) {\n\t\tif (this->n != a.n) {\n\t\t\tcerr << \"Invalid multiply of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tvector<T> memo(n);\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tmemo[j] += vec[i][k] * a.vec[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec[i] = memo;\n\t\t\tmemo.clear();\n\t\t\tmemo.resize(n);\n\t\t}\n\t\treturn *this;\n\t}\n\tstatic Matrix<T> measure(int n, T zero, T e) {\n\t\tMatrix<T> res(n, zero, e);\n\t\tres.letmeasure();\n\t\treturn res;\n\t}\n\tstatic Matrix pow(Matrix a, int b) {\n\t\tif (!b)return Matrix::measure(a.size(), a.zero, a.e);\n\t\tif (b % 2)return pow(a, b - 1) * a;\n\t\tMatrix memo = pow(a, b / 2);\n\t\treturn (memo * memo);\n\t}\n};\nclass mycomplex {\n\tdouble realvalue, imagvalue;\npublic:\n\tmycomplex() :realvalue(0), imagvalue(0) {}\n\tmycomplex(double realvalue, double imagvalue) : realvalue(realvalue), imagvalue(imagvalue) {}\n\tmycomplex(double realvalue) : realvalue(realvalue), imagvalue(0) {}\n\tmycomplex(complex<double> c) :realvalue(c.real()), imagvalue(c.imag()) {}\n\tmycomplex(const mycomplex& rhs) :realvalue(rhs.realvalue), imagvalue(rhs.imagvalue) {}\n\tdouble real()const { return this->realvalue; }\n\tdouble imag()const { return this->imagvalue; }\n\tdouble abs() { return hypot(realvalue, imagvalue); }\n\tmycomplex& operator=(const mycomplex& obj) {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = obj.realvalue;\n\t\t\tthis->imagvalue = obj.imagvalue;\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator=(mycomplex&& obj)noexcept {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = exchange(obj.realvalue, 0);\n\t\t\tthis->imagvalue = exchange(obj.imagvalue, 0);\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator+=(const mycomplex& rhs) {\n\t\tthis->realvalue += rhs.realvalue;\n\t\tthis->imagvalue += rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator+(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs += rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator-=(const mycomplex& rhs) {\n\t\tthis->realvalue -= rhs.realvalue;\n\t\tthis->imagvalue -= rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tmycomplex& operator-=(const double& rhs) {\n\t\tthis->realvalue -= rhs;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator-(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs -= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator*=(const mycomplex& rhs) {\n\t\tdouble pastreal = this->realvalue;\n\t\tthis->realvalue = this->realvalue * rhs.realvalue - this->imagvalue * rhs.imagvalue;\n\t\tthis->imagvalue = pastreal * rhs.imagvalue + rhs.realvalue * this->imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator*(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs *= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator/=(const mycomplex& rhs) {\n\t\t*this *= mycomplex(rhs.real(), -rhs.imag());\n\t\tdouble dnm = rhs.real() * rhs.real() - rhs.imag() * rhs.imag();\n\t\tthis->realvalue /= dnm;\n\t\tthis->imagvalue /= dnm;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator/(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs /= rhs;\n\t\treturn lhs;\n\t}\n};\nclass FastFourierTransform {\nprivate:\n\tstatic void dft(vector<mycomplex>& func, int inverse) {\n\t\tint sz = func.size();\n\t\tif (sz == 1)return;\n\t\tvector<mycomplex> veca, vecb;\n\t\trep(i, sz / 2) {\n\t\t\tveca.push_back(func[2 * i]);\n\t\t\tvecb.push_back(func[2 * i + 1]);\n\t\t}\n\t\tdft(veca, inverse); dft(vecb, inverse);\n\t\tmycomplex now = 1, zeta = polar(1.0, inverse * 2.0 * acos(-1) / sz);\n\t\trep(i, sz) {\n\t\t\tfunc[i] = veca[i % (sz / 2)] + now * vecb[i % (sz / 2)];\n\t\t\tnow *= zeta;\n\t\t}\n\t}\npublic:\n\ttemplate<typename T>\n\tstatic vector<double> multiply(vector<T> f, vector<T> g) {\n\t\tvector<mycomplex> nf, ng;\n\t\tint sz = 1;\n\t\twhile (sz < f.size() + g.size())sz *= 2;\n\t\tnf.resize(sz); ng.resize(sz);\n\t\trep(i, f.size()) {\n\t\t\tnf[i] = f[i];\n\t\t\tng[i] = g[i];\n\t\t}\n\t\tdft(nf, 1);\n\t\tdft(ng, 1);\n\t\trep(i, sz)nf[i] *= ng[i];\n\t\tdft(nf, -1);\n\t\tvector<double> res;\n\t\trep(i, sz)res.push_back(nf[i].real() / sz);\n\t\treturn res;\n\t}\n};\nint n, a, b, p[5010];\nint dp[5010][5010];\nsigned main() {\n\tcin >> n >> a >> b;\n\tREP(i, n)cin >> p[i];\n\trep(i, n + 1) {\n\t\trep(j, n + 1)dp[i][j] = INF;\n\t}\n\tdp[0][0] = 0;\n\tREP(i, n) {\n\t\trep(j, n + 1) {\n\t\t\tif (j < p[i]) {\n\t\t\t\tdp[i][p[i]] = min(dp[i][p[i]], dp[i - 1][j]);\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(j, n + 1)ans = min(ans, dp[n][j]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\ntemplate<typename T1,typename T2> inline T1 gmax(T1 &a,T2 b){return a=a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 gmin(T1 &a,T2 b){return a=a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 5007;\n\nint n,val[_];\nlint f[_][_],sl=0,sr=0;\n\nint main()\n{\n\tn=ty(),sr=ty(),sl=ty();\n\tfor(int i=1;i<=n;i++)val[i]=ty();\n\tmemset(f,63,sizeof(f)),f[0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=val[i];j++)gmin(f[i][val[i]],f[i-1][j]),gmin(f[i][j],f[i-1][j]+sr);\n\t\tfor(int j=val[i]+1;j<=n;j++)gmin(f[i][j],f[i-1][j]+sl);\n\t}\n\n\tlint ans=1e18;\n\tfor(int i=0;i<=n;i++)ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=5100;\nint n,A,B,p[N],mx[N][N],mn[N][N];\nll dp[N][N],inf;\nlong long dfs(int l,int r)\n{\n\tlong long &v=dp[l][r];\n\tif(v!=inf) return v;\n\tif(l==r) return v=0;\n\tif(p[l]<mn[l+1][r]) v=min(v,dfs(l+1,r));\n\telse v=min(v,dfs(l+1,r)+A);\n\tif(p[r]>mx[l][r-1]) v=min(v,dfs(l,r-1));\n\telse v=min(v,dfs(l,r-1)+B);\n\tfor(int i=l;i<r;i++)\n\t\tif(mx[l][i]<mn[i+1][r])\n\t\t\tv=min(v,dfs(l,i)+dfs(i+1,r));\n//\tprintf(\"dp[%d][%d]=%lld\\n\",l,r,dp[l][r]);\n\treturn v;\n}\nint v1[N],v2[N],pos[N];\nvoid Min(ll &a,ll b) {if(b<a) a=b;}\nvoid DP()\n{\n\tdp[0][0]=0;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;i+j<n;j++)\n\t\t{\n//\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\t\tMin(dp[i][j+1],dp[i][j]+(v2[pos[n-j]]<=i?0:A));\n\t\t\tMin(dp[i+1][j],dp[i][j]+(v1[pos[i+1]]>=n-j+1?0:B));\n\t\t}\n\tll Ans=inf;\n\tfor(int i=0;i<=n;i++)\n\t\tMin(Ans,dp[i][n-i]);\n\tcout<<Ans<<endl;\n\texit(0);\n}\nint main()\n{\n\tcin>>n>>A>>B;\n\tmemset(dp,63,sizeof(dp));inf=dp[0][0];\n\tfor(int i=1;i<=n;i++) cin>>p[i],pos[p[i]]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tv1[i]=1e9;\n\t\tfor(int j=1;j<i;j++) if(p[i]<p[j]) v1[i]=min(v1[i],p[j]);\n\t\tfor(int j=i+1;j<=n;j++) if(p[i]>p[j]) v2[i]=max(v2[i],p[j]);\n//\t\tprintf(\"v1[%d]=%d,v2[%d]=%d\\n\",i,v1[i],i,v2[i]);\n\t}\n//\tcout<<dfs(1,n)<<endl;\n\tDP();\n\tfor(int i=1;i<=n;i++) dp[i][i]=0;\n\tfor(int len=1;len<=n;len++)\n\t{\n\t\tfor(int l=1;l<=n-len+1;l++)\n\t\t{\n\t\t\tint r=l+len-1;\n\t\t\tll &v=dp[l][r];\n\t\t\tif(v==inf) continue;\n//\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",l,r,v);\n\t\t\tif(r<n)\tMin(dp[l][r+1],v+(mx[l][r]<p[r+1]?0:B));\n\t\t\tif(l>1)\tMin(dp[l-1][r],v+(mn[l][r]>p[l-1]?0:A));\n\n\t\t\tint L=1,R=min(n-r,len-1),p=0;\n\t\t\twhile(L<=R)\n\t\t\t{\n\t\t\t\tint mid=(L+R)>>1;\n\t\t\t\tif(mn[r+1][r+mid]>mx[l][r]) L=mid+1,p=mid;\n\t\t\t\telse R=mid-1;\n\t\t\t}\n//\t\t\tif(l==1&&r==7) printf(\"p=%d\\n\",p);\n\t\t\tif(p) Min(dp[l][r+p],dp[l][r]+dp[r+1][r+p]);\n\n\t\t\tL=1,R=min(l-1,len),p=0;\n\t\t\twhile(L<=R)\n\t\t\t{\n\t\t\t\tint mid=(L+R)>>1;\n\t\t\t\tif(mx[l-mid][l-1]<mn[l][r]) L=mid+1,p=mid;\n\t\t\t\telse R=mid-1;\n\t\t\t}\n\t\t\tif(p) Min(dp[l-p][r],dp[l-p][l-1]+dp[l][r]);\n\t\t}\n\t}\n\tcout<<dp[1][n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nint64_t dp[5001][5001];\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n = input<int>();\n    int X = input<int>();\n    int Y = input<int>();\n\n    vector<int> seq(n);\n    vector<int> where(n);\n\n    for (int i = 0; i != n; ++i) {\n        seq[i] = input<int>() - 1;\n        where[seq[i]] = i;\n    }\n\n    vector<int> preca(n);\n    for (int a = 0; a < n; ++a) {\n        preca[a] = TYPEMAX(int);\n        \n        for (int i = 0; i < where[a]; ++i)\n            if (seq[i] > a)\n                preca[a] = min(preca[a], seq[i]);\n    }\n\n    vector<int> precb(n);\n    for (int b = 0; b < n; ++b) {\n        precb[b] = -1;\n        for (int i = where[n - 1 - b] + 1; i < n; ++i)\n            if (seq[i] < n - 1 - b)\n                precb[b] = max(precb[b], seq[i]);\n    }\n    \n    for (int a = n; a >= 0; --a)\n        for (int b = n; b >= 0; --b)\n            if (a + b >= n)\n                dp[a][b] = 0;\n            else {\n                dp[a][b] = TYPEMAX(int64_t);\n\n                bool cheap_a = true, cheap_b = true;\n\n                if (preca[a] < n - b)\n                    cheap_a = false;\n                \n                // for (int i = 0; i < where[a]; ++i)\n                //     if (seq[i] > a and seq[i] < n - b)\n                //         cheap_a = false;\n\n                if (precb[b] >= a)\n                    cheap_b = false;\n                \n                // for (int i = where[n - 1 - b] + 1; i < n; ++i)\n                //     if (seq[i] < n - 1 - b and seq[i] >= a)\n                //         cheap_b = false;\n                \n                if (cheap_a)\n                    dp[a][b] = dp[a + 1][b];\n                else if (cheap_b)\n                    dp[a][b] = dp[a][b + 1];\n                else\n                    dp[a][b] = min(dp[a + 1][b] + Y, dp[a][b + 1] + X);                    \n            }\n\n    cout << dp[0][0] << \"\\n\";\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint p[5555];\nll dp[5111][5111];\n\nvoid amin(ll &a, ll b)\n{\n\ta=min(a,b);\n}\nconst ll INF=ll(1e18);\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; ll a,b; cin>>n>>a>>b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>p[i];\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++) dp[i][j]=ll(1e18);\n\t}\n\tdp[0][p[0]] = 0;\n\tdp[0][0] = a;\n\tfor(int i=0;i+1<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(dp[i][j]<INF)\n\t\t\t{\n\t\t\t\t//choose L\n\t\t\t\tamin(dp[i+1][max(j,p[i+1])],dp[i][j]+b);\n\t\t\t\t//choose 0\n\t\t\t\tif(j<p[i+1]) amin(dp[i+1][max(j,p[i+1])],dp[i][j]);\n\t\t\t\t//choose R\n\t\t\t\tif(j<p[i+1]) amin(dp[i+1][j],dp[i][j]+a);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(int j=0;j<=n;j++) amin(ans,dp[n-1][j]);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define int long long\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int N = 5005;\nint dp[N][N], p[N], a, b, n;\npbds st[N];\n\nint solve(int i, int j) {\n  if (i == 0 || j == 0) {\n    return 0;\n  }\n  if (~dp[i][j]) {\n    return dp[i][j];\n  }\n  if (p[i - 1] >= j) {\n    return solve(i - 1, j);\n  }\n  int cnt = st[i - 1].order_of_key(j) - st[i - 1].order_of_key(p[i - 1] + 1);\n  return dp[i][j] = min(solve(i - 1, j) + b, solve(i - 1, min(p[i - 1], j)) + cnt * a);\n}\n\nsigned main() {\n  memset(dp, -1, sizeof dp);\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n    if (i > 0) {\n      st[i] = st[i - 1];\n    }\n    st[i].insert(p[i]);\n  }\n  cout << solve(n, n) << '\\n';\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll            long long\n#define pb            emplace_back\n#define fi            first\n#define se            second\n#define mp            make_pair\n//#define int           int64_t\n\nusing namespace std;\n\ntypedef pair<ll, int> pii;\nconst int N = (int)5e3 + 5;\nconst ll inf = (ll)1e18;\n\nint n, A, B, a[N], pos[N];\nll f[N][N], mn;\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    #define FileName      \"test\"\n    if(fopen(FileName\".inp\", \"r\")) {\n       freopen(FileName\".inp\", \"r\", stdin);\n       freopen(FileName\".out\", \"w\", stdout);\n    }\n    cin >> n >> A >> B;\n    fill_n(&f[0][0], N * N, inf);\n    for(int i = 1; i <= n; ++i) cin >> a[i], pos[a[i]] = i - 1;\n    ///(0, 1], (1, 2], (2, 3], ..., (n - 1, n], (n, n + 1]\n    ///to the right A, to the left B\n    for(int i = 0; i <= n; ++i) f[1][i] = (i == pos[1]? 0: (i < pos[1]? B: A));\n    for(int i = 2; i <= n; ++i) { /// f(i, j) = sort 1 -> i, pos(i) in range (j, j + 1]\n        mn = inf;\n        for(int j = 0; j <= n; ++j) {\n            /// f(i, j) min f(i - 1, k) k < j\n            mn = min(mn, f[i - 1][j]);\n            f[i][j] = mn + (j == pos[i]? 0: (j < pos[i]? B: A));\n        }\n    }\n    cout << *min_element(f[n], f[n] + n + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define MP make_pair\n#define PB push_back\nusing namespace std;\nnamespace io{\n\tconst int Sz=1<<13;\n\tchar ibuf[Sz],*ips=ibuf+Sz-1;\n\tinline int getchar(){\n\t\tif(++ips==ibuf+Sz)fread(ips=ibuf,1,Sz,stdin);\n\t\treturn *ips;\n\t}\n\tchar obuf[Sz],*ops=obuf;\n\tinline void flush(){\n\t\tfwrite(obuf,1,ops-obuf,stdout);\n\t\tops=obuf;fflush(stdout);\n\t}\n\tinline void putchar(int c){\n\t\tif(ops==obuf+Sz)flush();\n\t\t*ops=c,ops++;\n\t}\n\tvoid gets(char *s){\n\t\tint c=getchar();\n\t\twhile(c<=32)c=getchar();\n\t\twhile(c>32)*s=c,++s,c=getchar();\n\t\t*s=0;\n\t}\n\tvoid puts(const char *s){\n\t\twhile(*s)putchar(*s),++s;\n\t}\n}\n#define getchar io::getchar\n#define putchar io::putchar\n#define gets io::gets\n#define puts io::puts\nint read(){\n\tint x=0,f=1,c=getchar();\n\tfor(;c<48||c>57;c=getchar())\n\t\tif(c=='-')f=-f;\n\tfor(;c>=48&&c<=57;c=getchar())\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tint stk[20],tp=0;\n\tif(!x)putchar(48);\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)stk[tp++]=(x-x/10*10)^48;\n\tfor(;tp;)putchar(stk[--tp]);\n}\nstruct Flusher{~Flusher(){io::flush();}}flusher;\n// ------------------------- Template End ------------------------- //\nconst int N=5005;\nint n,A,B;\nint p[N];\nll dp[N];\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nvoid chkmin(ll &x,ll y){if(y<x)x=y;}\nint main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=0;i<n;++i)p[i]=read();\n\tmemset(dp,0x3f,sizeof dp);\n\tdp[0]=0;\n\tfor(int i=1;i<=n+1;++i){\n\t\tll delta=0;\n\t\tfor(int j=i-1;~j;--j){\n\t\t\tif(i==n+1||!j||p[j-1]<p[i-1])\n\t\t\t\tchkmin(dp[i],dp[j]+delta);\n\t\t\tif(j){\n\t\t\t\tif(i==n+1||p[j-1]<p[i-1])delta+=B;\n\t\t\t\telse delta+=A;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n+1]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nint n, p[5010], pos[5010];\nll A, B, ans;\n\nint main() {\n    scanf(\"%d %lld %lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) if (p[j] == i) {\n            ans += min(A * (j - i), B);\n            if (A * (j - i) > B) {\n                for (int k = j; k > i; k--) p[k] = p[k - 1];\n                p[i] = i;\n            } else {\n                for (int k = i; k < j; k++) {\n                    pos[k - i + 1] = k;\n                }\n                sort(pos + 1, pos + j - i + 1, [&](int x, int y) {\n                    return (x < p[x]) > (y < p[y]);\n                });\n                for (int k = 1; k <= j - i; k++) {\n                    int num = p[pos[k]];\n                    for (int t = pos[k]; t < num; t++) p[t] = p[t + 1];\n                    p[num] = num;\n                }\n            }\n            break;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1LL<<60\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a,b;\nint p[5005];\nll dp[5005][5005];\n\nint main(void){\n    scanf(\"%d%lld%lld\",&n,&a,&b);\n    for(int i=0;i<n;i++) {\n        scanf(\"%d\", &p[i]);\n        p[i]--;\n    }\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            dp[i][j]=INF;\n        }\n    }\n    dp[0][0]=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=n;j++){\n            if(j>p[i]){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n            }\n            if(j==p[i]){\n                dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]);\n            }\n            if(j<p[i]){\n                dp[i+1][p[i]+1]=min(dp[i+1][p[i]+1],dp[i][j]);\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+a);\n            }\n        }\n    }\n    ll ans=INF;\n    for(int i=0;i<=n;i++){\n        ans=min(dp[n][i],ans);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read();\nint n;\nlong long a, b, res = 1e13;\nstruct Bit {\n    int s[100005];\n    void add(int p) {\n        for (; p <= n; p += p & -p) ++s[p];\n    }\n    int qry(int p) {\n        int rt = 0;\n        for (; p; p -= p & -p) rt += s[p];\n        return rt;\n    }\n} bit;\nint main() {\n    n = read(), a = read(), b = read();\n    for (int i = 1, x, s; i <= n; ++i, bit.add(x))\n        s = i - 1 - bit.qry(x = read()),\n        res = min(res, a * s + b * (x + s - i));\n    printf(\"%lld\\n\", res);\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 3/23/2019, 10:52:02 PM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(10101010));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll infty = 10000000000000007;\n\nll N, A, B;\nint p[5010];\nll R[5010][5010];\nll L[5010][5010];\nll cost[5010][5010];\n\nll calc(int l, int r)\n{\n  if (cost[l][r] < infty)\n  {\n    return cost[l][r];\n  }\n  else if (l + 1 == r)\n  {\n    cost[l][r] = 0;\n  }\n  else if (l + 2 == r)\n  {\n    if (p[l] < p[l + 1])\n    {\n      cost[l][r] = 0;\n    }\n    else\n    {\n      cost[l][r] = min(A, B);\n    }\n  }\n  else\n  {\n    cost[l][r] = min(A, B * R[l][r - 1]) + calc(l + 1, r);\n    cost[l][r] = min(cost[l][r], min(B, A * L[r - 1][l]) + calc(l, r - 1));\n  }\n#if DEBUG == 1\n  cerr << \"cost[\" << l << \"][\" << r << \"] = \" << cost[l][r] << endl;\n#endif\n  return cost[l][r];\n}\n\nint main()\n{\n  cin >> N >> A >> B;\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> p[i];\n    p[i]--;\n  }\n  fill(&cost[0][0], &cost[0][0] + 5010 * 5010, infty);\n  for (auto i = 0; i < N; i++)\n  {\n    R[i][i] = 0;\n    for (auto j = i + 1; j < N; j++)\n    {\n      R[i][j] = R[i][j - 1];\n      if (p[i] > p[j])\n      {\n        R[i][j]++;\n      }\n#if DEBUG == 1\n      cerr << \"R[\" << i << \"][\" << j << \"] = \" << R[i][j] << endl;\n#endif\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    L[i][i] = 0;\n    for (auto j = i - 1; j >= 0; j--)\n    {\n      L[i][j] = L[i][j + 1];\n      if (p[i] < p[j])\n      {\n        L[i][j]++;\n      }\n#if DEBUG == 1\n      cerr << \"L[\" << i << \"][\" << j << \"] = \" << L[i][j] << endl;\n#endif\n    }\n  }\n  cout << calc(0, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,a[200005],d[5005][5005],aa,b;\nint main() {\n\tcin >> n >> b >> aa;\n\t\n\tfor(int i=1; i<=n; i++)\n\t\tcin >> a[i];\n\t\n\t\n\t\n\tfor(int i=2; i<=n; i++){\n\t\tfor(int j=1; j<=n-i+1; j++){\n\t\t\tll raod = 0;\n\t\t\tfor(int l=j; l<=j+i-2; l++){\n\t\t\t\tif(a[l] > a[j + i - 1])raod++;\n\t\t\t}\n\t\t//\tcout << raod << endl;\n\t\t\td[j][j+i-1] = min(d[j][j+i-2] + raod * b,d[j][j+i-2] + aa);\n\t\t\traod = 0;\n\t\t\tfor(int l=j+1; l<=j+i-1; l++)if(a[j] > a[l])raod++;\n\t\t\td[j][i+j-1] = min(d[j][i+j-1],min(d[j+1][i+j-1] + aa * raod,d[j+1][i+j-1] + b));\n\t\t}\n\t}\n\t\n//\tcout << d[2][3] << endl;\n\t\n\tcout << d[1][n];\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n    using namespace std;\n    #define rep(i,a,n) for (int i=a;i<n;i++)\n    #define per(i,a,n) for (int i=n-1;i>=a;i--)\n    #define pb push_back\n    #define mp make_pair\n    #define all(x) (x).begin(),(x).end()\n    #define fi first\n    #define se second\n    #define SZ(x) ((int)(x).size())\n    typedef vector<int> VI;\n    typedef long long ll;\n    typedef pair<int,int> PII;\n    mt19937 mrand(random_device{}()); \n    const ll mod=1000000007;\n    int rnd(int x) { return mrand() % x;}\n    ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n    ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n    // head\n     \n    const int N=5010;\n    int n,a,b,x,p[N];\n    ll dp[N][N];\n    int main() {\n    \tscanf(\"%d%d%d\",&n,&a,&b);\n    \trep(i,1,n+1) scanf(\"%d\",&x),p[x]=i;\n    \tmemset(dp,0x20,sizeof(dp));\n    \tdp[0][0]=0;\n    \trep(i,1,n+1) rep(j,0,i) {\n    \t\tif (p[i]>p[j]) {\n    \t\t\tdp[i][i]=min(dp[i][i],dp[i-1][j]);\n    \t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+b);\n    \t\t} else\n    \t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+a);\n    \t}\n    \tprintf(\"%lld\\n\",dp[n][n]);\n    }"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n#define int long long\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nint A, B;\n\nsigned main() {\n\tscan n, A, B;\n\tvector<int> p(n);\n\tscan p;\n\tapply(p, x--);\n\tvector<int> at(n);\n\tf(i, n) {\n\t\tat[p[i]] = i;\n\t}\n\n\tvector<vector<int>> less(n, vector<int>(n + 1));\n\tfor (int i = 0; i < n; i++) {\n\t\tint offset = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (p[j] < p[i]) {\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\tless[i][n] = offset;\n\t\tfor (int j = n - 1; j > -1; j--) {\n\t\t\tless[i][j] = less[i][j + 1] + (at[j] < i);\n\t\t}\n\t}\n\n\tvector<vector<int>> greater(n, vector<int>(n + 1));\n\tfor (int i = 0; i < n; i++) {\n\t\tint offset = 0;\n\t\tfor (int j = n - 1; j > i; j--) {\n\t\t\tif (p[j] > p[i]) {\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\tgreater[i][0] = offset;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tgreater[i][j] = greater[i][j - 1] + (at[j - 1] > i);\n\t\t}\n\t}\n\n\n\tvector<vector<int>> dp(n + 2, vector<int>(n + 2, 1e18));\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\t{\n\t\t\t\tint w = B;\n\t\t\t\tif (at[i] == less[at[i]][n - j]) {\n\t\t\t\t\tw = 0;\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j] = min(dp[i][j] + w, dp[i + 1][j]);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint w = A;\n\t\t\t\tif (n - 1 - at[n - j - 1] == greater[at[n - j - 1]][i]) {\n\t\t\t\t\tw = 0;\n\t\t\t\t}\n\t\t\t\tdp[i][j + 1] = min(dp[i][j] + w, dp[i][j + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tint final = 1e18;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfinal = min(final, dp[i][n - i]);\n\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v){\n\tREP(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?1:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n}\n\nsigned main(){\n\tint n=read(),a=read(),b=read();\n\tvi p(n);\n\tREP(i,n)\n\t\tp[i]=read()-1;\n\tvi dp(n+1,0),nx(n+1,0);\n\tfor(int i=n-1;i>=0;i--){\n\t\tfill(ALL(nx),0);\n\t\tint x=-1,y=0;\n\t\tfor(int j=n-1;j>=0;j--){\n\t\t\tif(p[j]==i){\n\t\t\t\tx=j;\n\t\t\t}else if(p[j]>i&&x!=-1){\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tif(x==-1)\n\t\t\t\tnx[j]=dp[j];\n\t\t\telse\n\t\t\t\tnx[j]=min(dp[j]+b,dp[x+1]+a*y);\n\t\t}\n\t\tswap(dp,nx);\n\t}\n\tprint(dp[0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,A,B,a[5010],mn[5010],nx[5010],dep[5010];\nlong long f[5010][5010];\nint main(){\n\tscanf(\"%d %d %d\",&n,&A,&B);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n\tfor(int i=1;i<=n+1;++i)for(int j=1;j<=n+1;++j)f[i][j]=8e18;\n\tf[1][1]=0;\n\tfor(int i=1;i<=n;++i){\n\t\tint t=0;mn[n+1]=a[n+1]=nx[n]=n+1;\n\t\tfor(int j=n;j;--j)if(a[j]>=i)\n\t\t\tmn[j]=a[mn[j+1]]<a[j]?mn[j+1]:j,nx[j-1]=j;\n\t\telse mn[j]=mn[j+1],nx[j-1]=nx[j];\n\t\tfor(int j=n;j;--j)dep[j]=dep[nx[j]]+1;\n\t\tfor(int j=1;j<=n;++j)if(a[j]>=i&&f[i][j]<1e18){\n\t\t\tint x=mn[j];\n\t\t\tif(j==x)f[a[x]+1][nx[j]]=min(f[a[x]+1][nx[j]],f[i][j]);\n\t\t\telse f[a[x]+1][j]=min(f[a[x]+1][j],f[i][j]+B);\n\t\t\tf[a[mn[nx[x]]]][nx[x]]=min(f[a[mn[nx[x]]]][nx[x]],f[i][j]+1ll*A*(dep[j]-dep[x]));\n\t\t}\n\t}long long ans=8e18;\n\tfor(int i=1;i<=n+1;++i)ans=min(ans,min(f[i][n+1],f[n+1][i]));\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T, typename U>\ninline auto cmn (T& a, U b) {if (a > b) {a = b; return true;} return false;}\ntemplate<typename T, typename U>\ninline auto cmx (T& a, U b) {if (a < b) {a = b; return true;} return false;}\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, A, B;\n  std::cin >> n >> A >> B;\n  std::vector<int> p(n);\n  std::for_each(p.begin(), p.end(), [](auto& x){std::cin >> x;});\n  p.insert(p.begin(), 0), p.push_back(n + 1);\n  constexpr long long inf = 1LL << 60;\n  auto dp = std::vector<long long>(n + 2, inf);\n  dp.at(0) = 0;\n  for (int i = 1; i <= n + 1; i++) {\n    auto crr = p.at(i);\n    int lower = -1;\n    long long now = 0;\n    for (int j = i - 1; j >= 0; j--) {\n      auto prv = p.at(j);\n      assert(crr != prv && prv != lower);\n      if (prv > crr) {\n        now += A;\n      } else {\n        if (prv > lower) cmn(dp.at(i), dp.at(j) + now);\n        now += B;\n      }\n    }\n  }\n  std::cout << dp.at(n + 1) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<math.h>\n#include<list>\n#include<complex>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll>\n#define vvll vector<vector<ll>>\n#define vvvll vector<vector<vector<ll>>>\n#define vtype(type) vector<type>\n#define vvtype(type) vector<vector<type>>\n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\nstruct wall\n{\n\tlong long r; ll c;\n\tbool operator<(const wall& rhs) const {\n\t\tif (r != rhs.r) {\n\t\t\treturn r < rhs.r;\n\t\t}\n\t\telse {\n\t\t\treturn c < rhs.c;\n\t\t}\n\t}\n};\n\n\nll const MOD = 1e9 + 7;\n\n\nll mod_p(ll x, ll y) {\n\tx %= MOD;\n\ty %= MOD;\n\treturn (x + y + MOD) % MOD;\n}\n\nll mod_m(ll x, ll y) {\n\tx %= MOD;\n\ty %= MOD;\n\treturn x * y%MOD;\n}\n\nll mod_pow(ll x, ll t) {\n\tx %= MOD;\n\tif (t == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tll v = mod_pow(x, t / 2);\n\t\tif (t % 2 == 0) {\n\t\t\treturn v * v % MOD;\n\t\t}\n\t\telse {\n\t\t\treturn v * v%MOD * x %MOD;\n\t\t}\n\t}\n}\n\nll mod_inv(ll x) {\n\treturn mod_pow(x, MOD - 2);\n}\n\nll const MAX = 5e3 + 5;\nvvll dp(MAX, vll(MAX, 1e10));\nvll p(MAX);\n\nint main() {\n\tll n;\n\tcin >> n;\n\tll a, b;\n\tcin >> a >> b;\n\tREP(i, 1, n) {\n\t\tcin >> p[i];\n\t}\n\tdp[0][0] = 0;\n\tREP(i, 1, n) {\n\t\tREP(j, 0, n) {\n\t\t\tif (j < p[i]) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + a);\n\t\t\t\tdp[i][p[i]] = min(dp[i][p[i]], dp[i - 1][j]);\n\t\t\t}\n\t\t\telse if (j > p[i]) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1e10;\n\tREP(j, 1, n) {\n\t\tans = min(dp[n][j], ans);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nll n,a,b;\nint rk1[5005][5005],rk2[5005][5005],p[5005];\nll d[5005][5005];\n\nint main(){\n\tn=readint(); a=readint(); b=readint();\n\tfor(int i=1;i<=n;i++) p[i]=readint();\n\tfor(int i=n-1;i>=1;i--){\n\t\trk1[i][i]=p[i]>p[i+1];\n\t\tfor(int j=i-1;j>=1;j--) rk1[j][i]=rk1[j+1][i]+(p[j]>p[i+1]);\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\trk2[i][i]=p[i]<p[i-1];\n\t\tfor(int j=i+1;j<=n;j++) rk2[i][j]=rk2[i][j-1]+(p[j]<p[i-1]);\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=n-i+1;j++){\n\t\t\tint l=j,r=i+j-1;\n\t\t\td[l][r]=min(d[l][r-1]+min(b,a*rk1[l][r-1]),d[l+1][r]+min(a,b*rk2[l+1][r]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",d[1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 5050;\nlong long f[2 * maxn], nf[2 * maxn];\nint p[maxn];\nint main(){\n\tint n, A, B; scanf(\"%d %d %d\", &n, &A, &B);\n\tfor(int i = 1; i <= n; i++){\n\t\tint x; scanf(\"%d\", &x);\n\t\tp[x] = 2 * i;\n\t}\n\tint l = 2 * n + 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tlong long mi = f[1];\n\t\tf[1] += B;\n\t\tfor(int j = 2; j <= l; j++){\n\t\t\tmi = min(mi, f[j]);\n\t\t\tlong long cost = (p[i] < j) * A + (p[i] > j) * B;\n\t\t\tf[j] = mi + cost;\n\t\t}\n\t}\n\tlong long ans = 1ll<<62;\n\tfor(int j = 1; j <= l; j++) ans = min(ans, f[j]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n#define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 5010;\n\n\nll n, A, B, P[maxn], dp[maxn][maxn];\n\nvoid MAIN() {\n\n    cin >> n >> A >> B;\n    fori (i, n) cin >> P[i + 1];\n    memset(dp, 20, sizeof dp);\n    dp[0][0] = 0;\n    fori (i, n) {\n        fori (j, i + 1) {\n            if (P[i + 1] > P[j]) {\n                smin(dp[i + 1][i + 1], dp[i][j]);\n                smin(dp[i + 1][j], dp[i][j] + A);\n            } else {\n                smin(dp[i + 1][j], dp[i][j] + B);\n            }\n        }\n    }\n    ll ans = *min_element(dp[n], dp[n] + n + 1);\n    cout << ans << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\n9 40 50\n5 3 4 7 6 1 2 9 8\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-23 14:48:50\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=10010;\nconst i64 inf=1ll<<50;\ni64 n,a,b,p[N],f[N],F[N],ans;\nint main()\n{\n\tn=read(); a=read(); b=read(); ans=inf;\n\tfr(i,1,n) p[read()]=i;\n\tfr(i,1,n*2+1) f[i]=i<p[1]*2?b:i==p[1]*2?0:a;\n\tfr(i,2,n)\n\t{\n\t\tfr(j,1,n*2+1){ F[j]=f[j]; f[j]=inf; }\n\t\ti64 mf=inf;\n\t\tfr(j,1,n*2+1)\n\t\t{\n\t\t\tif(j&1) mf=std::min(mf,F[j]);\n\t\t\tf[j]=mf+(j<p[i]*2?b:j==p[i]*2?0:a);\n\t\t\tif(!(j&1)) mf=std::min(mf,F[j]);\n\t\t}\n\t}\n\tfr(i,1,n*2+1) ans=std::min(ans,f[i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#ifndef  _TB\n#define _TB\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = a; i < b; ++i)\n#define RFOR(i, b, a) for(int i = b - 1; i >= a; --i)\n#define REP(i, N) FOR(i, 0, N)\n#define RREP(i, N) RFOR(i, N, 0)\n\n#define MIN(A, B) ((A) < (B) ? (A) : (B))\n#define MAX(A, B) ((A) > (B) ? (A) : (B))\n#define ABS(A) ((A) < 0 ? (-(A)) : (A))\n#define ALL(V) V.begin(), V.end()\n#define SIZE(V) (int)V.size()\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-7\n#define Pi 3.14159265358979\n#define FILL(a,v) memset(a,v,sizeof(a))\n\nusing namespace std;\n\ntypedef long long Long;\ntypedef unsigned long long ULong;\ntypedef unsigned int Uint;\ntypedef unsigned char Uchar;\ntypedef vector <int> VI;\ntypedef pair <int, int> PII;\n\n#define X first\n#define Y second\n\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.X >> p.Y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.X << ' ' << p.Y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\nvoid fastIO(){ios::sync_with_stdio(false);cin.tie(nullptr); cout.tie(nullptr); }\n\n#endif\n\n\nint a,b;\nint n;\nVI p;\n\n\nconst int MAXN = 5050;\n\nLong dp[MAXN];\n\nLong solve() {\n    VI q = p;\n    q.push_back(MAXN);\n\n    REP(i,n+1)\n        dp[i] = 1e17;\n\n    dp[0] = 0;\n\n    REP(i,n) {\n        Long cur = dp[i];\n        int cm = MAXN+5;\n\n        FOR(j,i+1,n+1) {\n            if (q[j] < q[i])\n                cur += b;\n            else {\n                if (q[j] < cm) {\n                    dp[j] = min(dp[j], cur);\n                }\n                cm = min(cm, q[j]);\n                cur += a;\n            }\n        }\n    }\n\n    return dp[n];\n}\n\nclass DRotationSort {\npublic:\n    void solve(std::istream& in, std::ostream& out) {\n        in >> n >> a >> b;\n        p.resize(n);\n        in >> p;\n        Long a1 = ::solve();\n        reverse(ALL(p));\n        for(auto &pv: p)\n            pv *= -1;\n\n        swap(a,b);\n        Long a2 = ::solve();\n        out << min(a1,a2) << endl;\n\n    }\n};\n\n\nint main() {\n\tDRotationSort solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEBUG\n#include \"better_io.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\nconstexpr int MAXN = 5042;\n\nint N, A, B;\nint V[MAXN];\nint pos[MAXN];\nll gt[MAXN][MAXN];\nll dp[MAXN][MAXN];\n\nll solve(int i, int x) {\n\tif(i == N) return 0;\n\tif(x == N-1) return 0;\n\tif(dp[i][x] != -1) return dp[i][x];\n\tdp[i][x] = min(solve(i, x + 1) + B, solve(pos[x] + 1, x + 1) + A * gt[i][pos[x]]);\n\treturn dp[i][x];\n}\n\nint main() {\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tmemset(dp, -1, sizeof dp);\n\t\n\tcin >> N >> A >> B;\n\t\n\tfor(int i=0; i<N; i++) {\n\t\tcin >> V[i];\n\t\tV[i]--;\n\t\tpos[V[i]] = i;\n\t}\n\t\n\tfor(int j=0; j<N; j++) {\n\t\tfor(int i=j-1; i>=0; i--) {\n\t\t\tgt[i][j] = gt[i+1][j] + (V[i] > V[j]);\n\t\t}\n\t}\n\t\n\tcout << solve(0, 0) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,a,b,p[5050],dy[5050];\nlong long dp[5050][5050],ans=0x3f3f3f3f3f3f3f3f;\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&a,&b);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&p[i]),dy[p[i]]=i;\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tlong long mi=0x3f3f3f3f3f3f3f3f;\n\t\tfor(int j=0;j<=n;++j)\n\t\t{\n\t\t\tmi=min(mi,dp[i-1][j]);\n\t\t\tdp[i][j]=min(dp[i][j],mi+(j>=dy[i]?a:b));\n\t\t\tif(j+1==dy[i])dp[i][j+1]=min(dp[i][j+1],mi);\n\t\t}\n\t}\n\tfor(int i=0;i<=n;++i)ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* Starry Sky Tree */\n//0-index\n\nstruct StarrySkyTree{\n  typedef ll Type;\n  int segn2;\n  vector<Type> data, s_data;\n\n  StarrySkyTree(int n) {\n    for(segn2=1; segn2<n; segn2*=2);\n    data.assign(segn2*2, 0);\n    s_data.assign(segn2*2, 0);\n  }\n\n  //get value of [a,b)\n  Type query(int a, int b, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(r <= a || b <= l) return LLINF; //大きさに注意\n    if(a <= l && r <= b) return data[k] + s_data[k];\n    return min(query(a, b, l, (l+r)/2, k*2+1), query(a, b, (l+r)/2 , r, k*2+2)) + s_data[k];\n  }\n\n  //add x to [a,b)\n  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(a <= l && r <= b)\n      s_data[k] += x;\n    else if(a < r && l < b)\n      data[k] = min(add(a, b, x, l, (l+r)/2, k*2+1), add(a, b, x, (l+r)/2, r, k*2+2));\n\n    return data[k] + s_data[k];\n  }\n\n  Type val(int x){\n    Type res = 0;\n    x += segn2 - 1;\n\n    while(x){\n      res += s_data[x];\n      x = (x-1)/2;\n    }\n\n    return res;\n  }\n\n  void add(int a, Type x){\n    a += segn2 - 1;\n    s_data[a] += x;\n\n    while(a){\n      a = (a-1)/2;\n      data[a] = min(data[a*2+1] + s_data[a*2+1], data[a*2+2] + s_data[a*2+2]);\n    }\n  }\n};\n\nint main(){\n  int N, A, B, p;\n\n  scanf(\"%d%d%d\", &N, &A, &B);\n\n  StarrySkyTree seg(N+1);\n\n  for(int i=0;i<N;i++){\n    scanf(\"%d\", &p);\n\n    seg.add(p, seg.query(0, p) - seg.val(p));\n    seg.add(0, p, A);\n    seg.add(p+1, N+1, B);\n  }\n\n  ll ans = seg.query(0, N+1);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define int long long\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int N = 5005;\nint dp[N][N], p[N], a, b, n;\npbds st[N];\n\nint solve(int i, int j) {\n  if (i == 0 || j == 0) {\n    return 0;\n  }\n  if (p[i - 1] >= j) {\n    return solve(i - 1, j);\n  }\n  int cnt = st[i - 1].order_of_key(j) - st[i - 1].order_of_key(p[i - 1] + 1);\n  return min(solve(i - 1, j) + b, solve(i - 1, min(p[i - 1], j)) + cnt * a);\n}\n\nsigned main() {\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n    if (i > 0) {\n      st[i] = st[i - 1];\n    }\n    st[i].insert(p[i]);\n  }\n  cout << solve(n, n) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\n\nlong long dp[5010];\nint a[5010], pos[5010];\n\nvoid chmin(long long &a, long long b){a = a > b ? a : b;}\n\nstruct Segment_tree{\n\tstruct Node{\n\t\tlong long minj, lazy;\n\t}T[20010];\n\tvoid pushup(int now){\n\t\tT[now].minj = min(T[now << 1].minj, T[now << 1 | 1].minj);\n\t}\n\tvoid pushdown(int now){\n\t\tif (T[now].lazy == INF) return ;\n\t\tlong long v = T[now].lazy; T[now].lazy = INF;\n\t\tchmin(T[now << 1].minj, v);\n\t\tchmin(T[now << 1].lazy, v);\n\t\tchmin(T[now << 1 | 1].minj, v);\n\t\tchmin(T[now << 1 | 1].lazy, v);\n\t}\n\tvoid Build(int now, int l, int r){\n\t\tmemset(T, 0x3f, sizeof(T));\n\t}\n\tvoid Update(int now, int l, int r, int L, int R, long long x){\n\t\tif (l == L && r == R){\n\t\t\tchmin(T[now].minj, x);\n\t\t\tchmin(T[now].lazy, x);\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(now);\n\t\tint mid = l + r >> 1;\n\t\tif (R <= mid) Update(now << 1, l, mid, L, R, x);\n\t\telse if (L > mid) Update(now << 1 | 1, mid + 1, r, L, R, x);\n\t\telse Update(now << 1, l, mid, L, mid, x), Update(now << 1 | 1, mid + 1, r, mid + 1, R, x);\n\t\tpushup(now);\n\t}\n\tvoid get_dp(int now, int l, int r){\n\t\tif (l == r){\n\t\t\tdp[l] = T[now].minj;\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(now);\n\t\tint mid = l + r >> 1;\n\t\tget_dp(now << 1, l, mid), get_dp(now << 1 | 1, mid + 1, r);\n\t}\n}seg;\n\nint main(){\n\tint n, A, B;\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tpos[a[i]] = i + 1;\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tfor (register int i = 1; i <= n; i++){\n\t\tseg.Build(1, 0, n);\n\t\tint x = pos[i];\n\t\tfor (register int j = 0; j <= n; j++){\n\t\t\tif (dp[j] == INF) continue;\n\t\t\tif (j < x) seg.Update(1, 0, n, j, x - 1, dp[j] + B);\n\t\t\tif (j <= x) seg.Update(1, 0, n, x, x, dp[j]);\n\t\t\tseg.Update(1, 0, n, max(x, j), n, dp[j] + A);\n\t\t}\n\t\tseg.get_dp(1, 0, n);\n\t}\n\tlong long ans = INF;\n\tfor (int i = 0; i <= n; i++){\n\t\tchmin(ans, dp[i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=5005;\nll f[N][N],res;int a[N],pos[N],mn[19][N],mx[19][N],Log[N],n,A,B;\ninline int max(R int x,R int y){return x>y?x:y;}\ninline int min(R int x,R int y){return x<y?x:y;}\ninline int qrmx(R int l,R int r){\n\tR int k=Log[r-l+1];\n\treturn max(mx[k][l],mx[k][r-(1<<k)+1]);\n}\ninline int qrmn(R int l,R int r){\n\tR int k=Log[r-l+1];\n\treturn min(mn[k][l],mn[k][r-(1<<k)+1]);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfp(i,1,n)scanf(\"%d\",&a[i]),pos[a[i]]=i;\n\tLog[0]=-1;fp(i,1,n)Log[i]=Log[i>>1]+1;\n\tfp(i,1,n)mn[0][i]=mx[0][i]=pos[i];\n\tfp(j,1,Log[n])fp(i,1,n-(1<<j)+1){\n\t\tmn[j][i]=min(mn[j-1][i],mn[j-1][i+(1<<(j-1))]);\n\t\tmx[j][i]=max(mx[j-1][i],mx[j-1][i+(1<<(j-1))]);\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tres=f[0][n+1],f[0][n+1]=0;\n\tfd(len,n+1,2)for(R int l=0,r=l+len;r<=n+1;++l,++r){\n\t\tR ll coef=f[l][r];\n\t\tcmin(f[l+1][r],coef+B);\n\t\tcmin(f[l][r-1],coef+A);\n\t\tif(qrmn(l+1,r-1)==pos[l+1])cmin(f[l+1][r],coef);\n\t\tif(qrmx(l+1,r-1)==pos[r-1])cmin(f[l][r-1],coef);\n\t}\n\tfp(i,0,n)cmin(res,f[i][i+1]);\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N = 5e3 + 5;\nint n,p[N],not_inv[N];\nLL A,B,f[N][N];\nint main()\n{\n\tcin>>n>>A>>B;\n\tfor (int i = 1;i <= n; ++i)\n\t\tcin>>p[i]; \n\tfor (int i = 1;i <= n; ++i)\n\t{\n\t\tnot_inv[i] = 0;\n\t\tfor (int j = 1;j < i; ++j)\n\t\t\tif (p[j] < p[i])\n\t\t\t\tnot_inv[i]++;\n\t}\n\tfor (int i = 1;i <= n; ++i)\n\t\tfor (int j = 1;j <= i; ++j)\n\t\t\tif (not_inv[i] + 1 > j)\n\t\t\t\tf[i][j] = f[i - 1][j];\n\t\t\telse\n\t\t\t\tf[i][j] = min(f[i - 1][j - 1] + A,f[i - 1][not_inv[i]] + B * ((LL)j - 1 - not_inv[i])); \n\t\t\t\t//f[i - 1][not_inv[i]] + min(A,B * ((LL)j - 1 - not_inv[i]));\n\tcout<<f[n][n];\n } "
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 5e3 + 5;\n\nint P[N], C[N][N], M[N][N];\nll DP[N][N];\n// C[i][j] : # k : i <= k <= j && A[i] > A[k] \n// M[i][j] : index maximum A[k] <= j && k <= i\n// DP[i][j] : answer for first i element and numbers less than j\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\tint n, A, B; cin >> n >> A >> B;\n\tfor (int i = 1; i <= n; i++) cin >> P[i];\n\tfor (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) C[i][j] = C[i][j - 1] + (P[i] > P[j]);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) M[i][j] = (P[i] <= j && P[i] > P[M[i - 1][j]]) ?  i : M[i - 1][j];\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\tif (!M[i][j]) continue;\n\t\tDP[i][j] = min(A + DP[i][P[M[i][j]] - 1], DP[M[i][j] - 1][j] + 1LL * C[M[i][j]][i] * B);\n\t}\n\tcout << DP[n][n] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <boost/container/static_vector.hpp>\n//#include <boost/unordered_set.hpp>\n//#include <boost/unordered_map.hpp>\n//#include <unistd.h>\n\n//#include <cv.h>\n//#include <highgui.h>\n#include <stdlib.h>\n#include <string>\n\nconst int MAX_N = 5050;\nint N;\nlong long A, B;\nint p[MAX_N], pos[MAX_N];\nlong long dp[MAX_N][MAX_N];\nstd::set<int> st;\n\nlong long calc(int l, int r) {\n    if (dp[l][r] != -1) {\n        return dp[l][r];\n    }\n\n    long long ret = 0;\n    if (l + r == N) {\n        assert(st.begin() == st.end());\n    } else if (p[*st.begin()] == l + 1) {\n        int id = *st.begin();\n        st.erase(id);\n        ret = calc(l + 1, r);\n        st.insert(id);\n    } else if (p[*st.rbegin()] == N - r) {\n        int id = *st.rbegin();\n        st.erase(id);\n        ret = calc(l, r + 1);\n        st.insert(id);\n    } else {\n        st.erase(pos[l + 1]);\n        ret = B + calc(l + 1, r);\n        st.insert(pos[l + 1]);\n\n        st.erase(pos[N - r]);\n        ret = std::min(ret, A + calc(l, r + 1));\n        st.insert(pos[N - r]);\n    }\n\n    dp[l][r] = ret;\n    return ret;\n\n}\n\nint main(int argc, char **argv) {\n    std::cin >> N >> A >> B;\n\n    for (int i = 1; i <= N; i++) {\n        std::cin >> p[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        pos[p[i]] = i;\n    }\n\n    for (int i = 1; i <= N; i++) {\n        st.insert(i);\n    }\n\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            dp[i][j] = -1;\n        }\n    }\n\n    std::cout << calc(0, 0) << std::endl;\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctype.h>\n#include <algorithm>\n#include <fstream>\n#include <climits>\n#define mp make_pair\n#define Debug(...) fprintf(stdout, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<int, LL> pil;\n\nconst int MAXN = 5e3 + 7;\n\ninline void proc_status() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\nint n, a, b;\nint p[MAXN];\n\ninline void init() {\n\tn = read<int>(); a = read<int>(); b = read<int>();\n\tfor(int i = 1; i <= n; ++i) p[read<int>()] = i;\n//\tfor(int i = 1; i <= n; ++i) cout << p[i] << endl;\n}\n\nLL f[MAXN][MAXN];\n\ninline void solve() {\n\tmemset(f, 0x3f, sizeof f);\n\n\tf[1][0] = b; f[1][1] = 0;\n\tfor(int i = 2; i <= n; ++i) {\n\t\tfor(int j = 0; j < i; ++j) {\n\t\t\tif(p[i] < p[j]) {\n\t\t\t\tchkmin(f[i][j], f[i - 1][j] + a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchkmin(f[i][j], f[i - 1][j] + b);\n\t\t\t}\n//\t\t\tprintf(\"[%d %d] %lld\\n\", i, j, f[i][j]);\n\t\t}\n\t\tfor(int j = 0; j < i; ++j) {\n\t\t\tif(p[j] < p[i]) chkmin(f[i][i], f[i - 1][j]);\n\t\t}\n//\t\tprintf(\"[%d %d] %lld\\n\", i, i, f[i][i]);\n//\t\tputs(\"\");\n\t}\n//\tcout << endl;\n\tLL ans = LLONG_MAX;\n\tfor(int i = 0; i <= n; ++i) {\n//\t\tcout << f[n][i] << endl;\n\t\tchkmin(ans, f[n][i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\n// pythonのrangeのような範囲for文用のclass for(const auto& i : Range<>(10)) のように書く\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\n// lambda式を用いた再帰\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\n// 多次元vectorの一斉初期化 makeVector<i64, 0>(a, b, ...)のように書く\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\n// 最大値を更新し、更新できた時にはtrueを返す\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// 同様に最小値を更新する\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// 行数と変数名、値をclogに表示するデバッグ用print\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n// 同様の配列向けデバッグ用print\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\n// input用の関数群\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    i64 n, x, y;\n    input(n, x, y);\n    vector<i64> a(n);\n    input(a);\n    list<i64> s;\n    for(const auto& i : Range<>(n))\n        s.push_back(a[i]);\n    i64 ind = 1;\n    i64 sum = 0;\n    // [0, ind) is sorted\n    while(ind != n + 1){\n        auto it = s.begin();\n        for(; *it != ind; ++it);\n        auto it2 = next(it);\n        i64 nex = ind + 1;\n        while(it2 != s.end() && *it2 == nex){\n            ++nex;\n            ++it2;\n        }\n\n        // ここ線形\n        // dist回だけ前に移動する\n        i64 dist = distance(s.begin(), it);\n        // その後、length回だけ回転させる\n        i64 length = distance(it, it2);\n        i64 cost_a = dist * x;\n        i64 cost_b = length * y;\n        sum += min(cost_a, cost_b);\n        for(i64 i = 0; i < length; ++i)\n            it = s.erase(it);\n        ind += length;\n    }\n\n    cout << sum << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define db double\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 5000+5;\nLL f[MAXN][MAXN];\n// 所有数字都移动肯定能有序 所以要对不移动的位置 dp\nint A,B;\nint n,p[MAXN];\n\nint main(){\n    scanf(\"%d%d%d\",&n,&A,&B);\n    FOR(i,1,n) scanf(\"%d\",p+i);\n    CLR(f,0x3f);f[0][0] = 0;\n    FOR(i,1,n){\n        FOR(j,0,n){\n            if(p[i] > j){\n                f[i][j] = std::min(f[i][j],f[i-1][j]+A);\n                f[i][p[i]] = std::min(f[i][p[i]],f[i-1][j]);\n            }\n            else{\n                f[i][j] = std::min(f[i][j],f[i-1][j]+B);\n            }\n        }\n    }\n    LL ans = 1e18;\n    FOR(i,1,n) ans = std::min(ans,f[n][i]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const ll inf = (ll)1e15;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n, a, b; cin >> n >> a >> b;\n\tvi pos(n);\n\trep(i, n){\n\t\tint p; cin >> p;\n\t\tpos[p - 1] = 2 * i + 1;\n\t}\n\t\n\tvector<ll> dp(2 * n + 1, inf);\n\trep(i, n){\n\t\tvector<ll> next(2 * n + 1, inf);\n\t\tll mn = i ? inf : 0;\n\t\trep(j, next.size()){\n\t\t\tint cost = j < pos[i] ? b : j == pos[i] ? 0 : a;\n\t\t\tmn = min(mn, dp[j]);\n\t\t\tnext[j] = mn + cost;\n\t\t}\n\t\tdp = next;\n\t}\n\tcout << *min_element(all(dp)) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n#define LL long long\n\nint n;\nLL a,b;\nint p[5000],inv[5000];\nLL dp[5001][10001],mindp[5001][10002];\n\nint main(){\n  cin>>n>>a>>b;\n  REP(i,n){cin>>p[i];p[i]--;}\n  REP(i,n)inv[p[i]]=i;\n  REP(i,n+1)mindp[i][0]=0LL;\n  REP(i,2*n+1){dp[0][i]=0LL;mindp[0][i+1]=0LL;}\n  \n  FOR(i,1,n+1){\n    REP(j,2*n+1){\n      if(2*inv[i-1]+1==j)\n\tdp[i][j]=mindp[i-1][j];\n      else if(2*inv[i-1]+1 < j)\n\tdp[i][j]=mindp[i-1][j]+a;\n      else\n\tdp[i][j]=mindp[i-1][j]+b;\n    }\n\n    mindp[i][0]=dp[i][0];\n    REP(j,2*n+1){\n      if(j%2!=0)\n\tmindp[i][j+1] = min(dp[i][j],mindp[i][j]);\n      else\n\tmindp[i][j+1] = mindp[i][j];\n    }\n  }\n\n  /*\n  REP(i,n+1){\n    REP(j,2*n+1)\n      cerr<<dp[i][j]<<\" \";\n    cerr<<endl;\n  }\n\n  REP(i,n+1){\n    REP(j,2*n+2)\n      cerr<<mindp[i][j]<<\" \";\n    cerr<<endl;\n  }\n  */\n  \n  \n  cout<<*min_element(dp[n],dp[n]+2*n+1)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 5011;\nint n, a[maxn], pos[maxn];\nll dp[maxn], ndp[maxn];\nint ia[maxn];\nint main()\n{\n\tint A, B;\n\tgeti(n);\n\tgetii(A, B);\n\tfor (int i=1; i<=n; i++) geti(a[i]), ia[a[i]] = i;\n\tmemset(dp, 20, sizeof(dp));\n\tdp[0] = 0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tmemset(ndp, 20, sizeof(ndp));\n\t\tll mn = ndp[0];\n\t\tfor (int j=0; j<=n; j++)\n\t\t{\n\t\t\tif (j==ia[i]) ndp[j] = mn;\n\t\t\tmn = min(mn, dp[j]);\n\t\t\tndp[j] = min(ndp[j], mn+(j<ia[i]?B:A));\n\t\t}\n\t\tswap(dp, ndp);\n\t}\n\tll ans = 1e18;\n\tfor (int i=0; i<=n; i++) ans = min(ans, dp[i]);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n#define N 5003\n#define INF 0x3f3f3f3f3f3f3f3f\n\ninline void cmax(long long &x, long long y) { if (x < y) x = y;}\ninline void cmin(long long &x, long long y) { if (x > y) x = y;}\n\nint n, A, B, a[N], pos[N];\nlong long f[N][N << 1], res = INF;\n\nint main() {\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d\", a + i), pos[a[i]] = i;\n    for (int i = 1; i <= n; ++i) {\n        long long tmp = INF;\n        for (int j = 0; j <= n << 1; ++j) {\n            if (j & 1) {\n                int p = (j + 1) >> 1;\n                cmin(tmp, f[i - 1][j] + (p == pos[i] ? 0 : (p < pos[i] ? B : A)));\n            } else {\n                int p = j >> 1;\n                cmin(tmp, f[i - 1][j] + (p < pos[i] ? B : A));\n            }\n            f[i][j] = tmp;\n        }\n    }\n    long long ans = INF;\n    for (int j = 0; j <= n << 1; ++j)\n        cmin(ans, f[n][j]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 5050;\nconst long long mod = 998244353;\n\nusing namespace std;\n\nint n;\nint a, b;\nlong long d[N][N];\n\nint main()\n{\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n        ios_base::sync_with_stdio(0);\n\n        cin >> n >> a >> b;\n        for(int i = 0; i < N; i++){\n                for(int j = 0; j < N; j++){\n                        d[i][j] = 1e18;\n                }\n        }\n        d[0][0] = 0;\n        for(int i = 1; i <= n; i++){\n                int x;\n                cin >> x;\n                for(int j = 0; j <= n; j++){\n                        if(j > x)\n                                d[i][j] = min(d[i][j], d[i - 1][j] + b);\n                        if(j < x)\n                                d[i][x] = min(d[i][x], d[i - 1][j]);\n                        if(j < x)\n                                d[i][j] = min(d[i][j], d[i - 1][j] + a);\n                }\n        }\n        long long res = 1e18;\n        for(int i = 0; i <= n; i++){\n                res = min(res, d[n][i]);\n        }\n        cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register\n#define int long long\nusing namespace std; const int N=5010;\ninline int read()\n{\n    int s=0,w=1; char ch=getchar();\n    while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar(); return s*w;\n}\nint n,X,Y;\nint dp[N][N],p[N];\nsigned main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tn=read(), X=read(), Y=read();\n\tfor(ri int i=1;i<=n;i++) {int x=read(); p[x]=i; }\n\tfor(ri int i=1;i<=n;i++) for(ri int j=0;j<=n;j++) dp[i][j]=LONG_LONG_MAX/2;\n\tfor(ri int i=1;i<=n;i++)\n\t{\n\t\tfor(ri int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(p[i]==j) dp[i][j]=min(dp[i-1][j-1],dp[i][j]);\n\t\t\tif(j<p[i]) dp[\t\t\tif(j<p[i]) dp[i][j]=min(dp[i][j],dp[i-1][j]+Y);\ni][j]=min(dp[i][j],dp[i-1][j]+Y);\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+X);\n\t\t}\n\t\tfor(ri int j=1;j<=n;j++) dp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n#include <memory.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\n#define N 5002\n#define mod 1000000007\n\nvector<int> segDS[N*4];\n\nint p[N];\n\nint relPosLeft[N][N];\nint relPosRight[N][N];\nvoid init(int n) {\n  for(int i=1;i<=n;++i) {\n    for(int j = i+1;j<=n;++j) {\n      relPosRight[i][j] = relPosRight[i][j-1] + (p[j]<p[i]);\n    }\n  }\n  for(int i=1;i<=n;++i) {\n    for(int j = i-1;j>=1;--j) {\n      relPosLeft[j][i] = relPosLeft[j+1][i] + (p[j]<p[i]);\n    }\n  }\n}\nint getIndex(int l,int r,int findex,int n) {\n  if(l==findex) {\n    return l + relPosRight[l][r];\n  } else {\n    return l + relPosLeft[l][r];\n  }\n}\nlong long dp[N][N];\nint leftMoveCost,rightMoveCost;\nlong long solveDp(int l,int r,int n) {\n  if(l==r) {\n    return 0LL;\n  }\n  long long &ret = dp[l][r];\n  if(ret!=-1) {\n    return ret;\n  }\n  ret = 1e18;\n  //l first\n  int lindex = getIndex(l,r,l,n);\n  int add = 0;\n  if(lindex!=l) {\n    add = leftMoveCost;\n  }\n  ret = min(ret, add + solveDp(l+1,r,n));\n  //r first\n  int rindex = getIndex(l,r,r,n);\n  add = 0;\n  if(rindex!=r) {\n    add = rightMoveCost;\n  }\n  ret = min(ret, add + solveDp(l,r-1,n));\n  return ret;\n}\nvoid solve() {\n  int n,A,B;scanf(\"%d %d %d \", &n,&A,&B);\n  leftMoveCost = B;\n  rightMoveCost = A;\n  for(int i=1;i<=n;++i) {\n    int x;scanf(\"%d \", &x);\n    p[x] = i;\n  }\n  init(n);\n  memset(dp,-1,sizeof(dp));\n  printf(\"%lld\\n\", solveDp(1,n,n));\n}\n\nint main() {\n  //freopen(\"input.txt\",\"r\",stdin);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// khodaya khodet komak kon\n#include <bits/stdc++.h>\n#define pb push_back\n#define ers erase\n#define ins insert\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\n#define kill(x) return cout << x, 0;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<pll> vpl;\n\nconst ld Pi = 3.14159265359;\nconst ll MOD = 1000 * 1000 * 1000 + 7;\nconst ll N = 3e3 + 10;\nconst ll INF = 1e18;\nconst ll LOG = 20;\n\nll Place[N][N], a[N], n, A, B;/*Place[i][j] = where is the maximum number in first i element and max <= j*/\nll dp[N][N];/*dp[i][j] = int the first i element answer for the numbers who ai <= j*/\nll inv[N][N];\n\n\nint main(){\n\tIOS;\n\tcin >> n >> A >> B;\n\tfor (int i = 1; i<= n; i++){\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = i + 1; j <= n; j++){\n\t\t\tinv[i][j] = inv[i][j - 1];\n\t\t\tif (a[i] > a[j]) inv[i][j] ++;\n\t\t}\n\t}\n\t\n\t\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tPlace[i][j] = Place[i - 1][j];\n\t\t\tif (a[i] <= j){\n\t\t\t\tif (a[i] > a[Place[i - 1][j]]){\n\t\t\t\t\tPlace[i][j] = i;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t}\n\t\t\t//cout << i << ' ' << j << ' ' << Place[i][j] << '\\n';\t\t\t\t\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tif (Place[i][j] == 0) continue;\n\t\t\tdp[i][j] = min(dp[i][a[Place[i][j]] - 1] + A, dp[Place[i][j] - 1][j] + inv[Place[i][j]][i] * B);\n\t\t}\n\t}\n\tcout << dp[n][n];\n\t\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n/*\n     ,---,           ___                 ,--,\n    '  .' \\        ,--.'|_             ,--.'|                             ,--,\n   /  ;    '.      |  | :,'            |  | :                           ,--.'|    ,---.        ,---,\n  :  :       \\     :  : ' :            :  : '                 .--.--.   |  |,    '   ,'\\   ,-+-. /  |\n  :  |   /\\   \\  .;__,'  /    ,--.--.  |  ' |     ,--.--.    /  /    '  `--'_   /   /   | ,--.'|'   |\n  |  :  ' ;.   : |  |   |    /       \\ '  | |    /       \\  |  :  /`./  ,' ,'| .   ; ,. :|   |  ,\"' |\n  |  |  ;/  \\   \\:__,'| :   .--.  .-. ||  | :   .--.  .-. | |  :  ;_    '  | | '   | |: :|   | /  | |\n  '  :  | \\  \\ ,'  '  : |__  \\__\\/: . .'  : |__  \\__\\/: . .  \\  \\    `. |  | : '   | .; :|   | |  | |\n  |  |  '  '--'    |  | '.'| ,\" .--.; ||  | '.'| ,\" .--.; |   `----.   \\'  : |_|   :    ||   | |  |/\n  |  :  :          ;  :    ;/  /  ,.  |;  :    ;/  /  ,.  |  /  /`--'  /|  | '.'\\   \\  / |   | |--'\n  |  | ,'          |  ,   /;  :   .'   \\  ,   /;  :   .'   \\'--'.     / ;  :    ;`----'  |   |/\n  `--''             ---`-' |  ,     .-./---`-' |  ,     .-./  `--'---'  |  ,   /         '---'\n                            `--`---'            `--`---'                 ---`-'\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,a,b;\n  cin>>n>>a>>b;\n  vector<Int> p(n);\n  for(Int i=0;i<n;i++) cin>>p[i];\n\n  vector<Int> r(n);\n  for(Int i=0;i<n;i++) r[--p[i]]=i;\n\n  vector<Int> dp(n*2+2,0);\n\n  const Int INF = 1e18;  \n  for(Int i=0;i<n;i++){\n    vector<Int> nx(n*2+2,INF);\n    Int k=r[i]*2+1;\n    Int tmp=INF;\n    for(Int j=0;j<n*2+2;j++){      \n      if(j==k) chmin(nx[j],tmp);\n      chmin(tmp,dp[j]);\n      if(j&1) continue;\n      chmin(nx[j],tmp+(j<k?b:a));\n    }\n    swap(dp,nx);\n  }\n  \n  cout<<*min_element(dp.begin(),dp.end())<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MAX 5100000\nusing namespace std;\nusing Edge=pair<ll,ll>;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint main(){\n  ll N,A,B;\n  cin>>N>>A>>B;\n  vector<int> X(N);\n  REP(i,N){\n    int P;\n    cin>>P;\n    P--;\n    X[P]=i+1;\n  }\n  \n  vector<vector<ll>> DP(N+1,vector<ll>(N+1,INF));\n  REP(i,N+1) DP[0][i]=0;\n  \n  REP(i,N){\n    REP(j,N+1){\n      if(j>0) DP[i+1][j]=DP[i+1][j-1];\n      chmin(DP[i+1][j],DP[i][j]+(X[i]<=j ? A : B));\n      if(X[i]==j) chmin(DP[i+1][j],DP[i][j-1]);\n    }\n  }\n  cout<<DP[N][N]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll A,B,n,dp[2][5050],P[5050];\ninline void chkmin(ll &a,const ll &b){if (a>b) a=b;}\nsigned main(){\n\tn=read(),A=read(),B=read();\n\tfor (int i=1;i<=n;i++) P[i]=read();\n\tbool cur=0;\n\tmemset(dp[cur],0x3f,sizeof dp[cur]);\n\tll inf=dp[0][0];\n\tdp[0][0]=0;\n\tfor (int i=1;i<=n;i++){\n\t\tcur^=1;\n\t\tmemset(dp[cur],0x3f,sizeof dp[cur]);\n\t\tfor (int j=0;j<=n;j++){\n\t\t\tchkmin(dp[cur][j],dp[cur^1][j]+A*(P[i]>j)+B*(P[i]<j));\n\t\t\tif (P[i]>j) chkmin(dp[cur][P[i]],dp[cur^1][j]);\n\t\t}\n\t}\n\tll _=inf;\n\tfor (int i=0;i<=n;i++) chkmin(_,dp[cur][i]);\n\tcout<<_;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//!link: m,stdc++\n//!flag: -g,-DWAAUTOMATON\n// failed\n/*+lmake\n * DEFINE += WAAUTOMATON\n */\n#include <bits/stdc++.h>\n#ifdef WAAUTOMATON\n#define debug(args...)                                                                             \\\n    {                                                                                              \\\n        dbg, args;                                                                                 \\\n        cerr << endl;                                                                              \\\n    }\n#define massert(x) assert(x)\n#else\n#define debug(args...) // Just strip off all debug tokens\n#define massert(x)\n#endif\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef std::pair<int, int> pii;\ntypedef std::pair<LL, LL> pll;\nstruct debugger\n{\n    template <typename T>\n    debugger &operator,(const T &v)\n    {\n        std::cerr << v << \" \";\n        return *this;\n    }\n} dbg;\n\ntemplate <typename T>\ninline void chmax(T &a, T b)\n{\n    a = std::max(a, b);\n}\n\ntemplate <typename T>\ninline void chmin(T &a, T b)\n{\n    a = std::min(a, b);\n}\n\ntemplate <typename T>\ninline T sqr(const T& x)\n{\n\treturn x*x;\n}\n\ntemplate <size_t _I_Buffer_Size = 1 << 23, size_t _O_Buffer_Size = 1 << 23>\nstruct IO_Tp\n{\n    char _I_Buffer[_I_Buffer_Size];\n    char *_I_pos;\n    const char *_I_end;\n\n    char _O_Buffer[_O_Buffer_Size];\n    char *_O_pos;\n    const char *_O_end;\n\n    IO_Tp()\n        : _I_pos(_I_Buffer)\n        , _O_pos(_O_Buffer)\n        , _I_end(_I_Buffer + _I_Buffer_Size)\n        , _O_end(_O_Buffer + _O_Buffer_Size)\n    {\n    }\n\n    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }\n\n    inline char getchar()\n    {\n        char res = *_I_pos;\n        nextchar();\n        return res;\n    }\n\n    inline bool is_digit(const char ch) { return '0' <= ch && ch <= '9'; }\n\n    inline void nextchar()\n    {\n        ++_I_pos;\n        if (_I_pos == _I_end) {\n            fread(_I_Buffer, 1, _I_Buffer_Size, stdin);\n            _I_pos = _I_Buffer;\n        }\n    }\n\n    template <typename Int>\n    inline IO_Tp &operator>>(Int &res)\n    {\n        res = 0;\n        int k = 1;\n        while (!is_digit(*_I_pos)) {\n            if (*_I_pos == '-')\n                k = -1;\n            nextchar();\n        }\n        do {\n            (res *= 10) += (*_I_pos) - '0';\n            nextchar();\n        } while (is_digit(*_I_pos));\n        res *= k;\n        return *this;\n    }\n\n    inline IO_Tp &operator>>(char &res)\n    {\n        do {\n            res = *_I_pos;\n            nextchar();\n        } while (res == ' ' || res == '\\0' || res == '\\t' || res == '\\n' || res == '\\r');\n        return *this;\n    }\n\n    inline void putchar(char x)\n    {\n        if (_O_pos == _O_end) {\n            fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout);\n            _O_pos = _O_Buffer;\n        }\n        *_O_pos++ = x;\n    }\n    template <typename Int>\n    inline IO_Tp &operator<<(Int n)\n    {\n        if (n < 0) {\n            putchar('-');\n            n = -n;\n        }\n        static char _buf[20];\n        char *_pos(_buf);\n        do\n            *_pos++ = '0' + n % 10;\n        while (n /= 10);\n        while (_pos != _buf)\n            putchar(*--_pos);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(char ch)\n    {\n        putchar(ch);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(const char *s)\n    {\n        while (*s != 0) {\n            putchar(*s);\n            ++s;\n        }\n        return *this;\n    }\n};\nIO_Tp<> IO;\n\nconst int MAXN=5000;\nint a[MAXN+10];\nLL A,B;\nvector<int> in[MAXN+10],out[MAXN+10];\nint icnt[MAXN+10],ocnt[MAXN+10];\nvoid add(int x)\n{\n\tfor(auto v:out[x]) {\n\t\ticnt[v]++;\n\t}\n}\nbool b[MAXN+10];\nint main()\n{\n#ifdef WAAUTOMATON\n    //freopen(\"./in_D_5.txt\", \"r\", stdin);\n#endif\n\tLL ans=LLONG_MAX/3;\n\tint n;\n\tIO>>n>>A>>B;\n\tfor(int i=1; i<=n; ++i) {\n\t\tIO>>a[i];\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=i+1; j<=n; ++j) {\n\t\t\tif (a[i]>a[j]) {\n\t\t\t\tin[a[i]].push_back(a[j]);\n\t\t\t\tout[a[j]].push_back(a[i]);\n\t\t\t\tocnt[a[j]]++;\n\t\t\t}\n\t\t}\n\t}\t\n\tLL cntb=n;\n\tfor(int i=1; i<=n; ++i) {\n\t\tif (ocnt[i]==0) --cntb;\n\t\telse if (ocnt[i]==1) {\n\t\t\tadd(i);\n\t\t}\n\t}\n\tchmin(ans,cntb*B);\n\tfor(LL cnta=1; cnta<=n; ++cnta) {\n\t\tint p=0;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tif (!b[i] && icnt[i]>=icnt[p]) {\n\t\t\t\tp=i;\n\t\t\t}\n\t\t}\n\t\tif (p==0 || icnt[p]==0) break;\n\t\tcntb-=icnt[p];\n\t\tchmin(ans,cnta*A+cntb*B);\n\t\tassert(cntb>=0);\n\t\tb[p]=true;\n\t\tfor(auto v:in[p]) {\n\t\t\tocnt[v]--;\n\t\t\tif (ocnt[v]==1) {\n\t\t\t\tadd(v);\n\t\t\t}\n\t\t}\n\t}\n\tIO<<ans<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#undef LOCAL\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n#define FOR(i, a, b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define rep1(i,N) for(int i=1;i<=(int)(N);i++)\n#define fs first\n#define sc second\n#define eb emplace_back\n#define pb eb\n#define all(x) x.begin(),x.end()\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\n#ifdef LOCAL\n#define show(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n\nint n;\nll A, B;\n\nV<int> v;\n\nconst int MN = 5050;\nbool used[MN][MN];\nll dp[MN][MN];\nll solve(int p, int b) {\n    if (p == n) return 0;\n    if (used[p][b + 1]) return dp[p][b + 1];\n    used[p][b + 1] = true;\n\n    ll& ans = dp[p][b + 1]; ans = TEN(18);\n    if (b == -1 || v[b] < v[p]) ans = min(ans, solve(p + 1, p));\n\n    if (b != -1 && v[b] > v[p]) ans = min(ans, B + solve(p + 1, b));\n    else ans = min(ans, A + solve(p + 1, b));\n\n    return ans;\n}\n\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    cin >> n >> A >> B;\n    v = V<int>(n);\n    for (int i = 0; i < n; i++) cin >> v[i];\n\n    cout << solve(0, -1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int maxn=5e3+2;\nlong long n, A, B, dp[maxn], a[maxn];\n\nvoid Enter()\n{\n    cin>>n>>A>>B;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n    a[n+1]=1e18;\n    for(int i=1;i<=n+1;i++)\n    {\n        dp[i]=1e18;\n        long long t=0;\n        for(int j=i-1;j>=0;j--)\n        {\n            if(a[j]>a[i])t++;\n            else\n                dp[i]=min(dp[i],dp[j]+t*A+(i-j-1-t)*B);\n        }\n    }\n    cout<<dp[n+1];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    Enter();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define FORqr(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int (x); SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long (x); SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\n#define M0(x) memset(x,0,sizeof(x))\n#define FILL(x,y) memset(x,y,sizeof(x))\n#define MM(x) memset(x,-1,sizeof(x))\n#define ALL(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef pair<long long,long long> PLL;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n///////////////////////////////////////////////\nconst ll MOD = 1000000007;\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////\n\n/*（๑•﹏•๑｀) */\n\n\nint main() {\n    static ll a[5002] = {};\n    static ll b[5002] = {};\n    int N;\n    ll A;\n    ll B;\n    ll ans = 0;\n\n\n    cin >> N >> A >> B;\n    FORq(i,1,N){\n        cin >> a[i];\n        b[a[i]] = i;\n    }\n\n    static ll dp[5003][10005] = {};\n    static ll dpS[5003][10005] = {};\n    REP(i,5003){\n        REP(j,10005){\n            if (i != 0) {\n                dp[i][j] = 1e16;\n                dpS[i][j] = 1e16;\n            }\n            else {\n                dp[i][j] = 0;\n                dpS[i][j] = 0;\n            }\n\n        }\n    }\n\n    FORq(i,1,N){\n        FORq(j,1,2*N+1){\n            ll mini = dpS[i-1][j-1];\n\n            if (j < b[i] * 2) dp[i][j] = mini + B;\n            if (j > b[i] * 2) dp[i][j] = mini + A;\n            if (j == b[i] * 2) dp[i][j] = mini;\n\n\n            dpS[i][j] = min(dpS[i][j-1],dp[i][j]);\n        }\n\n\n    }\n\n//    FORq(i,1,N){\n//        FORq(j,1,2*N+1){\n//            printf(\"dp[%d][%d] = %lld\\n\",i,j,dp[i][j]);\n//        }\n//    }\n    cout << dpS[N][2*N+1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define int long long\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nll INF=1e18;\n\nll dp[5123][5123];\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,R,L;\n\t// n=5000; R=L=1000000000; --L;\n\tcin>>n>>R>>L;\n\tINF=ll(n-1)*min(L,R);\n\tvector<int> a(n); //rep(i,n) a[i]=n-1-i;\n\trep(i,n) cin>>a[i], --a[i];\n\tvector<int> toL(n),toR(n);\n\t{\n\t\tset<int> st{(ll)1e15};\n\t\trep(i,n){\n\t\t\ttoL[a[i]]=*st.lower_bound(a[i]);\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\t{\n\t\tset<int> st{-(ll)1e15};\n\t\trrep(i,n){\n\t\t\tauto it=st.lower_bound(a[i]); --it;\n\t\t\ttoR[a[i]]=*it;\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\t// out(toL,toR,1);\n\tfill(dp[0],dp[5123],INF);\n\tdp[0][n-1]=0;\n\trreps(d,2,n+1)rrep(l,n+1-d){\n\t\tint r=l+d-1;\n\t\tMN(dp[l+1][r],dp[l][r]+(toL[l]>r?0:L));\n\t\tMN(dp[l][r-1],dp[l][r]+(toR[r]<l?0:R));\n\t}\n\t// rep(i,n){rep(j,n) cout<<dp[i][j]<<\",\";cout<<endl;}\n\tll re=INF;\n\trep(i,n) MN(re,dp[i][i]);\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\nusing ll = long long;\ntypedef pair<int, int> P;\nll Mod = 1000000007;\n\nint N;\nll A,B;\nint p[5012];\nll C[5012];\nbool Graph[5012][5012];\nbool Tr[5012];\nbool exist[5012];\n\nll DFS(int a) {\n  Tr[a] = true;\n  ll f = 0;\n  int min_num = 99999;\n  for (int i = a+1; i < N; i++) {\n    if (Graph[a][i]) {\n      if (min_num < p[i]) {\n        continue;\n      } else {\n        min_num = p[i];\n      }\n      f = max(f,DFS(i) + C[i]); \n      Tr[i] = true;\n    }\n  }\n  return f;\n}\n\nint main() {\n  cin >> N >> A >> B;\n  for (int i = 0; i < N; i++) {\n    cin >> p[i];\n    p[i]--;\n    \n  }\n  ll normal_cost = 0;\n  for (int i = 0; i < N; i++) {\n    if (p[i] > i) {\n      normal_cost += A;\n      C[i] = A;\n    } else if (p[i] < i) {\n      normal_cost += B;\n      C[i] = B;\n    } else {\n      C[i] = 0;\n    }\n  }\n  \n  for (int i = 0; i < N; i++) {\n    for (int j = i; j < N; j++) {\n      if (p[i] < p[j]) {\n        exist[i] = true;\n        Graph[i][j] = true;\n      }\n    } \n  }\n  ll ans = normal_cost;\n  ans = min(ans,A*(N-1));\n  ans = min(ans,B*(N-1));\n  for (int i = 0; i < N; i++) {\n    if (Tr[i]) {\n      continue;\n    }\n    ll res = normal_cost;\n    if (!exist[i]) {\n      continue;\n    }\n    res -= C[i];\n    res -= DFS(i);\n    ans = min(ans,res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\n \nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ngpu_hash_map<int, int> mp;*/\nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000007;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = -1e6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 5002;\nll dp[mxN][mxN];\nint n;\nll a, b;\nint arr[mxN];\nint pos[mxN];\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n>>a>>b;\n    owo(i, 0, n) {\n        cin>>arr[i];\n        pos[arr[i]] = i;\n    }\n    memset(dp, INFLL, sizeof(dp));\n    owo(i, 0, mxN) {\n        dp[0][i] = 0;\n    }\n    owo(i, 1, n+1) {\n        int p = pos[arr[i]];\n        ll mn = INFLL;\n        owo(j, 0, n+1) {\n            mn = min(mn, dp[i-1][j]);\n            if(j>pos[i]) {\n                dp[i][j] = min(dp[i][j], mn+a);\n            }else {\n                dp[i][j] = min(dp[i][j], mn+b);\n            }\n            if(j==pos[i]) dp[i][n+1] = min(dp[i][n+1], mn);\n            if(j==pos[i-1])mn = min(mn, dp[i-1][n+1]);\n        }\n        /*mn = INFLL;\n        uwu(j, n+1, 0) {\n            if(j==pos[i-1])mn = min(mn, dp[i-1][n+1]);\n            if(j==pos[i]) dp[i][n+1] = min(dp[i][n+1], mn);\n            mn = min(mn, dp[i-1][j]);\n            if(j<=pos[i]) {\n                dp[i][j] = min(dp[i][j], mn+b);\n            }\n        }*/\n        /*owo(j, 0, n+2) {\n            cout<<i<<\" \"<<dp[i][j]<<\"\\n\";\n        }*/\n    }\n    ll ans = INFLL;\n    owo(i, 0, n+2) {\n        ans = min(ans, dp[n][i]);\n    }\n    cout<<ans<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define upd(x, y) x=min(x, y)\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=5010, LOG=20;\n\nint n, m, k, u, v, x, y, t, A, B;\nint P[MAXN], PP[MAXN];\nll dp[MAXN][MAXN], ans;\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tmemset(dp, 63, sizeof(dp));\n\tcin>>n>>A>>B;\n\tfor (int i=1; i<=n; i++) cin>>P[i], PP[P[i]]=i;\n\tdp[0][0]=0;\n\tfor (int i=0; i<n; i++) for (int j=0; j<=i; j++){\n\t\tif (PP[j]<PP[i+1]) upd(dp[i+1][j], dp[i][j]+B);\n\t\tif (PP[j]>PP[i+1]) upd(dp[i+1][j], dp[i][j]+A);\n\t\tif (PP[j]<PP[i+1]) upd(dp[i+1][i+1], dp[i][j]);\n\t}\n\tans=INF;\n\tfor (int i=0; i<=n; i++) upd(ans, dp[n][i]);\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* Starry Sky Tree */\n//0-index\n\nstruct StarrySkyTree{\n  typedef ll Type;\n  int segn2;\n  vector<Type> data, s_data;\n  function<Type(Type, Type)> merge;\n\n  StarrySkyTree(function<Type(Type, Type)> merge, int n): merge(merge)\n  {\n    for(segn2=1; segn2<n; segn2*=2);\n    data.assign(segn2*2, 0);\n    s_data.assign(segn2*2, 0);\n  }\n\n  StarrySkyTree(int n): //Original Ver.\n    StarrySkyTree([](Type a, Type b){ return min(a, b); }, n) {}\n\n  //get value of [a,b)\n  Type query(int a, int b, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(r <= a || b <= l) return LLINF; //大きさに注意\n    if(a <= l && r <= b) return data[k] + s_data[k];\n    return merge(query(a, b, l, (l+r)/2, k*2+1), query(a, b, (l+r)/2 , r, k*2+2)) + s_data[k];\n  }\n\n  //add x to [a,b)\n  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(a <= l && r <= b)\n      s_data[k] += x;\n    else if(a < r && l < b)\n      data[k] = merge(add(a, b, x, l, (l+r)/2, k*2+1), add(a, b, x, (l+r)/2, r, k*2+2));\n\n    return data[k] + s_data[k];\n  }\n\n};\n\nint main(){\n  int N, A, B;\n  int p[SIZE];\n\n  cin >> N >> A >> B;\n\n  for(int i=0;i<N;i++)\n    cin >> p[i];\n\n  StarrySkyTree seg(N+1);\n\n  for(int i=0;i<N;i++){\n    ll minVal = seg.query(0, p[i]);\n\n    seg.add(0, p[i], A);\n    seg.add(p[i]+1, N+1, B);\n\n    ll q = seg.query(p[i], p[i]+1);\n    seg.add(p[i], p[i]+1, minVal - q);\n  }\n\n  ll ans = seg.query(0, N+1);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define ull unsigned long long\n#define mp make_pair\n#define ld long double\n#define fi first\n#define se second\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nconst int N=5005;\nconst ll inf=1e18;\nll dp[N][N];\nint p[N],A,B,to[N];\nint main(){\n\tint n=read(); A=read(); B=read();\n\tfor(int i=1;i<=n;i++){\n\t\tp[i]=read(); to[p[i]]=i;\n\t}\n\tll ans=inf;\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)dp[i][j]=inf;\n\tdp[0][0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(p[i+1]<=j)dp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\tif(to[j+1]<=i)dp[i][j+1]=min(dp[i][j+1],dp[i][j]);\n\t\t\tif(p[i+1]==j+1)dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]);\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+A);\n\t\t\tdp[i][j+1]=min(dp[i][j+1],dp[i][j]+B);\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)if(max(i,j)==n)ans=min(ans,dp[i][j]);\n\tcout<<ans<<endl;\n}\n/*\n位置<i 或者 <=j的数已经归位 \n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 5e3 + 5;\nconst int kInf = 1e18;\nint dp[N][N];\nint min_pos[N][N];\nint max_pos[N][N];\n\nint p[N];\nint wh[N];\nint last_fixed[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, a, b;\n  cin>>n>>a>>b;\n  RE (i, n) {\n    cin>>p[i];\n    wh[p[i]] = i;\n    min_pos[p[i]][p[i]] = i;\n    max_pos[p[i]][p[i]] = i;\n    last_fixed[i] = kInf;\n  }\n  last_fixed[n + 1] = kInf;\n  wh[n + 1] = n + 1;\n  n++;\n  last_fixed[0] = 0;\n  RE (i, n) {\n    REP (prv_fixed, i) {\n      if (wh[prv_fixed] < wh[i]) {\n        mini(last_fixed[i], last_fixed[prv_fixed]);\n        last_fixed[prv_fixed] += b;\n      } else {\n        last_fixed[prv_fixed] += a;\n      }\n    }\n  }\n      //wh[prv_fixed] \n//   FOR (len, 2, n) {\n//     RE (i, n - len + 1) {\n//       int j = i + len - 1;\n//       dp[i][j] = min(dp[i + 1][j] + b, dp[i][j - 1] + a);\n//       if (min_pos[i][i] < min_pos[i + 1][j]) {\n//         mini(dp[i][j], dp[i + 1][j]);\n//       }\n//       if (max_pos[j][j] > max_pos[i][j - 1]) {\n//         mini(dp[i][j], dp[i][j - 1]);\n//       }\n//       max_pos[i][j] = max(max_pos[i][j - 1], max_pos[j][j]);\n//       min_pos[i][j] = min(min_pos[i][i], min_pos[i + 1][j]);\n//     }\n//   }\n//   cout<<dp[1][n]<<endl;\n  cout<<last_fixed[n]<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 5005\nint n,a,b;\nlg dp[MN][MN];\nint v[MN];\n#define Mi(x,y) (x)=(x)<(y)?(x):(y)\nint main(){\n\tread(n);read(a);read(b);\n\tfor(int i=1;i<=n;++i)read(v[i]);\n\tmemset(dp,0x3f,sizeof dp);\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tif(j<=v[i]){\n\t\t\t\tMi(dp[j][i],dp[j][i-1]+a);\n\t\t\t\tMi(dp[v[i]][i],dp[j][i-1]);\n\t\t\t}else{\n\t\t\t\tMi(dp[j][i],dp[j][i-1]+b);\n\t\t\t}\n\t\t}\n\t}\n\tlg res=0x3f3f3f3f3f3f3f3f;\n\tfor(int i=0;i<=n;++i)Mi(res,dp[i][n]);\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll N = 5e3 + 15, inf = 1000000LL * 1000000LL * 10, LOG = 13;\nll n, R, L;\nint Arr[N];\nll dp[N], ans;\nint seg[LOG][N];\n\nvoid build (int s = 0, int e = n, int lvl = 0) {\n\tfor (int i = s; i < e; i++)\n\t\tseg[lvl][i] = Arr[i];\n\tsort(seg[lvl] + s, seg[lvl] + e);\n\n\tif (e - s == 1)\n\t\treturn ;\n\n\tint mid = e + s >> 1;\n\tbuild(s, mid, lvl + 1);\n\tbuild(mid, e, lvl + 1);\n}\n\nint get (int l, int r, int val, int s = 0, int e = n, int lvl = 0) {\n\tif (l <= s && e <= r)\n\t\treturn upper_bound(seg[lvl] + s, seg[lvl] + e, val) - (seg[lvl] + s);\n\tif (r <= s || e <= l)\n\t\treturn 0;\n\n\tint mid = e + s >> 1;\n\treturn get(l, r, val, s, mid, lvl + 1) + get(l, r, val, mid, e, lvl + 1);\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> R >> L;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> Arr[i];\n\tbuild();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i] = inf;\n\t\tif (get(0, i + 1, Arr[i]) == 1)\n\t\t\tdp[i] = R * i;\n\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (Arr[j] < Arr[i] && get(j, i + 1, Arr[i]) - get(j, i + 1, Arr[j]) == 1) {\n\t\t\t\tint cnt = get(j, i + 1, Arr[j]) - 1;\n\t\t\t\tdp[i] = min(dp[i], dp[j] + L * cnt + R * (i - j - 1 - cnt));\n\t\t\t}\n\t}\n\n\tans = inf;\n\tfor (int i = 0; i < n; i++)\n\t\tif (Arr[i] - get(0, i + 1, Arr[i]) == n - i - 1)\n\t\t\tans = min(ans, dp[i] + (n - i - 1) * L);\n\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <bitset>\n#include <utility>\n#include <ctime>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pii > vii;\ntypedef vector<pair<int, pair<int, int> > > viii;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<vii> vvii;\n\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n#define MEM(a,b) memset(a,(b),sizeof(a))\n#define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define all(a) a.begin(),a.end()\n#define loop(x,a,b) for(int (x) = (a);(x)<(b);(x)++)\n#define rep(x,n)   for(int (x)=0;(x)<(n);(x)++)\n#define present(c,x) ((c).find(x) != (c).end()) \n#define cpresent(c,x) (find(all(c),x) != (c).end())\n#define ain(a,n) int ((a)[(n)]); for(int i=0; i<(n); i++) cin>>((a)[i])  \n#define md 1000000007\n#define MAXN 200005\n\nll dp[5001][5001];\n\nint main()\n{   \n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n,a,b;\n    cin>>n>>a>>b;\n    int array[n+1];\n    array[0] = 0;\n    rep(i,n)\n      cin>>array[i+1];\n\n    rep(i,n+1)\n      rep(j,n+1)\n        dp[i][j] = 1e18;\n\n    dp[0][0] = 0;\n    rep(i,n)\n      rep(j,n+1)\n      {\n        if(array[i+1] > array[j])\n          dp[i+1][i+1] = min(dp[i+1][i+1], dp[i][j]);\n        dp[i+1][j] = min(dp[i+1][j], dp[i][j] + (array[i+1] > array[j]? a : b));\n      }\n    ll ans = 1e18;\n    rep(i,n+1)\n      ans = min(ans, dp[n][i]);\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll INF = (ll)1e17;\nconst int N = 5050;\nll dp[N];\nint n;\nint a[N];\nll A, B;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%lld%lld\", &n, &A, &B);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tif (A < B) {\n\t\treverse(a + 1, a + n + 1);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = n + 1 - a[i];\n\t\tswap(A, B);\n\t}\n\ta[0] = 0;\n\ta[n + 1] = n + 1;\n\tfor (int i = 0; i <= n + 1; i++)\n\t\tdp[i] = INF;\n\tdp[0] = 0;\n\tfor (int l = 0; l <= n; l++) {\n\t\tll w = 0;\n\t\tfor (int r = l + 1; r <= n + 1; r++) {\n\t\t\tif (a[r] < a[l]) {\n\t\t\t\tw += A;\n\t\t\t} else {\n\t\t\t\tdp[r] = min(dp[r], dp[l] + w);\n\t\t\t\tw += B;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n + 1]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define ll __int128\n#define ll long long\n#define LEFT(a) ((a)<<1)\n#define RIGHT(a) (LEFT(a) + 1)\n#define MID(a,b) ((a+b)>>1)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define y1 y122\n/*\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"unroll-loops\")\n#pragma comment(linker, \"/STACK: 20000000005\")\n*/\n\nusing namespace std;\n\nconst ll N = 5005, MOD = 1e9 + 7;\n\nll n;\nll A, B;\n\nll a[N], b[N];\nll d[N][N];\nll dp[N][N];\n\n\nmain()\n{\n    //freopen (\"in.in\", \"r\", stdin);freopen (\"out.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++){\n        cin >> a[i];\n        b[a[i]] = i;\n    }\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j < b[i]; j++)\n            dp[i][j] = dp[i - 1][j];\n        ll num = -1;\n        for (int j = b[i]; j <= n; j++){\n            if (a[j] > i){\n                dp[i][j] = dp[i][j - 1];\n                continue;\n            }\n            num++;\n            dp[i][j] = min (dp[i - 1][j] + A, dp[i - 1][b[i] - 1] + num * B);\n        }\n    }\n    cout << dp[n][n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#define int long long\nusing namespace std;\nconst int N=5e3+2;\nconst int inf=1e18+2;\nint dp[N],ar[N],lef[N],rig[N],pos[N],bit[N];\nvoid upd(int pos){\n\twhile(pos<N){\n\t\tbit[pos]++;\n\t\tpos+=(pos&-pos);\n\t}\n}\nint get(int idx){\n\tint sum=0;\n\twhile(idx){\n\t\tsum+=bit[idx];\n\t\tidx-=(idx&-idx);\n\t}\n\treturn sum;\n}\nint getsum(int l,int r){\n\treturn get(r)-get(l-1);\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,a,b,ans=inf,idxans;\n\tcin>>n>>a>>b;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t\tpos[ar[i]]=i;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<i;j++){\n\t\t\tif(ar[j]>ar[i]){\n\t\t\t\tlef[ar[i]]++;\n\t\t\t}\n\t\t}\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tif(ar[j]>ar[i]){\n\t\t\t\trig[ar[i]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tdp[i]=(i-1)*b;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tbit[j]=0;\n\t\t}\n\t\tfor(j=i-1;j>=1;j--){\n\t\t\tif(pos[j]<pos[i]&&getsum(pos[j],pos[i])==0){\n//\t\t\t\tif(dp[j]+getsum(1,pos[j]-1)*a+getsum(pos[i]+1,n)*b<dp[i]){\n//\t\t\t\t\ttrace[i]=j;\n//\t\t\t\t}\n\t\t\t\tdp[i]=min(dp[i],dp[j]+getsum(1,pos[j]-1)*a+getsum(pos[i]+1,n)*b);\n\t\t\t}\n\t\t\tupd(pos[j]);\n\t\t}\n\t\tif(rig[i]==0){\n//\t\t\tif(dp[i]+lef[i]*a<ans){\n//\t\t\t\tidxans=i;\n//\t\t\t}\n\t\t\tans=min(ans,dp[i]+lef[i]*a);\n\t\t}\n\t\t//cout<<dp[i]+lef[i]*a<<' '<<dp[i]<<' '<<i<<' '<<rig[i]<<endl;\n\t}\n//\twhile(idxans){\n//\t\tcout<<idxans<<' ';\n//\t\tidxans=trace[idxans];\n//\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 5003\n#define ll long long\n\nusing namespace std;\n\nint n, m, a, b;\nint pos[N];\nll f[N][N << 1];\n\nint main(){\n\tcin >> n >> a >> b; m = n * 2 + 1;\n\tfor(int i = 1; i <= n; ++i){\n\t\tint x; scanf(\"%d\", &x);\n\t\tpos[x] = i * 2;\n\t}\n\tmemset(f, 127, sizeof f);\n\tfor(int j = 1; j <= m; ++j) f[0][j] = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= m; ++j){\n\t\t\tll tmp = (j != pos[i]) * (j < pos[i] ? b : a);\n\t\t\ttmp += f[i - 1][j - !(j & 1)]; \n\t\t\tf[i][j] = min(f[i][j - 1], tmp);\n\t\t}\n\tcout << f[n][m] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ld long double\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nconstexpr double eps=1e-8;\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint Random(int mi,int ma){\n    random_device rnd;\n    mt19937 mt(rnd());//32bit\n    //[mi,ma]\n    uniform_int_distribution<int>engine(mi,ma);\n    return engine(mt);\n}\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nvector<int>kaijo,invkaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    invkaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n    rep(i,n+1)invkaijo[i]=modpow(kaijo[i],mod-2);\n}\nint comb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return kaijo[a]*invkaijo[a-b]%mod*invkaijo[b]%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nvoid solve(){\n    int n,a,b,p[5010],q[5010],dp[5010][10010];\n    cin>>n>>a>>b;\n    rep(i,n){\n        cin>>p[i];\n        q[p[i]-1]=i+1;\n    }\n    rep(i,n+1)rep(j,2*n+2)dp[i][j]=INF;\n    dp[0][1]=0;\n    rep(i,n){\n        int cur=INF;\n        for(int j=1;j<=2*n+1;j++){\n            if(j%2==1){\n                chmin(cur,dp[i][j]);\n                chmin(cur,dp[i][j-1]);\n            }\n            if(j>q[i]*2)chmin(dp[i+1][j],cur+a);\n            if(j<q[i]*2)chmin(dp[i+1][j],cur+b);\n            if(j==q[i]*2)chmin(dp[i+1][j],cur);\n        }\n    }\n    cout<<*min_element(dp[n],dp[n]+2*n+2)<<endl;\n}\nsigned main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    //int t;cin>>t;while(t--)\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 5005;\n\nll n, a, b, x, y;\n\nll ara[MAX];\nll dp[MAX][MAX];\nll rngmx[MAX][MAX], rngmn[MAX][MAX];\nll boro[MAX][MAX], choto[MAX][MAX];\n\n\nll fnc(ll beg, ll ed){\n    if(beg == ed) return 0;\n    \n    if(dp[beg][ed] != -1) return dp[beg][ed];\n    \n    ll cc = 0;\n    if(rngmn[beg + 1][ed] < ara[beg]) cc = a;\n    \n    ll re1 = fnc(beg + 1, ed) + cc;\n    //ll re3 = fnc(beg + 1, ed) + choto[beg+1][ed] * b;\n    //re1 = min(re1,re3);\n    \n    cc = 0;\n    if(rngmx[beg][ed - 1] > ara[ed]) cc = b;\n    \n    ll re2 = fnc(beg, ed - 1) + cc;\n    //ll re4 = fnc(beg,ed-1) + boro[beg][ed-1] * a;\n    //re2 = min(re2,re4);\n    \n    return dp[beg][ed] = min(re1, re2);\n}\n\nll BIT[MAX];\nvoid update(ll indx, ll val){\n    while(indx<MAX){\n        BIT[indx]+=val;\n        indx+=(indx&-indx);\n    }\n}\n\nll sum(ll indx){\n    ll ans=0;\n    while(indx!=0){\n        ans+=BIT[indx];\n        indx-=(indx&-indx);\n    }\n    return ans;\n}\n\nint main(){\n    cin >> n >> a >> b;\n    for(ll i = 1; i <= n; i++) scanf(\"%lld\", &ara[i]);\n    \n    memset(dp, -1, sizeof(dp));\n    \n    for(int i = 1; i <= n; i++){\n        ll mx = ara[i], mn = ara[i];\n        for(int j = i; j <= n; j++){\n            mx = max(mx, ara[j]);\n            mn = min(mn, ara[j]);\n            rngmx[i][j] = mx;\n            rngmn[i][j] = mn;\n            \n            update(ara[j],1);\n            boro[i][j] = j - i + 1 - sum(ara[j+1]);\n            choto[i][j] = sum(ara[i-1]);\n        }\n        \n        for(int j = i; j <= n; j++) update(ara[j],-1);\n    }\n    \n    ll ans = fnc(1, n);\n    \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nint N;\nll A,B;\nint p[5010],where[5010];\nll dp[5010][5010];\nconst ll inf = 1e18;\nint AA[5010][5010];\nint BB[5010][5010];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tcin >> N >> A >> B;\n\trep(i,N) cin >> p[i],p[i]--,where[p[i]] = i;\n\n\trep(i,N+1) rep(j,N+1) dp[i][j] = inf;\n\n\trep(a,N){\n\t\tint now = 0;\n\t\tfor(int b=a+1;b<N;b++){\n\t\t\tif(where[b]<where[a]) now++;\n\t\t\tAA[a][b] = now;\n\t\t}\n\t}\n\trep(b,N){\n\t\tint now = 0;\n\t\tfor(int a=b-1;a>=0;a--){\n\t\t\tif(where[b]<where[a]) now++;\n\t\t\tBB[a][b] = now;\n\t\t}\n\t}\n\n\tauto getAA = [&](int a,int b){\n\t\tint res = 0;\n\t\trep(i,N){\n\t\t\tif(p[i] == a) break;\n\t\t\tif(a<=p[i] && p[i]<=b) res++;\n\t\t}\n\t\treturn res;\n\t};\n\tauto getBB = [&](int a,int b){\n\t\tint res = 0;\n\t\tfor(int i=N-1;i>=0;i--){\n\t\t\tif(p[i] == b) break;\n\t\t\tif(a<=p[i] && p[i]<=b) res++;\n\t\t}\n\t\treturn res;\n\t};\n\n\tdp[0][N-1] = 0;\n\tfor(int d=N-1;d>0;d--){\n\t\trep(a,N+1){\n\t\t\tint b = a+d;\n\t\t\tif(b>N-1) break;\n\t\t\tassert(getAA(a,b) == AA[a][b]);\n\t\t\tassert(getBB(a,b) == BB[a][b]);\n\t\t\tint aa = AA[a][b];\n\t\t\tint bb = BB[a][b];\n\t\t\tll costA = min(B,A*aa);\n\t\t\tll costB = min(A,B*bb);\n\t\t\tchmin(dp[a+1][b],dp[a][b]+costA);\n\t\t\tchmin(dp[a][b-1],dp[a][b]+costB);\n\t\t}\n\t}\n\tll ans = inf;\n\trep(i,N) chmin(ans,dp[i][i]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\n// pythonのrangeのような範囲for文用のclass for(const auto& i : Range<>(10)) のように書く\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\n// lambda式を用いた再帰\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\n// 多次元vectorの一斉初期化 makeVector<i64, 0>(a, b, ...)のように書く\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\n// 最大値を更新し、更新できた時にはtrueを返す\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// 同様に最小値を更新する\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// 行数と変数名、値をclogに表示するデバッグ用print\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n// 同様の配列向けデバッグ用print\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\n// input用の関数群\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    i64 n, x, y;\n    input(n, x, y);\n    vector<i64> a(n);\n    input(a);\n    list<i64> s;\n    for(const auto& i : Range<>(n))\n        s.push_back(a[i]);\n    i64 ind = 1;\n    i64 sum = 0;\n    // [0, ind) is sorted\n    while(ind != n + 1){\n        auto it = s.begin();\n        for(; *it != ind; ++it);\n        auto it2 = next(it);\n        i64 nex = ind + 1;\n        while(it2 != s.end() && *it2 == nex){\n            ++nex;\n            ++it2;\n        }\n\n        // ここ線形\n        // dist回だけ前に移動する\n        i64 dist = distance(s.begin(), it);\n        // その後、length回だけ回転させる\n        i64 length = distance(it, it2);\n        i64 cost_a = dist * x;\n        i64 cost_b = length * y;\n        sum += min(cost_a, cost_b);\n        for(i64 i = 0; i < length; ++i)\n            it = s.erase(it);\n        ind += length;\n    }\n\n    cout << sum << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n#include <iterator>\n#include <cmath>\n#include <stack>\n#include <random>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  ll n, a, b; cin >> n >> a >> b;\n  vector<int> p(n);\n  rep(i, n) {\n    int pos; cin >> pos;\n    pos--;\n    p[pos] = i;\n  }\n\n  int k = 2*n+1;\n  vector<ll> dp(k);\n\n  rep(i, n) {\n    int now = p[i]*2+1;\n    //debug(i); debugln(now);\n    ll mi = LLONG_MAX;\n    rep(j, k) {\n      chmin(mi, dp[j]);\n      if (now < j) {\n        dp[j] = mi+a;\n      } else if (now > j) {\n        dp[j] = mi+b;\n      } else {\n        dp[j] = mi;\n      }\n      //debug(i); debug(j); debugln(dp[j]);\n    }\n  }\n\n  ll ans = LLONG_MAX;\n  rep(i, k) {\n    chmin(ans, dp[i]);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return a = std::min(a, b), a == b; }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return a = std::max(a, b), a == b; }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===================================================================!//\n//!  .d88888b                    d888888P                             !//\n//!  88.    \"'                      88                                !//\n//!  'Y88888b. .d8888b. .d8888b.    88    88d888b. .d8888b. .d8888b.  !//\n//!        '8b 88ooood8 88'  '88    88    88'  '88 88ooood8 88ooood8  !//\n//!  d8'   .8P 88.  ... 88.  .88    88    88       88.  ... 88.  ...  !//\n//!   Y88888P  '88888P' '8888P88    dP    dP       '88888P' '88888P'  !//\n//!                          .88                                      !//\n//!                      d8888P                                       !//\n//!===================================================================!//\ntemplate <typename ValMonoid>\nclass SegTree\n{\npublic:\n    using T = typename ValMonoid::T;\n    SegTree(const std::size_t N, const T initial = ValMonoid::id()) : size(N), half(ceil2(size)), val(half << 1, ValMonoid::id())\n    {\n        if (initial != ValMonoid::id()) {\n            std::fill(val.begin() + half, val.end(), initial);\n            for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n        }\n    }\n    template <typename InIt>\n    SegTree(const InIt first, const InIt last) : size(std::distance(first, last)), half(ceil2(size)), val(half << 1, ValMonoid::id())\n    {\n        std::copy(first, last, val.begin() + half);\n        for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n    }\n    T get(const std::size_t a) const { return assert(a < size), val[a + half]; }\n    void set(std::size_t a, const T& v)\n    {\n        assert(a < size);\n        val[a += half] = v;\n        while (a >>= 1) { up(a); }\n    }\n    T fold(std::size_t L, std::size_t R) const\n    {\n        assert(L < R), assert(R <= size);\n        T accl = ValMonoid::id(), accr = ValMonoid::id();\n        for (L += half, R += half; L < R; L >>= 1, R >>= 1) {\n            if (L & 1) { accl = acc(accl, val[L++]); }\n            if (R & 1) { accr = acc(val[--R], accr); }\n        }\n        return acc(accl, accr);\n    }\n    friend std::ostream& operator<<(std::ostream& os, const SegTree& seg)\n    {\n        os << \"[\";\n        for (std::size_t i = seg.half; i < seg.half + seg.size; i++) { os << seg.val[i] << (i + 1 == seg.half + seg.size ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    void up(const std::size_t i) { val[i] = acc(val[i << 1], val[i << 1 | 1]); }\n    const std::size_t size, half;\n    std::vector<T> val;\n    const ValMonoid acc{};\n};\n//!==================================!//\n//!  8888ba.88ba                     !//\n//!  88  '8b  '8b                    !//\n//!  88   88   88 .d8888b. dP.  .dP  !//\n//!  88   88   88 88'  '88  '8bd8'   !//\n//!  dP   dP   dP '88888P8 dP'  'dP  !//\n//!==================================!//\ntemplate <typename X>\nstruct Max\n{\n    using T = X;\n    T operator()(const T& a, const T& b) const { return std::max(a, b); }\n    static constexpr T id() { return std::numeric_limits<T>::min(); }\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>();\n    const ll A = read<ll>(), B = read<ll>();\n    std::vector<int> p(N), r(N);\n    std::vector<ll> C(N);\n    ll ans = 0;\n    for (int i = 0; i < N; i++) { std::cin >> p[i], p[i]--, r[p[i]] = i, C[i] = (p[i] > i ? A : p[i] < i ? B : std::max(A, B)), ans += C[i]; }\n    SegTree<Max<ll>> dp(N, 0LL);\n    for (int i = 0; i < N; i++) { dp.set(r[i], dp.fold(0, r[i] + 1) + C[r[i]]); }\n    std::cout << ans - dp.fold(0, N) << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n\nconst int N = 5005, INF = 1e18;\n\n\n\nint n, A, B, a[N], dp[N];\n\nmain(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin >> n >> A >> B;\n    for(int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    int ans = INF;\n    for(int i = 1; i <= n; i++){\n        int cur = 0;\n        dp[i] = INF;\n        for(int j = i - 1; j >= 0; j--){\n            if(a[i] > a[j]){\n                dp[i] = min(dp[i], dp[j] + cur * A + (i - j - 1 - cur) * B);\n            }\n            else{\n                cur += 1;\n            }\n        }\n        ans = min(ans, dp[i] + (n - i) * B);\n    }\n    a[n + 1] = INF;\n    for(int i = n; i >= 1; i--){\n        int cur = 0;\n        dp[i] = INF;\n        for(int j = i + 1; j <= n + 1; j++){\n            if(a[i] < a[j]){\n                dp[i] = min(dp[i], dp[j] + cur * B + (j - i - 1 - cur) * A);\n            }\n            else{\n                cur += 1;\n            }\n        }\n        ans = min(ans, (i - 1) * A + dp[i]);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DEBUG_OUTPUT_ENABLED 1\n\t#define DBG(X) dout << #X << \"=\" << (X) << '\\n';\n\t#define SAY(X) dout << (X) << '\\n';\n#else\n\t#define DEBUG_OUTPUT_ENABLED 0\n\t#define DBG(X) 42;\n\t#define SAY(X) 42;\n#endif\n\n#define dout   __debug::instance\nusing namespace std;\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const set<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const multiset<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\nnamespace __debug {\n\tstruct DebugStream {\n\t\tprivate:\n\t\t\tbool is_first;\n\t\tpublic:\n\t\t\tDebugStream(bool _is_first): is_first(_is_first) {}\n\t\t\ttemplate<typename T> DebugStream operator<<(const T& value) const {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\tcout << value;\n\t\t\t\treturn DebugStream(false);\n\t\t\t};\n\n\t\t\ttemplate<typename T> DebugStream printArray(T* l, T* r) {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\twhile(l != r) {\n\t\t\t\t\tcout << (*l);\n\t\t\t\t\t++l;\n\t\t\t\t\tif(l == r) {\n\t\t\t\t\t\tcout << '\\n';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn DebugStream(false);\n\t\t\t}\n\t};\n\tDebugStream instance(true);\n};\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for(auto& elem: ret) cin >> elem; return ret; }\nconst int MAXN = 5007;\nll MoveLeft, MoveRight, dp[MAXN];\nint a[MAXN], b[MAXN], n;\nint F[MAXN];\ninline void clearFenv() {\n\tmemset(F, 0, sizeof(F));\n}\ninline void add(int pos, int val) {\n\tfor(; pos < MAXN; pos |= pos + 1) F[pos] += val;\n}\ninline int get(int r) {\n\tint rez = 0;\n\tfor(; r >= 0; r = (r & (r + 1)) - 1) rez += F[r];\n\treturn rez;\n}\ninline int get(int l, int r) {\n\tif(l <= r) return get(r) - get(l - 1);\n\telse return 0;\n}\nvoid solve() {\n\tcin >> n >> MoveRight >> MoveLeft;\n\tn += 2;\n\ta[0] = 0;\n\ta[n - 1] = n - 1;\n\tfor(int i = 1; i < n - 1; ++i) a[i] = fetch<int>();\n\tfor(int i = 1; i < n; ++i) {\n\t\tdp[i] = LL_INF;\n\t\tclearFenv();\n\t\tfor(int j = i - 1; j >= 0; --j) {\n\t\t\tif(a[j] < a[i]) {\n\t\t\t\tint ToLeft = get(a[j] - 1);\n\t\t\t\tint ToRight = get(a[i] + 1, MAXN - 1);\n\t\t\t\tll loc = MoveLeft * ToLeft + MoveRight * ToRight + dp[j];\n\t\t\t\tif(ToLeft + ToRight == i - j - 1) { \n\t\t\t\t\t//dout << j << ' ' << i << '\\n';\n\t\t\t\t\tdp[i] = min(dp[i], loc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(a[j], 1);\n\t\t}\n\t}\n\t//for(int i = 0; i < n; ++i) dout << i << \": \" << dp[i] << '\\n';\n\tcout << dp[n - 1] << '\\n';\n}\n\nint main() {\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing ui64 = uint_fast64_t;\nusing db = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 4 - 17;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double gold = 1.618033988;\nconstexpr long double eps = 1e-15;\n\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 5\n#define itr(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritr(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define fro front\n#define bac back\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nstruct setupper {\n    setupper() {\n        ios::sync_with_stdio(false);\n        std::cin.tie(nullptr);\n        std::cout.tie(nullptr);\n        std::cerr.tie(nullptr);\n        std::cout << fixed << setprecision(stdout_precision);\n        std::cerr << fixed << setprecision(stderr_precision);\n#ifdef LOCAL\n        freopen(\"input.txt\",\"rt\",stdin);\n        freopen(\"output.txt\",\"wt\",stdout);\n        // std::cerr << \"\\n---stderr---\\n\";\n        // auto print_atexit = []() {\n        //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n        //     std::cerr << \"------------\\n\";\n        // };\n        // atexit((void(*)())print_atexit);\n#endif\n    }\n} setupper_;\n\nnamespace std {\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i];\n    return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = int> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T, class U> static bool chmax(T &x, const U &y) { return x < y ? x = y,true : false; }\n    template <class T, class U> static bool chmin(T &x, const U &y) { return x > y ? x = y,true : false; }\n};\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> T mixf(const T &x, const T &y) { return max(x,y); }\nbool bit(i64 n, uint8_t e) { return (n >> e) & 1; }\ni64 mask(i64 n, uint8_t e) { return n & ((1 << e) - 1); }\nint ilog(uint64_t x, uint64_t b = 2) { return x ? 1 + ilog(x / b,b) : -1; }\ntemplate <class F> i64 binry(i64 ok, i64 ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        i64 mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class A> void cmprs(A ary[], size_t n) {\n    vector<A> tmp(ary,ary + n);\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(A *i = ary; i != ary + n; ++i) *i = l_bnd(all(tmp),*i) - begin(tmp);\n}\ntemplate <class T> void cmprs(vector<T> &v) {\n    vector<T> tmp = v; sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(auto i = begin(v); i != end(v); ++i) *i = l_bnd(all(tmp),*i) - begin(tmp);\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n/* The main code follows. */\n\nint a,b;\nint p[1<<13];\nint n;\ni64 dp[1<<13];\n\nsigned main() {\n    cin>>n>>a>>b;\n    rep(i,n) {\n        cin>>p[1+i];\n    }\n    p[0]=0;\n    p[n+1]=n+1;\n    init(dp,inf<i64>);\n    dp[0]=0;\n    for(int i=0; i<=n; ++i) {\n        i64 tmp=0;\n        int j=i;\n        int x=n+2;\n        while(++j<=n+1) {\n            if(p[j]>p[i] && p[j]<x) {\n                chmin(dp[j],dp[i]+tmp);\n                x=p[j];\n            }\n            if(p[i]>p[j]) tmp+=b;\n            else tmp+=a;\n        }\n    }\n    esc(dp[n+1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll INF = (ll)1e17;\nconst int N = 5050;\nll dp[N];\nint n;\nint a[N];\nll A, B;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%lld%lld\", &n, &A, &B);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tif (A < B) {\n\t\treverse(a + 1, a + n + 1);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = n + 1 - a[i];\n\t}\n\ta[0] = 0;\n\ta[n + 1] = n + 1;\n\tfor (int i = 0; i <= n + 1; i++)\n\t\tdp[i] = INF;\n\tdp[0] = 0;\n\tfor (int l = 0; l <= n; l++) {\n\t\tll w = 0;\n\t\tfor (int r = l + 1; r <= n + 1; r++) {\n\t\t\tif (a[r] < a[l]) {\n\t\t\t\tw += A;\n\t\t\t} else {\n\t\t\t\tdp[r] = min(dp[r], dp[l] + w);\n\t\t\t\tw += B;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n + 1]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll inf = (ll)2e16;\nconst ll maxn = (ll)5e3 + 10;\n\nll dp[maxn];\nll inv[maxn];\nll p[maxn];\nll n, a, b;\n\n\nvoid solve(){\n    fill(dp, dp + maxn, inf);\n    cin >> n >> a >> b;\n    for(ll i = 0; i < n; ++i){\n        cin >> p[i];\n        p[i]--;\n    }\n    p[n] = n;\n    for(ll i = 0; i <= n; ++i){\n        inv[p[i]] = i;\n    }\n    for(ll i = 0; i <= n; ++i){\n        ll adda = 0, addb = 0;\n        for(ll j = p[i] - 1; j >= -1; --j){\n            if(j == -1){\n                dp[i] = min(dp[i], adda * a + addb * b);\n                continue;\n            }\n            dp[i] = min(dp[i], dp[inv[j]] + adda * a + addb * b);\n            if(j != p[i]){\n                if(inv[j] < i){\n                    adda++;\n                } else if(inv[j] > i) {\n                    addb++;\n                }\n            }\n        }\n    }\n    cout << dp[n] << \"\\n\";\n}\n\nsigned main(){\n    srand(time(0));\n    ll t = 1;\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    #ifdef DEBUG\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    #else\n\n    #endif// DEBUG\n    while(t--){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nconst ll INF = 1LL << 60;\nint main() {\n\tint n;\n\tll a, b;\n\tscanf(\"%d%lld%lld\", &n, &a, &b);\n\tvector<int> p(n);\n\tvector<ll> dp(n + 1, INF), ndp(n + 1, INF);\n\tdp[0] = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &p[i]);\n\t\tfill(ndp.begin(), ndp.end(), INF);\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tll cost;\n\t\t\tif (p[i] > j) cost = a;\n\t\t\telse cost = b;\n\t\t\tndp[j] = min(ndp[j], dp[j] + cost);\n\t\t\tif (j < p[i]) ndp[p[i]] = min(ndp[p[i]], dp[j]);\n\t\t}\n\t\tswap(ndp, dp);\n\t}\n\tll ans = *min_element(dp.begin() + 1, dp.end());\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long dp[5001][5001] = {};\nint main() {\n\tlong long n, aa, bb;\n\tcin >> n >> aa >> bb;\n\tREP(i, 5001) {\n\t\tREP(q, 5001) {\n\t\t\tdp[i][q] = LONG_INF;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tfor (int q = 0; q <= n; ++q) {\n\t\t\tif (q <= a) {\n\t\t\t\tdp[i + 1][q] = min(dp[i + 1][q], dp[i][q] + aa);\n\t\t\t\tdp[i + 1][a] = min(dp[i + 1][a], dp[i][q]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][q] = min(dp[i + 1][q], dp[i][q] + bb);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = LONG_INF;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tans = min(ans, dp[n][i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(void){\n  cout<<\"おい！それってYO!!のびハザのネタじゃんか!!!ｱｯｱｯｱｯｱｯ\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (unsigned long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (unsigned long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n\n    ll n, a, b;\n    cin >> n >> a >> b;\n\n    // p_i および番兵0, N+1\n    vector<ll> p(n+2);\n    p.front() = 0;\n    RANGE(i, 1, n) cin >> p[i];\n    p.back() = ++n;\n    \n    // 遷移 O(N^2)\n    vector<ll> dp(n+1, LINF / 2); // dp[i] := {p_k|k<=i}が(狭義)単調増加（含番兵0）\n    dp[0] = 0; // 初期状態：何もしなくても番兵は{0}で単調増加\n    RANGE(i, 1, n) {\n        ll term = 0;\n        for (int j = i; j--; ) {\n            if (p[j] < p[i]) {\n                chmin(dp[i], dp[j] + term);\n                term += b;\n            } else {\n                term += a;\n            }\n        }\n    }\n\n    cout << dp[n] << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    lint n, a, b;\n    cin >> n >> a >> b;\n    vector<lint> p(n);\n    vector<pair<lint, lint>> pi;\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        pi.emplace_back(p[i], i);\n    }\n    sort(pi.begin(), pi.end());\n    vector<lint> dp(2 * n + 2);\n    vector<lint> dpn(2 * n + 2);\n    for (int i = 0; i < 2 * n + 2; ++i) {\n        int orig = pi[0].second * 2 + 1;\n        if (i < orig)\n            dp[i] = b;\n        else if (i > orig)\n            dp[i] = a;\n        else\n            dp[i] = 0;\n    }\n\n    for (int i = 1; i < n; ++i) {\n        int orig  = pi[i].second * 2 + 1;\n        lint mini = inf;\n        for (int j = 0; j < 2 * n + 2; ++j) {\n            mini = min(mini, dp[j]);\n            if (j < orig)\n                dpn[j] = mini + b;\n            else if (j > orig)\n                dpn[j] = mini + a;\n            else\n                dpn[j] = mini;\n        }\n        swap(dp, dpn);\n    }\n    cout << *min_element(dp.begin(), dp.end()) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : D2.cpp\n * Author  : Kazune Takahashi\n * Created : 2019-5-28 18:47:58\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n/*\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\n\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n*/\n\n/*\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n*/\n\nconst ll infty = 100000000000007;\nint N;\nll A, B;\nint p[5010];\nll DP[5010][5010];\n\nint main()\n{\n  cin >> N >> A >> B;\n  for (auto i = 1; i <= N; i++)\n  {\n    cin >> p[i];\n  }\n  fill(&DP[0][0], &DP[0][0] + 5010 * 5010, infty);\n  DP[0][0] = 0;\n  for (auto i = 0; i <= N; i++)\n  {\n    for (auto j = 0; j <= N; j++)\n    {\n      if (j < N)\n      {\n        DP[i][j + 1] = min(DP[i][j + 1], DP[i][j]);\n      }\n      if (i < N)\n      {\n        if (p[i + 1] <= j)\n        {\n          DP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + B);\n        }\n        else\n        {\n          DP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + A);\n        }\n      }\n      if (i < N && j < N && p[i + 1] == j + 1)\n      {\n        DP[i + 1][j + 1] = min(DP[i + 1][j + 1], DP[i][j]);\n      }\n    }\n  }\n  cout << DP[N][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 998244353LL;// (ll)(1e9 + 7);\n\n\nvoid solve()\n{\n\tll N, A, B;\n\tcin >> N >> A >> B;\n\tauto p = cinv(N);\n\n\tif (A > B){\n\t\tstd::swap(A, B);\n\t\tstd::reverse(p.begin(), p.end());\n\t\tEACH(e, p) e = N-e+1;\n\t}\n\n\tmap<ll, ll> dp;\n\tdp[0] = A;\n\tdp[p[0]] = 0;\n\n\tREP(i, N-1){\n\t\tll k = p[i+1];\n\n\t\tll x;\n\t\tfor (auto it = dp.begin(); it != dp.end(); ){\n\t\t\tll j = it->first;\n\t\t\tif (j < k){\n\t\t\t\tx = it->second;\n\t\t\t\tit->second += A;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tit->second += B;\n\t\t\t\tif (it->second >= x) it = dp.erase(it);\n\t\t\t\telse                 it++;\n\t\t\t}\n\t\t}\n\t\tdp[k] = x;\n\t}\n\tcout << ((--dp.end())->second) << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=5005;\nint n,A,B,a[N],q[N];\nll f[N],v1[N],v2[N];\nll mn[N*4],tg[N*4];\nstruct TR1{\n\tint t[N];\n\tvoid change(int x){\n\t\tfor (;x<n;x+=x&(-x)) t[x]++;\n\t}\n\tint ask(int x){\n\t\tint ans=0;\n\t\tfor (;x;x-=x&(-x)) ans+=t[x];\n\t\treturn ans;\n\t}\n}T1;\nvoid build(int k,int l,int r){\n\tmn[k]=1ll<<60; tg[k]=0;\n\tif (l==r) return;\n\tint mid=(l+r)/2;\n\tbuild(k*2,l,mid);\n\tbuild(k*2+1,mid+1,r);\n}\nvoid pushdown(int k){\n\tif (!tg[k]) return;\n\ttg[k*2]+=tg[k]; tg[k*2+1]+=tg[k];\n\tmn[k*2]+=tg[k]; mn[k*2+1]+=tg[k];\n\ttg[k]=0;\n}\nvoid change(int k,int l,int r,int x,int y,ll v){\n\tif (l==x&&r==y){\n\t\ttg[k]+=v;\n\t\tmn[k]+=v;\n\t\treturn;\n\t}\n\tpushdown(k);\n\tint mid=(l+r)/2;\n\tif (y<=mid) change(k*2,l,mid,x,y,v);\n\telse if (x>mid) change(k*2+1,mid+1,r,x,y,v);\n\telse{\n\t\tchange(k*2,l,mid,x,mid,v);\n\t\tchange(k*2+1,mid+1,r,mid+1,y,v);\n\t}\n\tmn[k]=min(mn[k*2],mn[k*2+1]);\n}\nvoid change(int k,int l,int r,int x,ll v){\n\tif (l==r){\t\n\t\tmn[k]=v;\n\t\treturn;\n\t}\n\tpushdown(k);\n\tint mid=(l+r)/2;\n\tif (x<=mid) change(k*2,l,mid,x,v);\n\telse change(k*2+1,mid+1,r,x,v);\n\tmn[k]=min(mn[k*2],mn[k*2+1]);\n}\nll ask(int k,int l,int r,int x,int y){\n\tif (l==x&&r==y) return mn[k];\n\tpushdown(k);\n\tint mid=(l+r)/2;\n\tif (y<=mid) return ask(k*2,l,mid,x,y);\n\tif (x>mid) return ask(k*2+1,mid+1,r,x,y);\n\treturn min(ask(k*2,l,mid,x,mid),ask(k*2+1,mid+1,r,mid+1,y));\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n){\n\t\tv1[i]=1ll*A*(i-1)+1ll*T1.ask(a[i])*(B-A);\n\t\tv2[i]=1ll*A*(n-a[i])+1ll*B*(a[i]-1)-v1[i];\n\t\tT1.change(a[i]);\n\t}\n\tll ans=1ll<<60;\n\tbuild(1,1,n);\n\tFor(i,1,n) f[i]=v1[i];\n\tFor(i,1,n){\n\t\tf[i]=min(f[i],ask(1,1,n,1,a[i])+1ll*(i-1)*A);\n\t\tchange(1,1,n,a[i],n,B-A);\n\t\tchange(1,1,n,a[i],f[i]-1ll*i*A);\n\t\t//printf(\"%lld %lld %lld\\n\",f[i],v1[i],v2[i]);\n\t}\n\tFor(i,1,n)\n\t\tans=min(ans,f[i]+v2[i]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)1000000007\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique priority_queue\nusing namespace std;\nint gcd(int a, int b) {\n\tif (!b)return a;\n\treturn gcd(b, a % b);\n}\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b % 2)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b / 2);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b % 2)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b / 2, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value += T(modulo) * max((int)1, -value / modulo + 1);\n\t\tthis->value %= T(modulo);\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % mod;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tstatic modInt pow(modInt x, int y) {\n\t\tif (!y)return 1;\n\t\tif (y & 1)return pow(x, y - 1) * x;\n\t\tmodInt memo = pow(x, y / 2);\n\t\treturn memo * memo;\n\t}\n\tinline modInt inv() {\n\t\treturn pow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nclass UnionFind {\nprotected:\n\tint* par, * rank, * size;\npublic:\n\tUnionFind(unsigned int size) {\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tthis->size = new int[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tthis->size[i] = 1;\n\t\t}\n\t}\n\tint find(int n) {\n\t\tif (par[n] == n)return n;\n\t\treturn par[n] = find(par[n]);\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m)return;\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t}\n\tbool same(int n, int m) {\n\t\treturn find(n) == find(m);\n\t}\n\tint getsize(int n) {\n\t\treturn size[find(n)];\n\t}\n};\nclass PerpetualUnionFind :UnionFind {\n\tP* notparent;\n\tvector<P>* sizevec;\n\tint opcount = 0;\npublic:\n\tPerpetualUnionFind(unsigned int size) :UnionFind(size) {\n\t\tthis->sizevec = new vector<P>[size];\n\t\tnotparent = new P[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsizevec[i].push_back(make_pair(-1, 1));\n\t\t\tnotparent[i] = make_pair(INF, i);\n\t\t}\n\t}\n\tint find(int n, int t = INF) {\n\t\tif (opcount <= t) {\n\t\t\tif (par[n] == n)return n;\n\t\t\treturn par[n] = find(par[n]);\n\t\t}\n\t\tif (notparent[n].first <= t)return find(notparent[n].second, t);\n\t\treturn n;\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m) {\n\t\t\topcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tnotparent[n] = make_pair(opcount, m);\n\t\t\tsizevec[m].push_back(make_pair(opcount, sizevec[m].back().second + sizevec[n].back().second));\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tnotparent[m] = make_pair(opcount, n);\n\t\t\tsizevec[n].push_back(make_pair(opcount, sizevec[n].back().second + sizevec[m].back().second));\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t\topcount++;\n\t}\n\tbool same(int n, int m, int t = INF) {\n\t\treturn find(n, t) == find(m, t);\n\t}\n\tint getsize(int n, int t = INF) {\n\t\tn = find(n, t);\n\t\tauto ite = lower_bound(sizevec[n].begin(), sizevec[n].end(), make_pair(t, (int)0));\n\t\tif (ite == sizevec[n].end())ite--;\n\t\tif (t < (*ite).first)ite--;\n\t\treturn (*ite).second;\n\t}\n};\nclass RollingHash {\n\tstring s;\n\tint n, m, base;\n\tdeque<int> has;\npublic:\n\tRollingHash(string s, int m, int b) : n(s.size()), m(m), base(b) { init(s, m, b); }\n\tvoid init(string s, int m, int b) {\n\t\tn = s.size();\n\t\thas.resize(n);\n\t\tbase = b;\n\t\tthis->s = s;\n\t\tthis->m = m;\n\t\trep(i, n) {\n\t\t\thas[i] = (int)s[i];\n\t\t\tif (i)has[i] += base * has[i - 1] % m;\n\t\t\thas[i] %= m;\n\t\t}\n\t}\n\toperator int() const {\n\t\treturn has.back();\n\t}\n\tvoid cut(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\trep(i, a)has.pop_front();\n\t\trep(i, n - b)has.pop_back();\n\t\ts = s.substr(a, b);\n\t\tint memo = modpow(modpow(base, n - b, m), m - 2, m);\n\t\trep(i, b - a) {\n\t\t\thas[i] *= memo;\n\t\t\thas[i] %= mod;\n\t\t}\n\t\tn = b - a;\n\t}\n\tint query(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\treturn (has[b - 1] - modpow(base, b - a, m) * (!a ? 0 : has[a - 1]) % m + m) % m;\n\t}\n\tint operator+(RollingHash t) {\n\t\tassert(m == t.m && base == t.base);\n\t\treturn (has[n - 1] * modpow(base, t.n, m) % m + t.has[t.n - 1]) % m;\n\t}\n\tRollingHash& operator+=(string t) {\n\t\ts += t;\n\t\thas.resize(n + t.size());\n\t\tfor (int i = n; i < n + t.size(); i++) {\n\t\t\thas[i] = (int)t[i] * base % m;\n\t\t\thas[i] += base * has[i - 1] % m;\n\t\t\thas[i] %= m;\n\t\t}\n\t\tn += t.size();\n\t\treturn *this;\n\t}\n};\ntemplate<typename T, typename U>\nclass SegTree {\n\tint n = 1;\n\tT* node = NULL;\n\tU* lazy = NULL;\n\tbool* lazyflag = NULL;\n\tT nodee;\n\tfunction<T(T, T)> nodef;\n\tfunction<U(U, U)> lazyf;\n\tfunction<T(int, T, U)> updf;\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazyflag[k]) {\n\t\t\tnode[k] = updf(r - l, node[k], lazy[k]);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazyflag[2 * k + 1] = lazyflag[2 * k + 2] = true;\n\t\t\t\tlazy[2 * k + 1] = lazyf(lazy[2 * k + 1], lazy[k]);\n\t\t\t\tlazy[2 * k + 2] = lazyf(lazy[2 * k + 2], lazy[k]);\n\t\t\t}\n\t\t\tlazyflag[k] = false;\n\t\t}\n\t}\npublic:\n\tSegTree(int m, int init, T nodee, function<T(T, T)> nodef, function<U(U, U)> lazyf, function<T(int, T, U)> updf) :nodee(nodee), nodef(nodef), lazyf(lazyf), updf(updf) {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t\twhile (n < m)n *= 2;\n\t\tnode = new T[2 * n], lazy = new U[2 * n], lazyflag = new bool[2 * n];\n\t\trep(i, 2 * n) {\n\t\t\tnode[i] = init;\n\t\t\tlazyflag[i] = false;\n\t\t}\n\t}\n\t~SegTree() {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t}\n\tvoid update(int a, int b, U x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazyflag[k] = true;\n\t\t\tlazy[k] = x;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = nodef(node[2 * k + 1], node[2 * k + 2]);\n\t\t}\n\t}\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return nodee;\n\t\tif (a <= l && r <= b)return node[k];\n\t\tT vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn nodef(vl, vr);\n\t}\n};\ntemplate<typename T>\nclass Matrix {\n\tint n;\n\tT zero, e;\n\tvector<vector<T>> vec;\n\tvoid letmeasure() {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i != j)vec[i][j] = zero;\n\t\t\t\telse vec[i][j] = e;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tMatrix(int n, T zero, T e) :n(n), zero(zero), e(e) {\n\t\tvec.resize(n, vector<T>(n));\n\t}\n\tMatrix(int n, T zero, T e, vector<int> vec) :n(n), zero(zero), e(e) {\n\t\tif (vec.size() != n * n) {\n\t\t\tcerr << \"Invalid construct of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tthis->vec.resize(n, vector<T>(n));\n\t\trep(i, n) {\n\t\t\trep(j, n)this->vec[i][j] = vec[i * n + j];\n\t\t}\n\t}\n\tT& operator[](int a) {\n\t\treturn vec[a / n][a % n];\n\t}\n\tunsigned int size() { return n; }\n\tMatrix operator*(const Matrix a) {\n\t\tif (this->n != a.n) {\n\t\t\tcerr << \"Invalid multiply of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tvector<T> memo(n);\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tmemo[j] += vec[i][k] * a.vec[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec[i] = memo;\n\t\t\tmemo.clear();\n\t\t\tmemo.resize(n);\n\t\t}\n\t\treturn *this;\n\t}\n\tstatic Matrix<T> measure(int n, T zero, T e) {\n\t\tMatrix<T> res(n, zero, e);\n\t\tres.letmeasure();\n\t\treturn res;\n\t}\n\tstatic Matrix pow(Matrix a, int b) {\n\t\tif (!b)return Matrix::measure(a.size(), a.zero, a.e);\n\t\tif (b % 2)return pow(a, b - 1) * a;\n\t\tMatrix memo = pow(a, b / 2);\n\t\treturn (memo * memo);\n\t}\n};\nclass mycomplex {\n\tdouble realvalue, imagvalue;\npublic:\n\tmycomplex() :realvalue(0), imagvalue(0) {}\n\tmycomplex(double realvalue, double imagvalue) : realvalue(realvalue), imagvalue(imagvalue) {}\n\tmycomplex(double realvalue) : realvalue(realvalue), imagvalue(0) {}\n\tmycomplex(complex<double> c) :realvalue(c.real()), imagvalue(c.imag()) {}\n\tmycomplex(const mycomplex& rhs) :realvalue(rhs.realvalue), imagvalue(rhs.imagvalue) {}\n\tdouble real()const { return this->realvalue; }\n\tdouble imag()const { return this->imagvalue; }\n\tdouble abs() { return hypot(realvalue, imagvalue); }\n\tmycomplex& operator=(const mycomplex& obj) {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = obj.realvalue;\n\t\t\tthis->imagvalue = obj.imagvalue;\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator=(mycomplex&& obj)noexcept {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = exchange(obj.realvalue, 0);\n\t\t\tthis->imagvalue = exchange(obj.imagvalue, 0);\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator+=(const mycomplex& rhs) {\n\t\tthis->realvalue += rhs.realvalue;\n\t\tthis->imagvalue += rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator+(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs += rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator-=(const mycomplex& rhs) {\n\t\tthis->realvalue -= rhs.realvalue;\n\t\tthis->imagvalue -= rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tmycomplex& operator-=(const double& rhs) {\n\t\tthis->realvalue -= rhs;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator-(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs -= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator*=(const mycomplex& rhs) {\n\t\tdouble pastreal = this->realvalue;\n\t\tthis->realvalue = this->realvalue * rhs.realvalue - this->imagvalue * rhs.imagvalue;\n\t\tthis->imagvalue = pastreal * rhs.imagvalue + rhs.realvalue * this->imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator*(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs *= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator/=(const mycomplex& rhs) {\n\t\t*this *= mycomplex(rhs.real(), -rhs.imag());\n\t\tdouble dnm = rhs.real() * rhs.real() - rhs.imag() * rhs.imag();\n\t\tthis->realvalue /= dnm;\n\t\tthis->imagvalue /= dnm;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator/(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs /= rhs;\n\t\treturn lhs;\n\t}\n};\nclass FastFourierTransform {\nprivate:\n\tstatic void dft(vector<mycomplex>& func, int inverse) {\n\t\tint sz = func.size();\n\t\tif (sz == 1)return;\n\t\tvector<mycomplex> veca, vecb;\n\t\trep(i, sz / 2) {\n\t\t\tveca.push_back(func[2 * i]);\n\t\t\tvecb.push_back(func[2 * i + 1]);\n\t\t}\n\t\tdft(veca, inverse); dft(vecb, inverse);\n\t\tmycomplex now = 1, zeta = polar(1.0, inverse * 2.0 * acos(-1) / sz);\n\t\trep(i, sz) {\n\t\t\tfunc[i] = veca[i % (sz / 2)] + now * vecb[i % (sz / 2)];\n\t\t\tnow *= zeta;\n\t\t}\n\t}\npublic:\n\ttemplate<typename T>\n\tstatic vector<double> multiply(vector<T> f, vector<T> g) {\n\t\tvector<mycomplex> nf, ng;\n\t\tint sz = 1;\n\t\twhile (sz < f.size() + g.size())sz *= 2;\n\t\tnf.resize(sz); ng.resize(sz);\n\t\trep(i, f.size()) {\n\t\t\tnf[i] = f[i];\n\t\t\tng[i] = g[i];\n\t\t}\n\t\tdft(nf, 1);\n\t\tdft(ng, 1);\n\t\trep(i, sz)nf[i] *= ng[i];\n\t\tdft(nf, -1);\n\t\tvector<double> res;\n\t\trep(i, sz)res.push_back(nf[i].real() / sz);\n\t\treturn res;\n\t}\n};\nint n, a, b, p[5010];\nvector<P> vec;\nsigned main() {\n\tcin >> n >> a >> b;\n\trep(i, n)cin >> p[i];\n\tint cnt = 1;\n\tREP(i, n - 1) {\n\t\tif (p[i - 1] + 1 == p[i])cnt++;\n\t\telse {\n\t\t\tvec.emplace_back(p[i - 1] - cnt + 1, cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tvec.emplace_back(p[n - 1] - cnt + 1, cnt);\n\trep(i, vec.size() - 1)vec[i + 1].second += vec[i].second;\n\tint ans = 0;\n\trep(i, vec.size()) {\n\t\tint t = -1;\n\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\tif (vec[j] > vec[i])t = j;\n\t\t}\n\t\tif (t != -1) {\n\t\t\tif (t == 0)ans += min(a * vec[i - 1].second, b * (vec[i].second - vec[i - 1].second));\n\t\t\telse ans += min(a * (vec[i - 1].second - vec[t - 1].second), b * (vec[i].second - vec[i - 1].second));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1, typename T2>\ninline bool cmn (T1& a, T2 b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n\tcin.tie(0); cin.sync_with_stdio(false);\n\tconstexpr long long inf = 1LL << 60;\n\tint n, A, B;\n\tcin >> n >> A >> B;\n\tvector<long long> p(n + 2);\n\tfor (int i = 1; i <= n; i++) cin >> p[i];\n\tp[0] = 0; p[n + 1] = n + 1;\n\tvector<long long> dp(n + 2, inf);\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tlong long tmp = 0;\n\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\tif (p[j] < p[i]) {\n\t\t\t\tcmn(dp[i], dp[j] + tmp);\n\t\t\t\ttmp += B;\n\t\t\t} else {\n\t\t\t\ttmp += A;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n + 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint main() {\n    int n, a, b; cin >> n >> a >> b;\n    int P[n]; for (int i = 0; i < n; i++) cin >> P[i];\n\n    int lis[n] = {};\n    fill(lis, lis+n, 1<<30);\n    for (int i = 0; i < n; i++)\n        *lower_bound(lis, lis+n, P[i]) = P[i];\n    vector<int> s;\n    int m = lower_bound(lis, lis+n, 1<<30) - lis - 1;\n    // for (int i = 0; i <= m; i++) cerr << lis[i] << ' '; cerr << endl;\n    int prevv = 1<<30;\n    for (int i = n-1; i >= 0; i--) {\n        if (lis[m] <= P[i] && P[i] < prevv) {\n            s.push_back(i);\n            prevv = P[i];\n            m--;\n        }\n    }\n    // for (int x : s) cerr << x << ' '; cerr << endl;\n    reverse(s.begin(), s.end());\n    bool in_lis[n] = {};\n    for (int i : s) in_lis[i] = true;\n    int acc_min[n], acc_max[n];\n    int temp = 1<<30;\n    for (int i = n-1; i >= 0; i--) {\n        if (in_lis[i]) temp = min(temp, P[i]);\n        acc_min[i] = temp;\n    }\n    temp = 0;\n    for (int i = 0; i < n; i++) {\n        if (in_lis[i]) temp = max(temp, P[i]);\n        acc_max[i] = temp;\n    }\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (in_lis[i]) continue;\n        auto it = lower_bound(s.begin(), s.end(), i);\n        if (it != s.end() && P[i] > P[*it]) ans += a;\n        else if (it != s.begin() && P[i] < P[*prev(it)]) ans += b;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 1000000000000000000;\n\tvector<long long> P, DP;\n\tcin >> N >> A >> B;\n\tP.resize(N);\n\tDP.assign(N + 1, INF);\n\tDP[0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (DP[j] >= INF) continue;\n\t\t\tif (j < P[i]) {\n\t\t\t\tDP[P[i]] = min(DP[P[i]], DP[j]);\n\t\t\t\tDP[j] += A;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDP[j] += B;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int N=5002;\nLL dp[N][N];\nint n,a,b,x[N],pos[N];\nint mn[N][N],mx[N][N];\n\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]), pos[x[i]]=i;\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)dp[i][j]=1e18;\n    dp[0][n+1]=0;\n    for(int i=1;i<=n;i++){\n        mx[i][i]=mn[i][i]=pos[i];\n        for(int j=i+1;j<=n;j++){\n            mx[i][j]=max(mx[i][j-1],pos[j]);\n            mn[i][j]=min(mn[i][j-1],pos[j]);\n        }\n    }\n    for(int len=0;len<n;len++)\n    for(int i=0;i<=len;i++){\n        int lef=i,rig=n+1-(len-i);\n        // [1,lef], [rig,n]\n        if(lef+1<rig && rig<=n+1){\n            //printf(\"len=%d,lef=%d,rig=%d %lld\\n\", len,lef,rig,dp[lef][rig]);\n            dp[lef+1][rig]=min(dp[lef+1][rig], dp[lef][rig]+(LL)(pos[lef+1]==mn[lef+1][rig-1]?0:b));\n            dp[lef][rig-1]=min(dp[lef][rig-1], dp[lef][rig]+(LL)(pos[rig-1]==mx[lef+1][rig-1]?0:a));\n        }\n    }\n    LL ans=1e18;\n    for(int i=0;i<=n;i++)ans=min(ans,dp[i][i+1]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5000 + 7;\nconst long long INF = 1e15;\nint n, a[maxn], b[maxn], L[maxn][maxn], R[maxn][maxn];\nlong long A, B, dp[maxn][maxn], ans = INF;\n\nint main() {\n\tscanf(\"%d%lld%lld\", &n, &A, &B);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[a[i]] = i;\n\t\tL[i][i] = R[i][i] = i;\n\t}\n\tfor (int i = 1; i < n; ++i) \n\t\tfor (int j = 1; j <= n - i; ++j) {\n\t\t\tL[j][j + i] = L[j + 1][j + i];\n\t\t\tR[j][j + i] = R[j + 1][j + i];\n\t\t\tif(b[j] < b[L[j][j + i]]) L[j][j + i] = j;\n\t\t\tif(b[j] > b[R[j][j + i]]) R[j][j + i] = j;\n\t\t}\n\t/*\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i; j <= n; ++j) printf(\"(%d, %d) \", L[i][j], R[i][j]);\n\t\tprintf(\"\\n\");\n\t} \n\t*/\n\tfor (int i = 0; i <= n + 1; ++i) for(int j = 0; j <= n + 1; ++j) dp[i][j] = INF;\n\tdp[0][n + 1] = 0;\n\tfor (int i = n + 1; i > 1; --i) {\n\t\tfor (int j = 0; j <= n + 1 - i; ++j) {\n\t\t\tint l = j, r = j + i;\n\t\t\tdp[l + 1][r] = min(dp[l + 1][r], dp[l][r] + B);\n\t\t\tif(L[l + 1][r - 1] == l + 1) dp[l + 1][r] = min(dp[l + 1][r], dp[l][r]);\n\t\t\tdp[l][r - 1] = min(dp[l][r - 1], dp[l][r] + A);\n\t\t\tif(R[l + 1][r - 1] == r - 1) dp[l][r - 1] = min(dp[l][r - 1], dp[l][r]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; ++i) ans = min(ans, dp[i][i + 1]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N = 5e3 + 5;\nint n,p[N],not_inv[N];\nLL A,B,f[N][N];\n//#define R\nint main()\n{\n\tcin>>n>>A>>B;\n\tfor (int i = 1;i <= n; ++i)\n\t\tcin>>p[i]; \n\tfor (int i = 1;i <= n; ++i)\n\t{\n\t\tnot_inv[i] = 0;\n\t\tfor (int j = 1;j < i; ++j)\n\t\t\tif (p[j] < p[i])\n\t\t\t\tnot_inv[i]++;\n\t}\n\tfor (int i = 1;i <= n; ++i)\n\t\tfor (int j = 1;j <= i; ++j)\n\t\t\tif (not_inv[i] + 1 > j)\n\t\t\t\tf[i][j] = f[i - 1][j];\n\t\t\telse\n\t\t\t\tf[i][j] = min(f[i - 1][j - 1] + B,f[i - 1][not_inv[i]] + A * ((LL)j - 1 - not_inv[i])); \n\t\t\t\t//f[i - 1][not_inv[i]] + min(A,B * ((LL)j - 1 - not_inv[i]));\n\t#ifdef R\n\tfor (int i = 1;i <= n; ++i)\n\t{\n\t\tfor (int j = 1;j <= n; ++j)\n\t\t\tcout<<f[i][j]<<\" \";\n\t\tputs(\"\");\n\t}\n\t#endif\n\tcout<<f[n][n];\n } "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n, a, b, num[5007], dp[5007][5007], res = 1e18;\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nsigned main()\n{\n\tn = read();\n\ta = read();\n\tb = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tnum[i] = read();\n\tmemset(dp, 0x3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tif (num[i] > j)\n\t\t\t{\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + a);\n\t\t\t\tdp[i][num[i]] = min(dp[i][num[i]], dp[i - 1][j]);\n\t\t\t}\n\t\t\telse dp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n\tfor (int i = 0; i <= n; i++)\n\t\tres = min(res, dp[n][i]);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\nconstexpr int kN = int(5E3 + 10);\nconstexpr ll kInf = ll(1E16 + 10);\nll dp[kN][kN];\nint p[kN], low[kN][kN], top[kN][kN];\nint main() {\n\tint n, a, b;\n\tll lcost, rcost;\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &p[i]);\n\tfor (int i = 1; i <= n; i++) dp[i][i] = 0;\n\tfor (int i = 1; i <= n; i++) low[i][i] = top[i][i] = p[i];\n\tfor (int i = 2; i <= n; i++) for (int j = 1; j + i - 1 <= n; j++) {\n\t\tlow[j][j + i - 1] = min(low[j][j + i - 2], p[j + i - 1]);\n\t\ttop[j][j + i - 1] = max(top[j][j + i - 2], p[j + i - 1]);\n\t\tlcost = low[j][j + i - 1] == p[j] ? 0 : a;\n\t\trcost = top[j][j + i - 1] == p[j + i - 1] ? 0 : b;\n\t\tdp[j][j + i - 1] = min(lcost + dp[j + 1][j + i - 1], rcost + dp[j][j + i - 2]);\n\t\tfor (int x = j + 1; x <= j + i - 3; x++) if (top[j][x] < low[x + 1][j + i - 1]) dp[j][j + i - 1] = min(dp[j][j + i - 1], dp[j][x] + dp[x + 1][j + i - 1]);\n\t}\n\tprintf(\"%lld\\n\", dp[1][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <deque>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\ntemplate<class T> inline bool chmax(T& a, T b) {if (a<b) {a=b; return true;} return false;}\ntemplate<class T> inline bool chmin(T& a, T b) {if (a>b) {a=b; return true;} return false;}\n\nconst ll MOD = 1000000007;\nconst ll HIGHINF = (ll)1e18;\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b;\n  vll p(n); REP(i, n) cin >> p[i];\n\n  vvll dp(n+1, vll(n+1, HIGHINF));\n  dp[0][0] = 0;\n  REP(i, n) {\n    REP(j, n+1) {\n      if (dp[i][j] >= HIGHINF) continue;\n      if (p[i] > j) {\n        // p[i]を右にずらさない\n        chmin(dp[i+1][p[i]], dp[i][j]);\n        // p[i]を右にずらす\n        chmin(dp[i+1][j], dp[i][j] + a);\n      } else {\n        // p[i]を左にずらさないといけない\n        chmin(dp[i+1][j], dp[i][j] + b);\n      }\n    }\n  }\n\n  ll ans = HIGHINF;\n  REP(i, n+1) chmin(ans, dp[n][i]);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 200000;\nint a[N], A, B, p[N];\nint used[5002][5002];\nlong long dp[5002][5002];\nint f[5002][5002];\nlong long solve(int l, int r) {\n    if (used[l][r]) {\n        return dp[l][r];\n    }\n    if (l == r) {\n        return 0;\n    }\n    used[l][r] = 1;\n    dp[l][r] = 1e18;\n    int i = p[l];\n    int cnt = f[i][r] - f[i][l - 1];\n    assert(cnt >= 1);\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r));\n    } else {\n        if (cnt == 2) {\n            dp[l][r] = min(dp[l][r], solve(l + 1, r) + A);\n        }\n        dp[l][r] = min(dp[l][r], solve(l + 1, r) + B);\n    }\n    i = p[r];\n    cnt = f[n][r] - f[n][l - 1] - (f[i - 1][r] - f[i - 1][l - 1]);\n    assert(cnt >= 1);\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1));\n    } else {\n        if (cnt == 2) {\n            dp[l][r] = min(dp[l][r], solve(l + 1, r) + B);\n        }\n        dp[l][r] = min(dp[l][r], solve(l, r - 1) + A);\n    }\n    return dp[l][r];\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        p[a[i]] = i;\n    }\n    for (int j = 1; j <= n; j++) {\n        for (int i = 1; i <= n; i++) {\n            f[i][j] = f[i - 1][j];\n            if (a[i] <= j) {\n                f[i][j]++;\n            }\n        }\n    }\n    cout << solve(1, n) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nshiftÊµÖÊÉÏÊÇ°ÑÒ»¸öÔªËØÍùÇ°ÒÆ»òÕßÍùºóÒÆ\n¿¼ÂÇÈç¹ûÈ·¶¨Ò»Ð©ÔªËØ²»¶¯µÄ»°£¨ÏÔÈ»ËüÃÇµÄÏÂ±êºÍÖµ¶¼µ¥Ôö£©£¬ÄÇÃ´¶ÔÓÚÏàÁÚÁ½¸öÈ·¶¨²»¶¯µÄÔªËØaºÍbÖ®¼äµÄÔªËØx£¬»áÓÐÈçÏÂÊÂ£º\n(1)P[x] < P[a]£¬ÄÇÃ´ÐèÒª°ÑP[x]ÍùÇ°ÒÆ\n(2)P[b] < P[x]£¬ÄÇÃ´ÐèÒª°ÑP[x]ÍùºóÒÆ\n(3)Ê£ÏÂµÄËùÓÐP[a] < P[x] < P[b]µÄÔªËØ£¬¿ÉÒÔÈ«ÓÃmin(A, B)µÄ´ú¼ÛÅÅºÃÐò\nÖ±½Ódp¼´¿É \n*/\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_N(5050);\ntypedef long long int LL;\n\nint N, P[Max_N], Pre[Max_N][Max_N], Suf[Max_N][Max_N];\nLL F[Max_N][Max_N], A, B;\n\ninline void upd(LL &a, LL b)\n{\n\ta = min(a, b);\n}\n\nint main()\n{\n\tscanf(\"%d%lld%lld\", &N, &A, &B);\n\tfor (int i = 1;i <= N;++i)\n\t\tscanf(\"%d\", P + i), Pre[i][P[i]] = Suf[i][P[i]] = 1;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tfor (int j = 1;j <= N + 1;++j)\n\t\t\tPre[i][j] += Pre[i][j - 1];\n\t\tfor (int j = N;j >= 0;--j)\n\t\t\tSuf[i][j] += Suf[i][j + 1];\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tPre[i][j] += Pre[i - 1][j], Suf[i][j] += Suf[i - 1][j];\n\t}\n\tmemset(F, 0X3F, sizeof(F)), F[0][0] = 0LL;\n\tP[0] = 0, P[N + 1] = N + 1;\n\tfor (int i = 1;i <= N + 1;++i)\n\t\tfor (int j = 0, t;j <= i - 1;++j)\n\t\t{\n\t\t\tupd(F[i][j], F[i - 1][j]);\n\t\t\tif (P[j] < P[i])\n\t\t\t{\n\t\t\t\tt = (i - 1) - j;\n\t\t\t\tt -= (Pre[i - 1][P[j]] - Pre[j][P[j]]) + (Suf[i - 1][P[i]] - Suf[j][P[i]]);\n\t\t\t\tupd(F[i][i], F[i - 1][j] + (Pre[i - 1][P[j]] - Pre[j][P[j]]) * B + (Suf[i - 1][P[i]] - Suf[j][P[i]]) * A + t * min(A, B));\n\t\t\t}\n\t\t}\n\tprintf(\"%d\", F[N + 1][N + 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 5010\n#define inf 1000000000000000ll\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,A,B;\nstruct data\n{\n\tint x,y;\n\tbool operator <(const data&a) const\n\t{\n\t\treturn x<a.x||x==a.x&&y<a.y;\n\t}\n}a[N];\nll f[N][N<<1];\nsigned main()\n{\n\tn=read(),A=read(),B=read();\n\tfor (int i=1;i<=n;i++) a[i].x=read(),a[i].y=i;\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tll s=inf;\n\t\tfor (int j=0;j<=n*2;j++)\n\t\t{\n\t\t\ts=min(s,f[i-1][j]);\n\t\t\tif (j&1)\n\t\t\t{\n\t\t\t\tf[i][j]=s+((j+1>>1)==a[i].y?0:((j+1>>1)<a[i].y?B:A));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tf[i][j]=s+(((j>>1)<a[i].y?B:A));\n\t\t\t}\n\t\t}\n\t}\n\tll ans=inf;\n\tfor (int i=0;i<=n*2;i++) ans=min(ans,f[n][i]);\n\tcout<<ans;\n\treturn 0;\n\t//NOTICE LONG LONG!!!!!\n}\n//考虑看做可以将数放到实数位置 向左a代价 向右b代价 不变0代价 "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n#include <unordered_map>\n#include <bitset>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  LL N,A,B;\n  cin >> N >> A >> B;\n  vector<LL> v(N);\n  REP(i,N){\n    cin >> v[i];\n  }\n\n  LL cost = N * B;\n\n  LL hoge = v[0];\n  REP(i, N)\n  {\n    if(v[i]>=hoge){\n      hoge = v[i];\n      cost -= B;\n    }\n  }\n\n  REP(i,N){\n    LL num = N - i;\n\n    LL targcnt = 0;\n    LL targ = num - 1;\n    REP(j, N)\n    {\n      LL idx = N - j - 1;\n      if(v[idx]==targ){\n        targ--;\n        targcnt++;\n      }\n      if(v[idx]>num){\n        targcnt = 0;\n        targ = num - 1;\n      }\n      if(v[idx]==num)\n      {\n        break;\n      }\n    }\n    if(A-B*targcnt<0&&targcnt>0){\n      cost += A - B * targcnt;\n    }\n  }\n\n  cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define taskname \"test\"\n\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long lli;\ntypedef pair<int, int> pii;\nconst int maxn = 5005;\nconst lli inf = 1e18;\nint n, a, b;\nint p[maxn];\n\nlli dp[maxn][maxn];\n\nvoid read_input()\n{\n    cin >> n >> a >> b;\n    for(int i = 1; i <= n; ++i)\n        cin >> p[i];\n}\n\nvoid solve()\n{\n    fill_n(&dp[0][0], sizeof(dp) / sizeof(dp[0][0]), inf);\n    dp[1][1] = 0;\n    for(int i = 2; i <= n; ++i)\n    {\n        dp[i][i] = 0;\n        for(int j = 1; j < i; ++j)\n        {\n            if(p[j] < p[i]) dp[i][i] += b;\n            else dp[i][i] += a;\n        }\n        for(int j = 1; j < i; ++j)\n        {\n            if(dp[i - 1][j] == inf) continue;\n            if(p[j] < p[i])\n            {\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + a);\n                dp[i][i] = min(dp[i][i], dp[i - 1][j]);\n            }\n            else /// p[j] > p[i]\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n        }\n    }\n    lli ans = inf;\n    for(int j = 1; j <= n; ++j)\n        ans = min(ans, dp[n][j]);\n    cout << ans << '\\n';\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    read_input();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nint dp[5010]={};\n\nint ban[5010][5010]={};\n\nint rui(int x1,int x2,int y1,int y2){\n\tif(x1>x2 || y1>y2)return 0;\n\tif(x1==0 && y1==0 )return ban[x2][y2];\n\tif(x1==0)return ban[x2][y2]-ban[x2][y1-1];\n\tif(y1==0)return ban[x2][y2]-ban[x1-1][y2];\n\t\n\treturn ban[x2][y2]-ban[x2][y1-1]-ban[x1-1][y2]+ban[x1-1][y1-1];\n\t\n\treturn 0;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n,a,b;\n \tcin>>n>>a>>b;\n \tvector<int> ve;\n \tve.pb(0);\n \tfor(int i=0;i<n;i++){\n \t\tint y;\n \t\tcin>>y;\n \t\tve.pb(y);\n \t\t\n \t}\n \tve.pb(n+1);\n \t\n \tn++;\n \tfor(int i=0;i<=n;i++){\n \t\tban[i][ve[i]]=1;\n \t}\n \t\n \tfor(int i=0;i<5010;i++)for(int j=0;j<5010;j++)if(i>0||j>0){\n \t\tif(i==0){\n \t\t\tban[i][j]+=ban[i][j-1];\n \t\t}\n \t\telse if(j==0) ban[i][j]+=ban[i-1][j];\n \t\telse{\n \t\t\tban[i][j]+=ban[i-1][j]+ban[i][j-1]-ban[i-1][j-1];\n \t\t}\n \t}\n \t\n \t\n \tfor(int i=0;i<=n;i++)dp[i]=inf*1000000000ll;\n \tdp[0]=0;\n \tfor(int i=1;i<=n;i++){\n \t\tfor(int j=0;j<i;j++)if(ve[j]<ve[i]){\n \t\t\t//cout<<i<<\" \"<<j<<endl;\n \t\t\tbool bo=1;\n \t\t\tint ans=dp[j];\n \t\t\tif(rui(j+1,i-1,ve[j]+1,ve[i]-1)>0){\n \t\t\t\tbo=0;\n \t\t\t//\tcout<<\"sk\"<<endl;\n \t\t\t}\n \t\t\telse{\n \t\t\t\tans+=a*rui(j+1,i-1,ve[i]+1,5009)+b*rui(j+1,i-1,0,ve[j]-1);\n \t\t\t}\n \t\t\t\n \t\t\tif(bo)dp[i]=min(ans,dp[i]);\n \t\t\t\n \t\t}\n \t//\tcout<<dp[i]<<endl;\n \t}\n \tcout<<dp[n]<<endl;\n \treturn 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define MP make_pair\n#define PB push_back\nusing namespace std;\nnamespace io{\n\tconst int Sz=1<<13;\n\tchar ibuf[Sz],*ips=ibuf+Sz-1;\n\tinline int getchar(){\n\t\tif(++ips==ibuf+Sz)fread(ips=ibuf,1,Sz,stdin);\n\t\treturn *ips;\n\t}\n\tchar obuf[Sz],*ops=obuf;\n\tinline void flush(){\n\t\tfwrite(obuf,1,ops-obuf,stdout);\n\t\tops=obuf;fflush(stdout);\n\t}\n\tinline void putchar(int c){\n\t\tif(ops==obuf+Sz)flush();\n\t\t*ops=c,ops++;\n\t}\n\tvoid gets(char *s){\n\t\tint c=getchar();\n\t\twhile(c<=32)c=getchar();\n\t\twhile(c>32)*s=c,++s,c=getchar();\n\t\t*s=0;\n\t}\n\tvoid puts(const char *s){\n\t\twhile(*s)putchar(*s),++s;\n\t}\n}\n#define getchar io::getchar\n#define putchar io::putchar\n#define gets io::gets\n#define puts io::puts\nint read(){\n\tint x=0,f=1,c=getchar();\n\tfor(;c<48||c>57;c=getchar())\n\t\tif(c=='-')f=-f;\n\tfor(;c>=48&&c<=57;c=getchar())\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tint stk[20],tp=0;\n\tif(!x)putchar(48);\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)stk[tp++]=(x-x/10*10)^48;\n\tfor(;tp;)putchar(stk[--tp]);\n}\nstruct Flusher{~Flusher(){io::flush();}}flusher;\n// ------------------------- Template End ------------------------- //\nconst int N=5005;\nint n,A,B;\nint p[N];\nint mn[N][N],mx[N][N];\nint dpl[N][N],dpr[N][N];\nll dp[N][N];\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nint main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=0;i<n;++i)p[i]=read();\n\tfor(int i=0;i<n;++i)mn[i][i]=mx[i][i]=p[i];\n\tfor(int i=0;i<n;++i)dpl[i][i]=dpr[i][i]=1;\n\tfor(int i=n-1;~i;--i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tmn[i][j]=min(mn[i][j-1],p[j]);\n\t\t\tmx[i][j]=max(mx[i][j-1],p[j]);\n\t\t\tdpl[i][j]=dpl[i][j-1];\n\t\t\tif(p[j]<p[i])++dpl[i][j];\n\t\t\tdpr[i][j]=dpr[i+1][j];\n\t\t\tif(p[i]<p[j])++dpr[i][j];\n\t\t}\n\t}\n\tfor(int i=n-1;~i;--i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tdp[i][j]=inf;\n\t\t\tdp[i][j]=min(dp[i][j],dp[i+1][j]+min(1LL*(dpl[i][j]>1?A:0),dpl[i][j]>2?inf:1LL*(dpl[i][j]>1?B:0)));\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][j-1]+min(1LL*(dpr[i][j]<j-i+1?B:0),dpr[i][j]<j-i?inf:1LL*(dpr[i][j]<j-i+1?A:0)));\n\t\t}\n\t}\n\twrite(dp[0][n-1]);putchar('\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n, i, j, a, b, x;\nint v[5005];\nlong long d[5005][5005], s[5005][5005];\nint main(){\n    cin>> n >> a >> b;\n    for(i = 1; i <= n; i++){\n        cin>> x;\n        v[x] = i;\n    }\n    for(i = 1; i <= n; i++){\n        for(j = 0; j <= n + 1; j++){\n            if(j <= v[i]){\n                d[i][j] = s[i - 1][j] + b;\n            }\n            else{\n                d[i][j] = s[i - 1][j] + a;\n            }\n            if(j == v[i]){\n                d[i][j] = min(d[i][j], s[i - 1][j - 1]);\n            }\n            s[i][j] = d[i][j];\n            if(j != 0){\n                s[i][j] = min(s[i][j], s[i][j - 1]);\n            }\n        }\n    }\n    cout<< s[n][n + 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ld long double\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nconstexpr double eps=1e-8;\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint Random(int mi,int ma){\n    random_device rnd;\n    mt19937 mt(rnd());//32bit\n    //[mi,ma]\n    uniform_int_distribution<int>engine(mi,ma);\n    return engine(mt);\n}\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nvector<int>kaijo,invkaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    invkaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n    rep(i,n+1)invkaijo[i]=modpow(kaijo[i],mod-2);\n}\nint comb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return kaijo[a]*invkaijo[a-b]%mod*invkaijo[b]%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nvoid solve(){\n    int n,a,b,p[5010],q[5010],dp[50][100];\n    cin>>n>>a>>b;\n    rep(i,n){\n        cin>>p[i];\n        q[p[i]-1]=i+1;\n    }\n    rep(i,n+1)rep(j,2*n+2)dp[i][j]=INF;\n    dp[0][1]=0;\n    rep(i,n){\n        int cur=INF;\n        for(int j=1;j<=2*n+1;j++){\n            if(j%2==1){\n                chmin(cur,dp[i][j]);\n                chmin(cur,dp[i][j-1]);\n            }\n            if(j>q[i]*2)chmin(dp[i+1][j],cur+a);\n            if(j<q[i]*2)chmin(dp[i+1][j],cur+b);\n            if(j==q[i]*2)chmin(dp[i+1][j],cur);\n        }\n    }\n    cout<<*min_element(dp[n],dp[n]+2*n+2)<<endl;\n}\nsigned main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    //int t;cin>>t;while(t--)\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define TR(X) ({ if(1) cerr << \"TR: \" << (#X) << \" = \" << (X) << endl; })\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tll n, L, R;\n\tcin >> n >> L >> R;\n\tswap(L,R);\n\n\tvl p(n+2);\n\tFOR(i,1,n+1) cin >> p[i];\n\tp[n+1] = n+1;\n\tn += 2;\n\n\tvl dp(n);\n\tvl inv(n);\n\n\tFOR(i,1,n) {\n\t\tFOR(j,0,i) if (p[j] > p[i]) inv[j]++;\n\t\t\n\t\tdp[i] = oo;\n\t\tll cntR = 0;\n\t\tFORD(j,0,i) {\n\t\t\tif (p[j] > p[i]) {\n\t\t\t\tcntR++;\n\t\t\t} else {\n\t\t\t\tll cntL = (i-j-1) - cntR; //inv[j];\n\t\t\t\tdp[i] = min(dp[i], dp[j] + cntL*L + cntR*R);\n\t\t\t}\n\t\t}\t\n\t}\n\tcout << dp[n-1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define llong long long\nconst llong inf=0x3f3f3f3f3f3f3f3f;\nint n,A,B;\nint nu[5050];\nllong f[5050][5050];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&A,&B);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&nu[i]);\n    memset(f,0x3f,sizeof(f));\n    f[0][0]=0;\n    int x;\n    for(int i=0;i<n;++i)\n        for(int j=0;j<=n;++j)\n        {\n            if(f[i][j]==inf)continue;\n            x=nu[i+1];\n            if(j>x)f[i+1][j]=min(f[i+1][j],f[i][j]+B);\n            else\n            {\n                f[i+1][x]=min(f[i+1][x],f[i][j]);\n                f[i+1][j]=min(f[i+1][j],f[i][j]+A);\n            }\n        }\n    llong ans=inf;\n    for(int i=0;i<=n;++i)ans=min(ans,f[n][i]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main() {\n  int n;\n  ll a, b;\n  scanf(\"%d%lld%lld\", &n, &a, &b);\n  vector<ll> f(n + 1, 1ll << 55);\n  f[0] = 0;\n  for (int _ = 1; _ <= n; _++) {\n    int x;\n    scanf(\"%d\", &x);\n    vector<ll> g(n + 1, 1ll << 55);\n    for (int i = 0; i <= n; i++) if (f[i] != 1ll << 55) {\n      if (x > i) {\n        g[x] = min(g[x], f[i]);\n        g[i] = min(g[i], f[i] + a);\n      } else {\n        g[i] = min(g[i], f[i] + b);\n      }\n    }\n    f = g;\n  }\n  ll ans = f[0];\n  for (int i = 1; i <= n; i++) {\n    ans = min(ans, f[i]);\n  }\n  printf(\"%lld\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define ll long long\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nint read(){\n    R int res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\nconst int N=5005;\nint p[N],n,A,B;ll dp[N],tmp;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read(),A=read(),B=read();\n\tfp(i,1,n)p[i]=read();\n\t++n,p[n]=n;\n\tfp(i,1,n){\n\t\tdp[i]=1e18,tmp=0;\n\t\tfd(j,i-1,0)p[j]<p[i]?(cmin(dp[i],dp[j]+tmp),tmp+=B):tmp+=A; \n\t}\n\tprintf(\"%lld\\n\",dp[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define y1 A2Dalek\n#define y0 Cyberman\n#define yn RoseTyler\n#define j1 JackHarkness\n#define fs first\n#define sd second\nconst int N=5000;\nconst long long oo=1e16+5;\nint du[]={-1,0,0,1};\nint dv[]={0,-1,1,0};\nconst long long mod=1e9+7;\ntypedef pair<int,int> ii;\ntypedef pair<int,ii> iii;\nlong long sqr(long long x) {return x*x;}\nint getbit(int state, int i) {return ((state>>i)&1);}\n\nint n,a[N+5];\nlong long A,B,f[N+5];\nint main()\n{\n\t//freopen(\"Rotation Sort.inp\",\"r\",stdin);\n\t//freopen(\"Rotation Sort.out\",\"w\",stdout);\n\tios_base::sync_with_stdio(false);\n    cin>>n>>A>>B;\n    for (int i=1;i<=n;i++) cin>>a[i];\n    for (int i=1;i<=n;i++)\n    {\n        f[i]=oo;\n        int dem1=0, dem2=0;\n        for (int j=i-1;j>=0;j--)\n        {\n            if (a[j]<a[i]) f[i]=min(f[i],f[j]+dem1*A+dem2*B);\n            if (a[j]<a[i]) dem1++; else dem2++;\n        }\n    }\n    cout<<f[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n\ntemplate <class X>\nclass SegmentTree {\n    int n;\n    vector<X> dat;\n    X identity;\n\n    X query_sub(int a, int b, int i, int l, int r) {\n        if (r <= a || b <= l) return identity;\n        if (a <= l && r <= b)\n            return dat[i];\n        else {\n            X vl = query_sub(a, b, i * 2 + 1, l, (l + r) / 2);\n            X vr = query_sub(a, b, i * 2 + 2, (l + r) / 2, r);\n            return op(vl, vr);\n        }\n    }\n\n    X get_identity(){\n        return 1LL<<60; // Range Minimum Query\n    }\n    X op(X x, X y){\n        return min(x, y); // Range Minimum Query;\n    }\npublic:\n    SegmentTree(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n\n        identity = get_identity();\n        dat = vector<X>(2 * n - 1, identity);\n\n    }\n    void update(int i, X x) {\n        i += n - 1;\n        dat[i] = x;\n        while (i > 0) {\n            i = (i - 1) / 2;\n            dat[i] = op(dat[i * 2 + 1], dat[i * 2 + 2]);\n        }\n    }\n    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n    X at(int i) { return dat[i + n - 1]; }\n};\n\nint main(){\n    int N, A, B;\n    cin >> N >> A >> B;\n    vector<int> p(N);\n    for(int i=0; i<N; i++)\n        cin >> p[i];\n    vector<int> pinv(N+1);\n    for(int i=0; i<N; i++)\n        pinv[p[i]] = 2*i+1;\n\n\n    SegmentTree<long long> st0(2*(N+1));\n    st0.update(0, 0);\n    for(int i=1; i<=N; i++){\n        SegmentTree<long long> st1(2*(N+1));\n\n        for(int j=0; j<pinv[i]; j+=2){\n            long long tmp = st0.query(0, j+1);\n            st1.update(j, tmp + B);\n        }\n\n        long long tmp = st0.query(0, pinv[i]);\n        st1.update(pinv[i], tmp);\n\n        for(int j=pinv[i]+1; j<=2*N; j+=2){\n            long long tmp = st0.query(0, j+1);\n            st1.update(j, tmp + A);\n        }\n        st0 = st1;\n    }\n    cout << st0.query(0, 2*(N+1)) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint main(){\n    int n,x,y;\n    cin>>n>>x>>y;\n    int b[n+1];\n    rep(i,n)cin>>b[i];\n    b[n]=n+1;\n    vector<ll> dp(n+2,longinf);\n    dp[0]=0;\n    rep(i,n+1){\n        ll sum=0;\n        for(int j = i-1;j>=0;--j){\n            if(b[j]>b[i])sum+=x;\n            if(b[j]<b[i]){\n                dp[i+1]=min(dp[i+1],dp[j+1]+sum);\n                sum+=y;\n            }\n        }\n        dp[i+1]=min(dp[i+1],sum);\n    }\n    cout<<dp[n+1]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 5e3 + 10;\nint n, A, B, ans;\nvector <int> v;\n\nvoid solve(vector <int> vec) {\n\tif (!vec.size())\n\t\treturn;\n\t\t\n\tint mn = N, indx = 0;\n\tfor (int i = 0; i < vec.size(); i++)\n\t\tif (vec[i] < mn) {\n\t\t\tmn = vec[i];\n\t\t\tindx = i;\n\t\t}\n\t\n\tif (B > A * indx) {\n\t\tans += A * indx;\n\t\tfor (int i = 0; i <= indx; i++)\n\t\t\tvec.erase(vec.begin());\n\t\tsolve(vec);\n\t}\n\telse {\n\t\tans += B;\n\t\tvec.erase(vec.begin() + indx);\n\t\tsolve(vec);\n\t}\n}\n\nint32_t main() {\n\tcin >> n >> A >> B;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tv.push_back(x);\n\t}\n\tsolve(v);\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 10000000000000;\n\tvector<long long> P, DP;\n\tcin >> N >> A >> B;\n\tP.resize(N);\n\tDP.assign(N + 1, INF);\n\tDP[0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long MIN = INF;\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tMIN = min(MIN, DP[j]);\n\t\t\t\tDP[j] += min(A, B);\n\t\t\t}\n\t\t\tif (0 < j && j < P[i]) {\n\t\t\t\tMIN = min(MIN, DP[j]);\n\t\t\t\tDP[j] += A;\n\t\t\t}\n\t\t\tif (j == P[i]) {\n\t\t\t\tDP[j] = MIN;\n\t\t\t}\n\t\t\tif (j > P[i]) {\n\t\t\t\tDP[j] += B;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MAXN =3e3+5;\nlong long dp[MAXN][MAXN];\nlong long pos[MAXN];\nlong long p[MAXN];\nlong long mindp[MAXN];\nint main(){\n    long long n,a,b;\n    cin>>n>>a>>b;\n    for(long long i=1;i<=n;i++){\n        cin>>p[i];\n        pos[p[i]] = i;\n    }\n    for(long long i=0;i<=n;i++){\n        for(long long j=0;j<=n;j++){\n            dp[i][j] = 1e18;\n        }\n    }\n    dp[0][0] = 0; \n    for(long long i=1;i<=n;i++){\n        for(long long j=0;j<=n;j++){\n           \n            if(j==pos[i]){\n                dp[i][j] = dp[i-1][j-1];\n                continue;\n            }\n            long long cost;\n            if(pos[i]<j){\n                cost = a;\n            }else{\n                cost = b;\n            }\n            if(j){\n                dp[i][j] = min(dp[i][j],dp[i][j-1]);\n               \n            }\n             dp[i][j] = min(dp[i][j],dp[i-1][j]+(cost));\n           // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n        }\n    }\n    cout<<dp[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst ll INF = 1ll << 60;\nconst int N = 5010;\nint n, A, B, per[N], mx[N], num[N], pla[N];\nll dp[N][N], ans;\nint main() {\n  read(n), read(A), read(B);\n  rep (i, 1, n) read(per[i]), pla[per[i]] = i;\n  memset(dp, 0x3f, sizeof dp);\n  dp[n][n] = 0;\n  ans = INF;\n  rrp (i, n, 1) {\n    rep (j, 1, n) {\n      num[j] = 0;\n      mx[j] = 0;\n      if (per[j] <= i) num[j] = 1, mx[j] = per[j];\n    }\n    rep (j, 2, n) mx[j] = max(mx[j], mx[j-1]);\n    rep (j, 2, n) num[j] += num[j-1];\n    rep (j, 1, n) {\n      int p = pla[mx[j]];\n      if (!p) {\n\tckmn(ans, dp[i][j]);\n\tcontinue;\n      }\n      ckmn(dp[i-1][j], dp[i][j] + A);\n      ckmn(dp[i-1][p-1], dp[i][j] + 1ll * B * (num[j] - num[p]));\n    }\n  }\n  rep (i, 0, n) ckmn(ans, dp[i][0]), ckmn(ans, dp[0][i]);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint a[5010], b[5010], c[5010];\nll mem[5010][5010], rt, lf, n;\nint d[5010][5010], s[5010][5010];\nll dp(int  x, int y){\n    if(x+1==y){\n        return 0;\n    }\n    if(mem[x][y]!=-1)\n        return  mem[x][y];\n    ll res;\n    int tmp=x+1;\n    if(b[tmp]>=y){\n        res=dp(x+1, y);\n    }\n    else{\n        res=rt+dp(x+1, y);\n        res=min(res, (d[tmp][tmp+1]-d[tmp][y])*lf+dp(x+1, y));\n    }\n    tmp=y-1;\n    if(c[tmp]<=x){\n        res=min(res, dp(x, y-1));\n    }\n    else{\n        res=min(res, lf+dp(x, y-1));\n        res=min(res, (s[tmp][tmp-1]-s[tmp][x])*rt+dp(x, y-1));\n    }\n    mem[x][y]=res;\n    return res;\n}\nint pos[5010];\nvoid pre(){\n    for(int i=0; i<n; ++i){\n        for(int j=n; j>a[i]; --j){\n            d[a[i]][j]=d[a[i]][j+1]+(pos[j]<i);\n//            cout<<a[i]<<\" \"<<j<<\" \"<<d[a[i]][j]<<endl;\n        }\n    }\n    for(int i=0; i<n; ++i){\n        for(int j=1; j<a[i]; ++j){\n            s[a[i]][j]=s[a[i]][j-1]+(pos[j]>i);\n//            cout<<a[i]<<\" \"<<j<<\" \"<<s[a[i]][j]<<endl;\n        }\n    }   \n\n}\nint main(){\n    while(cin>>n>>lf>>rt){\n        ll ans=0;\n        int tmp;\n        for(int i=0; i<n; ++i){\n            scanf(\"%d\",a+i);\n            pos[a[i]]=i;\n            tmp=n+1;\n            for(int j=0; j<i; ++j){\n                  if(a[j]>a[i])\n                        tmp=min(tmp, a[j]);\n            }\n            b[a[i]]=tmp;\n        }\n        for(int i=0; i<n; ++i){\n            tmp=0;\n            for(int j=n-1; j>i; --j){\n                if(a[j]<a[i]){\n                    tmp=max(tmp, a[j]);\n                }\n            }\n            c[a[i]]=tmp;\n        }\n        pre();\n        memset(mem, -1, sizeof mem);\n        ans=dp(0,n+1);\n        cout<<ans<<endl;\n    }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5678;\nconst long long llinf = 1e18;\n\nint n, a, b, p[N];\nlong long dp[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; ++i) {\n    cin >> p[i];\n  }\n  ++n;\n  p[n] = n;\n  fill(dp + 1, dp + n + 1, llinf);\n  for (int i = 0; i < n; ++i) {\n    int foo = n + 1;\n    long long cost = 0;\n    for (int j = i + 1; j <= n; ++j) {\n      if (p[j] > p[i]) {\n        if (p[j] > foo) {\n          break;\n        }\n        dp[j] = min(dp[j], dp[i] + cost);\n        foo = min(foo, p[j]);\n      }\n      if (p[j] < p[i]) {\n        cost += b;\n      } else {\n        cost += a;\n      }\n    }\n  }\n  cout << dp[n] << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nint dp[2][10004];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, a, b);\n\tVEC(int, p, n);\n\n\tV<int> q(n);\n\tREP(i, n) q[--p[i]] = i;\n\n\tFILL(dp, INFLL);\n\tdp[0][0] = 0;\n\n\tREP(i, n) {\n\t\tint pre = i % 2, cur = 1 - pre;\n\n\t\tint mi = INFLL;\n\t\tREP(j, 2 * n + 1) {\n\t\t\tint cost = 0;\n\t\t\tif (j <= 2 * q[i] + 0) cost = b;\n\t\t\tif (j >= 2 * q[i] + 2) cost = a;\n\n\t\t\tif (j % 2 == 0) {\n\t\t\t\tCHMIN(mi, dp[pre][j]);\n\t\t\t\tCHMIN(dp[cur][j], mi + cost);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCHMIN(dp[cur][j], mi + cost);\n\t\t\t\tCHMIN(mi, dp[pre][j]);\n\t\t\t}\n\t\t}\n\t\tFILL(dp[pre], INFLL);\n\t}\n\n\tint ans = INFLL;\n\tREP(j, 2 * n + 1) CHMIN(ans, dp[n % 2][j]);\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, A, B;\nint p[5005];\nlong long memo[5005][5005];\n\nlong long dp(int i, int j){\n    if(i > j){\n        return 0;\n    }else if(memo[i][j] != -1){\n        return memo[i][j];\n    }else{\n        vector<int> p2;\n        for(int k = 1; k <= N; k ++){\n            if(p[k] >= i && p[k] <= j){\n                p2.push_back(p[k]);\n            }\n        }\n\n        if(p2[0] == i){\n            return dp(i+1, j);\n        }else if(p2[j-i] == j){\n            return dp(i, j-1);\n        }\n\n        return memo[i][j] = min(B + dp(i+1, j), A + dp(i, j-1));\n    }\n}\n\nint main(){\n    scanf(\"%d%d%d\", &N, &A, &B);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &p[i]);\n    }\n\n    memset(memo, -1, sizeof(memo));\n    printf(\"%lld\", dp(1, N));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MN = 5005;\nll A, B, N, arr[MN], dp[MN][MN], i, j;\nll solve(ll n,ll lim){\n    if(n==0||lim==0) return 0;\n    else if(dp[n][lim]!=-1) return dp[n][lim];\n    if(arr[n]>lim){dp[n][lim]=solve(n-1,lim);}\n    else if(arr[n]==lim){dp[n][lim]=solve(n-1,lim-1);}\n    else dp[n][lim]=min(A+solve(n,lim-1),B+solve(n-1,lim));\n    return dp[n][lim];\n}\nint main(){\n    for(scanf(\"%lld%lld%lld\",&N,&A,&B),i=1;i<=N;i++)\n        scanf(\"%lld\",&arr[i]);\n    memset(dp,-1,sizeof(dp));\n    printf(\"%lld\\n\",solve(N,N));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll            long long\n#define pb            emplace_back\n#define fi            first\n#define se            second\n#define mp            make_pair\n//#define int           int64_t\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int N = (int)5e3 + 2;\nconst int mod = (int)1e9 + 7;\n\nint t[N], r[N], n, A, B, a[N], f, pos, mx;\nll res;\n\nvoid upd(int x) {for(; x <= n; x += (x & -x)) ++t[x];}\nint get(int x) {int res = 0; for(; x > 0; x -= (x & -x)) res += t[x]; return res;}\nvoid rupd(int x) {for(; x > 0; x -= (x & -x)) ++r[x];}\nint rget(int x) {int res = 0; for(; x <= n; x += (x & -x)) res += r[x]; return res;}\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    #define FileName      \"test\"\n    if(fopen(FileName\".inp\", \"r\")) {\n       freopen(FileName\".inp\", \"r\", stdin);\n       freopen(FileName\".out\", \"w\", stdout);\n    }\n    cin >> n >> A >> B;\n    for(int i = 1; i <= n; ++i) cin >> a[i];\n    for(int i = 1; i <= n; ++i) {\n        fill(t, t + n + 1, 0); mx = 0;\n        for(int j = n; j >= 1; --j) {\n            f = get(a[j]);\n            if(f > mx) mx = f, pos = j;\n            upd(a[j]);\n        }\n        if(mx == 0) return cout << res, 0;\n        fill(r, r + n + 1, 0);\n        for(int j = 1; j <= n; ++j) {\n            f = rget(a[j]);\n            if(f > mx) mx = f, pos = -j;\n            else if(f == mx && pos > 0 && A > B) pos = -j;\n            rupd(a[j]);\n        }\n        if(pos < 0) {\n           res += B; pos = -pos;\n           for(int j = pos - 1; j >= 1; --j) {\n               if(!mx) break;\n               if(a[j] > a[j + 1]) --mx;\n               swap(a[j], a[j + 1]);\n           }\n        } else {\n           res += A;\n           for(int j = pos + 1; j <= n; ++j) {\n               if(!mx) break;\n               if(a[j] < a[j - 1]) --mx;\n               swap(a[j], a[j - 1]);\n           }\n        }\n    }\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nint64 dp[5003][5003],dp2[5003];\nint64 a,b;\nint n;\nint p[5003],ip[5003];\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&a,&b);\n\tfor(int i = 1;i <= n;++i) {\n\t\tscanf(\"%d\",&p[i]);\n\t\tip[p[i]] = i;\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0][0] = 0;\n\tdp2[0] = 0;\n\tfor(int i = 1;i <= n;++i) {\n\t\t// (j,j+1)\n\t\tint64 min = dp[i-1][0];\n\t\tfor(int j = 0;j <= n;++j) {\n\t\t\tif(dp[i-1][j]!=-1 && dp[i-1][j]<min) min=dp[i-1][j];\n\t\t\tif(ip[i-1]==j && dp2[i-1]<min) min=dp2[i-1];\n\t\t\tdp[i][j] = min + (ip[i] <= j ? a : b);\n\t\t\tif(ip[i] == j+1) dp2[i] = min;\n\t\t}\n\t}\n\tint64 ans = dp2[n];\n\tfor(int i = 0;i <= n;++i) if(dp[n][i] < ans) ans = dp[n][i];\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\ntemplate<typename T> inline LL squ(T x) { return (LL) x * x; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T> inline T read()\n{\n\tT sum = 0, fg = 1; char c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') fg = -1;\n\tfor (; isdigit(c); c = getchar()) sum = (sum << 3) + (sum << 1) + (c ^ 0x30);\n\treturn fg * sum;\n}\n\nconst int maxn = 5e3 + 10;\nconst LL inf = 0x3f3f3f3f3f3f3f3f;\n\nint n, R, L, a[maxn], p[maxn], gl[maxn][maxn], gr[maxn][maxn];\nLL dp[maxn];\n\nint main()\n{\n\n\tn = read<int>(), R = read<int>(), L = read<int>();\n\tfor (int i = 1; i <= n; i++) p[a[i] = read<int>()] = i;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tgl[i][i] = gr[i][i] = p[i];\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tgl[i][j] = min(gl[i][j - 1], p[j]);\n\t\t\tgr[i][j] = max(gr[i][j - 1], p[j]);\n\t\t}\n\t}\n\n\tmemset(dp, 0x3f, sizeof dp), dp[n + 1] = 0;\n\tLL ans = inf;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int j = i ? n + 1 : n; j > i; j--)\n\t\t\tdp[j] = min(dp[j] + (a[gl[i][j - 1]] == i ? 0 : L), dp[j + 1] + (a[gr[i + 1][j]] == j ? 0 : R));\n\t\tchkmin(ans, dp[i + 1]);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 5005;\nconst long long INF = 1E18 + 7;\n\nint n, cl, cr, a[N], pl[N][N], pr[N][N];\nlong long dp[N][N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> cl >> cr;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = i; j >= 1; j--) {\n            pl[i][j] = (a[j] >= a[i] ? j : pl[i][j + 1]);\n        }\n        for (int j = i; j <= n; j++) {\n            pr[i][j] = (a[j] <= a[i] ? j : pr[i][j - 1]);\n        }\n    }\n    for (int l = n; l >= 1; l--) {\n        for (int r = l; r <= n; r++) {\n            dp[l][r] = min(dp[l][r - 1] + min(1LL * cr, 1LL * cl * (r - pl[r][l])), \n                           dp[l + 1][r] + min(1LL * cl, 1LL * cr * (pr[l][r] - l)));\n        }\n    }\n    cout << dp[1][n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 200000;\nint a[N], A, B, p[N];\nint used[5002][5002];\nlong long dp[5002][5002];\nint f[5002][5002];\nlong long solve(int l, int r) {\n    if (used[l][r]) {\n        return dp[l][r];\n    }\n    if (l == r) {\n        return 0;\n    }\n    used[l][r] = 1;\n    dp[l][r] = 1e18;\n    int i = p[l];\n    int cnt = f[i][r] - f[i][l - 1];\n    assert(cnt >= 1);\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r) + 1ll * min(A, B) * (cnt - 1));\n        dp[l][r] = min(dp[l][r], solve(l + 1, r) + B);\n    }\n    i = p[r];\n    cnt = f[n][r] - f[n][l - 1] - (f[i - 1][r] - f[i - 1][l - 1]);\n    assert(cnt >= 1);\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1) + 1ll * min(A, B) * (cnt - 1));\n        dp[l][r] = min(dp[l][r], solve(l, r - 1) + A);\n    }\n    return dp[l][r];\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        p[a[i]] = i;\n    }\n    for (int j = 1; j <= n; j++) {\n        for (int i = 1; i <= n; i++) {\n            f[i][j] = f[i - 1][j];\n            if (a[i] <= j) {\n                f[i][j]++;\n            }\n        }\n    }\n    cout << solve(1, n) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<int> p(n), pos(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        p[i]--;\n        pos[p[i]] = 2 * i + 1;\n    }\n    constexpr int64_t kInf = 1'000'000'000'000'000'000;\n    vector<vector<int64_t>> dp(n, vector<int64_t>(n + n + 1, kInf));\n    for (int i = 0; i < n + n; ++i) {\n        if (i < pos[0]) dp[0][i] = b;\n        else if (i == pos[0]) dp[0][i] = 0;\n        else dp[0][i] = a;\n    }\n    for (int i = 1; i < n; ++i) {\n        int64_t prv = kInf;\n        for (int j = 0; j < n + n + 1; ++j) {\n            prv = min(prv, dp[i - 1][j]);\n            if (j % 2 == 1 && j != pos[i]) continue;\n            int cost = j == pos[i] ? 0 : j < pos[i] ? b : a;\n            dp[i][j] = prv + cost;\n        }\n    }\n    cout << *min_element(dp[n - 1].begin(), dp[n - 1].end()) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\ntypedef long long ll ;\nconst ll N = 5055;\nll dp[N][N], A, B;\nint n, cnt[N][N], p[N], pos[N]; \nint main()\n{\n\tscanf(\"%d%lld%lld\", &n, &A, &B) ;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%d\", &p[i]) ;\n\t\tpos[p[i]] = i ; \n\t}\n\tfor(int i = 2 ; i <= n ; i ++)\n\t\tfor(int j = p[i]+1 ; j <= n ; j ++)\t\n\t\t\tcnt[i][j] = cnt[i][j-1] + (pos[j] < i) ;\n\tfor(int i = 1 ; i <= n ; i ++)\n\t\tfor(int j = 1 ; j <= n ; j ++)\n\t\t\tif(p[i] > j) dp[i][j] = dp[i-1][j] ;\n\t\t\telse dp[i][j] = min(dp[i-1][j]+B, cnt[i][j]*A+dp[i-1][p[i]-1]) ; \n\tcout << dp[n][n] ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nint n, p[5010];\nll A, B, ans = 1e18, f[5010][5010];\n\nint main() {\n    scanf(\"%d %lld %lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    memset(f, 0x3f, sizeof(f)), f[0][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (p[i] > j) {\n                f[i][j] = min(f[i][j], f[i - 1][j] + A);\n                f[i][p[i]] = min(f[i][p[i]], f[i - 1][j]);\n            } else {\n                f[i][j] = min(f[i][j], f[i - 1][j] + B);\n            }\n        }\n    }\n    for (int i = 0; i <= n; i++) {\n        ans = min(ans, f[n][i]);\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n#include <iomanip>\n#include <tuple>\n#define INF 1000000009\n#define LINF 1000000000000000009\n#define double long double\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n//ll mod = 1000000007;\n//ll mod = 998244353;\n\nint main() {\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tvector<ll> p(n);\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tvector<vector<ll>> dp(n + 1, vector<ll>(n + 1, LINF));\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (j < p[i]) {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + a);\n\t\t\t\tdp[i + 1][p[i]] = min(dp[i + 1][p[i]], dp[i][j]);\n\t\t\t}\n\t\t\tif (j > p[i]) {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + b);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = LINF;\n\tfor (int i = 0; i <= n; i++) ans = min(ans, dp[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nint n, p[5010], pos[5010];\nll A, B, ans;\n\nint main() {\n    scanf(\"%d %lld %lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) if (p[j] == i) {\n            ans += min(A * (j - i), B);\n            if (A * (j - i) > B) {\n                for (int k = j; k > i; k--) p[k] = p[k - 1];\n                p[i] = i;\n            } else {\n                for (int k = i; k < j; k++) {\n                    pos[k - i + 1] = k;\n                }\n                for (int k = 1; k <= j - i; k++) {\n                    int num = p[pos[k]];\n                    for (int t = pos[k]; t < num; t++) p[t] = p[t + 1];\n                    p[num] = num;\n                }\n            }\n            break;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nint arr[5012], revarr[5012];\nint l[5012][5012], r[5012][5012];\nll dp[5012][5012];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n;\n    ll a, b;\n    cin >> n >> a >> b;\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n        --arr[i];\n        revarr[arr[i]] = i;\n    }\n    for (int d = 0; d < n; ++d) {\n        for (int i = 0; i + d < n; ++i) {\n            if (d == 0) {\n                l[i][i] = r[i][i] = revarr[i];\n                dp[i][i] = 0;\n            } else {\n                dp[i][i + d] = 1e18;\n                l[i][i + d] = min(revarr[i], l[i + 1][i + d]);\n                r[i][i + d] = max(revarr[i], r[i + 1][i + d]);\n                if (revarr[i] < l[i + 1][i + d]) {\n                    dp[i][i + d] = min(dp[i][i + d], dp[i + 1][i + d]);\n                } else {\n                    dp[i][i + d] = min(dp[i][i + d], dp[i + 1][i + d] + b);\n                }\n                if (revarr[i + d] > r[i][i + d - 1]) {\n                    dp[i][i + d] = min(dp[i][i + d], dp[i][i + d - 1]);\n                } else {\n                    dp[i][i + d] = min(dp[i][i + d], dp[i][i + d - 1] + a);\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1] << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\nconst int N=5010;\nint n,a,b,x,p[N];\nll dp[N][N];\nint main() {\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\trep(i,1,n+1) scanf(\"%d\",&x),p[x]=i;\n\tmemset(dp,0x20,sizeof(dp));\n\tdp[0][0]=0;\n\trep(i,1,n+1) rep(j,1,i) {\n\t\tif (p[i]>p[j]) {\n\t\t\tdp[i][i]=min(dp[i][i],dp[i-1][j]);\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+b);\n\t\t} else\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+a);\n\t}\n\tprintf(\"%lld\\n\",*min_element(dp[n],dp[n]+n+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\nconst li mod = 1e9 + 7;\n\nint main() {\n    li n, a, b;\n    cin >> n >> a >> b;\n    vector<li> ps(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> ps[i];\n        ps[i]--;\n    }\n\n    vector<li> costs(n, 1LL << 60);\n    for (int i = 0; i < n; ++i) {\n        const li x = ps[i];\n        costs[x] = a * i;\n        for (int j = 0; j < i; ++j) {\n            if (ps[j] < x) {\n                costs[x] = min(costs[x], costs[ps[j]]);\n                costs[ps[j]] += a;\n            } else {\n                costs[ps[j]] += b;\n            }\n        }\n    }\n    const li ans = *min_element(costs.begin(), costs.end());\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSR(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nll A,B;\nint p[5005];\nvector<P>vec;\nll up[5005],dw[5005];\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t}\n\tint cur = -1;\n\tint pre = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i == 1){\n\t\t\tcur = p[i];\n\t\t}\n\t\telse if(cur+1 != p[i]){\n\t\t\tvec.pb(mp(pre+1,i-1));\n\t\t\tpre = i-1;\n\t\t\tcur = p[i];\n\t\t}\n\t\telse cur++;\n\t}\n\tvec.pb(mp(pre+1,n));\n\tll ans = 1e18;\n\tll C = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = vec[i].sc-vec[i].fi+1;\n\t\tll R = 0;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t    if(i == j) continue;\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] > p[y]){\n\t\t\t\tif(j > i) R += vec[j].sc-vec[j].fi+1;\n\t\t\t\telse;\n\t\t\t}\n\t\t}\n\t\tdw[i] = min(L*A,R*B);\n\t//\tcout << i << \" \" << L << \" \" << R<< endl;\n\t}\n\tll D = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = 0;\n\t\tll R = vec[i].sc-vec[i].fi+1;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t    if(i == j) continue;\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] < p[y]){\n\t\t\t\tif(j < i) L += vec[j].sc-vec[j].fi+1;\n\t\t\t\telse;\n\t\t\t}\n\t\t}\n\t\tup[i] = min(L*A,R*B);\n\t}\n\tfor(int j=0;j<=n;j++){\n\t    ll C = 0;\n\t    for(int i=0;i<vec.size();i++){\n\t        if(p[vec[i].fi] <= j) C += up[i];\n\t        else C += dw[i];\n\t    }\n\t    ans = min(ans,C); //cout<<C<<endl;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long A[10000];\nlong long a,b;\nlong long solve(vector<long long> &v)\n{\n  long long int now,ret = 10000000000000000,best;\n  if((int)v.size() <= 1) return 0;\n  vector<long long> l,r;\n  for(int i = 0;i < v.size();i++)\n  {\n    now = 0;\n    for(int j = 0;j < i;j++)\n    {\n      if(v[j] > v[i])\n        now += a;\n\n    }\n    for(int j = i+1;j < v.size();j++)\n    {\n      if(v[j] < v[i])\n      {\n        now+=b;\n      }\n    }\n    if(now < ret)\n    {\n      ret = now;\n      best = i;\n    }\n  }\n  for(int j = 0;j < best;j++)\n  {\n    if(v[j] <v[best])\n      l.push_back(v[j]);\n  }\n  for(int j = best + 1;j < v.size();j++)\n  {\n    if(v[j] >v[best])\n      r.push_back(v[j]);\n  }\n  return ret + solve(l) + solve(r);\n}\nint main()\n{\n  long long N,i,j,k,ans = 10000000000000,now;\n  vector<long long> pp;\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N >> a >> b;\n  for(i = 0;i <N;i++)\n  {\n    cin >> A[i];\n    pp.push_back(A[i]);\n  }\n  cout << solve(pp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fio() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pi;\ntypedef pair<pi, ll> pii;\n\nconst ll mod = 1e9 + 7;\nconst ll maxn = 1e5 + 6;\nconst ll N = 1e5 + 10;\nconst ll inf = 1e12;\nconst ld eps = 1e-16;\n\n\nll A, B;\nint n, a[N];\nbool mark[N];\n\nll calc (int r) {\n\tll res = 0;\n\t\n\tfill (mark, mark + n + 3, false);\n\t\n\tint i = 0;\n\tfor (int searchFor = 1; searchFor <= r; searchFor++) {\n\t\tif (a[i] == searchFor) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tres += A;\n\t}\n\t\n\tint toBe = r + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] <= r)\n\t\t\tcontinue;\n\t\tif (a[i] != toBe) {\n\t\t\tmark[a[i]] = true;\n\t\t\tres += B;\n\t\t} else {\n\t\t\ttoBe++;\n\t\t\twhile (mark[toBe])\n\t\t\t\ttoBe++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\tfio();\n\tcin >> n >> B >> A;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\n\tll ans = inf;\n\tfor (int r = 0; r <= n; r++)\n\t\tans = min(ans, calc(r));\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nint main()\n{\n\tsrand(time(NULL));\n\tint ans=rand();\n\tif (ans%2==0)\n\tprintf(\"Yes\");\n\telse printf(\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define loop(i, a, b, inc) for(int i = a; i < (b); i += inc)\n#define rep(i, n) loop(i, 0, n, 1)\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint main() {\n\tfreopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvi arr(n);\n\trep(i, n) cin >> arr[i];\n\tsort(arr.begin(), arr.end());\n\tint best = INT_MAX;\n\trep(i, n) best = min(best, i + (int)(arr.end() - upper_bound(arr.begin(), arr.end(), arr[i]*2)));\n\tcout << best << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nint in[5050];\nll dp[5050];\nint main() {\n\tll N, A, B, i, j;\n\tscanf(\"%lld %lld %lld\", &N, &A, &B);\n\tin[0] = 0, in[N + 1] = N + 1;\n\tfor (i = 1; i <= N; i++) scanf(\"%d\", &in[i]);\n\n\tdp[0] = 0;\n\tfor (i = 1; i <= N + 1; i++) {\n\t\tdp[i] = LL_INF;\n\n\t\tll sum = 0;\n\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\tif (in[j] < in[i]) {\n\t\t\t\tdp[i] = min(dp[i], dp[j] + sum);\n\t\t\t}\n\n\t\t\tif (in[j] < in[i]) sum += B;\n\t\t\telse sum += A;\n\t\t}\n\t}\n\treturn !printf(\"%lld\\n\", dp[N + 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nll dp[5005][5005], p[5005][5005], n, a, b, loc[5005];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> a >> b;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> p[n-1][i];\n\t\tp[n-1][i]--;\n\t}\n\tloc[0] = 0;\n\tfor (int i = n-1; i >= 1; --i) {\n\t\tint ct = 0;\n\t\tfor (int j = 0; j < i+1; ++j) {\n\t\t\tif (p[i][j] != i) {\n\t\t\t\tp[i-1][ct] = p[i][j];\n\t\t\t\t++ct;\n\t\t\t} else\n\t\t\t\tloc[i] = j;\n\t\t}\n\t\t/* for (int j = 0; j < i; ++j)\n\t\t\tcout << p[i-1][j] << ' ';\n\t\tcout << endl; */\n\t}\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t//last j guys have free left moves\n\t\t\tif (i == 0) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i][j] = (1LL<<60);\n\t\t\tif (loc[i] >= i+1-j) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j-1]);\n\t\t\t\tdp[i][j] = min(dp[i][i], a + dp[i-1][j-1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][i-loc[i]]+b*(i-j-loc[i]));\n\t\t\t\tdp[i][j] = min(dp[i][j], a + dp[i-1][j]);\n\t\t\t}\n\t\t}\n\tcout << dp[n-1][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 5000\n#define ll long long\ninline int read()\n{\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return x*f;\n}\nll f[MN+5],A,B;\nint n;\nint main()\n{\n    n=read();A=read();B=read();\n    memset(f,63,sizeof(f));f[0]=0;\n    for(int i=1;i<=n;++i)\n    {\n        int x=read();\n        for(int j=0;j<x;++j)\n        {\n            f[x]=min(f[x],f[j]);\n            f[j]+=A;\n        }\n        for(int j=x;++j<=n;) f[j]+=B;\n    }\n    ll ans=1e18;\n    for(int i=0;i<=n;++i) ans=min(ans,f[i]);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\nusing namespace std;\n#define MOD 1000000007\n#define REP(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//sortは初期で昇順 greater<hoge>()で降順\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(Graph & G, ll s, ll t)\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\t\t\t\t\t\t   \n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\nbool compare_by_b(pair<ll, ll> a, pair<ll, ll> b) {//降順second\n\tif (a.second != b.second) {\n\t\treturn a.second < b.second;\n\t}\n\telse {\n\t\treturn a.first > b.first;\n\t}\n}\n\nbool compare_by_a(pair<ll, ll> a, pair<ll, ll> b) {//降順first\n\tif (a.first != b.first) {\n\t\treturn a.first > b.first;\n\t}\n\telse {\n\t\treturn a.second > b.second;\n\t}\n}\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nint main() {\n\tll n;\n\tcin >> n;\n\tll a, b;\n\tcin >> a >> b;\n\tArray p(n);\n\tREP(i, n)cin >> p[i];\n\tMatrix dp(n + 1);\n\tREP(i, n + 1) {\n\t\tdp[i].resize(n + 1);\n\t\tREP(j, n + 1)dp[i][j] = INF;\n\t}\n\tdp[0][0] = 0;\n\tREP(i, n) {\n\t\tREP(j, n+1) {\n\t\t\tif (p[i] > j) {\n\t\t\t\tchmin(dp[i + 1][p[i]], dp[i][j]);\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + a);\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + b);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = INF;\n\tREP(i, n+1) {\n\t\tchmin(ans, dp[n][i]);\n\t}\n\tcout << ans;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register\n#define int long long\nusing namespace std; const int N=5010;\ninline int read()\n{\n    int s=0,w=1; char ch=getchar();\n    while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar(); return s*w;\n}\nint n,X,Y;\nint dp[N][N],p[N];\nsigned main()\n{\n\tn=read(), X=read(), Y=read();\n\tfor(ri int i=1;i<=n;i++) {int x=read(); p[x]=i; }\n\tfor(ri int i=1;i<=n;i++) for(ri int j=0;j<=n;j++) dp[i][j]=LONG_LONG_MAX/2;\n\tfor(ri int i=1;i<=n;i++)\n\t{\n\t\tfor(ri int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(p[i]==j) dp[i][j]=min(dp[i-1][j-1],dp[i][j]);\n\t\t\tif(j<p[i]) dp[i][j]=min(dp[i][j],dp[i-1][j]+Y);\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+X);\n\t\t}\n\t\tfor(ri int j=1;j<=n;j++) dp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 998244353LL;// (ll)(1e9 + 7);\n\n\nvoid solve()\n{\n\tll N, A, B;\n\tcin >> N >> A >> B;\n\tauto p = cinv(N);\n\n\tif (A < B){\n\t\tstd::swap(A, B);\n\t\tstd::reverse(p.begin(), p.end());\n\t\tEACH(e, p) e = N-e+1;\n\t}\n\n\tmap<ll, ll> dp;\n\tdp[0] = A;\n\tdp[p[0]] = 0;\n\n\tREP(i, N-1){\n\t\tll k = p[i+1];\n\n\t\tll x;\n\t\tfor (auto it = dp.begin(); it != dp.end(); ){\n\t\t\tll j = it->first;\n\t\t\tif (j < k){\n\t\t\t\tx = it->second;\n\t\t\t\tit->second += A;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tit->second += B;\n\t\t\t\tif (it->second >= x) it = dp.erase(it);\n\t\t\t\telse                 it++;\n\t\t\t}\n\t\t}\n\t\tdp[k] = x;\n\t}\n\tcout << ((--dp.end())->second) << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nint n, p[5010], pos[5010];\nll A, B, ans;\n\nint main() {\n    scanf(\"%d %lld %lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) if (p[j] == i) {\n            ans += min(A * (j - i), B);\n            if (A * (j - i) > B) {\n                for (int k = j; k > i; k--) p[k] = p[k - 1];\n                p[i] = i;\n            } else {\n                for (int k = i; k < j; k++) {\n                    pos[k - i + 1] = k;\n                }\n                sort(pos + 1, pos + j - i + 1, [&](int x, int y) { return p[x] > p[y]; });\n                for (int k = 1; k <= j - i; k++) {\n                    int num = p[pos[k]];\n                    for (int t = pos[k]; t < num; t++) p[t] = p[t + 1];\n                    p[num] = num;\n                }\n            }\n            break;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define sz size()\n#define pb push_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\n\nint N;\nLL A, B;\n\nint p[10000], pos[10000];\n\nLL dp[6000][6000];\n\nLL memo(int idx, int largest) {\n\tif (idx < 0 || largest < 0)\n\t\treturn 0LL;\n\t\t\n\tLL &ret = dp[idx][largest];\n\tif (ret != -1)\n\t\treturn ret;\n\t\t\n\tif (p[idx] == largest)\n\t\treturn ret = memo(idx - 1, largest - 1);\n\t\t\n\tif (p[idx] > largest)\n\t\treturn ret = memo(idx - 1, largest);\n\t\t\n\tif (pos[largest] > idx)\n\t\treturn ret = memo(idx, largest - 1);\n\t\t\n\tret = A + memo(idx, largest - 1);\n\tLL tmp = 0LL;\n\tffor (i, pos[largest], idx + 1)\n\t\tif (p[i] < largest)\n\t\t\ttmp += B;\n\tret = min(ret, tmp + memo(pos[largest] - 1, largest - 1));\n\t\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcin >> N >> A >> B;\n\t\n\tFOR (i, N) {\n\t\tcin >> p[i];\n\t\tp[i]--;\n\t\tpos[p[i]] = i;\n\t}\n\t\n\tSET(dp, 255);\n\tcout << memo(N - 1, N - 1) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 5e3 + 10;\n\nint n, a, b, p[N];\nlong long f[N][N];\n\nint main(void) {\n  scanf(\"%d%d%d\", &n, &a, &b);\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%d\", &p[i]);\n  }\n  memset(f, 0x3f, sizeof f);\n  f[0][0] = 0;\n  for(int i = 1; i <= n; i++) {\n    for(int j = 0, t; j <= n; j++) {\n      if(p[i] > j) {\n\tf[i][p[i]] = min(f[i][p[i]], f[i - 1][j]);\n\tf[i][j] = min(f[i][j], f[i - 1][j] + a);\n      } else {\n\tf[i][j] = min(f[i][j], f[i - 1][j] + b);\n      }\n    }\n  }\n  long long ans = f[0][1];\n  for(int i = 0; i <= n; i++) {\n    ans = min(ans, f[n][i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nint n, p[5010], pos[5010];\nll A, B, ans;\n\nint main() {\n    scanf(\"%d %lld %lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) if (p[j] == i) {\n            ans += min(A * (j - i), B);\n            if (A * (j - i) > B) {\n                for (int k = j; k > i; k--) p[k] = p[k - 1];\n                p[i] = i;\n            } else {\n                for (int k = i; k < j; k++) {\n                    pos[k - i + 1] = k;\n                }\n                sort(pos + 1, pos + j - i + 1, [&](int x, int y) {\n                    return (x + i - 1 < p[x]) > (y + i - 1 < p[y]);\n                });\n                for (int k = 1; k <= j - i; k++) {\n                    int num = p[pos[k]];\n                    for (int t = pos[k]; t < num; t++) p[t] = p[t + 1];\n                    p[num] = num;\n                }\n            }\n            break;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n\nll dp[5123][5123];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,R,L;\n\tcin>>n>>R>>L;\n\tvector<int> a(n);\n\trep(i,n) cin>>a[i], --a[i];\n\tvector<int> toL(n),toR(n);\n\t{\n\t\tset<int> st{n};\n\t\trep(i,n){\n\t\t\ttoL[a[i]]=*st.lower_bound(a[i]);\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\t{\n\t\tset<int> st{-1};\n\t\trrep(i,n){\n\t\t\tauto it=st.lower_bound(a[i]); --it;\n\t\t\ttoR[a[i]]=*it;\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\tout(toL,toR,1);\n\tfill(dp[0],dp[5123],INF);\n\tdp[0][n-1]=0;\n\trreps(d,2,n+1)rep(l,n+1-d){\n\t\tint r=l+d-1;\n\t\tMN(dp[l+1][r],dp[l][r]+(toL[l]>r?0:L));\n\t\tMN(dp[l][r-1],dp[l][r]+(toR[r]<l?0:R));\n\t}\n\t// rep(i,n){rep(j,n) cout<<dp[i][j]<<\",\";cout<<endl;}\n\tll re=INF;\n\trep(i,n) MN(re,dp[i][i]);\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define nmax 5005\nusing std::cin;\nusing std::cout;\nlong long min(long long x, long long y)\n{\n    return (y < x) ? y : x;\n}\nint n, x[nmax+1], p[nmax+1];\nlong long dp[nmax+1][nmax*2+1], a, b;\nint main()\n{\n    std::ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> a >> b;\n    for(int i = 1; i <= n; ++i)\n      cin >> p[i];\n    for(int i = 1; i <= n; ++i)\n      x[p[i]] = (i << 1) - 1;\n    for(int i = 1; i <= n; ++i){\n      dp[i][0] = dp[i - 1][0] + b;\n      for(int j = 1; j <= n << 1; ++j)\n        dp[i][j] = min(dp[i][j - 1], ((j < x[i]) ? b : ((j > x[i]) ? a : 0)) + ((j & 1) ? dp[i - 1][j - 1] : dp[i - 1][j]));\n    }\n    cout << dp[n][n * 2];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint num[5005],pos[5005];\nll f[5005][5005];\n\ninline void update(ll &x,ll y) {\n  x=min(x,y);\n}\n\nint main() {\n  memset(f,0x3f,sizeof(f));\n  int n,a,b;\n  scanf(\"%d%d%d\",&n,&a,&b);\n  for(int i=1;i<=n;i++) {\n  \tscanf(\"%d\",&num[i]);\n  \tpos[num[i]]=i;\n  }\n  for(int i=1;i<=n;i++) f[i][i]=0;\n  for(int i=n;i>0;i--) {\n  \tint minn=pos[i],maxn=pos[i];\n    for(int j=i+1;j<=n;j++) {\n    \tminn=min(minn,pos[j]);\n    \tmaxn=max(maxn,pos[j]);\n        update(f[i][j],f[i+1][j]+((pos[i]!=minn)?b:0));\n\t\tupdate(f[i][j],f[i][j-1]+((pos[j]!=maxn)?a:0));\t\n\t}\n  }\n  printf(\"%lld\\n\",f[1][n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 320000\nusing namespace std;\nlong long n,A,B;\nlong long L[N],R[N];\nlong long f[5200][5200]; \nlong long a[5200];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&A,&B);\n\tif(n==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tlong long x;\n\t\tscanf(\"%d\",&x);\n\t\ta[x]=i;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tfor(long long j=i+1;j<=n;j++)if(a[j]<a[i]){L[i]=j;break;}\n\t\tfor(long long j=i-1;j>=1;j--)if(a[j]>a[i]){R[i]=j;break;}\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0][n+1]=0;\n\tfor(long long i=0;i<n;i++){\n\t\tfor(long long j=n+1;j>i;j--){\n\t\t\tif(L[i]<j)f[i+1][j]=min(f[i][j]+B,f[i+1][j]);\n\t\t\telse f[i+1][j]=min(f[i][j],f[i+1][j]);\n\t\t\tif(R[j]>i)f[i][j-1]=min(f[i][j]+A,f[i][j-1]);\n\t\t\telse f[i][j-1]=min(f[i][j],f[i][j-1]);\n\t\t}\n\t}\n\tlong long ans=1000000000000000LL;\n\tfor(long long i=0;i<=n;i++)ans=min(ans,f[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n#define fir first\n#define sec second\n#define mod 998244353\n#define int long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\ninline int min(int x,int y,int z){return min(x,min(y,z));}\ninline int max(int x,int y,int z){return max(x,max(y,z));}\ninline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\ninline int add(int x,int y,int z){return add(add(x,y),z);}\ninline int sub(int x,int y){return x-y<0?x-y+mod:x-y;}\ninline int mul(int x,int y){return 1LL*x*y%mod;}\ninline int mul(int x,int y,int z){return mul(mul(x,y),z);}\n#define N 5005\nint a[N];\nint f[N][N];\nsigned main()\n{\n\tint n,A,B; cin>>n>>A>>B;\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(j<a[i]) f[i][j]=f[i-1][j]+A;\n\t\t\telse if(j>a[i]) f[i][j]=f[i-1][j]+B;\n\t\t}\n\t\tf[i][a[i]]=INF;\n\t\tfor(int j=0;j<=a[i];j++) if(f[i-1][j]<f[i][a[i]]) f[i][a[i]]=f[i-1][j];\n\t}\n\tint ans=INF;\n\tfor(int i=0;i<=n;i++) if(f[n][i]<ans) ans=f[n][i];\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<sstream>\n#include<set>\n#include<vector>\n#include<stack>\n#include<map>\n#include<queue>\n#include<deque>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<functional>\nusing namespace std;\n\n#define N 5005\n#define INF ((long long)1<<60)\n\nint a[N];\n\nstruct Edge\n{\n    int from,to;long long cap,flow;\n    Edge(int u,int v,long long c,long long f):from(u),to(v),cap(c),flow(f){}\n};\n\nstruct Dinic\n{\n\tint n,m,s,t;//结点数，边数（包括反向弧），源点编号，汇点编号\n\tvector<Edge>edges;//边表，dges[e]和dges[e^1]互为反向弧\n\tvector<int>G[N];//邻接表，G[i][j]表示结点i的第j条边在e数组中的编号\n\tbool vis[N]; //BFS的使用\n\tint d[N]; //从起点到i的距离\n\tint cur[N]; //当前弧下标\n\t\n\tvoid addedge(int from,int to,long long cap)\n\t{\n\t    edges.push_back(Edge(from,to,cap,0));\n\t    edges.push_back(Edge(to,from,0,0));\n\t    int  m=edges.size();\n\t    G[from].push_back(m-2);\n\t    G[to].push_back(m-1);\n\t}\n\t\n\tbool bfs()\n\t{\n\t    memset(vis,0,sizeof(vis));\n\t    queue<int>Q;\n\t    Q.push(s);\n\t    d[s]=0;\n\t    vis[s]=1;\n\t    while(!Q.empty())\n\t    {\n\t        int x=Q.front();Q.pop();\n\t        for(int i=0;i<G[x].size();i++)\n\t        {\n\t            Edge&e=edges[G[x][i]];\n\t            if(!vis[e.to]&&e.cap>e.flow)//只考虑残量网络中的弧\n\t            {\n\t                vis[e.to]=1;\n\t                d[e.to]=d[x]+1;\n\t                Q.push(e.to);\n\t            }\n\t        }\n\t\n\t    }\n\t    return vis[t];\n\t}\n\t\n\tlong long dfs(int x,long long a)//x表示当前结点，a表示目前为止的最小残量\n\t{\n\t    if(x==t||a==0)return a;//a等于0时及时退出，此时相当于断路了\n\t    long long flow=0,f;\n\t    for(int&i=cur[x];i<G[x].size();i++)//从上次考虑的弧开始，注意要使用引用，同时修改cur[x]\n\t    {\n\t        Edge&e=edges[G[x][i]];//e是一条边\n\t        if(d[x]+1==d[e.to]&&(f=dfs(e.to,min(a,e.cap-e.flow)))>0)\n\t        {\n\t            e.flow+=f;\n\t            edges[G[x][i]^1].flow-=f;\n\t            flow+=f;\n\t            a-=f;\n\t            if(!a)break;//a等于0及时退出，当a!=0,说明当前节点还存在另一个曾广路分支。\n\t\n\t        }\n\t    }\n\t    return flow;\n\t}\n\t\n\tlong long Maxflow(int s,int t)//主过程\n\t{\n\t    this->s=s,this->t=t;\n\t    long long flow=0;\n\t    while(bfs())//不停地用bfs构造分层网络，然后用dfs沿着阻塞流增广\n\t    {\n\t        memset(cur,0,sizeof(cur));\n\t        flow+=dfs(s,INF);\n\t    }\n\t    return flow;\n\t}\n}A;\ninline int read(){\n\tint ret=0;bool f=0;char ch=getchar();\n\twhile(ch>'9'||ch<'0') f^=ch=='-',ch=getchar();\n\twhile(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();\n\treturn f?-ret:ret;\n}\nint main(){\n\tA.n=read()+1;int X=read(),Y=read();\n\tfor (int i=1;i<A.n;i++) a[i]=read();\n\tfor (int i=1;i<A.n;i++)\n\tA.addedge(0,i,X),A.addedge(i,A.n,Y);\n\tfor (int i=1;i<A.n;i++)\n\tfor (int j=i+1;j<A.n;j++) if(a[i]>a[j])\n\tA.addedge(i,j,INF);\n\tprintf(\"%lld\\n\",A.Maxflow(0,A.n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define LL long long\nusing namespace std;\nconst int maxn = 5e3 + 5;\nLL f[maxn][maxn];\nint trs[maxn][maxn][2], a[maxn], n, A, B;\nint vis[maxn], pos[maxn], pt;\nint main() {\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor(register int i = 1; i <= n; ++i) \n\t\tscanf(\"%d\", &a[i]), pos[a[i]] = i;\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0][n + 1] = 0, pt = 0, pos[n + 1] = n + 1;\n\tfor(register int l = 0; l <= n + 1; ++l) {\n\t\tvis[pos[l]] = 1;\n\t\twhile(vis[pt]) ++pt;\n\t\tint pl = pt, pr = n + 1;\n\t\tfor(register int r = n + 1; r > l; --r) {\n\t\t\tvis[pos[r]] = 1;\n\t\t\twhile(vis[pl]) ++pl;\n\t\t\twhile(vis[pr]) --pr;\n\t\t\tif(a[pl] == l + 1) trs[l][r][0] = 1;\n\t\t\tif(a[pr] == r - 1) trs[l][r][1] = 1;\n\t\t}\n\t\tfor(register int r = n; r > l; --r)\n\t\t\tvis[pos[r]] = 0;\n\t}\n\tfor(register int i = n + 2; i >= 3; --i) {\n\t\tfor(register int l = 0; l <= n + 2 - i; ++l) {\n\t\t\tint r = l + i - 1;\n\t\t\tif(trs[l][r][1]) f[l][r - 1] = min(f[l][r - 1], f[l][r]);\n\t\t\telse f[l][r - 1] = min(f[l][r - 1], f[l][r] + A);\n\t\t\tif(trs[l][r][0]) f[l + 1][r] = min(f[l + 1][r], f[l][r]);\n\t\t\telse f[l + 1][r] = min(f[l + 1][r], f[l][r] + B);\n\t\t}\n\t}\n\tLL ans = 0x3f3f3f3f3f3f3f3f;\n\tfor(register int i = 0; i <= n; ++i) {\n\t\tans = min(ans, f[i][i + 1]);\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define ll long long\nusing namespace std;\nconst int N=5005;\nint n,a[N];\nll f[N],A,B;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>A>>B;\n\tfo(i,1,n)cin>>a[i];\n\ta[n+1]=n+1;\n\tfo(i,1,n+1){\n\t\tint ct=0,ct2=0,mx=0;\n\t\tf[i]=1e18;\n\t\tfd(j,0,i-1)\n\t\t\tif(a[j]<a[i]){\n\t\t\t\tif(a[j]<mx){\n\t\t\t\t\t++ct2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tf[i]=min(f[i],f[j]+A*ct+B*ct2);\n\t\t\t\t++ct2;mx=a[j];\n\t\t\t}else ++ct;\n\t}\n\tcout<<f[n+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nint main(){\n    int N; ll A, B;\n    cin >> N >> A >> B;\n    int p[N], id[N];\n    rep(i, N){\n        cin >> p[i]; p[i]--;\n        id[p[i]] = i;\n    }\n    int ord[N];\n    rep(i, N){\n        ord[i] = 1;\n        rep(j, i) if(id[j] < id[i]) ord[i]++;\n    }\n    ll dp[N+1][N+1];\n    fill(dp[0], dp[N+1], INF);\n    dp[0][0] = 0;\n    rep(i, N){\n        rep(j, ord[i]) dp[i+1][j] = dp[i][j];\n        rep2(j, ord[i], i+1){\n            dp[i+1][j] = min(dp[i][j-1]+A, dp[i][ord[i]-1]+B*(j-ord[i]));\n        }\n    }\n    cout << dp[N][N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll INF = (ll)1e17;\nconst int N = 5050;\nll dp[N];\nint n;\nint a[N];\nll A, B;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%lld%lld\", &n, &B, &A);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tif (A < B) {\n\t\treverse(a + 1, a + n + 1);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = n + 1 - a[i];\n\t\tswap(A, B);\n\t}\n\ta[0] = 0;\n\ta[n + 1] = n + 1;\n\tfor (int i = 0; i <= n + 1; i++)\n\t\tdp[i] = INF;\n\tdp[0] = 0;\n\tfor (int l = 0; l <= n; l++) {\n\t\tll w = 0;\n\t\tfor (int r = l + 1; r <= n + 1; r++) {\n\t\t\tif (a[r] < a[l]) {\n\t\t\t\tw += A;\n\t\t\t} else {\n\t\t\t\tdp[r] = min(dp[r], dp[l] + w);\n\t\t\t\tw += B;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n + 1]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5050;\nconst long long inf = 1e18;\n\nlong long dp[N][N];\nint p[N];\n\nvoid upd(long long &a, long long b) {\n  if (a > b)\n    a = b;\n}\n\nint main() {\n  int n, a, b;\n  scanf(\"%d %d %d\", &n, &a, &b);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", p+i);\n  }\n  for (int i = 0; i <= n; ++i)\n    for (int j = 0; j <= n; ++j)\n      dp[i][j] = inf;\n  dp[0][0] = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      if (dp[i][j] >= inf) continue;\n      upd(dp[i+1][j], dp[i][j] + (j > p[i] ? b : a));\n      if (j < p[i])\n        upd(dp[i+1][p[i]], dp[i][j]);\n    }\n  }\n  long long ans = inf;\n  for (int j = 0; j <= n; ++j)\n    upd(ans, dp[n][j]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst long long INF = 1LL << 60;\n\nint main(){\n    int N;\n    long long A, B;\n    cin >> N >> A >> B;\n    vector<int> pos(N);\n    for(int i=0;i<N;i++){\n        int p; cin >> p;\n        pos[p-1] = 2*i+1;\n    }\n    vector<long long> dp(2*N+1, INF);\n    for(int i=0;i<pos[0];i+=2) dp[i] = B;\n    dp[pos[0]] = 0;\n    for(int i=pos[0]+1;i<=2*N;i+=2) dp[i] = A;\n    for(int i=1;i<N;i++){\n        long long best = INF;\n        for(int j=0;j<=2*N;j++){\n            best = min(best, dp[j]);\n            if(j%2 == 0){\n                auto c = (j < pos[i] ? B : A);\n                dp[j] = best + c;\n            } else if(j == pos[i]){\n                dp[j] = best;\n            } else {\n                dp[j] = INF;\n            }\n        }\n    }\n    cout << *min_element(dp.begin(), dp.end()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#include<cstring> \n#include<cassert>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nlong long dp[5005][5005][2];\nint a[5005],id[5005];\nint main(){\n\tint n;\n\tlong long A,B;\n\tcin>>n>>A>>B;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tid[a[i]]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(j)dp[i][j][0]=min(min(dp[i-1][j][0],dp[i-1][j][1]),dp[i][j-1][0]);\n\t\t\telse dp[i][j][0]=dp[i-1][j][0];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(j>=id[i])dp[i][j][0]+=A; else dp[i][j][0]+=B;\n\t\t\tdp[i][j][1]=dp[i][j][0];\n\t\t}\n\t\tlong long mi=1e18;\n\t\tfor(int j=0;j<id[i];j++){\n\t\t\tmi=min(mi,min(dp[i-1][j][0],dp[i-1][j][1]));\n\t\t}\n\t\tdp[i][id[i]][1]=mi;\n\t//\tcout<<dp[i][id[i]][1]<<\" \";\n\t}\n\tlong long mi=1e9;\n\tfor(int i=0;i<=n;i++){\n\t\tmi=min(min(dp[n][i][0],dp[n][i][1]),mi);\n\t}\n\tcout<<mi;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nvoid solve() {\n    int n, A, B;\n    cin >> n >> A >> B;\n    vector<int> a(n+2);\n    a[0] = 0; a[n+1] = n+1;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    vector<long long> dp(n+2, 1ll<<60);\n    dp[0] = 0;\n    for (int i = 1; i <= n+1; i++) {\n        int cnt = 0;\n        for (int j = i-1; j >= 0; j--) {\n            if (a[j] < a[i]) {\n                dp[i] = min(dp[i], dp[j] + 1ll*cnt*A + 1ll*(i-1-j-cnt)*B);\n            } else {\n                cnt++;\n            }\n        }\n    }\n    cout << dp[n+1];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Jump, and you will find out how to unfold your wings as you fall.\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=5010,mod=1e9+7;\nconst ll inf=1e18;\n\nint dp1[maxn][maxn],dp2[maxn][maxn],a[maxn];\nll ans[maxn];\n\nint main(){\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    int n,A,B;cin>>n>>A>>B;\n    for(int i=1;i<=n;i++){\n\tcin>>a[i];\n    }\n    a[n+1]=n+1;\n    for(int i=0;i<=n+1;i++){\n\tfor(int j=i+1;j<=n+1;j++){\n\t    dp1[i][j]=dp1[i][j-1]+(a[i]>a[j]);\n\t}\n    }\n    for(int j=n+1;j>=0;j--){\n\tfor(int i=j-1;i>=0;i--){\n\t    dp2[i][j]=dp2[i+1][j]+(a[i]>a[j]);\n\t}\n    }\n    for(int r=1;r<=n+1;r++){\n\tans[r]=inf;\n\tfor(int l=0;l<r;l++){\n\t    if(a[l]>a[r] || dp1[l][r-1]+dp2[l+1][r]!=r-l-1) continue;\n\t    ans[r]=min(ans[r],ans[l]+1ll*A*dp2[l+1][r]+1ll*B*dp1[l][r-1]);\n\t}\n    }\n    return cout<<ans[n+1]<<endl,0;\n}\n// Deathly mistakes:\n//  * Read the problem curfully.\n//  * Check maxn.\n//  * Overflows.\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int N=5022;\nLL dp[N][N];\nint n,a,b,x[N],pos[N];\nint mn[N][N],mx[N][N];\n\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]), pos[x[i]]=i;\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)dp[i][j]=1e18;\n    dp[0][n+1]=0;\n    for(int i=1;i<=n;i++){\n        mx[i][i]=mn[i][i]=pos[i];\n        for(int j=i+1;j<=n;j++){\n            mx[i][j]=max(mx[i][j-1],pos[j]);\n            mn[i][j]=min(mn[i][j-1],pos[j]);\n        }\n    }\n    for(int len=0;len<n;len++)\n    for(int i=0;i<=len;i++){\n        int lef=i,rig=n+1-(len-i);\n        // [1,lef], [rig,n]\n        if(lef+1<rig && rig<=n+1){\n            //printf(\"len=%d,lef=%d,rig=%d %lld\\n\", len,lef,rig,dp[lef][rig]);\n            dp[lef+1][rig]=min(dp[lef+1][rig], dp[lef][rig]+(LL)(pos[lef+1]==mn[lef+1][rig-1]?0:b));\n            dp[lef][rig-1]=min(dp[lef][rig-1], dp[lef][rig]+(LL)(pos[rig-1]==mx[lef+1][rig-1]?0:a));\n        }\n    }\n    LL ans=1e18;\n    for(int i=0;i<=n;i++)ans=min(ans,dp[i][i+1]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stdlib.h>\n#include <time.h>\n#include <iomanip>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\n#define taskname \"A\"\n#define LL long long \n#define uLL unsigned long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n#define REP(i,l,r) for(int i = l; i < r; ++i)\n#define FORD(i,r,l) for(int i = r; i >= l; --i)\n#define REPD(i,r,l) for(int i = r; i > l; --i)\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(), (x).end()\n#define debug(x) { cerr << #x << \" = \" << x << endl; }\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scii(x, y) int x, y; scanf(\"%d %d\", &x, &y);\n#define sciii(x, y, z) int x, y, z; scanf(\"%d %d %d\", &x, &y, &z);\n#define pi pair<int,int>\n#define pii pair<int,pi>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define _USE_MATH_DEFINES \n/* M_PI */\n\nconst int maxN = 5011;\nconst LL oo = 1e17 + 11;\n\nint tcases = 1;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\nchar ch;\nint readInt(){\n    bool fl = 0;\n    while(ch = getchar(),ch != '-' && (ch < '0' || ch > '9'));\n    if(ch == '-'){\n        fl = 1;\n        while(ch = getchar(),ch < '0' || ch > '9');\n    }\n    int r = ch - '0';\n    while(ch = getchar(),ch >= '0' && ch <= '9') r = r * 10 + (ch - '0');\n    return fl ? -r : r;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N,M,K,p[maxN],p1[maxN],cntleft[maxN],cntright[maxN];\nint pos[maxN][maxN],w[maxN][maxN],smaller[maxN][maxN],cnt[maxN];\nLL A,B,dp[maxN][maxN],res = oo;\n\nstruct{\n    int f[maxN],a[maxN];\n    void update(int i){\n        ++a[i];\n        while(i <= N){\n            ++f[i];\n            i += i & -i;\n        }\n    }\n    int cal(int l,int r){\n        int rr = 0;\n        while(l <= r){\n            if(r - (r & -r) > l) rr += f[r],r -= r & -r;\n            else rr += a[r],--r;\n        }\n        return rr;\n    }\n    void clear(){ FOR(i,1,N) f[i] = a[i] = 0; }\n} BIT;\nvoid init(){\n    BIT.clear();\n    FOR(i,1,N){\n        cntleft[p[i]] = BIT.cal(1,p[i] - 1);\n        BIT.update(p[i]);\n    }\n    FOR(i,1,N){\n        int x = 0;\n        FORD(j,N,p[i] + 1){\n            x += cnt[j];\n            w[p[i]][j] = x;\n        }\n        int y = 0;\n        FOR(j,1,p[i] - 1){\n            y += cnt[j];\n            smaller[p[i]][j] = y;\n        }\n        cnt[p[i]]++;\n    }\n}\nvoid testcase(){\n    scanf(\"%d%lli%lli\",&N,&A,&B);\n\n    FOR(i,1,N){\n        scanf(\"%d\",&p[i]),p1[p[i]] = i;\n    }\n    init();\n    //\n    FOR(i,0,N + 1)\n    FOR(j,i + 1,N + 1) dp[i][j] = oo;\n    \n    dp[0][N + 1] = 0;\n    FOR(l,0,N){\n        REPD(r,N + 1,l + 1){\n            if(dp[l][r] >= oo) continue;\n            int k = p1[l + 1] - cntleft[l + 1] - w[l + 1][r];\n            dp[l + 1][r] = min(dp[l + 1][r],dp[l][r] + min(B,A * (k - 1)));\n            //cout << \"pos[\"<<l<<\"][\"<<r<<\"] = \" << k << \" / \";\n            //\n            k = p1[r - 1] - (smaller[r - 1][l]) - w[r - 1][r];\n            //cout << k << \" ~> \" << r - 1 - l << endl;\n            dp[l][r - 1] = min(dp[l][r - 1],dp[l][r] + min(A,B * ((r - 1 - l) - k)));\n        }\n        res = min(res,dp[l][l + 1]);\n    }\n    printf(\"%lli\",res);\n}\n\nint main(){\n\n    //cin >> tcases;\n\n    FOR(i,1,tcases) testcase();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n    \nvoid go();\n\nmain(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nvoid go(){\n    int n=in();\n    ll a=lin(),b=lin();\n    auto dp = vec2ll(n+2,n+10);\n    rep(i,n+1)rep(j,n+1)dp[i][j]=1e16;\n    vec p;rep(i,n)p.pb(in());\n    dp[0][0]=0;\n    rep(i,n){\n        rep(j,n){\n            if( j < p[i]){\n                chmin(dp[i+1][j],dp[i][j] + a);\n                chmin(dp[i+1][p[i]],dp[i][j]);\n            }\n            else if(j > p[i]){\n                chmin(dp[i+1][j],dp[i][j]+b);\n            }\n        }\n    }\n    ll mi=1e16;\n    rep(i,n+1)chmin(mi,dp[n][i]);\n    cout<<mi<<endl;\n}\n    \n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=5e3+5;\nint n,R,L,a[N];ll ans=1e18,dp[N];\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&R,&L);\n\tmemset(dp,64,sizeof(dp)),dp[0]=0;\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=0;j<a[i];++j) dp[a[i]]=min(dp[a[i]],dp[j]);\n\t\tfor(int j=0;j<a[i];++j) dp[j]+=R;\n\t\tfor(int j=a[i];j<n;++j) dp[j+1]+=L;\n\t}\n\tfor(int i=0;i<=n;++i) ans=min(ans,dp[i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\n// pythonのrangeのような範囲for文用のclass for(const auto& i : Range<>(10)) のように書く\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\n// lambda式を用いた再帰\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\n// 多次元vectorの一斉初期化 makeVector<i64, 0>(a, b, ...)のように書く\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\n// 最大値を更新し、更新できた時にはtrueを返す\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// 同様に最小値を更新する\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n// 行数と変数名、値をclogに表示するデバッグ用print\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n// 同様の配列向けデバッグ用print\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\n// input用の関数群\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    i64 n, x, y;\n    input(n, x, y);\n    vector<i64> a(n);\n    input(a);\n    list<i64> s;\n    for(const auto& i : Range<>(n))\n        s.push_back(a[i]);\n    i64 ind = 1;\n    i64 sum = 0;\n    // [0, ind) is sorted\n    while(ind != n + 1){\n        if(*s.begin() == ind){\n            s.erase(s.begin());\n            ++ind;\n            continue;\n        }\n        auto it = s.begin();\n        for(; *it != ind; ++it);\n        auto it2 = next(it);\n        i64 nex = ind + 1;\n        while(it2 != s.end() && *it2 == nex){\n            ++nex;\n            ++it2;\n        }\n\n        // ここ線形\n        // dist回だけ前に移動する\n        i64 dist = distance(s.begin(), it);\n        // その後、length回だけ回転させる\n        i64 length = distance(it, it2);\n        i64 cost_a = dist * x;\n        i64 cost_b = length * y;\n        sum += min(cost_a, cost_b);\n        for(i64 i = 0; i < length; ++i)\n            it = s.erase(it);\n        ind += length;\n    }\n\n    cout << sum << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INFL = 1e18;\nconst int MN = 5050;\nll dp[MN][MN];\nll dt[MN];\nll ord[MN];\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tll n,a,b;\n\tcin >> n >> a >> b;\n\tfor(int i=0;i<n;i++) {\n\t\tint t;\n\t\tcin >> t;\n\t\tt--;\n\t\tord[t] = i+1;\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tfor(int i=0;i<n;i++) {\n\t\tll ma = INFL;\n\t\tfor(int j=0;j<=n;j++) {\n\t\t\tif(i > 0) {\n\t\t\t\tif(j == ord[i-1]) {\n\t\t\t\t\tma = min(ma,dt[i-1]);\n\t\t\t\t}\n\t\t\t\tma = min(ma,dp[i-1][j]);\n\t\t\t} else {\n\t\t\t\tma = 0;\n\t\t\t}\n\t\t\tif(j == ord[i]) {\n\t\t\t\tdt[i] = ma;\n\t\t\t}\n\t\t\tdp[i][j] = ma + (j>=ord[i]?a:b);\n\t\t}\n\t}\n\tll res = INFL;\n\tfor(int i=0;i<=n;i++) {\n\t\tres = min(res,dp[n-1][i]);\n\t}\n\tres = min(res,dt[n-1]);\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define pb push_back\n \nconst int maxn = 5e3 + 20;\n\nll dp[maxn] , a[maxn];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tll x , y;\n\tcin >> n >> x >> y;\n\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\n\ta[n + 1] = n + 1;\n\tmemset(dp , 63 , sizeof dp);\n\tdp[0] = 0;\n\tfor(int i = 1; i <= n + 1; i++)\n\t{\n\t\tint mx = -1 , t = 0;\n\t\tfor(int j = i - 1; j >= 0; j--)\n\t\t{\n\t\t\tif(a[j] > a[i])\n\t\t\t\tt++;\n\t\t\telse if(a[j] > mx)\n\t\t\t{\n\t\t\t\tmx = a[j];\n\t\t\t\tdp[i] = min(dp[i] , dp[j] + t * x + (i - j - 1 - t) * y);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[n + 1] << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint read(){\n\tint x=0,f=1;\n    char c=getchar();\n    while(c<'0'||c>'9'){\n    \tif(c=='-') f=-1;\n    \tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\n#define maxn 5005\ntypedef long long ll;\nint n,a[maxn],dp[maxn],pre[maxn],posi[maxn];\nll A,B;\nbool vis[maxn]; \nvoid init(){\n\tn=read();\n\tscanf(\"%lld%lld\",&A,&B);\n\tfor(int i=1;i<=n;i++) a[i]=read(),posi[a[i]]=i;\n\t\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tif(a[j]<a[i]){\n\t\t\t\tif(dp[j]+1>dp[i]){\n\t\t\t\t\tdp[i]=dp[j]+1;\n\t\t\t\t\tpre[i]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxx=0,maxid;\n    for(int i=1;i<=n;i++) if(dp[i]>maxx) maxx=dp[i],maxid=i;\n    int now=maxid;\n    if(maxx==0) vis[1]=1;\n    while(now){\n    \tvis[now]=1; \n    \tnow=pre[now];\n\t}\n\tll ans=0,calc;\n\tfor(int i=1;i<=n;i++){\n\t\tif(vis[i]) continue;\n\t\tcalc=10000000;\n\t    int pos=a[i];\n\t    while(!vis[posi[pos]]&&pos>=1) pos--;\n\t    if(vis[posi[pos]]){\n\t    \tint t=posi[pos];\n\t    \tif(t>i){\n\t    \tll val1=A;\n\t\t\tll val2=(ll)(posi[pos]-i)*B;\n\t\t\tcalc=min(val1,val2);\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll val1=B;\n\t\t\t\tll val2=(ll)(i-posi[pos]-1)*A;\n\t\t\t\tcalc=min(val1,val2);\n\t\t\t}\n\t\t}\n\t\tpos=a[i];\n\t    while(!vis[posi[pos]]&&pos<=n) pos++;\n\t    if(vis[posi[pos]]){\n\t    \tint t=posi[pos];\n\t    \tif(t>i){\n\t    \tll val1=A;\n\t\t\tll val2=(ll)(posi[pos]-i-1)*B;\n\t\t\tcalc=min(calc,val2);\n\t\t\tcalc=min(calc,val1);\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll val1=B;\n\t\t\t\tll val2=(ll)(i-posi[pos])*A;\n\t\t\t\tcalc=min(calc,val1);\n\t\t\t\tcalc=min(calc,val2);\n\t\t\t}\n\t\t}\n\t\tans+=calc;\n\t}\n\tprintf(\"%lld\",ans);\n}\nint main(){\n    init();\n    \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing lint = long long;\nconstexpr lint INF = 1LL << 50;\n\nvoid solve() {\n    int n;\n    lint a, b;\n    std::cin >> n >> a >> b;\n\n    std::vector<int> xs(n);\n    for (auto& x : xs) std::cin >> x;\n    xs.insert(xs.begin(), -1);\n\n    std::vector<lint> dp(1, 0);\n    std::vector<lint> ndp = dp;\n\n    for (int i = 1; i <= n; ++i) {\n        ndp.assign(i + 1, INF);\n\n        for (int j = 0; j < i; ++j) {\n            if (xs[j] < xs[i]) {\n                // fix\n                ndp[i] = std::min(ndp[i], dp[j]);\n                // pass\n                ndp[j] = std::min(ndp[j], dp[j] + a);\n            } else {\n                // pass\n                ndp[j] = std::min(ndp[j], dp[j] + b);\n            }\n        }\n        std::swap(dp, ndp);\n    }\n\n    std::cout << *std::min_element(dp.begin(), dp.end()) << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 5005\nlong long dp[N][N];\nint n,a,b,p[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)dp[i][j]=1e17;\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tlong long mn=1e18;\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tlong long tp=mn;\n\t\t\tif(p[i]>j)tp+=a;\n\t\t\tif(p[i]<j)tp+=b;\n\t\t\tif(dp[i][j]>tp)dp[i][j]=tp;\n\t\t\tif(mn>dp[i-1][j])mn=dp[i-1][j];\n\t\t\ttp=mn;\n\t\t\tif(p[i]>j)tp+=a;else tp+=b;\n\t\t\tif(dp[i][j]>tp)dp[i][j]=tp;\n\t\t}\n\t}\n\tlong long as=1e18;\n\tfor(int i=0;i<=n;i++)if(as>dp[n][i])as=dp[n][i];\n\tprintf(\"%lld\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5002;\nint n,A,B,a[N];\nlong long f[N],tot;\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n//\tfreopen(\"D.out\",\"w\",stdout);\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\ta[n+1]=n+1,n++;\n\tmemset(f,63,sizeof(f));\n\tf[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ttot=0;\n\t\tfor(int j=i-1;~j;j--)\n\t\t{\n\t\t\tif (a[j]<a[i]) f[i]=min(f[i],f[j]+tot),tot+=B;\n\t\t\telse tot+=A;\n\t\t}\n\t\t//cout<<i<<' '<<f[i]<<endl;\n\t}\n\tprintf(\"%lld\",f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define MP make_pair\n#define PB push_back\nusing namespace std;\nnamespace io{\n\tconst int Sz=1<<13;\n\tchar ibuf[Sz],*ips=ibuf+Sz-1;\n\tinline int getchar(){\n\t\tif(++ips==ibuf+Sz)fread(ips=ibuf,1,Sz,stdin);\n\t\treturn *ips;\n\t}\n\tchar obuf[Sz],*ops=obuf;\n\tinline void flush(){\n\t\tfwrite(obuf,1,ops-obuf,stdout);\n\t\tops=obuf;fflush(stdout);\n\t}\n\tinline void putchar(int c){\n\t\tif(ops==obuf+Sz)flush();\n\t\t*ops=c,ops++;\n\t}\n\tvoid gets(char *s){\n\t\tint c=getchar();\n\t\twhile(c<=32)c=getchar();\n\t\twhile(c>32)*s=c,++s,c=getchar();\n\t\t*s=0;\n\t}\n\tvoid puts(const char *s){\n\t\twhile(*s)putchar(*s),++s;\n\t}\n}\n#define getchar io::getchar\n#define putchar io::putchar\n#define gets io::gets\n#define puts io::puts\nint read(){\n\tint x=0,f=1,c=getchar();\n\tfor(;c<48||c>57;c=getchar())\n\t\tif(c=='-')f=-f;\n\tfor(;c>=48&&c<=57;c=getchar())\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tint stk[20],tp=0;\n\tif(!x)putchar(48);\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)stk[tp++]=(x-x/10*10)^48;\n\tfor(;tp;)putchar(stk[--tp]);\n}\nstruct Flusher{~Flusher(){io::flush();}}flusher;\n// ------------------------- Template End ------------------------- //\nconst int N=5005;\nint n,A,B;\nint p[N],ps[N];\nll dp[N][N],mndp[N][N];\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nvoid chkmin(ll &x,ll y){if(y<x)x=y;}\nint main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=0;i<n;++i)p[i]=read(),ps[p[i]]=i<<1;\n\tmemset(dp,0x3f,sizeof dp);\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i)for(int k=0;k<(n<<1);++k){\n//\t\tfor(int j=0;j<=k;++j){\n\t\t\tchkmin(dp[i][k],mndp[i-1][k]+(ps[i]==k?0:(ps[i]<k?A:B)));\n\t\t\tif(k)mndp[i][k]=mndp[i][k-1];else mndp[i][k]=inf;\n\t\t\tchkmin(mndp[i][k],dp[i][k]);\n//\t\t}\n\t}\n\twrite(mndp[n][(n<<1)-1]);putchar('\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst ll INF = 1e18;\nconst int N = 5005;\nll dp[N][N];\nint a[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, A, B;\n    cin >> n >> A >> B;\n\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j] = INF;\n        }\n    }\n\n    dp[0][0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (j < a[i]) {\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + A);\n            }\n            else if (j > a[i]) {\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + B);\n            }\n        }\n        for (int j = 0; j < a[i]; j++)  {\n            dp[i + 1][a[i]] = min(dp[i + 1][a[i]], dp[i][j]);\n        }\n    }\n\n    ll ans = INF;\n\n    for (int i = 0; i <= n; i++) {\n        ans = min(ans, dp[n][i]);\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\nusing namespace std;\nconst int N=5005;\nint n,A,B,a[N];\nint p[N];\nll f[2][N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tFor(i,1,n) scanf(\"%d\",&a[i]),p[a[i]]=i;\n\tFor(i,1,n) For(j,0,n){\n\t\tint co=(j==p[i]?0:(j<p[i]?B:A));\n\t\tf[i&1][j]=min(j==0?1ll<<60:f[i&1][j-1],f[(i&1)^1][j]+co);\n\t}\n\tprintf(\"%lld\\n\",f[n&1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nnamespace n91 {\n\n\tusing i8 = std::int_least8_t;\n\tusing i32 = std::int_least32_t;\n\tusing i64 = std::int_least64_t;\n\tusing u8 = std::uint_least8_t;\n\tusing u32 = std::uint_least32_t;\n\tusing u64 = std::uint_least64_t;\n\tusing isize = std::ptrdiff_t;\n\tusing usize = std::size_t;\n\n\tclass rep {\n\t\tconst usize f, l;\n\n\tpublic:\n\t\tclass itr {\n\t\t\tfriend rep;\n\t\t\tusize i;\n\t\t\tconstexpr itr(const usize x) noexcept : i(x) {}\n\n\t\tpublic:\n\t\t\tvoid operator++() noexcept { ++i; }\n\t\t\tconstexpr usize operator*() const noexcept { return i; }\n\t\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t\t};\n\t\tconstexpr rep(const usize first, const usize last) noexcept\n\t\t\t: f(first), l(last) {}\n\t\tconstexpr itr begin() const noexcept { return itr(f); }\n\t\tconstexpr itr end() const noexcept { return itr(l); }\n\t};\n\tclass revrep {\n\t\tconst usize f, l;\n\n\tpublic:\n\t\tclass itr {\n\t\t\tfriend revrep;\n\t\t\tusize i;\n\t\t\tconstexpr itr(usize x) noexcept : i(x) {}\n\n\t\tpublic:\n\t\t\tvoid operator++() noexcept { --i; }\n\t\t\tconstexpr usize operator*() const noexcept { return i; }\n\t\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t\t};\n\t\tconstexpr revrep(usize first, usize last) noexcept : f(--first), l(--last) {}\n\t\tconstexpr itr begin() const noexcept { return itr(l); }\n\t\tconstexpr itr end() const noexcept { return itr(f); }\n\t};\n\ttemplate <class T> using vec_alias = std::vector<T>;\n\ttemplate <class T> auto md_vec(const usize n, const T &value) {\n\t\treturn std::vector<T>(n, value);\n\t}\n\ttemplate <class... Args> auto md_vec(const usize n, Args... args) {\n\t\treturn std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n\t}\n\ttemplate <class T> constexpr T difference(const T &a, const T &b) {\n\t\treturn a < b ? b - a : a - b;\n\t}\n\n} // namespace n91\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cassert>\n\nnamespace n91 {\n\n\tvoid stop(){}\n\n\tvoid main_() {\n\t\tusize n;\n\t\tu64 a, b;\n\t\tstd::cin >> n >> a >> b;\n\t\tstd::vector<usize> p(n);\n\t\tfor (auto &e : p) {\n\t\t\tstd::cin >> e;\n\t\t\t--e;\n\t\t}\n\t\tp.emplace_back(n);\n\t\tstatic constexpr u64 INF = std::numeric_limits<u64>::max();\n\t\tstd::vector<u64> dp(n + 1, INF);\n\t\tfor (const auto i : rep(0, n + 1)) {\n\n\t\t\tu64 acc = 0;\n\t\t\tusize prev = 0;\n\t\t\tfor (const auto k : revrep(0, i)) {\n\t\t\t\tif (p[k] > p[i]) {\n\t\t\t\t\tacc += a;\n\t\t\t\t}\n\t\t\t\telse if (p[k] < prev) {\n\t\t\t\t\tacc += b;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprev = p[k];\n\t\t\t\t\tif (dp[k] + acc < dp[i]) {\n\t\t\t\t\t\tdp[i] = dp[k] + acc;\n\t\t\t\t\t}\n\t\t\t\t\tacc += b;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (acc < dp[i]) {\n\t\t\t\tdp[i] = acc;\n\t\t\t}\n\t\t}\n\t\tstd::cout << dp.back() << std::endl;\n\t\tstop();\n\t}\n\n} // namespace n91\n\nint main() {\n\tn91::main_();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#define REP(i, a) for (int i = 0; i < (a); i++)\n#define REPR(i, a) for (int i = (int)(a) - 1; i >= 0; i--)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORR(i, a, b) for (int i = (int)(b) - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<long long>;\nusing vvl = vector<vl>;\nusing vs = vector<string>;\nint si() { int x; scanf(\"%d\", &x); return x; }\nlong long sl() { long long x; scanf(\"%lld\", &x); return x; }\nstring ss() { string x; cin >> x; return x; }\nvoid pi(int x) { printf(\"%d \", x); }\nvoid pl(long long x) { printf(\"%lld \", x); }\nvoid pd(double x) { printf(\"%.15f \", x); }\nvoid ps(const string &a) { cout << a << ' '; }\nvoid br() { putchar('\\n'); }\n\nvoid to(long long *x, long long y) {\n  *x = min(*x, y);\n}\n\nint main() {\n  int N = si();\n  long long R = sl();\n  long long L = sl();\n  vi A(N);\n  REP(i, N) A[i] = si();\n  static long long dp[5001][5001];\n  REP(i, 5001) REP(j, 5001) dp[i][j] = 1e18;\n  dp[0][0] = 0;\n  REP(i, N) {\n    REP(j, N+1) {\n      if (j < A[i]) {\n        to(&dp[i+1][A[i]], dp[i][j]);\n        to(&dp[i+1][j], dp[i][j] + R);\n      }\n      if (A[i] < j) {\n        to(&dp[i+1][j], dp[i][j] + L);\n      }\n    }\n  }\n  long long ans = 1e18;\n  REP(i, N+1) to(&ans, dp[N][i]);\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<ctime>\n#include<cmath>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<string>\n#include<vector>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\n#define Rep(i,s,t) for(register int i=s;i<t;++i)\n#define go(x) for(register int e=las[x];e;e=nxt[e])\n#define re register\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define is insert\n#define es erase\n#define pii pair<int,int>\n#define ms(f,x) memset(f,x,sizeof f)\n#define mc(f,x) memcpy(f,x,sizeof f)\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define gi(x) read(x)\n#define gii(x,y) read(x),read(y)\n#define giii(x,y,z) read(x),read(y),read(z)\nnamespace IO{\n    #define gc getchar()\n    #define pc(x) putchar(x)\n    template<typename T>inline void read(T &x){\n        x=0;int f=1;char ch=gc;while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc;x*=f;return;\n    }\n    template<typename T>inline void write(T x=0){\n        T wr[51];wr[0]=0;if(x<0)pc('-'),x=-x;if(!x)pc(48);\n        while(x)wr[++wr[0]]=x%10,x/=10;while(wr[0])pc(48+wr[wr[0]--]);return;\n    }\n}\nusing IO::read;\nusing IO::write;\ntypedef long long ll;\ntypedef double db;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nconst int N=5011;\nint n,A,B;\nint p[N],b[N],c[N],s[N],pos[N];\nll dp[N][N];\ninline void ins(int x){\n\t++x;\n\tfor(;x<=n+2;x+=x&-x)\n\t\t--s[x];\n}\ninline int query(int x){\n\tint res=0;\n\t++x;\n\tfor(;x;x-=x&-x)\n\t\tres+=s[x];\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\trep(i,1,n)\n\t\tscanf(\"%d\",p+i),pos[p[i]]=i;\n\trep(i,0,n+1)\n\t\trep(j,0,n+1)\n\t\t\tdp[i][j]=1e18;\n\tdp[0][n+1]=0;\n\tll ans=1e18;\n\trep(i,0,n){\n\t\tif(i)\n\t\t\t--c[pos[i]],++c[i];\n\t\trep(j,1,n+2)\n\t\t\tb[j]=b[j-1]+c[j],s[j]=0;\n\t\t_rep(j,n+1,i+2){\n\t\t\tif(j!=n+1)ins(pos[j]);\n\t\t\t\t//printf(\"%d %d %d\\n\",i,j-1,pos[j-1]+b[pos[j-1]]+query(pos[j-1]));\n\t\t\t\tif(pos[j-1]+b[pos[j-1]]+query(pos[j-1])==j-1)\n\t\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\t\telse\n\t\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]+A);\n\t\t\t\n\t\t\t\tif(pos[i+1]+b[pos[i+1]]+query(pos[i+1])==i+1)\n\t\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\t\telse\n\t\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+B);\n\t\t\t\n\t\t}\n\t}\n\t//rep(i,0,n)\n\t//\trep(j,i+1,n)\n\t//\t\tprintf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\trep(i,0,n)\n\t\tans=min(ans,dp[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\n\n\nint main() {\n  int n;\n  cin >> n;\n  ll a, b;\n  cin >> a >> b;\n  vi p(n);\n  vi i2x(n);\n  rep (i, n) {\n    cin >> p[i];\n    i2x[p[i] - 1] = i;\n    p[i] = 2 * p[i];\n  }\n \n  vll dp(n + 1, vl(2 * n + 2, INF));\n  rep (i, 2 * n + 2) dp[0][i] = 0;\n  rep (i, n) {\n    int x = i2x[i];\n    x = (x + 1) * 2;\n    //DEBUG(x);\n    rep (j, 2*n + 2) {\n      if (dp[i][j] == INF) continue;\n      if (j < x) {\n        chmin(dp[i + 1][x], dp[i][j]);\n        if (j % 2 == 1) {\n          chmin(dp[i + 1][j], dp[i][j] + b);\n        }\n        else {\n          chmin(dp[i + 1][j + 1], dp[i][j] + b);\n        }\n      }\n      else {\n        if (j % 2 == 1) {\n          chmin(dp[i + 1][j], dp[i][j] + a);\n        }\n        else {\n          chmin(dp[i + 1][j + 1], dp[i][j] + a);\n        }\n      }\n    }\n  }\n\n  \n  //DEBUG_MAT(dp);\n  ll ans = INF;\n  rep (i, 2 * n + 2) {\n    chmin(ans, dp[n][i]);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define int long long\n#define rep(i, a, b) for (register int i=(a); i<=(b); ++i)\n#define per(i, a, b) for (register int i=(a); i>=(b); --i)\nusing namespace std;\ntypedef long long ll;\ninline void chkmax(int &x, int y){x<y?(x=y):0;}\ninline void chkmin(int &x, int y){x>y?(x=y):0;}\nconst int N=5005;\nint dp[N][N], a[N];\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*f;\n}\n\nsigned main()\n{\n    int n=read(), A=read(), B=read(), ans=1ll<<60;\n    rep(i, 1, n) a[i]=read();\n    memset(dp, 0x3f, sizeof(dp)); dp[0][0]=0;\n    rep(i, 1, n) rep(j, 0, n)\n        if (a[i]>j) \n            chkmin(dp[i][j], dp[i-1][j]+A), \n            chkmin(dp[i][a[i]], dp[i-1][j]);\n        else\n            chkmin(dp[i][j], dp[i-1][j]+B);\n    rep(i, 0, n) chkmin(ans, dp[n][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nusing pi = pair< int, int >;\n\nint main() {\n  int N, A, B;\n  cin >> N >> A >> B;\n  vector< int > V(N);\n  cin >> V;\n\n  vector< int > rev(N);\n  for(int i = 0; i < N; i++) rev[--V[i]] = i;\n\n  auto dp = make_v< int64 >(N + 1, N + 1);\n  fill_v(dp, -1);\n  function< int64(int, int) > rec = [&](int idx, int pos) {\n    pos = min(pos, N);\n    if(idx == N) return 0LL;\n    if(~dp[idx][pos]) return dp[idx][pos];\n    int64 ret = infll;\n    chmin(ret, rec(idx + 1, pos) + B);\n    if(rev[idx] < pos) chmin(ret, rec(idx + 1, pos));\n    else chmin(ret, rec(idx + 1, (idx - pos) + rev[idx] + 1) + 1LL * (rev[idx] - pos) * A);\n    return dp[idx][pos] = ret;\n  };\n  cout << rec(0, 0) << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 5e3 + 10;\ntypedef long long ll;\n\nll a , b , f[N];\nint n , p[N];\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&a,&b);\n\tfor (int i = 1;i <= n;i++){\n\t\tscanf(\"%d\",p + i);\n\t}\n\tp[n + 1] = n + 1;\n\tmemset(f , 0x3f , sizeof f);\n\tf[0] = 0;\n\t\n\tfor (int i = 1;i <= n + 1;i++){\n\t\tint g = 0;\n\t\tfor (int j = i - 1;j >= 0;j--){\n\t\t\tif (p[j] > p[i]){\n\t\t\t\tg++;\n\t\t\t}else{\n\t\t\t\tf[i] = min(f[i] , f[j] + 1ll * g * a + 1ll * (i - j - 1 - g) * b);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n + 1];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1ll << 60;\n\nint n, A, B, p[5005], q[5005], cnt[5005][5005];\nll f[5005];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", p + i), q[p[i]] = i;\n\tcnt[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcopy(cnt[i - 1], cnt[i - 1] + 1 + n, cnt[i]);\n\t\t++cnt[i][q[i]];\n\t}\n\tfor (int i = 0; i <= n; ++i)\n\t\tpartial_sum(cnt[i], cnt[i] + 1 + n, cnt[i]);\n\tp[n + 1] = n + 1;\n\tfor (int i = 1; i <= n + 1; ++i) {\n\t\tf[i] = inf;\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tif (p[j] < p[i])\n\t\t\t\tf[i] = min(f[i], f[j] + 1ll * (j == 0 ? 0 : cnt[p[i] - 1][j - 1] - cnt[p[j]][j - 1]) * A + 1ll * ((cnt[p[i] - 1][n] - cnt[p[i] - 1][j]) - (cnt[p[j]][n] - cnt[p[j]][j])) * B);\n\t}\n\tprintf(\"%lld\\n\", f[n + 1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=5005;\nlong long dp[N][N],ans=100000000000000;\nint a[N],x,A,B,n; \nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\ta[x]=i;\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\tfor (int i=0;i<=n;i++) dp[0][i]=0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<i;j++){\n\t\t\tif (a[i]<a[j])\n\t\t\t\tdp[i][a[j]]=std::min(dp[i][a[j]],dp[i-1][a[j]]+A);\n\t\t\telse dp[i][a[j]]=std::min(dp[i][a[j]],dp[i-1][a[j]]+B),\n\t\t\tdp[i][a[i]]=std::min(dp[i][a[i]],dp[i-1][a[j]]);\n\t\t\t\n\t\t}\n\tfor (int i=1;i<=n;i++) ans=std::min(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans); \n} "
  },
  {
    "language": "C++",
    "code": "/// Be Kind :)\n#include <bits/stdc++.h>\nusing namespace std;\n \n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"Os\")\n\n/*\t\t\t\tI take you to the candy shop\t\t\t\t\t\t\t\t*/\n\n/*\t\t\t\tOoooh ooh, it's me, myself and I\n\t\t\t\tSolo ride until I die, cause I got me for life\t\t\t\t*/\n\n/*\t\t\t\tSo I ball So hard, muh'fuckas wanna find me\t\t\t\t\t*/\n \n/*\t\t\t\tBitch, where you when I was walkin'?\n\t\t\t\tNow I run the game, got the whole world talkin'\t\t\t\t*/\n \n/*\t\t\t\tNiggas been counting me out\n\t\t\t\tI'm counting my bullets, I'm loading my clips\n\t\t\t\tI'm writing down names, I'm making a list\t\t\t\t\t*/\n \n/*\t\t\t\tYou never liked us anyway, fuck your friendship, I meant it */\n \n/*\t\t\t\tThe Chanel or Balenciaga, Louis and Vuitton\n\t\t\t\tShe know I got Fendi, Prada when I hit Milan\t\t\t\t*/\n \n/*\t\t\t\tI ran away, I don't think I'm coming back home\t\t\t\t*/\n \n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n \n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst ll maxn=5e3+10, maxm=1e5+10, lg=17, mod=1e9+7, inf=1e18;\n\nll n,a,b,p[maxn],we[maxn],dp[maxn][maxn],ps[maxn][maxn];\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n>>a>>b;\n\tfor(int i=1;i<=n;i++) cin>>p[i], we[p[i]]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(j==we[i]) dp[i][j]=ps[i-1][j-1];\n\t\t\telse dp[i][j]=ps[i-1][j]+(j<we[i] ? b:a);\n\t\t\tps[i][j]=dp[i][j];\n\t\t\tif(j) ps[i][j]=min(ps[i][j],ps[i][j-1]);\n\t\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<ps[n][n];\n\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __cplusplus\n    cat << EOF\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define rep_0(i, end) for(int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for(int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg0, arg1, arg2, name, ...) name\n#define all(box) box.begin(), box.end()\n\ntemplate <class T, class U> inline bool chmax(T& lhs, const U& rhs) { if(lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T, class U> inline bool chmin(T& lhs, const U& rhs) { if(lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\ntypedef long long lint;\nconstexpr lint inf = (1ll << 60);\n\nint N, X, Y;\nint A[5000];\nlint dp[5001][5001];\n\nint main() {\n\n    cin >> N >> X >> Y;\n    rep(i, N) cin >> A[i];\n\n    rep(i, 1, N) rep(j, 0, N) dp[i][j] = inf;\n\n    rep(i, N) {\n        rep(j, 0, N) {\n            if(j < A[i]) {\n                chmin(dp[i + 1][j], dp[i][j] + X);\n                chmin(dp[i + 1][A[i]], dp[i][j]);\n            }\n            if(j > A[i]) {\n                chmin(dp[i + 1][j], dp[i][j] + Y);\n            }\n        }\n    }\n\n    lint ans = inf;\n    rep(i, 0, N) chmin(ans, dp[N][i]);\n    cout << ans << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": " /*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n\nusing namespace std;\ntemplate<typename T1, typename T2> inline void chkmin(T1 &a, T2 b) {if (a > b) a = b;}\ntemplate<typename T1, typename T2> inline void chkmax(T1 &a, T2 b) {if (a < b) a = b;}\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define all(c) (c).begin(), (c).end()\n#define sz(c) (int)(c).size()\n#define left left228\n#define right right228\n#define y1 y1228\n#define mp update_pair\n#define pb push_back\n#define y2 y2228\nconst string FILENAME = \"input\";\nconst int MAXN = 5005;\n\n\nint n, a, b;\nint p[MAXN];\nlong long dp[MAXN][MAXN];\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n  \t//read(FILENAME);\n\tcin >> n >> a >> b;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 0; i <= n + 1; i++) {\n\t\tfor (int j = 0; j <= n + 1; j++) {\n\t\t\tdp[i][j] = 1e18;\n\t\t}\t\n\t}\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n            if (p[i] < j) {\n                chkmin(dp[i + 1][j], dp[i][j] + a);\n            } else {\n               \tchkmin(dp[i + 1][p[i]], dp[i][j]);\n                chkmin(dp[i + 1][j], dp[i][j] + b);\n            }\n\t\t}\n\t}\n\tlong long ans = 1e18;\n\tfor (int i = 0; i <= n; i++) {\n\t\tchkmin(ans, dp[n][i]);\n\t}\n\tcout << ans << '\\n';\n\treturn 0; \t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define int long long\nint hmt() {int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';if(n) x=-x;return x;}\n#define in hmt()\n#define ins ({string x;char c=getchar();for(;c==' '||c=='\\n';c=getchar());for(;c!=' '&&c!='\\n';c=getchar()) x+=c;x;})\n#define forinc(i,a,b) for(int i=a,_b=b;i<=_b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forb(i,BS) for(int i=BS._Find_first();i< BS.size();i = BS._Find_next(i))\n#define forv(a,b) for(auto &a:b)\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define all(a) a.begin(),a.end()\n#define reset(f,x) memset(f,x,sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define onbit(x,i) (x|(1<<(i-1)))\n#define offbit(x,i) (x&~(1<<(i-1)))\nconst int N=5010;\nint n,A,B,f[N],a[N];\nmain()\n{\n    n=in,A=in,B=in;\n    forinc(i,1,n) a[i]=in;\n    a[++n]=n;\n    forinc(i,1,n)\n    {\n        f[i]=LLONG_MAX;\n        int res=0;\n        fordec(j,i-1,0)\n        {\n            if(a[j]>a[i]) ++res;\n            else if(f[i]>f[j]+A*res+B*(i-j-1-res)) f[i]=f[j]+A*res+B*(i-j-1-res);\n        }\n    }\n    cout<<f[n]<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';n?-x:x;})\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r){return l+rng()%(r-l+1);}\n#define fasty ios_base::sync_with_stdio(0),cin.tie(0);\n#define forinc(a,b,c) for(int a=b,_c=c;a<=_c;++a)\n#define fordec(a,b,c) for(int a=b,_c=c;a>=_c;--a)\n#define forv(a,b) for(auto&a:b)\n#define fi first\n#define se second\n#define pb push_back\n#define ii pair<int,int>\n#define mt make_tuple\n#define all(a) a.begin(),a.end()\n#define reset(f, x) memset(f, x, sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define on(x,i) (x|(1ll<<(i-1)))\n#define off(x,i) (x&~(1<<(i-1)))\n#define gg exit(0);\n\nconst int N=5010;\n\nint n,a,b;\nint p[N],f[N];\n\nmain(){\n    #define task \"agc032_d\"\n    //freopen(task\".inp\",\"r\",stdin);\n    //freopen(task\".out\",\"w\",stdout);\n\n    n=in,a=in,b=in;\n    forinc(i,1,n) p[i]=in;\n    p[n+1]=n+1, n++;\n    reset(f,127);\n    f[0]=0;\n    forinc(i,1,n){\n        int cntx=0,cnty=0;\n        fordec(j,i-1,0){\n            if(p[j]<p[i]) f[i]=min(f[i],f[j]+cntx*b+cnty*a);\n            if(p[j]<p[i]) cntx++; else cnty++;\n        }\n    }\n    cout<<f[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#define int long long\nusing namespace std;\nconst int N=5e3+2;\nconst int inf=1e18+2;\nint dp[N],ar[N],lef[N],rig[N],pos[N],bit[N];\nvoid upd(int pos){\n\twhile(pos<N){\n\t\tbit[pos]++;\n\t\tpos+=(pos&-pos);\n\t}\n}\nint get(int idx){\n\tint sum=0;\n\twhile(idx){\n\t\tsum+=bit[idx];\n\t\tidx-=(idx&-idx);\n\t}\n\treturn sum;\n}\nint getsum(int l,int r){\n\treturn get(r)-get(l-1);\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,a,b,ans=inf,idxans;\n\tcin>>n>>a>>b;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t\tpos[ar[i]]=i;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<i;j++){\n\t\t\tif(ar[j]>ar[i]){\n\t\t\t\tlef[ar[i]]++;\n\t\t\t}\n\t\t}\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tif(ar[j]>ar[i]){\n\t\t\t\trig[ar[i]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tdp[i]=(i-1)*b;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tbit[j]=0;\n\t\t}\n\t\tfor(j=i-1;j>=1;j--){\n\t\t\tif(pos[j]<pos[i]&&getsum(pos[j],pos[i])==0){\n//\t\t\t\tif(dp[j]+getsum(1,pos[j]-1)*a+getsum(pos[i]+1,n)*b<dp[i]){\n//\t\t\t\t\ttrace[i]=j;\n//\t\t\t\t}\n\t\t\t\tdp[i]=min(dp[i],dp[j]+getsum(1,pos[j]-1)*a+getsum(pos[i]+1,n)*b);\n\t\t\t}\n\t\t\tupd(pos[j]);\n\t\t}\n\t\tif(rig[i]==0){\n//\t\t\tif(dp[i]+lef[i]*a<ans){\n//\t\t\t\tidxans=i;\n//\t\t\t}\n\t\t\tans=min(ans,dp[i]+lef[i]*a);\n\t\t}\n\t\t//cout<<dp[i]+lef[i]*a<<' '<<dp[i]<<' '<<i<<' '<<rig[i]<<endl;\n\t}\n//\twhile(idxans){\n//\t\tcout<<idxans<<' ';\n//\t\tidxans=trace[idxans];\n//\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<ctime>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include <cstdio>\n#include <string>\n#include <unordered_map>\nusing namespace std;\nconst int N = 5001;\nint n, A, B;\nint a[N];\nlong long f[N][N + 1];\nint main(){\n    scanf(\"%d %lld %lld\", &n, &A, &B);\n    for (int i = 1; i <= n ;  i ++) {\n        int x;\n        scanf(\"%d\", &x);\n        a[x] = i;\n    }\n    for (int i = 1; i <= n ; i ++)\n        for (int j  = 0; j <= n + 1; j ++)\n            f[i][j] = 1e18;\n    for (int i = 0; i < n ; i ++) {\n        for (int j = 0; j <= n ; j ++)\n            f[i][j + 1] = min(f[i][j + 1], f[i][j]);\n        for (int j = 0; j <= n + 1; j++) {\n            if (j == a[i + 1])\n                f[i + 1][j]= min(f[i][j], f[i + 1][j]);\n            else\n                if (a[i + 1] > j)\n                    f[i + 1][j]= min(f[i][j] + B, f[i + 1][j]);\n                else    f[i + 1][j]= min(f[i][j] + A, f[i + 1][j]);\n\n        }\n    }\n    long long ans =1e18;\n    for (int i = 0; i <= n + 1; i ++)\n        ans = min(ans, f[n][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,a,b;cin>>n>>a>>b;\n  vector<ll>p(n);\n  rep(i,0,n){\n    cin>>p[i];p[i]--;\n  }\n  vector<ll>idx(n);\n  rep(i,0,n)idx[p[i]]=i;\n  auto dp=vec(n+1,n+1,INF);\n  //dp[i][j]小さい方からi個目まで見て左からj個目まで右に移動を選択\n  dp[0][0]=0;\n  vector<ll>s(n,1);\n  rep(i,0,n){\n    s[idx[i]]=0;\n    vector<ll>t(n+1);\n    rep(j,0,n)t[j+1]=t[j]+s[j];\n    rep(j,0,n+1){\n      if(dp[i][j]==INF)continue;\n      if(idx[i]<=j)chmin(dp[i+1][j],dp[i][j]);\n      else{\n        chmin(dp[i+1][j],dp[i][j]+b);\n        chmin(dp[i+1][idx[i]+1],dp[i][j]+a*(t[idx[i]+1]-t[j]));\n      }\n    }\n  }\n  //debug(dp,n+1,n+1);\n  cout<<*min_element(ALL(dp[n]))<<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nint dp[5003][5003] , arr[5003] , A , B , N;\nvoid chkmin(int &a , int b){a = a < b ? a : b;}\n\nsigned main(){\n\tcin >> N >> A >> B;\n\tfor(int i = 1 ; i <= N ; ++i) cin >> arr[i];\n\tmemset(dp , 0x3f , sizeof(dp)); dp[0][0] = 0;\n\tfor(int i = 0 ; i < N ; ++i)\n\t\tfor(int j = 0 ; j <= N ; ++j)\n\t\t\tif(j < arr[i + 1]){\n\t\t\t\tchkmin(dp[i + 1][arr[i + 1]] , dp[i][j]);\n\t\t\t\tchkmin(dp[i + 1][j] , dp[i][j] + A);\n\t\t\t}\n\t\t\telse chkmin(dp[i + 1][j] , dp[i][j] + B);\n\tint mn = 1e18; for(int i = 1 ; i <= N ; ++i) mn = min(mn , dp[N][i]);\n\tcout << mn; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 200000;\nint a[N], A, B, p[N];\nint used[5002][5002];\nlong long dp[5002][5002];\nint f[5002][5002];\nlong long solve(int l, int r) {\n    if (used[l][r]) {\n        return dp[l][r];\n    }\n    if (l == r) {\n        return 0;\n    }\n    used[l][r] = 1;\n    dp[l][r] = 1e18;\n    int i = p[l];\n    int cnt = f[i][r] - f[i][l - 1];\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r) + B);\n    }\n    i = p[r];\n    cnt = f[n][r] - f[i - 1][l - 1];\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1) + A);\n    }\n    return dp[l][r];\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        p[a[i]] = i;\n    }\n    for (int j = 1; j <= n; j++) {\n        for (int i = 1; i <= n; i++) {\n            f[i][j] = f[i - 1][j];\n            if (a[i] <= j) {\n                f[i][j]++;\n            }\n        }\n    }\n    cout << solve(1, n) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//constexpr long long MOD = 1000000007;\nconstexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nll dp[5050][5050];\npii mael[5050][5050],maer[5050][5050];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll N,A,B; cin >> N >> A >> B;\n    vector<int> p(N);\n    rep(i,N) {\n        cin >> p[i];\n        --p[i];\n    }\n\n    rep(i,N) {\n        int l = p[i];\n        int r = 0;\n        int cnt = 1;\n        rep(j,i) {\n            if (p[j] > p[i]) {\n                mael[p[i]][N-1-p[j]].second = 1;\n            }\n        }\n        for (int j = i+1; j < N; j++) {\n            if (p[j] < p[i]) continue;\n            if (p[j] > l+1) {\n                for (int k = r; k < N-p[j]; k++) {\n                    mael[p[i]][k].first = cnt;\n                }\n                chmax(r,N-p[j]);\n            } else {\n                l++;\n                cnt++;\n            }\n        }\n        for (int k = r; k < N-l; k++) {\n            mael[p[i]][k].first = cnt;\n        }\n        for (int j = N-1; j > 0; j--) {\n            mael[p[i]][j-1].second += mael[p[i]][j].second;\n        }\n    }\n\n    for (int i = N-1; i >= 0; i--) {\n        int r = p[i];\n        int l = 0;\n        int cnt = 1;\n        for (int j = N-1; j > i; j--) {\n            if (p[j] < p[i]) {\n                maer[p[j]][N-1-p[i]].second = 1;\n            }\n        }\n        for (int j = i-1; j >= 0; j--) {\n            if (p[j] > p[i]) continue;\n            if (p[j] < r-1) {\n                for (int k = l; k <= p[j]; k++) {\n                    maer[k][N-1-p[i]].first = cnt;\n                }\n                chmax(l,p[j]+1);\n            } else {\n                r--;\n                cnt++;\n            }\n            for (int k = l; k < p[i]; k++) {\n                maer[k][N-1-p[i]].first = cnt;\n            }\n        }\n\n        for (int j = N-1; j > 0; j--) {\n            maer[j-1][N-1-p[i]].second += maer[j][N-1-p[i]].second;\n        }\n\n    }\n\n    rep(i,N+1) rep(j,N+1) dp[i][j] = 1e18;\n    dp[0][0] = 0;\n    rep(k,N) {\n        for (int l = 0; l <= k; l++) {\n            if (dp[l][k-l]==1e18) continue;\n            auto [dl,cl] = mael[l][k-l];\n            chmin(dp[l+dl][k-l],dp[l][k-l]+A*cl);\n            chmin(dp[l+1][k-l],dp[l][k-l]+B);\n            auto[dr,cr] = maer[l][k-l];\n            chmin(dp[l][k-l+dr],dp[l][k-l]+B*cr);\n            chmin(dp[l][k-l+1],dp[l][k-l]+A);\n        }\n    }\n\n    ll ans = 1e18;\n    rep(i,N+1) {\n        chmin(ans,dp[i][N-i]);\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 5005;\ntypedef long long LL;\n\nint n, pre[N][N], a[N], pre_cnt[N][N], inv[N], occ[N];\nLL dp[N][N];\nLL A, B, inf = 1e18;\n\nLL solve(int pos, int kth) {\n    if(pos > n) return 0;\n    if(kth > (n-pos+1)) return 0;\n    if(dp[pos][kth] != -1) return dp[pos][kth];\n    int kth_pos = pre[pos][kth];\n    int kth_inv = pre_cnt[pos][kth];\n    int back_small = (kth_pos-pos) - kth_inv;\n//    cout << \"back_small: \" << back_small << endl;\n    int kth_jump = (kth-back_small);\n    LL ans1 = solve(kth_pos+1, kth_jump) + A*kth_inv;\n    LL ans2 = solve(pos, kth+1) + B;\n//    cout << \"pos: \" << pos << \"   kth: \" << kth << \" ---> \" << min(ans1, ans2) << endl;\n    return dp[pos][kth] = min(ans1, ans2);\n}\n\nint main() {\n    // freopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> A >> B;\n    for(int i = 1; i <= n; i++) cin >> a[i];\n    for(int i = n; i >= 1; i--) {\n        occ[a[i]] = i;\n        for(int j = 1; j <= n; j++) {\n            if(occ[j] && j < a[i]) inv[j]++;\n        }\n        int kth = 0;\n        for(int j = 1; j <= n; j++) {\n            if(occ[j]) {\n                ++kth;\n                pre[i][kth] = occ[j];\n                pre_cnt[i][kth] = inv[j];\n            }\n        }\n    }\n//    for(int i = 1; i <= n; i++) {\n//        for(int j = 1; j <= n; j++) {\n//            cout << pre_cnt[i][j] << \" \";\n//        }\n//        cout << endl;\n//    }\n    memset(dp, -1, sizeof dp);\n    cout << solve(1,1) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconst ll INF = 1e18;\n\nconst int MAXN = 5010;\nint N;\nll A, B;\nint P[MAXN];\nll dp[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> P[i];\n\t}\n\tP[0] = 0;\n\tP[N+1] = N+1;\n\n\tdp[0] = 0;\n\tfor (int i = 1; i <= N+1; i++) {\n\t\tdp[i] = INF;\n\t\tint numBigger = 0;\n\t\tfor (int j = i-1; j >= 0; j--) {\n\t\t\tif (P[j] < P[i]) {\n\t\t\t\tdp[i] = min(dp[i], dp[j] + numBigger * A + (i-j-1-numBigger) * B);\n\t\t\t} else {\n\t\t\t\tnumBigger++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N+1] << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\nconst int maxn=5005;\nint n,a,b;\nll dp[maxn];\nint main(){\n    ios::sync_with_stdio(0);\n    memset(dp,0x3f,sizeof(dp));dp[0]=0;\n    cin>>n>>a>>b;\n    rep(i,1,n){\n        int num;cin>>num;\n        ll mi=1e18;\n        rep(j,0,num)mi=min(mi,dp[j]);\n        rep(j,0,num)dp[j]+=a;\n        rep(j,num+1,n)dp[j]+=b;\n        dp[num]=min(dp[num],mi);\n    }\n    ll ans=1e18;\n    rep(i,1,n)ans=min(ans,dp[i]);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nshiftÊµÖÊÉÏÊÇ°ÑÒ»¸öÔªËØÍùÇ°ÒÆ»òÕßÍùºóÒÆ\n¿¼ÂÇÈç¹ûÈ·¶¨Ò»Ð©ÔªËØ²»¶¯µÄ»°£¨ÏÔÈ»ËüÃÇµÄÏÂ±êºÍÖµ¶¼µ¥Ôö£©£¬ÄÇÃ´¶ÔÓÚÏàÁÚÁ½¸öÈ·¶¨²»¶¯µÄÏÂ±êaºÍbÖ®¼äµÄÏÂ±êx(a < x < b)£¬»áÓÐÈçÏÂÊÂ£º\n(1)P[x] < P[a]£¬ÄÇÃ´ÐèÒª°ÑP[x]ÍùÇ°ÒÆ\n(2)P[b] < P[x]£¬ÄÇÃ´ÐèÒª°ÑP[x]ÍùºóÒÆ\n(3)Ê£ÏÂµÄËùÓÐP[a] < P[x] < P[b]µÄÔªËØ£¬¿ÉÒÔÈ«ÓÃmin(A, B)µÄ´ú¼ÛÅÅºÃÐò\nÖ±½Ódp¼´¿É \n*/\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_N(5050);\ntypedef long long int LL;\n\nint N, P[Max_N], Pre[Max_N][Max_N], Suf[Max_N][Max_N];\nLL F[Max_N][Max_N], A, B;\n\ninline void upd(LL &a, LL b)\n{\n\ta = min(a, b);\n}\n\nint main()\n{\n\tscanf(\"%d%lld%lld\", &N, &A, &B);\n\tfor (int i = 1;i <= N;++i)\n\t\tscanf(\"%d\", P + i), Pre[i][P[i]] = Suf[i][P[i]] = 1;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tfor (int j = 1;j <= N + 1;++j)\n\t\t\tPre[i][j] += Pre[i][j - 1];\n\t\tfor (int j = N;j >= 0;--j)\n\t\t\tSuf[i][j] += Suf[i][j + 1];\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tPre[i][j] += Pre[i - 1][j], Suf[i][j] += Suf[i - 1][j];\n\t}\n\tmemset(F, 0X3F, sizeof(F)), F[0][0] = 0LL;\n\tP[0] = 0, P[N + 1] = N + 1;\n\tfor (int i = 1;i <= N + 1;++i)\n\t\tfor (int j = 0, t;j <= i - 1;++j)\n\t\t{\n\t\t\tupd(F[i][j], F[i - 1][j]);\n\t\t\tif (P[j] < P[i])\n\t\t\t{\n\t\t\t\tt = (i - 1) - j;\n\t\t\t\tt -= (Pre[i - 1][P[j]] - Pre[j][P[j]]) + (Suf[i - 1][P[i]] - Suf[j][P[i]]);\n\t\t\t\tupd(F[i][i], F[i - 1][j] + (Pre[i - 1][P[j]] - Pre[j][P[j]]) * B + (Suf[i - 1][P[i]] - Suf[j][P[i]]) * A + t * min(A, B));\n\t\t\t}\n\t\t}\n\tprintf(\"%lld\", F[N + 1][N + 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nll f[5010][5010],n,A,B,p[5010];\nint main(){\n\tread(n);read(A);read(B);\n\tfor(int i=1;i<=n;i++) read(p[i]);\n\tmemset(f,63,sizeof(f));\n\tfor(int i=1;i<=n;i++){\n\t\tf[i][p[i]]=(i-1)*A;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tf[i][j]=min(f[i][j],f[i-1][j]+(p[i]>j?A:B));\n\t\t\tif(j<p[i]) f[i][p[i]]=min(f[i][p[i]],f[i-1][j]);\n\t\t}\n\t}\n\tll ans=1e18;\n\tfor(int i=1;i<=n;i++) ans=min(ans,f[n][i]);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define MP make_pair\n#define PB push_back\nusing namespace std;\nnamespace io{\n\tconst int Sz=1<<13;\n\tchar ibuf[Sz],*ips=ibuf+Sz-1;\n\tinline int getchar(){\n\t\tif(++ips==ibuf+Sz)fread(ips=ibuf,1,Sz,stdin);\n\t\treturn *ips;\n\t}\n\tchar obuf[Sz],*ops=obuf;\n\tinline void flush(){\n\t\tfwrite(obuf,1,ops-obuf,stdout);\n\t\tops=obuf;fflush(stdout);\n\t}\n\tinline void putchar(int c){\n\t\tif(ops==obuf+Sz)flush();\n\t\t*ops=c,ops++;\n\t}\n\tvoid gets(char *s){\n\t\tint c=getchar();\n\t\twhile(c<=32)c=getchar();\n\t\twhile(c>32)*s=c,++s,c=getchar();\n\t\t*s=0;\n\t}\n\tvoid puts(const char *s){\n\t\twhile(*s)putchar(*s),++s;\n\t}\n}\n#define getchar io::getchar\n#define putchar io::putchar\n#define gets io::gets\n#define puts io::puts\nint read(){\n\tint x=0,f=1,c=getchar();\n\tfor(;c<48||c>57;c=getchar())\n\t\tif(c=='-')f=-f;\n\tfor(;c>=48&&c<=57;c=getchar())\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tint stk[20],tp=0;\n\tif(!x)putchar(48);\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)stk[tp++]=(x-x/10*10)^48;\n\tfor(;tp;)putchar(stk[--tp]);\n}\nstruct Flusher{~Flusher(){io::flush();}}flusher;\n// ------------------------- Template End ------------------------- //\nconst int N=5005;\nint n,A,B;\nint p[N],ps[N];\nll dp[N][N],mndp[N][N];\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nvoid chkmin(ll &x,ll y){if(y<x)x=y;}\nint main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=0;i<n;++i)p[i]=read(),ps[p[i]]=i;\n\tmemset(dp,0x3f,sizeof dp);dp[0][0]=0;\n\tmemset(mndp,0x3f,sizeof mndp);\n\tfor(int i=0;i<=n;++i)mndp[0][i]=0;\n\tfor(int i=1;i<=n;++i)for(int j=0;j<=n;++j){\n\t\tchkmin(dp[i][j],mndp[i-1][j]+(ps[i]==j?0:(ps[i]<j?A:B)));\n\t\tif(j)mndp[i][j]=mndp[i][j-1];chkmin(mndp[i][j],dp[i][j]);\n\t}\n\twrite(mndp[n][n]);putchar('\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MAXN =5e3+5;\nlong long dp[MAXN][MAXN];\nlong long pos[MAXN];\nlong long p[MAXN];\nlong long mindp[MAXN];\nint main(){\n    long long n,a,b;\n    cin>>n>>a>>b;\n    for(long long i=1;i<=n;i++){\n        cin>>p[i];\n        pos[p[i]] = i;\n    }\n    for(long long i=0;i<=n;i++){\n        for(long long j=0;j<=n;j++){\n            dp[i][j] = 1e18;\n        }\n    }\n    dp[0][0] = 0; \n    for(long long i=1;i<=n;i++){\n        for(long long j=0;j<=n;j++){\n           \n            if(j==pos[i]){\n                dp[i][j] = dp[i-1][j-1];\n                continue;\n            }\n            long long cost;\n            if(pos[i]<j){\n                cost = a;\n            }else{\n                cost = b;\n            }\n            if(j){\n                dp[i][j] = min(dp[i][j],dp[i][j-1]);\n               \n            }\n             dp[i][j] = min(dp[i][j],dp[i-1][j]+(cost));\n           // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n        }\n    }\n    cout<<dp[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 5050;\nconst Int INF = 1e17;\nInt dp[MAX][MAX];\nInt dp2[MAX][MAX];\nInt dp3[MAX][MAX];\n\nInt p[MAX];\nInt cnt1[MAX],cnt2[MAX];\n\nsigned main(){\n  Int n,a,b;\n  cin>>n>>a>>b;\n  for(Int i=0;i<n;i++) cin>>p[i];\n  \n  for(Int i=0;i<MAX;i++){\n    for(Int j=0;j<MAX;j++){\n      dp[i][j]=INF;\n      dp2[i][j]=0;\n      dp3[i][j]=0;\n    }\n  }\n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=0;i<n;i++){\n      for(Int j=p[i];j<=n+1;j++)\n        dp2[p[i]-1][j]=i-(cnt1[p[i]]+cnt2[j]);\n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=n-1;i>=0;i--){\n      for(Int j=0;j<=p[i];j++)\n        dp3[j][p[i]+1]=(n-(i+1))-(cnt2[p[i]]+cnt1[j]);\n      \n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  \n  dp[0][n+1]=0;\n  for(Int w=n+1;w>0;w--){\n    for(Int i=0;i+w<=n+1;i++){      \n      Int j=i+w;\n      if(dp[i][j]>=INF) continue;\n      //cout<<i<<\" \"<<j<<\":\"<<dp2[i][j]<<\" \"<<dp3[i][j]<<endl;\n      chmin(dp[i+1][j],dp[i][j]+(dp2[i][j]==0?0:b));\n      chmin(dp[i][j-1],dp[i][j]+(dp3[i][j]==0?0:a));\n    }\n  }\n  \n  Int ans=INF;\n  for(Int i=0;i<n;i++) chmin(ans,dp[i][i+1]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std; typedef long long ll;\n\nint main() {\n  ll n, a, b; cin >> n >> a >> b; int p[n], p0[n]; ll res=0;\n  if (n==1) return 0e0 * puts(\"0\");\n  for(int i=0; i<n; i++) cin >> p[i];\n  \n  for(int i=0; i<n; i++) {\n    if (p[i] == i+1) continue;\n    for(int j=i; j<n; j++) {\n      ll y = n - i;\n      if (p[j] == i+1) {\n        ll s = j-i;\n        if (j-i != 1) {\n          //res += min((j+1-s)*a, s*b);\n          //cout << (j+1-s)*a << \" \" << s*b << \" \" << s << endl;\n          //cout << res << \" \" << i << \" \" << s*a << \" \" << (j-i+1-s)*b << \" \" << s << endl;\n          res += min(s*a, (j-i+1-s)*b);\n          int tmp = p[j];\n          for(int k=j-1; k>=i; k--) {\n            p[k+1] = p[k];\n          } p[i] = tmp;\n        } else {\n          int ln = 0, m=i; \n          while(p[m+1] == m+1 && m != n-1) {\n            ln++; swap(p[m], p[m+1]); m++;\n          }\n          //cout << ln << \"@ \";\n          res += min(a, b*ln);\n        }\n        \n        break;\n      }\n    }\n    /*cout << res << \"_\";\n    for(int x:p) {\n      cout << x << \" \";\n    } cout << endl;*/\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\n#define MOD 1000000007LL\n#define endl \"\\n\"\n#define fst first\n#define snd second\nconst ll UNDEF = -1;\nconst ll INF=LLONG_MAX/4;\ntemplate<typename T> inline bool chkmax(T &aa, T bb) { return aa < bb ? aa = bb, true : false; }\ntemplate<typename T> inline bool chkmin(T &aa, T bb) { return aa > bb ? aa = bb, true : false; }\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\nint Rjump,Ljump;\nconst int mn=5004;\nint a[mn];\n// f(p,b) is the minimum cost such that:\n// Position [1,p] with value within [1,b] are sorted\n// Position [1,p] with value within [b+1,n] have jumped right\n// f(p,b) = min f(p-1,[0,b]) + Ljump if a[p]<b + Rjump if a[p]>b\nll f[mn][mn],g[mn][mn];\nint main(){\t\n\tios::sync_with_stdio(false);\n\tfor (int x=0;x<mn;x++) for (int y=0;y<mn;y++) {\n\t\tf[x][y]=g[x][y]=INF;\n\t}\n\tint n; cin>>n>>Rjump>>Ljump;\n\tfor (int p=1;p<=n;p++) {\n\t\tcin>>a[p];\n\t}\n\tfor (int b=0;b<mn;b++) f[0][b]=g[0][b]=0;\n\tfor (int p=1;p<=n;p++) {\n\t\tfor (int b=1;b<=n;b++) {\n\t\t\tf[p][b]=g[p-1][b]+(a[p]<b?Ljump:0)+(a[p]>b?Rjump:0);\n\t\t}\n\t\tll lof=f[p][1];\n\t\tfor (int b=1;b<=n;b++) {\n\t\t\tchkmin(lof,f[p][b]);\n\t\t\tg[p][b]=lof;\n\t\t}\n\t}\n\tll final=INF; for (int b=1;b<=n;b++) chkmin(final,f[n][b]);\n\tprintf(\"%lld\\n\",final);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 5014;\nint p[SIZE];\nLL dp[SIZE];\nint main(){\n    int N,A,B; R(N,A,B);\n    FOR(i,1,N)R(p[i]);\n    p[N+1]=N+1;\n    FOR(i,1,N+1){\n        dp[i]=1e18;\n        LL now=0;\n        for(int j=i-1;j>0;j--){\n            if(p[j]<p[i]){\n                dp[i]=min(dp[i],dp[j]+now);\n                now+=B;\n            }\n            else now+=A;\n        }\n        dp[i]=min(dp[i],now);\n    }\n    W(dp[N+1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define pb push_back\n#define X first\n#define Y second\n\n#define SZ(a) ((LL)(a).size())\n#define all(a) (a).begin(),a.end()\n#define forn(i, n) for(LL i = 0; i < n; ++i)\n#define ALL(x) x.begin(), x.end()\n#define ll long long\n#define MAXN 100\n#define INF 1000 * 1000 * 1000\n#define LINF INF * (LL)INF;\nint n , m , A , B;\nint a[5005];\nint de[5005];\nLL dpT[5005][5005];\nint inL [5005];\nint inR [5005];\nLL dp(int l , int r , int freeL , int freeR)\n{\n\tif(l == r)\n\t\treturn 0;\n\tif(dpT[l][r] != -1)\n\t\treturn dpT[l][r];\n\tLL ans = LINF;\n\tint newFreeL = freeL;\n\tint newFreeR = freeR;\n\twhile(newFreeL <= n && (a[newFreeL + 1] < l || a[newFreeL + 1] > r))\n\t{\n\t\tnewFreeL++;\n\t}\n\twhile(newFreeR > 0 && (a[newFreeR - 1] > r || a[newFreeR - 1] < l))\n\t{\n\t\tnewFreeR--;\n\t}\n\tLL cost = B , cost2 = A;\n\tif(a[newFreeL + 1] == l)\n\t{\n\t\tcost = 0;\n\t}\n\tif(a[newFreeR - 1] == r)\n\t{\n\t\tcost2 = 0;\n\t}\n\t//cout << l << \" \" << r << \" \" << newFreeL << \" \" << newFreeR << endl;\n\tans = min(ans , cost + dp(l + 1 , r , newFreeL , newFreeR));\n\tans = min(ans , cost2 + dp(l  , r - 1 , newFreeL , newFreeR));\n\treturn dpT[l][r] = ans;\n}\nint main()\n{\n\tmemset(dpT , -1 , sizeof dpT);\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\t\n\tcout << dp(1 , n , 0 , n + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\nll dp[5010][10101];\n\nint main(){\n   int n,a,b; cin>>n>>a>>b;\n   vector<int> p(n); rep(i,0,n)cin>>p[i],p[i]--;\n   vector<int> rev(n); rep(i,0,n)rev[p[i]]=i*2+1;\n   rep(i,0,n+1)rep(j,0,2*n+1)dp[i][j]=INF;\n   rep(j,0,2*n+1)dp[0][j]=0;\n   rep(i,0,n){\n      rep(j,0,2*n+1){\n         int add;\n         if(j==rev[i])add=0;\n         if(j>rev[i])add=a;\n         if(j<rev[i])add=b;\n         chmin(dp[i+1][j],dp[i][j]+add);\n      }\n      rep(j,0,2*n)chmin(dp[i+1][j+1],dp[i+1][j]);\n   }\n   cout<<dp[n][2*n]<<endl;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// KALAM\n# include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5000 + 77;\nint n , X , Y;\nint a[N] , b[N] , F[N];\nlong long dp[N][N];\nint main() {\n   memset(dp , 63 , sizeof(dp));\n   for(int i = 0;i < N;++ i)\n      dp[0][i] = 0;\n   scanf(\"%d\" , & n);\n   scanf(\"%d %d\" , & X , & Y);\n   for(int i = 1;i <= n;++ i)\n      scanf(\"%d\" , a + i);\n   for(int i = 1;i <= n;++ i) {\n      for(int j = i;j <= n;++ j)\n         dp[i][j] = 0;\n      for(int j = 1;j < i;++ j)\n         F[i] += (a[j] > a[i]);\n      b[i] = i;\n      for(int j = i;j > 1;-- j)\n         if(a[b[j]] < a[b[j - 1]])\n            swap(b[j] , b[j - 1]);\n      for(int j = 2;j <= i;++ j) {\n         int t = i - j + 1;\n         int pos = b[i - t + 1];\n         int leftmore = F[pos];\n         int rightmore = t - 1 - F[pos];\n         int rightless = i - pos - rightmore;\n         dp[i][t] = dp[pos - 1][leftmore + 1] + rightless * 1ll * Y;\n         if(rightless == 0)\n            dp[i][t] = min(dp[i][t] , dp[i][t + 1]);\n         else\n            dp[i][t] = min(dp[i][t] , dp[i][t + 1] + X);\n      }\n   }\n\n   printf(\"%lld\\n\" , dp[n][1]);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntypedef unsigned int u32;\ninline int popcount(u32 x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    return ((x + (x >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\n}\n//(k+1)番目の1の立っている位置(最下位から)を返す\n//http://graphics.stanford.edu/~seander/bithacks.html#SelectPosFromMSBRank を参考にした\ninline int select32(u32 x, int k) {\n    u32 a, b, c; int t, s;\n    a = (x & 0x55555555) + ((x >> 1) & 0x55555555);\n    b = (a & 0x33333333) + ((a >> 2) & 0x33333333);\n    c = (b & 0x0f0f0f0f) + ((b >> 4) & 0x0f0f0f0f);\n    t = (c & 0xff) + ((c >> 8) & 0xff);\n    s = 0;\n    s += ((t - k - 1) & 128) >> 3; k -= t & ((t - k - 1) >> 8); //if(k >= t) s += 16, k -= t;\n    t = (c >> s) & 0xf;\n    s += ((t - k - 1) & 128) >> 4; k -= t & ((t - k - 1) >> 8); //if(k >= t) s += 8, k -= t;\n    t = (b >> s) & 0x7;\n    s += ((t - k - 1) & 128) >> 5; k -= t & ((t - k - 1) >> 8); //if(k >= t) s += 4, k -= t;\n    t = (a >> s) & 0x3;\n    s += ((t - k - 1) & 128) >> 6; k -= t & ((t - k - 1) >> 8); //if(k >= t) s += 2, k -= t;\n    t = (x >> s) & 0x1;\n    s += ((t - k - 1) & 128) >> 7; //if(k >= t) s += 1;\n    return s;\n}\n//※静的なデータ構造\n//constructした後setを何回か呼び、その後buildを呼んだ後にrank,selectが行える\nstruct FullyIndexableDictionary {\n    static const int NOTFOUND = -1;\n    static const int SELECTT_INTERVAL = 32; //SELECTT_INTERVAL >= 32\n    int length, blockslength, count;\n    vector<u32> blocks; vector<int> ranktable, selecttable0, selecttable1;\n    FullyIndexableDictionary(int len) : length(len) {\n        blocks.resize((blockslength = (len + 31) / 32) + 1);\n    }\n    inline void set(int i) { blocks[i / 32] |= 1 << i % 32; }\n    void build() {\n        if (length == 0) { count = 0; return; }\n        ranktable.assign(blockslength + 1, 0);\n        selecttable0.clear(); selecttable1.clear();\n        int prev0 = 0, prev1 = 0, count0 = 0, count1 = 0;\n        for (int i = 0; i < blockslength; i++) {\n            ranktable[i] = count1;\n            count1 += popcount(blocks[i]);\n            count0 = 32 * (i + 1) - count1;\n            if (prev1 < (count1 + SELECTT_INTERVAL - 1) / SELECTT_INTERVAL)\n                selecttable1.push_back(i), prev1 = (count1 + SELECTT_INTERVAL - 1) / SELECTT_INTERVAL;\n            if (prev0 < (count0 + SELECTT_INTERVAL - 1) / SELECTT_INTERVAL)\n                selecttable0.push_back(i), prev0 = (count0 + SELECTT_INTERVAL - 1) / SELECTT_INTERVAL;\n        }\n        ranktable[blockslength] = count1;\n        selecttable1.push_back(blockslength - 1);\n        selecttable0.push_back(blockslength - 1);\n        count = count1;\n    }\n    inline bool access(int pos) const {\n        return blocks[pos / 32] >> pos % 32 & 1;\n    }\n    inline int rank(int pos) const {    //[0..pos)の1の個数\n        int block_idx = pos / 32;\n        return ranktable[block_idx] + popcount(blocks[block_idx] & (1U << pos % 32) - 1);\n    }\n    inline int rank(bool b, int pos) const { return b ? rank(pos) : pos - rank(pos); }\n    inline int rank(bool b, int left, int right) const { return rank(b, right) - rank(b, left); }\n    //O(log n)は重いよねえ。expect O(1) (たぶん) ならできるけど最悪ケースがなあ\n    //あるいはメモリ4*32*n bytes でO(1)でもできるけど…ハッシュテーブルでうまくやればうまくできるか？\n    template<bool b>\n    int select(int k) const {   //(k+1)番目のbの位置\n        if ((b ? count : length - count) <= k) return NOTFOUND;\n        int selecttable_index = k / SELECTT_INTERVAL;\n        int l = (b ? selecttable1 : selecttable0)[selecttable_index],\n            u = (b ? selecttable1 : selecttable0)[selecttable_index + 1] + 1;   //ブロックを二分探索\n        while (l + 1 < u) {\n            int m = (l + u) / 2;\n            ((b ? ranktable[m] : m * 32 - ranktable[m]) <= k ? l : u) = m;\n        }\n        return l * 32 + select32(b ? blocks[l] : ~blocks[l], k - (b ? ranktable[l] : 32 * l - ranktable[l]));\n    }\n    inline int select(bool b, int k) const { return b ? select<true>(k) : select<false>(k); }\n    inline int select(bool b, int k, int left) const { return select(b, rank(b, left) + k); }\n};\ninline unsigned int BITMASK(int i) {\n    return (1 << i) - 1;\n}\n//※メモリ, 時間はだいたい支配的な部分のみ書く\n//メモリ: (length * bitsize / 8) bytes\nstruct WaveletMatrix {\n    typedef unsigned long long Val;\n    static const int NOTFOUND = -1;\n    static const Val UNDEFINED = Val(-1);\n    static const int MAX_BITSIZE = 64;\n    int length, bitsize; Val maxval;\n    vector<FullyIndexableDictionary> dicts;\n    vector<int> mids;\n    //追加メモリ: (2 * length * sizeof Val) bytes\n    //時間: bitsize * length * 大きめ\n    void init(const vector<Val>& data) {\n        length = data.size();\n        maxval = *max_element(data.begin(), data.end());\n        if (1ULL << (8 * sizeof(Val) - 1) <= maxval) bitsize = 8 * sizeof(Val);\n        else for (bitsize = 0; Val(1) << bitsize <= maxval; bitsize++);\n        dicts.assign(bitsize, length);\n        mids.assign(bitsize, 0);\n        vector<Val> datacurrent(data), datanext(length);\n        for (int bit = 0; bit < bitsize; bit++) {\n            int pos = 0;\n            for (int i = 0; i < length; i++)\n                if ((datacurrent[i] >> (bitsize - bit - 1) & 1) == 0)\n                    datanext[pos++] = datacurrent[i];\n            mids[bit] = pos;\n            for (int i = 0; i < length; i++)\n                if ((datacurrent[i] >> (bitsize - bit - 1) & 1) != 0)\n                    dicts[bit].set(i), datanext[pos++] = datacurrent[i];\n            dicts[bit].build();\n            datacurrent.swap(datanext);\n        }\n    }\n    Val access(int pos) const {\n        Val val = 0;\n        for (int bit = 0; bit < bitsize; bit++) {\n            bool dir = dicts[bit].access(pos);\n            val = val << 1 | (dir ? 1 : 0);\n            pos = dicts[bit].rank(dir, pos);\n            if (dir) pos += mids[bit];\n        }\n        return val;\n    }\n    int rank(Val val, int left, int right) const {\n        if (val > maxval) return 0;\n        for (int bit = 0; bit < bitsize; bit++) {\n            bool dir = val >> (bitsize - bit - 1) & 1;\n            left = dicts[bit].rank(dir, left), right = dicts[bit].rank(dir, right);\n            if (dir) left += mids[bit], right += mids[bit];\n        }\n        return right - left;\n    }\n    int rank(Val val, int right) const { return rank(val, 0, right); }\n    int rank_all(Val val, int left, int right, int& out_lt, int& out_gt) const {\n        if (val > maxval) { out_lt = right - left; out_gt = 0; return 0; }\n        out_lt = out_gt = 0;\n        for (int bit = 0; bit < bitsize; bit++) {\n            bool dir = val >> (bitsize - bit - 1) & 1;\n            int leftcount = dicts[bit].rank(dir, left), rightcount = dicts[bit].rank(dir, right);\n            (dir ? out_lt : out_gt) += (right - left) - (rightcount - leftcount);\n            left = leftcount, right = rightcount;\n            if (dir) left += mids[bit], right += mids[bit];\n        }\n        return right - left;\n    }\n    inline int rank_lt(Val val, int left, int right) const {\n        int tmp_lt, tmp_gt;\n        rank_all(val, left, right, tmp_lt, tmp_gt);\n        return tmp_lt;\n    }\n    inline int rangefreq(int left, int right, Val bottom, Val up) {\n        return rank_lt(up, left, right) - rank_lt(bottom, left, right);\n    }\n    //O(bitsize log length) (FID::selectがlog nで最悪の場合)\n    int select(Val val, int k) const {\n        if (val > maxval) return NOTFOUND;\n        static int lefts[MAX_BITSIZE], rights[MAX_BITSIZE];\n        int left = 0, right = length;\n        for (int bit = 0; bit < bitsize; bit++) {\n            lefts[bit] = left, rights[bit] = right;\n            bool dir = val >> (bitsize - bit - 1) & 1;\n            left = dicts[bit].rank(dir, left), right = dicts[bit].rank(dir, right);\n            if (dir) left += mids[bit], right += mids[bit];\n        }\n        for (int bit = bitsize - 1; bit >= 0; bit--) {\n            k = dicts[bit].select(val >> (bitsize - bit - 1) & 1, k, lefts[bit]);\n            if (k == FullyIndexableDictionary::NOTFOUND || k >= rights[bit])\n                return NOTFOUND;\n            k -= lefts[bit];\n        }\n        return k;\n    }\n    int select(Val val, int k, int left) const { return select(val, k + rank(val, left)); }\n    void quantile(int left, int right, int k, Val& out_val, int& out_k) const {\n        if (right - left <= k) { out_val = UNDEFINED; out_k = NOTFOUND; return; }\n        Val val = 0;\n        for (int bit = 0; bit < bitsize; bit++) {\n            int count = dicts[bit].rank(true, left, right);\n            bool dir = k < count;\n            val = val << 1 | (dir ? 1 : 0);\n            if (!dir) k -= count;\n            left = dicts[bit].rank(dir, left), right = dicts[bit].rank(dir, right);\n            if (dir) left += mids[bit], right += mids[bit];\n        }\n        out_val = val; out_k = k;\n    }\n    struct IdxVal {\n        int idx; Val val;\n        IdxVal() {}\n        IdxVal(int i, Val v) : idx(i), val(v) {}\n    };\n    inline Val quantile(int left, int right, int k) const {\n        Val tmp_val; int tmp_k;\n        quantile(left, right, k, tmp_val, tmp_k);\n        return tmp_val;\n    }\n    inline IdxVal quantile_idxval(int left, int right, int k) const {\n        Val tmp_val; int tmp_k;\n        quantile(left, right, k, tmp_val, tmp_k);\n        return IdxVal(select(tmp_val, tmp_k, left), tmp_val);\n    }\n    inline Val maximum(int left, int right) const { return quantile(left, right, 0); }\n    inline Val minimum(int left, int right) const { return quantile(left, right, right - left - 1); }\n    //区間がかぶってるとkとかがintより大きくなるよね\n    void quantile_ranges(const vector<int>& lefts0, const vector<int>& rights0, int k, Val& out_val, int& out_k) const {\n        int n = lefts0.size();\n        int width = 0;\n        for (int i = 0; i < n; i++) width += rights0[i] - lefts0[i];\n        if (width <= k) { out_val = UNDEFINED; out_k = NOTFOUND; return; }\n        static vector<int> lefts, rights; //自動変数だとメモリ確保の時間…と思ったけどこれだとどうだろう？\n        lefts.assign(lefts0.begin(), lefts0.end());\n        rights.assign(rights0.begin(), rights0.end());\n        Val val = 0;\n        for (int bit = 0; bit < bitsize; bit++) {\n            int count = 0;\n            for (int i = 0; i < n; i++) {\n                count += dicts[bit].rank(true, lefts[i], rights[i]);\n            }\n            bool dir = k < count;\n            val = val << 1 | (dir ? 1 : 0);\n            if (!dir) k -= count;\n            for (int i = 0; i < n; i++) {\n                lefts[i] = dicts[bit].rank(dir, lefts[i]);\n                rights[i] = dicts[bit].rank(dir, rights[i]);\n                if (dir) lefts[i] += mids[bit], rights[i] += mids[bit];\n            }\n        }\n        out_val = val; out_k = k;\n    }\n    //区間がかぶってるとバグる\n    //区間がソートされていないとバグる\n    inline IdxVal quantile_ranges_idxval(const vector<int>& lefts, const vector<int>& rights, int k) const {\n        int n = lefts.size();\n        Val tmp_val; int tmp_k;\n        quantile_ranges(lefts, rights, k, tmp_val, tmp_k);\n        for (int i = 0; i < n; i++) {\n            if (tmp_k < rights[i] - lefts[i]) {\n                return IdxVal(select(tmp_val, tmp_k, lefts[i]), tmp_val);\n            }\n            tmp_k -= rights[i] - lefts[i];\n        }\n        return IdxVal(NOTFOUND, UNDEFINED);\n    }\n    struct Range {\n        int left, right;\n        int bit; Val val;\n        Range(int l, int r, int b, Val v) :\n            left(l), right(r), bit(b), val(v) {}\n    };\n    //O(bitsize min(length, maxval) log min(length, maxval))?\n    //priority_queueではやはり最悪ケースが…\n    //でもランダムで適当(バラけすぎとかが無い)なデータに対しては結構速い\n    template<typename F, typename FOut>\n    int rectbfsk(const F& f, int left, int right, Val bottom, Val up, int k, FOut& out) const {\n        int k0 = k;\n        up = min(up, maxval + 1);\n        priority_queue<Range, vector<Range>, F> q(f);\n        q.push(Range(left, right, 0, 0));\n        while (k && !q.empty()) {\n            Range t = q.top(); q.pop();\n            if (t.bit == bitsize) {\n                f.pushvalues(out, t, k);\n            }\n            else {\n                int leftcount = dicts[t.bit].rank(false, t.left);\n                int rightcount = dicts[t.bit].rank(false, t.right);\n                if (rightcount - leftcount != 0 &&\n                    bottom <= ((t.val << (bitsize - t.bit)) | BITMASK(bitsize - t.bit - 1)))\n                    q.push(Range(leftcount, rightcount, t.bit + 1, t.val << 1));\n                if ((t.right - t.left) - (rightcount - leftcount) != 0 &&\n                    (((t.val << 1 | 1) << (bitsize - t.bit - 1))) < up) {\n                    q.push(Range(\n                        (t.left - leftcount) + mids[t.bit], (t.right - rightcount) + mids[t.bit],\n                        t.bit + 1, t.val << 1 | 1));\n                }\n            }\n        }\n        return k0 - k;\n    }\n    struct ValCount {\n        Val val; int count;\n        ValCount(Val v, int c) : val(v), count(c) {}\n        ValCount() {}\n    };\n    struct FreqList {\n        inline bool operator()(const Range& x, const Range& y) const {\n            return x.right - x.left < y.right - y.left ||\n                (x.right - x.left == y.right - y.left && x.val > y.val);\n        }\n        inline void pushvalues(vector<ValCount>& out, const Range& t, int& k) const {\n            out.push_back(ValCount(t.val, t.right - t.left));\n            k--;\n        }\n    };\n    inline int topk(int left, int right, Val bottom, Val up, int k, vector<ValCount>& out) const {\n        return rectbfsk<FreqList, vector<ValCount> >(FreqList(), left, right, bottom, up, k, out);\n    }\n    template<typename F, typename FOut>\n    struct DfsInfo {\n        const F& f;\n        FOut& out;\n        Val bottom, up;\n        DfsInfo(const F& f_, FOut& o, Val b, Val u) : f(f_), out(o), bottom(b), up(u) {}\n    };\n    //O(min(k bitsize, min(length, maxval)))?\n    //minじゃなくてもう少しなめらかな関数で上界得られそうだけど…kつの中で幅に入らない分は共有されるイメージ\n    //でもO(k bitsize)はやはり心強いな。k=1ならO(bitsize)となるわけだし\n    template<typename F, typename FOut>\n    void rectdfsk_dfs(const DfsInfo<F, FOut>& info, int bit, Val val, int left, int right, int& k) const {\n        if (bit == bitsize) {\n            info.f.pushvalues(info.out, val, right - left, k);\n            return;\n        }\n        int leftcount = dicts[bit].rank(left);\n        int rightcount = dicts[bit].rank(right);\n        if (F::MAXF) {\n            if (k > 0 && rightcount - leftcount != 0 &&\n                (((val << 1 | 1) << (bitsize - bit - 1)) < info.up))\n                rectdfsk_dfs<F, FOut>(info, bit + 1, val << 1 | 1, leftcount + mids[bit], rightcount + mids[bit], k);\n            if (k > 0 && (right - left) - (rightcount - leftcount) != 0 && (info.bottom <= ((val << (bitsize - bit)) | BITMASK(bitsize - bit - 1))))\n                rectdfsk_dfs<F, FOut>(info, bit + 1, val << 1, left - leftcount, right - rightcount, k);\n        }\n        else {\n            if (k > 0 && (right - left) - (rightcount - leftcount) != 0 &&\n                (info.bottom <= ((val << (bitsize - bit)) | BITMASK(bitsize - bit - 1))))\n                rectdfsk_dfs<F, FOut>(info, bit + 1, val << 1, left - leftcount, right - rightcount, k);\n            if (k > 0 && rightcount - leftcount != 0 &&\n                (((val << 1 | 1) << (bitsize - bit - 1)) < info.up))\n                rectdfsk_dfs<F, FOut>(info, bit + 1, val << 1 | 1, leftcount + mids[bit], rightcount + mids[bit], k);\n        }\n    }\n    template<bool maxf>\n    struct MinMaxList {\n        enum { MAXF = maxf };\n        inline void pushvalues(vector<ValCount>& out, Val val, int count, int& k) const {\n            out.push_back(ValCount(val, min(k, count)));\n            k -= min(k, count);\n        }\n    };\n    template<typename F, typename FOut>\n    int rectdfsk(const F& f, int left, int right, Val bottom, Val up, int k, FOut& out) const {\n        rectdfsk_dfs<F, FOut>(DfsInfo<F, FOut>(f, out, bottom, up), 0, 0, left, right, k);\n        return k;\n    }\n    template<bool maxf>\n    int rectminmaxk(int left, int right, Val bottom, Val up, int k, vector<ValCount>& out) const {\n        return rectdfsk<MinMaxList<maxf>, vector<ValCount> >(MinMaxList<maxf>(), left, right, bottom, up, k, out);\n    }\n};\nostream& operator<<(ostream& o, const WaveletMatrix::IdxVal& idxval) {\n    return o << \"(\" << idxval.idx << \": \" << idxval.val << \")\";\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N, A, B, P[5010];\nWaveletMatrix wm;\n//---------------------------------------------------------------------------------------------------\nint rev[5010];\nll dp[5010][5010];\nll f(int L, int R) {\n    if (0 <= dp[L][R]) return dp[L][R];\n    if (L == R) return 0;\n\n    dp[L][R] = infl;\n\n    // ←\n    int lft = wm.rangefreq(0, rev[L], L, R + 1);\n    if(0 < lft) chmin(dp[L][R], f(L + 1, R) + B);\n    else chmin(dp[L][R], f(L + 1, R));\n\n    // →\n    int rht = wm.rangefreq(rev[R] + 1, N, L, R + 1);\n    if (0 < rht) chmin(dp[L][R], f(L, R - 1) + A);\n    else chmin(dp[L][R], f(L, R - 1));\n\n    return dp[L][R];\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> A >> B;\n    rep(i, 0, N) cin >> P[i];\n\n    rep(i, 0, N) rev[P[i]] = i;\n    vector<WaveletMatrix::Val> v;\n    rep(i, 0, N) v.push_back(P[i]);\n    wm.init(v);\n\n    rep(i, 0, N + 1) rep(j, 0, N + 1) dp[i][j] = -1;\n    cout << f(1, N) << endl;\n\n    //rep(L, 1, N + 1) rep(R, L, N + 1) printf(\"dp[%d][%d] = %lld\\n\", L, R, f(L, R));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\n//#define int __int128\n//#define ll __int128\n//typedef __int128 long long;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#else\n    freopen(\"disconnected.in\", \"r\", stdin);\n    freopen(\"disconnected.out\", \"w\", stdout);\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nconst int N = 5009;\nconst ll oo = 1e18;\n\nll a, b;\n\nint p[N];\nint n;\nll dp[N][2];\n\nvoid smain() {\n\n    cin >> n >> a >> b;\n    fori (i, n) {\n        cin >> p[i + 1];\n    }\n    int pr = 0, cr = 1;\n    fori (i, N) fori (j, 2) dp[i][j] = oo;\n\n    dp[0][0] = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int mx = 0; mx <= n; ++mx) {\n            if (dp[mx][pr] < oo) {\n                if (mx > p[i]) {\n                    inmin(dp[mx][cr], dp[mx][pr] + b);\n                } else {\n                    inmin(dp[p[i]][cr], dp[mx][pr]);\n                    inmin(dp[mx][cr], dp[mx][pr] + a);\n                }\n            }\n            dp[mx][pr] = oo;\n        }\n        swap(pr, cr);\n    }\n    ll ans = oo;\n    fori (mx, n + 1) {\n        inmin(ans, dp[mx][pr]);\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\nusing ll = long long;\ntypedef pair<int, int> P;\nll Mod = 1000000007;\n\nint N;\nll A,B;\nint p[5012];\nll C[5012];\nbool Graph[5012][5012];\nbool Tr[5012];\nbool exist[5012];\n\nll DFS(int a) {\n  Tr[a] = true;\n  ll f = 0;\n  int min_num = 99999;\n  for (int i = a+1; i < N; i++) {\n    if (Graph[a][i]) {\n      Tr[i] = true;\n      if (min_num < p[i]) {\n        continue;\n        \n      } else {\n        min_num = p[i];\n      }\n      f = max(f,DFS(i) + C[i]); \n    }\n  }\n  return f;\n}\n\nint main() {\n  cin >> N >> A >> B;\n  for (int i = 0; i < N; i++) {\n    cin >> p[i];\n    p[i]--;\n    \n  }\n  ll normal_cost = 0;\n  for (int i = 0; i < N; i++) {\n    if (p[i] > i) {\n      normal_cost += A;\n      C[i] = A;\n    } else if (p[i] < i) {\n      normal_cost += B;\n      C[i] = B;\n    } else {\n      C[i] = 0;\n    }\n  }\n  \n  for (int i = 0; i < N; i++) {\n    for (int j = i; j < N; j++) {\n      if (p[i] < p[j]) {\n        exist[i] = true;\n        Graph[i][j] = true;\n      }\n    } \n  }\n  ll ans = normal_cost;\n  ans = min(ans,A*(N-1));\n  ans = min(ans,B*(N-1));\n  for (int i = 0; i < N; i++) {\n    if (Tr[i]) {\n      continue;\n    }\n    ll res = normal_cost;\n    if (!exist[i]) {\n      continue;\n    }\n    res -= C[i];\n    res -= DFS(i);\n    ans = min(ans,res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, w[5010];\nlong long D[5010], A, B, S[5010];\nint main() {\n\tint i, j;\n\tscanf(\"%d%lld%lld\", &n, &A, &B);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tD[i] = 1e18;\n\t}\n\tn++;\n\tw[n] = n;\n\tD[n] = 1e18;\n\tfor (i = 1; i <= n; i++) {\n\t\tD[i] = min(D[i], A * (i - 1));\n\t\tlong long s = 0;\n\t\tfor (j = i + 1; j <= n; j++) {\n\t\t\tif (w[j] > w[i]) {\n\t\t\t\tD[j] = min(D[j], D[i] + s);\n\t\t\t}\n\t\t\tif (w[i] < w[j]) {\n\t\t\t\ts += A;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts += B;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", D[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 5e3 + 10;\nconst long long max_val = 1LL << 62;\n\nlong long dp[maxn][maxn * 2];\nint p[maxn];\n\nlong long cost(int p1, int p2, int A, int B) {\n    if (p1 * 2 - 1 == p2) return 0;\n    else if (p1 * 2 - 1 > p2) return A;\n    else return B;\n}\n\nint main()\n{\n    int N, A, B;\n    cin >> N >> A >> B;\n    for (int i = 1; i <= N; i++) {\n        cin >> p[i];\n    }\n    for (int i = 1; i <= N; i++) for (int j = 0; j < 2 * N; j++) dp[i][j] = max_val;\n    //dp[i][j] = min{dp[i - 1][k] + (p[i] != k) * (A | B)}\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j < 2 * N; j++) {\n            int tail = (j % 2 == 0 ? j + 1 : j);\n            for (int k = 0; k < j; k++) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + cost(p[i], k, A, B));\n            }\n        }\n    }\n    long long res = max_val;\n    for (int j = 0; j < 2 * N; j++) res = min(res, dp[N][j]);\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "import sys\n\n# Rotate selected partial list and return the full list\ndef reorder(list, index, newIndex):\n    tmp = list\n    ind = -1\n    if index > newIndex:\n        tmp.insert(newIndex, list[index])\n        tmp.pop(index + 1)\n    if index < newIndex:\n        tmp.insert(newIndex + 1, list[index])\n        tmp.pop(index)\n\n    # print(2,tmp)\n    return tmp\n\n\n# Calculate the distance a element from its original position\ndef distance(element, set):\n    return element - set.index(element) - 1\n\n\n# Calculate the cheapest way to make a rotation\n## to rotate a list of k elements to the right once\n## is the same as to rotate k-1 times to the left\ndef add_cost(bef, aft):\n    global A\n    global B\n\n    max_rot = abs(aft-bef)\n\n    if bef > aft:\n        if B > max_rot * A:\n            return max_rot * A\n        else:\n            return B\n    else:\n        if A > max_rot * B:\n            return max_rot * B\n        else:\n            return A\n\n\n# Get input and assign the proper variables\ninput = [int(i) for i in sys.stdin.readline().split(\"\\n\")[0].split(\" \")]\n\nN = input[0]\nA = input[1]\nB = input[2]\n\nlst = [int(i) for i in sys.stdin.readline().split(\"\\n\")[0].split(\" \")]\n\n# Sorted list for comparison\nreordered = [i for i in range(1, N+1)]\n\n## moved is a list of numbers that were rotated\nmoved = []\ncost = 0\n\n\n# Repeat until the original list is sorted\nwhile not lst == reordered:\n\n    dist = 0\n    dest = 5001\n    dist_tmp = 0\n    indexCur = -1\n    indexNew = -1\n\n    # Select the element that is the furthest\n    for i in lst:\n        if i not in moved:\n            dist_tmp = abs(distance(i, lst))\n            if dist_tmp > dist:\n                indexCur = lst.index(i)\n                dist = dist_tmp\n\n    # Find where to put the selected element\n    if not dist == 1:\n        for k in lst:\n            if not k == lst[indexCur]:\n                dist_tmp = abs(distance(k, lst))\n                if dist_tmp < dest:\n                    indexNew = lst.index(k)\n                    dest = dist_tmp\n                    continue\n                if dist_tmp == dest:\n                    if k < lst[indexCur]:\n                        indexNew = lst.index(k)\n                        continue\n\n    # Final Stage\n    # There are only 0s and 1s left\n    else:\n        try:\n            if distance(lst[indexCur + 1],lst) == -1:\n                indexNew = indexCur + 1\n        # Already moved the element with the highest distance [5,2,3,1,4]\n        except:\n            if distance(lst[indexCur - 1], lst) == 1:\n                indexNew = indexCur - 1\n\n    # Move element and count Cost\n    moved.append(lst[indexCur])\n    if not indexNew == -1 and not indexCur == indexNew:\n        # print(lst[indexCur], indexNew, add_cost(indexCur, indexNew))\n        lst = reorder(lst, indexCur, indexNew)\n        # print(lst)\n        cost += add_cost(indexCur, indexNew)\n\nprint(cost)"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst long long INF=4557430888798830399;\nint n,A,B;\nint a[5001];\nlong long dp[5001][5001];\nlong long ans=INF;\nint main()\n{\n    memset(dp,63,sizeof(dp));\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n        \tif(a[i]>j) dp[i][j]=min(dp[i][j],dp[i-1][j]+A),dp[i][a[i]]=min(dp[i][a[i]],dp[i-1][j]);\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n\tfor(int i=0;i<=n;i++)\n\t\tans=min(ans,dp[n][i]);\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\ntypedef long long LL;\nconst int inf=0x3f3f3f3f;\nconst int MAX=5345;\nconst LL llinf=1ll<<60;\nint n,c[MAX],ub[MAX][MAX];\nLL a,b,dp[MAX][MAX];\nint main(){\n    scanf(\"%d%lld%lld\",&n,&b,&a);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&c[i]);\n    for(int i=0;i<=n+1;++i)ub[0][i]=inf;\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n+1;++j){\n            ub[i][j]=ub[i-1][j];\n            if(c[i]>j&&c[i]<ub[i][j])ub[i][j]=c[i];\n        }\n    }\n    for(int i=1;i<=n+1;++i){\n        if(i<=c[1])dp[1][i]=b;\n        else dp[1][i]=0;\n    }\n    for(int i=2;i<=n;++i){\n        for(int j=1;j<=n+1;++j){\n            if(j<=c[i]){\n                dp[i][j]=dp[i-1][j]+b;\n            }\n            else if(j>c[i]&&j<=ub[i-1][c[i]]){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=min(dp[i-1][j]+a,dp[i-1][ub[i-1][c[i]]]);\n            }\n        }\n    }\n    LL sx5=llinf;\n    /*for(int i=1;i<=n;++i){\n        for(int j=1;j<=n+1;++j){\n            printf(\"%d %d:%lld\\n\",i,j,dp[i][j]);\n        }\n    }*/\n    for(int i=1;i<=n+1;++i){\n        sx5=min(sx5,dp[n][i]);\n    }\n    printf(\"%lld\\n\",sx5);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long \nll dp[5050],A,B;\nint a[5050],n;\nint main(){\n\tmemset(dp,63,sizeof dp);\n\tscanf(\"%d\",&n);\n\tscanf(\"%lld%lld\",&A,&B);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\ta[n+1]=n+1;\n\tdp[0]=0;\n\tfor (int i=1;i<=n+1;i++){\n\t\tint g=0;\n\t\tfor (int j=i-1;j>=0;j--)\n\t\t\tif (a[j]>a[i])g++;\n\t\t\telse dp[i]=std::min(dp[i],dp[j]+A*g+B*(i-j-1-g));\n\t}\n\tprintf(\"%lld\",dp[n+1]);\n} "
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\n\nusing namespace std;\n\nconst long long N = 5000 + 5;\nconst long long inf = 1e9 + 7;\nvector<long long> p;\nlong long a;\nlong long b;\nlong long n;\n\nlong long solver(vector<long long> vec)\n{\n    if (vec.size() <= 1)\n    {\n        return 0;\n    }\n    long long mini = vec[0];\n    long long ind = 0;\n    for (long long i = 0; i < vec.size(); i++)\n    {\n        if (mini > vec[i])\n        {\n            mini = vec[i];\n            ind = i;\n        }\n    }\n    vector<long long> v;\n    //only pay for minimum and take it to left;\n    for (long long i = 0; i < vec.size(); i++)\n    {\n        if (vec[i] == mini)\n        {\n            continue;\n        }\n        v.push_back(vec[i]);\n    }\n    long long tmp1 = b + solver(v);\n    v.clear();\n    long long tmp2 = ind * a;\n    //pay for all of the bigger than minimum and take them to the right place;\n    for (long long i = ind + 1; i < vec.size(); i++)\n    {\n        v.push_back(vec[i]);\n    }\n    tmp2 += solver(v);\n    return min(tmp1, tmp2);\n}\n\n \nint main() \n{\n    cin >> n >> a >> b;\n    for (long long i = 0; i < n; i++)\n    {\n        long long tmp;\n        cin >> tmp;\n        p.push_back(tmp);\n    }\n    cout << solver(p);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=5005;\nusing namespace std;\ntypedef long long ll;\nconst ll inf=1e18;\nint n,a,b,p[N],x;\nll f[N],g[N],ans=inf;\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=0;i<n;i++)\n\tscanf(\"%d\",&x),p[x-1]=i;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=n;j++)\n\t\tg[j]=f[j],f[j]=inf;\n\t\tfor(int j=0;j<=n;j++)\n\t\tif(p[i]<j)\n\t\tf[j]=min(f[j],g[j]+a);\n\t\telse{\n\t\t\tif(p[i]>j)f[j]=min(f[j],g[j]+b);\n\t\t\tf[p[i]+1]=min(f[p[i]+1],g[j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\tans=min(ans,f[i]);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inf 2333333333333333333LL\n\nll f[5010][5010],a,b;\nint num[5010],p[5010],n;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nint main()\n{\n\tn=rd();a=rd();b=rd();\n\tfor (int i=1;i<=n;i++) num[i]=rd(),p[num[i]]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i==p[1]) f[1][i]=0;\n\t\telse if (i<p[1]) f[1][i]=b;\n\t\telse f[1][i]=a;\n\t}\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++) f[i][j]=inf;\n\t\tll mn=inf;\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tmn=min(mn,f[i-1][j]);\n\t\t\tif (j<p[i]) f[i][j]=min(f[i][j],mn+b);\n\t\t\telse if (j==p[i]) f[i][j]=min(f[i][j],mn);\n\t\t\telse f[i][j]=min(f[i][j],mn+a);\n\t\t}\n\t}\n\tll ans=inf;\n\tfor (int i=1;i<=n;i++) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define pb push_back\n#define X first\n#define Y second\n\n#define SZ(a) ((LL)(a).size())\n#define all(a) (a).begin(),a.end()\n#define forn(i, n) for(LL i = 0; i < n; ++i)\n#define ALL(x) x.begin(), x.end()\n#define ll long long\n#define MAXN 100\nint step[100005];\nvector<vector<int> > g(100005);\nint n , m;\nint block = 0;\nint visited[100005];\nvoid dfs(int u)\n{\n\tvisited[u] = 1;\n\tfor(auto v : g[u])\n\t{\n\t\tif(v == block || visited[v])\n\t\t\tcontinue;\n\t\tdfs(v);\n\t}\n}\nint cnt(int u)\n{\n\tmemset(visited , 0 , sizeof visited);\n\tblock = u;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(u == i)\n\t\t\tcontinue;\n\t\tif(!visited[i])\n\t\t{\n\t\t\tans++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\treturn ans;\n}\nint main()\n{\n\t\n\tcin >> n >> m;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint u , v;\n\t\tcin >> u >> v;\n\t\tu--;v--;\n\t\tg[u].PB(v);\n\t\tstep[u]++;\n\t\tstep[v]++;\n\t}\n\tint cnt4 = 0;\n\tint mx = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(step[i] % 2)\n\t\t{\n\t\t\tcout << \"No\";\n\t\t\treturn 0;\n\t\t}\n\t\tcnt4 += step[i] == 4;\n\t\tmx = max(mx , step[i]);\n\t}\n\t//cout << mx << \" \" << cnt4 << endl;\n\tif(mx >= 6)\n\t{\n\t\tcout << \"Yes\";\n\t\treturn 0;\n\t}\n\tif(mx == 4 && cnt4 >= 3)\n\t{\n\t\tcout << \"Yes\";\n\t\treturn 0;\n\t}\n\tif(mx == 4 && cnt4 == 1)\n\t{\n\t\tcout << \"No\";\n\t\treturn 0;\n\t}\n\tif(mx == 2)\n\t{\n\t\tcout << \"No\";\n\t\treturn 0;\n\t}\n\tbool good = false;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\t\n\t\tif(step[i] == 4)\n\t\t{\n\t\t\tint f = cnt(i);\n\t\t\t\n\t\t\tif(f != 1)\n\t\t\t{\n\t\t\t\tgood = true;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout << (good ? \"Yes\" : \"No\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define inf 9982443530000000\n#define maxn 5001\n#define int long long\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint n, A, B, a[maxn], b[maxn], pos[maxn], ans = inf, dp[maxn][maxn];\nsigned main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn = read(); A = read(); B = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read(), pos[a[i]] = i;\n\tmemset(dp, 0x3f3f3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < i; j++)\n\t\t{\n\t\t\tif(pos[i] > pos[j]) {\n\t\t\t\tdp[i][i] = min(dp[i - 1][j], dp[i][i]);\n\t\t\t\tdp[i][j] = dp[i - 1][j] + B;\n\t\t\t}\n\t\t\telse dp[i][j] = dp[i - 1][j] + A;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) ans = min(ans, dp[n][i]);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\ntemplate <class T> void chmin(T& x, T y) { if (x > y) x = y; }\nInt dp[5010][5010];\nconst Int INF = 1e18;\nint main() {\n    int N, A, B; cin >> N >> A >> B;\n    vector<int> P(N); for (auto &p : P) cin >> p;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= N; j++) {\n            dp[i][j] = INF;\n        }\n    }\n    dp[0][0] = A;\n    dp[0][P[0]] = 0;\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = 0; j <= N; j++) {\n            if (j >= P[i + 1]) {\n                chmin(dp[i + 1][j], dp[i][j] + B);\n            } else {\n                chmin(dp[i + 1][P[i + 1]], dp[i][j]);\n                chmin(dp[i + 1][j], dp[i][j] + A);\n            }\n        }\n    }\n    Int ans = INF;\n    for (int j = 0; j <= N; j++) {\n        chmin(ans, dp[N - 1][j]);\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n//const int mod = 998244353;\nconst int N = 7005;\nconst int K = 1000000;\nvector < int > ls[N], rs[N];\nint dp[N][N], p[N][N], c[N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int b, a, n;\n    cin >> n >> a >> b;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            if (i == 0 && j == 0) continue;\n            dp[i][j] = 1e16;\n        }\n    }\n    for (int i = 1; i <= n; i++) cin >> c[i];\n    for (int i = 1; i <= n; i++){\n        for (int j = 0; j <= n; j++){\n            if (c[i] == j){\n                dp[i][j] = p[i - 1][j];\n            } else{\n                if (i < c[i]){\n                    dp[i][j] = dp[i - 1][j] + a;\n                }\n                if (i > c[i]){\n                    dp[i][j] = dp[i - 1][j] + b;\n                }\n                if (i == c[i]){\n                    dp[i][j] = dp[i - 1][j] + min(a, b);\n                }\n            }\n            if (j != 0)\n                p[i][j] = min(p[i][j - 1], dp[i][j]); else\n                p[i][j] = dp[i][j];\n        }\n    }\n    int ans = 1e18;\n    for (int i = 0; i <= n; i++){\n        ans = min(ans, dp[n][i]);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 5010;\n\nint n;\nint pos[N], cnt[N], mx[N];\nint pt[N][N];\nll dp[N][N];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n\n  int a, b; scanf(\"%d%d%d\", &n, &a, &b);\n  for (int i = 1; i <= n; ++i) {\n    int p; scanf(\"%d\", &p);\n    pos[p] = i;\n  }\n  for (int i = 1; i <= n; ++i) {\n    memset(cnt, 0, sizeof(cnt));\n    memset(mx, 0, sizeof(mx));\n    int p = pos[i], c = 1, m = i;\n    mx[pos[i]] = i;\n    for (int j = i + 1; j <= n; ++j) {\n      ++cnt[pos[j]];\n      if (pos[j] < p) {\n        ++c;\n        m = j;\n      } else\n        mx[pos[j]] = j;\n      while (c + i - 1 != m) {\n        ++p;\n        c += cnt[p];\n        m = max(m, mx[p]);\n      }\n      if (m != j)\n        pt[i][j] = m;\n    }\n  }\n  for (int len = 2; len <= n; ++len)\n    for (int l = 1, r = len; r <= n; ++l, ++r) {\n      //LOG(\"%d %d: %d\\n\", l, r, pt[l][r]);\n      if (pt[l][r])\n        dp[l][r] = dp[l][pt[l][r]] + dp[pt[l][r] + 1][r];\n      else\n        dp[l][r] = min(dp[l + 1][r] + b, dp[l][r - 1] + a);\n    }\n  printf(\"%lld\\n\", dp[1][n]);\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n// #define int long long\n#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define FORD(i,a,b) for(int i=(a);i>=(b);i--)\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\nconst int INF = (((1<<30)-1)<<1)+1;\nconst int nINF = 1<<31;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<char, int> pci;\n\n/////////////////////////////////////////////////////////////////////\n\nconst int N = 5010;\nint n, p[N];\nll a, b, ac[N], bc[N];\n\nvoid print() {\n\tFOR(i,1 ,n) cout << p[i] << ' ';\n\tcout << endl;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    //cout << fixed << setprecision(7);\n    cin >> n >> a >> b;\n    FOR(i, 1, n) cin >> p[i];\n    FOR(i, 1, n-1) ac[i] = i*a;\n    FOR(i, 1, n-1) bc[i] = i*b;\n    ll ans = 0;\n    FOR(i, 1, n) {\n    \tbool found = false;\n    \tint rt = n, id = 0;\n    \t// print();\n    \tFOR(j, i, n) {\n    \t\tif(p[j] == i) {\n    \t\t\tfound = true;\n    \t\t\tid = j;\n    \t\t} else if(found && p[j] >= j) {\n    \t\t\trt = j-1;\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    \t// DEBUG(i);\n    \t// DEBUG(id);\n    \t// DEBUG(rt);\n    \t// DEBUG(min(ac[id-i], bc[rt-id+1]));\n    \tans += min(ac[id-i], bc[rt-id+1]);\n    \trotate(p+i, p+id, p+rt+1);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n// Easy things to check:\n// - LONG LONGS (WA)\n// - const int N is correct (WA, RTE)\n// - .size()-k underflow (WA, RTE, TLE)\n// - small n edge cases (WA)\n\n// Rare mistakes made in the past:\n// - division by 0 (WA)\n// - integer division (WA)\n// - setprecision (WA)\n// - INF not big enough using ll (WA)\n// - setting max to 0 instead of -INF/min to 0 instead of INF (WA)\n// - outputting debug (WA)\n// - allocating too much memory (locRTE, MLE)\n// - stack size (locRTE)\n// - round announcements (WA)\n// - multiset::erase (WA)\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n\nconst int MAX_N = 5000 + 7;\n\nint n;\nint A[MAX_N];\nint B[MAX_N];\nint lmax[MAX_N][MAX_N], rmin[MAX_N][MAX_N];\nll l, r;\nll dp[MAX_N][MAX_N];\n\n\nint main() {\n    scanf(\"%d%lld%lld\", &n, &r, &l);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &A[i]);\n        B[A[i]] = i;\n    }\n    \n    for (int k = 1; k <= n; k++) {\n        int cnt = 0;\n        for (int t = 1; t < k; t++) {\n            if (A[t] > A[k])\n                cnt++;\n            lmax[t][A[k]] = cnt;\n        }\n    }\n    \n    for (int k = n; k >= 0; k--)\n        for (int i = n; i >= 1; i--) {\n            if (k == n || i == n)\n                dp[k][i] = 0;\n            else if (B[i] <= k) {\n                dp[k][i] = dp[k][i + 1];\n            }\n            else {\n                dp[k][i] = min(l + dp[k][i + 1], r * (lmax[B[i] - 1][i] - lmax[k][i]) + dp[B[i] - 1][i + 1]);\n            }\n        }\n\n    /*for (int i = 1; i <= n; i++)\n        printf(\"%d \", lmin[i]);\n    printf(\"\\n\");\n    for (int i = 1; i <= n; i++)\n        printf(\"%d \", rmax[i]);\n    printf(\"\\n\");*/\n\n    /*for (int i = 0; i <= n; i++)\n        dp[i][n - i] = 0;\n    for (int sum = n - 1; sum >= 0; sum--)\n        for (int i = 0; i <= sum; i++) {\n            int j = sum - i;\n            dp[i][j] = l + dp[i + 1][j];\n            if (lmin[i + 1] >= n - j + 1)\n                dp[i][j] = min(dp[i][j], dp[i + 1][j]);\n            dp[i][j] = min(dp[i][j], r + dp[i][j + 1]);\n            if (rmax[n - j] <= i)\n                dp[i][j] = min(dp[i][j], dp[i][j + 1]);\n            //printf(\"!!!!!%d %d: %lld\\n\", i, j, dp[i][j]);\n        }*/\n    printf(\"%lld\\n\", dp[0][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * \tThe way if it's all predetermined\n * \t\tAnd the way i should go all my life\n * \t\t\tI swear to go wherever will be\n * \t\t\t\t'Cause there'll be something to see and to find\n * \tI don't know the meaning of life\n * \t\tBut i know what's truly precious\n * \t\t\tThe way it's leading me to be in love\n * \t\t\t\tNo fear i can find me always in my heart\n * \tThe life it's not for comparing things\n * \t\tSo i hold both of light and shadow\n * \t\t\tThe rays of stars will bring me to you\n * \t\t\t\tThrought the dark night skies\n * \t\t\t\t\tSee the way to be shined\n * \tI dont know what's right for our lives\n * \t\tBut i know the truth of my love\n * \t\t\tThe way it feels our breaths at the wind\n * \t\t\t\tAnd the way i should go all my life\n * \t\t\t\t\tI swear to go wherever will be\n * \t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\tWill always in my heart\n * \t\t\t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\t\t\tWill always in my heart\n */\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#ifndef rd\n#define endl '\\n'\n#endif\n#ifdef rd\n#define trace(...) cout<<\"Line:\"<<__LINE__<<\" \"; __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n\tcout<<name<<\" : \"<<arg1<<endl;\n}\ntemplate<typename Arg1, typename ... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n\tconst char* comma=strchr(names+1,',');\n\tcout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";\n\t__f(comma+1,args...);\n}\n#else\n#define trace(...)\n#endif\n#define deb cout<<\"Line: \"<<__LINE__<<\" plz \"\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double f80;\n#define double long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define sz(x) ((long long)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\nconst ll infl=2e18;\nconst int infi=2e9;\nconst int mod=1e9+7;\ntypedef vector<int> vi;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;\nmt19937 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nauto clk=clock();\nint rng(int lim) {\n\tuniform_int_distribution<int> uid(0,lim-1);\n\treturn uid(rang);\n}\n\nint dp[5005][5005];\nint p[5005];\nint peb[5005];\nint bac[5005];\nvoid solve() {\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tfr(i,1,n) {\n\t\tcin>>p[i];\n\t\tpeb[i]=n+1;\n\t}\n\tfr(j,1,n) {\n\t\tfr(i,j,n) {\n\t\t\tif(p[i]<p[j]) {\n\t\t\t\tpeb[p[i]]=min(peb[p[i]],p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfr(j,1,n) {\n\t\tfr(i,j,n) {\n\t\t\tif(p[j]<p[i]) {\n\t\t\t\tbac[p[i]]=max(bac[p[i]],p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n+1; i++)\n\t\tfill(dp[i],dp[i]+n+2,infl);\n\tdp[0][n+1]=0;\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=n+1; j>1; j--) {\n\t\t\tif(peb[i+1]>=j) {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\t} else {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n\t\t\t}\n\t\t\tif(bac[j-1]<=i) {\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\t} else\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]+a);\n\t\t}\n\t}\n\n//\tcout<<dp[]\n\tint ans=infl;\n\tfor(int i=0; i<=n; i++) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tif(i+1>=j)\n\t\t\t\tans=min(ans,dp[i][i+1]);\n\t\t}\n\t}\n\tassert(ans<infl);\n\tassert(ans<=(n-1)*a);\n\tassert(ans<=(n-1)*b);\n\tcout<<ans<<endl;\n}\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::high_resolution_clock::now().time_since_epoch().count());\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t\tsolve();\n#ifdef rd\n\tcerr<<endl<<endl<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 10000000000000;\n\tvector<long long> P, DP;\n\tcin >> N >> A >> B;\n\tP.resize(N);\n\tDP.assign(N + 1, INF);\n\tDP[0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i], P[i]--;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long MIN = INF;\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (j != P[i] && DP[j] >= INF) continue;\n\t\t\tif (j == 0) {\n\t\t\t\tMIN = min(MIN, DP[j]);\n\t\t\t\tDP[j] += min(A, B);\n\t\t\t}\n\t\t\tif (0 < j && j < P[i]) {\n\t\t\t\tMIN = min(MIN, DP[j]);\n\t\t\t\tDP[j] += A;\n\t\t\t}\n\t\t\tif (j == P[i]) {\n\t\t\t\tDP[j] = MIN;\n\t\t\t}\n\t\t\tif (j > P[i]) {\n\t\t\t\tDP[j] += B;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n//#include<cstdlib>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<iterator>\n#include<deque>\n\nusing namespace std;\n#define PI          acos(-1)\n#define INF         10000000000000000ll\n#define sc(n)       scanf(\"%d\",&n);\n#define lsc(n)      scanf(\"%lld\",&n);\n#define dsc(n)      scanf(\"%lf\",&n);\n#define LL          long long int\n#define UI          unsigned int\n#define ULL         unsigned long long int\n#define DB          double\n#define pii         pair<int,int>\n#define PB          push_back\n#define MP          make_pair\n#define M(mx,a)     mx=max(mx,a)\n#define IT          ::iterator\n#define all(a)      a.begin(),a.end()\n#define mems(a,b)   memset(a,b,sizeof(a))\n#define ARC(n)      for(i=0;i<n;i++)\n#define ASC(n,aa)   for(i=0;i<n;i++)scanf(\"%lld\",&aa[i]);\n#define PNT(n,aa)   for(i=0;i<n;i++)printf(\"%lld \",aa[i]);\n#define mod         1000000007\n#define NUM         5009\n#define NUM2        1000000000\n\n\nint a[NUM],aa[NUM];\nLL neww[NUM][NUM],nxt[NUM][NUM];\n\n\nint main()\n{\n    int T=1,QQ=0;\n    //cin >> T ;\n    while(T--)\n    {\n        int n,i,j ;\n        LL aaa,bbb,k ;\n        cin >> n >> aaa >> bbb ;\n        for(i=1; i<=n; i++)\n        {\n            sc(a[i]);\n            aa[a[i]]=i;\n        }\n        for(i=0; i<=n; i++)\n        {\n            for(int j=0; j<=n; j++)\n            {\n                neww[i][j]=nxt[i][j]=INF;\n            }\n        }\n        for(i=0; i<=n; i++)\n            nxt[0][i]=neww[0][i]=0ll;\n        for(i=1; i<=n; i++)\n        {\n            for(j=0; j<=n; j++)\n            {\n                if(j==aa[i])\n                {\n                    neww[i][j]=min(neww[i][j],nxt[i-1][j-1]);\n                }\n                if(j<aa[i])\n                    k=nxt[i-1][j]+bbb;\n                else\n                    k=nxt[i-1][j]+aaa;\n                neww[i][j]=min(neww[i][j],k);\n            }\n            nxt[i][0]=neww[i][0];\n            for(j=1; j<=n; j++)\n                nxt[i][j]=min(nxt[i][j-1],neww[i][j]);\n        }\n        cout << nxt[n][n] ;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long dp[5010][5010];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; long long a, b; cin >> n >> a >> b;\n    vector<int> p(n, 0), rem(n+1, 1);\n    for (int i = 0; i < n; i++) cin >> p[i];\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = 1e16;\n        }\n    }\n    dp[0][0] = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            // dp[i][j]\n            if (i < n && p[i] == j+1) dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j]);\n            else {\n                dp[i][j+1] = min(dp[i][j+1], dp[i][j] + b * rem[j+1]);\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + a * (i < n && p[i] > j));\n            }\n            //cout << i << \" \" << j << \" -> \" << dp[i][j] << \"\\n\";\n        }\n        rem[p[i]]--;\n    }\n    long long ans = 1e16;\n    for (int i = 0; i <= n; i++) {\n        ans = min(ans, dp[i][n]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//constexpr ll MOD=1e9+7;\n//\nconstexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<55);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        if(A<0) return B;\n        if(B<0) return A;\n        return std::min(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vector<vector<int>> dp;\n    vector<int> dist;\n    Tree(vector<vector<int>> edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,A,B; cin>>N>>A>>B;\n    vi P(N);\n    rep(i,0,N){\n        cin>>P[i];\n        P[i]--;\n    }\n    vii front(N,vi(N+1)),back(N,vi(N+1));\n    rep(i,0,N){\n        ll cnt=0;\n        rep(j,0,i){\n            if(P[j]>P[i]){\n                cnt++;\n                front[P[i]][N-P[j]]--;\n            }\n        }\n        front[P[i]][0]=cnt;\n        REP(j,1,N) front[P[i]][j]+=front[P[i]][j-1];\n        REP(j,0,N) front[P[i]][j]=std::min(B,A*front[P[i]][j]);\n        cnt=0;\n        rep(j,i+1,N){\n            if(P[j]<P[i]){\n                cnt++;\n                back[P[i]][P[j]+1]--;\n            }\n        }\n        back[P[i]][0]=cnt;\n        REP(j,1,N) back[P[i]][j]+=back[P[i]][j-1];\n        REP(j,0,N) back[P[i]][j]=std::min(A,B*back[P[i]][j]);\n    }\n    vii dp(N+1,vi(N+1,inf));\n    dp[0][0]=0;\n    rep(i,0,N){\n        rep(j,0,N-i){\n            dp[i+1][j]=std::min(dp[i+1][j],dp[i][j]+front[i][j]);\n            dp[i][j+1]=std::min(dp[i][j+1],dp[i][j]+back[N-1-j][i]);\n        }\n    }\n    ll ans=inf;\n    REP(i,0,N){\n        ans=std::min(ans,dp[i][N-i]);\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSR(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nll A,B;\nint p[5005];\nvector<P>vec;\nll up[5005],dw[5005];\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t}\n\tint cur = -1;\n\tint pre = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i == 1){\n\t\t\tcur = p[i];\n\t\t}\n\t\telse if(cur+1 != p[i]){\n\t\t\tvec.pb(mp(pre+1,i-1));\n\t\t\tpre = i-1;\n\t\t\tcur = p[i];\n\t\t}\n\t\telse cur++;\n\t}\n\tvec.pb(mp(pre+1,n));\n\tll ans = 1e18;\n\tll C = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = vec[i].sc-vec[i].fi+1;\n\t\tll R = 0;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t    if(i == j) continue;\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] > p[y]){\n\t\t\t\tif(j > i) R += vec[j].sc-vec[j].fi+1;\n\t\t\t\telse;\n\t\t\t}\n\t\t}\n\t\tC += min(L*A,R*B);\n\t//\tcout << i << \" \" << L << \" \" << R<< endl;\n\t}\n\tll D = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = 0;\n\t\tll R = vec[i].sc-vec[i].fi+1;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t    if(i == j) continue;\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] < p[y]){\n\t\t\t\tif(j < i) L += vec[j].sc-vec[j].fi+1;\n\t\t\t\telse;\n\t\t\t}\n\t\t}\n\t\tD += min(L*A,R*B);\n\t}\n\tcout << min(C,D) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,a[200005],d[5005][5005],aa,b,d1[5005][5005],d2[5005][5005];\nint main() {\n\tcin >> n >> b >> aa;\n\t\n\tfor(int i=1; i<=n; i++)\n\t\tcin >> a[i];\n\t\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=i+1; j<=n; j++){\n\t\t\td1[i][j] = d1[i][j-1] + (a[i] > a[j]);\n\t\t}\n\t}\n\t\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=i-1; j>=1; j--){\n\t\t\td2[i][j] = d2[i][j+1] + (a[j] > a[i]);\n\t\t}\n\t}\n\t\n\tfor(int i=2; i<=n; i++){\n\t\tfor(int j=1; j<=n-i+1; j++){\n\t\t\tll raod = 0;\n\t\t\td[j][j+i-1] = min(d[j][j+i-2] + d2[j+i-1][j] * b,d[j][j+i-2] + aa);\n\t\t\traod = 0;\n\t\t\td[j][i+j-1] = min(d[j][i+j-1],min(d[j+1][i+j-1] + aa * d1[j][i+j-1],d[j+1][i+j-1] + b));\n\t\t}\n\t}\n\t\n//\tcout << d[2][3] << endl;\n\t\n\tcout << d[1][n];\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define MP make_pair\n#define PB push_back\nusing namespace std;\nnamespace io{\n\tconst int Sz=1<<13;\n\tchar ibuf[Sz],*ips=ibuf+Sz-1;\n\tinline int getchar(){\n\t\tif(++ips==ibuf+Sz)fread(ips=ibuf,1,Sz,stdin);\n\t\treturn *ips;\n\t}\n\tchar obuf[Sz],*ops=obuf;\n\tinline void flush(){\n\t\tfwrite(obuf,1,ops-obuf,stdout);\n\t\tops=obuf;fflush(stdout);\n\t}\n\tinline void putchar(int c){\n\t\tif(ops==obuf+Sz)flush();\n\t\t*ops=c,ops++;\n\t}\n\tvoid gets(char *s){\n\t\tint c=getchar();\n\t\twhile(c<=32)c=getchar();\n\t\twhile(c>32)*s=c,++s,c=getchar();\n\t\t*s=0;\n\t}\n\tvoid puts(const char *s){\n\t\twhile(*s)putchar(*s),++s;\n\t}\n}\n#define getchar io::getchar\n#define putchar io::putchar\n#define gets io::gets\n#define puts io::puts\nint read(){\n\tint x=0,f=1,c=getchar();\n\tfor(;c<48||c>57;c=getchar())\n\t\tif(c=='-')f=-f;\n\tfor(;c>=48&&c<=57;c=getchar())\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tint stk[20],tp=0;\n\tif(!x)putchar(48);\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)stk[tp++]=(x-x/10*10)^48;\n\tfor(;tp;)putchar(stk[--tp]);\n}\nstruct Flusher{~Flusher(){io::flush();}}flusher;\n// ------------------------- Template End ------------------------- //\nconst int N=5005;\nint n,A,B;\nint p[N];\nint mn[N][N],mx[N][N];\nint dpl[N][N],dpr[N][N];\nll dp[N][N];\nint main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=0;i<n;++i)p[i]=read();\n\tfor(int i=0;i<n;++i)mn[i][i]=mx[i][i]=p[i];\n\tfor(int i=0;i<n;++i)dpl[i][i]=dpr[i][i]=1;\n\tfor(int i=n-1;~i;--i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tmn[i][j]=min(mn[i][j-1],p[j]);\n\t\t\tmx[i][j]=max(mx[i][j-1],p[j]);\n\t\t\tdpl[i][j]=dpl[i][j-1];\n\t\t\tif(p[j]<p[i])++dpl[i][j];\n\t\t\tdpr[i][j]=dpr[i+1][j];\n\t\t\tif(p[i]<p[j])++dpr[i][j];\n\t\t}\n\t}\n\tfor(int i=n-1;~i;--i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tdp[i][j]=0x3f3f3f3f3f3f3f3f;\n\t\t\tdp[i][j]=min(dp[i][j],dp[i+1][j]+min(1LL*(dpl[i][j]>1?A:0),1LL*(dpl[i][j]-1)*B));\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][j-1]+min(1LL*(dpr[i][j]<j-i+1?B:0),1LL*(j-i+1-dpr[i][j])*A));\n\t\t}\n\t}\n\twrite(dp[0][n-1]);putchar('\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,a,b;\nll mem[5005][5005];\nint p[5005], pos[5005];\nll dp(int id, int cur){\n    if (mem[id][cur] != -1) return mem[id][cur];\n    if (id == 0) return mem[id][cur] = 0;\n    if (pos[id] > cur) {\n        //printf(\"%d at %d needs to move to %d, cost %d\\n\",id,pos[id],cur,b);\n        return mem[id][cur] = dp(id-1,cur)+b; ///move id to cur.\n    }\n    //printf(\"%d at %d, can move to %d, cost %d\\n\",id,pos[id],cur,a);\n    return mem[id][cur] =  min(dp(id-1,pos[id]),dp(id-1,cur)+a);\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for (int i = 1; i <= n; i++){\n        scanf(\"%d\",&p[i]);\n        pos[p[i]] = i;\n    }\n    memset(mem,-1,sizeof(mem));\n    printf(\"%lld\",dp(n,n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int maxn=5010;\n\nint n,a[maxn];\nlong long A,B,f[maxn][maxn];\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=n;j++)\n\t\t{\n\t\t\tf[i][j]=100000000000000;\n\t\t}\n\t}\n\tf[0][0]=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=n;j++)\n\t\t{\n\t\t\tint C=0;\n\t\t\tif (a[i]>j) C=A;\n\t\t\telse C=B;\n\t\t\tf[i][j]=min(f[i][j],f[i-1][j]+C);\n\t\t\tif (a[i]>j)\n\t\t\t{\n\t\t\t\tf[i][a[i]]=min(f[i][a[i]],f[i-1][j]);\n\t\t\t}\n\t\t} \n\t}\n\tlong long ans=10000000000000;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tans=min(ans,f[n][i]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n        int n, a, b;\n        scanf(\"%d%d%d\", &n, &a, &b);\n        vector<int> pos(n);\n        rep(i, n) {\n                int p;\n                scanf(\"%d\", &p);\n                p --;\n                pos[p] = i;\n        }\n        const long long inf = 1e18;\n        vector<vector<long long>> cur(n + 1, vector<long long> (2));\n        rep(i, n) {\n                vector<vector<long long>> next(n + 1, vector<long long> (2));\n                vector<long long> mi0(n + 1), mi1(n + 1);\n                mi0[0] = cur[0][0];\n                rep(j, n + 1) if (j) {\n                        mi0[j] = min(mi0[j - 1], cur[j][0]);\n                }\n                mi1[0] = cur[0][1];\n                rep(j, n + 1) if (j) {\n                        mi1[j] = min(mi1[j - 1], cur[j][1]);\n                }\n\n                // rep(j, n + 1) cerr << mi0[j] << ' '; cerr << endl;\n                // rep(j, n + 1) cerr << mi1[j] << ' '; cerr << endl;\n\n                rep(j, n + 1) {\n                        next[j][0] = inf;\n                        next[j][1] = inf;\n                        int cost = 0;\n                        if (j < pos[i]) cost = b;\n                        if (j > pos[i]) cost = a;\n                        // hei\n                        if (j != n + 1) {\n                                if (j > 0) next[j][0] = min(next[j][0], mi0[j - 1] + cost);\n                                if (j > 0) next[j][0] = min(next[j][0], mi1[j - 1] + cost);\n                                /*\n                                rep(k, j) {\n                                        next[j][0] = min(next[j][0], cur[k][0] + cost);\n                                        next[j][0] = min(next[j][0], cur[k][1] + cost);\n                                }\n                                */\n                                next[j][0] = min(next[j][0], cur[j][1] + cost);\n                        }\n                        // kai\n                        if (j == pos[i]) cost = b;\n                        if (j > 0) next[j][1] = min(next[j][1], mi0[j - 1] + cost);\n                        /*\n                        rep(k, j) {\n                                next[j][1] = min(next[j][1], cur[k][0] + cost);\n                        }\n                        */\n                        next[j][1] = min(next[j][1], mi1[j] + cost);\n                        /*\n                        rep(k, j + 1) {\n                                next[j][1] = min(next[j][1], cur[k][1] + cost);\n                        }\n                        */\n                }\n                // rep(j, n + 1) cerr << next[j][0] << ' '; cerr << endl;\n                // rep(j, n + 1) cerr << next[j][1] << ' '; cerr << endl;\n                cur.swap(next);\n        }      \n        long long ans = inf;\n        rep(i, n + 1) {\n                ans = min(ans, cur[i][0]);\n                ans = min(ans, cur[i][1]);\n        }\n        printf(\"%lld\\n\", ans);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ninline int read()\n{\n\tint s=0,f=1; char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=5e3+20;\nconst ll inf=1ll<<60;\n\nint n,A,B;\nint p[maxn];\nll dp[maxn];\nint s[maxn][maxn];\n\ninline void init()\n{\n\tn=read();A=read();B=read();\n\tREP(i,1,n)p[i]=read(); p[n+1]=n+1; \n\tREP(i,1,n+1)s[i][p[i]]++;\n\tREP(i,1,n+1)REP(j,1,n+1)s[i][j]+=s[i][j-1];\n\tREP(i,1,n+1)REP(j,1,n+1)s[i][j]+=s[i-1][j];\n}\n\ninline int Matrix(int x1,int x2,int y1,int y2)\n{\n\treturn s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];\n}\n\ninline void doing()\n{\n\tdp[0]=0;\n\tREP(i,1,n+1)\n\t{\n\t\tdp[i]=inf;\n\t\tREP(j,0,i-1)if(p[j]<p[i])\n\t\t{\n\t\t\tint num=Matrix(j,i,p[j]+1,p[i]-1);\n\t\t\tif(!num)\n\t\t\t{\n\t\t\t\tint a=Matrix(j,i,p[i]+1,n+1);\n\t\t\t\tint b=Matrix(j,i,1,p[j]-1);\n\t\t\t\tchkmin(dp[i],(ll)a*A+(ll)b*B+dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n+1]);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define INF 1000000000000000000LL\nll dp[5050][5050];\nint d[5050], rd[5050];\nint main()\n{\n\tint num;\n\tll cr, cl;\n\tscanf(\"%d%lld%lld\", &num, &cr, &cl);\n\tfor (int i = 0; i < num; i++)scanf(\"%d\", &d[i]), d[i]--, rd[d[i]] = i;\n\tfor (int i = 0; i <= num + 5; i++)for (int j = 0; j <= num + 5; j++)dp[i][j] = INF;\n\tdp[0][0] = 0;\n\tfor (int i = 0; i <= num; i++)\n\t{\n\t\tfor (int j = 0; j <= num; j++)\n\t\t{\n\t\t\tif (j < num&&i < rd[j])dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + cl);\n\t\t\tif (i < num&&j < num&&i == rd[j])dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]);\n\t\t\tif (j < num&&i > rd[j])dp[i][j + 1] = min(dp[i][j + 1], dp[i][j]);\n\t\t\tif (i < num&&j < d[i])dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + cr);\n\t\t\tif (i < num&&j > d[i])dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[num][num]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n \n// const int mod = 1e9 + 7;\n// inline int Add(int x) { return x >= mod ? x - mod : x; }\n// inline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\n// inline int Sub(int x) { return x < 0 ? x + mod : x; }\n// inline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\n// inline int Mul(int x, int y) { return (int)((li)x * y % mod); }\n \n// int Pow(int x, int y) {\n//   int z = 1;\n//   for (; y; y >>= 1) {\n//     if (y & 1) z = Mul(z, x);\n//     x = Mul(x, x);\n//   }\n//   return z;\n// }\n \n// ----------------------------------------\n \ntypedef long long li;\nconst int maxn = 5000;\nconst li inf = 1e18;\nint n, A, B;\nint p[maxn];\nli dp[maxn + 1], dp2[maxn + 1];\n \nvoid Min(li &a, li b) {\n  a = min(a, b);\n}\n \nint main(void) {\n  scanf(\"%d%d%d\", &n, &A, &B);\n  swap(A, B);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", p + i), --p[i];\n  }\n  fill(dp, dp + n + 1, inf);\n  dp[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    COPY(dp, n + 1, dp2);\n    for (int x = 0; x <= n; ++x) {\n      li val = inf;\n      if (x > 0) Min(val, dp[x - 1]);\n      if (x - 1 == p[i]) Min(val, dp2[x - 1]);\n      if (x - 1 > p[i]) Min(val, dp[x] + A);\n      if (x - 1 < p[i]) Min(val, dp[x] + B);\n      dp[x] = val;\n    }\n  }\n  printf(\"%lld\\n\", *min_element(dp, dp + n + 1));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 5000\n#define LL long long\nusing namespace std;\nint n,A,B,a[N+5];LL f[N+5][N+5];\nint main()\n{\n\tRI i,j;for(scanf(\"%d%d%d\",&n,&A,&B),i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor(memset(f,63,sizeof(f)),f[0][0]=0,i=1;i<=n;++i)\n\t{\n\t\tfor(j=0;j^a[i];++j) f[i][j]=min(f[i][j],f[i-1][j]+A),f[i][a[i]]=min(f[i][a[i]],f[i-1][j]);\n\t\tfor(j=a[i]+1;j<=n;++j) f[i][j]=min(f[i][j],f[i-1][j]+B);\n\t}\n\tLL ans=f[0][1];for(i=0;i<=n;++i) ans=min(ans,f[n][i]);return printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst int N = 5e3 + 3;\n\nint dp[N], A[N];\n\nsigned main(){\n\tint n, a, b;\n\tcin >> n >> a >> b;\n    \n    memset(dp , 22, sizeof dp);\n    dp[0] = 0;\n    for(int i=1; i<=n; i++){\n        cin >> A[i];\n        int t = 0;\n        int mx = 0;\n        for(int j=i-1; j>=0; j--){\n            if(A[j] > A[i]) t++;\n        \telse mx = max(mx , A[j]);\n            if(mx == A[j])\n                dp[i] = min(dp[i] , dp[j] + a*t + b*(i-j-1-t));\n        }\n    }\n    \n    int mx = 0;\n    int ans = 1LL << 60;\n    for(int i=n; i>=1; i--){\n        if(mx < A[i]){\n            mx = A[i];\n            ans = min(ans , dp[i] + (n-i)*b);\n        }\n    }\n    \n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\nusing ll = long long;\ntypedef pair<int, int> P;\nll Mod = 1000000007;\n\nint N;\nll A,B;\nint p[5012];\nll C[5012];\nbool Graph[5012][5012];\n\nll DFS(int a) {\n  ll f = 0;\n  for (int i = a+1; i < N; i++) {\n    if (Graph[a][i]) {\n      f = max(f,DFS(i) + C[i]); \n    }\n  }\n  return f;\n}\n\nint main() {\n  cin >> N >> A >> B;\n  for (int i = 0; i < N; i++) {\n    cin >> p[i];\n    p[i]--;\n    \n  }\n  ll normal_cost = 0;\n  for (int i = 0; i < N; i++) {\n    if (p[i] > i) {\n      normal_cost += A;\n      C[i] = A;\n    } else if (p[i] < i) {\n      normal_cost += B;\n      C[i] = B;\n    } else {\n      C[i] = 0;\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = i; j < N; j++) {\n      if (p[i] < p[j]) {\n        Graph[i][j] = true;\n      }\n    } \n  }\n  ll ans = normal_cost;\n  ans = min(ans,A*(N-1));\n  ans = min(ans,B*(N-1));\n  for (int i = 0; i < N; i++) {\n    ll res = normal_cost;\n    bool can = false;\n    for (int j = i+1; j < N; j++) {\n      if (Graph[i][j]) {\n        can = true;\n        break;\n      }\n    }\n    if (can) {\n      res -= C[i];\n    }\n    res -= DFS(i);\n    ans = min(ans,res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 5500;\nll c[maxn],f[maxn],ans;\nint vis[maxn];\nint n,a[maxn];\nll A,B,C;\nll query(int x){\n    ll ans = 1ll<<60;\n    Rep(i,1,x) ans=min(ans,c[i]);\n    return ans;\n}\nvoid add(ll x,ll v){\n    c[x] = v;\n}\nvoid modify(ll x,ll C,ll T){\n    Rep(i,x+1,n) if(vis[i] <= T)\n        c[i] += C;\n}\nint main(){\n//    freopen(\"A.in\",\"r\",stdin);\n//    freopen(\"A.out\",\"w\",stdout);\n    n = read(),A = read(),B = read();\n//    writeln(A);\n//    writeln(B);\n//    if(A<=B) return 0;\n    Rep(i,1,n) a[i] = read();\n    if(A>B){\n        swap(A,B);\n        reverse(a+1,a+1+n);\n        Rep(i,1,n) a[i] = n-a[i]+1;\n    }\n    C = min(A,B);assert(C==A);\n    ans = 1ll << 60;\n    Rep(i,1,n) vis[a[i]] = i;\n    Rep(i,1,n){//A是右移，B是左移 \n        f[i] = min((i - 1) * A,query(a[i]) + i * C - C);\n        modify(a[i],B - C,i);\n        c[a[i]] = f[i] - i * C;\n        ans = min(ans,f[i] + B * (n - i));\n    }writeln(ans);\n    return 0;\n}\n//f[3] = f[2]\n//[3,4,6,9]"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nLL N, X, Y;\nvector<int> A;\nint P[5003][5003];\nint Q[5003][5003];\nint R[5003][5003];\n\nvoid pre() {\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N) {\n\t\t\tQ[i][j + 1] = Q[i][j] + P[i][j];\n\t\t}\n\t}\n\n\tREP(j, 0, N + 1) {\n\t\tREP(i, 0, N) {\n\t\t\tR[i + 1][j] = R[i][j] + Q[i][j];\n\t\t}\n\t}\n}\n\nint rect(int li, int lj, int ri, int rj) {\n\treturn R[li][lj] - R[li][rj] - R[ri][lj] + R[ri][rj];\n}\n\nLL DP[5002][5002];\nint main() {\n\tcin >> N >> X >> Y;\n\tA.push_back(0);\n\tREP(i, 0, N) A.push_back(Next<int>());\n\tA.push_back(N + 1);\n\n\tN += 2;\n\tREP(i, 0, N) {\n\t\t++P[i][A[i]];\n\t}\n\tpre();\n\n\tFill(DP, INFLL);\n\tDP[0][0] = 0;\n\tREP(i, 1, N) {\n\t\tREP(j, 0, N) {\n\t\t\tif (j == A[i]) {\n\t\t\t\tLL mn = INFLL;\n\t\t\t\tREP(li, 0, i) {\n\t\t\t\t\tif (A[li] > A[i]) continue;\n\t\t\t\t\tint lj = A[li];\n\t\t\t\t\tint L = rect(li, lj, i, N) - 1;\n\t\t\t\t\tint R = rect(i, lj, N, j);\n\n\t\t\t\t\tmn = min(mn, DP[i - 1][lj] + L * X + R * Y);\n\t\t\t\t}\n\t\t\t\tDP[i][j] = mn;\n\t\t\t} else {\n\t\t\t\tDP[i][j] = DP[i - 1][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[N - 1][N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\n// const int mod = 1e9 + 7;\n// inline int Add(int x) { return x >= mod ? x - mod : x; }\n// inline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\n// inline int Sub(int x) { return x < 0 ? x + mod : x; }\n// inline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\n// inline int Mul(int x, int y) { return (int)((li)x * y % mod); }\n\n// int Pow(int x, int y) {\n//   int z = 1;\n//   for (; y; y >>= 1) {\n//     if (y & 1) z = Mul(z, x);\n//     x = Mul(x, x);\n//   }\n//   return z;\n// }\n\n// ----------------------------------------\n\ntypedef long long li;\nconst int maxn = 5000;\nconst li inf = 1e18;\nint n, A, B;\nint p[maxn];\nli dp[maxn + 1], dp2[maxn + 1];\n\nvoid Min(li &a, li b) {\n  a = min(a, b);\n}\n\nint main(void) {\n  scanf(\"%d%d%d\", &n, &A, &B);\n  swap(A, B);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", p + i), --p[i];\n  }\n  fill(dp, dp + n + 1, inf);\n  dp[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    COPY(dp, n + 1, dp2);\n    for (int x = 0; x <= n; ++x) {\n      li val = inf;\n      if (x > 0) Min(val, dp[x - 1]);\n      if (x - 1 == p[i]) Min(val, dp2[x - 1]);\n      if (x - 1 > p[i]) Min(val, dp[x] + A);\n      if (x - 1 < p[i]) Min(val, dp[x] + B);\n      dp[x] = val;\n    }\n  }\n  printf(\"%lld\\n\", dp[n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <set>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\nusing namespace std;\n\n#define sz(X) ((int)(X).size())\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n#define all(X) (X).begin(),(X).end()\n#define FOR(I,S,N) for(int I=(S);I<(N);++I)\n#define REP(I,N) FOR(I,0,N)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef vector<ll> vec;\n\nconst int DIM = 5010;\n\nint Min[DIM][DIM];\nint Max[DIM][DIM];\nll cache[DIM][DIM];\n\nint n, a, b;\nvi x, pos;\n\n\nint getMax(int l, int r) {\n    if (l + 1 == r) return pos[l];\n    if (Max[l][r] != -1) return Max[l][r];\n    return Max[l][r] = max(pos[l], getMax(l + 1, r));\n}\n\nint getMin(int l, int r) {\n    if (l + 1 == r) return pos[l];\n    if (Min[l][r] != -1) return Min[l][r];\n    return Min[l][r] = min(pos[l], getMin(l + 1, r));\n}\n\nll solve(int l, int r) {\n    if (l + 1 == r) return 0;\n    if (l >= r) throw 1;\n    if (cache[l][r] != -1) return cache[l][r];\n\n    int costMax = (pos[r-1] == getMax(l, r)) ? 0 : a;\n    int costMin = (pos[l] == getMin(l, r)) ? 0 : b;\n\n    return cache[l][r] = min(\n        costMax + solve(l, r - 1),\n        costMin + solve(l + 1, r)\n    );\n}\n\nint main() {\n\n    cin >> n >> a >> b;\n    x = vi(n);\n    pos = vi(n);\n\n    REP(i, n) {\n        cin >> x[i];\n        x[i] -= 1;\n        pos[x[i]] = i;\n    }\n\n    memset(cache, -1, sizeof(cache));\n    memset(Min, -1, sizeof(Min));\n    memset(Max, -1, sizeof(Max));\n\n    ll ans = solve(0, n);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define set0(x) memset(x,0,sizeof(x))\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();int f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\nll n,va,vb,a[5050],pos[5050],dp[5050][10010];\nint main() {\n\tmemset(dp,7,sizeof(dp));\n\tread(n);read(va);read(vb);\n\tfor(int i=1;i<=n;i++){\n\t\tread(a[i]);\n\t\tpos[a[i]] = i;\n\t}\n\tdp[0][1] = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tll cmin = 1e18;\n\t\tfor(int j=1;j<=n*2+1;j++){\n\t\t\tif(j&1){\n\t\t\t\tcmin = min(cmin,dp[i-1][j]);\n\t\t\t\tcmin = min(cmin,dp[i-1][j-1]);\n\t\t\t}\n\t\t\tif(pos[i]*2 < j)dp[i][j] = cmin+va;\n\t\t\tif(pos[i]*2 == j)dp[i][j] = cmin;\n\t\t\tif(pos[i]*2 > j)dp[i][j] = cmin+vb;\n\t\t}\n\t}\n\tll ans = 1e18;\n\tfor(int j=1;j<=n*2+1;j++)ans = min(ans,dp[n][j]);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INFL = 1e18;\nconst int INF = 1e9;\nconst int MN = 5050;\nll ord[MN];\nll w[MN];\nll dt[MN];\nll dp[MN][MN];\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tint n;\n\tcin >> n;\n\tll a,b;\n\tcin >> a >> b;\n\tfor(int i=0;i<n;i++) {\n\t\tcin >> w[i];\n\t\tw[i]--;\n\t\tord[w[i]] = i+1;\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tfor(int i=0;i<n;i++) {\n\t\tll ma = INFL;\n\t\tfor(int j=0;j<=n;j++) {\n\t\t\tif(i > 0) {\n\t\t\t\tma = min(ma,dp[i-1][j]);\n\t\t\t\tif(j == ord[i-1]) {\n\t\t\t\t\tma = min(ma,dt[i-1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tma = 0;\n\t\t\t}\n\t\t\tif(j == ord[i]) {\n\t\t\t\tdt[i] = ma;\n\t\t\t}\n\t\t\tdp[i][j] = ma+(j>=ord[i]?a:b);\n\t\t}\n\t}\n\tll res = INFL;\n\tfor(int i=0;i<=n;i++) {\n\t\tres = min(res,dp[n-1][i]);\n\t}\n\tres = min(res,dt[n-1]);\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 5007;\nint n, A, B;\nint a[N];\nLL f[N], ans = 1e18;\nint main() {\n#ifdef fwat\n#endif\n\tn = gi(), A = gi(), B = gi();//A:r B:l\n\trep(i, 1, n) a[i] = gi();\n\trep(i, 1, n) {\n\t\tf[i] = 1e18;\n\t\tLL tot = 0;\n\t\tfor(int j = i - 1; ~j; --j) {\n\t\t\tif(a[i] > a[j]) Min(f[i], f[j] + tot);\n\t\t\tif(a[j] > a[i]) tot += A;\n\t\t\telse tot += B;\n\t\t}\n\t\tMin(ans, f[i] + (LL) (n - i) * B);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n\nconst int MAX_N = 5000 + 7;\n\nint n;\nint A[MAX_N];\nint lmin[MAX_N], rmax[MAX_N];\nll l, r;\nll dp[MAX_N][MAX_N];\n\n\nint main() {\n    scanf(\"%d%lld%lld\", &n, &r, &l);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &A[i]);\n    \n    for (int i = 1; i <= n; i++) {\n        lmin[A[i]] = 87878787;\n        for (int j = 1; j < i; j++)\n            if (A[j] > A[i])\n                lmin[A[i]] = min(lmin[A[i]], A[j]);\n        rmax[A[i]] = -1;\n        for (int j = n; j > i; j--)\n            if (A[j] < A[i])\n                rmax[A[i]] = max(rmax[A[i]], A[j]);\n    }\n\n    /*for (int i = 1; i <= n; i++)\n        printf(\"%d \", lmin[i]);\n    printf(\"\\n\");\n    for (int i = 1; i <= n; i++)\n        printf(\"%d \", rmax[i]);\n    printf(\"\\n\");*/\n\n    for (int i = 0; i <= n; i++)\n        dp[i][n - i] = 0;\n    for (int sum = n - 1; sum >= 0; sum--)\n        for (int i = 0; i <= sum; i++) {\n            int j = sum - i;\n            dp[i][j] = l + dp[i + 1][j];\n            if (lmin[i + 1] >= n - j + 1)\n                dp[i][j] = min(dp[i][j], dp[i + 1][j]);\n            dp[i][j] = min(dp[i][j], r + dp[i][j + 1]);\n            if (rmax[n - j] <= i)\n                dp[i][j] = min(dp[i][j], dp[i][j + 1]);\n            //printf(\"!!!!!%d %d: %lld\\n\", i, j, dp[i][j]);\n        }\n    printf(\"%lld\\n\", dp[0][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nll dp[3][10010];\nint main() {\n    ll N, A, B; scanf(\"%lld%lld%lld\", &N, &A, &B);\n    vector<ll> P(N);\n    for(int i=0; i<N; i++) {\n        int v; scanf(\"%d\", &v); v--;\n        P[v] = i;\n    }\n\n    fill(dp[0], dp[2], LONGINF);\n    dp[0][0] = 0;\n    for(int i=0; i<N; i++) {\n        int cur = i % 2, nxt = cur ^ 1;\n        int pos = (P[i] << 1) | 1;\n        ll mi = LONGINF;\n        for(int j=0; j<=2*N; j++) {\n            chmin(mi, dp[cur][j]);\n            if(j % 2 == 1 and pos != j) continue;\n            ll C = 0;\n            if(pos < j) C = A;\n            if(pos > j) C = B;\n            chmin(dp[nxt][j], mi + C);\n        }\n        fill(dp[cur], dp[cur+1], LONGINF);\n    }\n    printf(\"%lld\\n\", *min_element(dp[N%2], dp[N%2] + 2*N + 1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 5050;\nconst Int INF = 1e17;\nInt dp[MAX][MAX];\nInt dp2[MAX][MAX];\nInt dp3[MAX][MAX];\n\nInt p[MAX];\nInt cnt1[MAX],cnt2[MAX];\n\nsigned main(){\n  Int n,a,b;\n  cin>>n>>a>>b;\n  for(Int i=0;i<n;i++) cin>>p[i];\n  \n  for(Int i=0;i<MAX;i++){\n    for(Int j=0;j<MAX;j++){\n      dp[i][j]=INF;\n      dp2[i][j]=0;\n      dp3[i][j]=0;\n    }\n  }\n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=0;i<n;i++){\n      for(Int j=p[i];j<=n+1;j++)\n        dp2[p[i]-1][j]=i-(cnt1[p[i]]+cnt2[j]);\n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  {\n    memset(cnt1,0,sizeof(cnt1));\n    memset(cnt2,0,sizeof(cnt2));\n    for(Int i=n-1;i>=0;i--){\n      for(Int j=0;j<=p[i];j++)\n        dp3[j][p[i]+1]=(n-(i+1))-(cnt2[p[i]]+cnt1[j]);\n      \n      for(Int j=p[i];j<=n+1;j++) cnt1[j]++;    \n      for(Int j=0;j<=p[i];j++) cnt2[j]++;\n    }\n  }\n  \n  dp[0][n+1]=0;\n  for(Int w=n+1;w>0;w--){\n    for(Int i=0;i+w<=n+1;i++){      \n      Int j=i+w;\n      //cout<<i<<\" \"<<j<<\":\"<<dp2[i][j]<<\" \"<<dp3[i][j]<<endl;\n      chmin(dp[i+1][j],dp[i][j]+(dp2[i][j]==0?0:b));\n      chmin(dp[i][j-1],dp[i][j]+(dp3[i][j]==0?0:a));\n      \n      // mettya mawasu\n      chmin(dp[i+1][j],dp[i][j]+dp2[i][j]*a);\n      chmin(dp[i][j-1],dp[i][j]+dp3[i][j]*b);\n    }\n  }\n  \n  Int ans=INF;\n  for(Int i=0;i<n;i++) chmin(ans,dp[i][i+1]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\n#define pb           push_back\n#define ff           first\n#define ss           second\n#define gcd(a, b)    __gcd(a, b)\n#define lcm(a, b)    ((a)*((b)/gcd(a,b)))\n#define all(v)       v.begin(),v.end()\n#define lllim        2147483648\n#define Pi           2*acos(0.0)\n#define sci(n)\t     scanf(\"%d\",&n)\n#define scii(n,m)    scanf(\"%d%d\",&n,&m)\n#define scl(n)       scanf(\"%lld\",&n)\n#define scll(n,m)    scanf(\"%lld%lld\",&n,&m)\n#define pii          pair<int,int>\n#define pll \t     pair<ll,ll>\n#define mem(a,b)     memset(a, b, sizeof(a))\n#define fill_(a,b)   fill(a,a+n,b);\n#define MOD          1000000007\n#define fast_cin     ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define filein       freopen(\"input.txt\",\"r\", stdin)\n#define watch(x)   \t cerr << __LINE__ << \": \" << #x << \" = \" << (x) << '\\n'\n\n/*------------------------------Graph Moves----------------------------*/\n//const int fx[]= {+1,-1,+0,+0};\n//const int fy[]= {+0,+0,+1,-1};\n//const int fx[]= {+0,+0,+1,-1,-1,+1,-1,+1};  // Kings Move\n//const int fy[]= {-1,+1,+0,+0,+1,+1,-1,-1}; // Kings Move\n//const int fx[]={-2, -2, -1, -1,  1,  1,  2,  2};  // Knights Move\n//const int fy[]={-1,  1, -2,  2, -2,  2, -1,  1}; // Knights Move\n/*---------------------------------------------------------------------*/\n\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int maxn=5005;\nint ara[maxn];\nint tree[maxn*3];\nint lazy[maxn*3];\n\nvoid init(int node,int b, int e)\n{\n    if(b==e)\n    {\n        tree[node]=ara[b];\n        return ;\n    }\n    int mid=(b+e)>>1;\n    int left=node<<1;\n    int right=left+1;\n    init(left, b,mid);\n    init(right,mid+1,e);\n    tree[node]=tree[left]+tree[right];\n}\nvoid update(int node,int b, int e, int i, int j,int value)\n{\n    if(lazy[node])\n    {\n        tree[node]+=(e-b+1)*lazy[node];\n        if(b!=e)\n        {\n            lazy[node*2]+=lazy[node];\n            lazy[node*2+1]+=lazy[node];\n        }\n        lazy[node]=0;\n    }\n    if(e<i or b>j) return ;\n    if(b>=i and e<=j)\n    {\n        tree[node]+=(e-b+1)*value;\n        if(b!=e)\n        {\n            lazy[node*2]+=value;\n            lazy[node*2+1]+=value;\n        }\n        return ;\n    }\n    int mid=(b+e)>>1;\n    int left=node<<1;\n    int right=left+1;\n    update(left, b,mid,i,j,value);\n    update(right,mid+1,e,i,j,value);\n    tree[node]=tree[left]+tree[right];\n}\nint  query(int node,int b, int e, int i,int j)\n{\n    if(lazy[node])\n    {\n        tree[node]+=(e-b+1)*lazy[node];\n        if(b!=e)\n        {\n            lazy[node*2]+=lazy[node];\n            lazy[node*2+1]+=lazy[node];\n        }\n        lazy[node]=0;\n    }\n    if(e<i or b>j) return 0;\n    if(b>=i and e<=j)\n    {\n        return tree[node];\n    }\n    int mid=(b+e)>>1;\n    int left=node<<1;\n    int right=left+1;\n    int x=query(left, b,mid,i,j);\n    int y=query(right,mid+1,e,i,j);\n    return x+y;\n}\nint  main()\n{\n    int n,a,b;\n    scanf(\"%d%d%d\",&n,&a,&b);\n\n    for(int i=1;i<=n;i++)\n    {\n        int num;\n        scanf(\"%d\",&num);\n        ara[num]=i;\n    }\n\n   // cout<<\" done\"<<endl;\n    init(1,1,n);\n\n    ll ans=0;\n\n    for(int i=n;i>=1;i--)\n    {\n        int pos1=query(1,1,n,i,i);\n\n        if(pos1<=0)\n        {\n            pos1=n+pos1;\n        }\n        if(pos1>n)\n        {\n            pos1=pos1-n;\n        }\n\n        //cout<<pos1<<\" \"<<i<<endl;\n\n        int ans1,ans2;\n\n        if(pos1==i)\n        continue;\n        if(pos1<i)\n        {\n            ans1=(i-pos1)*b;\n            ans2=(pos1 + n-i)*a;\n\n            if(ans1<ans2)\n            {\n                update(1,1,n,1,n,(i-pos1));\n            }\n            else\n            {\n                 update(1,1,n,1,n,(i-n-pos1));\n            }\n            ans+=min(ans1,ans2);\n        }\n\n    }\n\n    printf(\"%lld\",ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing ll = long long;\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nint const nmax = 5000;\nint const inf = 1000000000;\n\nint v[5 + nmax];\nll dp[5 + nmax];\n\nint main() {\n  int n, a, b;\n  std::cin >> n >> a >> b;\n  for(int i = 1; i <= n; i++)\n    std::cin >> v[i];\n  v[n + 1] = n + 1;\n  for(int i = 1; i <= n + 1; i++) {\n    int smax = -1, bigger = 0;\n    dp[i] = 1LL * nmax * inf;\n    for(int j = i - 1; 0 <= j; j--) {\n      if(v[j] < v[i] && smax < v[j]) { \n        dp[i] = std::min(dp[i], dp[j] + 1LL * bigger * a + 1LL * (i - j - 1 - bigger) * b);\n      }\n      if(v[j] < v[i])\n        smax = std::max(smax, v[j]);\n      else\n        bigger++;\n    }\n  }\n  std::cout << dp[n + 1];\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 5005\ninline long long min(long long x,long long y){return x<y?x:y;}\ninline long long max(long long x,long long y){return x<y?y:x;}\nint a[N],b[N],c[N],d[N],g[N],h[N],i,j,n,o,p;long long f[N],x;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&o,&p),x=0x3f3f3f3f3f3f3f3fll;\n\tfor(i=1;i<=n;i++)scanf(\"%d\",a+i),f[b[a[i]]=i]=x,g[i]=i-1,h[i]=i+1;\n\tfor(i=n;i;i--)c[i]=h[a[i]],h[g[a[i]]]=h[a[i]],g[h[a[i]]]=g[a[i]];\n\tfor(f[i=1]=0;i<=n;i++)g[i]=i-1,h[i]=i+1;\n\tfor(i=1;i<=n;i++)d[i]=g[a[i]],h[g[a[i]]]=h[a[i]],g[h[a[i]]]=g[a[i]];\n\tfor(j=n;--j;)for(i=n-j;i;i--)f[i+1]=min(f[i+1],f[i]+(i+j<c[b[i]]?0:p)),f[i]+=d[b[i+j]]<i?0:o;\n\tfor(i=1;i<=n;i++)x=min(x,f[i]);\n\treturn 0*printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define int long long\n#define rep(i,a,b) for(register int i=(a);i<=(b);++i)\n#define per(i,a,b) for(register int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef long long ll;\ninline void chkmax(int &x,int y){\n\tx<y?(x=y):0;\n}\ninline void chkmin(int &x,int y){\n\tx>y?(x=y):0;\n}\nconst int N=5005;\nint dp[N][N],a[N];\ninline int read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()){\n\t\tif(ch=='-'){\n\t\t\tf=-1;\n\t\t}\n\t}\n\tfor(;ch>='0'&&ch<='9';ch=getchar()){\n\t\tx=(x<<1)+(x<<3)+(ch^48);\n\t}\n\treturn x*f;\n}\nsigned main() {\n\tint n=read(),A=read(),B=read(),ans=1ll<<60;\n\trep(i,1,n){\n\t\ta[i]=read();\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(a[i]>j){\n\t\t\t\tchkmin(dp[i][j],dp[i-1][j]+A);\n\t\t\t\tchkmin(dp[i][a[i]],dp[i-1][j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchkmin(dp[i][j],dp[i-1][j]+B);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n){\n\t\tchkmin(ans,dp[n][i]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n9 40 50\n5 3 4 7 6 1 2 9 8\n*/\n\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <cstdlib>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <climits>\n#include <fstream>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <stack>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <ios>\n#include <iomanip>\n#include <functional>\n#include <array>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = a; i <= b; ++i)\n#define FORA(i, a) for (auto &i : a)\n#define FORB(i, a, b) for (int i = a; i >= b; --i)\n#define SZ(a) ((int) a.size())\n#define ALL(a) begin(a), end(a)\n\ntypedef int64_t ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n#define fi first\n#define se second\n\n// start of code\n\nconst int MAXN = 5007;\nconst ll INF = 1e17;\nll cost[MAXN][MAXN], dp[MAXN], A, B;\nint arr[MAXN], N;\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> N >> A >> B;\n\tFOR(i, 1, N) cin >> arr[i];\n\n\tarr[N + 1] = N + 1;\n\tFOR(i, 0, N) {\n\t\tll cur = 0;\n\t\tFOR(j, i + 1, N + 1) {\n\t\t\tcost[i][j] = cur;\n\t\t\tcur += (arr[i] < arr[j] ? A : B);\n\t\t}\n\t}\n\n\tFOR(i, 1, N + 1) {\n\t\tdp[i] = INF;\n\t\tFOR(j, 0, i - 1) if (arr[j] < arr[i]) {\n\t\t\tdp[i] = min(dp[i], dp[j] + cost[j][i]);\n\t\t}\n\t}\n\n\tcout << dp[N + 1] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define int long long\n#define rep(i, a, b) for (register int i=(a); i<=(b); ++i)\n#define per(i, a, b) for (register int i=(a); i>=(b); --i)\nusing namespace std;\ntypedef long long ll;\ninline void chkmax(int &x, int y){x<y?(x=y):0;}\ninline void chkmin(int &x, int y){x>y?(x=y):0;}\nconst int N=5005;\nint dp[N][N], a[N];\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*f;\n}\n\nsigned main()\n{\n    int n=read(), A=read(), B=read(), ans=1ll<<60;\n    rep(i, 1, n) a[i]=read();\n    memset(dp, 0x3f, sizeof(dp)); dp[0][0]=0;\n    rep(i, 1, n) rep(j, 0, n)\n        if (a[i]>j) \n            chkmin(dp[i][j], dp[i-1][j]+A), \n            chkmin(dp[i][a[i]], dp[i-1][j]);\n        else\n            chkmin(dp[i][j], dp[i-1][j]+B);\n    rep(i, 0, n) chkmin(ans, dp[n][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return a = std::min(a, b), a == b; }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return a = std::max(a, b), a == b; }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!==============================================================================================!//\n//!  dP   dP   dP                            dP            dP      8888ba.88ba             dP    !//\n//!  88   88   88                            88            88      88  '8b  '8b            88    !//\n//!  88  .8P  .8P .d8888b. dP   .dP .d8888b. 88 .d8888b. d8888P    88   88   88 .d8888b. d8888P  !//\n//!  88  d8'  d8' 88'  '88 88   d8' 88ooood8 88 88ooood8   88      88   88   88 88'  '88   88    !//\n//!  88.d8P8.d8P  88.  .88 88 .88'  88.  ... 88 88.  ...   88      88   88   88 88.  .88   88    !//\n//!  8888' Y88'   '88888P8 8888P'   '88888P' dP '88888P'   dP      dP   dP   dP '88888P8   dP    !//\n//!==============================================================================================!//\ntemplate <std::size_t L>\nclass WaveletMatrix\n{\npublic:\n    using T = unsigned long long;\n    template <typename InIt>\n    WaveletMatrix(const InIt first, const InIt last) : sz(std::distance(first, last))\n    {\n        std::vector<bool> b(sz);\n        std::vector<T> v(first, last);\n        for (std::size_t i = 0, j = L - 1; i < L; i++, j--) {\n            std::vector<T> z, o;\n            for (std::size_t i = 0; i < sz; i++) { b[i] = (v[i] >> j) & 1, (b[i] ? o : z).push_back(v[i]); }\n            table.push_back(FID{b}), v = z, zero.push_back(z.size());\n            for (const T e : o) { v.push_back(e); }\n        }\n    }\n    std::size_t noLessThan(std::size_t l, std::size_t r, const T v) const\n    {\n        assert(l < r);\n        std::size_t ans = 0;\n        for (std::size_t i = 0, j = L - 1; i < L; i++, j--) {\n            const bool b = (v >> j) & 1;\n            const std::size_t rl = table[i].rank(l), rr = table[i].rank(r);\n            l = (b ? rl + zero[i] : l - rl), r = (b ? rr + zero[i] : r - rr), ans += (b ? 0 : rr - rl);\n        }\n        return r - l + ans;\n    }\n    std::size_t lessThan(const std::size_t l, const std::size_t r, const T v) const { return assert(l < r), r - l - noLessThan(l, r, v); }\n    std::size_t rangeFreq(const std::size_t l, const std::size_t r, const T vinf, const T vsup) const { return assert(l < r), assert(vinf < vsup), noLessThan(l, r, vinf) - noLessThan(l, r, vsup); }\n    std::size_t rank(const std::size_t l, const std::size_t r, const T v) const { return assert(l < r), rangeFreq(l, r, v, v + 1); }\n    T quantile(std::size_t l, std::size_t r, std::size_t k) const\n    {\n        assert(l < r);\n        std::size_t ans = 0;\n        for (std::size_t i = 0, j = L - 1; i < L; i++, j--) {\n            const std::size_t rl = table[i].rank(l), rr = table[i].rank(r);\n            const bool b = rr - rl > k;\n            l = (b ? rl + zero[i] : l - rl), r = (b ? rr + zero[i] : r - rr), k += (b ? 0 : k -= rr - rl), ans |= ((std::size_t)b << j);\n        }\n        return ans;\n    }\n\nprivate:\n    class FID\n    {\n    private:\n        using B = unsigned long long;\n        static constexpr std::size_t BS = sizeof(B) * 8;\n        const std::size_t sz;\n        std::vector<B> data;\n        std::vector<std::size_t> large;\n\n    public:\n        FID(const std::vector<bool>& b) : sz(b.size()), data((sz + BS) / BS, 0), large((sz + BS) / BS, 0)\n        {\n            std::size_t one = 0;\n            for (std::size_t i = 0; i < sz; i++) {\n                data[i / BS] |= ((B)b[i] << (i % BS)), one += b[i];\n                if (i % BS == BS - 1) { large[(i + 1) / BS] = one; }\n            }\n        }\n        bool operator[](const std::size_t n) const { return (data[n / BS] >> (n % BS)) & 1; }\n        std::size_t rank(const std::size_t n) const { return large[n / BS] + (n % BS == 0 ? 0 : popCount(data[n / BS] & ((1ULL << (n % BS)) - 1))); }\n    };\n    const std::size_t sz;\n    std::vector<std::size_t> zero;\n    std::vector<FID> table;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>();\n    const ll A = read<ll>(), B = read<ll>();\n    std::vector<int> p(N + 2, 0), r(N + 2, N + 1);\n    p[0] = r[0] = 0, p[N + 1] = r[N + 1] = N + 1;\n    std::vector<ll> C(N);\n    for (int i = 1; i <= N; i++) { std::cin >> p[i], r[p[i]] = i; }\n    SHOW(p, r);\n    WaveletMatrix<13> wm(p.begin(), p.end());\n    std::vector<ll> dp(N + 2, INF<ll>);\n    dp[0] = 0LL;\n    for (int v = 1; v <= N + 1; v++) {\n        const int i = r[v];\n        for (int j = 0; j < i; j++) {\n            if (p[j] > p[i]) { continue; }\n            ll cost = dp[j] + (ll)wm.noLessThan(j + 1, i + 1, p[i] + 1) * A + (ll)wm.lessThan(j + 1, i + 1, p[j]) * B + (ll)wm.rangeFreq(j + 1, i + 1, p[j], p[i]) * std::max(A, B);\n            chmin(dp[i], cost);\n        }\n        SHOW(v, i, dp);\n    }\n    std::cout << dp[N + 1] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n#define int long long\nconst int N = 5555;\nint n, A, B, a[N], id[N], dp[N][N];\n\ninline void U(int &x, int y) {\n    x = min(x, y);\n}\n\nsigned main(void) {\n    read(n); read(A); read(B);\n    swap(A, B);\n    rep (i, n) read(a[i]), id[a[i]] = i;\n    memset(dp, 38, sizeof dp);\n    int tmp = dp[0][0];\n    dp[0][0] = 0;\n    for (int i = 1; i <= n; i++)\n        for (int pre = 0; pre <= n; pre++)\n            if (dp[i - 1][pre] != tmp) {\n                int np = id[i];\n                if (np > pre) {\n                    U(dp[i][np], dp[i - 1][pre]);\n                    U(dp[i][pre], dp[i - 1][pre] + A);\n                } else {\n                    U(dp[i][pre], dp[i - 1][pre] + B);\n                }\n            }\n    // rep (i, n) re0 (pre, n + 1) {\n    //     if (dp[i][pre] != tmp)\n    //         printf(\"dp[%lld][%lld] = %lld\\n\", i, pre, dp[i][pre]);\n    // }\n    int ans = 1e18;\n    for (int pre = 0; pre <= n; pre++)\n        U(ans, dp[n][pre]);\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 5014;\nLL A,B;\nint p[SIZE],pos[SIZE];\nint need_ll[SIZE][SIZE],need_rr[SIZE][SIZE];\nLL dp[SIZE][SIZE];\nint main(){\n    int N; R(N);\n    R(A,B);\n    FOR(i,1,N){\n        R(p[i]);\n        pos[p[i]]=i;\n    }\n    FOR(i,1,N){\n        for(int j=i-1;j>0;j--){\n            need_rr[j][i]=need_rr[j+1][i];\n            if(pos[j]>pos[i])need_rr[j][i]++;\n        }\n        FOR(j,i+1,N){\n            need_ll[i][j]=need_ll[i][j-1];\n            if(pos[j]<pos[i])need_ll[i][j]++;\n        }\n    }\n    FOR(len,1,N-1){\n        for(int ll=1;ll+len<=N;ll++){\n            int rr=ll+len;\n            dp[ll][rr]=min(dp[ll+1][rr]+min(B,A*need_ll[ll][rr]),dp[ll][rr-1]+min(A,B*need_rr[ll][rr]));\n        }\n    }\n    W(dp[1][N]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 5010\n#define inf 1000000000000000ll\nint n,A,B; ll f[N][N<<1];\nstruct data { int x,y; bool operator <(const data&a) const { return x<a.x||x==a.x&&y<a.y; } }a[N];\nsigned main() {\n\tscanf(\"%d%d%d\",&n,&A,&B); for (int i=1;i<=n;i++) scanf(\"%d\",&a[i].x),a[i].y=i;\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++){ll s=inf;for(int j=0;j<=n*2;j++){s=min(s,f[i-1][j]);if(j&1){f[i][j]=s+((j+1>>1)==a[i].y?0:((j+1>>1)<a[i].y?B:A));}else{f[i][j]=s+(((j>>1)<a[i].y?B:A));}}}\n    ll ans=inf;\n    for (int i=0;i<=n*2;i++) ans=min(ans,f[n][i]);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 5005;\nint a[MAXN];\nint f[MAXN][MAXN];\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, A, B; read(n), read(A), read(B);\n  for (RI i = 1; i <= n; ++i) read(a[i]);\n  memset(f, 0x3f, sizeof(f));\n  f[0][0] = 0;\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 0; j <= n; ++j)\n      if (a[i] > j) {\n        f[i][j] = min(f[i][j], f[i - 1][j] + A);\n        f[i][a[i]] = min(f[i][a[i]], f[i - 1][j]);\n      }\n      else {\n        f[i][j] = min(f[i][j], f[i - 1][j] + B);\n      //  f[i][a[i]] = min(f[i][a[i]], f[i - 1][j] + A);\n      }\n  int ans = 0x7f7f7f7f;\n  for (RI i = 0; i <= n; ++i)\n    ans = min(ans, f[n][i]);\n  printf(\"%d\\n\", ans);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <numeric>\n#include <cassert>\n#include <array>\n#include <memory>\n#include <random>\n#include <functional>\n#include <complex>\n#ifdef DEBUG\n#include \"./Lib/debug.hpp\"\n#include \"./Lib/Timer.hpp\"\n#include \"./Lib/sample.hpp\"\n#else\n#define dump(...)\n#endif\n\n/* (=＾o＾=) */\n//#define int ll\n\n/* macro */\n#define FOR(i, b, e) for(ll i = (ll)(b); i < (ll)(e); ++i)\n#define RFOR(i, b, e) for(ll i = (ll)(e-1); i >= (ll)(b); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n#define REPC(x,c) for(const auto& x:(c))\n#define REPI2(it,b,e) for(auto it = (b); it != (e); ++it)\n#define REPI(it,c) REPI2(it, (c).begin(), (c).end())\n#define RREPI(it,c) REPI2(it, (c).rbegin(), (c).rend())\n#define REPI_ERACE2(it, b, e) for(auto it = (b); it != (e);)\n#define REPI_ERACE(it, c) REPI_ERACE2(it, (c).begin(), (c).end())\n#define ALL(x) (x).begin(),(x).end()\n#define cauto const auto&\n/* macro func */\ntemplate<class T>\ninline void sort(T& t) { std::sort(ALL(t)); }\ntemplate<class T>\ninline void rsort(T& t) { std::sort((t).rbegin(), (t).rend()); }\ntemplate<class T>\ninline void unique(T& t) { (t).erase(unique((t).begin(), (t).end()), (t).end()); }\ntemplate<class T, class S>\ninline bool chmax(T& t, const S& s) { if (s > t) { t = s; return true; } return false; }\ntemplate<class T, class S>\ninline bool chmaxE(T& t, const S& s) { if (s >= t) { t = s; return true; } return false; }\ntemplate<class T, class S>\ninline bool chmin(T& t, const S& s) { if (s < t) { t = s; return true; } return false; }\ninline void BR() { std::cout << \"\\n\"; }\n\n/* type define */\nusing ll = long long;\nusing PAIR = std::pair<ll, ll>;\nusing VS = std::vector<std::string>;\nusing VL = std::vector<long long>;\nusing VVL = std::vector<VL>;\nusing VVVL = std::vector<VVL>;\nusing VD = std::vector<double>;\ntemplate<class T>\nusing V = std::vector<T>;\n\n/* using std */\nusing std::cout;\nconstexpr char endl = '\\n';\nusing std::cin;\nusing std::pair;\nusing std::string;\nusing std::stack;\nusing std::queue;\nusing std::vector;\nusing std::list;\nusing std::map;\nusing std::unordered_map;\nusing std::multimap;\nusing std::unordered_multimap;\nusing std::set;\nusing std::unordered_set;\nusing std::unordered_multiset;\nusing std::multiset;\nusing std::bitset;\nusing std::priority_queue;\nusing std::tuple;\n\n/* constant value */\n//constexpr ll MOD = 1000000007;\nconstexpr ll MOD = 998244353;\n\n/* Initial processing  */\nstruct Preprocessing { Preprocessing() { std::cin.tie(0); std::ios::sync_with_stdio(0); }; }_Preprocessing;\n\n/* Remove the source of the bug */\ninline signed pow(signed, signed) { assert(false); return -1; }\n\n/* define hash */\nnamespace std {\ntemplate <>\tclass hash<std::pair<ll, ll>> { public:\tsize_t operator()(const std::pair<ll, ll>& x) const { return hash<ll>()(1000000000 * x.first + x.second); } };\n}\n\n/* input */\ntemplate<class T> std::istream& operator >> (std::istream& is, vector<T>& vec) { for (T& x : vec) is >> x; return is; }\n\n//=============================================================================================\n\nclass RangeMin {\n\tVL m_array;\n\n\tauto construct(const VL& v) {\n\t\tVL mn = v;\n\t\tFOR(i, 1, v.size()) {\n\t\t\tchmin(mn[i], mn[i - 1]);\n\t\t}\n\t\treturn mn;\n\t}\npublic:\n\n\tRangeMin(const VL& v) :m_array(construct(v)) {}\n\n\tauto get(ll r) {\n\t\treturn m_array[r];\n\t}\n};\nsigned main() {\n\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tVL p(n);\n\tcin >> p;\n\n\n\tVL dp(n + 2);\n\tset<ll> s;\n\ts.emplace(-1);\n\tREP(i, n) {\n\t\tauto mn = RangeMin(dp);\n\t\tREP(j, n + 2) {\n\t\t\tll mx = *(--s.lower_bound(j));\n\t\t\tdp[j] = mn.get(j) + (\n\t\t\t\t(j <= p[i]) ? +a :\n\t\t\t\t(mx > p[i]) ? +b : 0);\n\t\t}\n\t\ts.emplace(p[i]);\n\t\tdump(dp);\n\t}\n\tll ans = 1e10;\n\tREPC(x, dp) { chmin(ans, x); }\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\n\nlong long dp[5010], ndp[5010];\nint a[5010], pos[5010];\n\nvoid chmin(long long &a, long long b){a = a < b ? a : b;}\n\nstruct Segment_tree{\n\tlong long minj[20010], lazy[20010];\n\tvoid pushup(int now){\n\t\tminj[now] = min(minj[now << 1], minj[now << 1 | 1]);\n\t}\n\tvoid pushdown(int now){\n\t\tif (lazy[now] == INF) return ;\n\t\tlong long v = lazy[now]; lazy[now] = INF;\n\t\tchmin(minj[now << 1], v);\n\t\tchmin(lazy[now << 1], v);\n\t\tchmin(minj[now << 1 | 1], v);\n\t\tchmin(lazy[now << 1 | 1], v);\n\t}\n\tvoid Build(int now, int l, int r){\n\t\tmemset(minj, 0x3f, sizeof(minj));\n\t\tmemset(lazy, 0x3f, sizeof(lazy));\n\t}\n\tvoid Update(int now, int l, int r, int L, int R, long long x){\n\t\tif (l == L && r == R){\n\t\t\tchmin(minj[now], x);\n\t\t\tchmin(lazy[now], x);\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(now);\n\t\tint mid = l + r >> 1;\n\t\tif (R <= mid) Update(now << 1, l, mid, L, R, x);\n\t\telse if (L > mid) Update(now << 1 | 1, mid + 1, r, L, R, x);\n\t\telse Update(now << 1, l, mid, L, mid, x), Update(now << 1 | 1, mid + 1, r, mid + 1, R, x);\n\t\tpushup(now);\n\t}\n\tvoid get_dp(int now, int l, int r){\n\t\tif (l == r){\n\t\t\tdp[l] = minj[now];\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(now);\n\t\tint mid = l + r >> 1;\n\t\tget_dp(now << 1, l, mid), get_dp(now << 1 | 1, mid + 1, r);\n\t}\n}seg;\n\nint main(){\n\tint n, A, B;\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tpos[a[i]] = i + 1;\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tfor (register int i = 1; i <= n; i++){\n\t\tint x = pos[i];\n\t\tlong long minj = INF;\n\t\tfor (register int j = 0; j <= n; j++){\n\t\t\tminj = min(minj, dp[j]);\n\t\t\tdp[j] = minj + (j < x ? B : j > x ? A : 0);\n\t\t}\n\t}\n\tlong long ans = INF;\n\tfor (int i = 0; i <= n; i++){\n\t\tchmin(ans, dp[i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct BIT{\nprivate:\n  vector<int> array;\n  int n;\npublic:\n  BIT(int _n):array(_n+1,0),n(_n){}\n\n  int sum(int i){\n    int s=0;\n    i++;\n    while(i>0){\n      s+=array[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  int add(int i){\n    i++;\n    while(i<=n){\n      array[i]++;\n      i+=i&-i;\n    }\n  }\n};\n\nint main(){\n  LL n,a,b;\n  cin >> n >> a >> b;\n  vector<int> p(n);\n  vector<int> pos(n);\n  for(int i=0;i<n;i++){\n    cin >> p[i];\n    p[i]--;\n    pos[p[i]]=i;\n  }\n  vector<vector<LL>> dp(n,vector<LL>(n,0));\n  BIT bit(n);\n  bit.add(pos[0]);\n  for(int i=1;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(pos[i]>j) dp[i][j]=dp[i-1][j];\n      else{\n        dp[i][j]=min((bit.sum(j)-bit.sum(pos[i])==0?0:a)+dp[i-1][j],b*(bit.sum(j)-bit.sum(pos[i]))+(pos[i]>0?dp[i-1][pos[i]-1]:0));\n      }\n      // cout << dp[i][j] << \" \";\n    }\n    bit.add(pos[i]);\n    // cout << endl;\n  }\n  cout << dp[n-1][n-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n//const int mod = 998244353;\nconst int N = 7005;\nconst int K = 1000000;\nvector < int > ls[N], rs[N];\nint dp[N][N], p[N][N], c[N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int b, a, n;\n    cin >> n >> a >> b;\n    for (int i = 0; i <= n; i++){\n        for (int j = 0; j <= n; j++){\n            if (i == 0 && j == 0) continue;\n            dp[i][j] = 1e16;\n        }\n    }\n    for (int i = 1; i <= n; i++) cin >> c[i];\n    for (int i = 1; i <= n; i++){\n        for (int j = 0; j <= n; j++){\n            if (c[i] == j){\n                dp[i][j] = p[i - 1][j];\n            } else{\n                if (i < c[i]){\n                    dp[i][j] = dp[i - 1][j] + a;\n                }\n                if (i > c[i]){\n                    dp[i][j] = dp[i - 1][j] + b;\n                }\n                if (i == c[i]){\n                    dp[i][j] = dp[i - 1][j] + min(a, b);\n                }\n            }\n            if (j != 0)\n                p[i][j] = min(p[i][j - 1], dp[i][j]); else\n                p[i][j] = dp[i][j];\n        }\n    }\n    int ans = 1e18;\n    for (int i = 0; i <= n; i++){\n        ans = min(ans, dp[n][i]);\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll inf = (ll)2e16;\nconst ll maxn = (ll)5e3 + 10;\n\nll dp[maxn];\nll inv[maxn];\nll p[maxn];\nll n, a, b;\n\n\nvoid solve(){\n    fill(dp, dp + maxn, inf);\n    cin >> n >> a >> b;\n    for(ll i = 0; i < n; ++i){\n        cin >> p[i];\n    }\n    p[n] = n;\n    for(ll i = 0; i <= n; ++i){\n        inv[p[i]] = i;\n    }\n    for(ll i = 0; i <= n; ++i){\n        ll adda = 0, addb = 0;\n        for(ll j = p[i] - 1; j >= -1; --j){\n            if(j == -1){\n                dp[i] = min(dp[i], adda * a + addb * b);\n            }\n            dp[i] = min(dp[i], dp[inv[j]] + adda * a + addb * b);\n            if(j != p[i]){\n                if(inv[j] < i){\n                    adda++;\n                } else if(inv[j] > i) {\n                    addb++;\n                }\n            }\n        }\n    }\n    cout << dp[n] << \"\\n\";\n}\n\nsigned main(){\n    srand(time(0));\n    ll t = 1;\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    #ifdef DEBUG\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    #else\n\n    #endif// DEBUG\n    while(t--){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long INF = 1e18;\n\nint n, a, b;\nint f[5001];\nlong long dp[5001][5001];\n\nlong long solve(int i, int prv) {\n\tif (i == n) return 0;\n\tif (dp[i][prv] != -1) return dp[i][prv];\n\n\tlong long ans = INF;\n\tif (f[i] < prv) {\n\t\tans = min(ans, solve(i+1, prv) + b);\n\t} else {\n\t\tans = min(ans, solve(i+1, f[i]));\n\t\tans = min(ans, solve(i+1, prv) + a);\n\t}\n\treturn dp[i][prv] = ans;\n}\n\nsigned main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\t\n\tcin >> n >> a >> b;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> f[i];\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tcout << solve(0, 0) << '\\n';\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=5005;\nconst long long INF=4557430888798830399;\nint n,A,B;\nint a[N];\nlong long dp[N][N];\nlong long ans=INF;\nint main()\n{\n    memset(dp,63,sizeof(dp));\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n        \tif(a[i]>j) dp[i][j]=min(dp[i][j],dp[i-1][j]+A),dp[i][a[i]]=min(dp[i][a[i]],dp[i-1][j]);\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n\tfor(int i=0;i<=n;i++)\n\t\tans=min(ans,dp[n][i]);\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  ll n, a, b;\n  cin >> n >> a >> b;\n  vi p_(n);\n  rep (i, n) {\n    cin >> p_[i];\n    p_[i]--;\n  }\n  //DEBUG(a); DEBUG(b);\n  \n  ll ans = INF;\n  rep (aaa, 2) {\n    vi p = p_;\n    if (aaa == 1) {\n      swap(a, b);\n      rep (i, n) {\n        p[i] = n - p[i];\n      }\n    }\n    vl dp(n + 1, INF);\n    dp[0] = 0;\n    rep (i, n) {\n      rep (j, p.size()) {\n        if (p[j] == i) {\n          chmin(dp[i + 1], dp[i] + b);\n          int k;\n          for (k = 0; j + k < n; k++) {\n            if (p[j + k] != i + k) break;\n          }\n          //DEBUG(k);\n          chmin(dp[i + k], dp[i] + a * j);\n          p.erase(p.begin() + j);\n          break;\n        }\n      }\n    }\n    chmin(ans, dp[n]);\n  }\n  //DEBUG_VEC(dp);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n#define int long long\nconst int N = 3e5 + 233;\nint n, A, B, a[N], dp[N];\nsigned main(void) {\n    read(n); read(A); read(B);\n    rep (i, n) read(a[i]);\n    memset(dp, 38, sizeof dp);\n    dp[0] = 0;\n    rep (i, n) {\n        int f = 0;\n        for (int k = 1; k < i; k++)\n            f += a[k] < a[i];\n        dp[i] = dp[i - 1] + (f == a[i] - 1 ? 0 : B);\n        int p = 0;\n        for (int k = i - 1; k >= 1; k--) {\n            p += a[k] > a[i];\n            dp[i] = min(dp[i], dp[k - 1] + p * A);\n        }\n    }\n    cout << dp[n] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\n\nstruct BIT {\nprivate:\n\tvector<ll> node; int n;\npublic:\n\tBIT(int n_) {\n\t\tn = n_; node.resize(n, 0);\n\t}\n\t//0-indexed\n\tvoid add(int a, ll w) {\n\t\tfor (int i = a; i < n; i |= i + 1)node[i] += w;\n\t}\n\t//[0,a)\n\tll sum(int a) {\n\t\tll ret = 0;\n\t\tfor (int i = a - 1; i >= 0; i = (i&(i + 1)) - 1)ret += node[i];\n\t\treturn ret;\n\t}\n\t//[a,b)\n\tll sum(int a, int b) {\n\t\treturn sum(b) - sum(a);\n\t}\n};\nint p[5000];\nint invp[5001];\n\n//左がl,右が次r\nint le[5000][5000];\nint ri[5000][5000];\n\nbool used[5000][5000];\nll ans[5000][5000];\nll a, b;\nll dfs(int l, int r) {\n\tif (used[l][r])return ans[l][r];\n\tused[l][r] = true;\n\tif (l == r)return 0;\n\tll lef = min(b, a*le[l][r]) + dfs(l + 1, r);\n\tll rif = min(a, b*ri[r][l]) + dfs(l, r - 1);\n\treturn ans[l][r] = min(lef, rif);\n}\nvoid solve() {\n\tint n; cin >> n >> a >> b;\n\tBIT ble(n + 1),bri(n+1);\n\trep(i, n) {\n\t\tcin >> p[i]; p[i]--; invp[p[i]] = i;\n\t}\n\trep(i, n) {\n\t\tint id = invp[i];\n\t\tint loc = ble.sum(id);\n\t\tle[i][n-1] = id - loc;\n\t\tfor (int j = n - 2; j >= i; j--) {\n\t\t\tle[i][j] = le[i][j + 1];\n\t\t\tint nid = invp[j+1];\n\t\t\tif (nid < id) {\n\t\t\t\tle[i][j]--;\n\t\t\t}\n\t\t}\n\t\tble.add(id, 1);\n\t}\n\tper(i, n) {\n\t\tint id = invp[i];\n\t\tint loc = bri.sum(id);\n\t\tint cnt = n - 1 - id;\n\t\tcnt -= n - 1 - i - loc;\n\t\tri[i][0] = cnt;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tri[i][j] = ri[i][j - 1];\n\t\t\tint nid = invp[j - 1];\n\t\t\tif (nid > id) {\n\t\t\t\tri[i][j]--;\n\t\t\t}\n\t\t}\n\t\tbri.add(id, 1);\n\t}\n\tcout << dfs(0, n - 1) << endl;\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define IN freopen(\"dichromatic.in\",\"r\",stdin)\n#define OUT freopen(\"dichromatic.out\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 1000000000\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define sq(x)  ((x)*(x))\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\n#define maxn 200005\n#define mod 1000000007LL\n\ntypedef  long long int T ;\n\ni64 dp[5005][5005] , cnt[5005][5005] , a[5005] ;\n\nint main()\n{\n    int n ;\n    i64 A , B ;\n\n    scanf(\"%d %lld %lld\",&n,&A,&B) ;\n\n    for(int i=1 ; i<=n ; i++) scanf(\"%lld\",&a[i]) ;\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        for(int j=1 ; j<=n ; j++) cnt[i][j] = cnt[i-1][j] ;\n        for(int j=a[i]-1 ; j>=1 ; j--) cnt[i][j]++ ;\n    }\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        for(int j=1 ; j<=n ; j++)\n        {\n            if( a[i] > j ) dp[i][j] = dp[i-1][j] ;\n            else dp[i][j] = min( B+dp[i-1][ j ] , (cnt[i][a[i]]-cnt[i][j])*A + dp[i-1][ a[i] ] ) ;\n        }\n    }\n\n    printf(\"%lld\\n\",dp[n][n]) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 100000000000000;\n\tcin >> N >> A >> B;\n\tvector<long long> P(N);\n\tvector<vector<long long> > DP(N + 1, vector<long long>(N + 1, INF));\n\tDP[0][0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (DP[i][j] >= INF) continue;\n\t\t\tif (j < P[i]) {\n\t\t\t\tDP[i + 1][P[i]] = min(DP[i + 1][P[i]], DP[i][j]);\n\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + A);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + B);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[N][i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\n#define int long long\n\nconst int N = 5e3 + 7;\n\nint dp[N][N];\nint n, a, b;\nint p[N], pnt[N];\n\nint32_t main() {\n\tmakefast;\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> p[i], pnt[p[i]] = i;\n\tfor (int i = n; i >= 1; i--) {\n\t\tset <int> s;\n\t\ts.insert(0);\n\t\tfor (int j = i; j <= n; j++)\n\t\t\ts.insert(p[j]);\n\t\tint lst = *s.rbegin();\n\t\tint mn = pnt[lst];\n\t\tint x = lst;\n\t\ts.erase(lst);\n\t\tint cnt = 0;\n\t\twhile (lst) {\n\t\t//\tcout << endl << endl << i << \" LST : \" << lst << \" X : \" << x << \" \" << cnt << endl;\n\t\t\tfor (int j = lst; j > *s.rbegin(); j--) {\n\t\t\t\tdp[i][j] = min(dp[mn + 1][lst] + a, dp[mn + 1][x + 1] + b * cnt);\n\t\t//\t\tcout << i << \" \" << j << \" > \" << dp[i][j] << \" \" << dp[mn + 1][1] + a << \" & \" << dp[mn + 1][x + 1] + b * cnt << endl;\n\t\t\t}\n\t\t\tlst = *s.rbegin();\n\t\t\tif (pnt[lst] < mn) {\n\t\t\t\tmn = pnt[lst];\n\t\t\t\tx = lst;\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t\telse\t\n\t\t\t\tcnt++;\n\t\t\ts.erase(lst);\n\t\t}\n\t}\n\tcout << dp[1][1];\n\n\treturn 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\nll a,b;\nint p[5252];\nint rev[5252];\npii mx[5252][5252], mn[5252][5252];\n\nll dp[5252][5252];\nint rmost[5252][5252];\nint lmost[5252][5252];\nint cnt[5252][5252];\n\nint main(){\n  scanf(\"%d%lld%lld\",&n,&a,&b);\n  REP(i,n)scanf(\"%d\",p+i),p[i]--;\n  REP(i,n)rev[p[i]] = i;\n  REP(i,5252)REP(j,5252)dp[i][j] = 1ll<<60;\n  REP(i,n+1)dp[i][i] = 0;\n\n  REP(i,n)rmost[p[i]][p[i]] = i;\n  REP(i,n)lmost[p[i]][p[i]] = i;\n  FOR(len,2,n+1)REP(low,n-len+1){\n    int high = low+len-1;\n    rmost[low][high] = max(rmost[low][high-1], rmost[low+1][high]);\n    lmost[low][high] = min(lmost[low][high-1], lmost[low+1][high]);\n  }\n  REP(l,n){\n    pii xx = pii(p[l], l);\n    pii nn = pii(p[l], l);\n    FOR(r,l+1,n+1){\n      mx[l][r] = xx;\n      mn[l][r] = nn;\n      if(r==n)break;\n      pii pp = pii(p[r], r);\n      CHMAX(xx, pp);\n      CHMIN(nn, pp);\n    }\n  }\n\n  REP(i,n){\n    int v = p[i];\n    FOR(j,v+1,n+10)cnt[i+1][j]++;\n  }\n  REP(i,n+1)REP(j,n+1)cnt[i+1][j] += cnt[i][j];\n\n  FOR(len,2,n+1)REP(low,n-len+1){\n    int high = low+len-1;\n    int lft = lmost[low][high];\n    int rgt = rmost[low][high];\n    // printf(\"low:%d, high:%d (%d %d)\\n\",low,high,lft,rgt);\n    // high move\n    {\n      int pos = rev[high];\n      // left\n      CHMIN(dp[low][high], dp[low][high-1] + a);\n      // right\n      int x = cnt[rgt+1][high] - cnt[pos][high];\n      x -= cnt[rgt+1][low] - cnt[pos][low];\n      // printf(\"x: %d(%d: %d %d %d %d), \",x,pos,cnt[rgt+1][high],cnt[pos][high],cnt[rgt+1][low],cnt[pos][low]);\n      int nxtlow = mn[lft][pos].first;\n      int nxthigh = mx[lft][pos].first;\n      CHMIN(dp[low][high], dp[nxtlow][nxthigh] + b*x);\n    }\n    // low move\n    {\n      int pos = rev[low];\n      // right\n      CHMIN(dp[low][high], dp[low+1][high] + b);\n      // left\n      int x = cnt[pos][high+1] - cnt[lft][high+1];\n      x -= cnt[pos][low] - cnt[lft][low];\n      // printf(\"x: %d, \",x);\n      int nxtlow = mn[pos+1][rgt+1].first;\n      int nxthigh = mx[pos+1][rgt+1].first;\n      CHMIN(dp[low][high], dp[nxtlow][nxthigh] + a*x);\n    }\n    // printf(\"ans: %lld\\n\",dp[low][high]);\n  }\n\n  printf(\"%lld\\n\",dp[0][n-1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000021\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 5010\n\n\n\nint main() {\n\tlong long dp[N];\n\tlong long a[N];\n\tlong long llc[N];\n\tlong long n;\n\tlong long x, y, z, ca, cb;\n\tscanf(\"%lld %lld %lld\", &n, &ca, &cb);\n\tf(i, n)scanf(\"%lld\", &a[i]);\n\tf(i, N)dp[i] = 100000000000000000;\n\tdp[0] = 0;\n\tf(i,n) {\t\n\t\tx = 100000000000000000;\n\t\tf(j, a[i]) {\n\t\t\tx = min(x, dp[j]);\n\t\t}\n\t\tdp[a[i]] = x;\n\t\tf(j, a[i])dp[j] += ca;\n\t\tfor (long long j = a[i] + 1; j <= n; j++) {\n\t\t\tdp[j] += cb;\n\t\t}\n\t}\n\tx = 100000000000000000;\n\tf(i, n + 1)x = min(x, dp[i]);\n\tprintf(\"%lld\\n\", x);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\nconst int maxn=5005;\nint n,a,b;\nll dp[maxn];\nint main(){\n    ios::sync_with_stdio(0);\n    memset(dp,0x3f,sizeof(dp));dp[0]=0;\n    cin>>n>>a>>b;\n    rep(i,1,n){\n        int num;cin>>num;\n        ll mi=1e18;\n        rep(j,0,num)mi=min(mi,dp[j]);\n        rep(j,0,num-1)dp[j]+=a;\n        rep(j,num+1,n)dp[j]+=b;\n        dp[num]=min(dp[num],mi);\n    }\n    ll ans=1e18;\n    rep(i,1,n)ans=min(ans,dp[i]);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define pb push_back\n#define mkp make_pair\n#define pa pair<int,int>\nconst int N=1e5+10;\nconst int mod=1e9+7;\nusing namespace std;\n\nint a[5005];\nll dp[5005];\nint main()\n{   \n    ll n,A,B; scanf(\"%lld%lld%lld\",&n,&A,&B);\n    for(int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n    a[n+1]=n+1;\n  for(int i=1;i<=n+1;++i)\n  {\n     dp[i]=1e18;\n     int big=0;\n     for(int j=i-1;j>=0;j--) \n     {\n       if(a[i]<a[j]) big++;\n       else dp[i]=min(dp[i],dp[j]+A*big+B*(i-1-j-big));\n     }\n  }\n  printf(\"%lld\\n\",dp[n+1]);\nreturn 0;\n}\n/*\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nint main(){\n    ll n,a,b;cin>>n>>a>>b;\n    vi v(n);\n    rep(i,n)cin>>v[i];\n    rep(i,n)v[i]--;\n    vi l(n,inf),r(n,-inf);\n    rep(i,n)REP(j,i+1,n)if(v[i]>v[j])chmin(l[j],v[i]);\n    rep(i,n)rep(j,i)if(v[i]<v[j])chmax(r[j],v[i]);\n    vvi dp(n+1,vi(n+1,inf));\n    dp[0][0]=0;\n    vi id(n);\n    rep(i,n)id[v[i]]=i;\n    rep(i,n+1){\n        rep(j,n+1){\n            //if(i+j>=n)break;\n            if(i<n){\n                if(l[id[i]]<=n-j)chmin(dp[i+1][j],dp[i][j]+b);\n                else chmin(dp[i+1][j],dp[i][j]);\n            }\n            if(j<n){\n                if(r[id[n-j-1]]>=i)chmin(dp[i][j+1],dp[i][j]+a);\n                else chmin(dp[i][j+1],dp[i][j]);\n            }\n        }\n    }\n    ll ans=inf;\n    rep(i,n+1)chmin(ans,dp[i][n-i]);\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return a = std::min(a, b), a == b; }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return a = std::max(a, b), a == b; }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>();\n    const ll A = read<ll>(), B = read<ll>();\n    std::vector<int> p(N + 2, 0), r(N + 2, N + 1);\n    p[0] = r[0] = 0, p[N + 1] = r[N + 1] = N + 1;\n    std::vector<ll> C(N);\n    for (int i = 1; i <= N; i++) { std::cin >> p[i], r[p[i]] = i; }\n    auto LT = Vec(N + 2, N + 2, 0);\n    for (int v = 0; v <= N + 1; v++) {\n        LT[v][0] = (0 < v);\n        for (int i = 1; i <= N + 1; i++) { LT[v][i] = LT[v][i - 1] + (p[i] < v); }\n    }\n    auto lessThan = [&](const int l, const int r, const int v) { return LT[v][r - 1] - (l == 0 ? 0 : LT[v][l - 1]); };\n    std::vector<ll> dp(N + 2, INF<ll>);\n    dp[0] = 0LL;\n    for (int v = 1; v <= N + 1; v++) {\n        const int i = r[v];\n        for (int j = 0; j < i; j++) {\n            if (p[j] > p[i]) { continue; }\n            const int min = lessThan(j, i, p[j]);\n            const int mid = lessThan(j, i, p[i]) - min - 1;\n            const int max = lessThan(j, i, N + 1) - mid - min - 1;\n            SHOW(v, i, j, min, mid, max);\n            ll cost = dp[j] + (ll)min * B + (ll)max * A + (ll)mid * std::max(A, B);\n            chmin(dp[i], cost);\n        }\n    }\n    std::cout << dp[N + 1] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: D.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nll inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint dp[5005][5005],a[5005];\n\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint n,x,y;\n\tread(n,x,y);\n\tfor(int i=0;i<=n;++i)for(int j=0;j<=n;++j)dp[i][j]=inf;\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i){\n\t\tread(a[i]);\t\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tif(j<a[i]){\n\t\t\t\tchkmin(dp[i][a[i]],dp[i-1][j]);\n\t\t\t\tchkmin(dp[i][j],dp[i-1][j]+x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchkmin(dp[i][j],dp[i-1][j]+y);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=inf;\n\tfor(int i=0;i<=n;++i)chkmin(ans,dp[n][i]);\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst long long INF=10000000000000000ll;\n\nint main()\n{\n  int n;\n  long long a,b;\n  scanf(\"%d%lld%lld\",&n,&a,&b);\n  vector<int> p(n+1);\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&p[i]);\n    p[i]--;\n  }\n  p[n]=n;\n  vector<long long> dp(n+1);\n  for(int i=0;i<=n;i++){\n    int ca=0,cb=0;\n    int k=-1;\n    dp[i]=INF;\n    for(int j=i-1;j>=0;j--){\n      if(p[j]>p[i]){\n\tca++;\n      }\n      else if(k==-1||p[k]<p[j]){\n\tdp[i]=min(dp[i],dp[j]+ca*a+cb*b);\n\tcb++;\n\tk=j;\n      }\n      else{\n\tcb++;\n      }\n    }\n    if(k==-1){\n      dp[i]=i*a;\n    }\n  }\n  printf(\"%lld\\n\",dp[n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n; ll a, b;\n    cin>>n>>a>>b;\n    int p[5003];\n    for(int i=1; i<=n; i++) cin>>p[i];\n    p[n+1]=n+1, p[0]=0;\n    ll dp[5001];\n    dp[0]=0;\n    for(int i=1; i<=n+1; i++){\n        ll s=0;\n        dp[i]=1e18;\n        for(int j=i-1; j>=0; j--){\n            if(p[i]<p[j]){\n                s+=a;\n            }else{\n                dp[i]=min(dp[i], dp[j]+s);\n                s+=b;\n            }\n        }\n    }\n    cout<<dp[n+1]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// D.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 5e3 + 200;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint n, A, B, pi[MAX_N], pos[MAX_N];\nll dp[MAX_N][MAX_N];\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &A, &B);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &pi[i]), pos[pi[i]] = i;\n    memset(dp, 0x3f, sizeof(dp)), dp[0][0] = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            if (dp[i - 1][j] != INF)\n                if (pos[i] > pos[j])\n                {\n                    dp[i][i] = min(dp[i][i], dp[i - 1][j]);\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + B);\n                }\n                else\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + A);\n    }\n    printf(\"%lld\\n\", *min_element(dp[n], dp[n] + 1 + n));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';n?-x:x;})\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r){return l+rng()%(r-l+1);}\n#define fasty ios_base::sync_with_stdio(0),cin.tie(0);\n#define forinc(a,b,c) for(int a=b,_c=c;a<=_c;++a)\n#define fordec(a,b,c) for(int a=b,_c=c;a>=_c;--a)\n#define forv(a,b) for(auto&a:b)\n#define fi first\n#define se second\n#define pb push_back\n#define ii pair<int,int>\n#define mt make_tuple\n#define all(a) a.begin(),a.end()\n#define reset(f, x) memset(f, x, sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define on(x,i) (x|(1ll<<(i-1)))\n#define off(x,i) (x&~(1<<(i-1)))\n#define gg exit(0);\n\nconst int N=5010;\n\nint n,a,b;\nint p[N],f[N];\n\nmain(){\n    #define task \"agc032_d\"\n    //freopen(task\".inp\",\"r\",stdin);\n    //freopen(task\".out\",\"w\",stdout);\n\n    n=in,a=in,b=in;\n    forinc(i,1,n) p[i]=in;\n\n    reset(f,127);\n    f[0]=0;\n    forinc(i,1,n){\n        int cntx=0,cnty=0;\n        fordec(j,i-1,0){\n            if(p[j]<p[i]) f[i]=min(f[i],f[j]+cntx*b+cnty*a);\n            if(p[j]<p[i]) cntx++; else cnty++;\n        }\n    }\n    cout<<f[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\nconst long long N=(5050),M=(250025),LEN=(50);\nconst long long Mod=(323232323);\nconst long double EPS=(1e-7);\nconst long long MAX=(1e18);\n///////////////////////////////////////////////\nint n,a[N];\nlong long ans=MAX,A,B,f[N][N];\nint main(){\n\t//freopen(\"problem.in\",\"r\",stdin);\n\t//freopen(\"problem.out\",\"w\",stdout);\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tf[i][j]=MAX;\n\t\t}\n\t}\n\tf[0][0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(a[i]>j){\n\t\t\t\tf[i][j]=min(f[i][j],f[i-1][j]+A);\n\t\t\t\tf[i][a[i]]=min(f[i][a[i]],f[i-1][j]);\n\t\t\t}\n\t\t\tif(a[i]<j) f[i][j]=min(f[i][j],f[i-1][j]+B);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n/*\n3 1 6 2\n3 3 6 6\n4 5\n4 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL>PL;\nconst LL INF=1e18;\nLL N,A,B,i,j;\nLL R[12345],dp[12345];\nLL pa[12345];\nLL mini;\nbool chk[12345];\nvector<LL>V[12345];\nLL cnt;\nLL D,ans;\nstruct fenwick\n{\n    LL data[12345];\n    inline void clear()\n    {\n        for(LL i=0;i<12345;i++)\n            data[i]=0;\n        return;\n    }\n    inline void FI(LL i,LL x)\n    {\n        for(i++;i<12345;i+=i&-i)\n            data[i]+=x;\n        return;\n    }\n    inline LL FS(LL i)\n    {\n        LL ret=0;\n        for(i++;i>0;i=i&i-1)\n            ret+=data[i];\n        return ret;\n    }\n}FT;\nLL t;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>N>>A>>B;\n    for(i=0;i<N;i++)\n    {\n        cin>>R[i];\n        dp[i]=1;\n        pa[i]=-1;\n        for(j=0;j<i;j++)\n        {\n            if(dp[j]+1>=dp[i]&&R[i]>R[j])\n            {\n                dp[i]=dp[j]+1;\n                pa[i]=j;\n            }\n        }\n    }\n    for(i=N;i-->0;)\n    {\n        if(!chk[i])\n        {\n            j=i;\n            while(j!=-1)\n            {\n                V[cnt].push_back(j);\n                chk[j]=true;\n                j=pa[j];\n            }\n            reverse(V[cnt].begin(),V[cnt].end());\n            cnt++;\n        }\n    }\n    ans=INF;\n    for(i=0;i<cnt;i++)\n    {\n        for(j=0;j<N;j++)\n            chk[j]=false;\n        for(j=0;j<V[i].size();j++)\n            chk[V[i][j]]=true;\n        mini=-1;\n        D=0;\n        FT.clear();\n        for(j=0;j<N;j++)\n            if(chk[j])\n                FT.FI(j,1);\n        for(j=0;j<N;j++)\n        {\n            if(chk[j])\n            {\n                mini=R[j];\n                continue;\n            }\n            else if(mini>R[j])\n            {\n                t=FT.FS(j);\n                D+=min(t*A,B);\n            }\n            else\n            {\n                t=FT.FS(8191)-FT.FS(j);\n                D+=A;//min(t*B,A);\n            }\n        }\n        ans=min(ans,D);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst ll MAX_N = 5e3 + 15, inf = 1000000LL * 1000000LL * 1000000LL;\nll n, L, R, ans = inf, ind = 0;\nll IND[MAX_N];\nll Arr[MAX_N];\nll cntl[MAX_N][MAX_N];\nll cntb[MAX_N][MAX_N];\n\nll dp[MAX_N];\n\nvoid processMin() {\n\tfor (ll i = 0; i < n; i++) {\n\t\tll l = 0, b = 0;\n\t\tfor (ll j = i - 1; 0 <= j; j--) {\n\t\t\tl += (Arr[j] < Arr[i]);\n\t\t\tb += (Arr[j] > Arr[i]);\n\t\t\t\n\t\t\tcntl[i][j] = l;\n\t\t\tcntb[i][j] = b;\n\t\t}\n\t}\n\t\n\tfor (ll i = 0; i < n; i++) {\n\t\tll l = 0, b = 0;\n\t\tfor (ll j = i + 1; j < n; j++) {\n\t\t\tl += (Arr[j] < Arr[i]);\n\t\t\tb += (Arr[j] > Arr[i]);\n\t\t\t\n\t\t\tcntl[i][j] = l;\n\t\t\tcntb[i][j] = b;\n\t\t}\n\t}\n}\n\nint main() {\n//\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> L >> R;\n\tswap(L, R);\n\t\n\tfor (ll i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\t\n\t\tIND[Arr[i]] = i;\n\t}\n\t\n\tprocessMin();\n\t\n\tind = Arr[0];\n\tfor (ll i = 1; i < n; i++) {\n\t\tif (ind > Arr[i]) {\n\t\t\tdp[i] = cntb[i][0] * R;\n\t\t\tind = Arr[i];\n\t\t}\n\t\telse\n\t\t\tdp[i] = inf;\n\t\t\t\n\t\tint Max = -1;\n\t\tfor (ll j = i - 1; ~j; j--)\n\t\t\tif (Arr[j] < Arr[i] && Arr[j] > Max) {\n\t\t\t\tll l = min(cntl[j][i - 1], cntl[i][j + 1]);\n\t\t\t\tll b = min(cntb[j][i - 1], cntb[i][j + 1]);\n\t\t\t\t\n\t\t\t\tdp[i] = min(dp[i], dp[j] + l * L + b * R);\n\t\t\t\tMax = Arr[j];\n\t\t\t}\n\t}\n\t\n\tind = -1;\n\tfor (ll i = n - 1; ~i; i--) {\n\t\tif (Arr[i] > ind) {\n\t\t\tans = min(ans, dp[i] + cntl[i][n - 1] * L);\n\t\t\tind = Arr[i];\n\t\t}\n\t}\n\t\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* Starry Sky Tree */\n//0-index\n\nstruct StarrySkyTree{\n  typedef ll Type;\n  int segn2;\n  vector<Type> data, s_data;\n  function<Type(Type, Type)> merge;\n\n  StarrySkyTree(function<Type(Type, Type)> merge, int n): merge(merge)\n  {\n    for(segn2=1; segn2<n; segn2*=2);\n    data.assign(segn2*2, 0);\n    s_data.assign(segn2*2, 0);\n  }\n\n  StarrySkyTree(int n): //Original Ver.\n    StarrySkyTree([](Type a, Type b){ return min(a, b); }, n) {}\n\n  //get value of [a,b)\n  Type query(int a, int b, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(r <= a || b <= l) return LLINF; //大きさに注意\n    if(a <= l && r <= b) return data[k] + s_data[k];\n    return merge(query(a, b, l, (l+r)/2, k*2+1), query(a, b, (l+r)/2 , r, k*2+2)) + s_data[k];\n  }\n\n  //add x to [a,b)\n  Type add(int a, int b, Type x, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(a <= l && r <= b)\n      s_data[k] += x;\n    else if(a < r && l < b)\n      data[k] = merge(add(a, b, x, l, (l+r)/2, k*2+1), add(a, b, x, (l+r)/2, r, k*2+2));\n\n    return data[k] + s_data[k];\n  }\n\n  Type val(int x){\n    Type res = 0;\n    x += segn2 - 1;\n\n    while(x){\n      res += s_data[x];\n      x = (x-1)/2;\n    }\n\n    return res;\n  }\n\n};\n\nint main(){\n  int N, A, B, p;\n\n  scanf(\"%d%d%d\", &N, &A, &B);\n\n  StarrySkyTree seg(N+1);\n\n  for(int i=0;i<N;i++){\n    scanf(\"%d\", &p);\n    ll minVal = seg.query(0, p);\n\n    seg.add(0, p, A);\n    seg.add(p+1, N+1, B);\n\n    ll q = seg.val(p);\n    seg.add(p, p+1, minVal - q);\n  }\n\n  ll ans = seg.query(0, N+1);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 5054;\n\nint n, L, R;\nint p[N];\nll f[N][N];\n\ninline void down(ll &x, const ll y) {x > y ? x = y : 0;}\n\nint main() {\n\tint i, j;\n\tscanf(\"%d%d%d\", &n, &R, &L);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", p + i);\n\tfor (i = 1; i <= n + 1; ++i) {\n\t\tfor (j = 0; j < i; ++j) f[i][j] = f[i - 1][j] + (p[i] < p[j] ? L : R);\n\t\tf[i][i] = LLONG_MAX;\n\t\tfor (j = 0; j < i; ++j) if (p[i] > p[j]) down(f[i][i], f[i - 1][j]);\n\t}\n\tprintf(\"%lld\\n\", *std::min_element(f[n], f[n] + (n + 1)));;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint n;\nvector<vector<int> > e;\n\nvector<bool> vis;\nvector<int> dep,r;\nint ct;\n\nvoid dfs(int i,int p)\n{\n  vis[i]=true;\n  for(int x=0;x<e[i].size();x++){\n    int j=e[i][x];\n    if(j==p)continue;\n    if(!vis[j]){\n      dep[j]=dep[i]+1;\n      dfs(j,i);\n      r[i]+=r[j];\n    }\n    else if(dep[j]<dep[i]){\n      r[j]--;\n      r[i]++;\n      ct++;\n    }\n  }\n}\n\nint main()\n{\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  vector<vector<int> > e(n);\n  for(int t=0;t<m;t++){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    a--,b--;\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n  int r6=0;\n  vector<int> r4;\n  for(int i=0;i<n;i++){\n    if((int)e[i].size()%2!=0){\n      puts(\"No\");\n      return 0;\n    }\n    if((int)e[i].size()>=6){\n      r6++;\n    }\n    else if(e[i].size()==4){\n      r4.push_back(i);\n    }\n  }\n  if(r6>0||r4.size()>=3){\n    puts(\"Yes\");\n  }\n  else if(r4.size()<2){\n    puts(\"No\");\n  }\n  else{\n    bool F=false;\n    for(int x=0;x<4;x++){\n      int i=e[r4[0]][x];\n      int p=r4[0];\n      while(e[i].size()==2){\n\tint temp=e[i][0]+e[i][1]-p;\n\tp=i;\n\ti=temp;\n      }\n      if(i==r4[0]){\n\tF=true;\n      }\n    }\n    puts(F?\"Yes\":\"No\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define ll long long\nconst int N=5010;\nint n,a,b,x,p[N];\nll dp[N][N];\nint main() {\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\trep(i,1,n+1) scanf(\"%d\",&x),p[x]=i;\n\tmemset(dp,0x20,sizeof(dp));\n\tdp[0][0]=0;\n\trep(i,1,n+1) rep(j,1,i) {\n\t\tif (p[i]>p[j]) {\n\t\t\tdp[i][i]=min(dp[i][i],dp[i-1][j]);\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+b);\n\t\t} else\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+a);\n\t}\n\tprintf(\"%lld\\n\",*min_element(dp[n],dp[n]+n+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int inf = 1000000000000000LL;\n\nint dp[5432];\n\nsigned main() {\n\tint n, a, b;\n\tcin >> n >> a >> b;\n\tvector<int> v;\n\trep(i, n) {\n\t\tint p;\n\t\tcin >> p;\n\t\tdp[i] = inf;\n\t\tint count = 0;\n\t\tfor(int j = i - 1; j >= 0; j--) {\n\t\t\tif(v[j] < p) {\n\t\t\t\tdp[i] = min(dp[i], dp[j] + count * a + (i - j - 1 - count) * b);\n\t\t\t}\n\t\t\tif(v[j] > p) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count == i) {\n\t\t\tdp[i] = min(dp[i], count * a);\n\t\t}\n\t\tv.push_back(p);\n\t}\n\tint ans = inf;\n\tint ma = 0;\n\tfor(int i = n - 1; i >= 0; i--) {\n\t\tif(ma < v[i]) {\n\t\t\tans = min(ans, dp[i] + (n - 1 - i) * b);\n\t\t}\n\t\tma = max(ma, v[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n#include <cstring>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <stack>\n\n/* ---------- Namespace ---------- */\nusing namespace std;\n\n/* ---------- Type ---------- */\nusing ll = long long;\n#define int ll\n#define P pair<ll, ll>\n\n/* ---------- Constants  */\nconst double PI = 3.141592653589793238462643383279;\nconst ll MOD = 1e9 + 7;\nconst int INF = 1LL << 55;\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\nsigned main() {\n    int N, cost_r, cost_l;\n    cin >> N >> cost_r >> cost_l;\n    vector<int> A(N);\n    vector<int> num2pos(N + 1);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n        num2pos[A[i]] = i;\n    }\n\n    int dp[N+1][N]; // 数字iを区間jにおいたときのコストの最小値\n    for (int i = 0; i < N; i++) dp[0][i] = 0;\n\n    // dp[i+1][j] = min(dp[i][0], ..., dp[i][j]) + cost;\n    for (int i = 0; i < N; i++) {\n        int mn = INF;\n        for (int j = 0; j < N; j++) {\n            mn = min(mn, dp[i][j]);\n            int cost;\n            if (num2pos[i + 1] == j) cost = 0;\n            else if (num2pos[i + 1] > j) cost = cost_l;\n            else cost = cost_r;\n            dp[i+1][j] = mn + cost;\n        }\n    }\n\n    int ret = INF;\n    for (int j = 0; j < N; j++) ret = min(ret, dp[N][j]);\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconst int MAXN = 5100;\nint N;\nll dp[MAXN][MAXN];\nint P[MAXN];\nll A, B;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> P[i];\n\t}\n\tP[N+1] = N+1;\n\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= N+1; i++) {\n\t\tdp[i][i] = ll(1e18);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (P[i] > P[j]) dp[i][i] = min(dp[i][i], dp[i-1][j]);\n\t\t\tdp[i][j] = dp[i-1][j] + (P[i] > P[j] ? A : B);\n\t\t}\n\t}\n\n\tcout << dp[N+1][N+1] << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,avx512f\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <numeric>\n#include <cassert>\n#include <memory>\n#include <random>\n#include <functional>\n#include <complex>\n#include <immintrin.h>\n#ifdef DEBUG\n#include \"./Lib/debug_VC.hpp\"\n#include \"./Lib/Timer.hpp\"\n#include \"./Lib/sample.hpp\"\n#else\n#define dump(...)\n#endif\n\n/* macro */\n#define FOR(i, b, e) for(ll i = (ll)(b); i < (ll)(e); ++i)\n#define RFOR(i, b, e) for(ll i = (ll)(e-1); i >= (ll)(b); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n#define REPC(x,c) for(const auto& x:(c))\n#define REPI2(it,b,e) for(auto it = (b); it != (e); ++it)\n#define REPI(it,c) REPI2(it, (c).begin(), (c).end())\n#define RREPI(it,c) REPI2(it, (c).rbegin(), (c).rend())\n#define REPI_ERACE2(it, b, e) for(auto it = (b); it != (e);)\n#define REPI_ERACE(it, c) REPI_ERACE2(it, (c).begin(), (c).end())\n#define ALL(x) (x).begin(),(x).end()\n#define cauto const auto&\n/* macro func */\ntemplate<class T>\ninline auto sort(T& t) { std::sort(ALL(t)); }\ntemplate<class T>\ninline auto rsort(T& t) { std::sort((t).rbegin(), (t).rend()); }\ntemplate<class T>\ninline auto unique(T& t) { (t).erase(unique((t).begin(), (t).end()), (t).end()); }\ntemplate<class T, class S>\ninline auto chmax(T& t, const S& s) { if (s > t) { t = s; return true; } return false; }\ntemplate<class T, class S>\ninline auto chmin(T& t, const S& s) { if (s < t) { t = s; return true; } return false; }\ninline auto BR() { std::cout << \"\\n\"; }\n\n/* type define */\nusing ll = long long;\nusing PAIR = std::pair<ll, ll>;\nusing VS = std::vector<std::string>;\nusing VL = std::vector<long long>;\nusing VVL = std::vector<VL>;\nusing VVVL = std::vector<VVL>;\nusing VD = std::vector<double>;\ntemplate<class T>\nusing V = std::vector<T>;\n\n/* using std */\nusing std::cout;\nconstexpr char endl = '\\n';\nusing std::cin;\nusing std::pair;\nusing std::string;\nusing std::stack;\nusing std::queue;\nusing std::vector;\nusing std::list;\nusing std::map;\nusing std::unordered_map;\nusing std::multimap;\nusing std::unordered_multimap;\nusing std::set;\nusing std::unordered_set;\nusing std::unordered_multiset;\nusing std::multiset;\nusing std::bitset;\nusing std::priority_queue;\n\n/* Initial processing  */\nstruct Preprocessing { Preprocessing() { std::cin.tie(0); std::ios::sync_with_stdio(0); }; }_Preprocessing;\n\n/* Remove the source of the bug */\nsigned pow(signed, signed) { assert(false); return -1; }\n\n/* define hash */\nnamespace std {\ntemplate <>\tclass hash<std::pair<ll, ll>> { public:\tsize_t operator()(const std::pair<ll, ll>& x) const { return hash<ll>()(1000000000 * x.first + x.second); } };\n}\n\n/* input */\ntemplate<class T> std::istream& operator >> (std::istream& is, vector<T>& vec) { for (T& x : vec) is >> x; return is; }\n\n/* constant value */\n//constexpr ll MOD = 1000000007;\nconstexpr ll MOD = 998244353;\n\n//=============================================================================================;\n\n\nsigned main() {\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tVL p(n);\n\tcin >> p;\n\tconstexpr ll ng = 1e18;\n\tVL dp(n + 1, ng);\n\tdp[0] = 0;\n\tVL tmp;\n\tREPC(x, p) {\n\t\t//dump(dp);\n\t\ttmp = VL(n + 1, ng);\n\t\tREP(i, n + 1) {\n\t\t\tif (x == i) { continue; }\n\t\t\tif (x < i) { chmin(tmp[i], dp[i] + b); continue; }\n\t\t\tchmin(tmp[x], dp[i]);\n\t\t\tchmin(tmp[i], dp[i] + a);\n\n\t\t}\n\t\tstd::swap(dp, tmp);\n\t}\n\tll ans = n * a;\n\tREPC(x, dp) { chmin(ans, x); }\n\tcout << ans << endl;\n\tdump(dp);\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nLL N, X, Y;\nvector<int> A;\nint P[5001][5001];\nint Q[5002][5002];\nint R[5002][5002];\n\nvoid pre() {\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N) {\n\t\t\tQ[i][j + 1] = Q[i][j] + P[i][j];\n\t\t}\n\t}\n\n\tREP(j, 0, N + 1) {\n\t\tREP(i, 0, N) {\n\t\t\tR[i + 1][j] = R[i][j] + Q[i][j];\n\t\t}\n\t}\n}\n\nint rect(int li, int lj, int ri, int rj) {\n\treturn R[li][lj] - R[li][rj] - R[ri][lj] + R[ri][rj];\n}\n\nLL DP[5002][5002];\nint main() {\n\tcin >> N >> X >> Y;\n\tA.push_back(0);\n\tREP(i, 0, N) A.push_back(Next<int>());\n\tA.push_back(N + 1);\n\n\tN += 2;\n\tREP(i, 0, N) {\n\t\t++P[i][A[i]];\n\t}\n\tpre();\n\n\tFill(DP, INFLL);\n\tDP[0][0] = 0;\n\tREP(i, 1, N) {\n\t\tREP(j, 0, N) {\n\t\t\tif (j == A[i]) {\n\t\t\t\tLL mn = INFLL;\n\t\t\t\tREP(li, 0, i) {\n\t\t\t\t\tif (A[li] > A[i]) continue;\n\t\t\t\t\tint lj = A[li];\n\t\t\t\t\tint L = rect(li, lj, i, N) - 1;\n\t\t\t\t\tint R = rect(i, lj, N, j);\n\n\t\t\t\t\tmn = min(mn, DP[i - 1][lj] + L * X + R * Y);\n\t\t\t\t}\n\t\t\t\tDP[i][j] = mn;\n\t\t\t} else {\n\t\t\t\tDP[i][j] = DP[i - 1][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[N - 1][N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=5005;\nint n,A,B,a[N];\nll f[N],v1[N],v2[N];\nll mn[N*4],tg[N*4];\nstruct TR1{\n\tint t[N];\n\tvoid change(int x){\n\t\tfor (;x<=n;x+=x&(-x)) t[x]++;\n\t}\n\tint ask(int x){\n\t\tint ans=0;\n\t\tfor (;x;x-=x&(-x)) ans+=t[x];\n\t\treturn ans;\n\t}\n}T1;\nvoid build(int k,int l,int r){\n\tmn[k]=1ll<<60; tg[k]=0;\n\tif (l==r) return;\n\tint mid=(l+r)/2;\n\tbuild(k*2,l,mid);\n\tbuild(k*2+1,mid+1,r);\n}\nvoid pushdown(int k){\n\tif (!tg[k]) return;\n\ttg[k*2]+=tg[k]; tg[k*2+1]+=tg[k];\n\tmn[k*2]+=tg[k]; mn[k*2+1]+=tg[k];\n\ttg[k]=0;\n}\nvoid change(int k,int l,int r,int x,int y,ll v){\n\tif (l==x&&r==y){\n\t\ttg[k]+=v;\n\t\tmn[k]+=v;\n\t\treturn;\n\t}\n\tpushdown(k);\n\tint mid=(l+r)/2;\n\tif (y<=mid) change(k*2,l,mid,x,y,v);\n\telse if (x>mid) change(k*2+1,mid+1,r,x,y,v);\n\telse{\n\t\tchange(k*2,l,mid,x,mid,v);\n\t\tchange(k*2+1,mid+1,r,mid+1,y,v);\n\t}\n\tmn[k]=min(mn[k*2],mn[k*2+1]);\n}\nvoid change(int k,int l,int r,int x,ll v){\n\tif (l==r){\t\n\t\tmn[k]=v;\n\t\treturn;\n\t}\n\tpushdown(k);\n\tint mid=(l+r)/2;\n\tif (x<=mid) change(k*2,l,mid,x,v);\n\telse change(k*2+1,mid+1,r,x,v);\n\tmn[k]=min(mn[k*2],mn[k*2+1]);\n}\nll ask(int k,int l,int r,int x,int y){\n\tif (l==x&&r==y) return mn[k];\n\tpushdown(k);\n\tint mid=(l+r)/2;\n\tif (y<=mid) return ask(k*2,l,mid,x,y);\n\tif (x>mid) return ask(k*2+1,mid+1,r,x,y);\n\treturn min(ask(k*2,l,mid,x,mid),ask(k*2+1,mid+1,r,mid+1,y));\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n){\n\t\tv1[i]=1ll*A*(i-1)+1ll*T1.ask(a[i])*(B-A);\n\t\tv2[i]=1ll*A*(n-a[i])+1ll*B*(a[i]-1)-v1[i];\n\t\tT1.change(a[i]);\n\t}\n\tll ans=1ll<<60;\n\tbuild(1,1,n);\n\tFor(i,1,n) f[i]=v1[i];\n\tFor(i,1,n){\n\t\tf[i]=min(f[i],ask(1,1,n,1,a[i])+1ll*(i-1)*A);\n\t\tchange(1,1,n,a[i],n,B-A);\n\t\tchange(1,1,n,a[i],f[i]-1ll*i*A);\n\t}\n\tFor(i,1,n)\n\t\tans=min(ans,f[i]+v2[i]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 5005\nusing namespace std;\ntypedef long long LL;\nint n,a[maxn];\nLL A,B;\nLL f[maxn][maxn];\nint main()  {\n    scanf(\"%d%lld%lld\",&n,&A,&B);\n    for (int i=1;i<=n;++i)\n        scanf(\"%d\",a+i);\n    memset(f,0x3f,sizeof(f));\n    f[0][0]=0;\n    for (int i=1;i<=n;++i)  {\n        for (int j=i-1,c=0;~j;--j)\n            if (a[j]<a[i])\n                // cout<<i<<\" <- \"<<j<<endl,\n                f[i][i]=min(f[i][i],f[j][j]+(i-j-1-c)*B+c*A);\n            else    ++c;\n        for (int j=0;j<i;++j)\n            f[i][j]=f[i-1][j]+B;\n        // for (int j=0;j<=i;++j)\n        //     printf(\"f[%d][%d]=%lld\\n\",i,j,f[i][j]);\n    }\n    LL ans=1LL<<62;\n    for (int i=1;i<=n;++i)\n        ans=min(ans,f[n][i]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr ll INF=1000000000000000000;\nint n,a,b,p[5010],q[5010];\nll dp[5010][10010];\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    cin>>n>>a>>b;\n    rep(i,n){\n        cin>>p[i];\n        q[p[i]-1]=i+1;\n    }\n    rep(i,n+1)rep(j,2*n+2)dp[i][j]=INF;\n    dp[0][1]=0;\n    rep(i,n){\n        ll cur=INF;\n        for(int j=1;j<=2*n+1;j++){\n            if(j%2==1){\n                chmin(cur,dp[i][j]);\n                chmin(cur,dp[i][j-1]);\n            }\n            if(j>q[i]*2)chmin(dp[i+1][j],cur+a);\n            if(j<q[i]*2)chmin(dp[i+1][j],cur+b);\n            if(j==q[i]*2)chmin(dp[i+1][j],cur);\n        }\n    }\n    ll ans=INF;\n    rep(j,2*n+2)chmin(ans,dp[n][j]);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nint dp[5003][5003];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, a, b);\n\tVEC(int, p, n);\n\n\tV<int> q(n);\n\tREP(i, n) q[p[i] - 1] = i + 1;\n\n\tFILL(dp, INFLL);\n\tdp[0][0] = 0;\n\n\tREP(i, n + 1) REP(j, n + 1) {\n\t\tif (i < n && j < n) {\n\t\t\tint cost = 0;\n\t\t\tif (p[i] > j + 1) cost += a;\n\t\t\tif (i + 1 < q[j]) cost += b;\n\t\t\tCHMIN(dp[i + 1][j + 1], dp[i][j] + cost);\n\t\t}\n\t\tif (i < n) {\n\t\t\tint cost = 0;\n\t\t\tif (p[i] > j + 1) cost += a;\n\t\t\tCHMIN(dp[i + 1][j], dp[i][j] + cost);\n\t\t}\n\t\tif (j < n) {\n\t\t\tint cost = 0;\n\t\t\tif (i + 1 < q[j]) cost += b;\n\t\t\tCHMIN(dp[i][j + 1], dp[i][j] + cost);\n\t\t}\n\t}\n\tOUT(dp[n][n])BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n \nusing namespace std;\n \nconst int maxn = 5000 + 7;\n \nint n, A, B, pos[maxn], dp[maxn], a[maxn], ans;\n \nint32_t main()\n{\n    cin >> n >> A >> B;\n    for(int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    a[n + 1] = 1e15;\n    for(int i = 1; i <= n + 1; i++)\n    {\n        dp[i] = 1e15;\n        ans = 0;\n        for(int j = i - 1; j >= 0; j--)\n        {\n            if(a[j] > a[i]) ans++;\n            else\n            {\n                dp[i] = min(dp[i], dp[j] + ans * A + (i - j - 1 - ans) * B);\n            }\n        }\n    }\n    cout << dp[n + 1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 320000\nusing namespace std;\nlong long n,A,B;\nlong long L[N],R[N];\nlong long f[5200][5200]; \nlong long a[5200];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&A,&B);\n\tif(n==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tlong long x;\n\t\tscanf(\"%d\",&x);\n\t\ta[x]=i;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tfor(long long j=i+1;j<=n;j++)if(a[j]<a[i]){L[i]=j;break;}\n\t\tfor(long long j=i-1;j>=1;j--)if(a[j]>a[i]){R[i]=j;break;}\n\t}\n\tfor(int i=0;i<=5100;i++){\n\t\tfor(int j=0;j<=5100;j++)f[i][j]=1000000000000000LL;\n\t}\n\tf[0][n+1]=0;\n\tfor(long long i=0;i<n;i++){\n\t\tfor(long long j=n+1;j>i;j--){\n\t\t\tif(L[i+1]<j&&L[i+1]!=0)f[i+1][j]=min(f[i][j]+B,f[i+1][j]);\n\t\t\telse f[i+1][j]=min(f[i][j],f[i+1][j]);\n\t\t\tif(R[j-1]>i&&R[j-1]!=0)f[i][j-1]=min(f[i][j]+A,f[i][j-1]);\n\t\t\telse f[i][j-1]=min(f[i][j],f[i][j-1]);\n\t\t}\n\t}\n\tlong long ans=1000000000000000LL;\n\tfor(long long i=0;i<=n;i++)ans=min(ans,f[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long int;\n\n#define FOR(i, b, e) for (int i = (b); i < (e); ++i)\n#define RFOR(i, b, e) for (int i = ((e) - 1); (b) <= i; --i)\n#define REP(i, N) for (int i = 0; i < (N); ++i)\n#define RREP(i, N) for (int i = ((N) - 1); 0 <= i; --i)\n#define scanInt(x) int x; scanf(\"%d\", &(x)); getchar();\n#define scanLLInt(x) ll x; scanf(\"%lld\", &(x)); getchar();\n#define scanVecInt(A, N) vector<int> A(N); REP(i, N){scanf(\"%d\", &(A[i])); getchar();}\n#define scanVecLLInt(A, N) vector<ll> A(N); REP(i, N){scanf(\"%lld\", &(A[i])); getchar();}\n\nint v_search(vector<int>& P, int n){\n    REP(i, P.size()){\n        if (P[i] == n) return i;\n    }\n    return -1;\n}\n\n// int right_shift(vector<int>& P, int bi, int ei, int n){\n//     int s = ei - bi;\n//     vector<int> temp(s);\n//     FOR(i, bi, ei) temp[i - bi] = P[i];\n//     FOR(i, bi, ei) P[i] = temp[(i - bi + s - n) % s];\n// }\n\nvoid left_shift(vector<int>& P, int bi, int ei, int n){\n    int s = ei - bi;\n    vector<int> temp(s);\n    FOR(i, bi, ei) temp[i - bi] = P[i];\n    FOR(i, bi, ei) P[i] = temp[(i - bi + n) % s];\n}\n\nll func(vector<int>& P, int bi, int ei, ll A, ll B){\n    if (bi + 1 == ei) return 0;\n    vector<int> ltemp(P.begin(), P.end());\n    vector<int> rtemp(P.begin(), P.end());\n    const int mli = v_search(P, bi);\n    const int mri = v_search(P, ei - 1);\n    left_shift(ltemp, bi, mli + 1, mli - bi);\n    left_shift(rtemp, mri, ei, 1);\n    return min(func(ltemp, bi + 1, ei, A, B) + min(A * (mli - bi), B), func(rtemp, bi, ei - 1, A, B) + min(A, B * (ei - 1 - mri)));\n}\n\nint main(){\n    scanInt(N);\n    scanLLInt(A);\n    scanLLInt(B);\n    scanVecInt(P, N);\n    REP(i, N) P[i]--;\n    cout << func(P, 0, N, A, B) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL>PL;\nconst LL INF=1e18;\nLL N,A,B,i,j;\nLL R[12345],dp[12345];\nLL pa[12345];\nLL mini;\nbool chk[12345];\nvector<LL>V[12345];\nLL cnt;\nLL D,ans;\nstruct fenwick\n{\n    LL data[12345];\n    inline void clear()\n    {\n        for(LL i=0;i<12345;i++)\n            data[i]=0;\n        return;\n    }\n    inline void FI(LL i,LL x)\n    {\n        for(i++;i<12345;i+=i&-i)\n            data[i]+=x;\n        return;\n    }\n    inline LL FS(LL i)\n    {\n        LL ret=0;\n        for(i++;i>0;i=i&i-1)\n            ret+=data[i];\n        return ret;\n    }\n}FT;\nLL t;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>N>>A>>B;\n    for(i=0;i<N;i++)\n    {\n        cin>>R[i];\n        dp[i]=1;\n        pa[i]=-1;\n        for(j=0;j<i;j++)\n        {\n            if(dp[j]+1>=dp[i]&&R[i]>R[j])\n            {\n                dp[i]=dp[j]+1;\n                pa[i]=j;\n            }\n        }\n    }\n    for(i=N;i-->0;)\n    {\n        if(!chk[i])\n        {\n            j=i;\n            while(j!=-1)\n            {\n                V[cnt].push_back(j);\n                chk[j]=true;\n                j=pa[j];\n            }\n            reverse(V[cnt].begin(),V[cnt].end());\n            cnt++;\n        }\n    }\n    ans=INF;\n    for(i=0;i<cnt;i++)\n    {\n        for(j=0;j<N;j++)\n            chk[j]=false;\n        for(j=0;j<V[i].size();j++)\n            chk[V[i][j]]=true;\n        mini=-1;\n        D=0;\n        FT.clear();\n        for(j=0;j<N;j++)\n            if(chk[j])\n                FT.FI(j,1);\n        for(j=0;j<N;j++)\n        {\n            if(chk[j])\n            {\n                mini=R[j];\n                continue;\n            }\n            else if(mini>R[j])\n            {\n                t=FT.FS(j);\n                D+=min(t*A,B);\n            }\n            else\n            {\n                t=FT.FS(8191)-FT.FS(j);\n                D+=min(t*B,A);\n            }\n        }\n        ans=min(ans,D);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=5010;\nconst int inf=0x3f3f3f3f;\nconst ll infmax=10000000000000000;\nll f[N][N];\nint s0[N][2],s1[N][2],a[N],b[N],sum[N];\nint n; \nll A,B;\nll solve(int l,int r) {\n     if (f[l][r]!=-1) return f[l][r];\n     f[l][r]=infmax;\n     if (s0[b[l]][1]<=r) f[l][r]=min(f[l][r],B+solve(l+1,r)); else f[l][r]=min(f[l][r],solve(l+1,r));\n\t if (s1[b[r]][0]>=l) f[l][r]=min(f[l][r],A+solve(l,r-1)); else f[l][r]=min(f[l][r],solve(l,r-1)); \n\t return f[l][r]; \n}\nvoid init() {\n\tfor (int i=1;i<=n;i++) {\n\t\ts0[i][0]=0; s0[i][1]=inf;\n\t\tfor (int j=1;j<i;j++) \n\t\tif (a[j]<a[i]) s0[i][0]=max(s0[i][0],a[j]); else s0[i][1]=min(s0[i][1],a[j]);\n\t}\n\tfor (int i=n;i>=1;i--) {\n\t\ts1[i][0]=0; s1[i][1]=inf;\n\t\tfor (int j=i+1;j<=n;j++) \n\t\t if (a[j]<a[i]) s1[i][0]=max(s1[i][0],a[j]); else s1[i][1]=min(s1[i][1],a[j]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%lld%lld\",&A,&B);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]),b[a[i]]=i;\n\tmemset(f,255,sizeof(f));\n\tfor (int i=1;i<=n;i++) f[i][i]=0;\n\tinit();\n\tll ans=0;\n\tint las=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tsum[a[i]]++;\n\t\tbool p=0;\n\t\tfor (int j=1;j<=i;j++)\n\t\tif (!sum[j]) {p=1; break;}\n\t\tif (!p) ans+=solve(las+1,i),las=i;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <set>\n#include <vector>\n#include <deque>\n#include <queue>\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n#define FOR(i, a, b) for(int i=a, loop=b; i<=loop; ++i)\n#define REV(i, a, b) for(int i=a, loop=b; i>=loop; --i)\n#define mize(a, b) a = min(a, b)\n#define maxi(a, b) a = max(a, b)\n#define shl(k) ((k) << 1)\nusing namespace std;\n\nconst int N = 5001;\nint n, a[N], c[N][N], v[N], A, B;\nint64_t f[N][N], INF = 1e15;\n\nint main()\n{\n    ios::sync_with_stdio(); cin.tie(0);\n\n    cin >> n >> A >> B;\n    FOR(i, 1, n) {\n        cin >> a[i];\n        v[a[i]] = i;\n    }\n\n    FOR(i, 1, n) {\n        c[i][i] = a[i];\n        FOR(j, i+1, n) c[i][j] = max(c[i][j-1], a[j]);\n    }\n\n    FOR(i, 0, n) FOR(j, 1, n) f[i][j] = INF;\n    f[0][1] = (a[1]==1 ? 0 : B);\n    f[v[1]][1] = 0;\n\n\n    FOR(j, 1, n-1) FOR(i, 0, n) {\n        ///cout << i <<' '<< j <<' '<< f[i][j] << endl;\n        if (v[j+1] <= i)\n            mize(f[i][j+1], f[i][j]+A);\n        else {\n            mize(f[v[j+1]][j+1], f[i][j]);\n            mize(f[i][j+1], f[i][j] + (c[i+1][v[j+1]-1] > j+1 ? B : 0));\n        }\n    }\n\n    int64_t ans = INF;\n    FOR(i, 0, n) mize(ans, f[i][n]);\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n#define sol k+k\n#define sag k+k+1\n#define orta ((bas+son)/2)\n#define mod 1000000007\n#define N 5005\nusing namespace std;\n\ntypedef long long ll;\n\nll n, A, B, a[N], dp[N][N], mn[N][N], mx[N][N];\nvector < ll > seg[4*N];\n\nvoid merge(ll k){\n\tseg[k].clear();\n\tll i = 0, a = (int)seg[sol].size();\n\tll j = 0, b = (int)seg[sag].size();\n\twhile(i < a and j < b){\n\t\tif(seg[sol][i] < seg[sag][j])\n\t\t\tseg[k].pb(seg[sol][i++]);\n\t\telse\n\t\t\tseg[k].pb(seg[sag][j++]);\n\t}\n\twhile(i < a)seg[k].pb(seg[sol][i++]);\n\twhile(j < b)seg[k].pb(seg[sag][j++]);\n}\n\nll qu(ll k, ll bas, ll son, ll x, ll y, ll z){\n\tif(bas > y or son < x)\n\t\treturn 0;\n\tif(bas >= x and son <= y){\n\t\tll ind = lower_bound(seg[k].begin(), seg[k].end(), z) - seg[k].begin();\n\t\treturn (int)seg[k].size() - ind ;\n\t}\n\treturn qu(sol, bas, orta, x, y, z) + qu(sag, orta + 1, son, x, y, z);\n}\n\nll quu(ll k, ll bas, ll son, ll x, ll y, ll z){\n\tif(bas > y or son < x)\n\t\treturn 0;\n\tif(bas >= x and son <= y){\n\t\tll ind = lower_bound(seg[k].begin(), seg[k].end(), z) - seg[k].begin();\n\t\treturn ind;\n\t}\n\treturn quu(sol, bas, orta, x, y, z) + quu(sag, orta + 1, son, x, y, z);\n}\n\nvoid up(ll k, ll bas, ll son, ll x, ll y){\n\tif(bas == son){\n\t\tseg[k].pb(y);\n\t\treturn;\n\t}\n\tif(x <= orta)\n\t\tup(sol, bas, orta, x, y);\n\telse\n\t\tup(sag, orta + 1, son, x, y);\n\tmerge(k);\n}\n\nll f(ll bas, ll son){\n\tif(bas == son)\n\t\treturn 0;\n\tll &r = dp[bas][son];\n\tif(r != -1)\n\t\treturn r;\n\tif(a[bas] == mn[bas][son])\n\t\treturn r = f(bas + 1, son);\n\tif(a[son] == mx[bas][son])\n\t\treturn r = f(bas, son - 1);\n\treturn r = min(f(bas + 1, son) + min(A, B*(quu(1, 1, n, bas + 1, son, a[bas])) ), f(bas, son - 1) + min(B, A*(qu(1, 1, n, bas, son - 1, a[son])) ) );\n}\n\nint main() {\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n\n\tmemset(dp, -1, sizeof dp);\n\n\tscanf(\"%lld %lld %lld\",&n ,&A ,&B);\n\tfor(ll i = 1; i <= n; i++){\n\t\tscanf(\"%lld\",a + i);\n\t\tup(1, 1, n, i, a[i]);\n\t}\n\t// cout << quu(1, 1, n, 1, 1, 3) << endl;\n\n\tfor(ll i = 1; i <= n; i++){\n\t\tmx[i][i] = mn[i][i] = a[i];\n\t\tfor(ll j = i + 1; j <= n; j++){\n\t\t\tmn[i][j] = min(mn[i][j - 1], a[j]);\n\t\t\tmx[i][j] = max(mx[i][j - 1], a[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f(1, n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll; \n#define rll register ll\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=5005;\nconst ll inf=1e18;\nstruct segtree{\n\tll mn[N<<2],tag[N<<2];\n\t#define lc x<<1\n\t#define rc x<<1|1 \n\tinline void build(ri x,ri l,ri r){\n\t\tmn[x]=inf;\n\t\tif(l==r)\n\t\t\treturn;\n\t\tri mid=l+r>>1;\n\t\tbuild(lc,l,mid);\n\t\tbuild(rc,mid+1,r);\n\t}\n\tinline void up(ri x){\n\t\tmn[x]=min(mn[lc],mn[rc])+tag[x];\n\t}\n\tinline void upd(ri x,ri l,ri r,ri p,rll v){\n\t\tv-=tag[x];\n\t\tif(l==r){\n\t\t\tmn[x]=v+tag[x];\n\t\t\treturn;\n\t\t}\n\t\tri mid=l+r>>1;\n\t\tp<=mid?upd(lc,l,mid,p,v):upd(rc,mid+1,r,p,v);\n\t\tup(x);\n\t}\n\tinline void modify(ri x,ri l,ri r,ri ql,ri qr,rll v){\n\t\tif(ql<=l&&r<=qr){\n\t\t\tmn[x]+=v;\n\t\t\ttag[x]+=v; \n\t\t\treturn;\n\t\t}\n\t\tri mid=l+r>>1;\n\t\tif(ql<=mid) modify(lc,l,mid,ql,qr,v);\n\t\tif(qr> mid) modify(rc,mid+1,r,ql,qr,v);\n\t\tup(x);\n\t}\n\tinline ll query(ri x,ri l,ri r,ri ql,ri qr){\n\t\tif(ql<=l&&r<=qr)\n\t\t\treturn mn[x];\n\t\tri mid=l+r>>1;\n\t\trll v=inf;\n\t\tif(ql<=mid) v=\t\tquery(lc,l,mid,ql,qr);\n\t\tif(qr> mid) v=min(v,query(rc,mid+1,r,ql,qr));\n\t\tv+=tag[x];\n\t\treturn v;\n\t}\n}seg;\nint p[N];\nll dp[N];\nint main(){\n\tri n,A,B,C,i,j;\n\tgi(n);gi(A);gi(B);\n\tC=B-A;\n\tfor(i=1;i<=n;++i) gi(p[i]);\n\tp[n+1]=n+1;\n\tseg.build(1,0,n+1);\n\tseg.upd(1,0,n+1,0,0);\n\tfor(i=1;i<=n+1;++i)\n\t\tdp[i]=seg.query(1,0,n,0,p[i]-1)+(ll)A*(i-1),\n\t\tseg.upd(1,0,n+1,p[i],dp[i]-(ll)A*i),\n\t\tseg.modify(1,0,n+1,p[i]+1,n+1,C);\n\tprintf(\"%lld\\n\",dp[n+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\n\nll cost[5100][5100];\n// cost first i elements, cur max\n\nint main(){\n\tint n;\n\tcin >> n;\n\tll a, b;\n\tcin >> a >> b;\n\tvector<int> p(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> p[i];\n\t}\n\tif(a > b){\n\t\tswap(a, b);\n\t\treverse(p.begin(), p.end());\n\t}\n\tfor(int i = 0; i < 5100; i++) for(int j = 0; j < 5100; j++) cost[i][j] = 1e17;\n\tcost[0][0] = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tif(cost[i][j] >= ll(1e17)) continue;\n\t\t\tif(p[i] >= j){\n\t\t\t\tcost[i+1][j] = min(cost[i+1][j], cost[i][j] + a);\n\t\t\t\tcost[i+1][p[i]] = min(cost[i+1][p[i]], cost[i][j]);\n\t\t\t}\n\t\t\tcost[i+1][j] = min(cost[i+1][j], cost[i][j] + b);\n\t\t}\n\t}\n\tll ans = 1e17;\n\tfor(int j = 0; j <= n; j++){\n\t\tans = min(ans, cost[n][j]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\n// 0-indexed bottom up Segment Tree\n// UNIT is the identity element of operation func\ntemplate <typename T = int>\nstruct SegmentTree {\n    using F = function<T(T, T)>;\n    int n;\n    vector<T> dat;\n    F func;\n    T UNIT;\n\n    SegmentTree(int n_, F func_, T UNIT_) : func(func_), UNIT(UNIT_) {\n        n = 1;\n        // full binary tree: num of leaves = n = 2^k >= n_\n        while (n < n_)\n            n *= 2;\n        dat.assign(2 * n - 1, UNIT);\n    }\n    SegmentTree(vector<T> v_, F func_, T UNIT_) : func(func_), UNIT(UNIT_) {\n        n      = 1;\n        int nv = v_.size();\n        while (n < nv)\n            n *= 2;\n        dat.assign(2 * n - 1, UNIT);\n        for (int i = 0; i < nv; ++i) {\n            dat[n - 1 + i] = v_[i];\n        }\n        for (int i = n - 2; i >= 0; --i) {\n            dat[i] = func(dat[2 * i + 1], dat[2 * i + 2]);\n        }\n    }\n    void update(int k, T a) {\n        // leaves are at index n-1 to 2*n-2\n        k += n - 1;\n        dat[k] = a;\n        while (k > 0) {\n            // k -> parent node\n            k = (k - 1) / 2;\n            // func(child nodes)\n            dat[k] = func(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n    // get result of func() in [l, r)\n    T query(int l, int r) {\n        l += n - 1;\n        r += n - 1;\n        T retl = UNIT, retr = UNIT;\n        while (l < r) {\n            if ((l & 1) == 0)\n                retl = func(retl, dat[l]);\n            if ((r & 1) == 0)\n                retr = func(dat[r - 1], retr);\n            l = l / 2;\n            r = (r - 1) / 2;\n        }\n        return func(retl, retr);\n    }\n};\nauto f          = [](lint l, lint r) { return min(l, r); };\nconst lint unit = inf;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    lint n, a, b;\n    cin >> n >> a >> b;\n    vector<lint> p(n);\n    vector<pair<lint, lint>> pi;\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        pi.emplace_back(p[i], i);\n    }\n    sort(pi.begin(), pi.end());\n    SegmentTree<lint> seg(2 * n + 2, f, unit);\n    SegmentTree<lint> segn(2 * n + 2, f, unit);\n    for (int i = 0; i < 2 * n + 2; ++i) {\n        int orig = pi[0].second * 2 + 1;\n        if (i < orig)\n            seg.update(i, b);\n        else if (i > orig)\n            seg.update(i, a);\n        else\n            seg.update(i, 0);\n    }\n\n    for (int i = 1; i < n; ++i) {\n        int orig = pi[i].second * 2 + 1;\n        for (int j = 0; j < 2 * n + 2; ++j) {\n            lint mini = seg.query(0, j + 1);\n            if (j < orig)\n                segn.update(j, mini + b);\n            else if (j > orig)\n                segn.update(j, mini + a);\n            else\n                segn.update(j, mini);\n        }\n        swap(seg, segn);\n    }\n    cout << seg.query(0, 2 * n + 2) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\n\n/*\n1~nを左から順に配置していく\ndp(i,j)=iをjに置く\n*/\n\nll n,A,B,a[5010],dp[5010]={},inf=1e18,ans=1e18;\n\nint main(void){\n\tcin>>n>>A>>B;\n\treg(i,1,n){\n\t\tll x;\n\t\tcin>>x;\n\t\ta[x]=i;\n\t}\n\treg(i,1,n){\n\t\tll c=inf;\n\t\treg(j,1,n){\n\t\t\tc=min(c,dp[j]);\n\t\t\tif(a[i]<j){\n\t\t\t\tdp[j]=c+A;\n\t\t\t}else if(a[i]>j){\n\t\t\t\tdp[j]=c+B;\n\t\t\t}else{\n\t\t\t\tdp[j]=c;\n\t\t\t}\n\t\t}\n\t}\n\treg(i,1,n)ans=min(ans,dp[i]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define inf (int)(3e18)\n#define P pair<int,int>\n#define mod (int)(1e9+7)\ntemplate<class T> inline void chmin(T &a, T b) {\n\ta = min(a, b);\n}\ntemplate<class T> inline void chmax(T &a, T b) {\n\ta = max(a, b);\n}\n\nint N,A,B;\nint p[5005],q[5005];\nint dp[5005][5005];\nint lo[5005][5005],up[5005][5005];\nsigned main(){\n\tcin>>N>>A>>B;\n\tREP(i,N+1){\n\t\tcin>>p[i];\n\t\tq[p[i]]=i;\n\t}\n\tint cnt[5005];memset(cnt,0,sizeof(cnt));\n\tREP(i,N+1){\n\t\tfor(int j=N;j>q[i];j--)lo[i][j]=cnt[j];\n\t\tfor(int j=q[i];j>0;j--){\n\t\t\tcnt[j]++;lo[i][j]=cnt[j];\n\t\t}\n\t}\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=N;i>0;i--){\n\t\trep(j,q[i])up[i][j]=cnt[j];\n\t\tfor(int j=q[i];j<=N;j++){\n\t\t\tcnt[j]++;up[i][j]=cnt[j];\n\t\t}\n\t}\n\trep(i,N+1)rep(j,N+2)dp[i][j]=inf;\n\tdp[0][N+1]=0;\n\trep(i,N+1)for(int j=N+1;j>i+1;j--){\n\t\tif(i<N){\n\t\t\tif(q[i+1]+lo[i][q[i+1]+1]-up[j][q[i+1]-1]==i+1){\n\t\t\t\tchmin(dp[i+1][j],dp[i][j]);\n\t\t\t}else chmin(dp[i+1][j],dp[i][j]+B);\n\t\t}\n\t\tif(j>1){\n\t\t\tif(q[j-1]+lo[i][q[j-1]+1]-up[j][q[j-1]-1]==j-1){\n\t\t\t\tchmin(dp[i][j-1],dp[i][j]);\n\t\t\t}else chmin(dp[i][j-1],dp[i][j]+A);\n\t\t}\n\t}\n\tint ans=inf;\n\trep(i,N+1){\n\t\tchmin(ans,dp[i][i+1]);\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst LL INF=1e18;\nint n,A,B,a[5555],s[5010][5010];\nLL f[5555],ans;\nint main(){\n\tcin>>n>>A>>B;\n\tFOR(i,1,n) getint(a[i]);\n\tFOR(i,1,n){\n\t\tFOR(j,1,n) s[i][j]=s[i-1][j];\n\t\tFOR(j,a[i],n) s[i][j]++;\n\t}\n\tf[0]=0;\n\tFOR(i,1,n){\n\t\tf[i]=INF;\n\t\tFORD(j,i-1,0){\n\t\t\t//j+1..i-1\n\t\t\tif (a[i]<a[j]) continue;\n\t\t\tf[i]=min(f[i],f[j]+1ll*(i-j-1-(s[i-1][a[i]]-s[j][a[i]]))*A+1ll*(s[i-1][a[j]]-s[j][a[j]])*B+1ll*(s[i-1][a[i]]-s[i-1][a[j]]-s[j][a[i]]+s[j][a[j]])*min(A,B));\n\t\t}\n\t}\n\tans=INF;\n\tFOR(i,1,n){\n\t\tans=min(ans,f[i]+1ll*B*(s[n][a[i]]-s[i][a[i]])+1ll*((n-i)-s[n][a[i]]+s[i][a[i]])*min(A,B));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 5002\n\nint n;\nint A;\nint B;\n\nlong long int dp[MAX][MAX];\nbool us[MAX][MAX];\n\n\nvector<int> v;\n\n\ninline long long int dfs(int a, int b) {\n\tif (a == n) {\n\t\treturn 0;\n\t}\n\tif (us[a][b])return dp[a][b];\n\tus[a][b] = true;\n\tdp[a][b] = LLONG_MAX;\n\tif (b == 0 || v[b - 1] < v[a]) {\n\t\tdp[a][b] = min(dp[a][b], dfs(a + 1, a + 1));\n\t}\n\tif (b == 0 || v[b - 1] < v[a]) {\n\t\tdp[a][b] = min(dp[a][b], dfs(a + 1, b) + A);\n\t}\n\telse {\n\t\tdp[a][b] = min(dp[a][b], dfs(a + 1, b) + B);\n\t}\n\treturn dp[a][b];\n}\n\nint main() {\n\tcin >> n >> A >> B;\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\tv.push_back(p);\n\t}\n\tprintf(\"%lld\\n\", dfs(0, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nProblem Source : agc-032D\nAuthor : oier_hzy\nTime : Nov 24 2019\n*/\n\n/*\nA : move a element to the right\nB : ... left\n\nIn the best case, there're several fixed elements\nWe could consider all the circumstances during DP procession\n\nf[i][j] : the first i elements (by coordinate) has been considered, and the last fixed coordinate is j\n*/\n\n#include <cstdio>\ntypedef long long ll;\n\ntemplate <typename _tp> inline void cmin(_tp&x, const _tp y) {if(x > y) x = y;}\n\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst int N = 5001;\nint a[N];\nll f[N], g[N];\nint n, A, B;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor(int i = 1; i <= n; ++ i) scanf(\"%d\", a+i);\n\t\n\tfor(int i = 0; i <= n; ++ i) f[i] = g[i] = +oo;\n\tf[0] = 0;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 0; j < a[i]; ++ j) {\n\t\t\tcmin(g[j], f[j] + A);\n\t\t\tcmin(g[a[i]], f[j]);\n\t\t}\n\t\tfor(int j = a[i]; j <= n; ++ j)\n\t\t\tcmin(g[j], f[j] + B);\n\t\tfor(int j = 0; j <= n; ++ j) f[j] = g[j], g[j] = +oo;\n\t}\n\t\n\tll Ans = +oo;\n\tfor(int i = 0; i <= n; ++ i)\n\t\tcmin(Ans, f[i]);\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define N 5050\nusing namespace std;\n\nint n, a, b, p[N];\nlong long f[N << 1][N];\n\ninline int calc(int j, int i) {\n    if (p[j] < i) return a;\n    if (p[j] > i) return b;\n    return 0;\n}\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> a >> b;\n    for (int i = 1, x; i <= n; ++i)\n        scanf(\"%d\", &x), p[x] = i;\n\n    memset(f, 0x3f, sizeof f);\n    f[0][0] = 0;\n    for (int i = 1; i <= (n << 1 | 1); ++i) {\n        f[i][0] = 0;\n        for (int j = 1; j <= n; ++j)\n            if (i & 1) {\n                f[i][j] = min(f[i - 1][j], f[i][j - 1] + (p[j] <= i / 2 ? a : b));\n            } else {\n                f[i][j] = min(f[i - 1][j], f[i - 1][j - 1] + calc(j, i / 2));\n            }\n    }\n\n    cout << f[n << 1 | 1][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nll dp[5005][5005];\nll N, A, B;\nll p[5000];\n\nint main() {\n    cin >> N >> A >> B;\n    for(int i = 0; i < N; i++) {\n        cin >> p[i];\n    }\n    for(int i = 0; i <= N; i++) {\n        for(int j = 0; j <= N; j++) {\n            dp[i][j] = 1e18;\n        }\n    }\n    dp[0][0] = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j <= N; j++) {\n            if(p[i] < j) {\n                chmin(dp[i+1][j], dp[i][j] + B);\n            } else {\n                chmin(dp[i+1][j], dp[i][j] + A);\n                chmin(dp[i+1][p[i]], dp[i][j]);\n            }\n        }\n    }\n    ll ans = 1e18;\n    for(int i = 0; i <= N; i++) {\n        chmin(ans, dp[N][i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 5007;\nconst ll INF = 1e18;\n\nll f[MX][MX];\nint a[MX];\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n, A, B;\n    cin >> n >> B >> A;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i <= n + 1; i++) {\n        for (int j = 0; j <= n + 1; j++) {\n            f[i][j] = INF;\n        }\n    }\n    f[0][0] = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n; j++) {\n            int x = a[i + 1];\n            if (x < j) {\n                f[i + 1][j] = min(f[i + 1][j], f[i][j] + A);\n            } else {\n                f[i + 1][x] = min(f[i + 1][x], f[i][j]);\n                f[i + 1][j] = min(f[i + 1][j], f[i][j] + B);\n            }\n        }\n    }\n    ll ans = INF;\n    for (int i = 0; i <= n; i++) {\n        ans = min(ans, f[n][i]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 5555;\nlong long dp[N][N];\n\nvoid remin(long long& x, long long y) {\n\tif (x == -1 || x > y) {\n\t\tx = y;\n\t}\n}\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt(), cost_r = nxt(), cost_l = nxt();\n\tvector<int> p(n), q(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tp[i] = nxt() - 1;\n\t\tq[p[i]] = i;\n\t}\n\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0][0] = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint num_less = 0, num_greater = 0;\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (p[j] < p[i]) {\n\t\t\t\t++num_less;\n\t\t\t} else {\n\t\t\t\t++num_greater;\n\t\t\t}\n\t\t}\n\t\tremin(dp[i][i], 1ll * cost_r * num_greater + 1ll * cost_l * num_less);\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (dp[i - 1][j] == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[i] < p[j]) {\n\t\t\t\tremin(dp[i][j], dp[i - 1][j] + cost_l);\n\t\t\t} else {\n\t\t\t\tremin(dp[i][j], dp[i - 1][j] + cost_r);\n\t\t\t\tremin(dp[i][i], dp[i - 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long ans = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (dp[n - 1][i] > -1) {\n\t\t\tremin(ans, dp[n - 1][i]);\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=5e3+5;\nconst ll inf=1e15;\n\nint n,a,b,p[N];\nll f[N][N];\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfo(i,1,n) scanf(\"%d\",&p[i]);\n\tfo(i,0,n) fo(j,0,n) f[i][j]=inf;f[0][0]=0;\n\tfo(i,1,n)\n\t\tfo(j,0,n)\n\t\t\tif (f[i-1][j]!=inf) \n\t\t\t\tif (p[i]>j) {\n\t\t\t\t\tf[i][j]=min(f[i][j],f[i-1][j]+a);\n\t\t\t\t\tf[i][p[i]]=min(f[i][p[i]],f[i-1][j]);\n\t\t\t\t} else f[i][j]=min(f[i][j],f[i-1][j]+b);\n\tll ans=inf;\n\tfo(i,0,n) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 1000000000000000000;\n\tcin >> N >> A >> B;\n\tvector<long long> P(N);\n\tvector<vector<long long> > DP(N + 1, vector<long long>(N + 1, INF));\n\tDP[0][0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (DP[i][j] >= INF) continue;\n\t\t\tif (j < P[i]) {\n\t\t\t\tDP[i + 1][P[i]] = min(DP[i + 1][P[i]], DP[i][j]);\n\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + A);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + B);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[N][i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define y1 A2Dalek\n#define y0 Cyberman\n#define yn RoseTyler\n#define j1 JackHarkness\n#define fs first\n#define sd second\nconst int N=5000;\nconst long long oo=1e16+5;\nint du[]={-1,0,0,1};\nint dv[]={0,-1,1,0};\nconst long long mod=1e9+7;\ntypedef pair<int,int> ii;\ntypedef pair<int,ii> iii;\nlong long sqr(long long x) {return x*x;}\nint getbit(int state, int i) {return ((state>>i)&1);}\n\nint n,a[N+5];\nlong long A,B,f[N+5];\nint main()\n{\n\t//freopen(\"Rotation Sort.inp\",\"r\",stdin);\n\t//freopen(\"Rotation Sort.out\",\"w\",stdout);\n\tios_base::sync_with_stdio(false);\n    cin>>n>>A>>B;\n    for (int i=1;i<=n;i++) cin>>a[i];\n    a[n+1]=n+1; n++;\n    for (int i=1;i<=n;i++)\n    {\n        f[i]=oo;\n        int dem1=0, dem2=0;\n        for (int j=i-1;j>=0;j--)\n        {\n            if (a[j]<a[i]) f[i]=min(f[i],f[j]+dem1*A+dem2*B);\n            if (a[j]<a[i]) dem1++; else dem2++;\n        }\n    }\n    cout<<f[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nint n, p[5010], pos[5010];\nll A, B, ans;\n\nint main() {\n    scanf(\"%d %lld %lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) if (p[j] == i) {\n            ans += min(A * (j - i), B);\n            if (A * (j - i) > B) {\n                for (int k = j; k > i; k--) p[k] = p[k - 1];\n                p[i] = i;\n            } else {\n                for (int k = i; k < j; k++) {\n                    pos[k - i + 1] = k;\n                }\n                sort(pos + 1, pos + j - i + 1, [&](int x, int y) { return p[x] < p[y]; });\n                for (int k = 1; k <= j - i; k++) {\n                    int num = p[pos[k]];\n                    for (int t = pos[k]; t < num; t++) p[t] = p[t + 1];\n                    p[num] = num;\n                }\n            }\n            break;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 1e16 + 7;\n\nint n, a[5005];\nLL A, B;\nLL dp[5005];\n\nint main()\n{\n\tscanf(\"%d%lld%lld\", &n, &A, &B);\n\trep1(i, n) scanf(\"%d\", &a[i]);\n\ta[n + 1] = n + 1;\n\tn ++;\n\t\n\tdp[0] = 0;\n\trep1(i, n) dp[i] = INF;\n\t\n\trep1(i, n) {\n\t\tint cntr = 0, cmin = a[i];\n\t\tfor(int j = i - 1; j >= 0; j --) {\n\t\t\tif(a[j] > a[i]) cntr ++;\n\t\t\telse {\n\t\t\t\tif(cmin > a[i]) continue;\n\t\t\t\tint cntl = i - j - 1 - cntr;\n\t\t\t\tdp[i] = min(dp[i], dp[j] + A * cntr + B * cntl);\n\t\t\t\tcmin = a[i];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nint main() {\n    int n; i64 a, b;\n    std::cin >> n >> a >> b;\n    std::vector<int> p(n + 1);\n    for (int i = 1; i <= n; i++) {\n        int in;\n        std::cin >> in;\n        p[in] = i * 2 - 1;\n    }\n    std::vector<std::vector<i64>> dp(n + 1, std::vector<i64>(2 * n + 2));\n    std::vector<i64> v(2 * n + 2);\n    for (int i = 1; i <= n; i++) {\n        v[0] = std::numeric_limits<i64>::max();\n        dp[i][0] = dp[i - 1][0] + b;\n        for (int j = 0; j < 2 * n + 1; j++) {\n            v[j + 1] = std::min(v[j], dp[i - 1][j]);\n            dp[i][j + 1] = v[j + 1] + (p[i] < j ? a : p[i] == j ? 0 : b);\n        }\n    }\n    std::cout << *std::min_element(dp[n].begin(), dp[n].end()) << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5002;\nint n,A,B,a[N],i,j;\nlong long f[N],tot;\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\ta[n+1]=n+1,n++;\n\tmemset(f,63,sizeof(f));\n\tf[0]=0;\n\tfor (i=1;i<=n;i++){\n\t\ttot=0;\n\t\tfor (j=i-1;~j;j--)\n\t\t\tif (a[j]<a[i]) f[i]=min(f[i],f[j]+tot),tot+=B;\n\t\t\telse tot+=A;\n\t}\n\tprintf(\"%lld\",f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 5007\n\nint N, pos[MAX_N];\nll A, B, f[MAX_N][MAX_N];\n\nint main() {\n#ifdef LOCAL\n    FIN(\"in\");\n#endif\n    read(N), read(A), read(B);\n    Rep(i, N) pos[input<int>()] = i;\n    rep(i, 0, N) rep(j, 0, N) f[i][j] = 1e16;\n    f[0][0] = 0;\n    Rep(i, N) {\n        lep(j, 0, i) {\n            if (pos[i] > pos[j]) {\n                chmin(f[i][i], f[i - 1][j]);\n                chmin(f[i][j], f[i - 1][j] + B);\n            } else\n                chmin(f[i][j], f[i - 1][j] + A);\n        }\n    }\n    ll res = 1e16;\n    rep(i, 0, N) chmin(res, f[N][i]);\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define nmax 5005\nusing namespace std;\nint n, mx[nmax+1], mn[nmax+1], p[nmax+1];\nlong long dp[nmax+2][nmax+2], a, b;\nint main()\n{\n    std::ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> a >> b;\n    for(int i = 1; i <= n; ++i)\n      cin >> p[i];\n    for(int i = 1; i <= n; ++i){\n      mn[p[i]] = n + 1;\n      for(int j = 1; j < i; ++j)\n        if(p[j] > p[i] && mn[p[i]] > p[j]) mn[p[i]] = p[j];\n    }\n    for(int i = n; i >= 1; --i){\n      mx[p[i]] = 0;\n      for(int j = n; j > i; --j)\n        if(p[j] < p[i] && mx[p[i]] < p[j]) mx[p[i]] = p[j];\n    }\n    dp[0][n + 1] = 0;\n    for(int j = n; j > 0; --j)\n      dp[0][j] = (mx[j] == 0) ? dp[0][j + 1] : dp[0][j + 1] + a;\n    for(int i = 1; i <= n; ++i){\n      dp[i][n + 1] = (mn[i] == n + 1) ? dp[i - 1][n + 1] : dp[i - 1][n + 1] + b;\n      for(int j = n; j > i; --j){\n        dp[i][j] = (mn[i] >= j) ? dp[i - 1][j] : dp[i - 1][j] + b;\n        dp[i][j] = min(dp[i][j], ((mx[j] <= i) ? dp[i][j + 1] : dp[i][j + 1] + a));\n      }\n    }\n    long long ans = dp[0][1];\n    for(int i = 0; i <= n; ++i)\n      ans = min(ans, dp[i][i + 1]);\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nint N;\nll A,B;\nint p[5010],where[5010];\nll dp[5010][5010];\nconst ll inf = 1e18;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tcin >> N >> A >> B;\n\trep(i,N) cin >> p[i],p[i]--,where[p[i]] = i;\n\n\trep(i,N+1) rep(j,N+1) dp[i][j] = inf;\n\n\tdp[0][0] = 0;\n\trep(i,N){\n\t\trep(j,N+1) if(dp[i][j] != inf){\n\t\t\tif(j != N){\n\t\t\t\tchmin(dp[i][j+1],dp[i][j]);\n\t\t\t}\n\t\t\tif(p[i] == j){\n\t\t\t\tchmin(dp[i+1][j+1],dp[i][j]);\n\t\t\t}\n\t\t\tif(p[i] < j){\n\t\t\t\tchmin(dp[i+1][j],dp[i][j] + B);\n\t\t\t}\n\t\t\tif(p[i] > j){\n\t\t\t\tchmin(dp[i+1][j],dp[i][j] + A);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = inf;\n\trep(j,N+1) chmin(ans,dp[N][j]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nlong long p[5005],mn[5005][15],mx[5005][15],A,B,F[5005][5005],n;\nlong long getmax(long long l,long long r)\n{\n    long long kq=0;\n    while (l<=r)\n    {\n        long long x=trunc(log2(r-l+1));//cout<<l<<' '<<r<<' '<<x<<endl;\n        kq=max(kq,mx[l][x]);\n        l=l+(1<<x);\n    }\n    return kq;\n}\nlong long getmin(long long l,long long r)\n{\n    long long kq=n+1;\n    while (l<=r)\n    {\n        long long x=trunc(log2(r-l+1));//cout<<l<<' '<<r<<' '<<x<<endl;\n        kq=min(kq,mn[l][x]);\n        l=l+(1<<x);\n    }\n    return kq;\n}\nint main()\n{\n   \n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n>>A>>B;\n    for (long long i=1;i<=n;++i) {cin>>p[i];mn[i][0]=mx[i][0]=p[i];}\n    for (long long k=1;(1<<k)<=n;++k)\n     for (long long i=1;i+(1<<k)-1<=n;++i)\n    {\n        mn[i][k]=min(mn[i][k-1],mn[i+(1<<(k-1))][k-1]);\n        mx[i][k]=max(mx[i][k-1],mx[i+(1<<(k-1))][k-1]);\n    }\n    for (long long step=2;step<=n;++step)\n     for (long long i=1;i+step-1<=n;++i)\n    {\n        long long j=i+step-1;\n        if (p[j]>getmax(i,j-1)) F[i][j]=F[i][j-1];\n        else                    F[i][j]=F[i][j-1]+B;\n        if (p[i]<getmin(i+1,j)) F[i][j]=min(F[i][j],F[i+1][j]);\n        else                    F[i][j]=min(F[i][j],F[i+1][j]+A);\n       // cout<<i<<' '<<j<<' '<<F[i][j]<<endl;\n    }\n    cout<<F[1][n];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <assert.h>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 5005;\nconst ll INF = 1e18;\n\nint n,A,B;\nint p[MAXN];\n\nll ans;\nll f[MAXN][MAXN];\nll MIN[MAXN][MAXN];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n >> A >> B;\n\tfor (int v,i = 1;i <= n;i++)\n\t{\n\t\tcin >> v;\n\t\tp[v] = i;\n\t}\n\tans = INF;\n\tfor (int i = 0;i <= n;i++)\n\t\tfor (int j = 0;j <= n;j++)\n\t\t\tf[i][j] = MIN[i][j] = INF;\n\tf[0][0] = 0;\n\tfor (int i = 0;i <= n;i++)\n\t\tMIN[0][i] = 0;\n\tfor (int i = 1;i <= n;i++)\n\t\tfor (int j = 0;j <= n;j++)\n\t\t{\n\t\t\tif (j == p[i])\n\t\t\t\tf[i][j] = MIN[i - 1][j - 1];\n\t\t\telse if (j < p[i])\n\t\t\t\tf[i][j] = MIN[i - 1][j] + B;\n\t\t\telse\n\t\t\t\tf[i][j] = MIN[i - 1][j] + A;\n\t\t\tif (!j)\n\t\t\t\tMIN[i][j] = f[i][j];\n\t\t\telse\n\t\t\t\tMIN[i][j] = min(MIN[i][j - 1],f[i][j]);\n\t\t\tif (i == n)\n\t\t\t\tans = min(ans,f[i][j]);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,x,y,a[5005],f[5005];\nll dp[5005];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&x,&y);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]),f[a[i]]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int pos=f[i];\n        ll t=1e18;\n        for(int j=1;j<=n;j++)\n        {\n            t=min(t,dp[j]);\n            if(pos>j)\n                dp[j]=t+y;\n            else if(pos==j)\n                dp[j]=t;\n            else dp[j]=t+x;\n        }\n    }\n    printf(\"%lld\\n\",dp[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5050;\n\nint a[N];\nlong long f[N];\n\nint main() {\n\tint n, A, B;\n\tscanf(\"%d %d %d\", &n, &A, &B);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t}\n\ta[0] = 0;\n\ta[n + 1] = n + 1;\n\tf[0] = 0;\n\tfor (int i = 1; i <= n + 1; ++i) {\n\t\tf[i] = 1e18;\n\t\tint cnt = 0;\n\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\tif (a[i] > a[j]) {\n\t\t\t\tf[i] = min(f[i], f[j] + (long long) A * cnt + (long long) B * (i - j - 1 - cnt));\n\t\t\t} else {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[n + 1]);\t\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\n\nusing namespace std;\n\nconst int N = 5000 + 5;\nlong long dp[N][N];\nint p[N];\nint a;\nint b;\nint n;\n \nint main () \n{\n    cin >> n >> a >> b;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> p[i];\n    }\n    memset(dp, 127, sizeof dp);\n    dp[0][0] = 0;\n    for (int i = 1;i <= n; i++)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            if(p[i] > j)\n            {\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + a);\n                dp[i][p[i]] = min(dp[i][p[i]],dp[i-1][j]);\n            }\n            else\n            {\n                dp[i][j] = min(dp[i][j],dp[i-1][j] + b);\n            }\n        }\n    }\n    long long ans = dp[n][1];\n    for (int i = 1; i <= n; i++)\n    {\n        ans = min(ans, dp[n][i]);\n    }\n    cout << ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int, int >\n#define F first\n#define S second\n#define int  long long int\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\nusing namespace std;\n/// age ye mosh dp ro baze dashti dp tedad baz shodeye baste nashode yadet nare !!\n/// joooob zadam\nconst int N=5003;\nll dp[N][N];\nll last[N][N];\nll b[N][N];\nll a[N];\nint32_t main(){\n    ll n,a1,b1;\n    cin >> n >> a1 >> b1 ;\n    for (int i=1;i<=n;i++){\n        cin >> a[i];\n    }\n    for (int i=1;i<=n;i++){\n        for (int j=0;j<N;j++){\n            if (a[i]<j){\n                last[i][j]=i;\n            }\n            else{\n                last[i][j]=last[i-1][j];\n            }\n            if (a[i]>j){\n                b[i][j]=b[i-1][j]+1;\n            }\n            else{\n                b[i][j]=b[i-1][j];\n            }\n        }\n    }\n    a[0]=0;\n    memset(dp,69,sizeof dp);\n    for (int i=0;i<N;i++){\n        dp[0][i]=0;\n    }\n    for (int i=1;i<=n;i++){\n        for (int j=0;j<N;j++){\n            ll l=last[i][j];\n          //  for (int k=i;k>0;k--){\n            //    if (a[k]<j){\n                 //   l=k;\n                   // break;\n           //     }\n           // }\n            if (!l){\n                dp[i][j]=0;\n                continue;\n            }\n            dp[i][j]=dp[l-1][j]+b1;\n            //ll z=0;\n            ll z=b[l][a[l]]-b[l][j-1];\n          //  for (int k=1;k<l;k++){\n            //    if (a[k]>a[l] && a[k]<j){\n                    //z++;\n              //  }\n          //  }\n            dp[i][j]=min(dp[i][j],dp[l-1][a[l]]+z*a1);\n            //cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n    }\n    cout << dp[n][N-1];\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define f(i,a,b) for (int i = a; i < b; i++)\n#define Min(a,b) a=min(a,b)\n\nconst ll oo = 1e18;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint n;\n\tcin>>n;\n\tint p[n];\n\tint rt,lt; cin>>rt>>lt;\n\tf(i,0,n) cin>>p[i];\n\tll dp[n][n];\n\tf(i,0,n) f(j,0,n) dp[i][j] = oo;\n\tf(i,0,n) {\n\t\tint gr = 0, ls = 0;\t\n\t\tf(j,0,i) if (p[j]>p[i]) gr++;\n\t\telse ls++;\n\t\tdp[i][i] = 1LL*gr*rt+1LL*ls*lt;\n\t\tf(j,0,i) if (dp[i-1][j]!=oo) {\n\t\t\tif (p[j] > p[i]) // has to move left\t\n\t\t\t\tMin(dp[i][j],dp[i-1][j]+lt);\n\t\t\telse { // has to move right ... moving left doesn't make sense\n\t\t\t\tMin(dp[i][j],dp[i-1][j]+rt);\t\n\t\t\t\t// not moving\n\t\t\t\tMin(dp[i][i],dp[i-1][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = oo;\n\tf(i,0,n) Min(ans,dp[n-1][i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 320000\nusing namespace std;\nint n,A,B;\nint L[N],R[N];\nlong long f[5200][5200]; \nint a[5200];\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif(n==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ta[x]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++)if(a[j]<a[i]){L[i]=j;break;}\n\t\tfor(int j=i-1;j>=1;j--)if(a[j]>a[i]){R[i]=j;break;}\n\t}\n\tmemset(f,77,sizeof(f));\n\tf[0][n+1]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=n+1;j>i;j--){\n\t\t\tif(L[i]<j)f[i+1][j]=min(f[i][j]+B,f[i+1][j]);\n\t\t\telse f[i+1][j]=min(f[i][j],f[i+1][j]);\n\t\t\tif(R[j]>i)f[i][j-1]=min(f[i][j]+A,f[i][j-1]);\n\t\t\telse f[i][j-1]=min(f[i][j],f[i][j-1]);\n\t\t}\n\t}\n\tlong long ans=100000000000000LL;\n\tfor(int i=0;i<=n;i++)ans=min(ans,f[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn=5005;\nll dp[maxn][maxn],a[maxn];\nll n,A,B,ans;\nint main(){\n\tn = read(),A = read(),B = read();\n\tans = 1ll << 60;\n\tRep(i,1,n) a[i] = read();\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0] = 0;\n\tRep(i,1,n)Rep(j,0,n){\n\t\tif(a[i] > j)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j] + A),\n\t\t\tdp[i][a[i]]=min(dp[i][a[i]],dp[i-1][j]);\n\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n\t}\n\tRep(i,0,n) ans=min(ans,dp[n][i]);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nll n,m,T,k,q;\nconst ll big = 1000000007;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\nuniform_int_distribution<> DD(0, 1000000000);\n\nll random(ll r){\n    return (ll(DD(eng))*1000000000 + ll(DD(eng)))%r;\n}\n\nconst ll MAXN = 5001;\n\nll P[MAXN];\nll P2[MAXN];\n\nll A,B;\n\nll DP[MAXN][MAXN] = {0};\nbool DPC[MAXN][MAXN] = {0};\n\nll dp(ll i, ll rp){\n    if(i == n)return 0;\n    if(DPC[i][rp])return DP[i][rp];\n    ll ans = 0;\n    if(P2[i] < rp){\n        ans = A + dp(i+1, rp);\n    }\n    else{\n        ans = min(B + dp(i+1, rp), dp(i+1, P2[i]));\n    }\n    DP[i][rp] = ans;\n    DPC[i][rp] = 1;\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"autput.txt\",\"w\",stdout);\n\n    ll a,b,c,d;\n\n    cin >> n >> A >> B;\n\n    for(int c1 = 0; c1 < n; c1++){\n        cin >> a;\n        a--;\n        P[c1] = a;\n        P2[a] = c1;\n    }\n\n    a = dp(0,0);\n    cout << a << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#define NDEBUG 1\n#endif\n#include<bits/stdc++.h>\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint number, leftMoveCost, rightMoveCost; std::cin>>number>>rightMoveCost>>leftMoveCost;\n\tstd::vector<int> data(number), pos(number);\n\tfor(int index=0;index<number;++index) {\n\t\tauto& item=data[index];\n\t\tstd::cin>>item;--item; \n\t\tpos[item]=index;\n\t}\n\n\tstd::vector f(number+1, std::vector<int64_t>(number+1, INT64_MAX));\n\tf[0][0]=0;\n\n\t// f[a][b]=minimum cost to move a smallest numbers to the left, and\n\t// b numbers at first indices(including those that may be moved to the left)\n\t// to an arbitrary position to the right)\n\tfor(int a=0;a<number;++a) {\n\t\tstd::vector<int> uncoveredSuffix(number+1);\n\t\tfor(int cur=0,index=number; index--;){\n\t\t\tuncoveredSuffix[index]=cur+=(data[index]>=a);\n\t\t}\n\n\n\t\tfor(int b=0;b<=number;++b) if(f[a][b]!=INT64_MAX) {\n\t\t\tauto const cur=f[a][b];\n\t\t\tf[a+1][b]=std::min(f[a+1][b], cur+leftMoveCost);\n\t\t\tauto const rightMoveCount=std::max(0,uncoveredSuffix[b]-uncoveredSuffix[pos[a]]);\n\t\t\tauto& next2=f[a+1][b+rightMoveCount];\n\t\t\tnext2=std::min(next2, cur+(int64_t)rightMoveCost*rightMoveCount);\n\t\t}\n\t}\n\n\tstd::cout<<*std::min_element(begin(f[number]),end(f[number]))<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 998244353ll;\nconst ll MAXN = (ll) 5e3 + 100;\nconst ll INF = (ll) 9223372036854775;\nconst ld EPS = (ld) 1e-8;\n\nll a[MAXN], dp[MAXN], ind[MAXN];\nvector<ll> fr;\n\n\nll BS2(ll x){\n\tll l = -1, r = fr.size();\n\tll mid;\n\twhile(l + 1 < r){\n\t\tmid = (l + r) / 2;\n\t\tif(fr[mid] < x) l = mid;\n\t\telse r = mid;\n\t}\n\treturn fr.size() - r;\n}\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tll n, A, B;\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t\tind[a[i]] = i;\n\t}\n\t\n\tmemset(dp, 31, sizeof dp);\n\tdp[0] = 0;\n\ta[0] = -1;\n\tll ans = n * A;\n\tfor(int i = 1; i <= n; i++){\n\t\tll ca = 0;\n\t\tll cb = 0;\n\t\tfr.clear();\n\t\tfor(int j = i + 1; j <= n; j++) fr.pb(a[j]);\n\t\tsort(all(fr));\n\t\tfor(int j = i - 1; j > 0; j--){\n\t\t\tif(a[j] < a[i]){\n\t\t\t\tll cnt = BS2(a[j]) - BS2(a[i]);\n\t\t\t\tdp[i] = min(dp[i], dp[j] + cnt * B + ((a[i] - a[j] - 1) - cnt) * A);\n\t\t\t}\n\t\t}\n\t\tdp[i] = min(dp[i], B * (a[i] - 1));\n\t\tans = min(ans, dp[i] + (n - a[i]) * A);\n\t}\n\tcout << ans;\n \t\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL N=5010;\nLL n, a, b, p[N], id[N], dp[N][N], s[N][N];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\tfor(LL i=1; i<=n; ++i)scanf(\"%lld\",&p[i]), id[p[i]]=i;\n\tmemset(s,127,sizeof(s));\n\tfor(LL i=0; i<=n; ++i)s[0][i]=0;\n\tfor(LL i=1; i<=n; ++i)\n\t\tfor(LL j=1; j<=n; ++j){\n\t\t\tdp[i][j]=s[i-1][j]+(j>=id[i]?a:b);\n\t\t\tif(j==id[i])dp[i][j]=min(dp[i][j],s[i-1][j-1]);\n\t\t\tif(j>1)s[i][j]=min(s[i][j-1],dp[i][j]);else s[i][j]=dp[i][j];\n\t\t}\n\tLL mn=0x3f3f3f3f3f3f3f3f;\n\tfor(LL i=1; i<=n; ++i)mn=min(mn,dp[n][i]);\n\tprintf(\"%lld\",mn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\nclass Lazy_segment_tree\n{\n    using data_type = int;\n\npublic:\n\n    vector<data_type> dat, lazy;\n    int N;\n    data_type id, id2;\n\n    //区間演算結果を求めるクエリに関する演算\n    data_type func(data_type u, data_type v){\n        return min(u, v);\n    }\n    //区間更新に関する演算\n    data_type func2(data_type u, data_type v){\n        return u + v;\n    }\n    //作用素同士の演算\n    data_type func3(data_type u, data_type v){\n        return u + v;\n    }\n\n    Lazy_segment_tree(int n, data_type id, data_type id2): id(id), id2(id2) {\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<data_type>(2 * N - 1, id);\n        lazy = vector<data_type>(2 * N - 1, id2);\n    }\n\n    Lazy_segment_tree(int n, data_type id, data_type id2, vector<data_type> v): id(id), id2(id2) {\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<data_type>(2 * N - 1, id);\n        lazy = vector<data_type>(2 * N - 1, id2);\n        REP(i, n) dat[i + N - 1] = v[i];\n        IREP(i, N - 1) dat[i] = func(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n\n    //遅延評価\n    void eval(int k, int l, int r){\n        if(lazy[k] != id2){\n            //子ノード数に比例した量の演算をする場合\n            //dat[k] = func2(dat[k], lazy[k] * (r - l));\n            //子ノード数に依存しない場合\n            dat[k] = func2(dat[k], lazy[k]);\n\n            if(r - l > 1){\n                lazy[k * 2 + 1] = func3(lazy[k * 2 + 1], lazy[k]);\n                lazy[k * 2 + 2] = func3(lazy[k * 2 + 2], lazy[k]);\n            }\n\n            lazy[k] = id2;\n        }\n    }\n\n    void update(int a, int b, data_type x, int k, int l, int r){\n\n        eval(k, l, r);\n\n        if(b <= l || r <= a) return;\n\n        if(a <= l && r <= b){\n            lazy[k] = func3(lazy[k], x);\n            eval(k, l, r);\n        }else{\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n            dat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n\n    }\n\n    data_type query(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return id;\n\n        eval(k, l, r);\n        if(a <= l && r <= b) return dat[k];\n        else{\n            data_type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            data_type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return func(vl, vr);\n        }\n    }\n\n    //[a,b)の区間更新\n    void update(int a, int b, data_type x){\n        update(a, b, x, 0, 0, N);\n    }\n\n    //[a, b)の演算結果\n    data_type query(int a, int b){\n        return query(a, b, 0, 0, N);\n    }\n\n    data_type getdat(int k){\n        return query(k, k + 1);\n    }\n};\n\nsigned main(){\n\n    int N, A, B; cin >> N >> A >> B;\n    vec p(N); readv(p);\n\n    vec dp(N + 1, INF / 10);\n    dp[0] = 0;\n    Lazy_segment_tree ST(N + 1, INF, 0, dp);\n    REP(i, N){\n        int v = ST.query(0, p[i]);\n        ST.update(0, p[i], A);\n        ST.update(p[i] + 1, N + 1, B);\n        ST.update(p[i], p[i] + 1, -ST.getdat(p[i]) + v);\n    }\n    int ans = ST.query(0, N + 1);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define ll long long\nconst int N=5010;\nint n,a,b,x,p[N];\nll dp[N][N];\nint main() {\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\trep(i,1,n+1) scanf(\"%d\",&x),p[x]=i;\n\tmemset(dp,0x20,sizeof(dp));\n\tdp[0][0]=0;\n\trep(i,1,n+1) rep(j,0,i) {\n\t\tif (p[i]>p[j]) {\n\t\t\tdp[i][i]=min(dp[i][i],dp[i-1][j]);\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+b);\n\t\t} else\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+a);\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nlong long dp[5010][5010];\n\n\nclass Solution {\n  int n;\n  vector<int> A;\n  long long costA, costB;\n  long long dfs(int i, int j) {\n    if (dp[i][j] != -1) return dp[i][j];\n    if (j - i == 1) return dp[i][j] = 0;\n    long long ans = 1e18;\n    for (int k = i + 1; k < j; ++k) {\n      if (A[i] < A[k] and A[k] < A[j]) {\n        ans = min(ans, dfs(i, k) + dfs(k, j));\n      }\n    }\n    if (ans == 1e18) {\n      ans = 0;\n      for (int k = i + 1; k < j; ++k) ans += A[k] < A[i] ? costB : costA;\n    }\n    return dp[i][j] = ans;\n  }\npublic:\n  void run() {\n    memset(dp, -1, sizeof(dp));\n    cin >> n;\n    cin >> costA >> costB;\n    A = {0};\n    for (int i = 0; i < n; ++i) {\n      int a; cin >> a;\n      A.push_back(a);\n    }\n    A.push_back(n + 1);\n    cout << dfs(0, n + 1) << '\\n';\n  }     \n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  Solution().run();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\nint n, a, b, p[5010], pos[5010];\n\nint64 f[5010][5010];\n\nint c1[5010], c2[5010][5010];\n\nint c3[5010], c4[5010][5010];\n\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; ++i) cin >> p[i], pos[p[i]] = i;\n  for (int i = 0; i <= n; ++i) {\n  \tfor (int j = 0; j <= n; ++j) {\n  \t  f[i][j] = 1e18;\n\t}\n  }\n  for (int i = 1; i <= n; ++i) {\n  \tfor (int j = i + 1; j <= n; ++j) {\n  \t  if (p[i] > p[j]) {\n  \t  \t++c1[i];\n\t  }\n\t}\n\tfor (int j = 1; j < i; ++j) {\n\t  ++c2[i][p[j]];\n\t}\n\tfor (int j = n; ~j; --j) c2[i][j] += c2[i][j + 1];\n\tfor (int j = 1; j < i; ++j) {\n\t  if (p[i] < p[j]) {\n\t  \t++c3[i];\n\t  }\n\t}\n\tfor (int j = i + 1; j <= n; ++j) {\n\t  ++c4[i][p[j]];\n\t}\n\tfor (int j = 1; j <= n; ++j) c4[i][j] += c4[i][j - 1];\n  }\n  f[0][0] = 0;\n  int64 ans = 1e18;\n  for (int i = 0; i <= n; ++i) {\n  \tfor (int j = 0; j + i <= n; ++j) {\n  \t  if (!i && !j) {\n  \t  \tcontinue;\n\t  }\n\t  if (i) {\n\t  \tint X = c1[pos[i]]; //ÔÚËüÓÒ±ß±ÈËüÐ¡µÄÊýµÄ¸öÊý\n\t\tint Y = c2[pos[i]][n - j + 1]; //ÔÚËü×ó±ß´óÓÚµÈÓÚn-j+1µÄÊýµÄ¸öÊý \n\t  \tint c = pos[i] + X - Y;\n\t  \t//cerr << \"fir : \" << i << \", \" << j << \", \" << c << endl;\n\t  \tf[i][j] = min(f[i][j], f[i - 1][j] + (c != i) * b);\n\t  } \n\t  if (j) {\n\t  \tint X = c3[pos[n - j + 1]]; //ÔÚËü×ó±ß±ÈËü´óµÄÊýµÄ¸öÊý\n\t  \tint Y = c4[pos[n - j + 1]][i]; //ÔÚËüÓÒ±ßÐ¡ÓÚµÈÓÚiµÄÊýµÄ¸öÊý \n\t  \tint c = pos[n - j + 1] - X + Y;\n\t  \t//cerr << \"sec : \" << i << \", \" << j << \", \" << c << endl;\n\t  \tf[i][j] = min(f[i][j], f[i][j - 1] + (c != n - j + 1) * a);\n\t  }\n\t}\n  }\n  for (int i = 0; i <= n; ++i) {\n  \tans = min(ans, f[i][n - i]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream &s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream &s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream &s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\nsigned main() {\n  int n, a, b; cin >> n >> a >> b;\n  vector<int> p(n + 2); REP (i, n) cin >> p[i + 1];\n  p[n + 1] = n + 1;\n  vector<int> dp(n + 2, 1e18);\n  dp[0] = 0;\n  REP (i, n + 2) {\n    int acc = 0;\n    for (int j = i - 1; j >= 0; j--) {\n      if (p[j] > p[i]) {\n        acc += a;\n      } else {\n        chmin(dp[p[i]], dp[p[j]] + acc);\n        acc += b;\n      }\n    }\n  }\n  cout << dp.back() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 5010;\nconst long long oo = 1e18;\nint n, p[maxn], m;\nlong long A, B;\nlong long dp[maxn][maxn << 1], mx[maxn][maxn << 1];\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\tp[a] = i * 2;\n\t}\n\tm = n * 2 + 1;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tmx[i][0] = oo;\n\t\tfor(int j = 1; j <= m; j ++)\n\t\t{\n\t\t\tlong long a;\n\t\t\tif(j % 2 == 0)\n\t\t\t\ta = mx[i - 1][j - 1];\n\t\t\telse\n\t\t\t\ta = mx[i - 1][j];\n\t\t\tif(j > p[i])\n\t\t\t\ta += A;\n\t\t\telse if(j < p[i])\n\t\t\t\ta += B;\n\t\t\tdp[i][j] = a;\n\t\t\tmx[i][j] = min(mx[i][j - 1], dp[i][j]);\n\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t}\n\t}\n\tcout << mx[n][m] << endl;\n\treturn 0;\n}\n/*\n5 1 9\n3 5 1 4 2 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5005;\nlong long s[N],p[N],f[N];\nint n,A,B;\nint main(){\n    freopen(\"1.out\",\"w\",stdout);\n    freopen(\"1.in\",\"r\",stdin);\n    memset(f,23,sizeof(f));\n    scanf(\"%d%d%d\",&n,&A,&B),f[0]=0;\n    for(int i=1,x;i<=n;i++){\n        scanf(\"%d\",&x);\n        for(int j=0;j<=n;j++)\n            if(j)   p[j]=min(p[j-1],f[j]);\n            else    p[j]=f[j];\n        for(int j=0;j<=x;j++)   f[j]+=A;\n        for(int j=x+1;j<=n;j++) f[j]+=B;\n        f[x]=min(f[x],p[x]);\n    }\n    long long ans=f[n+1];\n    for(int i=0;i<=n;i++)   ans=min(ans,f[i]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define ph push\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long) 1e18)//1234567890987654321\n#define INF 1234567890ll\n// #define cerr if(0)cout\n#define MAXN (5006)\nll n, a, b, A[MAXN], dp[2][MAXN], pos[MAXN], co[MAXN]; // dp(i, j) = dp(val i, at pos j -> 0 all the elements are in order);\nint main()\n{ // can be proven that each element moves once\n\tFAST\n\tcin>>n>>a>>b;\n\tFOR(i,1,n)cin>>A[i],pos[A[i]]=i;\n\tFOR(i,1,n) {\n\t\tmmst(dp[i%2],0);\n\t\tll x=pos[i];\n\t\tFOR(j,1,x-1) dp[i%2][j]=dp[i%2^1][j]; // storing history values (won't be changed), but might be referenced in the future\n\t\tFOR(j,x,n){ // legit ones\n\t\t\tdp[i%2][j]=min((j==x?LLINF:dp[i%2^1][j]+a), dp[i%2^1][x-1] + b * (co[j] - co[x])); // move all blocking elements to correct position, u'll end up at position i (cos i-p-1 items just got moved)\n\t\t}\n\t\tFOR(i,x,n) ++ co[i];\n\t\t// FOR(j,1,n)cerr<<dp[i%2][j]<<' '; cerr<<'\\n';\n\t}\n\tcout<<dp[n%2][n]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nint N, p[5050], A, B;\nll dp[5050][5050];\n\nvoid upd(ll &a, ll b) { if(a > b) a = b; }\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\", p+i);\n\trep(i, 5050) rep(j, 5050) dp[i][j] = 1e18;\n\tdp[0][0] = 0;\n\tfor(int i=0;i<N;i++) for(int j=0;j<=N;j++) {\n\t\tint x = p[i+1];\n\t\tif(j < x) upd(dp[i+1][j], dp[i][j] + A);\n\t\telse upd(dp[i+1][j], dp[i][j] + B);\n\t\tif(j < x) {\n\t\t\tupd(dp[i+1][x], dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", *min_element(dp[N], dp[N] + N+1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long A[10000];\nlong long a,b;\nlong long solve(vector<long long> &v)\n{\n  long long int now,ret = 10000000000000000,best;\n  if((int)v.size() <= 1) return 0;\n  vector<long long> l,r;\n  for(int i = 0;i < v.size();i++)\n  {\n    now = 0;\n    for(int j = 0;j < i;j++)\n    {\n      if(v[j] > v[i])\n        now += a;\n\n    }\n    for(int j = i+1;j < v.size();j++)\n    {\n      if(v[j] < v[i])\n      {\n        now+=b;\n      }\n    }\n    if(now < ret)\n    {\n      ret = now;\n      best = i;\n    }\n  }\n  for(int j = 0;j < best;j++)\n  {\n    if(v[j] <v[best])\n      l.push_back(v[j]);\n  }\n  for(int j = best + 1;j < v.size();j++)\n  {\n    if(v[j] >v[best])\n      r.push_back(v[j]);\n  }\n  return ret + solve(l) + solve(r);\n}\nint main()\n{\n  long long N,i,j,k,ans = 10000000000000,now;\n  vector<long long> pp;\n  cin >> N >> a >> b;\n  for(i = 0;i <N;i++)\n  {\n    cin >> A[i];\n    pp.push_back(A[i]);\n  }\n  cout << solve(pp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint a;\nlong long int b,c;\nint x[5010];\nstd::pair<int,int> start[5010][5010];\nlong long int check[5010][5010];\nlong long int func(int s, int t)\n{\n\tif(s==t) return 0;\n\tif(check[s][t]!=-1) return check[s][t];\n\t\n\tif(start[s][t].first==0)\n\t{\n\t\tif(start[s][t+1].first!=0) start[s][t].first = start[s][t+1].first;\n\t\telse\n\t\t{\n\t\t\tfor(int i=start[s-1][t].first;i<=a;i++)\n\t\t\t{\n\t\t\t\tif(x[i]<s) continue;\n\t\t\t\tif(x[i]>t) continue;\n\t\t\t\tstart[s][t].first = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(start[s][t].second==0)\n\t{\n\t\tif(start[s-1][t].second!=0) start[s][t].second = start[s-1][t].second;\n\t\telse\n\t\t{\n\t\t\tfor(int i=start[s][t+1].second;i>=1;i--)\n\t\t\t{\n\t\t\t\tif(x[i]<s) continue;\n\t\t\t\tif(x[i]>t) continue;\n\t\t\t\tstart[s][t].second = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(x[start[s][t].first]==s) return func(s+1,t);\n\tif(x[start[s][t].second]==t) return func(s,t-1);\n\tlong long int s1 = func(s+1,t)+c;\n\tlong long int s2 = func(s,t-1)+b;\n\treturn s1<s2?s1:s2;\n}\nint main()\n{\n\tscanf(\"%d%lld%lld\",&a,&b,&c);\n\tstart[1][a].first = 1;\n\tstart[1][a].second = a;\n\tfor(int i=1;i<=a;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=a;i++) for(int j=1;j<=a;j++) check[i][j] = -1;\n\tprintf(\"%lld\",func(1,a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint a[5010], b[5010], c[5010];\nll mem[5010][5010], rt, lf, n;\nll d[5010][5010], s[5010][5010];\nll dp(int  x, int y){\n    if(x+1==y){\n        return 0;\n    }\n    if(mem[x][y]!=-1)\n        return  mem[x][y];\n    ll res;\n    int tmp=x+1;\n    if(b[tmp]>=y){\n        res=dp(x+1, y);\n    }\n    else{\n        res=rt+dp(x+1, y);\n        res=min(res, (d[tmp][tmp+1]-d[tmp][y])*lf+dp(x+1, y));\n    }\n    tmp=y-1;\n    if(c[tmp]<=x){\n        res=min(res, dp(x, y-1));\n    }\n    else{\n        res=min(res, lf+dp(x, y-1));\n        res=min(res, (s[tmp][tmp-1]-s[tmp][x])*rt+dp(x, y-1));\n    }\n    mem[x][y]=res;\n    return res;\n}\nint pos[5010];\nvoid pre(){\n    for(int i=0; i<n; ++i){\n        for(int j=n; j>a[i]; --j){\n            d[a[i]][j]=d[a[i]][j+1]+(pos[j]<i);\n//            cout<<a[i]<<\" \"<<j<<\" \"<<d[a[i]][j]<<endl;\n        }\n    }\n    for(int i=0; i<n; ++i){\n        for(int j=1; j<a[i]; ++j){\n            s[a[i]][j]=s[a[i]][j-1]+(pos[j]>i);\n//            cout<<a[i]<<\" \"<<j<<\" \"<<s[a[i]][j]<<endl;\n        }\n    }\n\n}\nint main(){\n    while(cin>>n>>lf>>rt){\n        ll ans=0;\n        int tmp;\n        for(int i=0; i<n; ++i){\n            scanf(\"%d\",a+i);\n            pos[a[i]]=i;\n            tmp=n+1;\n            for(int j=0; j<i; ++j){\n                  if(a[j]>a[i])\n                        tmp=min(tmp, a[j]);\n            }\n            b[a[i]]=tmp;\n        }\n        for(int i=0; i<n; ++i){\n            tmp=0;\n            for(int j=n-1; j>i; --j){\n                if(a[j]<a[i]){\n                    tmp=max(tmp, a[j]);\n                }\n            }\n            c[a[i]]=tmp;\n        }\n        pre();\n        memset(mem, -1, sizeof mem);\n        ans=dp(0,n+1);\n        cout<<ans<<endl;\n    }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst size_t SIZE = 5010;\nconst ll inf = 5e15;\nll dp[SIZE][SIZE];\n\ntemplate <typename T>\nstruct Bit {\n    V<T> data;\n    T id_ele;\n\n    Bit(ll size, T id_ele) : id_ele(id_ele) {\n        ll bsize = 1;\n        while(bsize < size) bsize *= 2;\n        data = V<T>(bsize + 1, id_ele);\n    }\n\n    T sum(ll pos) {\n        T ret = id_ele;\n        for(; 0 < pos; pos -= pos & -pos) ret += data[pos];\n        return ret;\n    }\n\n    T sum(ll l, ll r) { return sum(r) - sum(l); }\n\n    void add(ll pos, T delta) {\n        for(++pos; pos < data.size(); pos += pos & -pos) data[pos] += delta;\n    }\n};\n\nint main() {\n    ll N, A, B;\n    cin >> N >> A >> B;\n    V<ll> P(N), idx_v(N);\n    for (ll i = 0; i < N; i++) {\n        ll e;\n        cin >> e;\n        e--;\n        P[i] = e;\n        idx_v[e] = i;\n    }\n\n    Bit<ll> bt(N, 0);\n    for (ll i = 0; i < N; i++) bt.add(i, 1);\n\n    for (ll i = 0; i < SIZE; i++) fill(dp[i], dp[i] + SIZE, inf);\n    dp[0][0] = 0;\n    for (ll i = 0; i < N; i++) {\n        ll idx = idx_v[i];\n        for (ll j = 0; j <= N; j++) {\n            if (idx <= j) {\n                chmin(dp[i + 1][j], dp[i][j]);\n                continue;\n            }\n            ll left = bt.sum(j, idx);\n            chmin(dp[i + 1][idx + 1], dp[i][j] + left * A);\n            if (left == 0) chmin(dp[i + 1][j], dp[i][j]);\n            else chmin(dp[i + 1][j], dp[i][j] + B);\n        }\n        bt.add(idx, -1);\n    }\n    cout << *min_element(dp[N], dp[N] + SIZE) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=5005;\nconst long long INF=1e18;\nint n,a,b,x; long long f[N][N],ans=INF;\nint main()\n{\n\tRI i,j; for (scanf(\"%d%d%d\",&n,&a,&b),i=1;i<=n;++i)\n\tfor (j=1;j<=n;++j) f[i][j]=INF; for (i=1;i<=n;++i)\n\tfor (scanf(\"%d\",&x),j=1;j<=n;++j)\n\tif (x<j) f[i][j]=min(f[i][j],f[i-1][j]+b); else\n\tf[i][x]=min(f[i][x],f[i-1][j]),f[i][j]=min(f[i][j],f[i-1][j]+a);\n\tfor (i=1;i<=n;++i) ans=min(ans,f[n][i]);\n\treturn printf(\"%lld\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <array>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\n#define FOR(i, a, b) for(decltype(b) i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\n\nusing namespace std;\n\n#ifdef INPUT\n#include <sstream>\nstringstream input(R\"(\n9 40 50\n5 3 4 7 6 1 2 9 8\n)\");\n#define cin input\n#endif\n\nint main()\n{\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\n\tvector<int> p(n);\n\tfor (auto& i : p)\n\t\tcin >> i;\n\n\tauto eval = [&](int v, bool s)\n\t{\n\t\tll r = 0;\n\t\tint x = 1;\n\t\t//cout << '_';\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (x == v + 1)\n\t\t\t\tbreak;\n\t\t\tif (p[i] > v)\n\t\t\t{\n\t\t\t\tif (!s)\n\t\t\t\t{\n\t\t\t\t\tr += (v - x + 1) * b;\n\t\t\t\t\t//cout << \"++\" << (v - x + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[i] > x)\n\t\t\t{\n\t\t\t\tr += (p[i] - x) * b;\n\t\t\t\t//cout << '+' << (p[i] - x);\n\t\t\t}\n\t\t\tif (x <= p[i])\n\t\t\t\tx = p[i] + 1;\n\t\t}\n\t\tx = n;\n\t\tfor (int i = n - 1; i >= 0; --i)\n\t\t{\n\t\t\tif (x == v)\n\t\t\t\tbreak;\n\t\t\tif (p[i] <= v)\n\t\t\t{\n\t\t\t\tif (s)\n\t\t\t\t{\n\t\t\t\t\tr += (x - v) * a;\n\t\t\t\t\t//cout << \"--\" << (x - v);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[i] < x)\n\t\t\t{\n\t\t\t\tr += (x - p[i]) * a;\n\t\t\t\t//cout << '-' << (x - p[i]);\n\t\t\t}\n\t\t\tif (x >= p[i])\n\t\t\t\tx = p[i] - 1;\n\t\t}\n\t\t//cout << '>' << v << s << ' ' << r << endl;\n\t\treturn r;\n\t};\n\n\tll r = n * (a + b);\t\n\tREP (i, n + 1)\n\t\tr = min(r, min(eval(i, true), eval(i, false)));\n\n\tcout << r << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n#define LL long long\n\nint n;\nLL a,b;\nint p[5000],inv[5000];\nLL dp[5001][10001],mindp[5001][10002];\n\nint main(){\n  cin>>n>>a>>b;\n  REP(i,n){cin>>p[i];p[i]--;}\n  REP(i,n)inv[p[i]]=i;\n  REP(i,n+1)mindp[i][0]=0LL;\n  REP(i,2*n+1){dp[0][i]=0LL;mindp[0][i+1]=0LL;}\n  \n  FOR(i,1,n+1){\n    REP(j,2*n+1){\n      //cerr<<i<<\" \"<<j<<\" \"<<2*inv[i-1]+1<<\" \"<<mindp[i-1][j]<<endl;\n      if(2*inv[i-1]+1==j)\n\tdp[i][j]=mindp[i-1][j];\n      else if(2*inv[i-1]+1 < j)\n\tdp[i][j]=mindp[i-1][j]+a;\n      else\n\tdp[i][j]=mindp[i-1][j]+b;\n    }\n\n    mindp[i][0]=dp[i][0];\n    REP(j,2*n+1){\n      if(j%2!=0)\n\tmindp[i][j+1] = min(dp[i][j],min(dp[i][j+1],mindp[i][j]));\n      else\n\tmindp[i][j+1] = mindp[i][j];\n    }\n  }\n\n  /*\n  REP(i,n+1){\n    REP(j,2*n+1)\n      cerr<<dp[i][j]<<\" \";\n    cerr<<endl;\n  }\n\n  REP(i,n+1){\n    REP(j,2*n+2)\n      cerr<<mindp[i][j]<<\" \";\n    cerr<<endl;\n  }\n  */\n  \n  \n  cout<<*min_element(dp[n],dp[n]+2*n+1)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N; long long A, B;\n\nint p[5005];\nint rev[5005];\n\n// Second indx:\n/*\n1: (-inf, 1]\n2: (1, 2]\n3: (2, 3]\n4: (3, 4] and so on.\nN+1: (N, N+1]\n*/\n//long long memo[5005][5005];\nlong long dp[5005][5005];\n\n// Sort from 1 to i inclusive\n// The element i+1 is in k\n/*long long dp(int i, int k){\n    if(i == 0){\n        return 0;\n    }else if(memo[i][k] != -1){\n        return memo[i][k];\n    }else{\n        // shift left\n        long long ans = 1LL << 61;\n\n        for(int j = 1; j <= k; j ++){\n            if(j < rev[i]){\n                ans = min(ans, B + dp(i-1, j));\n            }else if(j == rev[i]){\n                ans = min(ans, B*(j==k) + dp(i-1, j));\n            }else{\n                ans = min(ans, A + dp(i-1, j));\n            }\n        }\n\n        //printf(\"dp(%d, %d)=%lld\\n\", i, k, ans);\n        return memo[i][k] = ans;\n    }\n}*/\n\nint main(){\n    scanf(\"%d%lld%lld\", &N, &A, &B);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &p[i]);\n        rev[p[i]] = i;\n    }\n\n    for(int j = 1; j <= N+1; j ++){\n        dp[0][j] = 0;\n    }\n\n    for(int i = 1; i <= N; i ++){\n        long long ans = 1LL << 61;\n        for(int j = 1; j <= N+1; j ++){\n\n            if(j < rev[i]){\n                ans = min(ans, B + dp[i-1][j]);\n            }else if(j == rev[i]){\n                ans = min(ans, dp[i-1][j]);\n            }else{\n                ans = min(ans, A + dp[i-1][j]);\n            }\n\n            dp[i][j] = ans;\n            if(j == rev[i]){\n                dp[i][j] = min(ans, dp[i-1][j]);\n            }\n        }\n    }\n\n    printf(\"%lld\", dp[N][N+1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ts cout<<\"ok\"<<endl\n#define int long long\n#define hh puts(\"\")\n#define pc putchar\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\n//char buf[1<<21],*p1=buf,*p2=buf;\nusing namespace std;\nconst int N=5005;\nint n,A,B,a[N],pos[N],dp[N][N],s[N][N];\ninline int read(){\n    int ret=0,ff=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}\n    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}\n    return ret*ff;\n}\nvoid write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}\nvoid writeln(int x){write(x),hh;}\nvoid writesp(int x){write(x),pc(' ');}\nsigned main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=1;i<=n;i++) a[i]=read(),pos[a[i]]=i;\n\tmemset(dp,0x3f,sizeof(dp));\n\tmemset(s,0x3f,sizeof(s));\n\tfor(int i=1;i<=n;i++) s[0][i]=dp[0][i]=0;\n\tfor(int i=1;i<=n;i++){//从小到大放 \n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(pos[i]==j) dp[i][j]=min(dp[i][j],s[i-1][j-1]);\n\t\t\tdp[i][j]=min(dp[i][j],s[i-1][j]+(j<pos[i]?B:A));\n\t\t}\n\t\ts[i][0]=dp[i][0];\n\t\tfor(int j=1;j<=n;j++) s[i][j]=min(s[i][j-1],dp[i][j]);\n\t}\n\twrite(s[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair<int, int>\n#define PLL pair<LL, LL>\n#define VI vector<int>\n#define VPII vector<PII>\n#define LL long long\n#define LD long double\n#define f first\n#define s second\n#define MP make_pair\n#define PB push_back\n#define pb pop_back\n#define ALL(c) (c).begin(), (c).end()\n#define SIZ(c) (int)(c).size()\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, b, e) for(int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for(int i = (b); i >= (int)(e); --i)\n\n#define Sim template<class n\nSim, class s> ostream & operator << (ostream &p, pair<n, s> x)\n{return p << \"<\" << x.f << \", \" << x.s << \">\";}\nSim> auto operator << (ostream &p, n y) -> \ntypename enable_if<!is_same<n, string>::value, decltype(y.begin(), p)>::type \n{int o = 0; p << \"{\"; for(auto c: y) {if(o++) p << \", \"; p << c;} return p << \"}\";}\nvoid dor() {cerr << endl;}\nSim, class...s> void dor(n p, s...y) {cerr << p << \" \"; dor(y...);}\nSim, class s> void mini(n &p, s y) {if(p>y) p = y;}\nSim, class s> void maxi(n &p, s y) {if(p<y) p = y;}\n#ifdef DEB\n#define debug(...) dor(__FUNCTION__, \":\", __LINE__, \": \", __VA_ARGS__)\n#else\n#define debug(...)\n#endif \n\n#define I(x) #x \" = \", (x), \" \"\n#define A(a, i) #a \"[\" #i \" = \", i, \"] = \", a[i], \" \"\nconst int M = 1024 * 8;\n\nconst LL inf = 1e18;\nint n, a, b, T[M];\nLL dp[M], D[2 * M];\n\nvoid add(int v, int w)\n{\n  v += M;\n  D[v] += w;\n  while (v > 1)\n  {\n    v /= 2;\n    D[v] = D[2 * v] + D[2 * v + 1];\n  }\n}\n\nint sum(int p, int k)\n{\n  p += M;\n  k += M;\n  int res = D[p];\n  if (p != k)\n  {\n    res += D[k];\n  }\n  while (p / 2 != k / 2)\n  {\n    if (p % 2 == 0)\n    {\n      res += D[p + 1];\n    }\n    if (k % 2 == 1)\n    {\n      res += D[k - 1];\n    }\n    p /= 2;\n    k /= 2;\n  }\n  return res;\n}\n\nint main()\n{\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(NULL);\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tFOR(i, 1, n)\n\t{\n\t\tscanf(\"%d\", T + i);\n\t}\n\t\n\tdp[1] = 0;\n\tT[n + 1] = n + 1;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tdp[i] = inf;\n\t\tLL tmp = 0;\n\t\tint ile = 0;\n\t\tFORD(j, i - 1, 0)\n\t\t{\n\t\t\tif (T[j] < T[i])\n\t\t\t{\n\t\t\t\tint mn = sum(0, T[j]);\n\t\t\t\tmini(dp[i], dp[j] + tmp + (LL)mn * b + (LL)min(a, b) * (ile - mn));\n\t\t\t\tdebug(i, j, dp[i], dp[j], tmp, mn, b, min(a, b), (ile - mn));\n\t\t\t}\n\t\t\tadd(T[j], 1);\n\t\t\tif (T[j] > T[i])\n\t\t\t{\n\t\t\t\ttmp += a;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tile++;\n\t\t\t}\n\t\t}\n\t\tFOR(j, 0, i - 1)\n\t\t{\n\t\t\tadd(T[j], -1);\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[n + 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996)\n \ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\n#define MOD 1000000007\nusing namespace std;\n\n\nint main(int argc, char* argv[])\n{\n    long n;\n    ll a, b;\n    scanf(\"%ld%lld%lld\", &n, &a, &b);\n\n    vector<long> p(n+2);\n    long i;\n    p[0]=0;\n    for(i=0; i<n; i++) {\n        scanf(\"%ld\", &p[i+1]);\n    }\n    p[n+1]=n+1;\n\n    vector<ll> dp(n+2, LINF);\n    long j;\n    dp[0]=0;\n    for(i=1; i<=n+1; i++) {\n        ll cst = 0;\n        for(j=i-1; j>=0; j--) {\n            if(p[j] < p[i]) {\n                dp[i] = MIN(dp[i], dp[j] + cst);\n                cst += b;\n            }\n            else {\n                cst += a;\n            }\n        }\n    }    \n\n    printf(\"%lld\\n\", dp[n+1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nint n,v[5005];\nll a,b,f[5005];\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&a,&b);\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tf[i]=1000000000000000000;\n\t\tif(i<=n)scanf(\"%d\",&v[i]);\n\t\telse v[i]=n+1;\n\t\tll sum=0;\n\t\tint maxx=0;\n\t\tfor(int j=i-1;j>=1;j--)\n\t\t{\n\t\t\tif(v[j]>v[i])sum+=a;\n\t\t\telse if(v[j]>maxx)\n\t\t\t{\n\t\t\t\tf[i]=min(f[i],f[j]+sum);\n\t\t\t\tsum+=b;\n\t\t\t}\n\t\t\telse sum+=b;\n\t\t}\n\t\tf[i]=min(f[i],sum);\n\t}\n\tprintf(\"%lld\\n\",f[n+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1LL<<60\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a,b;\nint p[5005];\nll dp[5005][5005];\nbool chl[5005][5005];\nbool chr[5005][5005];\nint cntr[5005];\nint cntl[5005];\nbool used[5005];\n\nint main(void){\n    scanf(\"%d%lld%lld\",&n,&a,&b);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&p[i]);\n        p[i]--;\n    }\n    memset(used,false,sizeof(used));\n    for(int i=0;i<n;i++){\n        used[p[i]]=true;\n        for(int j=0;j<p[i];j++){\n            if(!used[j]){\n                cntl[j]++;\n                chl[j][p[i]]=true;\n            }\n        }\n    }\n    memset(used,false,sizeof(used));\n    for(int i=n-1;i>=0;i--){\n        used[p[i]]=true;\n        for(int j=p[i];j<n;j++){\n            if(!used[j]){\n                cntr[j]++;\n                chr[j][p[i]]=true;\n            }\n        }\n    }\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            dp[i][j]=INF;\n        }\n    }\n    dp[0][n]=0;\n    for(int i=0;i<n;i++){\n        for(int j=n;j>i;j--){\n            int lv=i;\n            assert(cntl[lv]>=0);\n            if(cntl[lv]==0){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n            }else{\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+min(b,(ll)a*cntl[lv]));\n            }\n            if(chl[lv][j-1]){\n                cntl[lv]--;\n            }\n            int rv=j-1;\n            assert(cntr[rv]>=0);\n            if(cntr[rv]==0){\n                dp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n            }else{\n                dp[i][j-1]=min(dp[i][j-1],dp[i][j]+min(a,(ll)b*cntr[rv]));\n            }\n            //printf(\"%d %d %d %d %lld\\n\",i,j,cntl[lv],cntr[rv],dp[i][j]);\n\n        }\n        for(int j=0;j<n;j++){\n            if(chr[j][i]){\n                cntr[j]--;\n            }\n        }\n    }\n    ll ans=INF;\n    for(int i=0;i<=n;i++){\n        ans=min(ans,dp[i][i]);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#define N 5001\n#include<bitset>\n#include<deque>\n#include<cstdlib>\n#include<set>\n#include<ctime>\n#define ll long long\n#define mp make_pair\nusing namespace std;\nll read()\n{\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile(c>'9'||c<'0')\n\t{\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\nint n,pos[N],A,B;\nll dp[N][N];\nint main()\n{\n\tn=read(),A=read(),B=read();\n\tmemset(dp,20,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=read();\n\t\tpos[x]=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tll mn=dp[i-1][0];\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(pos[i]==j) dp[i][j]=dp[i-1][j-1];\n\t\t\tmn=min(mn,dp[i-1][j]);\n\t\t\tdp[i][j]=min(dp[i][j],mn+(j<pos[i]?B:A));\n\t\t}\n\t}\n\tll ans=1e18;\n\tfor(int i=1;i<=n;++i) ans=min(ans,dp[n][i]);\n\tcout<<ans<<'\\n';\n\treturn 0;\n }\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\ninline char gc() {\n\tstatic const LL L = 233333;\n\tstatic char sxd[L], *sss = sxd, *ttt = sxd;\n\tif (sss == ttt) {\n\t\tttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n\t\tif (sss == ttt) {\n\t\t\treturn EOF;\n\t\t}\n\t}\n\treturn *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n\tchar dd;\n\tfor (; !isalpha(c); dd);\n\treturn c;\n}\n\ninline char readchar() {\n\tchar dd;\n\tfor (; c == ' '; dd);\n\treturn c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n\tbool flg = false;\n\tchar dd;\n\tx = 0;\n\tfor (; !isdigit(c); dd) {\n\t\tif (c == '-') {\n\t\t\tflg = true;\n\t\t} else if(c == EOF) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (; isdigit(c); dd) {\n\t\tx = (x << 1) + (x << 3) + (c ^ 48);\n\t}\n\tif (flg) {\n\t\tx = -x;\n\t}\n\treturn true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n\tif (x < 0) {\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tif (x < 10) {\n\t\tputchar(x | 48);\n\t\treturn;\n\t}\n\twrite(x / 10);\n\tputchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n\twrite(x);\n\tputchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\n\ntypedef long long LL;\n\nconst int maxn = 5005;\nconst LL inf = 0x3f3f3f3f3f3f3f3fLL;\n\nint n, A, B;\nint aa[maxn];\nLL f[maxn];\n\nint main() {\n\tread(n), read(A), read(B), ++n;\n\tfor (register int i = 1, j; i <= n; ++i) {\n\t\t(i == n) ? aa[i] = n : read(aa[i]);\n\t\tf[i] = inf;\n\t\tregister LL tmp = 0;\n\t\tfor (j = i - 1; ~j; --j) {\n\t\t\t(!j || aa[i] > aa[j]) ? ((f[i] > f[j] + tmp ? f[i] = f[j] + tmp : 0), tmp += B) : (tmp += A);\n\t\t}\n\t}\n\twrite(f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nconstexpr int MN = 5005;\n\nll p[MN], DP[MN][MN];\n\nint main() {\n    if (fopen(\"in\", \"r\")) freopen(\"in\", \"r\", stdin), freopen(\"out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n\tint N; cin >> N;\n\tll A, B; cin >> A >> B;\n\tfor (int i = 0; i < N; ++i) cin >> p[i];\n\n\tmemset(DP, '?', sizeof DP);\n\tDP[0][0] = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j <= N; ++j) {\n\t\t\tif (p[i] > j) DP[i+1][j] = min(DP[i][j]+A, DP[i+1][j]), DP[i+1][p[i]] = min(DP[i][j], DP[i+1][p[i]]);\n\t\t\telse DP[i+1][j] = min(DP[i][j]+B, DP[i+1][j]);\n\t\t}\n\t}\n\n\tll ans = 1e18;\n\tfor (int i = 1; i <= N; ++i) ans = min(DP[N][i], ans);\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 5010\n#define ll long long\nusing namespace std;\nint a[maxn], pre[maxn][maxn];\nll f[maxn];\nint main()\n{\n\tint n, A, B;\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (j >= a[i]) pre[i][j] = pre[i - 1][j] + 1;\n\t\t\telse pre[i][j] = pre[i - 1][j];\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tf[i] = 1e18;\n\t\tfor (int j = 0; j <= i - 1; j++)\n\t\t{\n\t\t\tif (a[j] >= a[i]) continue;\n\t\t\tint t1, t2;\n\t\t\tif (j == 0) t1 = 0;\n\t\t\telse t1 = pre[i - 1][a[j] - 1] - pre[j][a[j] - 1];\n\t\t\tt2 = (i - j - 1) - t1;\n\t\t\tf[i] = min(f[i], f[j] + (ll)t1 * B + (ll)t2 * A);\n\t\t}\n\t}\n\tll res = 1e18;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tint t1, t2;\n\t\tif (i == 0) t1 = 0;\n\t\telse t1 = pre[n][a[i] - 1] - pre[i][a[i] - 1];\n\t\tt2 = (n - i) - t1;\n\t\tres = min(res, f[i] + (ll)t1 * B + (ll)t2 * A);\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n#define int long long\nconst int N = 5555;\nint n, A, B, a[N], id[N], dp[N][N];\n\ninline void U(int &x, int y) {\n    x = min(x, y);\n}\n\nsigned main(void) {\n    read(n); read(A); read(B);\n    swap(A, B);\n    rep (i, n) read(a[i]), id[a[i]] = i;\n    memset(dp, 38, sizeof dp);\n    int tmp = dp[0][0];\n    dp[0][0] = 0;\n    for (int i = 1; i <= n; i++)\n        for (int pre = 0; pre <= n; pre++)\n            if (dp[i - 1][pre] != tmp) {\n                int np = id[i];\n                if (np > pre) {\n                    U(dp[i][np], dp[i - 1][pre]);\n                    U(dp[i][pre], dp[i - 1][pre] + A);\n                } else {\n                    U(dp[i][pre], dp[i - 1][pre] + B);\n                }\n            }\n    // rep (i, n) re0 (pre, n + 1) {\n    //     if (dp[i][pre] != tmp)\n    //         printf(\"dp[%lld][%lld] = %lld\\n\", i, pre, dp[i][pre]);\n    // }\n    int ans = 1e18;\n    for (int pre = 0; pre <= n; pre++)\n        U(ans, dp[n][pre]);\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n//#include<cstdlib>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<iterator>\n#include<deque>\n\nusing namespace std;\n#define PI          acos(-1)\n#define INF         0x3f3f3f3f\n#define sc(n)       scanf(\"%d\",&n);\n#define lsc(n)      scanf(\"%lld\",&n);\n#define dsc(n)      scanf(\"%lf\",&n);\n#define LL          long long int\n#define UI          unsigned int\n#define ULL         unsigned long long int\n#define DB          double\n#define pii         pair<int,int>\n#define PB          push_back\n#define MP          make_pair\n#define M(mx,a)     mx=max(mx,a)\n#define IT          ::iterator\n#define all(a)      a.begin(),a.end()\n#define mems(a,b)   memset(a,b,sizeof(a))\n#define ARC(n)      for(i=0;i<n;i++)\n#define ASC(n,aa)   for(i=0;i<n;i++)scanf(\"%lld\",&aa[i]);\n#define PNT(n,aa)   for(i=0;i<n;i++)printf(\"%lld \",aa[i]);\n#define mod         1000000007\n#define NUM         5009\n#define NUM2        1000000000\n\n\nint a[NUM],aa[NUM];\nLL neww[NUM][NUM],nxt[NUM][NUM];\n\n\nint main()\n{\n    int T=1,QQ=0;\n    //cin >> T ;\n    while(T--)\n    {\n        int n,i,j ;\n        LL aaa,bbb,k ;\n        cin >> n >> aaa >> bbb ;\n        for(i=1; i<=n; i++)\n        {\n            sc(a[i]);\n            aa[a[i]]=i;\n        }\n        for(i=0; i<=n; i++)\n        {\n            for(int j=0; j<=n; j++)\n            {\n                neww[i][j]=nxt[i][j]=INF;\n            }\n        }\n        for(i=0; i<=n; i++)\n            nxt[0][i]=neww[0][i]=0ll;\n        for(i=1; i<=n; i++)\n        {\n            for(j=0; j<=n; j++)\n            {\n                if(j==aa[i])\n                {\n                    neww[i][j]=min(neww[i][j],nxt[i-1][j-1]);\n                }\n                if(j<aa[i])\n                    k=nxt[i-1][j]+bbb;\n                else\n                    k=nxt[i-1][j]+aaa;\n                neww[i][j]=min(neww[i][j],k);\n            }\n            nxt[i][0]=neww[i][0];\n            for(j=1; j<=n; j++)\n                nxt[i][j]=min(nxt[i][j-1],neww[i][j]);\n        }\n        cout << nxt[n][n] ;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n#include <memory.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\n#define N 5002\nint p[N];\n\nint relPosLeft[N][N];\nint relPosRight[N][N];\nvoid init(int n) {\n  for(int i=1;i<=n;++i) {\n    for(int j = i+1;j<=n;++j) {\n      relPosRight[i][j] = relPosRight[i][j-1] + (p[j]<p[i]);\n    }\n  }\n  for(int i=1;i<=n;++i) {\n    for(int j = i-1;j>=1;--j) {\n      relPosLeft[j][i] = relPosLeft[j+1][i] + (p[j]<p[i]);\n    }\n  }\n}\nint getIndex(int l,int r,int findex,int n) {\n  if(l==findex) {\n    return l + relPosRight[l][r];\n  } else {\n    return l + relPosLeft[l][r];\n  }\n}\nlong long dp[N][N];\nlong long leftMoveCost,rightMoveCost;\nlong long solveDp(int l,int r,int n) {\n  if(l==r) {\n    return 0LL;\n  }\n  long long &ret = dp[l][r];\n  if(ret!=-1) {\n    return ret;\n  }\n  ret = 1e18;\n  //l first\n  int lindex = getIndex(l,r,l,n);\n  int add = 0;\n  if(lindex!=l) {\n    add = min(leftMoveCost, rightMoveCost*(r-l));\n  }\n  ret = min(ret, add + solveDp(l+1,r,n));\n  //r first\n  int rindex = getIndex(l,r,r,n);\n  add = 0;\n  if(rindex!=r) {\n    add = min(rightMoveCost, leftMoveCost*(r-l));\n  }\n  ret = min(ret, add + solveDp(l,r-1,n));\n  return ret;\n}\nvoid solve() {\n  int n;\n  long long A,B;\n  scanf(\"%d %lld %lld \", &n,&A,&B);\n  leftMoveCost = B;\n  rightMoveCost = A;\n  for(int i=1;i<=n;++i) {\n    int x;scanf(\"%d \", &x);\n    p[x] = i;\n  }\n  init(n);\n  memset(dp,-1,sizeof(dp));\n  printf(\"%lld\\n\", solveDp(1,n,n));\n}\n\nint main() {\n  //freopen(\"input.txt\",\"r\",stdin);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define itrep(i, a) for (auto i = (a).begin(); i != (a).end(); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n#define mp(a, b) make_pair((a), (b))\n\nusing namespace std;\n\ntemplate<class T> void inputVector(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\n\nint leftBig[5010], rightSmall[5010];\n\nint N, A, B;\nvector<int> p;\n\nvoid makeLeftBig() {\n    set<int> st;\n    rep(i, N) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.end()) leftBig[p[i]] = N + 1;\n        else leftBig[p[i]] = *it;\n        st.insert(p[i]);\n    }\n    //cerr << \"leftBig:\";\n    //REP(i, 1, N) cerr << \" \" << leftBig[i];\n    //cerr << endl;\n}\nvoid makeRightSmall() {\n    set<int> st;\n    st.insert(p[N - 1]);\n    rightSmall[p[N - 1]] = 0;\n    for (int i = N - 2; i >= 0; i--) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.begin()) rightSmall[p[i]] = 0;\n        else {\n            it--;\n            rightSmall[p[i]] = *it;\n        }\n        st.insert(p[i]);\n    }\n    //cerr << \"rightSmall:\";\n    //REP(i, 1, N) cerr << \" \" << rightSmall[i];\n    //cerr << endl;\n}\n\nstruct Info {\n    int left, right;\n    int dist;\n\n    Info(int left, int right, int dist) : left(left), right(right), dist(dist) {\n    }\n\n    bool operator< (const Info& a) const {\n        return dist > a.dist;\n    }\n};\n\nint memo[5010][5010];\n\nsigned main() {\n    cin >> N >> A >> B;\n\n    inputVector(p, N);\n\n    makeLeftBig();\n    makeRightSmall();\n\n    rep(i, N + 5) rep(j, N + 5) memo[i][j] = LLONG_MAX;\n\n    priority_queue<Info> q;\n    q.push(Info(0, N + 1, 0));\n    memo[0][N + 1] = 0;\n    while (!q.empty()) {\n        auto info = q.top(); q.pop();\n        if (info.dist > memo[info.left][info.right]) continue;\n        //cerr << \"Info: [left:\" << info.left << \" right:\" << info.right << \" dist:\" << info.dist << \"]\" << endl;\n        if (info.left + 1 == info.right) {\n            cout << info.dist << endl;\n            break;\n        }\n\n        {\n            int nextNum = info.left + 1;\n            int ndist = info.dist;\n            if (leftBig[nextNum] < info.right) {\n                ndist += B;\n            }\n            if (ndist < memo[info.left + 1][info.right]) {\n                memo[info.left + 1][info.right] = ndist;\n                q.push(Info(info.left + 1, info.right, ndist));\n            }\n        }\n        {\n            int nextNum = info.right - 1;\n            int ndist = info.dist;\n            if (rightSmall[nextNum] > info.left) {\n                ndist += A;\n            }\n            if (ndist < memo[info.left][info.right - 1]) {\n                memo[info.left][info.right - 1] = ndist;\n                q.push(Info(info.left, info.right - 1, ndist));\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=5e3+10;\nint D[N];\nint n,A,B;\nll sol(int idx)\n{\n\tif(idx>=n-1)return 0;\n\tint j=idx;\n\tfor(int i=idx+1;i<n;i++){\n\t\tif(D[i]<D[j])j=i;\n\t}\n\tll res=sol(j+1)+1LL*(j-idx)*A;\n\tint u=D[j];\n\tfor(int i=j;i>idx;i--)D[i]=D[i-1];\n\tres=min(res,sol(idx+1)+B);\n\tfor(int i=idx;i<j;i++)D[i]=D[i+1];\n\tD[j]=u;\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tll ans=0;\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&D[i]);\n\tcout<<sol(0)<<'\\n';\n\t/*\n\tfor(int i=0;i<n;i++){\n\t\tint j=0;\n\t\tfor(;j<i;j++)if(D[j]>D[i])break;\n\t\tif(j!=i)ans+=min(1LL*A*(i-j),1LL*B);\n\t\tint u=D[i];\n\t\tfor(int k=i;k>j;k--)D[k]=D[k-1];\n\t\tD[j]=u;\n\t}cout<<ans<<'\\n';*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll INF = 1e18;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    ll a, b;\n    cin >> n >> a >> b;\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n        p[i]--;\n    }\n\n    vector<ll> dp(n, 0);\n    for (int i = 0; i < n; i++) {\n        vector<ll> ndp(n, INF);\n        ndp[p[i]] = dp[p[i]];\n        for (int j = 0; j < n; j++) {\n            if (dp[j] == INF || j == p[i]) continue;\n            if (j < p[i]) ndp[p[i]] = min(ndp[p[i]], dp[j]);\n            ndp[j] = dp[j];\n            if (j > p[i]) ndp[j] += b;\n            else ndp[j] += a;\n        }\n        dp = ndp;\n    }\n\n    ll ans = INF;\n    for (int i = 0; i < n; i++) {\n        ans = min(ans, dp[i]);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nconst int limit = 5010;\nll dp[limit][limit];\nint p[limit];\n\nint main(void){\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\n\trep(i, n) cin >> p[i], p[i]--;\n\n\trep(i, n + 1)rep(j, n + 1) dp[i][j] = 1LL << 60;\n\tdp[0][0] = 0LL;\n\n\trep(i, n + 1)rep(j, n + 1){\n\t\tif(i + 1 <= n and j + 1 <= n and p[i] == j){\n\t\t\tchmin(dp[i + 1][j + 1], dp[i][j]);\n\t\t}\n\n\t\tif(i + 1 <= n){\n\t\t\tif(p[i] <= j){\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + b);\n\t\t\t} else {\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + a);\t\n\t\t\t}\n\t\t}\n\n\t\tif(j + 1 <= n){\n\t\t\tchmin(dp[i][j + 1], dp[i][j]);\n\t\t}\n\t}\n\n\tcout << dp[n][n] << endl;\n\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\nusing namespace std;\nconst ll MAX_N=5000,INF=1e18;\nll N,A,B,memo[MAX_N+1][MAX_N*2+1],q[MAX_N];\nll dfs(ll n,ll x){\n\tif(n==N){\n\t\treturn 0;\n\t}\n\tif(memo[n][x]!=-1){\n\t\treturn memo[n][x];\n\t}\n\tll ret=INF,x2;\n\tif(q[n]*2+1>x){\n\t\tx2=(x+1)/2*2;\n\t\tret=dfs(n+1,x2)+B;\n\t\tret=min(ret,dfs(n+1,q[n]*2+1));\n\t}\n\tret=min(ret,A+dfs(n+1,max(q[n]*2+2,(x+1)/2*2)));\n\treturn memo[n][x]=ret;\n}\n\t\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>N>>A>>B;\n\tREP(i,N){\n\t\tll p;\n\t\tcin>>p;\n\t\tp--;\n\t\tq[p]=i;\n\t}\n\tmemset(memo,-1,sizeof(memo));\n\tcout<<dfs(0,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct BIT{\nprivate:\n  vector<int> array;\n  int n;\npublic:\n  BIT(int _n):array(_n+1,0),n(_n){}\n\n  int sum(int i){\n    int s=0;\n    i++;\n    while(i>0){\n      s+=array[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  int add(int i){\n    i++;\n    while(i<=n){\n      array[i]++;\n      i+=i&-i;\n    }\n  }\n};\n\nint main(){\n  LL n,a,b;\n  cin >> n >> a >> b;\n  vector<int> p(n);\n  vector<int> pos(n);\n  for(int i=0;i<n;i++){\n    cin >> p[i];\n    p[i]--;\n    pos[p[i]]=i;\n  }\n  vector<vector<LL>> dp(n,vector<LL>(n,0));\n  BIT bit(n);\n  bit.add(pos[0]);\n  for(int i=1;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(pos[i]>j) dp[i][j]=dp[i-1][j];\n      else{\n        dp[i][j]=min((bit.sum(j)-bit.sum(pos[i])==0?0:a)+dp[i-1][j],b*(i-bit.sum(pos[i]))+(pos[i]>0?dp[i-1][pos[i]-1]:0));\n      }\n      // cout << dp[i][j] << \" \";\n    }\n    bit.add(pos[i]);\n    // cout << endl;\n  }\n  cout << dp[n-1][n-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<int> p(n + 2);\n    for (int i = 1; i <= n; ++i)\n        cin >> p[i];\n    p.back() = n + 1;\n    vector<LL> dp(n + 2, 1E18);\n    dp[0] = 0;\n    for (int i = 1; i <= n + 1; ++i) {\n        for (int j = i - 1, c = 0; j >= 0; --j) {\n            if (p[j] > p[i])\n                ++c;\n            else\n                dp[i] = min(dp[i], dp[j] + 1LL * c * a + 1LL * (i - j - 1 - c) * b);\n        }\n    }\n    cout << dp.back() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,mmx,avx,tune=native\")\n#include \"bits/stdc++.h\"\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\nconst int MOD=1000000007;\n#define endl \"\\n\"\n#define fst first\n#define snd second\nconst int UNDEF = -1;\nconst int INF=1<<30;\ntemplate<typename T> inline bool chkmax(T &aa, T bb) { return aa < bb ? aa = bb, true : false; }\ntemplate<typename T> inline bool chkmin(T &aa, T bb) { return aa > bb ? aa = bb, true : false; }\ntypedef pair<ll,ll> pll;typedef vector<ll> vll;typedef pair<int,int> pii;typedef vector<int> vi;typedef vector<vi> vvi;\n#ifdef ONLINE_JUDGE\n#define assert(...) /* nothing */\n#endif\n#define DEBUG_CAT\n#ifdef DEBUG_CAT\n#define dbg(...)   printf( __VA_ARGS__ )\n#else \n#define dbg(...)   /****nothing****/\n#endif\nconst int mn=5004;\nint a[mn];\nll dp[mn][mn];\nint Lcost, Rcost;\nll f(int l, int r) {\n\tif (l>=r) return 0;\n\tif (dp[l][r]!=-1) return dp[l][r];\n\tvector<pii> b;\n\tfor (int p=l;p<=r;p++) b.PB(MP(a[p],p-l));\n\tsort(b.begin(),b.end());\n\tll ans=LLONG_MAX;\n\tint n=b.size();\n\tvector<int> p2v(n);\n\tfor (int v=0;v<n;v++) {\n\t\tint p=b[v].snd;\n\t\tp2v[p]=v;\n\t}\n\tvector<int> rlo(n);\n\trlo[n-1]=INT_MAX;\n\tfor (int p=n-1;p>=1;p--) {\n\t\trlo[p-1]=min(p2v[p],rlo[p]);\n\t}\n\tint lhi=INT_MIN;\n\tfor (int p=0;p<n;p++) {\n\t\tint v=p2v[p];\n\t\tif (lhi<rlo[p]) {\n\t\t\t// Swap v from position=p to position=v.\n\t\t\tll base=f(l+0,l+p-1)+f(l+p+1,l+n-1); ll extra;\n\t\t\tif (p<v) extra=Lcost;\n\t\t\telse if (p>v) extra=Rcost;\n\t\t\telse extra=0;\n\t\t\tll cand=base+extra;\n\t\t\tchkmin(ans,cand);\n\t\t}\n\t\tchkmax(lhi,v);\n\t}\n\t//printf(\"l:%d r:%d ans:%lld split p:%lld\\n\",l,r,ans.fst, ans.snd);\n\treturn dp[l][r]=ans;\n}\nint main(){\t\n\tios::sync_with_stdio(false);\n\tmemset(dp,-1,sizeof dp);\n\tint n; cin>>n>>Lcost>>Rcost;\n\tfor (int p=0;p<n;p++) {\n\t\tcin>>a[p];\n\t\t--a[p];\n\t}\n\tll final=f(0,n-1);\n\tprintf(\"%lld\\n\",final);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define int long long\nusing std::min;\nint n,A,B,p[5010],dp[5010][5010],ans;\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&p[i]);\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;ans=0x3f3f3f3f;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(p[i]>j)dp[i][j]=min(dp[i][j],dp[i-1][j]+A),\n\t\t\t\tdp[i][p[i]]=min(dp[i][p[i]],dp[i-1][j]);\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n\tfor(int i=0;i<=n;i++)\n\t\tans=min(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\nconst int NC = 5e3 + 5;\nint N, A, B, p[NC];\nll dp[NC][NC];\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &p[i]);\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 0; j <= N; ++j)\n\t\t{\n\t\t\tif (p[i] > j)\n\t\t\t{\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j] + A);\n\t\t\t\tdp[i][p[i]] = min(dp[i][p[i]], dp[i-1][j]);\n\t\t\t}\n\t\t\telse dp[i][j] = min(dp[i][j], dp[i-1][j] + B);\n\t\t}\n\tll ans = 0x3f3f3f3f3f3f3f3f;\n\tfor (int i = 1; i <= N; ++i) ans = min(ans, dp[N][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 100000000000000000;\n\nll dp[5002][5002];\n\nint main()\n{\n    int n;\n    ll a, b;\n    cin >> n >> a >> b;\n    int p[5002], q[5002];\n    for(int i = 0; i < n; i++){\n        cin >> p[i];\n        p[i]--;\n        q[p[i]] = i;\n    }\n    int left[5002], right[5002];\n    fill(left, left + n, n);\n    fill(right, right + n, -1);\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < q[i]; j++){\n            if(p[j] > i) left[i] = min(left[i], p[j]);\n        }\n        for(int j = q[i] + 1; j < n; j++){\n            if(p[j] < i) right[i] = max(right[i], p[j]);\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++) dp[i][j] = INF;\n    }\n    dp[0][0] = 0;\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            if(i){\n                if(left[i - 1] >= n - j) dp[i][j] = min(dp[i][j], dp[i - 1][j]);\n                else dp[i][j] = min(dp[i][j], dp[i - 1][j] + b);\n            }\n            if(j){\n                if(right[n - j] < i) dp[i][j] = min(dp[i][j], dp[i][j - 1]);\n                else dp[i][j] = min(dp[i][j], dp[i][j - 1] + a);\n            }\n        }\n    }\n    cout << dp[n][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL>PL;\nconst LL INF=1e18;\nLL N,A,B,i,j;\nLL R[12345],dp[12345];\nLL pa[12345];\nLL mini;\nbool chk[12345];\nvector<LL>V[12345];\nLL cnt;\nLL D,ans;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>N>>A>>B;\n    for(i=0;i<N;i++)\n    {\n        cin>>R[i];\n        dp[i]=1;\n        pa[i]=-1;\n        for(j=0;j<i;j++)\n        {\n            if(dp[j]+1>=dp[i]&&R[i]>R[j])\n            {\n                dp[i]=dp[j]+1;\n                pa[i]=j;\n            }\n        }\n    }\n    for(i=N;i-->0;)\n    {\n        if(!chk[i])\n        {\n            j=i;\n            while(j!=-1)\n            {\n                V[cnt].push_back(j);\n                chk[j]=true;\n                j=pa[j];\n            }\n            cnt++;\n        }\n    }\n    ans=INF;\n    for(i=0;i<cnt;i++)\n    {\n        for(j=0;j<N;j++)\n            chk[j]=false;\n        for(j=0;j<V[i].size();j++)\n            chk[V[i][j]]=true;\n        mini=-1;\n        D=0;\n        for(j=0;j<N;j++)\n        {\n            if(chk[j])\n            {\n                mini=R[j];\n                continue;\n            }\n            if(mini>R[j])\n                D+=B;\n            else\n                D+=A;\n        }\n        ans=min(ans,D);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nconst int MAX_M = 1e5 + 5;\n\nstruct edge {\n    int u, v;\n    int other(int x) { return x ^ u ^ v; }\n};\n\nint n, m;\nedge ed[MAX_M];\nset<int> g[MAX_N];\n\nbool mk[MAX_N];\n\nbool remove1() {\n    int u;\n    for (u = 1; u <= n && g[u].empty(); u++);\n    if (u == n + 1) return 0;\n    \n    fill_n(mk, n + 1, 0);\n    vector<pair<int, int>> rec{{-1, u}};\n    while (1) {\n        if (mk[u]) {\n            //cout << \"re \" << u << endl;\n            break;\n        }\n        mk[u] = 1;\n        //cout << \"cyc \" << u << endl;\n        if (g[u].empty()) return 0;\n        int e = *g[u].begin();\n        int v = ed[e].other(u);\n        g[u].erase(e);\n        g[v].erase(e);\n        rec.push_back({e, v});\n        u = v;\n    }\n    for (auto &p : rec) {\n        int e, v; tie(e, v) = p;\n        if (e != -1) {\n            g[ed[e].u].insert(e);\n            g[ed[e].v].insert(e);\n        }\n        if (v == u) break;\n    }\n    return 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(nullptr);\n\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        cin >> ed[i].u >> ed[i].v;\n        g[ed[i].u].insert(i);\n        g[ed[i].v].insert(i);\n    }\n\n    int odd = 0;\n    for (int u = 1; u <= n; u++) odd += g[u].size() % 2;\n\n    if (odd) cout << \"No\\n\";\n    else {\n        bool ok = 0;\n        mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n        for (int iter = 0; iter < 20; iter++) {\n            shuffle(ed, ed + m, rng);\n            fill_n(g + 1, n, set<int>());\n            for (int i = 0; i < m; i++) {\n                g[ed[i].u].insert(i);\n                g[ed[i].v].insert(i);\n            }\n            if (!remove1());\n            else if (!remove1());\n            else if (!remove1());\n            else ok = 1;\n            if (ok) break;\n        }\n        cout << (ok ? \"Yes\\n\" : \"No\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n#include <iterator>\n#include <cmath>\n#include <stack>\n#include <random>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  ll n, a, b; cin >> n >> a >> b;\n  vector<int> p(n);\n  rep(i, n) {\n    int pos; cin >> pos;\n    pos--;\n    p[pos] = 2*i+1;\n  }\n\n  int k = 2*n+1;\n  vector<ll> dp(k);\n\n  rep(i, n) {\n    ll mi = LLONG_MAX;\n    rep(j, k) {\n      chmin(mi, dp[j]);\n      if (p[i] < j) {\n        dp[j] = mi+b;\n      } else if (p[i] == j) {\n        dp[j] = mi;\n      } else {\n        dp[j] = mi+a;\n      }\n    }\n  }\n\n  ll ans = LLONG_MAX;\n  rep(i, k) {\n    chmin(ans, dp[i]);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"UnionFind.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"FlowSolver.h\"\n#include \"Tree.h\"\n#include \"SuffixArray.h\"\n#include \"Matrix.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#include \"Math.h\"\n#include \"LazySegmentTree.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nLL N, X, Y;\nvector<int> A;\nint P[5002][5002];\nint Q[5003][5003];\nint R[5003][5003];\n\nvoid pre() {\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N) {\n\t\t\tQ[i][j + 1] = Q[i][j] + P[i][j];\n\t\t}\n\t}\n\n\tREP(j, 0, N + 1) {\n\t\tREP(i, 0, N) {\n\t\t\tR[i + 1][j] = R[i][j] + Q[i][j];\n\t\t}\n\t}\n}\n\nint rect(int li, int lj, int ri, int rj) {\n\treturn R[li][lj] - R[li][rj] - R[ri][lj] + R[ri][rj];\n}\n\nLL DP[5002][5002];\nint main() {\n\tcin >> N >> X >> Y;\n\tA.push_back(0);\n\tREP(i, 0, N) A.push_back(Next<int>());\n\tA.push_back(N + 1);\n\n\tN += 2;\n\tREP(i, 0, N) {\n\t\t++P[i][A[i]];\n\t}\n\tpre();\n\n\tFill(DP, INFLL);\n\tDP[0][0] = 0;\n\tREP(i, 1, N) {\n\t\tREP(j, 0, N) {\n\t\t\tif (j == A[i]) {\n\t\t\t\tLL mn = INFLL;\n\t\t\t\tREP(li, 0, i) {\n\t\t\t\t\tif (A[li] > A[i]) continue;\n\t\t\t\t\tint lj = A[li];\n\t\t\t\t\tint L = rect(li, lj, i, N) - 1;\n\t\t\t\t\tint R = rect(i, lj, N, j);\n\n\t\t\t\t\tmn = min(mn, DP[i - 1][lj] + L * X + R * Y);\n\t\t\t\t}\n\t\t\t\tDP[i][j] = mn;\n\t\t\t} else {\n\t\t\t\tDP[i][j] = DP[i - 1][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[N - 1][N - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=5100;\nint n,A,B,p[N],mx[N][N],mn[N][N];\nlong long dp[N][N],inf;\nlong long dfs(int l,int r)\n{\n\tlong long &v=dp[l][r];\n\tif(v!=inf) return v;\n\tif(l==r) return v=0;\n\tif(p[l]<mn[l+1][r]) v=min(v,dfs(l+1,r));\n\telse v=min(v,dfs(l+1,r)+A);\n\tif(p[r]>mx[l][r-1]) v=min(v,dfs(l,r-1));\n\telse v=min(v,dfs(l,r-1)+B);\n\tfor(int i=l;i<r;i++)\n\t\tif(mx[l][i]<mn[i+1][r])\n\t\t\tv=min(v,dfs(l,i)+dfs(i+1,r));\n//\tprintf(\"dp[%d][%d]=%lld\\n\",l,r,dp[l][r]);\n\treturn v;\n}\nvoid Min(ll &a,ll b) {if(b<a) a=b;} \nint main()\n{\n\tcin>>n>>A>>B;\n\tmemset(dp,63,sizeof(dp));inf=dp[0][0];\n\tfor(int i=1;i<=n;i++) cin>>p[i];\n\tfor(int l=1;l<=n;l++)\n\t{\n\t\tmx[l][l]=mn[l][l]=p[l];\n\t\tfor(int r=l+1;r<=n;r++)\n\t\t{\n\t\t\tmx[l][r]=max(mx[l][r-1],p[r]);\n\t\t\tmn[l][r]=min(mn[l][r-1],p[r]);\n\t\t}\n\t}\n//\tcout<<dfs(1,n)<<endl;\n\tfor(int i=1;i<=n;i++) dp[i][i]=0;\n\tfor(int len=1;len<=n;len++)\n\t{\n\t\tfor(int l=1;l<=n;l++)\n\t\t{\n\t\t\tint r=l+len-1;\n\t\t\tll &v=dp[l][r];\n\t\t\tif(v==inf) continue;\n//\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",l,r,v);\n\t\t\tif(r<n)\tMin(dp[l][r+1],v+(mx[l][r]<p[r+1]?0:B));\n\t\t\tif(l>1)\tMin(dp[l-1][r],v+(mn[l][r]>p[l-1]?0:A));\n\n\t\t\tint L=1,R=min(n-r,len-1),p=0;\n\t\t\twhile(L<=R)\n\t\t\t{\n\t\t\t\tint mid=(L+R)>>1;\n\t\t\t\tif(mn[r+1][r+mid]>mx[l][r]) L=mid+1,p=mid;\n\t\t\t\telse R=mid-1;\n\t\t\t}\n//\t\t\tif(l==1&&r==7) printf(\"p=%d\\n\",p);\n\t\t\tif(p) Min(dp[l][r+p],dp[l][r]+dp[r+1][r+p]);\n\n\t\t\tL=1,R=min(l-1,len),p=0;\n\t\t\twhile(L<=R)\n\t\t\t{\n\t\t\t\tint mid=(L+R)>>1;\n\t\t\t\tif(mx[l-mid][l-1]<mn[l][r]) L=mid+1,p=mid;\n\t\t\t\telse R=mid-1;\n\t\t\t}\n\t\t\tif(p) Min(dp[l-p][r],dp[l-p][l-1]+dp[l][r]);\n\t\t}\n\t}\n\tcout<<dp[1][n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5678;\nconst long long llinf = 1e18;\n\nint n, a, b, p[N];\nlong long dp[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; ++i) {\n    cin >> p[i];\n  }\n  ++n;\n  p[n] = n;\n  fill(dp + 1, dp + n + 1, llinf);\n  for (int i = 0; i < n; ++i) {\n    int foo = n + 1;\n    long long cost = 0;\n    for (int j = i + 1; j <= n; ++j) {\n      if (p[j] > p[i]) {\n        if (p[j] < foo) {\n          dp[j] = min(dp[j], dp[i] + cost);\n        }\n        foo = min(foo, p[j]);\n      }\n      if (p[j] < p[i]) {\n        cost += b;\n      } else {\n        cost += a;\n      }\n    }\n  }\n  cout << dp[n] << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  ll n, a, b;\n  cin >> n >> a >> b;\n  vi p(n);\n  rep (i, n) {\n    cin >> p[i];\n    p[i]--;\n  }\n  //DEBUG(a); DEBUG(b); \n  int next = 0;\n  ll ans = 0;\n  vl dp(n + 1, INF);\n  dp[0] = 0;\n  rep (i, n) {\n    rep (j, p.size()) {\n      if (p[j] == i) {\n        chmin(dp[i + 1], dp[i] + b);\n        int k;\n        for (k = 0; j + k < n; k++) {\n          if (p[j + k] != i + k) break;\n        }\n        //DEBUG(k);\n        chmin(dp[i + k], dp[i] + a * j);\n        p.erase(p.begin() + j);\n        break;\n      }\n    }\n  }\n  //DEBUG_VEC(dp);\n  cout << dp[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long ll;\n\nll gcd(ll x, ll y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y) {\n\treturn x / gcd(x, y)*y;\n}\nll kai(ll x, ll y, ll m) {\n\tll res = 1;\n\tfor (ll i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nll mod_pow(ll x, ll y, ll m) {\n\tll res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll comb(ll x, ll y, ll m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nconst ll INF = 1000000000000000000;\n\nint n, a, b, p[5010], x[5010];\nint cum[5010][5010];\nll d[5010][5010];\nll ans = INF;\n\nsigned main() {\n\tstd::random_device rnd;\n\tstd::mt19937_64 mt(rnd());\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; i++)cin >> p[i], x[p[i]] = i;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\tif (i < p[j])cum[i][j] = cum[i][j - 1] + 1;\n\t\telse cum[i][j] = cum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= n; i++)for (int j = 1; j <= i; j++)d[i][j] = INF;\n\td[1][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tll k = d[i][j];\n\t\t\tif (x[i + 1] < x[j])k += a;\n\t\t\tif (x[j] + 1 < x[i + 1])k += min((ll)b, (ll)a*(cum[i + 1][x[i + 1]] - cum[i + 1][x[j]]));\n\t\t\td[i + 1][j] = min(d[i + 1][j], k);\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tif (x[j] < x[i + 1])d[i + 1][i + 1] = min(d[i + 1][i + 1], d[i][j] + min((ll)b, (ll)a*(cum[i + 1][x[i + 1]] - cum[i + 1][x[j]])));\n\t\t\tif (x[j] < x[i + 1])cnt++;\n\t\t}\n\t\td[i + 1][i + 1] = min(d[i + 1][i + 1], (ll)cnt*a + (ll)(i - cnt)*b);\n\t}\n\tfor (int i = 1; i <= n; i++)ans = min(ans, d[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"pch.h\"\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <bitset>\n\n#define ll long long\n#define fri(n) for(i=0;i<(n);i++)\n#define frj(n) for(j=0;j<(n);i++)\n#define min(p,q) ((p)<(q)?(p):(q))\n#define max(p,q) ((p)>(q)?(p):(q))\n#define INF 1000000000000000000//10^18\n#define INFINT 2000000001//2*10^9+1\n#define MOD 1000000007\n#define MODANOTHER 998244353\n#define PI acos(-1)\n\nusing namespace std;\n\nint n,a,b;\nstatic int p[5010];\nstatic ll int dp[5010][5010];\nstatic int hanten[5010][5010][2];\n\nll search(int x, int y){\n\tint i;\n\tll ret;\n\tll temp1,temp2;\n\n\tif(dp[x][y]!=-1) return dp[x][y];\n\n\tif(x==y){\n\t\tdp[x][y]=0;\n\t\treturn 0;\n\t}\n\n\ttemp1=search(x+1,y);\n\ttemp2=search(x,y-1);\n\n\tret=min(temp1+b*hanten[x][y][0],temp2+a*hanten[x][y][1]);\n\n\tdp[x][y]=ret;\n\n\treturn ret;\n\n}\n\nint main(void)\n{\n\t//変数の宣言\n\n\t//よく使う変数\n\tint i,j,k,l;\n\tint flag=0;\n\tll int ans=0;\n\tint count=0;\n\tint temp=0;\n\tint temp1=0;\n\tint temp2=0;\n\tint max=0;\n\tint min=INFINT;\n\tint len=0;\n\tint sum=0;\n\tint ok=0;\n\tint ng=0;\n\n\n\n\t//データの読み込み\n\n\n\tscanf(\"%d %d %d\",&n,&a,&b);\n//\tscanf_s(\"%d %d %d\",&n,&a,&b);\n\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&p[i]);\n//\t\tscanf_s(\"%d\",&p[i]);\n\t}\n\n\t//\tprintf(\"nは%dです\\n\", n);\n\t//\tprintf(\"データの読み込み終了\\n\");\n\t//実際の処理\n\n\tfor(i=0;i<5010;i++){\n\t\tfor(j=0;j<5010;j++){\n\t\t\thanten[i][j][0]=1;\n\t\t\thanten[i][j][1]=1;\n\t\t\tdp[i][j]=-1;\n\t\t}\n\t}\n\n\tfor(i=1;i<=n;i++){\n\t\ttemp=1;\n\t\thanten[i][i][0]=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(temp<=p[j]&&p[j]<=i){\n\t\t\t\ttemp=p[j];\n\t\t\t\thanten[p[j]][i][0]=0;\n\t\t\t}\n\t\t}\n\t\ttemp=n;\n\t\thanten[i][i][1]=0;\n\t\tfor(j=n-1;j>=0;j--){\n\t\t\tif(temp>=p[j]&&p[j]>=i){\n\t\t\t\ttemp=p[j];\n\t\t\t\thanten[i][p[j]][1]=0;\n\t\t\t}\n\t\t}\n\t}\n\n\tsearch(1,n);\n\n\t//\tprintf(\"計算部分終了\\n\");\n\n\t//出力\n\n\tprintf(\"%lld\",dp[1][n]);\n\n/*\tprintf(\"\\n\");\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=i;j<=n;j++){\n\t\t\tprintf(\"hanten[%d][%d]={%d,%d}\\n\",i,j,hanten[i][j][0],hanten[i][j][1]);\n\t\t}\n\t}*/\n\t\n\t//\tprintf(\"結果の出力終了\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic ll n,a,b;\n\tstatic ll p[5002];\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\trep1(i,n)scanf(\"%lld\",&p[i]);\n\t\n\tstatic ll dp[2][5002] = {};\n\tstatic int t = 0, t_ = 1;\n\trep1(i,n){\n\t\trep1(j,n){\n\t\t\tdp[t_][j] = dp[t][j];\n\t\t\tif(j < p[i])dp[t_][j] += a;\n\t\t\telse if(j > p[i])dp[t_][j] += b;\n\t\t\tif(j > 1)dp[t_][j] = min( dp[t_][j] , dp[t_][j-1] );\n\t\t}\n\t\tswap(t,t_);\n\t}\n\tcout << dp[t][n] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nll N, A, B;\nll p[5000];\ntemplate< typename flow>\nstruct max_flow {\n    struct edge {\n        int to;\n        flow cap;\n        int rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    max_flow(int V) : V(V) { G.assign(V,vector<edge>()); }\n\n    void add_edge(int from, int to, flow cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    flow dfs(int v, int t, flow f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                flow d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    flow run(int s, int t) {\n        flow ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, INF)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\n\nint main() {\n    cin >> N >> A >> B;\n    for(int i = 0; i < N; i++) cin >> p[i];\n    max_flow<ll> graph(2 * N + 2);\n    int s = 2 * N;\n    int t = 2 * N + 1;\n    for(int i = 0; i < N; i++) {\n        graph.add_edge(s, i, A);\n        graph.add_edge(i+N, t, B);\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = i + 1; j < N; j++) {\n            if(p[i] < p[j]) continue;\n            graph.add_edge(i, j + N, 1e16);\n        }\n    }\n    cout << graph.run(s, t) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=5050;\nconst ll inf=9e18;\nll dp[N];\nint p[N],cnt[N];\nint main()\n{\n\tint n,A,B;\n\tscanf(\"%i %i %i\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++) scanf(\"%i\",&p[i]),dp[i]=inf;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint lo=0,hi=0,mx=0;\n\t\tfor(int j=i-1;j>=1;j--)\n\t\t{\n\t\t\tif(p[j]<p[i])\n\t\t\t{\n\t\t\t\tif(p[j]>mx)\n\t\t\t\t{\n\t\t\t\t\tmx=p[j];\n\t\t\t\t\tdp[i]=min(dp[i],dp[j]+(ll)lo*B+(ll)hi*A);\n\t\t\t\t}\n\t\t\t\tlo++;\n\t\t\t}\n\t\t\telse hi++;\n\t\t\t//printf(\"%i %i\\n\",p[j],p[i]);\n\t\t}\n\t\tif(lo==0) dp[i]=min(dp[i],(ll)hi*A);\n\t\t//printf(\"%i %lld hi:%i lo:%i\\n\",i,dp[i],hi,lo);\n\t}\n\tll ans=inf;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint lo=0,hi=0;\n\t\tfor(int j=1;j<p[i];j++) lo+=cnt[j];\n\t\tfor(int j=p[i]+1;j<=n;j++) hi+=cnt[j];\n\t\tans=min(ans,dp[i]+(ll)lo*B+(ll)hi*A);\n\t\tcnt[p[i]]++;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconst ll INF = 1e18;\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int N; ll tol, tor;\n   cin >> N >> tor >> tol;\n   vector<int> P(N + 2);\n   for (int i = 1; i <= N; ++i) {\n      cin >> P[i];\n   }\n   P[0] = 0;\n   P[N + 1] = N + 1;\n   vector<ll> dp(N + 2, INF);\n   dp[0] = 0;\n   for (int i = 1; i <= N + 1; ++i) {\n      int cnt = 0;\n      for (int j = i - 1; j >= 0; --j) {\n         if (P[j] > P[i]) {\n            cnt++;\n         } else {\n            dp[i] = min(dp[i], dp[j] + tor * cnt + tol * (i - j - 1 - cnt));\n         }\n      }\n   }\n   cout << dp[N + 1] << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 5000 + 5 ; \nconst int inf = 1e15 + 5 ; \nint n, A, B, p[N], dp[N][N] ; \nsigned main()\n{\n\tn = gi(), A = gi(), B = gi() ; \n\trep( i, 1, n ) p[i] = gi() ; \n\tmemset( dp, 63, sizeof(dp) ), dp[0][0] = 0 ; \n\trep( i, 1, n ) rep( j, 0, i - 1 ) {\n\t\tif( p[j] < p[i] ) \n\t\t\tdp[i][i] = min( dp[i][i], dp[i - 1][j] ),\n\t\t\tdp[i][j] = dp[i - 1][j] + A ; \n\t\tif( p[j] > p[i] ) \n\t\t\tdp[i][j] = dp[i - 1][j] + B ; \n\t}\n\tint ans = inf ; \n\trep( i, 1, n ) ans = min( ans, dp[n][i] ) ;\n\tcout << ans << endl ; \n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define LL long long\nusing namespace std;\nconst int maxn = 5e3 + 5;\nLL f[maxn][maxn], trs[maxn][maxn][2];\nint a[maxn], n, A, B;\nint vis[maxn], pos[maxn], pt, dis;\nint main() {\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor(register int i = 1; i <= n; ++i) \n\t\tscanf(\"%d\", &a[i]), pos[a[i]] = i;\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0][n + 1] = 0, pt = 0, pos[n + 1] = n + 1;\n\tfor(register int l = 0; l < n + 1; ++l) {\n\t\tvis[pos[l]] = 1, dis = 0;\n\t\tfor(register int i = pos[l + 1] - 1; i >= 0; --i)\n\t\t\tif(!vis[i]) ++dis;\n\t\tfor(register int r = n + 1; r > l; --r) {\n\t\t\tif(pos[r] <= pos[l + 1]) --dis;\n\t\t\ttrs[l][r][1] = B;\n\t\t\tif(dis == 0) trs[l][r][1] = 0;\n\t\t\ttrs[l][r][1] = min(trs[l][r][1], 1ll * dis * A);\n\t\t}\n\t}\n\tmemset(vis, 0, sizeof(vis));\n\tfor(register int r = n + 1; r > 0; --r) {\n\t\tvis[pos[r]] = 1, dis = 0;\n\t\tfor(register int i = pos[r - 1] + 1; i <= n + 1; ++i)\n\t\t\tif(!vis[i]) ++dis;\n\t\tfor(register int l = 0; l < r; ++l) {\n\t\t\tif(pos[l] >= pos[r - 1]) --dis;\n\t\t\ttrs[l][r][0] = A;\n\t\t\tif(dis == 0) trs[l][r][0] = 0;\n\t\t\ttrs[l][r][0] = min(trs[l][r][0], 1ll * dis * B);\n\t\t}\n\t}\n\tfor(register int i = n + 2; i >= 3; --i) {\n\t\tfor(register int l = 0; l <= n + 2 - i; ++l) {\n\t\t\tint r = l + i - 1;\n\t\t\tf[l][r - 1] = min(f[l][r - 1], f[l][r] + trs[l][r][0]);\n\t\t\tf[l + 1][r] = min(f[l + 1][r], f[l][r] + trs[l][r][1]);\n\t\t}\n\t}\n\tLL ans = 0x3f3f3f3f3f3f3f3f;\n\tfor(register int i = 0; i <= n; ++i) {\n\t\tans = min(ans, f[i][i + 1]);\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define debug printf(\"fuck %d\\n\", __LINE__);\n\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tif (ch == '-') bo = -1;\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tres = (res << 1) + (res << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn bo * res;\n}\n\ntemplate <typename T>\nvoid read(T &x) {\n\tx = read();\n}\n\ntemplate <typename T, typename... Argv>\nvoid read(T &a, Argv &... argv) {\n\tread(a);\n\tread(argv...);\n}\n\nconst int N = 5005;\nLL s[N], p[N], f[N];\nint n, A, B;\n\nint main() {\n\tmemset(f, 0x3f, sizeof(f));\n\tread(n, A, B); f[0] = 0;\n\tfor (int i = 1, x; i <= n; ++ i) {\n\t\tread(x);\n\t\tfor (int j = 0; j <= n; ++ j) \n\t\t\tif (j) p[j] = std::min(p[j - 1], f[j]);\n\t\t\telse p[j] = f[j];\n\t\tfor (int j = 0; j <= x; ++ j) f[j] += A;\n\t\tfor (int j = x + 1; j <= n; ++ j) f[j] += B;\n\t\tf[x] = std::min(f[x], p[x]);\n\t}\n\tLL ans = f[n + 1];\n\tfor (int i = 0; i <= n; ++ i) ans = std::min(ans, f[i]);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define MAX_V 15000\n\n//rev: G[to][rev]で逆辺にアクセスできるようにしている\nstruct edge {int to;ll cap;int rev;};\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, ll cap){\n\tG[from].push_back((edge){to, cap, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\n//vからtに流せたフローの量を返す　fはvが保持しているフローの量\nll dfs(int v, int t, ll f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tll d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nll max_flow(int s, int t){\n\tll flow = 0;\n\tfor(;;){\n\t\tmemset(used,0,sizeof(used));//usedを0で初期化してるだけ\n\t\tll f = dfs(s,t,LINF);\n\t\tif(f==0) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main(void){\n\tint n,p;\n\tll a,b;\n\tcin>>n>>a>>b;\n\tvector<int> P;\n\trep(i,n){\n\t\tcin>>p;\n\t\tP.push_back(p);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i>=j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(P[i]>P[j]){\n\t\t\t\tadd_edge(i+1,n+j+1,LINF);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n){\n\t\tadd_edge(0,i+1,a);\n\t}\n\trep(i,n){\n\t\tadd_edge(n+i+1,2*n+1,b);\n\t}/*\n\trep(i,2*n+2){\n\t\tcout<<i<<\" \";\n\t\trep(j,G[i].size()){\n\t\t\tcout << G[i][j].to << \" \" << G[i][j].cap<<\", \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\n\n\tcout<<max_flow(0,2*n+1)<<endl;;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <tuple>\ntemplate <typename T> constexpr T my_abs(const T &x) { return x < 0 ? -x : x; }\nusing ll = long long;\nll dp[5005][5005];\nint main()\n{\n\t// freopen(\"AGC032-D.in\", \"r\", stdin);\n\tint n, a, b;\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tfor (int j = 0; j <= n; j++)\n\t\t{\n\t\t\tif (dp[i][j] >= 1e18)\n\t\t\t\tcontinue;\n\t\t\tif (x > j)\n\t\t\t{\n\t\t\t\tdp[i + 1][x] = std::min(dp[i + 1][x], dp[i][j]);\n\t\t\t\tdp[i + 1][j] = std::min(dp[i + 1][j], dp[i][j] + a);\n\t\t\t}\n\t\t\telse\n\t\t\t\tdp[i + 1][j] = std::min(dp[i + 1][j], dp[i][j] + b);\n\t\t}\n\t}\n\tll ans = 1e18;\n\tfor (int i = 0; i <= n; i++)\n\t\tans = std::min(ans, dp[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <iostream>\n#include <random>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include <fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing pll = pair<ll, ll>;\nusing qll = queue<ll>;\nusing vb = vector<bool>;\nusing mll = map<ll, ll>;\nusing sll = stack<ll>;\n#define REP(i,n) for(ll i(0);(i)<(n);(i)++)\n#define rep(i,n) for(ll i(0);(i)<(n);(i)++)\n#define ALL(a) a.begin(), a.end()\n#define enld endl //* missspell check\nconst ll INF = 1LL << 59;\n\n\nstruct edgeForFlow{ll to, cap, rev; }; //! cap: may change; rev: pointer in G[to]\n\nvoid addEdgeForFlow(vector<vector<edgeForFlow>> &G, ll from, ll to, ll cap){\n    G[from].push_back((edgeForFlow){ to, cap,  (ll) G[to].size()});\n    G[to].push_back((edgeForFlow) { from, 0, (ll) G[from].size()-1});\n}\n\nll dfsFordFulkson(vector<vector<edgeForFlow>> &G, vb &checked, ll v, ll t, ll f){\n    //* v: current vertex, t: sink, f: DELTA of this path. (No need for source)\n    if(v == t) return f;\n    checked[v] = true;\n    REP(i, G[v].size()){\n        edgeForFlow &e = G[v][i];\n        if(!checked[e.to] && e.cap > 0){\n            ll d = dfsFordFulkson(G, checked, e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0; //* if no valid outgoing edges\n}\n\nll maxFlowFordFulkson(vector<vector<edgeForFlow>> &G, ll s, ll t){\n    vb checked(G.size());\n    ll flow = 0;\n    for(;;){\n        fill(ALL(checked), false);\n        ll f = dfsFordFulkson(G, checked, s, t, INF);\n        if(f == 0) \n            return flow;\n        flow += f;\n    }\n}\n\nvoid bfsDinic(vector<vector<edgeForFlow>> &G, vll &level, ll s){\n    fill(ALL(level), -1);\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n        ll v = que.front(); que.pop();\n        for(ll i=0; i< G[v].size(); i++){\n            edgeForFlow &e = G[v][i];\n            if(e.cap > 0 && level[e.to] < 0){\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nll dfsDinic(vector<vector<edgeForFlow>> &G, vll &level, vll &iter, ll v, ll t, ll f){\n    //? iter: record where have been searched?\n    //* v: current vertex, t: sink, f: DELTA of this path. (No need for source)\n    if(v == t) return f;\n    for( ll &i = iter[v]; i < G[v].size(); i++){\n        edgeForFlow &e = G[v][i];\n        if( e.cap > 0 && level[v] < level[e.to]){\n            ll d = dfsDinic(G, level, iter, e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0; //* if no valid outgoing edges\n}\n\nll maxFlowDinic(vector<vector<edgeForFlow>> &G, ll s, ll t){\n    vll level(G.size()), iter(G.size());\n    ll flow = 0;\n    for(;;){\n        bfsDinic(G, level, s);\n        if(level[t] < 0)//* sink t is not reachable from s on current residual graph\n            return flow;\n        fill(ALL(iter), 0);\n        ll f;\n        while((f = dfsDinic(G, level, iter, s, t, INF)) > 0){\n            flow += f;\n        }\n    }\n}\n\nvoid solve(long long N, long long A, long long B, std::vector<long long> p){\n    vector<vector<edgeForFlow>> G(2*N+2);\n    ll s = 2*N, t = 2*N+1;\n    REP(i, N){\n        addEdgeForFlow(G, s, i, A);\n        addEdgeForFlow(G, i+N, t, B);\n    }\n    for(ll i=0; i< N; i++){\n        for(ll j = i+1; j < N; j++){\n            ll u = p[i], v = p[j];\n            if(p[i] > p[j]) addEdgeForFlow(G, u, v+N, INF);\n        }\n    }\n    ll ans = maxFlowDinic(G, s, t);\n    cout<<ans<<endl;\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long A;\n    scanf(\"%lld\",&A);\n    long long B;\n    scanf(\"%lld\",&B);\n    std::vector<long long> p(N);\n    for(int i = 0 ; i < N ; i++){\n        scanf(\"%lld\",&p[i]);\n        p[i]--;\n    }\n    solve(N, A, B, std::move(p));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int N = 5005;\nconst int inf = 1e18;\nint n, a[N], f[N], p[N], A, B, s[N];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); A = read(); B = read();\n\tfor(int i = 1; i <= n; i ++) a[i] = read();\n\tfor(int i = 1; i <= n; i ++) f[i] = inf;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tint x = a[i];\n\t\tfor(int j = 0; j <= n; j ++)\n\t\t{\n\t\t\tif(j) p[j] = min(f[j], p[j - 1]);\n\t\t\telse p[j] = f[j];\n\t\t}\n\t\tfor(int j = 0; j <= x; j ++) f[j] += A;\n\t\tfor(int j = x + 1; j <= n; j ++) f[j] += B;\n\t\tf[x] = min(f[x], p[x]);\n\t}\n\tint ans = inf;\n\tfor(int i = 0; i <= n; i ++) ans = min(ans, f[i]);\n\tprintf(\"%lld\\n\", ans);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n#include <limits>\n\n// contancer library\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <functional>\n\nusing ll = long long;\nusing ld = long double;\n\n/* ----- class ----- */\n\ntemplate <class Cost = int, class Cap = int>\nstruct Edge {\n    int from, to, rev;\n    Cost cost;\n    Cap cap;\n    Edge(int from = -1, int to = -1, Cost cost = 1, Cap cap = 0, int rev = -1)\n        : from(from), to(to), cost(cost), cap(cap), rev(rev){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int, class Cap = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost, Cap>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int u, int v, Cost cost = 1, Cap cap = 0) {\n        path[u].push_back(Edge<Cost, Cap>(u, v, cost, cap));\n    }\n    std::vector<Edge<Cost, Cap>> operator[](int v) const { return path[v]; }\n};\n\n/* ----- Output Functions for Debugging ----- */\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v);\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p);\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q);\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q);\ntemplate <class T, class U>\nstd::ostream& operator<<(std::ostream& os, Edge<T, U> e);\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class L, class R>\nstd::ostream& operator<<(std::ostream& os, std::pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\ntemplate <class K, class T>\nstd::ostream& operator<<(std::ostream& os, std::map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\ntemplate <class T, class U>\nstd::ostream& operator<<(std::ostream& os, Edge<T, U> e) {\n    return os << \"(\" << e.from << \"->\" << e.to << \":\" << e.cost << \",\" << e.cap << \")\";\n}\n\n/* ----- Short Functions ----- */\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\n/* ----- Constants ----- */\n\n// const int INF = std::numeric_limits<int>::max();\nconst ll INF = 1LL << 55;\n// const ld PI = acos(-1);\n// const ld EPS = 1e-10;\n// std::mt19937 mt(ll(time(0)));\n\nint main() {\n    int N;\n    ll A, B;\n    std::cin >> N >> A >> B;\n    std::vector<int> p(N);\n    for (auto& e : p) std::cin >> e;\n\n    std::vector<bool> backbig(N, false);\n    int max = p[N - 1];\n    for (int i = N - 2; i >= 0; --i) {\n        if (p[i] < max) backbig[i] = true;\n        max = std::max(max, p[i]);\n    }\n\n    auto dp = Vec<ll>(N + 1, N + 1, INF);\n    dp[0][0] = 0;\n    // i個目までで、jを固定したときの最小コスト\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            if (p[i] == j) continue;\n            if (p[i] < j) {\n                // i項目は左へ移動\n                dp[i + 1][j] = std::min(dp[i + 1][j], dp[i][j] + B);\n                // 固定\n                dp[i + 1][p[i]] = std::min(dp[i + 1][p[i]], dp[i][j] + A);\n            } else {\n                dp[i + 1][p[i]] = std::min(dp[i + 1][p[i]], dp[i][j]);\n            }\n        }\n    }\n\n    std::cout << *std::min_element(dp[N].begin(), dp[N].end()) << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll INF = 1e18;\nconst int MAXN = 5007;\nll dp[MAXN][MAXN];\nint a[MAXN], p[MAXN];\nint main()\n{\n    int n; ll A, B; scanf(\"%d%lld%lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), p[a[i]] = i;\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j <= n; j++)\n            dp[i][j] = INF;\n    dp[0][0] = 0;\n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j <= i; j++)\n        {\n            if (j < p[i]) \n            {\n                dp[i][p[i]] = min(dp[i][p[i]], dp[i - 1][j]);\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + B);\n            }\n            else dp[i][j] = min(dp[i][j], dp[i - 1][j] + A);\n        }\n    // for (int i = 0; i <= n; i++)\n    //     for (int j = 0; j <= n; j++) printf(\"%lld%c\", dp[i][j], \" \\n\"[j == n]);\n    ll ans = INF;\n    for (int i = 0; i <= n; i++) ans = min(ans, dp[n][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long ll;\n\nll gcd(ll x, ll y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y) {\n\treturn x / gcd(x, y)*y;\n}\nll kai(ll x, ll y, ll m) {\n\tll res = 1;\n\tfor (ll i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nll mod_pow(ll x, ll y, ll m) {\n\tll res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll comb(ll x, ll y, ll m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nconst ll INF = 1000000000000000000;\n\nint n, a, b, p[5010], x[5010];\nint cum[5010][5010];\nll d[5010][5010];\nll ans = INF;\n\nsigned main() {\n\tstd::random_device rnd;\n\tstd::mt19937_64 mt(rnd());\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; i++)cin >> p[i], x[p[i]] = i;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\tif (i < p[j])cum[i][j] = cum[i][j - 1] + 1;\n\t\telse cum[i][j] = cum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= n; i++)for (int j = 1; j <= i; j++)d[i][j] = INF;\n\td[1][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tll k = d[i][j];\n\t\t\tif (x[i + 1] < x[j])k += a;\n\t\t\tif (x[j] + 1 < x[i + 1])k += min((ll)b, (ll)a*(cum[i + 1][x[i + 1]] - cum[i + 1][x[j]]));\n\t\t\td[i + 1][j] = min(d[i + 1][j], k);\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tif (x[j] < x[i + 1])d[i + 1][i + 1] = min(d[i + 1][i + 1], d[i][j] + min(b, (ll)a*(cum[i + 1][x[i + 1]] - cum[i + 1][x[j]])));\n\t\t\tif (x[j] < x[i + 1])cnt++;\n\t\t}\n\t\td[i + 1][i + 1] = min(d[i + 1][i + 1], (ll)cnt*a + (ll)(i - cnt)*b);\n\t}\n\tfor (int i = 1; i <= n; i++)ans = min(ans, d[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 10000000000000ll\nusing namespace std;\nint read();\nint n, a, b;\n\n#define root 0, n, 1\n#define ls l, mid, k << 1\n#define rs mid + 1, r, k << 1 | 1\nstruct Seg {\n    long long tmn[400005], tag[400005];\n    void Tag(int k, long long v) { tmn[k] += v, tag[k] += v; }\n    void psd(int k) {\n        Tag(k << 1, tag[k]), Tag(k << 1 | 1, tag[k]), tag[k] = 0;\n    }\n    void update(int k) { tmn[k] = min(tmn[k << 1], tmn[k << 1 | 1]); }\n    void build(int l, int r, int k) {\n        if (l == r) return tmn[k] = l ? inf : 0, void();\n        int mid = l + r >> 1;\n        build(ls), build(rs), update(k);\n    }\n    void modi(int l, int r, int k, int p, long long v) {\n        if (l == r) return tmn[k] = v, void();\n        psd(k);\n        int mid = l + r >> 1;\n        p <= mid ? modi(ls, p, v) : modi(rs, p, v), update(k);\n    }\n    long long qry(int l, int r, int k, int st, int en) {\n        if (st > r || en < l) return inf;\n        if (st <= l && en >= r) return tmn[k];\n        psd(k);\n        int mid = l + r >> 1;\n        return min(qry(ls, st, en), qry(rs, st, en));\n    }\n    void add(int l, int r, int k, int st, int en, int v) {\n        if (st > r || en < l) return;\n        if (st <= l && en >= r) return Tag(k, v);\n        psd(k);\n        int mid = l + r >> 1;\n        add(ls, st, en, v), add(rs, st, en, v), update(k);\n    }\n} seg;\n\nint main() {\n    n = read(), a = read(), b = read();\n    seg.build(root);\n    for (int i = 1, x; i <= n; ++i) {\n        x = read(), seg.modi(root, x, seg.qry(root, 0, x));\n        seg.add(root, 0, x - 1, a), seg.add(root, x + 1, n, b);\n    }\n    printf(\"%lld\\n\", seg.qry(root, 0, n));\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define ull unsigned long long\n#define mp make_pair\n#define ld long double\n#define fi first\n#define se second\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nconst int N=5005;\nconst ll inf=1e18;\nll dp[N][N];\nint f[N][N],g[N][N],p[N],A,B;\nint main(){\n\tint n=read(); A=read(); B=read();\n\tfor(int i=1;i<=n;i++){\n\t\tp[i]=read(); f[p[i]][p[i]]=i; g[p[i]][p[i]]=i;\n\t}\n\tfor(int i=n;i;i--){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tdp[i][j]=inf;\n\t\t\tf[i][j]=max(f[i][j-1],f[j][j]); g[i][j]=min(g[i][j-1],g[j][j]);\n\t\t\tif(f[j][j]>f[i][j-1])dp[i][j]=min(dp[i][j],dp[i][j-1]); else dp[i][j]=min(dp[i][j],dp[i][j-1]+A);\n\t\t\tif(g[i][i]<g[i+1][j])dp[i][j]=min(dp[i][j],dp[i+1][j]); else dp[i][j]=min(dp[i][j],dp[i+1][j]+B);\n\t\t}\n\t}\n\tcout<<dp[1][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define itrep(i, a) for (auto i = (a).begin(); i != (a).end(); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n#define mp(a, b) make_pair((a), (b))\n\nusing namespace std;\n\ntemplate<class T> void inputVector(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\n\nint leftBig[5010], rightSmall[5010];\n\nint N, A, B;\nvector<int> p;\n\nvoid makeLeftBig() {\n    set<int> st;\n    rep(i, N) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.end()) leftBig[p[i]] = N + 1;\n        else leftBig[p[i]] = *it;\n        st.insert(p[i]);\n    }\n    //cerr << \"leftBig:\";\n    //REP(i, 1, N) cerr << \" \" << leftBig[i];\n    //cerr << endl;\n}\nvoid makeRightSmall() {\n    set<int> st;\n    for (int i = N - 1; i >= 0; i--) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.begin()) rightSmall[p[i]] = 0;\n        else {\n            it--;\n            rightSmall[p[i]] = *it;\n        }\n        st.insert(p[i]);\n    }\n    //cerr << \"rightSmall:\";\n    //REP(i, 1, N) cerr << \" \" << rightSmall[i];\n    //cerr << endl;\n}\n\nstruct Info {\n    int left, right;\n    int dist;\n\n    Info(int left, int right, int dist) : left(left), right(right), dist(dist) {\n    }\n\n    bool operator< (const Info& a) const {\n        return dist > a.dist;\n    }\n};\n\nint memo[5010][5010];\n\nsigned main() {\n    cin >> N >> A >> B;\n\n    inputVector(p, N);\n\n    makeLeftBig();\n    makeRightSmall();\n\n    rep(i, N + 5) rep(j, N + 5) memo[i][j] = LLONG_MAX;\n\n    priority_queue<Info> q;\n    q.push(Info(0, N + 1, 0));\n    memo[0][N + 1] = 0;\n    while (!q.empty()) {\n        auto info = q.top(); q.pop();\n        if (info.dist > memo[info.left][info.right]) continue;\n        //cerr << \"Info: [left:\" << info.left << \" right:\" << info.right << \" dist:\" << info.dist << \"]\" << endl;\n        if (info.left + 1 == info.right) {\n            cout << info.dist << endl;\n            break;\n        }\n\n        {\n            int nextNum = info.left + 1;\n            int ndist = info.dist;\n            if (leftBig[nextNum] < info.right) {\n                ndist += min(B, A * (info.right - info.left - 1));\n            }\n            if (ndist < memo[info.left + 1][info.right]) {\n                memo[info.left + 1][info.right] = ndist;\n                q.push(Info(info.left + 1, info.right, ndist));\n            }\n        }\n        {\n            int nextNum = info.right - 1;\n            int ndist = info.dist;\n            if (rightSmall[nextNum] > info.left) {\n                ndist += min(A, B * (info.right - info.left - 1));\n            }\n            if (ndist < memo[info.left][info.right - 1]) {\n                memo[info.left][info.right - 1] = ndist;\n                q.push(Info(info.left, info.right - 1, ndist));\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " /*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n\nusing namespace std;\ntemplate<typename T1, typename T2> inline void chkmin(T1 &a, T2 b) {if (a > b) a = b;}\ntemplate<typename T1, typename T2> inline void chkmax(T1 &a, T2 b) {if (a < b) a = b;}\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define all(c) (c).begin(), (c).end()\n#define sz(c) (int)(c).size()\n#define left left228\n#define right right228\n#define y1 y1228\n#define mp update_pair\n#define pb push_back\n#define y2 y2228\nconst string FILENAME = \"input\";\nconst int MAXN = 5005;\n\n\nint n, a, b;\nint p[MAXN];\nlong long dp[MAXN][MAXN];\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n  \t//read(FILENAME);\n\tcin >> n >> a >> b;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tdp[i][j] = 1e18;\n\t\t}\t\n\t}\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n            if (p[i] < j) {\n                chkmin(dp[i + 1][j], dp[i][j] + b);\n            } else {\n               \tchkmin(dp[i + 1][p[i]], dp[i][j]);\n                chkmin(dp[i + 1][j], dp[i][j] + a);\n            }\n\t\t}\n\t}\n\tlong long ans = 1e18;\n\tfor (int i = 0; i <= n; i++) {\n\t\tchkmin(ans, dp[n][i]);\n\t}\n\tcout << ans << '\\n';\n\treturn 0; \t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define y1 A2Dalek\n#define y0 Cyberman\n#define yn RoseTyler\n#define j1 JackHarkness\n#define fs first\n#define sd second\nconst int N=2e5;\nconst long long oo=1e16+5;\nint du[]={-1,0,0,1};\nint dv[]={0,-1,1,0};\nconst long long mod=1e9+7;\ntypedef pair<int,int> ii;\ntypedef pair<int,ii> iii;\nlong long sqr(long long x) {return x*x;}\nint getbit(int state, int i) {return ((state>>i)&1);}\n\nlong long A,B;\nint n;\nlong long dequy(vector<int> q)\n{\n    long long ans=oo;\n    if (q.size()<=1) return 0;\n    for (int i=0;i<q.size();i++)\n    {\n        long long tmp=0;\n        vector<int> q1;\n        vector<int> q2;\n        for (int j=0;j<i;j++) if (q[i]<q[j]) tmp+=A; else q1.push_back(q[j]);\n        for (int j=i+1;j<q.size();j++) if (q[i]>q[j]) tmp+=B; else q2.push_back(q[j]);\n        tmp+=dequy(q1);\n        tmp+=dequy(q2);\n        ans=min(ans,tmp);\n    }\n    return ans;\n}\nint main()\n{\n\t//freopen(\"Rotation Sort.inp\",\"r\",stdin);\n\t//freopen(\"Rotation Sort.out\",\"w\",stdout);\n\tios_base::sync_with_stdio(false);\n\tvector<int> q;\n    cin>>n>>A>>B;\n    for (int i=1;i<=n;i++)\n    {\n        int x;\n        cin>>x;\n        q.push_back(x);\n    }\n    cout<<dequy(q);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define lc (rt << 1)\n#define rc (rt << 1) | 1\nusing namespace std;\ntypedef long long LL;\nconst int N = 5005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, A, B, p[N];\nLL mn[N << 2], tag[N << 2];\n\ninline void pushup(int rt) {\n    mn[rt] = min(mn[lc], mn[rc]);\n}\n\ninline void puttag(int rt, LL tg) {\n    mn[rt] += tg;\n    tag[rt] += tg;\n}\n\ninline void pushdown(int rt) {\n    if (tag[rt]) {\n        puttag(lc, tag[rt]);\n        puttag(rc, tag[rt]);\n        tag[rt] = 0;\n    }\n}\n\nvoid SetVal(int rt, int b, int e, int p, LL val) {\n    if (b == e) {\n        mn[rt] = val;\n        return;\n    }\n    int mid = (b + e) >> 1;\n    pushdown(rt);\n    if (p <= mid) SetVal(lc, b, mid, p, val);\n    else SetVal(rc, mid + 1, e, p, val);\n    pushup(rt);\n}\n\nvoid Update(int rt, int b, int e, int l, int r, LL val) {\n    if (l <= b && e <= r) {\n        puttag(rt, val);\n        return;\n    }\n    int mid = (b + e) >> 1;\n    pushdown(rt);\n    if (l <= mid) Update(lc, b, mid, l, r, val);\n    if (r > mid) Update(rc, mid + 1, e, l, r, val);\n    pushup(rt);\n}\n\nLL Query(int rt, int b, int e, int l, int r) {\n    if (l <= b && e <= r) return mn[rt];\n    int mid = (b + e) >> 1;\n    pushdown(rt);\n    if (r <= mid) return Query(lc, b, mid, l, r);\n    if (l > mid) return Query(rc, mid + 1, e, l, r);\n    return min(Query(lc, b, mid, l, r), Query(rc, mid + 1, e, l, r));\n}\n\nvoid solve() {\n    read(n); read(A); read(B);\n\tfor (int i = 1; i <= n; ++i) {\n        read(p[i]);\n\t}\n    mset(mn, 0x3f);\n    SetVal(1, 0, n, 0, 0);\n\tfor (int i = 1; i <= n; ++i) {\n\t    LL tmp = Query(1, 0, n, 0, p[i] - 1);\n\t    SetVal(1, 0, n, p[i], tmp);\n        Update(1, 0, n, 0, p[i] - 1, A);\n        if (p[i] <n) Update(1, 0, n, p[i] + 1, n, B);\n\t}\n\tprintf(\"%lld\\n\", mn[1]);\n}\n\nint main() {\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 5003\n#define ll long long\n\nusing namespace std;\n\nint n, m, a, b;\nint pos[N];\nll f[N][N << 1];\n\nint main(){\n\tcin >> n >> a >> b; m = n * 2 + 1;\n\tfor(int i = 1; i <= n; ++i){\n\t\tint x; scanf(\"%d\", &x);\n\t\tpos[x] = i * 2;\n\t}\n\tmemset(f, 127, sizeof f);\n\tfor(int j = 1; j <= m; ++j) f[0][j] = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= m; ++j){\n\t\t\tll tmp = (j != pos[i]) * (j < pos[i] ? b : a);\n\t\t\ttmp += f[i - 1][j - !(j & 1)]; \n\t\t\tf[i][j] = min(f[i][j - 1], tmp);\n\t\t}\n\tcout << f[n][m] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing PII = pair<int, int>;\nusing TI3 = tuple<int, int, int>;\nusing LL = long long;\nusing ULL = unsigned long long;\nusing MAT = array<array<LL, 2>, 2>;\n\ntemplate<class T> constexpr inline T begin(const T&) {return 0;}\ntemplate<class T> constexpr inline T end(const T& x) {return max(T(0), x);}\n\n#define SZ(x) int((x).size())\n#define PB push_back\n#define EB emplace_back\n#define GET_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define CHECK(a,b) static_assert(std::is_same<decltype(a), decltype(b)>::value, \"REP diff types\");\n\n#define REPPP(i,s,c,t) for(i; ((s) and (c)) or (putchar(\"\\n \"[c]) and (c)); (t))\n#define REPP2(i,n) REPPP(auto i=begin(n),i==begin(n),i!=end(n),++i)\n#define REPP3(i,m,n) CHECK(m,n) REPPP(auto i=(m),i==(m),i<(n),++i)\n#define REPP4(i,m,n,s) CHECK(m,n) REPPP(auto i=(m),i==(m),((s)>0 and i<(n)) or ((s)<0 and i>(n)),i+=(s))\n#define REPP(...) GET_MACRO(__VA_ARGS__, REPP4, REPP3, REPP2)(__VA_ARGS__)\n\n#define REP2(i,n) for(auto i=begin(n);i!=end(n);++i)\n#define REP3(i,m,n) CHECK(m,n) for(auto i=(m);i<(n);++i)\n#define REP4(i,m,n,s) CHECK(m,n) for(auto i=(m);((s)>0 and i<(n)) or ((s)<0 and i>(n));i+=(s))\n#define REP(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2)(__VA_ARGS__)\n\ntemplate<class T> void _read(T &x) {cin >> x;}\nvoid _read(size_t &x) {scanf(\"%zu\", &x);}\nvoid _read(int &x) {scanf(\"%d\", &x);}\nvoid _read(LL &x) {scanf(\"%lld\", &x);}\nvoid _read(ULL &x) {scanf(\"%llu\", &x);}\nvoid _read(double &x) {scanf(\"%lf\", &x);}\nvoid _read(char &x) {scanf(\" %c\", &x);}\nvoid _read(char *x) {scanf(\"%s\", x);}\nvoid read() {}\ntemplate<class T, class... U>\nvoid read(T& head, U&... tail) {\n    _read(head);\n    read(tail...);\n}\n\ntemplate<class T> void _print(const T &x) {cout << x;}\nvoid _print(const size_t &x) {printf(\"%zu\", x);}\nvoid _print(const int &x) {printf(\"%d\", x);}\nvoid _print(const LL &x) {printf(\"%lld\", x);}\nvoid _print(const ULL &x) {printf(\"%llu\", x);}\nvoid _print(const double &x) {printf(\"%.16lf\", x);}\nvoid _print(const char &x) {putchar(x);}\nvoid _print(const char *x) {printf(\"%s\", x);}\nvoid _print(const string &x) {printf(\"%s\", x.c_str());}\ntemplate<class T> void _print(const vector<T> &x) {\n    for(auto i = x.begin(); i != x.end(); _print(*i++)) {\n        if (i != x.cbegin()) putchar(' ');\n    }\n}\nvoid print() {putchar('\\n');}\ntemplate<class T, class... U> void print(const T& head, const U&... tail) {\n    _print(head);\n    if(sizeof...(tail)) putchar(' ');\n    print(tail...);\n}\n\n\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define INF 0x3f3f3f3f\n\nconst int MOD = 1000000007;\n\n//}}}\n#define MAX_N 5005\n\nint q[MAX_N];\nLL dp[MAX_N][MAX_N];\n\nint main()\n{\n    int N, A, B;\n    read(N, A, B);\n    REP(i, 1, N + 1) {\n        int k;\n        read(k);\n        q[k] = i;\n    }\n\n    REP(i, 1, N + 1) {\n        REP(j, N + 1) {\n            LL m = LLINF;\n            REP(k, j + 1) {\n                m = min(m, dp[i - 1][k]);\n            }\n\n            LL cost;\n            if(q[i] == j) {\n                cost = 0;\n            } else if(q[i] < j) {\n                cost = A;\n            } else {\n                cost = B;\n            }\n            dp[i][j] = m + cost;\n            //_print(dp[i][j]);\n        }\n    }\n    LL ans = LLINF;\n    REP(j, N + 1) {\n        ans = min(ans, dp[N][j]);\n    }\n    print(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSR(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nll A,B;\nint p[5005];\nvector<P>vec;\nll up[5005],dw[5005];\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t}\n\tint cur = -1;\n\tint pre = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i == 1){\n\t\t\tcur = p[i];\n\t\t}\n\t\telse if(cur+1 != p[i]){\n\t\t\tvec.pb(mp(pre+1,i-1));\n\t\t\tpre = i-1;\n\t\t\tcur = p[i];\n\t\t}\n\t\telse cur++;\n\t}\n\tvec.pb(mp(pre+1,n));\n\tll ans = 1e18;\n\tll C = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = vec[i].sc-vec[i].fi+1;\n\t\tll R = 0;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t    if(i == j) continue;\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] > p[y]){\n\t\t\t\tif(j > i) R += vec[j].sc-vec[j].fi+1;\n\t\t\t\telse;\n\t\t\t}\n\t\t}\n\t\tdw[i] = min(L*A,R*B);\n\t//\tcout << i << \" \" << L << \" \" << R<< endl;\n\t}\n\tll D = 0;\n\tans = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = 0;\n\t\tll R = vec[i].sc-vec[i].fi+1;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t    if(i == j) continue;\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] < p[y]){\n\t\t\t\tif(j < i) L += vec[j].sc-vec[j].fi+1;\n\t\t\t\telse;\n\t\t\t}\n\t\t}\n\t\tans += min(L*A,R*B);\n\t}\n/*\tfor(int j=0;j<=n;j++){\n\t    ll C = 0;\n\t    for(int i=0;i<vec.size();i++){\n\t        if(p[vec[i].fi] <= j) C += up[i];\n\t        else C += dw[i];\n\t    }\n\t    ans = min(ans,C); //cout<<C<<endl;\n\t}*/\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define int long long\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nll INF=1e18;\n\nll dp[5123][5123];\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,R,L;\n\t// n=5000; R=L=1000000000; --L;\n\tcin>>n>>R>>L;\n\tINF=ll(n-1)*min(L,R);\n\tvector<int> a(n); //rep(i,n) a[i]=n-1-i;\n\trep(i,n) cin>>a[i], --a[i];\n\tvector<int> toL(n),toR(n);\n\t{\n\t\tset<int> st{n};\n\t\trep(i,n){\n\t\t\ttoL[a[i]]=*st.lower_bound(a[i]);\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\t{\n\t\tset<int> st{-1};\n\t\trrep(i,n){\n\t\t\tauto it=st.lower_bound(a[i]); --it;\n\t\t\ttoR[a[i]]=*it;\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\t// out(toL,toR,1);\n\tfill(dp[0],dp[5123],INF);\n\tdp[0][n-1]=0;\n\trreps(d,2,n+1)rep(l,n+1-d){\n\t\tint r=l+d-1;\n\t\tMN(dp[l+1][r],dp[l][r]+(toL[l]>r?0:L));\n\t\tMN(dp[l][r-1],dp[l][r]+(toR[r]<l?0:R));\n\t}\n\t// rep(i,n){rep(j,n) cout<<dp[i][j]<<\",\";cout<<endl;}\n\tll re=INF;\n\trep(i,n) MN(re,dp[i][i]);\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,a,b,p[5005],idx[5005][5005],cum[5005][5005];\nlong long dp[5005][5005];\nlong long solve(int i,int j)\n{\n\tif (!idx[i][j])\n\treturn 0;\n\tif (dp[i][j]!=-1)\n\treturn dp[i][j];\n\treturn dp[i][j]=min(a+solve(i,p[idx[i][j]]-1),1LL*b*(cum[i][j]-cum[idx[i][j]][j])+solve(idx[i][j]-1,j));\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&p[i]);\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tidx[i][j]=idx[i-1][j];\n\t\t\tif (p[i]<=j && p[i]>p[idx[i][j]])\n\t\t\tidx[i][j]=i;\n\t\t\tcum[i][j]=cum[i-1][j]+(p[i]<=j);\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%lld\",solve(n,n));\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Binary Indexed Tree (BIT)\n// Verified: AOJ DSL_2_B: Range Sum Query (intのみ)\n\ntemplate <typename T>\nstruct BIT{\nprivate:\n    vector<T> array;\n    int n;\n\npublic:\n    // 初期化 (適当)\n    BIT() : array(11, 0), n(10) {}\n    BIT(int _n) : array(_n + 1, 0), n(_n) {}\n\n    // 他のクラスで BIT を呼び出すときに便利なので作った\n    void resize(int _n) {\n        array.resize(_n + 1);\n        n = _n;\n    }\n\n    // 1番目から i番目までの累積和を求める\n    T sum(int i) {\n        T s = 0;\n        while(i > 0) {\n            s += array[i];\n            i -= i & -i;      // LSB 減算\n        }\n        return s;\n    }\n\n    // [i, j] の要素の総和\n    T sum(int i, int j) {\n        T ret_i = sum(i-1);\n        T ret_j = sum(j);\n        return ret_j - ret_i;\n    }\n\n    // i 番目に 要素 x を追加\n    void add(int i, T x) {\n        while(i <= n) {\n            array[i] += x;\n            i += i & -i;      // LSB 加算\n        }\n    }\n};\n\nint dp[5010][2];\nsigned main() {\n    int N, A, B; cin >> N >> A >> B;\n    vector<int> p(N);\n    vector< pair<int, int> > info;\n\n    int midx = -1;\n    for(int i=0; i<N; i++) {\n        cin >> p[i];\n        if(p[i] == 1) midx = i;\n    }\n\n    vector<int> take(N, 1), mul(N, 1);\n    for(int i=1; i<N; i++) {\n        int cidx = (midx + i) % N;\n        int pidx = (cidx + N - 1) % N;\n        if(p[pidx] + 1 == p[cidx]) {\n            take[cidx] = false;\n            while(p[pidx] + 1 == p[cidx]) {\n                mul[pidx] = mul[cidx] + 1;\n                pidx = (pidx + N - 1) % N;\n                cidx = (cidx + N - 1) % N;\n            }\n        }\n    }\n\n    for(int i=0; i<N; i++) {\n        info.emplace_back(p[i], i+1);\n    }\n    sort(info.rbegin(), info.rend());\n\n    int ans = 0;\n    BIT<int> bit(N);\n    const int SHIFT_A = 1, SHIFT_B = 2, SHIFT_AB = 3;\n\n    fill(dp[0], dp[N+1], INF);\n    dp[0][0] = dp[0][1] = 0;\n    int M = info.size();\n    int pre_val = -1;\n    for(int i=0; i<M; i++) {\n        int val, idx; tie(val, idx) = info[i];\n        int sum = bit.sum(idx);\n        // 左、右\n        int costA = A*sum, costB = B;\n        \n        /*\n        int shift = -1;\n        if(costA < costB) shift = SHIFT_A;\n        else if(costA > costB) shift = SHIFT_B;\n        else shift = SHIFT_AB;\n\n        if((shift & pre_shift & SHIFT_B) == 0) {\n            ans += min(costA, costB);\n        }\n        */\n        bit.add(idx, 1);\n\n        // 左の場合は、転倒数？が同じ場合は節約できる (左シフトをまとめてやったと考える)\n        dp[i+1][0] = (pre_val == sum ? dp[i][0] : min(dp[i][0], dp[i][1]) + costA);\n        // 右の場合はいかなる場合に置いてもコストがかかる\n        dp[i+1][1] = min(dp[i][0], dp[i][1]) + costB;\n        // pre_shift = shift;\n        pre_val = sum;\n    }\n    ans = min(dp[N][0], dp[N][1]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <string.h>\n#include<queue>\nusing std::queue;\ntypedef long long LL;\ntypedef std::pair<int, LL> Pil;\n/*\ndp[i][j]表示1~i的处理为有序，并且i在j 花费\ndp[i+1]\n\n*/\n\n\n\nint pos[5005];\n\nint roll = 0;\nLL dp[2][5005];\n\nLL min(LL x,LL y){\n\treturn x < y ? x : y;\n}\nconst LL INF = 4557430888798830399;\nint main() {\n\t//freopen(\"in.txt\", \"r\", stdin);\n\tmemset(dp, 0x3f, sizeof dp);\n\tint n; scanf(\"%d\", &n);\n\tLL A, B;scanf(\"%lld %lld\", &A, &B);\n\tint x;\n\tfor (int i = 1; i <=n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tpos[x] = i;\n\t}\n\tdp[roll][0] = B;\n\tdp[roll][pos[1]] = 0;\n\n\tfor(int i=2;i<=n;i++){\n\t\tmemset(dp[roll ^ 1], 0x3f, sizeof dp[roll ^ 1]);\n\t\tfor(int j=0;j<=n;j++)if(dp[roll][j]<INF){\n\t\t\t\tif(pos[i]>j){\n\t\t\t\t\t//留在原地\n\t\t\t\t\tdp[roll ^ 1][pos[i]] = min(dp[roll][j], dp[roll ^ 1][pos[i]]);\n\t\t\t\t\t//左移到[j~j+1)的合适位置\n\t\t\t\t\tdp[roll ^ 1][j] = min(dp[roll][j]+B, dp[roll ^ 1][j]);\n\t\t\t\t}\n\t\t\t\telse\t\n\t\t\t\t\t//右移到[j~j+1)的合适位置\n\t\t\t\t\tdp[roll ^ 1][j] = min(dp[roll][j] + A, dp[roll ^ 1][j]);\t\t\n\t\t\t}\n\t\troll ^= 1;\n\t}\n\tLL ans = INF;\n\tfor (int i=1;i<=n;i++){\n\t\tans = min(ans, dp[roll][i]);\n\t}\n\tprintf(\"%lld\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define ll long long\nconst int Q=5005;\nll f[Q][Q];\nint ml[Q],mr[Q],p[Q];\nint main()\n{\n\tint n;\n\tll a,b;\n\tscanf(\"%d%lld%lld\",&n,&a,&b);\n\treturn 1;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=p[i];\n\t\tml[x]=998244353,mr[x]=-1;\n\t\tfor(int j=1;j<i;j++)\n\t\t\tif(p[j]>x)ml[x]=min(ml[x],p[j]);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(p[j]<x)mr[x]=max(mr[x],p[j]);\n\t}\n\tfor(int len=1;len<=n;len++)\n\t\tfor(int i=1;i+len-1<=n;i++){\n\t\t\tint j=i+len-1;\n\t\t\tif(i==j)f[i][j]=0;\n\t\t\telse f[i][j]=min(f[i][j-1]+(mr[j]<i?0:a),f[i+1][j]+(ml[i]>j?0:b));\n\t\t}\n\tprintf(\"%lld\\n\",f[1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//constexpr long long MOD = 1000000007;\nconstexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nll dp[5050][5050];\npii mael[5050][5050],maer[5050][5050];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    ll N,A,B; cin >> N >> A >> B;\n    vector<int> p(N);\n    rep(i,N) {\n        cin >> p[i];\n        --p[i];\n    }\n\n    rep(i,N) {\n        int l = p[i];\n        int r = 0;\n        int cnt = 1;\n        rep(j,i) {\n            if (p[j] > p[i]) {\n                mael[p[i]][N-1-p[j]].second = 1;\n            }\n        }\n        for (int j = i+1; j < N; j++) {\n            if (p[j] < p[i]) continue;\n            if (p[j] > l+1) {\n                for (int k = r; k < N-p[j]; k++) {\n                    mael[p[i]][k].first = cnt;\n                }\n                chmax(r,N-p[j]);\n            } else {\n                l++;\n                cnt++;\n            }\n        }\n        for (int k = r; k < N-l; k++) {\n            mael[p[i]][k].first = cnt;\n        }\n        for (int j = N-1-p[i]; j > 0; j--) {\n            mael[p[i]][j-1].second += mael[p[i]][j].second;\n        }\n    }\n\n    for (int i = N-1; i >= 0; i--) {\n        int r = p[i];\n        int l = 0;\n        int cnt = 1;\n        for (int j = N-1; j > i; j--) {\n            if (p[j] < p[i]) {\n                maer[p[j]][N-1-p[i]].second = 1;\n            }\n        }\n        for (int j = i-1; j >= 0; j--) {\n            if (p[j] > p[i]) continue;\n            if (p[j] < r-1) {\n                for (int k = l; k <= p[j]; k++) {\n                    maer[k][N-1-p[i]].first = cnt;\n                }\n                chmax(l,p[j]+1);\n            } else {\n                r--;\n                cnt++;\n            }\n        }\n\n        for (int k = l; k <= p[i]; k++) {\n            maer[k][N-1-p[i]].first = cnt;\n        }\n        for (int j = p[i]; j > 0; j--) {\n            maer[j-1][N-1-p[i]].second += maer[j][N-1-p[i]].second;\n        }\n\n    }\n\n    rep(i,N+1) rep(j,N+1) dp[i][j] = 1e18;\n    dp[0][0] = 0;\n    rep(k,N) {\n        for (int l = 0; l <= k; l++) {\n            if (dp[l][k-l]==1e18) continue;\n\n            auto [dl,cl] = mael[l][k-l];\n            chmin(dp[l+dl][k-l],dp[l][k-l]+A*cl);\n            chmin(dp[l+1][k-l],dp[l][k-l]+B);\n\n            auto[dr,cr] = maer[l][k-l];\n            chmin(dp[l][k-l+dr],dp[l][k-l]+B*cr);\n            chmin(dp[l][k-l+1],dp[l][k-l]+A);\n        }\n    }\n\n    ll ans = 1e18;\n    rep(i,N+1) {\n        chmin(ans,dp[i][N-i]);\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define MAX 5005\nusing namespace std;\n\nint n, a[MAX];\nll f[MAX], A, B;\n\nint main()\n{\n    cin >> n >> A >> B;\n    for(int i = 1; i <= n; i++){\n        scanf(\"%d\", &a[i]);\n    }\n    memset(f, 0x3f, sizeof(f));\n    f[0] = 0;\n    a[n+1] = n+1;\n    n++;\n    for(int i = 1; i <= n; i++){\n        ll s = 0;\n        for(int j = i-1; j >= 0; j--){\n            if(a[i] > a[j]){\n                f[i] = min(f[i], f[j]+s);\n                s += B;\n            }\n            else s += A;\n        }\n    }\n    cout << f[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sort stable_sort\n#define all(x) (x).begin(),(x).end()\n#define rep(i,x) for (int (i)=(1);(i)<=(x);(i)++)\n#define rep2(i,x) for (int (i)=(x);(i)>=(1);(i)--)\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\nusing namespace std;\nlong long n,A,b,f[5005],pos[5005],ans,a[5005],c[5005];\nint main(){\n\tans=0x7f7f7f7f7f7f7f7fll;\n\tcin>>n>>A>>b;\n\trep(i,n) f[i]=ans;\n\trep(i,n){\n\t\tcin>>a[i];\n\t\tpos[a[i]]=i;\n\t}\n\trep(i,n){\n\t\tc[i]=c[i-1]+(i<a[i]?A:b);\n\t}\n\trep(i,n){\n\t\tfor (int j=0;j<i;j++){\n\t\t\tif (a[j]<a[i]){\n\t\t\t\tf[i]=min(f[i],f[j]+c[i-1]-c[j]);\n\t\t\t}\n\t\t}\n\t\tans=min(ans,f[i]+c[n]-c[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main()\n{\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<ll> dp(n+2);\n    vector<int> p(n+2);\n    for(int i = 1; i <= n; i++)\n    {\n        cin >> p[i];\n    }\n    p[0] = 0;\n    p[n+1] = n+1;\n\n    for(int i = 1; i <= n+1; i++)\n    {\n        dp[i] = 1e14;\n        ll bigger = 0;\n        for(int j = i-1; j >= 0; j--)\n        {\n            if(p[i] > p[j])\n            {\n                dp[i] = min(dp[i], dp[j] + bigger * a + (i-j-1-bigger) * b);\n            }\n            else\n            {\n                bigger++;\n            }\n        }\n    }\n    cout << dp[n+1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#define N 5001\n#include<bitset>\n#include<deque>\n#include<cstdlib>\n#include<set>\n#include<ctime>\n#define ll long long\n#define mp make_pair\nusing namespace std;\nll read()\n{\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile(c>'9'||c<'0')\n\t{\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn f*x;\n}\nint n,pos[N],A,B;\nll dp[N][N];\nint main()\n{\n\tn=read(),A=read(),B=read();\n\tmemset(dp,20,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=read();\n\t\tpos[x]=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tll mn=dp[i-1][0];\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(pos[i]==j) dp[i][j]=mn;\n\t\t\tmn=min(mn,dp[i-1][j]);\n\t\t\tdp[i][j]=min(dp[i][j],mn+(j<pos[i]?B:A));\n\t\t}\n\t}\n\tll ans=1e18;\n\tfor(int i=1;i<=n;++i) ans=min(ans,dp[n][i]);\n\tcout<<ans<<'\\n';\n\treturn 0;\n }\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=5005;\nint n,A,B;\nint a[maxn];\nll dp[maxn][maxn];\nbool have[maxn];\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tREP(i,n)scanf(\"%d\",&a[i]);\n\tREP(i,n){\n\t\tint cnt=0;\n\t\tREP(j,n){\n\t\t\tif(j>a[i])cnt+=have[j];\n\t\t\tif(a[i]>j)dp[i][j]=dp[i-1][j];\n\t\t\telse{\n\t\t\t\tdp[i][j]=dp[i-1][j]+(cnt?B:0);\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][a[i]]+1LL*cnt*A);\n\t\t\t}\n\t\t}\n\t\thave[a[i]]=true;\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nint main(){\n    ll n,a,b;cin>>n>>a>>b;\n    vi v(n);\n    rep(i,n)cin>>v[i];\n    rep(i,n)v[i]--;\n    vi l(n,inf),r(n,-inf);\n    rep(i,n)REP(j,i+1,n)if(v[i]>v[j])chmin(l[j],v[i]);\n    rep(i,n)rep(j,i)if(v[i]<v[j])chmax(r[j],v[i]);\n    vvi dp(n+1,vi(n+1,inf));\n    dp[0][0]=0;\n    vi id(n);\n    rep(i,n)id[v[i]]=i;\n    rep(i,n+1){\n        rep(j,n+1){\n            if(i+j>=n)break;\n            if(i<n){\n                if(l[id[i]]<n-j)chmin(dp[i+1][j],dp[i][j]+b);\n                else chmin(dp[i+1][j],dp[i][j]);\n            }\n            if(j<n){\n                if(r[id[n-j-1]]>i)chmin(dp[i][j+1],dp[i][j]+a);\n                else chmin(dp[i][j+1],dp[i][j]);\n            }\n        }\n    }\n    ll ans=inf;\n    rep(i,n+1)chmin(ans,dp[i][n-i]);\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nlint dp[5010][5010];\nlint inf=123456789012345678LL;\nint p[5010];\nint main()\n{\n\tint n;lint a,b;\n\tcin>>n>>a>>b;\n\trep(i,n) cin>>p[i];\n\trep(i,5005) rep(j,5005) dp[i][j]=inf;dp[0][0]=0;\n\trep(i,n) rep(j,n+1){\n\t\tif(dp[i][j]>=inf) continue;\n\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\tif(p[i]>j){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+a);\n\t\t\tdp[i+1][p[i]]=min(dp[i+1][p[i]],dp[i][j]);\n\t\t}\n\t\telse if(p[i]<j){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n\t\t}\n\t\telse{\n\t\t\tassert(false);\n\t\t}\n\t}\n\tlint out=inf;\n\trep(i,n+1) out=min(out,dp[n][i]);\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nint n,a,b;\nint p[5001], f[10011], mn[10011], pos[5001];\n\nint32_t main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> n >> a >> b;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tcin >> p[i];\n\t\tpos[p[i]] = i*2;\n\t}\n\tmn[0] = 1e18;\n\tfor (int j=1;j<=n;j++)\n\t{\n    \tfor (int i=1;i<=2*n+1;i++)\n    \t{\n    \t\tint cost = 0;\n    \t\tif (i < pos[j]) cost = b;\n    \t\telse if (i > pos[j]) cost = a;\n    \t\tif (i%2 == 1)\n    \t\t\tf[i] = mn[i] + cost;\t\t\t\n    \t\telse\n    \t\t\tf[i] = mn[i-1] + cost;\n    \t}\n\t\tfor (int i=1;i<=2*n+1;i++)\n\t\t\tmn[i] = min(mn[i-1],f[i]);\n\t}\n\tcout << mn[2*n+1];\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 5002\nusing namespace std;\nlong long n,a,b,i,j,f[N],sl,ma,p[N];\nint main()\n{\n   // freopen(\"ntu.inp\",\"r\",stdin);\n   // freopen(\"ntu.out\",\"w\",stdout);\n    cin>>n>>a>>b;\n    for(i=1;i<=n;i++) cin>>p[i];\n    p[n+1]=n+1;\n    for(i=1;i<=n+1;i++)\n    {\n        ma=-1; sl=0; f[i]=round(1e18);\n        for(j=i-1;j>=0;j--)\n            if(p[j]>p[i]) sl++;\n            else\n            {\n                if(ma<p[j]) f[i]=min(f[i],f[j]+sl*a+(i-j-1-sl)*b);\n                ma=max(ma,p[j]);\n            }\n    }\n    cout<<f[n+1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long AA, BB;\nint t[5009];\nlong long dp[5009][5009]; //from i, limit j\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>AA>>BB;\n    for(int i=1; i<=n; i++)\n    {\n        cin>>t[i];\n    }\n    for(int i=n; i>=1; i--)\n    {\n        for(int lim=0; lim<=n; lim++)\n        {\n            if(t[i]<lim)\n            {\n                dp[i][lim]=dp[i+1][lim]+BB;\n            }\n            else\n            {\n                dp[i][lim]=min(dp[i+1][t[i]], dp[i+1][lim]+AA);\n            }\n        }\n    }\n    cout<<dp[1][0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\nusing namespace std;\ntypedef pair<int, int> PP;\ntypedef long long LL;\n#define pb push_back\n#define fr first\n#define sc second\n#define bitcnt __builtin_popcount\n#define all(x) x.begin(), x.end()\ninline LL ri() {LL x; scanf(\"%lld\", &x); return x;}\n#define rep2(i, n, ...) for (int i = 0; i < (n); i ++) \n#define rep3(i, a, b, ...) for (int i = (a); i < (b); i ++)\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define rep(...) GET_MACRO(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\n#define drep2(i, n, ...) for (int i = (n) - 1; i >= 0; i --)\n#define drep3(i, a, b) for (int i = (a) - 1; i >= (b); i --)\n#define drep(...) GET_MACRO(__VA_ARGS__, drep3, drep2)(__VA_ARGS__)\ntemplate<typename T>inline bool smax(T&a, T b){if(a<b){a=b;return true;}return false;} \ntemplate<typename T>inline bool smin(T&a, T b){if(a>b){a=b;return true;}return false;} \n/*}}}*/\n\nconst int maxn = 5005;\nconst LL inf = 1e18;\n\nLL p[maxn][maxn], a[maxn], n, A, B, d[maxn], b[maxn];\n\nint main() {\n  rep(i, maxn) rep(j, maxn) p[i][j] = inf;\n  cin >> n >> A >> B;\n  rep(i, n) cin >> a[i];\n\n  p[0][0] = 0;\n\n  d[0] = 0; b[0] = a[0];\n  rep(i, 1, n) {\n    int t = lower_bound(b, b + i, a[i]) - b;\n    d[i] = t;\n    drep(j, i, t) {\n      b[j + 1] = b[j]; \n    }\n    b[t] = a[i];\n  }\n  //cout << d[0] << d[1] << d[2];\n\n  rep(i, n) {\n    rep(j, i + 1) {\n      if (d[i] >= j) {\n        //smin(p[i + 1][j], p[i][j]);\n        //smin(p[i + 1][i + 1], p[i][j]);\n        smin(p[i + 1][d[i] + 1], p[i][j]);\n        smin(p[i + 1][j], p[i][j] + A);\n      }\n      else {\n        smin(p[i + 1][j + 1], p[i][j] + B);\n      }\n      //smin(p[i + 1][i + 1], p[i][j]);\n      if (j + 1 <= i) {\n        smin(p[i][j + 1], p[i][j]);\n      }\n    }\n  }\n\n  LL res = inf;\n  rep(i, n + 1) {\n    smin(res, p[n][i]);\n  }\n\n  //cout << p[1][0] << endl;\n\n  //cout << p[2][1] << endl;\n\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5005;\nconst long long INF = 1e18;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nll dp[MAXN][MAXN];\nint n, f, b, a[MAXN];\nint main() {\n\tread(n), read(f), read(b);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j <= n; j++)\n\t\tdp[i][j] = INF;\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = 0; j <= n; j++) {\n\t\tll tmp = dp[i - 1][j];\n\t\tif (tmp == INF) continue;\n\t\tif (a[i] > j) {\n\t\t\tchkmin(dp[i][j], tmp + f);\n\t\t\tchkmin(dp[i][a[i]], tmp);\n\t\t} else chkmin(dp[i][j], tmp + b);\n\t}\n\tll ans = INF;\n\tfor (int i = 0; i <= n; i++)\n\t\tchkmin(ans, dp[n][i]);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\tlong long A,B;\n\tcin>>n>>A>>B;\n\tvector<int>a(n+2);\n\ta[n+1]=n+1;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tvector<long long>dp(n+2);\n\tdp[0]=0;\n\tfor(int i=1;i<=n+1;i++){\n\t\tdp[i]=(long long) 1e18;\n\t\tint bigger=0;\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t\tif(a[j]>a[i])\n\t\t\t\tbigger++;\n\t\t\telse{\n\t\t\t\tdp[i]=min(dp[i],dp[j]+bigger*A+(i-1-j-bigger)*B);\n\t\t\t}\n\t}\n\tcout<<dp[n+1]<<endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define bp __builtin_popcountll\n#define pb push_back\n#define in(s) freopen(s, \"r\", stdin);\n#define out(s) freopen(s, \"w\", stdout);\n#define inout(s, end1, end2) freopen((string(s) + \".\" + end1).c_str(), \"r\", stdin),\\\n\t\tfreopen((string(s) + \".\" + end2).c_str(), \"w\", stdout);\n#define fi first\n#define se second\n#define bw(i, r, l) for (int i = r - 1; i >= l; i--)\n#define fw(i, l, r) for (int i = l; i < r; i++)\n#define fa(i, x) for (auto i: x)\nusing namespace std;\nconst int mod = 1e9 + 7, inf = 1061109567;\nconst long long infll = 4557430888798830399;\nconst int N = 5005;\nint n, a[N], dp[N][N], A, B;\nsigned main() {\n\t#ifdef BLU\n\tin(\"blu.inp\");\n\t#endif\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> A >> B;\n\tfw (i, 0, n) cin >> a[i], a[i]--;\n\tmemset(dp, 63, sizeof dp);\n\tdp[0][n] = 0;\n\tfw (i, 0, n) fw (j, 0, n + 1) if (dp[i][j] != infll) {\n\t\tif (j == n || j < a[i]) dp[i + 1][a[i]] = min(dp[i + 1][a[i]], dp[i][j]);\n\t\tif (i < a[i]) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + A);\n\t\telse if (i > a[i]) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + B);\n\t\t\n//\t\tcout << \"dp[\" << i << \"][\" << j + 1 << \"] = \" << dp[i][j] << \"\\n\";\n\t}\n\tint ans = infll;\n\tfw (j, 0, n + 1) ans = min(ans, dp[n][j]);\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define inf 9982443530000000\n#define maxn 5001\n#define int long long\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint n, A, B, a[maxn], b[maxn], pos[maxn], ans = inf, dp[maxn][maxn];\nsigned main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn = read(); A = read(); B = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read(), pos[a[i]] = i;\n\tmemset(dp, 0x3f3f3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < i; j++)\n\t\t{\n\t\t\tif(pos[i] > pos[j]) {\n\t\t\t\tdp[i][i] = min(dp[i - 1][j], dp[i][i]);\n\t\t\t\tdp[i][j] = dp[i - 1][j] + B;\n\t\t\t}\n\t\t\telse dp[i][j] = dp[i - 1][j] + A;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) ans = min(ans, dp[n][i]);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 5e3 + 10;\nconst long long max_val = 1LL << 62;\n\nlong long dp[maxn][maxn * 2], dp_min[maxn * 2];\nint p[maxn];\n\nlong long cost(int p1, int p2, int A, int B) {\n    if (p1 == p2) return 0;\n    else if (p1 > p2) return B;\n    else return A;\n}\n\nint main()\n{\n    int N, A, B, x;\n    cin >> N >> A >> B;\n    for (int i = 1; i <= N; i++) {\n        cin >> x;\n        p[x] = 2 * i - 1;\n    }\n    for (int i = 1; i <= N; i++) for (int j = 0; j <= 2 * N; j++) dp[i][j] = max_val;\n    //dp[i][j] = min{dp[i - 1][k] + (p[i] != k) * (A | B)}\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j <= 2 * N; j++) {\n            int tail = (j % 2 == 0 ? j : j - 1);\n            dp[i][j] = dp_min[tail] + cost(p[i], j, A, B);\n//            for (int k = 0; k < tail; k++) {\n//                //cout << j << ' ' << k << ' ' << dp[i - 1][k] << ' ' << cost(p[i], k, A, B) << endl;\n//                dp[i][j] = min(dp[i][j], dp[i - 1][k] + cost(p[i], j, A, B));\n//            }\n            //cout << i << ' ' << j << ' ' << dp[i][j] << endl;\n        }\n        dp_min[0] = dp[i][0];\n        for (int j = 1; j <= 2 * N; j++) dp_min[j] = min(dp_min[j - 1], dp[i][j]);\n    }\n//    long long res = max_val;\n//    for (int j = 0; j <= 2 * N; j++) res = min(res, dp[N][j]);\n//    cout << res << endl;\n    cout << dp_min[2 * N] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint n,A,B,a[5030];\nlong long f[5030][5030];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tmemset(f,0x3f,sizeof(f));\n\tfor(int i=1;i<=n;i++)\n\tscanf(\"%d\",&a[i]);\n\tf[0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(a[i]<a[j]) f[i][j]=min(f[i-1][j]+B,f[i][j]);\n\t\t\t\telse f[i][j]=min(f[i-1][j]+A,f[i][j]),f[i][i]=min(f[i][i],f[i-1][j]);\n\t\t\t}\n\tlong long ans=f[0][1];\n\tfor(int i=1;i<=n;i++) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst ll INF = 1e9, MOD = 1e9 + 7;\n\nll n, d[5000][5000], A, B;\n\nint main ()\n{\n\tcin >> n >> A >> B;\n\n\tfor (ll i = 1; i <= n; i++)\n\t{\n\t\tll a;\n\n\t\tscanf (\"%lld\", &a);\n\n\t\tfor (ll j = 0; j <= n; j++)\n\t\t{\n\t\t\tif (j < a) d[i][j] = d[i-1][j] + A;\n\t\t\telse if (j == a) d[i][j] = d[i-1][j];\n\t\t\telse d[i][j] = d[i-1][j] + B;\n\t\t\tif (j) d[i][j] = min (d[i][j], d[i][j-1]);\n\t\t}\n\t}\n\n\tcout << d[n][n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll maxn=5050;\nconst ll INF=1e15;\nll a[maxn][maxn],dp[maxn],p[maxn],n,A,B;\n\nint main(){\n    cin >> n >> A >> B;\n    for (int i=1;i<=n;i++) cin >> p[i];\n    p[++n]=n+1;\n    for (int i=0;i<=n;i++){\n        a[i][i]=0;\n        for (int j=i+1;j<=n;j++) a[i][j]=a[i][j-1]+(p[j]>p[i]?A:B);\n    }\n    for (int i=1;i<=n;i++){\n        dp[i]=INF;\n        for (int j=0;j<i;j++) if (p[j]<p[i]) dp[i]=min(dp[i],dp[j]+a[j][i-1]);\n    }\n    cout << dp[n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll A,B;\nint P[5050];\nll dp[5050][5050];\nint num[5050][5050];\n\nll hoge(int L,int R) {\n\tif(L==R) return 0;\n\tif(dp[L][R]>=0) return dp[L][R];\n\t\n\tint s=num[L][R];\n\tint t=num[R][L];\n\t\n\t\n\t\n\treturn dp[L][R]=min(min(B,s*A)+hoge(L+1,R),min(A,t*B)+hoge(L,R-1));\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A>>B;\n\tFOR(i,N) cin>>P[i+1];\n\tMINUS(dp);\n\t\n\tfor(x=1;x<=N;x++) {\n\t\tfor(y=1;y<x;y++) if(P[y]>P[x]) num[P[x]][P[y]]=1;\n\t\tfor(y=x+1;y<=N;y++) if(P[y]<P[x]) num[P[x]][P[y]]=1;\n\t}\n\tfor(x=1;x<=N;x++) {\n\t\tfor(y=x+2;y<=N;y++) num[x][y]+=num[x][y-1];\n\t\tfor(y=x-2;y>=1;y--) num[x][y]+=num[x][y+1];\n\t}\n\t\n\tcout<<hoge(1,N)<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n#define int long long\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nint A, B;\n\nsigned main() {\n\tscan n, A, B;\n\tvector<int> p(n);\n\tscan p;\n\tapply(p, x--);\n\tvector<int> at(n);\n\tf(i, n) {\n\t\tat[p[i]] = i;\n\t}\n\n\tvector<vector<int>> less(n, vector<int>(n + 1));\n\tfor (int i = 0; i < n; i++) {\n\t\tint offset = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (p[j] < p[i]) {\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\tless[i][n] = offset;\n\t\tfor (int j = n - 1; j > -1; j--) {\n\t\t\tless[i][j] = less[i][j + 1] + (at[j] < i);\n\t\t}\n\t}\n\n\tvector<vector<int>> greater(n, vector<int>(n + 1));\n\tfor (int i = 0; i < n; i++) {\n\t\tint offset = 0;\n\t\tfor (int j = n - 1; j > i; j--) {\n\t\t\tif (p[j] > p[i]) {\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\tgreater[i][0] = offset;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tgreater[i][j] = greater[i][j - 1] + (at[j - 1] > i);\n\t\t}\n\t}\n\n\n\tvector<vector<int>> dp(n + 2, vector<int>(n + 2, 1e18));\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\t{\n\t\t\t\tint w = B;\n\t\t\t\tif (at[i] == less[at[i]][n - j]) {\n\t\t\t\t\tw = 0;\n\t\t\t\t} else {\n\t\t\t\t\tw = min(w, (at[i] - less[at[i]][n - j]) * A);\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j] = min(dp[i][j] + w, dp[i + 1][j]);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint w = A;\n\t\t\t\tif (n - 1 - at[n - j - 1] == greater[at[n - j - 1]][i]) {\n\t\t\t\t\tw = 0;\n\t\t\t\t} else {\n\t\t\t\t\tw = min(w, ((n - 1 - at[n - j - 1]) - greater[at[n - j - 1]][i]) * B);\n\t\t\t\t}\n\t\t\t\tdp[i][j + 1] = min(dp[i][j] + w, dp[i][j + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tint final = 1e18;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfinal = min(final, dp[i][n - i]);\n\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ΔAGC032D\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 5005;\nconst LL inf = 1e17;\nint n,p[N];\nLL a,b,f[N];\nint main()\n{\n\tint i,j,o,x,y;\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\ta=x,b=y;\n\tfor(i=1;i<=n;i=i+1)\n\t\tscanf(\"%d\",p+i);\n\tp[0]=0,p[n+1]=n+1;\n\tf[0]=-inf;\n\tfor(i=1;i<=n+1;i=i+1){\n\t\to=-1;\n\t\tx=0,y=0;\n\t\tfor(j=i-1;j>=0;j=j-1){\n\t\t\tif(p[j]>p[i])\n\t\t\t\tx++;\n\t\t\telse{\n\t\t\t\tif(p[j]>o){\n\t\t\t\t\tf[i]=min(f[i],f[j]+a*x+b*y);\n\t\t\t\t\to=p[j];\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t\t//cout<<i<<f[i]+inf<<endl;\n\t}\n\tcout<<f[n+1]+inf;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline void chmin (long long& a, long long b) {\n  if (a > b) a = b;\n}\nint main() {\n  int n, a, b;\n  cin >> n >> a >> b;\n  vector<int> p(n + 2);\n  p[0] = 0;\n  p[n + 1] = n + 1;\n  for (int i = 1; i <= n; i++) {\n    cin >> p[i];\n  }\n  vector<long long> dp(n + 2, 1e18);\n  dp[0] = 0;\n  for (int i = 1; i <= n + 1; i++) {\n    long long tmp = 0;\n    for (int j = i - 1; j >= 0; j--) {\n      if (p[j] < p[i]) {\n        chmin(dp[i], dp[j] + tmp);\n        tmp += b;\n      } else {\n        tmp += a;\n      }\n    }\n  }\n  cout << dp[n + 1] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n, A, B, a[5050], b[5050];\nll f[5050][5050];\n\nvoid Umn(auto &x,auto y){\n    x=min(x,y);\n}\n\nint main(){\n    cin>>n>>A>>B;\n    for (int i=1;i<=n;++i){\n        cin>>a[i];\n        b[a[i]]=i;\n    }\n    memset(f,33,sizeof f);\n    f[0][0]=0;\n    for (int i=0;i<=n;++i)\n        for (int j=0;j<=n;++j){\n            if (i<n) Umn(f[i+1][j],f[i][j]+(a[i+1]>j? A: 0));\n            if (j<n) Umn(f[i][j+1],f[i][j]+(b[j+1]>i? B: 0));\n            if (i<n&&j<n&&a[i+1]==j+1) Umn(f[i+1][j+1],f[i][j]);\n        }\n    cout<<f[n][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 5050;\nint n,p[N],pos[N],a,b,mx[N][N];\nll f[N][N];\nint main() {\n\tread(n);read(a);read(b);rep(i,1,n)read(p[i]),pos[p[i]]=i;\n\trep(i,1,n)rep(j,i,n)mx[i][j]=max(mx[i][j-1],p[j]);\n\trep(i,0,n)rep(j,0,n)f[i][j]=1e16;\n\tf[0][0]=0;\n\trep(i,0,n-1)rep(j,0,n)if(f[i][j]<1e16){\n\t\tif(pos[i+1]<=j)umin(f[i+1][j],f[i][j]+a);\n\t\telse if(i+1==mx[j+1][pos[i+1]])umin(f[i+1][j],f[i][j]);\n\t\telse{\n\t\t\tumin(f[i+1][j],f[i][j]+b);\n\t\t\tumin(f[i+1][pos[i+1]],f[i][j]);\n\t\t}\n\t}\n\tll res=1e16;rep(i,0,n)umin(res,f[n][i]);\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\nint n, a, b, p[5010], pos[5010];\n\nint64 f[5010][5010];\n\nint c1[5010], c2[5010][5010];\n\nint c3[5010], c4[5010][5010];\n\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; ++i) cin >> p[i], pos[p[i]] = i;\n  for (int i = 0; i <= n + 1; ++i) {\n  \tfor (int j = 0; j <= n + 1; ++j) {\n  \t  f[i][j] = 1e18;\n\t}\n  }\n  for (int i = 1; i <= n; ++i) {\n  \tfor (int j = i + 1; j <= n; ++j) {\n  \t  if (p[i] > p[j]) {\n  \t  \t++c1[i];\n\t  }\n\t}\n\tfor (int j = 1; j < i; ++j) {\n\t  ++c2[i][p[j]];\n\t}\n\tfor (int j = n; ~j; --j) c2[i][j] += c2[i][j + 1];\n\tfor (int j = 1; j < i; ++j) {\n\t  if (p[i] < p[j]) {\n\t  \t++c3[i];\n\t  }\n\t}\n\tfor (int j = i + 1; j <= n; ++j) {\n\t  ++c4[i][p[j]];\n\t}\n\tfor (int j = 1; j <= n; ++j) c4[i][j] += c4[i][j - 1];\n  }\n  f[0][0] = 0;\n  int64 ans = 1e18;\n  for (int i = 0; i <= n; ++i) {\n  \tfor (int j = 0; j + i <= n; ++j) {\n  \t  if (!i && !j) {\n  \t  \tcontinue;\n\t  }\n\t  if (i) {\n\t  \tint X = c1[pos[i]]; //ÔÚËüÓÒ±ß±ÈËüÐ¡µÄÊýµÄ¸öÊý\n\t\tint Y = c2[pos[i]][n - j + 1]; //ÔÚËü×ó±ß´óÓÚµÈÓÚn-j+1µÄÊýµÄ¸öÊý \n\t  \tint c = pos[i] + X - Y;\n\t  \t//cerr << \"fir : \" << i << \", \" << j << \", \" << c << endl;\n\t  \tf[i][j] = min(f[i][j], f[i - 1][j] + (c != i) * b);\n\t  } \n\t  if (j) {\n\t  \tint X = c3[pos[n - j + 1]]; //ÔÚËü×ó±ß±ÈËü´óµÄÊýµÄ¸öÊý\n\t  \tint Y = c4[pos[n - j + 1]][i]; //ÔÚËüÓÒ±ßÐ¡ÓÚµÈÓÚiµÄÊýµÄ¸öÊý \n\t  \tint c = pos[n - j + 1] - X + Y;\n\t  \t//cerr << \"sec : \" << i << \", \" << j << \", \" << c << endl;\n\t  \tf[i][j] = min(f[i][j], f[i][j - 1] + (c != n - j + 1) * a);\n\t  }\n\t}\n  }\n  for (int i = 0; i <= n; ++i) {\n  \tans = min(ans, f[i][n - i]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=5005;\nll f[N],res,ret;int a[N],n,A,B;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\t++n,a[n]=n;\n\tfp(i,1,n){\n\t\tf[i]=1e18,ret=0;\n\t\tfd(j,i-1,0)a[j]<a[i]?(cmin(f[i],f[j]+ret),ret+=B):ret+=A;\n\t}\n\tprintf(\"%lld\\n\",f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=5010;\nconst int inf=0x3f3f3f3f;\nconst ll infmax=10000000000000000;\nll f[N][N];\nint s0[N][2],s1[N][2],a[N],b[N];\nint n; \nll A,B;\nll solve(int l,int r) {\n     if (f[l][r]!=-1) return f[l][r];\n     f[l][r]=infmax;\n     if (s0[b[l]][1]<=r) f[l][r]=min(f[l][r],B+solve(l+1,r)); else f[l][r]=min(f[l][r],solve(l+1,r));\n\t if (s1[b[r]][0]>=l) f[l][r]=min(f[l][r],A+solve(l,r-1)); else f[l][r]=min(f[l][r],solve(l,r-1)); \n\t return f[l][r]; \n}\nvoid init() {\n\tfor (int i=1;i<=n;i++) {\n\t\ts0[i][0]=0; s0[i][1]=inf;\n\t\tfor (int j=1;j<i;j++) \n\t\tif (a[j]<a[i]) s0[i][0]=max(s0[i][0],a[j]); else s0[i][1]=min(s0[i][1],a[j]);\n\t}\n\tfor (int i=n;i>=1;i--) {\n\t\ts1[i][0]=0; s1[i][1]=inf;\n\t\tfor (int j=i+1;j<=n;j++) \n\t\t if (a[j]<a[i]) s1[i][0]=max(s1[i][0],a[j]); else s1[i][1]=min(s1[i][1],a[j]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%lld%lld\",&A,&B);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]),b[a[i]]=i;\n\tmemset(f,255,sizeof(f));\n\tfor (int i=1;i<=n;i++) f[i][i]=0;\n\tinit();\n\tprintf(\"%lld\\n\",solve(1,n));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long N, A, B, X[5009], dp[5009];\n\nint main() {\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; i++) cin >> X[i];\n\tfor (int i = 1; i <= N + 1; i++) dp[i] = (1LL << 60);\n\n\tdp[1] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tvector<int>V;\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (X[j] >= i) V.push_back(X[j]);\n\t\t}\n\n\t\tint pos1 = -1;\n\t\tfor (int j = 0; j < V.size(); j++) { if (V[j] == i) pos1 = j; }\n\n\t\tfor (int j = pos1; j < V.size(); j++) {\n\t\t\tif (V[j] != i + (j - pos1)) break;\n\n\t\t\tlong long A1 = pos1, B1 = (j - pos1 + 1);\n\t\t\tdp[i + 1 + (j - pos1)] = min(dp[i + 1 + (j - pos1)], dp[i] + min(A1 * A, B1 * B));\n\t\t}\n\t}\n\tcout << dp[N + 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define maxn 5001\n#define inf 1000000000000000000\nll p[maxn], pos[maxn], dp[maxn][maxn];\nusing namespace std;\nint main()\n{\n    ll n, a, b, ans=inf;\n    cin>>n>>a>>b;\n    for(int i=1; i<=n; i++) cin>>p[i], pos[p[i]]=i;\n    memset(dp, 1000000, sizeof dp);\n    dp[0][0]=0;\n    for(int i=1; i<=n; i++){\n        for(int j=0; j<i; j++){\n            if(pos[i]>pos[j]){\n                dp[i][i]=min(dp[i-1][j], dp[i][i]);\n                dp[i][j]=dp[i-1][j]+b;\n            }\n            else dp[i][j]=dp[i-1][j]+a;\n        }\n    }\n    for(int i=1; i<=n; i++) ans=min(ans, dp[n][i]);\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005;\nint n,a,b,i,j,p[N],s[N][N],x,y;\nll f[N],ans;\nint ask(int a,int b,int c,int d){return s[b][d]-s[b][c-1]-s[a-1][d]+s[a-1][c-1];}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);ans=1ll*n*min(a,b);\n\tfor(i=1;i<=n;++i)for(scanf(\"%d\",p+i),memcpy(s[i]+1,s[i-1]+1,n<<2),j=p[i];j<=n;++j)++s[i][j];\n\tfor(i=1;i<=n;++i){\n\t\tx=ask(1,i-1,p[i]+1,n);f[i]=1ll*x*a+1ll*(i-1-x)*min(a,b);\n\t\tfor(j=1;j<i;++j)if(p[j]<p[i]){\n\t\t\tx=ask(j+1,i-1,1,p[j]-1);y=ask(j+1,i-1,p[i]+1,n);\n\t\t\tf[i]=min(f[i],1ll*x*b+1ll*y*a+1ll*(i-j-1-x-y)*min(a,b)+f[j]);\n\t\t}\n\t\tx=ask(i+1,n,1,p[i]-1);ans=min(ans,f[i]+1ll*x*b+1ll*(n-i-x)*min(a,b));\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int N=5022;\nLL dp[N][N];\nint n,a,b,x[N],pos[N];\nint mn[N][N],mx[N][N];\n\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]), pos[x[i]]=i;\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)dp[i][j]=1e18;\n    dp[0][0]=0;\n    for(int i=1;i<=n;i++){\n        LL mn=dp[i-1][0];\n        for(int j=0;j<=n+1;j++){\n            if(j==n+1)mn=min(mn,dp[i-1][j]);\n\n            if(j==pos[i]) dp[i][j]=mn;\n            else if(j<pos[i]) dp[i][j]=mn+b;\n            else dp[i][j]=mn+a;\n    \n            mn=min(mn,dp[i-1][j]);\n            //printf(\"dp[%d][%d]=%lld\\n\", i,j,dp[i][j]);\n        }\n    }\n    LL ans=1e18;\n    for(int i=0;i<=n+1;i++)ans=min(ans,dp[n][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\nconstexpr double EPS = 1e-10;\n//constexpr int INF = 1001001001;\nconstexpr ll INF = 1001001001001001001ll;\n\n\n\ntemplate< typename flow_t >\nstruct Dinic {\n    const flow_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        int rev;\n        bool isrev;\n        int idx;\n    };\n\n    vector< vector< edge > > graph;\n    vector< int > min_cost, iter;\n\n    Dinic(int V) : INF(numeric_limits< flow_t >::max()), graph(V) {}\n\n    void add_edge(int from, int to, flow_t cap, int idx = -1) {\n        graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false, idx});\n        graph[to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1, true, idx});\n    }\n\n    bool bfs(int s, int t) {\n        min_cost.assign(graph.size(), -1);\n        queue< int > que;\n        min_cost[s] = 0;\n        que.push(s);\n        while (!que.empty() && min_cost[t] == -1) {\n            int p = que.front();\n            que.pop();\n            for (auto &e : graph[p]) {\n                if (e.cap > 0 && min_cost[e.to] == -1) {\n                    min_cost[e.to] = min_cost[p] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return min_cost[t] != -1;\n    }\n\n    flow_t dfs(int idx, const int t, flow_t flow) {\n        if (idx == t) return flow;\n        for (int &i = iter[idx]; i < graph[idx].size(); i++) {\n            edge &e = graph[idx][i];\n            if (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n                flow_t d = dfs(e.to, t, min(flow, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    flow_t max_flow(int s, int t) {\n        flow_t flow = 0;\n        while (bfs(s, t)) {\n            iter.assign(graph.size(), 0);\n            flow_t f = 0;\n            while ((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n        return flow;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            for (auto &e : graph[i]) {\n                if (e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\n\n\nint main() {\n    int N; cin >> N;\n    ll A, B; cin >> A >> B;\n    vi p(N);\n    rep(i, N) {\n        cin >> p[i];\n        p[i]--;\n    }\n\n    Dinic<ll> di(N * 2 + 2);\n    int s = N * 2, t = s + 1;\n\n    rep(i, N) {\n        di.add_edge(s, i, A);\n        di.add_edge(i + N, t, B);\n    }\n    rep(i, N) {\n        for (int j = i + 1; j < N; j++) {\n            if (p[i] > p[j]) di.add_edge(p[i], p[j] + N, INF);\n        }\n    }\n\n    cout << di.max_flow(s, t) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<long long> dp(n + 1, 1e18);\n    dp[0] = 0;\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        dp[i + 1] = dp[0];\n        dp[0] += a;\n        for (int j = 0; j < i; ++j) {\n            if (p[j] < p[i]) dp[i + 1] = min(dp[i + 1], dp[j + 1]);\n            dp[j + 1] += p[j] < p[i] ? a : b;\n        }\n    }\n    long long ans = 1e18;\n    for (int i = 0; i <= n; ++i) ans = min(ans, dp[i]);\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n#define f first\n#define s second\n#define FOR(i,a,b) for (int i = a; i < b; ++i)\n#define RFOR(i, b, a) for (int i = b-1; i>=a; --i)\n#define FILL(a, b) memset(a, b, sizeof a)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)a.size()\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef pair<LL, LL> PLL;\n\nconst int INF = 1000 * 1000 * 1000;\nconst LL LINF = 1LL * INF*INF;\nconst int MAX = 100010;\nconst long double PI = acos(-1.);\nconst double EPS = 1e-6;\nLL mod = 1000LL*1000*1000 + 7;\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0); double startClock = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\tLL n,a,b;\n\tcin >> n >> a >> b;\n\tVI arr(n);\n\tFOR(i,0,n)\n\t\tcin >> arr[i];\n\tLL ans = 0;\n\tFOR(i,0,n)\n\t{\n\t\tFOR(j,i,n)\n\t\t{\n\t\t\tif(arr[j]==i+1)\n\t\t\t{\n\t\t\t\tint m = 0;\n\t\t\t\twhile(j+m<n && arr[j+m]==i+1+m)\n\t\t\t\t\tm++;\n\n\t\t\t\tans += min((j-i)*a,b*m);\n\t\t\t\tRFOR(z,j+m,i+m)\n\t\t\t\t{\n\t\t\t\t\tarr[z] = arr[z-m];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n\n\n\n\n\n\n\n\n\n\tcerr << endl << (clock() - startClock)/CLOCKS_PER_SEC << endl;return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// KALAM\n# include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5000 + 77;\nint n , X , Y;\nint a[N] , b[N] , F[N];\nlong long dp[N][N];\nint main() {\n   memset(dp , 63 , sizeof(dp));\n   for(int i = 0;i < N;++ i)\n      dp[0][i] = 0;\n   scanf(\"%d\" , & n);\n   scanf(\"%d %d\" , & X , & Y);\n   for(int i = 1;i <= n;++ i)\n      scanf(\"%d\" , a + i);\n   for(int i = 1;i <= n;++ i) {\n      dp[i][i] = 0;\n      for(int j = 1;j < i;++ j)\n         F[i] += (a[j] > a[i]);\n      b[i] = i;\n      for(int j = i;j > 1;-- j)\n         if(a[b[j]] < a[b[j - 1]])\n            swap(b[j] , b[j - 1]);\n      for(int j = 2;j <= i;++ j) {\n         int t = i - j + 1;\n         int pos = b[i - t + 1];\n         int leftmore = F[pos];\n         int rightmore = t - 1 - F[pos];\n         int rightless = i - pos - rightmore;\n         dp[i][t] = dp[pos - 1][leftmore + 1] + rightless * 1ll * Y;\n         if(rightless == 0)\n            dp[i][t] = min(dp[i][t] , dp[i][t + 1]);\n         else\n            dp[i][t] = min(dp[i][t] , dp[i][t + 1] + X);\n      }\n   }\n\n   printf(\"%lld\\n\" , dp[n][1]);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nll dp[5005][5005], p[5005][5005], n, a, b, loc[5005];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> a >> b;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> p[n-1][i];\n\t\tp[n-1][i]--;\n\t}\n\tloc[0] = 0;\n\tfor (int i = n-1; i >= 1; --i) {\n\t\tint ct = 0;\n\t\tfor (int j = 0; j < i+1; ++j) {\n\t\t\tif (p[i][j] != i) {\n\t\t\t\tp[i-1][ct] = p[i][j];\n\t\t\t\t++ct;\n\t\t\t} else\n\t\t\t\tloc[i] = j;\n\t\t}\n\t\t/* for (int j = 0; j < i; ++j)\n\t\t\tcout << p[i-1][j] << ' ';\n\t\tcout << endl; */\n\t}\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t//last j guys have free left moves\n\t\t\tif (i == 0) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i][j] = (1LL<<60);\n\t\t\tdp[i][j] = min(dp[i][j], a+dp[i-1][j]);\n\t\t\tif (loc[i] >= i+1-j)\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j-1]);\n\t\t\telse\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][i-loc[i]]+b*(i-j-loc[i]));\n\t\t}\n\tcout << dp[n-1][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=5003,M=N<<1,maxn=1e18;\n\nll f[N];\n\nll qz[N][N];\n\nint n,p[N];\nll A,B;\n\ninline ll min(ll a,ll b)\n{return a<b?a:b;}\ninline ll max(ll a,ll b)\n{return a>b?a:b;}\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfo(i,1,n)scanf(\"%d\",&p[i]);\n\t++n; p[n]=n;\n\tfo(i,1,n){\n\t\tqz[i][i]=0;\n\t\tfd(l,i-1,1)qz[i][l]=qz[i][l+1]+(p[l]>p[i]);\n\t}\n\tp[0]=0;\n\tfo(i,1,n)f[i]=maxn;\n\tfo(i,0,n){\n\t\tint gs=0;\n\t\tfo(l,i+1,n){\n\t\t\tif(gs+qz[l][i+1]==l-i-1&&p[l]>p[i])\n\t\t\tf[l]=min(f[l],f[i]+gs*B+qz[l][i+1]*A);\n\t\t\tgs=gs+(p[l]<p[i]);\n\t\t}\n\t}\n\tcout<<f[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nclass IntervalTree { // find min, add to range\n\tusing wgt = long long;\n\n\tstatic constexpr wgt no_val = (1LL<<60);\n\n\tstruct node {\n\t\twgt val, add;\n\t\tint l, r;\n\t};\n\n\tvector<node> T;\n\n\tvoid upd(int i) {\n\t\tnode & n = T[i];\n\t\tn.val += n.add;\n\t\tif(n.l+1 < n.r) {\n\t\t\tT[2*i].add += n.add;\n\t\t\tT[2*i+1].add += n.add;\n\t\t}\n\t\tn.add = 0;\n\t}\n\npublic:\n\tIntervalTree() {}\n\n\tIntervalTree(int N) {\n\t\tint b = 1;\n\t\twhile(b < N) b *= 2;\n\t\tT.reserve(2*b+1);\n\t\tT.resize(2, {no_val, 0, 0, b});\n\t\tfor(int i = 1; ; i++) {\n\t\t\tif(i == (int)T.size() || T[i].l+1 == T[i].r) break;\n\t\t\tT.push_back({no_val, 0, T[i].l, (T[i].l+T[i].r)/2});\n\t\t\tT.push_back({no_val, 0, (T[i].l+T[i].r)/2, T[i].r});\n\t\t}\n\t}\n\n\tvoid add(int l, int r, wgt w_add, int i = 1) {\n\t\tnode & n = T[i];\n\t\tif(n.l == l && n.r == r) {\n\t\t\tn.add += w_add;\n\t\t\tupd(i);\n\t\t\treturn;\n\t\t}\n\t\telse if(n.add) upd(i);\n\t\tif(n.l >= r || l >= n.r) return;\n\t\tint c = (n.l + n.r) / 2;\n\t\tif(n.l+1 < n.r) {\n\t\t\tadd(l, min(r, c), w_add, 2*i);\n\t\t\tadd(max(l, c), r, w_add, 2*i+1);\n\t\t\tn.val = min(T[2*i].val, T[2*i+1].val);\n\t\t}\n\t}\n\n\tvoid put(int pos, wgt w, int i = 1) {\n\t\tnode & n = T[i];\n\t\tif(n.l == pos && n.r == pos+1) {\n\t\t\tT[i].val = w;\n\t\t\tT[i].add = 0;\n\t\t\treturn;\n\t\t}\n\t\telse if(n.add) upd(i);\n\t\tif(n.l > pos || pos >= n.r) return;\n\t\tput(pos, w, 2*i);\n\t\tput(pos, w, 2*i+1);\n\t\tn.val = min(T[2*i].val, T[2*i+1].val);\n\t}\n\n\twgt get(int l, int r, int i = 1) { // max [l..r)\n\t\tnode & n = T[i];\n\t\tif(n.add) upd(i);\n\t\tif(n.l >= r || l >= n.r) return no_val;\n\t\tif(n.l == l && n.r == r) return n.val;\n\t\tn.val = min(T[2*i].val, T[2*i+1].val);\n\t\tint c = (n.l + n.r) / 2;\n\t\tauto best_lft = get(l, min(r, c), 2*i);\n\t\tauto best_rt = get(max(l, c), r, 2*i+1);\n\t\treturn min(best_lft, best_rt);\n\t}\n};\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcat A, B;\n\tcin >> N >> A >> B;\n\tvector<int> P(N);\n\tfor(int i = 0; i < N; i++) cin >> P[i];\n\tIntervalTree I(N+5);\n\tI.put(0, 0);\n\tfor(int i = 0; i < N; i++) {\n\t\tcat cost = I.get(0, P[i]);\n\t\tI.put(P[i], cost);\n\t\tI.add(0, P[i], A);\n\t\tI.add(P[i]+1, N+3, B);\n\t}\n\tcout << I.get(0, N+3) << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass DRotationSort {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, A, B; cin >> N >> A >> B;\n        vector<int> P(N); cin >> P;\n        for (int &p: P) --p;\n        vector<int> I(N);\n        for (int i = 0; i < N; ++i) I[P[i]] = i;\n//\n//        vector2<int> F(N, N+1, 0); // F[i][j] => i is right of j\n//        for (int i = 0; i < N; ++i) {\n//            for (int j = 0; j < N; ++j) {\n//                if (I[i] > I[j]) {\n//                    F[i][j+1] = 1;\n//                }\n//            }\n//            for (int j = 0; j < N; ++j) {\n//                F[i][j+1] += F[i][j];\n//            }\n//        }\n\n        vector2<ll> D(N+1, N+1, 1e18);\n        D[0][0] = 0;\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (I[j] < i) {\n                    // it is already on the left\n                    D[i][j+1] = min(D[i][j+1], D[i][j]);\n                } else if (P[i] == j) {\n                    // it's here, that's cheap\n                    D[i+1][j+1] = min(D[i+1][j+1], D[i][j]);\n                } else if (P[i] > j) {\n                    D[i][j+1] = min(D[i][j+1], D[i][j] + B);\n                    D[i+1][j] = min(D[i+1][j], D[i][j] + A);\n                } else {\n                    D[i+1][j] = min(D[i+1][j], D[i][j]);\n                }\n            }\n        }\n\n\n        ll ans = 1e18;\n        for (int i = 0; i <= N; ++i) {\n            ans = min(ans, D[i][N]);\n            ans = min(ans, D[N][i]);\n        }\n        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDRotationSort solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 5e3 + 5;\nconst int maxm = 1e7 + 5;\n\nconst int mod = 1e9 + 7;\nint n , A , B;\nint pos[maxn] , a[maxn];\nint m = 0;\nll f[maxn][maxn];\nint Lef[maxn][maxn] , Rig[maxn][maxn];\n\nll Solve(int l , int r){\n    if(l == r)return 0;\n    ll & res = f[l][r];\n    if(res != -1)return res;\n    res = 1e18;\n    if(Lef[l + 1][r] > pos[l])res = min(res,Solve(l+1,r));\n    else res = min(res,Solve(l+1,r)+B);\n    if(Rig[l][r - 1] < pos[r])res = min(res,Solve(l,r-1));\n    else res = min(res,Solve(l,r-1)+A);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\"))\n        freopen(taskname\".INP\",\"r\",stdin),\n        freopen(taskname\".OUT\",\"w\",stdout);\n    cin >> n >> A >> B;\n    for(int i = 1 ; i <= n ; ++i){\n        cin >> a[i];\n        pos[a[i]] = i;\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        Lef[i][i - 1] = 1e9;\n        for(int j = i ; j <= n ; ++j){\n            Lef[i][j] = min(Lef[i][j - 1], pos[j]);\n            Rig[i][j] = max(Rig[i][j - 1] , pos[j]);\n        }\n    }\n    memset(f,-1,sizeof f);\n    cout << Solve(1,n) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll A,B;\nint n;\nconst int N=5010;\nint a[N],pos[N];\nll f[N][N];\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tpos[a[i]]=i;\n\t}\n\tfor(int i=0;i<=n;i++)f[0][i]=B*i;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif(j) f[i][j]=min(f[i][j],f[i][j-1]+(pos[j]>i ? B:A) );\n\t\t\tif(j&&pos[j]==i) f[i][j]=min(f[i][j],f[i-1][j-1]);\n//\t\t\tcout<<i<<\" \"<<j<<\" :: \"<<f[i][j]<<endl;\n\t\t}\n\t}\n\tcout<<f[n][n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N; long long A, B;\n\nint p[5005];\nint rev[5005];\n\n// Second indx:\n/*\n1: (-inf, 1]\n2: (1, 2]\n3: (2, 3]\n4: (3, 4] and so on.\nN+1: (N, N+1]\n*/\nlong long memo[5005][5005];\n\n// Sort from 1 to i inclusive\n// The element i+1 is in k\nlong long dp(int i, int k){\n    if(i == 0){\n        return 0;\n    }else if(memo[i][k] != -1){\n        return memo[i][k];\n    }else{\n        // shift left\n        long long ans = 1LL << 61;\n\n        for(int j = 1; j <= k; j ++){\n            if(j < rev[i]){\n                ans = min(ans, B + dp(i-1, j));\n            }else if(j == rev[i]){\n                ans = min(ans, B*(j==k) + dp(i-1, j));\n            }else{\n                ans = min(ans, A + dp(i-1, j));\n            }\n        }\n\n        //printf(\"dp(%d, %d)=%lld\\n\", i, k, ans);\n        return memo[i][k] = ans;\n    }\n}\n\nint main(){\n    scanf(\"%d%lld%lld\", &N, &A, &B);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &p[i]);\n        rev[p[i]] = i;\n    }\n\n    memset(memo, -1, sizeof(memo));\n    long long ans = 1LL << 62;\n    ans = dp(N, N+1);\n    printf(\"%lld\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5005;\nlong long s[N],p[N],f[N];\nint n,A,B;\nint main(){\n    //freopen(\"1.out\",\"w\",stdout);\n    //freopen(\"1.in\",\"r\",stdin);\n    memset(f,23,sizeof(f));\n    scanf(\"%d%d%d\",&n,&A,&B),f[0]=0;\n    for(int i=1,x;i<=n;i++){\n        scanf(\"%d\",&x);\n        for(int j=0;j<=n;j++)\n            if(j)   p[j]=min(p[j-1],f[j]);\n            else    p[j]=f[j];\n        for(int j=0;j<=x;j++)   f[j]+=A;\n        for(int j=x+1;j<=n;j++) f[j]+=B;\n        f[x]=min(f[x],p[x]);\n    }\n    long long ans=f[n+1];\n    for(int i=0;i<=n;i++)   ans=min(ans,f[i]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<int> p(n), pos(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        p[i]--;\n        pos[p[i]] = 2 * i;\n    }\n    constexpr int64_t kInf = 1'000'000'000'000'000'000;\n    vector<vector<int64_t>> dp(n, vector<int64_t>(n + n, kInf));\n    for (int i = 0; i < n + n; ++i) {\n        if (i < pos[0]) dp[0][i] = b;\n        else if (i == pos[0]) dp[0][i] = 0;\n        else dp[0][i] = a;\n    }\n    for (int i = 1; i < n; ++i) {\n        int64_t prv = kInf;\n        for (int j = 0; j < n + n; ++j) {\n            prv = min(prv, dp[i - 1][j]);\n            if (j % 2 == 0 && j != pos[i]) continue;\n            int cost = j == pos[i] ? 0 : j < pos[i] ? b : a;\n            dp[i][j] = prv + cost;\n        }\n    }\n    cout << *min_element(dp[n - 1].begin(), dp[n - 1].end()) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst int sz = 5005;\nll dp[sz][sz];\nbool used[sz];\n\nint main(){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\n\tll n, a, b;cin >> n >> a >> b;\n\tvector<ll> v(n);\n\tREP(i, n)cin >> v[i],v[i]--;\n\n\tREP(i, sz)REP(j, sz)dp[i][j] = LLINF;\n\tdp[0][0] = 0;\n\n\tREP(i, n+1){\n\t\tif(i > 0)used[v[i-1]] = true;\n\t\tREP(j, n+1){\n\t\t\tif(used[j])dp[i][j+1] = min(dp[i][j+1], dp[i][j]);\n\t\t\telse dp[i][j+1] = min(dp[i][j+1], dp[i][j] + b);\n\t\t\tif(v[i] == j)dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j]);\n\t\t\tif(v[i] < j)dp[i+1][j] = min(dp[i+1][j], dp[i][j]);\n\t\t\telse dp[i+1][j] = min(dp[i+1][j], dp[i][j] + a);\n\t\t}\n\t}\n\n\tcout << dp[n][n] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=5005;\nll a[N],dp[N][N];\ninline void cmn(ll&a,ll b){if(a>b)a=b;}\nint main()\n{\n\tll n,A,B,ans=1ll<<60;scanf(\"%lld%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tmemset(dp,0x3f,sizeof(dp));dp[0][0]=0;\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=n;j++)if(a[i]>j)cmn(dp[i][j],dp[i-1][j]+A),cmn(dp[i][a[i]],dp[i-1][j]);else cmn(dp[i][j],dp[i-1][j]+B);\n\tfor(int i=0;i<=n;i++)cmn(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 5005;\ntypedef long long ll;\n\nint n, A, B, i, j, p;\nint smaller[Nmax], a[Nmax];\n\nint main()\n{\n//    freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    cin >> n >> B >> A;\n    for(i=1; i<=n; ++i) cin >> a[i];\n\n    vector<ll> dp(n+2), new_dp(n+2);\n\n    for(i=1; i<=n; ++i)\n    {\n        for(p=1; p<=n; ++p)\n            if(a[p] == i) break;\n\n        for(j=p; j<=n; ++j)\n            smaller[j]++;\n\n        for(j=1; j<p; ++j) new_dp[j] = dp[j];\n\n        for(j=p; j<=n; ++j)\n            new_dp[j] = min(dp[p-1] + (ll) A * (smaller[j] - smaller[p]), dp[j] + B);\n\n        swap(dp, new_dp);\n    }\n\n    cout << dp[n] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define nmax 5005\nusing std::cin;\nusing std::cout;\nlong long min(long long x, long long y)\n{\n    return (y < x) ? y : x;\n}\nint n, mx[nmax+1], mn[nmax+1], p[nmax+1];\nlong long dp[nmax+2][nmax+2], a, b;\nint main()\n{\n    std::ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> a >> b;\n    for(int i = 1; i <= n; ++i)\n      cin >> p[i];\n    for(int i = 1; i <= n; ++i){\n      mn[p[i]] = n + 1;\n      for(int j = 1; j < i; ++j)\n        if(p[j] > p[i] && mn[p[i]] > p[j]) mn[p[i]] = p[j];\n    }\n    for(int i = n; i >= 1; --i){\n      mx[p[i]] = 0;\n      for(int j = n; j > i; --j)\n        if(p[j] < p[i] && mx[p[i]] < p[j]) mx[p[i]] = p[j];\n    }\n    dp[0][n + 1] = 0;\n    for(int j = n; j > 0; --j)\n      dp[0][j] = (mx[j] == 0) ? dp[0][j + 1] : dp[0][j + 1] + a;\n    for(int i = 1; i <= n; ++i){\n      dp[i][n + 1] = (mn[i] == n + 1) ? dp[i - 1][n + 1] : dp[i - 1][n + 1] + b;\n      for(int j = n; j > i; --j){\n        dp[i][j] = (mn[i] >= j) ? dp[i - 1][j] : dp[i - 1][j] + b;\n        dp[i][j] = min(dp[i][j], ((mx[j] <= i) ? dp[i][j + 1] : dp[i][j + 1] + a));\n      }\n    }\n    long long ans = dp[0][1];\n    for(int i = 0; i <= n; ++i)\n      ans = min(ans, dp[i][i + 1]);\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"-O3\")\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<set>\n#include<cmath>\n#include<vector>\n#include<bitset>\n#define DB long double\n#define LL long long\n#define ui unsigned int\n#define ull unsigned long long\nusing namespace std;\n  \ninline int read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid Out(int x){\n    if(x>9) Out(x/10);\n    putchar('0'+x%10);\n}\nint gcd(int x,int y){\n    if(!y) return x;\n    return gcd(y,x%y);\n}\nLL qpow(LL x,LL y,LL P){\n    LL re=1;\n    while(y){\n        if(y&1) re=re*x%P;\n        x=x*x%P;y>>=1;\n    }\n    return re;\n}\nconst DB eps=1e-8;\nconst LL P=10000019;\nconst DB PI=acos(-1);\nconst LL inf=1e16;\nconst int N=1e5+10;\nint n,m;\nLL A,B;\nint p[5050],a[5050];\nint b[5050][5050];\nbool vis[5050][5050];\nLL f[5050][5050];\nLL F(int l,int r){\n\tif(l>=r) return 0;\n\tif(vis[l][r]) return f[l][r];\n\telse vis[l][r]=1;\n\tf[l][r]=inf;\n\tLL tt=0,x=a[l];\n\ttt=b[x][r]-b[x][l];\n\tf[l][r]=min(f[l][r],F(l+1,r)+min(B,tt*A));\n\tx=a[r];\n\ttt=(b[n][r-1]-b[x-1][r-1])-(b[n][l-1]-b[x-1][l-1]);\n\tf[l][r]=min(f[l][r],F(l,r-1)+min(B*tt,A));\n\treturn f[l][r];\n}\nint main(){\n\tcin>>n>>A>>B;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&p[i]);\n\t\ta[p[i]]=i;\n\t\tfor(int j=1;j<=n;++j) b[i][j]=b[i-1][j];\n\t\t++b[i][p[i]];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j) b[i][j]+=b[i][j-1];\n\t}\n\tcout<<F(1,n)<<endl;\n}\n/*\n5 4 4 1\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\nconst LL N = 1000000007;\n\nLL n,l,r;\nLL a[5005],dp[5005];\n\nstruct BIT{\n\tLL tr[100005];\n\tLL lowbit(LL x){ return (x & (-(x))); }\n\tvoid modify(LL x,LL v){ for(;x <= n + 2;x += lowbit(x)); tr[x] += v; }\n\tLL query(LL x){ LL ret = 0; for(;x;x -= lowbit(x)) ret += tr[x]; return ret; }\n}t;\n\nint main(){\n\tmemset(dp,0x3f,sizeof(dp));\n\tcin >> n >> r >> l;\n\tfor(LL i = 1;i <= n;i ++){\n\t\tcin >> a[i];\n\t\ta[i] ++;\n\t}\n\ta[0] = 1; dp[0] = 0; a[n + 1] = n + 2;\n\tfor(LL i = 1;i <= n + 1;i ++){\n\t\tLL sr = 0,sl = 0;\n//\t\tdp[i] = dp[i - 1] + l;\n\t\tfor(LL j = i - 1;j >= 0;j --){\n\t\t\tif(a[j] < a[i]) dp[i] = min(dp[i],dp[j] + r * sr + l * sl);\n\t\t\tif(a[j] > a[i]) sr ++; if(a[j] < a[i]) sl ++;\n\t\t\tt.modify(a[j],1);\n//\t\t\tcout << i << ' ' << j << ' ' << sr << ' ' << dp[i] << endl;\n\t\t}\n\t\tfor(LL j = i - 1;j >= 0;j --) t.modify(a[j],-1);\n\t}\n\tcout << dp[n + 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 5005\n#define INF 10000000000000LL\nusing namespace std;\nint n,A,B,p[N],pos[N],l[N][N],r[N][N];\nlong long f[N][N];\n\nvoid print(int i,int j){\n    printf(\"f[%d][%d]=\",i,j),cout<<f[i][j]<<endl;\n}\n\nint main(){\n    scanf(\"%d%d%d\",&n,&A,&B);\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",&p[i]);\n        pos[p[i]]=i;\n    }\n    for(int i=1;i<=n;++i){\n        for(int j=n;j;--j)l[i][j]=l[i][j+1]+(pos[j]<pos[i]);\n        for(int j=1;j<=n;++j)r[i][j]=r[i][j-1]+(pos[j]<pos[i]);\n    }\n    for(int i=0;i<=n;++i)\n        for(int j=n+1;j;--j)f[i][j]=INF;\n    f[0][n+1]=0;\n    for(int i=0;i<n;++i)\n        for(int j=n+1;j>i+1;--j){\n            //printf(\"f[%d][%d]=\",i,j),cout<<f[i][j]<<endl;\n            int k=pos[i+1]-l[i+1][j]-r[i+1][i];\n            f[i+1][j]=min(f[i+1][j],f[i][j]+(k>1 ? (k>2 ? B:min(A,B)):0));\n            //if(i==2 && j==9)printf(\"k=%d f[%d][%d]=\",k,i+1,j),cout<<f[i+1][j]<<endl;\n            k=pos[j-1]-l[j-1][j]-r[j-1][i];\n            f[i][j-1]=min(f[i][j-1],f[i][j]+(k<j-i-1 ? (k<j-i-2 ? A:min(A,B)):0));\n            //if(i==2 && j==9)printf(\"k=%d f[%d][%d]=\",k,i,j-1),cout<<f[i][j-1]<<endl;\n        }\n    /*print(1,10);\n    print(2,10);\n    print(2,9);\n    print(2,8);\n    print(2,7);\n    print(2,6);\n    print(2,5);\n    print(2,4);\n    print(2,3);*/\n    long long ans=INF;\n    for(int i=0;i<=n;++i)ans=min(ans,f[i][i+1]);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 10000000000000;\n\tvector<long long> P, DP;\n\tcin >> N >> A >> B;\n\tP.resize(N);\n\tDP.assign(N + 1, INF);\n\tDP[0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (DP[j] >= INF || j == P[i]) continue;\n\t\t\tif (j < P[i]) {\n\t\t\t\tDP[P[i]] = min(DP[P[i]], DP[j]);\n\t\t\t\tDP[j] += A;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDP[j] += B;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tcout << DP[j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSR(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nll A,B;\nint p[5005];\nvector<P>vec;\nint main(){\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t}\n\tint cur = -1;\n\tint pre = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i == 1){\n\t\t\tcur = p[i];\n\t\t}\n\t\telse if(cur+1 != p[i]){\n\t\t\tvec.pb(mp(pre+1,i-1));\n\t\t\tpre = i-1;\n\t\t\tcur = p[i];\n\t\t}\n\t\telse cur++;\n\t}\n\tvec.pb(mp(pre+1,n));\n\tll ans = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = vec[i].sc-vec[i].fi+1;\n\t\tll R = 0;\n\t\tfor(int j=i+1;j<vec.size();j++){\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] > p[y]){\n\t\t\t\t//need to swap\n\t\t\t\tR += (vec[j].sc-vec[j].fi+1);\n\t\t\t}\n\t\t}\n\t\tans += min(L*A,R*B);\n\t}\n\tll ans2 = 0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//vec[i]はどこにあるべきか\n\t\tll L = 0;\n\t\tll R = vec[i].sc-vec[i].fi+1;\n\t\tfor(int j=i-1;j>=0;j--){\n\t\t\tint x = vec[i].fi;\n\t\t\tint y = vec[j].fi;\n\t\t\tif(p[x] < p[y]){\n\t\t\t\t//need to swap\n\t\t\t\tL += (vec[j].sc-vec[j].fi+1);\n\t\t\t}\n\t\t}\n\t\tans2 += min(L*A,R*B);\n\t}\n\tcout << min(ans,ans2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSR(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,p[5005];\nll dp[5005][5005],A,B;\n\nint main(){\n\tcin>>n>>A>>B;\n\tfor(int i=1;i<=n;i++) cin>>p[i];\n\trep(i,5005)rep(j,5005) dp[i][j] = 1e18;\n\tdp[0][0] = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(dp[i-1][j] > 1e17) continue;\n\t\t\tif(p[j] < p[i]){\n\t\t\t\tdp[i][i] = min(dp[i-1][j],dp[i][i]);\n\t\t\t}\n\t\t\tif(p[j] < p[i]){\n\t\t\t\tdp[i][j] = min(dp[i-1][j]+A,dp[i][j]);\n\t\t\t}\n\t\t\tif(p[j] > p[i]){\n\t\t\t\tdp[i][j] = min(dp[i-1][j]+B,dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1e18;\n\tfor(int i=0;i<5005;i++) ans = min(ans,dp[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    long long A, B;\n    cin>>A>>B;\n\n    vector<int> p(N);\n    for (int &t: p)\n    {\n        cin>>t;\n        t--;\n    }\n\n    vector<int> R(N);\n    for (int i=0; i<N; i++)\n        R[p[i]] = i;\n\n    vector<long long> T(2*N+1);\n    for (int i=0; i<N; i++)\n    {\n        vector<long long> P = T;\n        T = vector<long long>(2*N+1);\n        for (int j=1; j<2*N+1; j++)\n            P[j] = min(P[j], P[j-1]);\n        for (int j=0; j<2*N+1; j++)\n        {\n            long long c;\n            if (j<R[i]*2+1)\n                c = B;\n            else if (j>R[i]*2+1)\n                c = A;\n            else\n                c = 0;\n            T[j] = P[j/2*2]+c;\n        }\n    }\n\n    cout<<*min_element(T.begin(), T.end())<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 5010;\ntypedef long long LL;\nint A[MAXN], va, vb, n;\nLL dp[MAXN][MAXN];\nvoid getmin(LL & x, const LL y) { x > y ? x = y : 0; }\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> va >> vb;\n\tfor (int i = 1; i <= n; ++i) std::cin >> A[i];\n\tmemset(dp, 0x3f, sizeof dp);\n\t**dp = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tif (j > A[i]) {\n\t\t\t\tgetmin(dp[i][j], dp[i - 1][j] + vb);\n\t\t\t} else {\n\t\t\t\tgetmin(dp[i][A[i]], dp[i - 1][j]);\n\t\t\t\tgetmin(dp[i][j], dp[i - 1][j] + va);\n\t\t\t}\n\t\t}\n\t}\n\tstd::cout << *std::min_element(dp[n], dp[n] + n + 1) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,A,B;\nLL ans;\nconst int N=5010;\nLL f[N],p[N];\nint main()\n{\n\tcin>>n>>A>>B;memset(f,0x3f,sizeof(f));ans=f[0];f[0]=0;\n\tfor(int i=1,x;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tfor(int j=0;j<=n;++j)\n\t\t\tif(!j)p[j]=f[j];\n\t\t\telse p[j]=min(p[j-1],f[j]);\n\t\tfor(int j=0;j<=x;++j)f[j]+=A;\n\t\tfor(int j=x+1;j<=n;++j)f[j]+=B;\n\t\tf[x]=min(f[x],p[x]);\n\t}\n\tfor(int i=0;i<=n;++i)ans=min(ans,f[i]);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nconst double EPS = 1e-10;\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\n\n#define MAX_N (1<<17)\n\nstruct segtree{\n    int n, dat[2*MAX_N-1]; //(1<<17) = 130000\n\n    void init(int n_){\n        n = 1;\n        while(n < n_) n *= 2;\n        for(int i = 0; i < 2*n-1; i++) dat[i] = 0;\n    }\n\n    void update(int k, int a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = dat[k*2+1]+dat[k*2+2];\n        }\n    }\n\n    //(a,b,0,0,seg.n)で呼ぶ\n    int query(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            int vl = query(a,b,k*2+1,l,(l+r)/2);\n            int vr = query(a,b,k*2+2,(l+r)/2,r);\n            return vl+vr;\n        }\n    }\n} seg;\n\nint n;\nll dp[5000][5000];\nll A, B;\nint p[5000];\nint r[5000], l[5000];\n\nint main() {\n    cin >> n;\n    cin >> A >> B;\n    rep(i,n) cin >> p[i];\n    rep(i,n) p[i]--;\n    rep(i,n) {\n        l[p[i]] = INF;\n        rep(j,i) {\n            if (p[j] > p[i] && p[j] < l[p[i]]) {\n                l[p[i]] = p[j];\n            }\n        }\n    }\n    if (n == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    rep(i,n) {\n        r[p[i]] = -1;\n        for (int j = i+1; j < n; j++) {\n            if (p[j] < p[i] && p[j] > r[p[i]]) {\n                r[p[i]] = p[j];\n            }\n        }\n    }\n    /*\n    for (int i = 0; i < n; i++) {\n        cout << r[i] << \" \" << l[i] << endl;\n    }\n    */\n    rep(i,n+1) rep(j,n+1) dp[i][j] = MOD*MOD;\n    ll ans = MOD*MOD;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            //dp[i][j] -> dp[i+1][j], dp[i][j+1]\n            if (l[i] >= n-j) dp[i+1][j] = min(dp[i+1][j], dp[i][j]);\n            else dp[i+1][j] = min(dp[i+1][j], dp[i][j]+B);\n            if (r[n-1-j] < i) dp[i][j+1] = min(dp[i][j+1], dp[i][j]);\n            else dp[i][j+1] = min(dp[i][j+1], dp[i][j]+A);\n            if (i+j == n-1) {\n                ans = min(ans, dp[i+1][j]);\n                ans = min(ans, dp[i][j+1]);\n            }\n        }\n    }\n    /*\n    rep(i,n) {\n        rep(j,n) {\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 5e3 + 5;\nconst int maxm = 1e7 + 5;\n\nconst int mod = 1e9 + 7;\nint n , A , B;\nint pos[maxn] , a[maxn];\nint m = 0;\nll f[maxn][maxn];\nint Lef[maxn][maxn] , Rig[maxn][maxn];\n\nll Solve(int l , int r){\n    if(l == r)return 0;\n    ll & res = f[l][r];\n    if(res != -1)return res;\n    res = 1e18;\n    if(Lef[l + 1][r] > pos[l])res = min(res,Solve(l+1,r));\n    else res = min(res,Solve(l+1,r)+B);\n    if(Rig[l][r - 1] < pos[r])res = min(res,Solve(l,r-1));\n    else res = min(res,Solve(l,r-1)+A);\n    return res;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\"))\n        freopen(taskname\".INP\",\"r\",stdin),\n        freopen(taskname\".OUT\",\"w\",stdout);\n    cin >> n >> A >> B;\n    for(int i = 1 ; i <= n ; ++i){\n        cin >> a[i];\n        pos[a[i]] = i;\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        Lef[i][i - 1] = 1e9;\n        for(int j = i ; j <= n ; ++j){\n            Lef[i][j] = min(Lef[i][j - 1], pos[j]);\n            Rig[i][j] = max(Rig[i][j - 1] , pos[j]);\n        }\n    }\n    memset(f,-1,sizeof f);\n    cout << Solve(1,n) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int64_t& a, int64_t b){\n    a = min(a, b);\n}\n\nint main(){\n    int N;\n    int64_t A, B;\n    cin >> N >> A >> B;\n    int pos[5001];\n    for(int i=0; i<N; i++){\n        int p;\n        cin >> p;\n        pos[p-1] = 2*i+1;\n    }\n\n    const int64_t INF = 1e18;\n    static int64_t dp[5001][10001];\n    for(int i=1; i<=N; i++) for(int j=0; j<=2*N; j++) dp[i][j] = INF;\n\n    for(int i=0; i<N; i++){\n        int64_t mn = INF;\n        for(int j=0; j<=2*N; j++){\n            chmin(mn, dp[i][j]);\n            if(pos[i] == j){\n                chmin(dp[i+1][j], mn);\n            }else if(j%2 == 0){\n                int64_t cost = (pos[i] < j ? A : B);\n                chmin(dp[i+1][j], mn + cost);\n            }\n        }\n    }\n\n    int64_t ans = INF;\n    for(int j=0; j<=2*N; j++) chmin(ans, dp[N][j]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define INF 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef long long ll;\n\nll dp[6000][6000];\nint p[6000];\n\nint main(){\n\tint n,a,b;cin>>n>>a>>b;\n\trep(i,n)scanf(\"%d\",&p[i]);\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\trep(i,n)rep(j,n){\n\t\tif(dp[i][j]==INF)continue;\n\t\tif(j>p[i]){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n\t\t}\n\t\telse{\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+a);\n\t\t\tdp[i+1][p[i]]=min(dp[i+1][p[i]],dp[i][j]);\n\t\t}\n\t}\n\tcout<<*min_element(dp[n],dp[n]+n+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\n\n\nint main() {\n  int n;\n  cin >> n;\n  ll a, b;\n  cin >> a >> b;\n  vi p(n);\n  vi i2x(n);\n  rep (i, n) {\n    cin >> p[i];\n    i2x[p[i] - 1] = i;\n    p[i] = 2 * p[i];\n  }\n \n  vll dp(n + 1, vl(2 * n + 2, INF));\n  rep (i, 2 * n + 2) dp[0][i] = 0;\n  rep (i, n) {\n    int x = i2x[i];\n    x = (x + 1) * 2;\n    //DEBUG(x);\n    rep (j, 2*n + 1) {\n      if (dp[i][j] == INF) continue;\n      if (j < x) {\n        chmin(dp[i + 1][x], dp[i][j]);\n        if (j % 2 == 1) {\n          chmin(dp[i + 1][j], dp[i][j] + b);\n        }\n        else {\n          chmin(dp[i + 1][j + 1], dp[i][j] + b);\n        }\n      }\n      else {\n        if (j % 2 == 1) {\n          chmin(dp[i + 1][j], dp[i][j] + a);\n        }\n        else {\n          chmin(dp[i + 1][j + 1], dp[i][j] + a);\n        }\n      }\n    }\n  }\n\n  \n  //DEBUG_MAT(dp);\n  ll ans = INF;\n  rep (i, 2 * n + 2) {\n    chmin(ans, dp[n][i]);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 3/23/2019, 10:52:02 PM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(10101010));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll infty = 10000000000000007;\n\nll N, A, B;\nint p[5010];\nll R[5010][5010];\nll L[5010][5010];\nll cost[5010][5010];\n\nll calc(int l, int r)\n{\n  if (cost[l][r] < infty)\n  {\n    return cost[l][r];\n  }\n  else if (l + 1 == r)\n  {\n    cost[l][r] = 0;\n  }\n  else\n  {\n    cost[l][r] = min(A, B * R[l][r - 1]) + calc(l + 1, r);\n    cost[l][r] = min(cost[l][r], min(B, A * L[r - 1][l]) + calc(l, r - 1));\n  }\n#if DEBUG == 1\n  cerr << \"cost[\" << l << \"][\" << r << \"] = \" << cost[l][r] << endl;\n#endif\n  return cost[l][r];\n}\n\nint main()\n{\n  cin >> N >> A >> B;\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> p[i];\n    p[i]--;\n  }\n  fill(&cost[0][0], &cost[0][0] + 5010 * 5010, infty);\n  for (auto i = 0; i < N; i++)\n  {\n    R[i][i] = 0;\n    for (auto j = i + 1; j < N; j++)\n    {\n      R[i][j] = R[i][j - 1];\n      if (p[i] > p[j])\n      {\n        R[i][j]++;\n      }\n#if DEBUG == 1\n      cerr << \"R[\" << i << \"][\" << j << \"] = \" << R[i][j] << endl;\n#endif\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    L[i][i] = 0;\n    for (auto j = i - 1; j >= 0; j--)\n    {\n      L[i][j] = L[i][j + 1];\n      if (p[i] < p[j])\n      {\n        L[i][j]++;\n      }\n#if DEBUG == 1\n      cerr << \"L[\" << i << \"][\" << j << \"] = \" << L[i][j] << endl;\n#endif\n    }\n  }\n  cout << calc(0, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define endl '\\n'\n\n//TEMPLATE START---------------8<---------------8<---------------8<---------------8<---------------//\n\n/* TYPE */\ntypedef long long ll;       typedef long double ld;\ntypedef pair<int, int> pii; typedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;   typedef vector<pll> vpll;\ntypedef vector<int> vi;     typedef vector<ll> vl;\ntypedef vector<string> vst; typedef vector<bool> vb;\ntypedef vector<ld> vld;     typedef vector<vector<int>> vvi;\ntemplate<typename T, typename Cmp = less<>> using prique = priority_queue<T, vector<T>, Cmp>;\ntemplate<typename T> using prique_r = prique<T, greater<>>;\n/* CONSTANT */\n#define ln '\\n'\nconst int INF = 1 << 30;    const ll INFF = 1LL << 60;  const string ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst int MOD = 1e9 + 7;    const int MODD = 998244353; const string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\nconst double EPS = 1e-9;    const ld PI = 3.14159265358979323846264338327950288;\nconst int dx[] = { 1, 0, -1,  0,  1, -1, -1, 1, 0 };\nconst int dy[] = { 0, 1,  0, -1, -1, -1,  1, 1, 0 };\n/* CONTAINER */\n#define PB              emplace_back\n#define ALL(v)          (v).begin(), (v).end()\n#define RALL(v)         (v).rbegin(), (v).rend()\n#define SORT(v)         sort(ALL(v))\n#define RSORT(v)        sort(RALL(v))\n#define LESS(x, val)    (lower_bound(x.begin(), x.end(), val) - x.begin())\n#define LEQ(x, val)     (upper_bound(x.begin(), x.end(), val) - x.begin())\n#define GREATER(x, val) (int)(x).size() - LEQ((x), (val))\n#define GEQ(x, val)     (int)(x).size() - LESS((x), (val))\n#define UNIQUE(v)       sort(ALL(v)); (v).erase(unique(ALL(v)), (v).end())\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }\ntemplate<typename T, typename U, typename... V> enable_if_t<is_same<T, U>::value != 0> fill_v(U &u, const V... v) { u = U(v...); }\ntemplate<typename T, typename U, typename... V> enable_if_t<is_same<T, U>::value == 0> fill_v(U &u, const V... v) { for (auto &e : u) fill_v<T>(e, v...); }\n/* LOOP */\n#define _overload3(_1, _2, _3, name, ...) name\n#define _REP(i, n)      REPI(i, 0, n)\n#define REPI(i, a, b)   for (ll i = (ll)a; i < (ll)b; ++i)\n#define REP(...)        _overload3(__VA_ARGS__, REPI, _REP,)(__VA_ARGS__)\n#define _RREP(i, n)     RREPI(i, n, 0)\n#define RREPI(i, a, b)  for (ll i = (ll)a; i >= (ll)b; --i)\n#define RREP(...)       _overload3(__VA_ARGS__, RREPI, _RREP,)(__VA_ARGS__)\n#define EACH(e, v)      for (auto& e : v)\n#define PERM(v)         sort(ALL(v)); for (bool c##p = true; c##p; c##p = next_permutation(ALL(v)))\n/* INPUT */\ntemplate<typename T> void SSS(T& t) { cin >> t; }\ntemplate<typename Head, typename... Tail> void SSS(Head&& head, Tail&&... tail) { cin >> head; SSS(tail...); }\n#define SS(T, ...)      T __VA_ARGS__; SSS(__VA_ARGS__);\n#define SV(T, v, n)     vector<T> v(n); for (auto& i : v) cin >> i;\n#define SVV(T, v, n, m) vector<vector<T>> v(n, vector<T>(m)); for (auto& r : v) for (auto& i : r) cin >> i;\n/* OUTPUT */\n// PROTOTYPE DECLARATION\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &j);\ntemplate<typename... T> ostream &operator<<(ostream &os, const tuple<T...> &t);\ntemplate<class C, enable_if_t<!is_same<C, string>::value, decltype(declval<const C &>().begin(), nullptr)> = nullptr> ostream& operator<<(ostream &os, const C &c);\ntemplate<typename T> ostream &operator<<(ostream &os, const stack<T> &j);\ntemplate<typename T> ostream &operator<<(ostream &os, const queue<T> &j);\ntemplate<typename T, typename C, typename Cmp> ostream &operator<<(ostream &os, const priority_queue<T, C, Cmp> &j);\n// IMPLEMENTATION\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &j) { return os << '{' << j.first << \", \" << j.second << '}'; }\ntemplate<size_t num = 0, typename... T> enable_if_t<num == sizeof...(T)> PRINT_TUPLE(ostream &os, const tuple<T...> &t) {}\ntemplate<size_t num = 0, typename... T> enable_if_t<num <  sizeof...(T)> PRINT_TUPLE(ostream &os, const tuple<T...> &t) { os << get<num>(t); if (num + 1 < sizeof...(T)) os << \", \"; PRINT_TUPLE<num + 1>(os, t); }\ntemplate<typename... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { PRINT_TUPLE(os << '{', t); return os << '}'; }\ntemplate<class C, enable_if_t<!is_same<C, string>::value, decltype(declval<const C &>().begin(), nullptr)>> ostream& operator<<(ostream &os, const C &c) { os << '{'; for (auto it = begin(c); it != end(c); it++) { if (begin(c) != it) os << \", \"; os << *it; } return os << '}'; }\ntemplate<typename T> ostream &operator<<(ostream &os, const stack<T> &j) { deque<T> d; for (auto c = j; !c.empty(); c.pop()) d.push_front(c.top());  return os << d; }\ntemplate<typename T> ostream &operator<<(ostream &os, const queue<T> &j) { deque<T> d; for (auto c = j; !c.empty(); c.pop()) d.push_back(c.front()); return os << d; }\ntemplate<typename T, typename C, typename Cmp> ostream &operator<<(ostream &os, const priority_queue<T, C, Cmp> &j) { deque<T> d; for (auto c = j; !c.empty(); c.pop()) d.push_front(c.top());  return os << d; }\n// OUTPUT FUNCTION\ntemplate<typename T> int PV(T &v) { int sz = v.size(); for (int i = 0; i < sz; ++i) cout << v[i] << \" \\n\"[i == sz - 1]; return 0; }\ninline int print() { cout << endl; return 0; }\ntemplate<typename Head> int print(Head&& head){ cout << head; return print(); }\ntemplate<typename Head, typename... Tail> int print(Head&& head, Tail&&... tail) { cout << head << \" \"; return print(forward<Tail>(tail)...); }\n#ifdef LOCAL\ninline void dump() { cerr << endl; }\ntemplate<typename Head> void dump(Head&& head) { cerr << head; dump(); }\ntemplate<typename Head, typename... Tail> void dump(Head&& head, Tail&&... tail) { cerr << head << \", \"; dump(forward<Tail>(tail)...); }\n#define debug(...) do {cerr << __LINE__ << \":\t\" << #__VA_ARGS__ << \" = \"; dump(__VA_ARGS__); } while (false)\n#else\n#define dump(...)\n#define debug(...)\n#endif\n/* OTHER */\n#define MP              make_pair\n#define MT              make_tuple\n#define tmax(x, y, z)   max((x), max((y), (z)))\n#define tmin(x, y, z)   min((x), min((y), (z)))\ntemplate<typename T, typename A, typename B> inline bool between(T x, A a, B b) { return ((a <= x) && (x < b)); }\ntemplate<typename A, typename B> inline bool chmax(A &a, const B &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename A, typename B> inline bool chmin(A &a, const B &b) { if (a > b) { a = b; return true; } return false; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\ninline ll POW(ll a, ll b)                    { ll r = 1; do { if (b & 1)  r *= a;        a *= a; }       while (b >>= 1); return r; }\ninline ll MOP(ll a, ll b, const ll &m = MOD) { ll r = 1; do { if (b & 1) (r *= a) %= m; (a *= a) %= m; } while (b >>= 1); return r; }\nstruct abracadabra {\n    abracadabra() {\n        cin.tie(nullptr); ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n        cerr << fixed << setprecision(5);\n    };\n} ABRACADABRA;\n\n//TEMPLATE END---------------8<---------------8<---------------8<---------------8<---------------//\n\nll dp[5050][5050];\n\nsigned main() {\n\n    SS(ll, N, A, B);\n    SV(int, P, N);\n\n    REP(i, 5050) REP(j, 5050) dp[i][j] = INFF;\n    dp[0][0] = 0;\n\n    REP(i, N) {\n        int k = P[i];\n        REP(j, N + 1) {\n            if (k > j) {\n                chmin(dp[i + 1][k], dp[i][j]);\n                chmin(dp[i + 1][j], dp[i][j] + A);\n            } else {\n                chmin(dp[i + 1][j], dp[i][j] + B);\n            }\n        }\n    }\n\n    ll res = INFF;\n    REP(i, N + 1) chmin(res, dp[N][i]);\n    print(res);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N, p[5005], A, B, dp[5005][5005];\nll pos[5005];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> N >> A >> B;\n\tfor (int i = 1; i <= N; ++i){\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 1; i <= N; ++i){\n\t\tpos[p[i]] = i;\n\t} \n\tfor (int i = 1; i <= N+1; ++i){\n\t\tif (i < pos[1]) dp[1][i] = A;\n\t\telse if (i > pos[1]) dp[1][i] = B;\n\t\telse dp[1][i] = 0;\n\t} \n\tfor (int i = 2; i <= N; ++i){\n\t\tdeque<pair<ll,int> > f;\n\t\tfor (int j = 1; j <= N+1; ++j){\n\t\t\tif (j == pos[i]) dp[i][j] = dp[i-1][j];\n\t\t\telse dp[i][j] = 1e16;\n\t\t\tif (!f.empty()){\n\t\t\t\tif (j > pos[i]) dp[i][j] = min(dp[i][j],B+f.front().first);\n\t\t\t\telse if (j < pos[i]) dp[i][j] = min(dp[i][j],A+f.front().first);\n\t\t\t\telse dp[i][j] = min(dp[i][j],f.front().first);\n\t\t\t}\n\t\t\twhile (!f.empty() && f.back().first > dp[i-1][j]){\n\t\t\t\tf.pop_back();\n\t\t\t}\n\t\t\tf.push_back(make_pair(dp[i-1][j],j));\n\t\t}\n\t} \n\tfor (int i = 1; i <= N; ++i){\n\t\tfor (int j = 1; j <= N+1; ++j){\n\t\t\t//cout << dp[i][j] << ' ';\n\t\t}\n\t\t//cout << '\\n';\n\t} \n\tll M = 1e16;\n\tfor (int i = 1; i <= N+1; ++i){\n\t\tM = min(M,dp[N][i]);\n\t}\n\tcout << M << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 10000000000000;\n\tvector<long long> P, DP;\n\tcin >> N >> A >> B;\n\tP.resize(N);\n\tDP.assign(N + 1, INF);\n\tDP[0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (DP[j] >= INF || j == P[i]) continue;\n\t\t\tif (j < P[i]) {\n\t\t\t\tDP[P[i]] = min(DP[P[i]], DP[j]);\n\t\t\t\tDP[j] += A;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDP[j] += B;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#define int long long\nusing namespace std;\nconst int N=5e3+2;\nconst int inf=1e18+2;\nint dp[N],ar[N],lef[N],rig[N],pos[N],it[4*N],trace[N];\nvoid upd(int idx,int l,int r,int pos){\n\tif(pos>r||pos<l){\n\t\treturn;\n\t}\n\tif(l==r){\n\t\tit[idx]++;\n\t\treturn;\n\t}\n\tupd(2*idx,l,(l+r)/2,pos);\n\tupd(2*idx+1,(l+r)/2+1,r,pos);\n\tit[idx]=it[2*idx]+it[2*idx+1];\n}\nint getsum(int idx,int l,int r,int lef,int rig){\n\tif(lef>rig){\n\t\treturn 0;\n\t}\n\tif(l>rig||r<lef){\n\t\treturn 0;\n\t}\n\tif(l>=lef&&r<=rig){\n\t\treturn it[idx];\n\t}\n\treturn getsum(2*idx,l,(l+r)/2,lef,rig)+getsum(2*idx+1,(l+r)/2+1,r,lef,rig);\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,a,b,ans=inf,idxans;\n\tcin>>n>>a>>b;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t\tpos[ar[i]]=i;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<i;j++){\n\t\t\tif(ar[j]>ar[i]){\n\t\t\t\tlef[ar[i]]++;\n\t\t\t}\n\t\t}\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tif(ar[j]>ar[i]){\n\t\t\t\trig[ar[i]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tdp[i]=(i-1)*b;\n\t\tfor(j=1;j<=4*n;j++){\n\t\t\tit[j]=0;\n\t\t}\n\t\tfor(j=i-1;j>=1;j--){\n\t\t\tif(pos[j]<pos[i]&&getsum(1,1,n,pos[j],pos[i])==0){\n\t\t\t\tif(dp[j]+getsum(1,1,n,1,pos[j]-1)*a+getsum(1,1,n,pos[i]+1,n)*b<dp[i]){\n\t\t\t\t\ttrace[i]=j;\n\t\t\t\t}\n\t\t\t\tdp[i]=min(dp[i],dp[j]+getsum(1,1,n,1,pos[j]-1)*a+getsum(1,1,n,pos[i]+1,n)*b);\n\t\t\t}\n\t\t\tupd(1,1,n,pos[j]);\n\t\t}\n\t\tif(rig[i]==0){\n//\t\t\tif(dp[i]+lef[i]*a<ans){\n//\t\t\t\tidxans=i;\n//\t\t\t}\n\t\t\tans=min(ans,dp[i]+lef[i]*a);\n\t\t}\n\t\t//cout<<dp[i]+lef[i]*a<<' '<<dp[i]<<' '<<i<<' '<<rig[i]<<endl;\n\t}\n//\twhile(idxans){\n//\t\tcout<<idxans<<' ';\n//\t\tidxans=trace[idxans];\n//\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define S second\n#define pb push_back\n#define sz(x) ((int)(x).size())\n\ninline int in(){ int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = 5000 + 100;\nset<int> curr; \n\nint a[N]; \nint p[N];\n\nll dp[N][N];\n\nvoid smin(ll& a, ll b) { \n    a = min(a,b); \n}\n\nint main(){\n    int n; \n    ll A, B;\n    cin >> n >> A >> B;\n\n    for(int i = 0; i < n; i++) {\n        cin >> a[i];\n        a[i]--; \n        p[a[i]] = i; \n    }\n    memset(dp, 63, sizeof dp); \n\n    for(int i = n-1; i >= 0; i--) { \n        dp[i][i+1] = 0;\n        int t[4] = {p[i], n+1, p[i], -1}; \n\n        for(int j = i+2; j <= n; j++) {\n            j--;\n            if( p[j] < t[0] ) { \n                t[1] = t[0]; \n                t[0] = p[j];  \n            } else if( p[j] < t[1] ) { \n                t[1] = p[j]; \n            }\n            if( p[j] > t[2] ) { \n                t[3] = t[2]; \n                t[2] = p[j]; \n            } else if( p[j] > t[3] ) \n                t[3] = p[j]; \n            j++;\n\n            smin(dp[i][j], dp[i+1][j] + B);\n            smin(dp[i][j], dp[i][j-1] + A); \n\n            if( p[i] == t[0] ) \n                smin( dp[i][j] , dp[i+1][j] ); \n            if( p[i] == t[1] ) \n                smin( dp[i][j] , dp[i+1][j] + A ); \n            if( p[j-1] == t[2] ) \n                smin( dp[i][j] , dp[i][j-1] ); \n            if( p[j-1] == t[3] ) \n                smin( dp[i][j] , dp[i][j-1] + B );\n\n        }\n\n    }\n\n    cout << dp[0][n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;long long n,aa,i,j,b,f[5005],pos[5005],ans,a[5005],c[5005];int main(){ans=12345678912345678ll;cin>>n>>aa>>b;for (i=1;i<=n;i++) f[i]=ans;for (i=1;i<=n;i++){\tcin>>a[i];pos[a[i]]=i;\t}\tfor (i=1;i<=n;i++){\t\tc[i]=c[i-1]+(i<a[i]?aa:b);\t}\tfor (i=1;i<=n;i++){\t\tlong long s=0;\t\tfor (j=i-1;j>=0;j--){\t\t\tif (a[j]<a[i]){\t\t\t\tf[i]=min(f[i],f[j]+s);\t\t\t}\t\t\tif (a[j]<a[i]){\t\t\t\ts+=b;\t\t\t} else {\t\t\t\ts+=aa;\t\t\t}\t\t}\t\tans=min(ans,f[i]+(n-i)*b);\t}\tcout<<ans<<endl;return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\n#define per(i, a, b) for (int i = (a); i >= int(b); i--)\n#define fir first\n#define sec second\n#define tct template<class type>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int maxn = 5e3, mod = 1e9 + 7;\nint n, A, B, p[maxn + 5];\nll f[maxn + 5];\n\ninline void red(int &x) { x += x >> 31 & mod; }\ntct inline void cmax(type &x, type y) { x < y ? x = y : 0; }\ntct inline void cmin(type &x, type y) { x > y ? x = y : 0; }\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &A, &B);\n\trep(i, 1, n) scanf(\"%d\", &p[i]);\n\trep(i, 1, n) {\n\t\tll mn = 1e18;\n\t\trep(j, 1, p[i]) mn = min(mn, f[j]);\n\t\tf[p[i]] = mn;\n\t\trep(j, 1, p[i] - 1) f[j] += A;\n\t\trep(j, p[i] + 1, n) f[j] += B;\n\t}\n\tll mn = 1e18;\n\trep(i, 1, n) mn = min(mn, f[i]);\n\tprintf(\"%lld\\n\", mn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint pos[5000];\nlong long dp[6000][6000];\nint main(){\n  int n;\n  long long a,b;\n  scanf(\"%d%lld%lld\",&n,&b,&a);\n  for(int i=0;i<n;i++){\n    int p;\n    scanf(\"%d\",&p);\n    pos[p]=i+1;\n  }\n  for(int i=0;i<n+1;i++){\n      if(i<pos[1])\n        dp[1][i]=a;\n      else\n        dp[1][i]=0ll;\n  }\n  for(int x=2;x<=n;x++){\n    for(int i=0;i<n+1;i++){\n      dp[x][i] = (long long)1e18;\n      if(i<pos[x])\n        dp[x][i] = min(dp[x][i],a+dp[x-1][i]);\n      else{\n          dp[x][i] = min(dp[x][i], dp[x-1][pos[x]-1]);\n          dp[x][i] = min(dp[x][i], b+dp[x-1][i]);\n      }\n    }\n  }\n  printf(\"%lld\\n\",dp[n][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"d.in\", \"r\", stdin);\n  freopen(\"d.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    ++n;\n    vector<int> p(n);\n    for (int i = 1; i < n; i++) {\n      scanf(\"%d\", &p[i]);\n    }\n\n    vector<int> ps = p;\n    sort(ps.begin(), ps.end());\n\n    vector<ll> dp(n, 1LL << 60);\n    dp[0] = a * 1LL * (n - 1);\n\n    for (int i = 0; i < n; i++) {\n      int from = find(ps.begin(), ps.end(), p[i]) - ps.begin();\n      ps.erase(ps.begin() + from);\n      for (int j = from; j < (int)ps.size(); j++) {\n        int v = ps[j];\n        assert(v > p[i]);\n        dp[v] = min(dp[v], dp[p[i]] - a + (b - a) * 1LL * (j - from));\n      }\n    }\n\n    printf(\"%lld\\n\", *min_element(dp.begin(), dp.end()));\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n#define MAX_N 5000\n#define INF 0x3f3f3f3f\n\nlong dp[MAX_N + 1][MAX_N + 1];\nint x0[MAX_N + 1], P[MAX_N];\n\nlong rotation_sort( int N, int A, int B )\n{\n    for ( int i = 0; i < N; i++ ) x0[P[i]] = i;\n\n    memset( dp, INF, sizeof( dp ) );\n    memset( dp[0], 0, sizeof( dp[0] ) );\n\n    for ( int k = 1; k <= N; k++ )\n    {\n        long min_prev = INF;\n\n        for ( int x = 0; x <= N; x++ )\n        {\n            int cost;\n            if ( x == x0[k] )\n                cost = 0;\n            else if ( x < x0[k] )\n                cost = B;\n            else\n                cost = A;\n\n            min_prev = min( min_prev, dp[k - 1][x] );\n            dp[k][x] = min_prev + cost;\n        }\n    }\n\n    long ans = INF;\n    for ( auto v : dp[N] ) ans = min( ans, v );\n\n    return ans;\n}\n\nint main( int argc, char **argv )\n{\n    long N, A, B;\n    cin >> N >> A >> B;\n\n    for ( int i = 0; i < N; i++ ) cin >> P[i];\n\n    cout << rotation_sort( N, A, B ) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 5050;\nint n, a, b;\nint loc[N];\nll f[N][2 * N];\nint main() {\n\tcin >> n >> a >> b;\n\tfor(int i = 1; i <= n; i++) {\n\t\tint t; scanf(\"%d\", &t); loc[t] = i;\n\t}\n\tmemset(f, 127, sizeof f);\n\tmemset(f[0], 0, sizeof f[0]);\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= 2 * n; j++) {\n\t\t\tf[i][j] = f[i - 1][j - (j & 1)];\n\t\t\tif (j < loc[i] * 2) f[i][j] += b;\n\t\t\t\telse if (j > loc[i] * 2) f[i][j] += a;\n\t\t\tf[i][j] = min(f[i][j - 1], f[i][j]);\n\t\t}\n\t}\n\tll ans = 1e18;\n\tfor(int j = 1; j <= 2 * n; j++) ans = min(ans, f[n][j]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        i++;\n        while (i <= n){\n            bit[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            ret += bit[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return sum(r-1) - sum(l-1);\n    }\n};\n\nint main() {\n    int n;\n    ll a, b;\n    cin >> n >> a >> b;\n    VL p(n), pos(n);\n    REP(i,n){\n        p[i] = n - in();\n        pos[p[i]] = i;\n    }\n\n    VL dp(n + 1, 1e18);\n    dp[0] = 0;\n    BIT bit(n);\n    REP(i,n-1){\n        bit.add(pos[i], 1);\n        if (bit.sum(pos[i + 1]) == 0) dp[i + 1] = min(dp[i + 1], dp[i]);\n        ll x = 1e18, cc = bit.sum(pos[i + 1]);\n        FOR(j,i+1,n-1){\n            if (pos[j] > x || bit.sum(pos[j]) != cc) break;\n            x = pos[j];\n            dp[j] = min(dp[j], dp[i] + (j - i) * b);\n            dp[j] = min(dp[j], dp[i] + cc * a);\n        }\n        dp[i + 1] = min(dp[i + 1], dp[i] + a * bit.sum(pos[i + 1]));\n    // REP(i,n) cout << dp[i] << \" \";\n    // cout << endl;\n    }\n\n    cout << dp[n - 1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Maxn=5005;\nint a[Maxn],pos[Maxn];\nll f[Maxn][Maxn];\nint main(){\n    int n,A,B;cin>>n>>A>>B;\n    for(int i=1;i<=n;i++)cin>>a[i],pos[a[i]]=i;\n    memset(f,0x3f,sizeof(f));\n    memset(f[0],0,sizeof(f[0]));\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            int l=pos[i],delta=0;\n            if(l<j)delta=A;\n            else if(l>j)delta=B;\n            f[i][j]=min(f[i][j],f[i-1][j]+delta);\n        }\n        for(int j=1;j<=n;j++)f[i][j]=min(f[i][j],f[i][j-1]);\n    }\n    cout<<f[n][n]<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint a[5005];\nint dp[5005][5005];\nint n,A,B;\n\nint solve(int i, int maxx)\n{\n    if (i == n) return 0;\n    if (dp[i][maxx] != -1) return dp[i][maxx];\n    dp[i][maxx] = 0;\n    if (a[i + 1] > maxx)\n    {\n        dp[i][maxx] = min(solve(i + 1, maxx) + A, solve(i + 1, a[i + 1]));\n    } else {\n        dp[i][maxx] = solve(i + 1, maxx) + B;\n    }\n    return dp[i][maxx];\n}\n\nsigned main()\n{\n    //freopen(\"file.inp\",\"r\",stdin);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        for (int j = 0; j <= n; j++)\n        {\n            dp[i][j] = -1;\n        }\n    }\n    dp[0][0] = -1;\n    cout << solve(0, 0);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    ll n, a, b;\n    cin >> n >> a >> b;\n    int p[n];\n    rep(i,n){\n        cin >> p[i];\n    }\n    ll dp[n][n+1];\n    ll INF = 1001001001001001001;\n    rep(i,n)rep(j,n+1)dp[i][j] = INF;\n    rep(i,n){\n        if(i == 0){\n            dp[i][0] = a;\n            dp[i][p[i]] = 0;\n        }else{\n            int x = p[i];\n            dp[i][0] = dp[i-1][0] + a;\n            srep(j,1,n+1){\n                if(j < x){\n                    dp[i][j] = dp[i-1][j] + a;\n                }else if(j == x){\n                    rep(k,x+1){\n                        dp[i][x] = min(dp[i][x], dp[i-1][k]);\n                    }\n                }else{\n                    dp[i][j] = dp[i-1][j] + b;\n                }\n            }\n        }\n    }\n    ll ans = INF;\n    rep(j,n+1)ans = min(ans, dp[n-1][j]);\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\n//uint MODULAR=998244353;\nuint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nll n,a,b,dp[5005][5005],p[5005],ans=infl;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n>>a>>b;\n\trng(i,1,n+1)cin>>p[i];\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)dp[i][j]=infl;\n\tdp[0][0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(j<p[i+1])chmin(dp[i+1][p[i+1]],dp[i][j]);\n\t\t\tif(j<p[i+1])chmin(dp[i+1][j],dp[i][j]+a);\n\t\t\tif(j>p[i+1])chmin(dp[i+1][j],dp[i][j]+b);\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)chmin(ans,dp[n][i]);\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\ntemplate<class T> void chmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<class T> void chmax(T &a,const T &b){if(a<b) a=b;}\n\nconst ll INF=1e18;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N;\n  ll A,B;\n  cin>>N>>A>>B;\n  vector<int> P(N);\n  rep(i,N) cin>>P[i];\n\n  vector<vector<ll>> dp(N+1,vector<ll> (N+1,INF));\n  dp[0][0]=0;\n  for(int i=0;i<N;i++){\n      for(int j=0;j<=N;j++){\n          if(dp[i][j]==INF) continue;\n          {\n              ll neco=A;\n              if(P[i]<j) neco=B;\n              chmin(dp[i+1][j],dp[i][j]+neco);\n          }\n\n          {\n              if(j<P[i]) chmin(dp[i+1][P[i]],dp[i][j]);\n          }\n      }\n  }\n\n  ll ans=INF;\n  rep(i,N+1) chmin(ans,dp[N][i]);\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mino \"test\"\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define matrix vector<vector<ll>>\n#define FOR(i,a,b) for(int i=a; i<=b; i++)\n#define Down(i,a,b) for(int i=a; i>=b; i--)\n#define FOR_(i,a,b) for(int i=a; i<b; i++)\n#define turbo ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define oo 1e9\n\nconst int N = 2e5 + 5;\n\nusing namespace std;\n\ntypedef pair<ll,int> pii;\n\n\nint n;\nint st[N], top;\nll res, A, B;\n\nvoid nhap()\n{\n    cin >> n >> A >> B;\n}\n\nvoid xuli()\n{\n    int dem;\n    FOR(i,1,n)\n    {\n        int x;\n        cin >> x;\n        int tam = top;\n        dem = 0;\n        while(tam > 0 && st[tam] > x)\n        {\n            tam--;\n            dem++;\n        }\n        if(A * dem < B)\n        {\n            top = tam;\n            res += A * dem;\n            st[++top] = x;\n        }\n        else res += B;\n    }\n    cout << res;\n}\n\nint main()\n{\n    //freopen(mino\".inp\",\"r\",stdin);\n    //freopen(mino\".out\",\"w\",stdout);\n    turbo\n    nhap();\n    xuli();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst ll INF = 1e15;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 5e3 + 5;\n\nint per[MAXN];\nll dp[MAXN][MAXN];\n\nvoid solve(){\n\tint n;\n\tll a, b;\n\tcin >> n >> a >> b;\n\tREPN(i, 1, n) {\n\t\tcin >> per[i];\n\t}\n\tREPN(i, 1, n) {\n\t\tREPN(j, 0, n) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tREPN(i, 1, n) {\n\t\tdp[i][0] = a * i;\n\t}\n\tREP(i, 0, n) {\n\t\tREPN(j, 0, n) {\n\t\t\tif (dp[i][j] == INF) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (per[i + 1] > j) {\n\t\t\t\tdp[i + 1][per[i + 1]] = min(dp[i + 1][per[i + 1]], dp[i][j]);\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + a);\n\t\t\t} else {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + b);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = INF;\n\tREPN(i, 0, n) {\n\t\tans = min(ans, dp[n][i]);\n\t}\n\tcout << ans << endl;\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define itrep(i, a) for (auto i = (a).begin(); i != (a).end(); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n#define mp(a, b) make_pair((a), (b))\n\nusing namespace std;\n\ntemplate<class T> void inputVector(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\n\nint leftBig[5010], rightSmall[5010];\n\nint N, A, B;\nvector<int> p;\n\nvoid makeLeftBig() {\n    set<int> st;\n    rep(i, N) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.end()) leftBig[p[i]] = N + 1;\n        else leftBig[p[i]] = *it;\n        st.insert(p[i]);\n    }\n    //cerr << \"leftBig:\";\n    //REP(i, 1, N) cerr << \" \" << leftBig[i];\n    //cerr << endl;\n}\nvoid makeRightSmall() {\n    set<int> st;\n    for (int i = N - 1; i >= 0; i--) {\n        auto it = st.upper_bound(p[i]);\n        if (it == st.begin()) rightSmall[p[i]] = 0;\n        else {\n            it--;\n            rightSmall[p[i]] = *it;\n        }\n        st.insert(p[i]);\n    }\n    //cerr << \"rightSmall:\";\n    //REP(i, 1, N) cerr << \" \" << rightSmall[i];\n    //cerr << endl;\n}\n\nstruct Info {\n    int left, right;\n    int dist;\n\n    Info(int left, int right, int dist) : left(left), right(right), dist(dist) {\n    }\n\n    bool operator< (const Info& a) const {\n        return dist > a.dist;\n    }\n};\n\nint memo[5010][5010];\n\nsigned main() {\n    cin >> N >> A >> B;\n\n    inputVector(p, N);\n\n    makeLeftBig();\n    makeRightSmall();\n\n    rep(i, N + 5) rep(j, N + 5) memo[i][j] = LLONG_MAX;\n\n    priority_queue<Info> q;\n    q.push(Info(0, N + 1, 0));\n    memo[0][N + 1] = 0;\n    while (!q.empty()) {\n        auto info = q.top(); q.pop();\n        if (info.dist > memo[info.left][info.right]) continue;\n        //cerr << \"Info: [left:\" << info.left << \" right:\" << info.right << \" dist:\" << info.dist << \"]\" << endl;\n        if (info.left + 1 == info.right) {\n            cout << info.dist << endl;\n            break;\n        }\n\n        {\n            int nextNum = info.left + 1;\n            int ndist = info.dist;\n            if (leftBig[nextNum] < info.right) {\n                ndist += min(B, A * (info.right - info.left - 2));\n            }\n            if (ndist < memo[info.left + 1][info.right]) {\n                memo[info.left + 1][info.right] = ndist;\n                q.push(Info(info.left + 1, info.right, ndist));\n            }\n        }\n        {\n            int nextNum = info.right - 1;\n            int ndist = info.dist;\n            if (rightSmall[nextNum] > info.left) {\n                ndist += min(A, B * (info.right - info.left - 2));\n            }\n            if (ndist < memo[info.left][info.right - 1]) {\n                memo[info.left][info.right - 1] = ndist;\n                q.push(Info(info.left, info.right - 1, ndist));\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint N, A, B; long long D[5050];\n\nint main()\n{\n\tscanf (\"%d %d %d\", &N, &A, &B);\n\tfor (int i = 1; i <= N; i++){\n\t\tint x; scanf (\"%d\", &x);\n\t\tlong long X[5050];\n\t\tfor (int j = 0; j <= N; j++) X[j] = 1e18;\n\t\tfor (int j = 0; j <= N; j++){\n\t\t\tif (j <= x){\n\t\t\t\tif (X[x] > D[j]) X[x] = D[j];\n\t\t\t\tif (X[j] > D[j] + A) X[j] = D[j] + A;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (X[j] > D[j] + B) X[j] = D[j] + B;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= N; j++) D[j] = X[j];\n\t}\n\n\tlong long ans = 1e18;\n\tfor (int j = 0; j <= N; j++) if (ans > D[j]) ans = D[j];\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 1000000000000000000LL\nusing namespace std;\n#define Maxn 5007\nint n,a,b;\nint p[Maxn],pos[Maxn];\nint mx[Maxn][16],mn[Maxn][16];\nint bin[Maxn];\nlong long f[Maxn][Maxn];\nint get_max(int lx,int rx)\n{\n    int k=bin[rx-lx+1];\n    int a=mx[lx][k],b=mx[rx-(1<<k)+1][k];\n    if (pos[a]>pos[b]) return a; else return b;\n}\nint get_min(int lx,int rx)\n{\n    int k=bin[rx-lx+1];\n    int a=mn[lx][k],b=mn[rx-(1<<k)+1][k];\n    if (pos[a]<pos[b]) return a; else return b;\n}\nint calc_max(int lx,int rx)\n{\n    if (lx>rx) return 0;\n    int k=bin[rx-lx+1];\n    int a=mx[lx][k],b=mx[rx-(1<<k)+1][k];\n    return max(pos[a],pos[b]);\n}\nint calc_min(int lx,int rx)\n{\n    if (lx>rx) return n+1;\n    int k=bin[rx-lx+1];\n    int a=mn[lx][k],b=mn[rx-(1<<k)+1][k];\n    return min(pos[a],pos[b]);\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for (int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&p[i]);\n        pos[p[i]]=i;\n    }\n    bin[1]=0;\n    for (int i=2;i<=n;i++)\n        bin[i]=bin[i/2]+1;\n    for (int i=1;i<=n;i++)\n        mx[i][0]=i,mn[i][0]=i;\n    for (int k=1;k<=15;k++)\n        for (int i=1;i<=n;i++)\n        {\n            mx[i][k]=mx[i][k-1];\n            if (i+(1<<(k-1))<=n) \n            {\n                if (pos[mx[i][k]]<pos[mx[i+(1<<(k-1))][k-1]]) mx[i][k]=mx[i+(1<<(k-1))][k-1];\n            }\n            mn[i][k]=mn[i][k-1];\n            if (i+(1<<(k-1))<=n) \n            {\n                if (pos[mn[i][k]]>pos[mn[i+(1<<(k-1))][k-1]]) mn[i][k]=mn[i+(1<<(k-1))][k-1];\n            }\n        }\n    for (int i=1;i<=n;i++)\n        for (int j=i;j<=n;j++)\n            f[i][j]=inf;\n    for (int i=1;i<=n;i++)\n        f[i][i]=0LL;\n    for (int len=1;len<n;len++)\n        for (int i=1;i+len<=n;i++)\n        {\n            int j=i+len;\n            if (pos[j]>pos[get_max(i,j-1)]) f[i][j]=min(f[i][j],f[i][j-1]); else f[i][j]=min(f[i][j],f[i][j-1]+a);\n            int k=get_max(i,j-1);\n            if (pos[j]>calc_max(i,k-1)&&pos[j]>calc_max(k+1,j-1)) f[i][j]=min(f[i][j],f[i][j-1]+b);\n            if (pos[i]<pos[get_min(i+1,j)]) f[i][j]=min(f[i][j],f[i+1][j]); else f[i][j]=min(f[i][j],f[i+1][j]+b);\n            k=get_min(i+1,j);\n            if (pos[i]<calc_min(i+1,k-1)&&pos[i]<calc_min(k+1,j)) f[i][j]=min(f[i][j],f[i+1][j]+a);\n        }\n    printf(\"%lld\\n\",f[1][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n// スパーステーブルをまずは検討しよう\n#ifdef _MSC_VER\ninline unsigned int __builtin_clz(unsigned int x){unsigned long r;_BitScanReverse(&r,x);return 31-r;}\n#endif // _MSC_VER\ntemplate<class V> struct SparseTableMax { // [L,R)\n    const V def = -1;\n    inline V comp(V a, V b) { return max(a,b); }\n\n    int n; vector<V> a, b[20]; inline int __lg(int x) { return 32 - 1 - __builtin_clz(x); }\n    void init(vector<V> v) {\n        int nn = v.size(); n = 1; while (n < nn) n *= 2; a.resize(n);\n        rep(i, 0, 20) b[i].resize(n); rep(i, 0, nn) a[i] = v[i];\n\n        int d = 1 << __lg(n - 1), e = d << 1;\n        for (int h = 0, f; (f = 1 << h) <= d; ++h) {\n            for (int i = f, r = f << 1; i < e; i += r) {\n                b[h][i - 1] = a[i - 1];\n                for (int j = i - 2; j >= i - f; --j) b[h][j] = comp(b[h][j + 1], a[j]);\n                b[h][i] = a[i];\n                for (int j = i + 1; j < i + f; ++j) b[h][j] = comp(b[h][j - 1], a[j]);\n            }\n        }\n    }\n\n    V get(int L,int R){\n        assert(0<=L&&L<=R);\n        if(L==R)return def;R--;if(L==R)return a[L];int h=__lg(L^R);\n        return comp(b[h][L],b[h][R]);}};\ntemplate<class V> struct SparseTableMin { // [L,R)\n    const V def = inf;\n    inline V comp(V a, V b) { return min(a,b); }\n\n    int n; vector<V> a, b[20]; inline int __lg(int x) { return 32 - 1 - __builtin_clz(x); }\n    void init(vector<V> v) {\n        int nn = v.size(); n = 1; while (n < nn) n *= 2; a.resize(n);\n        rep(i, 0, 20) b[i].resize(n); rep(i, 0, nn) a[i] = v[i];\n\n        int d = 1 << __lg(n - 1), e = d << 1;\n        for (int h = 0, f; (f = 1 << h) <= d; ++h) {\n            for (int i = f, r = f << 1; i < e; i += r) {\n                b[h][i - 1] = a[i - 1];\n                for (int j = i - 2; j >= i - f; --j) b[h][j] = comp(b[h][j + 1], a[j]);\n                b[h][i] = a[i];\n                for (int j = i + 1; j < i + f; ++j) b[h][j] = comp(b[h][j - 1], a[j]);\n            }\n        }\n    }\n\n    V get(int L,int R){assert(0<=L&&L<=R);if(L==R)return def;R--;if(L==R)return a[L];int h=__lg(L^R);\n        return comp(b[h][L],b[h][R]);}};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N, A, B, P[5010];\nSparseTableMax<int> stmax;\nSparseTableMin<int> stmin;\n//---------------------------------------------------------------------------------------------------\nint rev[5010];\nll dp[5010][5010];\nll f(int L, int R) {\n    if (0 <= dp[L][R]) return dp[L][R];\n    if (L == R) return 0;\n\n    dp[L][R] = infl;\n\n    // ←\n    auto lft = stmin.get(L + 1, R + 1);\n    if (lft != infl and lft < rev[L]) chmin(dp[L][R], f(L + 1, R) + B);\n    else chmin(dp[L][R], f(L + 1, R));\n\n    // →\n    auto rht = stmax.get(L, R);\n    if (rht != -1 and rev[R] < rht) chmin(dp[L][R], f(L, R - 1) + A);\n    else chmin(dp[L][R], f(L, R - 1));\n\n    return dp[L][R];\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> A >> B;\n    rep(i, 0, N) cin >> P[i];\n\n    rep(i, 0, N) rev[P[i]] = i;\n    vector<int> v(N + 1);\n    rep(i, 1, N + 1) v[P[i]] = rev[P[i]];\n    stmax.init(v);\n    stmin.init(v);\n\n    rep(i, 0, N + 1) rep(j, 0, N + 1) dp[i][j] = -1;\n    cout << f(1, N) << endl;\n\n    //rep(i, 1, N + 1) rep(j, i, N + 1) printf(\"dp[%d][%d] = %lld\\n\", i, j, f(i, j));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 200000;\nint a[N], A, B, p[N];\nint used[5002][5002];\nlong long dp[5002][5002];\nint f[5002][5002];\nlong long solve(int l, int r) {\n    if (used[l][r]) {\n        return dp[l][r];\n    }\n    if (l == r) {\n        return 0;\n    }\n    used[l][r] = 1;\n    dp[l][r] = 1e18;\n    int i = p[l];\n    int cnt = f[i][r] - f[i][l - 1];\n    assert(cnt >= 1);\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r) + 1ll * A * (cnt - 1));\n        dp[l][r] = min(dp[l][r], solve(l + 1, r) + B);\n    }\n    i = p[r];\n    cnt = f[n][r] - f[n][l - 1] - (f[i - 1][r] - f[i - 1][l - 1]);\n    assert(cnt >= 1);\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1) + 1ll * B * (cnt - 1));\n        dp[l][r] = min(dp[l][r], solve(l, r - 1) + A);\n    }\n    return dp[l][r];\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        p[a[i]] = i;\n    }\n    for (int j = 1; j <= n; j++) {\n        for (int i = 1; i <= n; i++) {\n            f[i][j] = f[i - 1][j];\n            if (a[i] <= j) {\n                f[i][j]++;\n            }\n        }\n    }\n    cout << solve(1, n) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define FORqr(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int (x); SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long (x); SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\n#define M0(x) memset(x,0,sizeof(x))\n#define FILL(x,y) memset(x,y,sizeof(x))\n#define MM(x) memset(x,-1,sizeof(x))\n#define ALL(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef pair<long long,long long> PLL;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n///////////////////////////////////////////////\nconst ll MOD = 1000000007;\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////\n\n/*（๑•﹏•๑｀) */\n\n\nint main() {\n    static ll a[5002] = {};\n    static ll b[5002] = {};\n    int N;\n    ll A;\n    ll B;\n    ll ans = 0;\n\n\n    cin >> N >> A >> B;\n    FORq(i,1,N){\n        cin >> a[i];\n        b[a[i]] = i;\n    }\n\n    static ll dp[5003][10005] = {};\n    static ll dpS[5003][10005] = {};\n    REP(i,5003){\n        REP(j,10005){\n            if (i != 0) {\n                dp[i][j] = 1e16;\n                dpS[i][j] = 1e16;\n            }\n            else {\n                dp[i][j] = 0;\n                dpS[i][j] = 0;\n            }\n\n        }\n    }\n\n    FORq(i,1,N){\n        FORq(j,1,2*N+1){\n            ll mini = dpS[i-1][j];\n\n            if (j < b[i] * 2) dp[i][j] = mini + B;\n            if (j > b[i] * 2) dp[i][j] = mini + A;\n            if (j == b[i] * 2) dp[i][j] = mini;\n\n\n            dpS[i][j] = min(dpS[i][j-1],dp[i][j]);\n        }\n\n\n    }\n\n//    FORq(i,1,N){\n//        FORq(j,1,2*N+1){\n//            printf(\"dp[%d][%d] = %lld\\n\",i,j,dp[i][j]);\n//        }\n//    }\n    cout << dpS[N][2*N+1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nconst int maxN = 1e5 + 100;\n\nint n;\nint q[maxN + 1];\nLL x[maxN + 1], T, E, f[maxN + 1], ans;\n\nint main()\n{\n\tscanf(\"%d %lld %lld\", &n, &E, &T);\n\tfor(int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]), ans += x[i] - x[i - 1];\n\tans += E - x[n];\n\n\tint now = 0, head = 1, tail = 0;\n\tLL minT = 1e18; q[++ tail] = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\twhile(head <= tail && 2 * (x[i] - x[ q[head] + 1 ]) >= T) head ++;\n\t\twhile(now < i && 2 * (x[i] - x[now + 1]) >= T) \n\t\t\tminT = min(minT, f[now] - 2 * x[now + 1]), now ++;\n\t\tf[i] = minT + 2 * x[i];\n\t\tif(head <= tail) f[i] = min(f[i], f[ q[head] ] + T);\n\t\twhile(head <= tail && f[i] <= f[ q[tail] ]) tail --;\n\t\tq[++ tail] = i;\n\t}\n\n\tprintf(\"%lld\", ans + f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <cmath>\n#include <unordered_map>\n#include <cstdio>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long ll;\n\nll gcd(ll x, ll y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y) {\n\treturn x / gcd(x, y)*y;\n}\nll kai(ll x, ll y, ll m) {\n\tll res = 1;\n\tfor (ll i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nll mod_pow(ll x, ll y, ll m) {\n\tll res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll comb(ll x, ll y, ll m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nconst ll INF = 1000000000000000000;\n\nint n, a, b, p[5010], x[5010];\nint cum[5010][5010];\nll d[5010][5010];\nll ans = INF;\n\nsigned main() {\n\tstd::random_device rnd;\n\tstd::mt19937_64 mt(rnd());\n\tcin >> n >> a >> b;\n\tfor (int i = 1; i <= n; i++)cin >> p[i], x[p[i]] = i;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\tif (i < p[j])cum[i][j] = cum[i][j - 1] + 1;\n\t\telse cum[i][j] = cum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= n; i++)for (int j = 1; j <= i; j++)d[i][j] = INF;\n\td[1][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tll k = d[i][j];\n\t\t\tif (x[i + 1] < x[j])k += a;\n\t\t\tif (x[j] + 1 < x[i + 1])k += min((ll)b, (ll)a*(cum[i + 1][x[i + 1]] - cum[i + 1][x[j]]))\n\t\t\td[i + 1][j] = min(d[i + 1][j], k);\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tif (x[j] + 1 == x[i + 1])d[i + 1][i + 1] = d[i][j];\n\t\t\tif (x[j] < x[i + 1])cnt++;\n\t\t}\n\t\td[i + 1][i + 1] = min(d[i + 1][i + 1], (ll)cnt*a + (ll)(i - cnt)*b);\n\t}\n\tfor (int i = 1; i <= n; i++)ans = min(ans, d[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define REP(i, n) FOR(i, 0, (n))\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define LAR(a, b) ((a)=max((a),(b)))\n#define SML(a, b) ((a)=min((a),(b)))\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pair<int, int>> vpii;\ntypedef pair<int, int> pii;\n#define PB push_back\n#define EB emplace_back\n#ifdef LOCAL_DEBUG\n#define DEBUG(...) printf(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\n#define N 5123\nint n; ll aa, bb;\nint p[N], q[N];\nint s[N][N], t[N][N];\n\nll memo[N][N];\nll DP(int a, int b);\ninline ll dp(int a, int b){\n\tif(~memo[a][b]) return memo[a][b];\n\telse return memo[a][b]=DP(a, b);\n}\nll DP(int a, int b){\n\tll ret = 0;\n\tif(a<b){\n\t\tint c=s[a][b], d=t[a][b];\n\t\t// max -> right, aa\n\t\tll x=dp(a, b-1);\n\t\tif(q[b]<d){\n\t\t\tx+=aa;\n\t\t}\n\t\t// min -> left, bb\n\t\tll y=dp(a+1, b);\n\t\tif(c<q[a]){\n\t\t\ty+=bb;\n\t\t}\n\t\tDEBUG(\"[%d, %d]=>[%d, %d] %lld, %lld\\n\", a, b, c, d, x, y);\n\t\tret=min(x, y);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tREP(i, N) REP(j, N) memo[i][j]=-1;\n\tscanf(\"%d%lld%lld\", &n, &aa, &bb);\n\tFOR(i, 1, n+1){\n\t\tscanf(\"%d\", p+i);\n\t\tq[p[i]]=i;\n\t}\n\tFOR(i, 1, n+1){\n\t\ts[i][i]=t[i][i]=q[i];\n\t\tDEBUG(\"  [%d, %d]=>[%d, %d]\\n\", i, i, s[i][i], t[i][i]);\n\t\tFOR(j, i+1, n+1){\n\t\t\ts[i][j]=min(s[i][j-1], q[j]);\n\t\t\tt[i][j]=max(t[i][j-1], q[j]);\n\t\t\tDEBUG(\"  [%d, %d]=>[%d, %d]\\n\", i, j, s[i][j], t[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp(1, n));\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n  //can nlogn\n\tllint n,i,j,L,R;cin>>n>>L>>R;\n\tvector<llint>dp(n+1);\n\tstatic int pp[5001];\n\tfor(i=0;i<n;i++){cin>>pp[i];}\n\tdp[0]=0;\n\tfor(i=1;i<=n;i++){dp[i]=big;}\n\tfor(i=0;i<n;i++){\n\t\tint p=pp[i];\n\t\tfor(j=0;j<p;j++){mineq(dp[p],dp[j]);dp[j]+=L;}\n\t\tfor(j=p+1;j<=n;j++){dp[j]+=R;}\n\t\t//for(j=0;j<=n;j++){cerr<<dp[j]<<\" \";}cerr<<endl;\n\t}\n  \n\tllint ans=big;\n\tfor(i=0;i<=n;i++){mineq(ans,dp[i]);}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define MP make_pair\n#define PB push_back\nusing namespace std;\nnamespace io{\n\tconst int Sz=1<<13;\n\tchar ibuf[Sz],*ips=ibuf+Sz-1;\n\tinline int getchar(){\n\t\tif(++ips==ibuf+Sz)fread(ips=ibuf,1,Sz,stdin);\n\t\treturn *ips;\n\t}\n\tchar obuf[Sz],*ops=obuf;\n\tinline void flush(){\n\t\tfwrite(obuf,1,ops-obuf,stdout);\n\t\tops=obuf;fflush(stdout);\n\t}\n\tinline void putchar(int c){\n\t\tif(ops==obuf+Sz)flush();\n\t\t*ops=c,ops++;\n\t}\n\tvoid gets(char *s){\n\t\tint c=getchar();\n\t\twhile(c<=32)c=getchar();\n\t\twhile(c>32)*s=c,++s,c=getchar();\n\t\t*s=0;\n\t}\n\tvoid puts(const char *s){\n\t\twhile(*s)putchar(*s),++s;\n\t}\n}\n#define getchar io::getchar\n#define putchar io::putchar\n#define gets io::gets\n#define puts io::puts\nint read(){\n\tint x=0,f=1,c=getchar();\n\tfor(;c<48||c>57;c=getchar())\n\t\tif(c=='-')f=-f;\n\tfor(;c>=48&&c<=57;c=getchar())\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tint stk[20],tp=0;\n\tif(!x)putchar(48);\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)stk[tp++]=(x-x/10*10)^48;\n\tfor(;tp;)putchar(stk[--tp]);\n}\nstruct Flusher{~Flusher(){io::flush();}}flusher;\n// ------------------------- Template End ------------------------- //\nconst int N=5005;\nint n,A,B;\nint p[N],ps[N];\nll dp[N][N],mndp[N][N];\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nvoid chkmin(ll &x,ll y){if(y<x)x=y;}\nint main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=0;i<n;++i)p[i]=read(),ps[p[i]]=i;\n\tmemset(dp,0x3f,sizeof dp);dp[0][0]=0;\n\tmemset(mndp,0x3f,sizeof mndp);\n\tfor(int i=0;i<=n;++i)mndp[0][i]=0;\n\tfor(int i=1;i<=n;++i)for(int j=0;j<=n;++j){\n\t\tchkmin(dp[i][j],mndp[i-1][j]+(ps[i]==j?0:(ps[i]<j?A:B)));\n\t\tif(j)mndp[i][j]=mndp[i][j-1];chkmin(mndp[i][j],dp[i][j]);\n\t}\n\twrite(mndp[n][n]);putchar('\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 5005\ntypedef long long ll;\n\nint n, A, B;\nint a[N], b[N], s[N], g[N][N];\nll dp[N];\n\nint main() {\n    scanf(\"%d %d %d\", &n, &A, &B);\n    for (int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i ++) {\n        int j = i-1;\n        while (j>0&&a[j]<a[i]) j = b[j];\n        b[i] = j;\n    }\n    for (int i = 1; i <= n; i ++) {\n        int j = i-1;\n        while (j>0&&a[j]>a[i]) j = s[j];\n        s[i] = j;\n    }\n    for (int i = 1; i <= n; i ++) {\n        for (int j = 1; j <= n; j ++) g[i][j] = g[i-1][j];\n        for (int j = a[i]; j <= n; j ++) g[i][j] ++;\n    }\n    ll ans = 1e18;\n    dp[0] = 0;\n    for (int i = 1; i <= n; i ++) {\n\t\tdp[i] = 1e18;\n        for (int j = 0; j < i; j ++) if (a[j] < a[i]) {\n            int x = g[i-1][a[i]-1] - g[j][a[i]-1];\n            dp[i] = min(dp[i], dp[j] + 1ll * x * B + 1ll * (i-j-1-x) * A);\n        }\n        ans = min(ans, dp[i]+1ll*(n-i)*B);\n    }\n    printf(\"%I64d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// edge class (for network-flow)\ntemplate<class FLOWTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    Edge(int r, int f, int t, FLOWTYPE c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// graph class (for network-flow)\ntemplate<class FLOWTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE> &redge(Edge<FLOWTYPE> e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, 0));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, cap));\n    }\n};\n\ntemplate<class FLOWTYPE> struct Dinic {\n    const FLOWTYPE INF = 1LL<<60; // to be set\n    vector<int> level, iter;\n\n    Dinic() { }\n    void dibfs(Graph<FLOWTYPE> &G, int s) {\n        level.assign((int)G.size(), -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge<FLOWTYPE> &e = G[v][i];\n                if (level[e.to] < 0 && e.cap > 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    FLOWTYPE didfs(Graph<FLOWTYPE> &G, int v, int t, FLOWTYPE f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge<FLOWTYPE> &e = G[v][i], &re = G.redge(e);\n            if (level[v] < level[e.to] && e.cap > 0) {\n                FLOWTYPE d = didfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    re.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    FLOWTYPE solve(Graph<FLOWTYPE> &G, int s, int t) {\n        level.assign((int)G.size(), -1); iter.assign((int)G.size(), 0);\n        FLOWTYPE res = 0;\n        while (true) {\n            dibfs(G, s);\n            if (level[t] < 0) return res;\n            for (int i = 0; i < (int)iter.size(); ++i) iter[i] = 0;\n            FLOWTYPE flow = 0;\n            while ((flow = didfs(G, s, t, INF)) > 0) {\n                res += flow;\n            }\n        }\n    }\n};\n\n\n\n\nint N;\nlong long A, B;\nvector<int> P;\n\nint main() {\n    cin >> N >> A >> B;\n    P.resize(N);\n    for (int i = 0; i < N; ++i) cin >> P[i], --P[i];\n\n    Graph<long long> G(N*2 + 2);\n    int s = N*2, t = s+1;\n    for (int i = 0; i < N; ++i) {\n        G.addedge(s, i, A);\n        G.addedge(i+N, t, B);\n    }\n    for (int i = 0; i < N; ++i) {\n        for (int j = i+1; j < N; ++j) {\n            int u = P[i], v = P[j];\n            if (P[i] > P[j]) G.addedge(u, v+N, 1LL<<59);\n        }\n    }\n    Dinic<long long> din;\n    long long res = din.solve(G, s, t);\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ninline void chmin(ll &x, ll y) { if (x >= y) x = y; }\n\nll dp[5010][5010];\nconst ll INF = TEN(18);\n\nint main() {\n\tint N; ll A, B;\n\tcin >> N >> A >> B;\n\tvi p(N);\n\n\trep(i, N) {\n\t\tcin >> p[i];\n\t}\n\n\trep(i, 5010) {\n\t\trep(j, 5010) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\n\tdp[0][p[0]] = 0;\n\tdp[0][0] = A;\n\n\tfor (int i = 1; i < N; ++i) {\n\t\tdp[i][p[i]] = A * i;\n\t\trep(j, 5010) if (dp[i-1][j] != INF) { //skip\n\t\t\tchmin(dp[i][j], dp[i-1][j] + (p[i] < j ? B : A));\n\t\t}\n\t\t//fix\n\t\trep(j, p[i]) {\n\t\t\tchmin(dp[i][p[i]], dp[i-1][j]);\n\t\t}\n\t}\n\n\tll mini = INF;\n\trep(j, 5010) chmin(mini, dp[N-1][j]);\n\tcout << mini << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define reps(i, n) for (int i = 1; i <= (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T1, typename T2> bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct Setup {\n    static constexpr int PREC = 20;\n    Setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint N, A, B;\nint p[5500];\nint dp[5500][5500];\nsigned main() {\n    cin >> N >> A >> B;\n    reps(i, N) { cin >> p[i]; }\n    rep(i, 5500)rep(j, 5500) { dp[i][j] = 1e13; }\n    dp[0][0] = 0;\n    reps(i, N) {\n        for (int j = 0; j <= N; j++) {\n            if (j < p[i]) {\n                // そのまま集合に入れる\n                chmin(dp[i][p[i]], dp[i - 1][j]);\n                // 左に移す\n                chmin(dp[i][j], dp[i - 1][j] + A);\n            } else {\n                // 右に移す\n                chmin(dp[i][j], dp[i - 1][j] + B);\n            }\n        }\n    }\n    int ans = LLONG_MAX;\n    for (int i = 0; i <= N; i++) { chmin(ans, dp[N][i]); }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nll dp[5005][5005], p[5005][5005], n, a, b, loc[5005];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> a >> b;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> p[n-1][i];\n\t\tp[n-1][i]--;\n\t}\n\tloc[0] = 0;\n\tfor (int i = n-1; i >= 1; --i) {\n\t\tint ct = 0;\n\t\tfor (int j = 0; j < i+1; ++j) {\n\t\t\tif (p[i][j] != i) {\n\t\t\t\tp[i-1][ct] = p[i][j];\n\t\t\t\t++ct;\n\t\t\t} else\n\t\t\t\tloc[i] = j;\n\t\t}\n\t\t/* for (int j = 0; j < i; ++j)\n\t\t\tcout << p[i-1][j] << ' ';\n\t\tcout << endl; */\n\t}\n\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t//last j guys have free left moves\n\t\t\tif (i == 0) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i][j] = (1LL<<60);\n\t\t\tif (loc[i] >= i+1-j) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j-1]);\n\t\t\t\tdp[i][j] = min(dp[i][j], a + dp[i-1][j-1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][i-loc[i]]+b*(i-j-loc[i]));\n\t\t\t\tdp[i][j] = min(dp[i][j], a + dp[i-1][j]);\n\t\t\t}\n\t\t}\n\tcout << dp[n-1][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  int n;\n  cin >> n;\n  ll a, b;\n  cin >> a >> b;\n  vi p(n);\n  vi i2x(n);\n  rep (i, n) {\n    cin >> p[i];\n    i2x[p[i] - 1] = i;\n    p[i] = 2 * p[i];\n  }\n\n  vll dp(n + 1, vl(2 * n + 2, INF));\n  dp[0][0] = 0;\n  rep (i, n) {\n    int x = i2x[i];\n    x = (x + 1) * 2;\n    //DEBUG(x);\n    rep (j, 2*n + 1) {\n      if (dp[i][j] == INF) continue;\n      if (j < x) {\n        chmin(dp[i + 1][x], dp[i][j]);\n        if (j % 2 == 1) {\n          chmin(dp[i + 1][j], dp[i][j] + b);\n        }\n        else {\n          chmin(dp[i + 1][j + 1], dp[i][j] + b);\n        }\n      }\n      else {\n        if (j % 2 == 1) {\n          chmin(dp[i + 1][j], dp[i][j] + a);\n        }\n        else {\n          chmin(dp[i + 1][j + 1], dp[i][j] + a);\n        }\n      }\n    }\n  }\n  //DEBUG_MAT(dp);\n  ll ans = INF;\n  rep (i, 2 * n + 2) {\n    chmin(ans, dp[n][i]);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=5010;\nll f[N][N<<1];\nint n,a[N],x;\nll A,B;\nll pan(int x,int y)\n{\n\tif (x<y) return B;\n\telse if (x>y) return A;\n\telse return 0;\n}\nll pan1(int x,int y)\n{\n\tif (x-1>=y) return A;\n\telse return B;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tscanf(\"%lld%lld\",&A,&B);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&x),a[x]=i;\n\tfor (int i=1;i<=n;i++) {\n\t\tfor (int j=1;j<=n*2+1;j++) \n\t\t if (j%2==0) f[i][j]=f[i-1][j-1]+pan(j/2,a[i]);\n\t\t else f[i][j]=f[i-1][j]+pan1(j/2+1,a[i]);\n\t\tfor (int j=2;j<=n*2+1;j++) f[i][j]=min(f[i][j],f[i][j-1]); \n\t}\n\tll ans=10000000000000000;\n\tfor (int i=1;i<=n*2+1;i++) ans=min(ans,f[n][i]);\n\tcout << ans << endl;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5 * 1000 + 17;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\nint n;\nlong long A, B;\nint a[N];\nint L[N][N], R[N][N];\nlong long dp[N][N];\n\nbool read() {\n    if (!(cin >> n >> A >> B))\n        return false;\n\n    for (int i = 1; i <= n; ++i)\n        cin >> a[i];\n\n    return true;\n}\n\nint solve() {\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            L[a[i]][a[j]] = (j < i && a[j] > a[i]);\n            R[a[i]][a[j]] = (j > i && a[j] < a[i]);\n        }\n\n        for (int j = 1; j <= n; ++j) L[a[i]][j] += L[a[i]][j - 1];\n        for (int j = n; j >= 0; --j) R[a[i]][j] += R[a[i]][j + 1];\n    }\n\n    for (int l = 0; l <= n; ++l)\n        for (int r = 0; r <= n; ++r)\n            dp[l][r] = 1ll * MOD * MOD;\n\n    dp[0][0] = 0;\n\n    for (int cnt = 0; cnt < n; ++cnt)\n        for (int l = 0; l <= cnt; ++l) {\n            auto r = cnt - l;\n            dp[l + 1][r] = min(dp[l + 1][r], dp[l][r] + (L[l + 1][n - r] ? B : 0));\n            dp[l][r + 1] = min(dp[l][r + 1], dp[l][r] + (R[n - r][l + 1] ? A : 0));\n        }\n\n    auto ans = 1ll * MOD * MOD;\n\n    for (int l = 0; l <= n; ++l)\n        ans = min(ans, dp[l][n - l]);\n\n    cout << ans << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (read())\n        solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 5e3 + 5;\nint a[N], p[N], pos[N][N];\nlong long dp[N][N], A, B;\n\nlong long P(int i, int l, int r) {\n    return pos[i][r] - pos[i][l - 1] + 1;\n}\nint main() {\n    int n; cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) cin >> a[i], p[a[i]] = i;\n    for (int i = 1; i <= n; i++) {\n        pos[i][0] = 1;\n        for (int j = 1; j <= n; j++) pos[i][j] = pos[i][j - 1] + (p[j] < p[i]);\n    }\n    memset(dp, 63, sizeof dp);\n    dp[0][n + 1] = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = n + 1; j > i; j--) {\n            if (i >= 1) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] +\n                           min((P(i, i, j - 1) - 1) * A, B));\n            }\n            if (j <= n) {\n                dp[i][j] = min(dp[i][j], dp[i][j + 1] +\n                           min((j - i - P(j, i + 1, j)) * B, A));\n            }\n        }\n    }\n    long long ans = 1e18;\n    for (int i = 0; i <= n; i++) ans = min(ans, dp[i][i + 1]);\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n    \nvoid go();\n\nmain(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nvoid go(){\n    int n=in();\n    ll a=lin(),b=lin();\n    auto dp = vec2ll(n+2,n+10);\n    rep(i,n+1)rep(j,n+2)dp[i][j]=1e16;\n    vec p;rep(i,n)p.pb(in());\n    rep(j,n+2)dp[0][j]=0;\n    rep(i,n){\n        rep(j,n+2){\n            if( j < p[i]){\n                chmin(dp[i+1][j],dp[i][j] + a);\n                chmin(dp[i+1][p[i]],dp[i][j]);\n            }\n            else if(j > p[i]){\n                chmin(dp[i+1][j],dp[i][j]+b);\n            }\n        }\n    }\n    ll mi=1e16;\n    rep(i,n+1)chmin(mi,dp[n][i]);\n    cout<<mi<<endl;\n}\n    \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nll N, A, B;\nll p[5000];\ntemplate< typename flow>\nstruct max_flow {\n    struct edge {\n        int to;\n        flow cap;\n        int rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    max_flow(int V) : V(V) { G.assign(V,vector<edge>()); }\n\n    void add_edge(int from, int to, flow cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    flow dfs(int v, int t, flow f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                flow d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    flow run(int s, int t) {\n        flow ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, INF)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\n\nint main() {\n    cin >> N >> A >> B;\n    for(int i = 0; i < N; i++) cin >> p[i];\n    max_flow<ll> graph(2 * N + 2);\n    int s = 2 * N;\n    int t = 2 * N + 1;\n    for(int i = 0; i < N; i++) {\n        graph.add_edge(s, i, A);\n        graph.add_edge(i+N, t, B);\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = i + 1; j < N; j++) {\n            if(p[i] < p[j]) continue;\n            graph.add_edge(i, j + N, 1e14);\n        }\n    }\n    cout << graph.run(s, t) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll dp[5010][5010], _min[5010][5010];\nint n, A, B;\nint a[5010], pos[5010];\nint main() {\n    cin >> n >> A >> B;\n    for(int i = 1; i <= n; i++) cin >> a[i], pos[a[i]] = i;\n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j <= n; j++) {\n            if(j != pos[i]) {\n                dp[i][j] = _min[i - 1][j] + (j > pos[i] ? A : B);\n            }\n            else if(j == pos[i]) {\n                dp[i][j] = min(_min[i - 1][j] + B, _min[i - 1][j - 1]);\n            }\n            if(j == 0) _min[i][j] = dp[i][j];\n            else _min[i][j] = min(_min[i][j - 1], dp[i][j]);\n        }\n    }\n    return cout << _min[n][n] << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define pii pair<int, int>\n#define fr(n) for (int i = 0; i < n; i++)\n#define fr1(n) for (int i = 1; i <= n; i++)\nusing namespace std;\n\nint c[5003][5003], d[5003][5003];\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, p[5003] = {};\n    ll a, b, z[5003];\n    cin >> n >> a >> b;\n    fr1(n) cin >> p[i];\n    fr1(n) for (int j = 1; j <= n; j++) c[i][j] = c[i - 1][j] + (p[i] < j), d[i][j] = d[i - 1][j] + (p[i] > j);\n    fr1(n) z[i] = a * (i - 1);\n    fr1(n) for (int j = 1; j < i; j++) if (p[i] > p[j]) z[i] = min(z[i], z[j] + b * (c[i - 1][p[j]] - c[j][p[j]]) + a * (d[i - 1][p[i]] - d[j][p[i]]) + min(a, b) * (i - j - 1 - c[i - 1][p[j]] + c[j][p[j]] - d[i - 1][p[i]] + d[j][p[i]]));\n    fr1(n) z[i] += b * (n - i);\n    //fr1(n) cout << z[i] << ' ';\n    fr1(n) z[n] = min(z[n], z[i]);\n    cout << z[n];\n}\n"
  },
  {
    "language": "C++",
    "code": "// saihemanth9019\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n#define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define endl '\\n'\n#define vi vector<int>\n#define vs vector<string>\n#define vll vector<long long>\n#define vc vector<char>\n#define vs vector<string>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define pcc pair<char, char>\n#define pdd pair<double, double>\n#define mp make_pair\n#define F first\n#define S second\n#define pb(x) push_back(x)\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define foi(i,a,n) for(i = (a); i <= (n); i++)\n#define pd(x) cout<<x\n#define sd(x) cin>>x\n#define nl cout<<endl\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0)\n#define gcd __gcd\n#define clr(x) memset(x,0,sizeof(x))\n#define all(a) (a).begin(), (a).end()\n#define foreach(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); ++i)\n#define sz(a) (int)((a).size())\n//int a[25]= { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\n//ll fibonacci[2][2] = {{0,1},{1,1}};\n//ll identity[2][2] = {{1,0},{0,1}};\n\nint main() {\n    sws;\n\tll i,j,k;\n\tll n,a,b;\n\tcin>>n>>a>>b;\n\tvll v(n+2);\n\tv[0] = 0; v[n+1] = (n+1);\n\tfo(i,1,n+1) cin >> v[i];\n\tvll dp(n+2,INFLL);\n\tdp[0] = 0;\n\tfo(i,1,n+2) {\n\t\tll tmp = 0;\n\t\tfor(j=i-1;j>=0;j--) {\n\t\t\tif (v[j] < v[i]) {\n\t\t\t\tdp[i] = min(dp[i],dp[j]+tmp);\n\t\t\t\ttmp += b;\n\t\t\t} else {\n\t\t\t\ttmp += a;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n+1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\nconst ll MOD = 1000000007LL;\n\nll dp[1005][1005];\n// 数字iまで見たときに、iを絶対位置j番目に置くような場合の数\n\nint main() {\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n\n    ll n, a, b;\n    cin >> n >> a >> b;\n\n    ll p[n];\n    map <ll, int> pos;\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n        pos[p[i]] = i;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (j < pos[i]) dp[i][j] += b;\n            if (j > pos[i]) dp[i][j] += a;\n            if (j) dp[i][j] = min(dp[i][j], dp[i][j-1]);\n        }\n    }\n\n    cout << dp[n][n-1] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <assert.h>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 5005;\nconst ll INF = 1e18;\n\nint n,A,B;\nint p[MAXN];\n\nll ans;\nll f[MAXN][MAXN];\nll MIN[MAXN][MAXN];\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> n >> A >> B;\n\tfor (int v,i = 1;i <= n;i++)\n\t{\n\t\tcin >> v;\n\t\tp[v] = i;\n\t}\n\tans = INF;\n\tfor (int i = 0;i <= n;i++)\n\t\tfor (int j = 0;j <= n;j++)\n\t\t\tf[i][j] = MIN[i][j] = INF;\n\tf[0][0] = MIN[0][0] = 0;\n\tfor (int i = 1;i <= n;i++)\n\t\tfor (int j = 0;j <= n;j++)\n\t\t{\n\t\t\tif (j == p[i])\n\t\t\t\tf[i][j] = MIN[i - 1][j - 1];\n\t\t\telse if (j < p[i])\n\t\t\t\tf[i][j] = MIN[i - 1][j] + B;\n\t\t\telse\n\t\t\t\tf[i][j] = MIN[i - 1][j] + A;\n\t\t\tif (!j)\n\t\t\t\tMIN[i][j] = f[i][j];\n\t\t\telse\n\t\t\t\tMIN[i][j] = min(MIN[i][j - 1],f[i][j]);\n\t\t\tif (i == n)\n\t\t\t\tans = min(ans,f[i][j]);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register\n#define int long long\nusing namespace std; const int N=5010;\ninline int read()\n{\n    int s=0,w=1; char ch=getchar();\n    while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar(); return s*w;\n}\nint n,A,B,val[N];\nint dp[N][N],p[N];\nsigned main()\n{\n\tn=read(), A=read(), B=read();\n\tfor(ri int i=1;i<=n;i++) {int x=read(); p[x]=i; }\n\tfor(ri int i=1;i<=n;i++) for(ri int j=0;j<=n;j++) dp[i][j]=LONG_LONG_MAX/2;\n\tfor(ri int i=1;i<=n;i++)\n\t{\n\t\tfor(ri int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(p[i]==j)\n\t\t\t{\n\t\t\t\tdp[i][j]=min(dp[i-1][j-1],dp[i][j]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+(j<p[i]?B:A));\n\t\t}\n\t\tfor(ri int j=1;j<=n;j++) dp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass DRotationSort {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, A, B; cin >> N >> A >> B;\n        vector<int> P(N); cin >> P;\n        for (int &p: P) --p;\n        vector<int> I(N);\n        for (int i = 0; i < N; ++i) I[P[i]] = i;\n\n        vector2<int> F(N, N+1, 0);\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (I[i] > I[j]) {\n                    F[i][j+1] = 1;\n                }\n            }\n            for (int j = 0; j < N; ++j) {\n                F[i][j+1] += F[i][j];\n            }\n        }\n\n        vector2<ll> D(N+1, N+1, 1e18);\n        D[0][N] = 0;\n        for (int l = 0; l <= N; ++l) {\n            for (int r = N; r > l; --r) {\n                // move r-1 to right\n                D[l][r-1] = min(D[l][r-1], D[l][r] + A * (F[r-1][r-1] - F[r-1][l] != r - l - 1));\n\n\n                // move l to left\n                D[l+1][r] = min(D[l+1][r], D[l][r] + B * (F[l][r] - F[l][l+1] != 0));\n            }\n        }\n\n        ll ans = 1e18;\n        for (int l = 0; l < N; ++l) {\n            ans = min(ans, D[l][l]);\n        }\n        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDRotationSort solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<ctime>\n#include<cmath>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<string>\n#include<vector>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\n#define Rep(i,s,t) for(register int i=s;i<t;++i)\n#define go(x) for(register int e=las[x];e;e=nxt[e])\n#define re register\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define is insert\n#define es erase\n#define pii pair<int,int>\n#define ms(f,x) memset(f,x,sizeof f)\n#define mc(f,x) memcpy(f,x,sizeof f)\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define gi(x) read(x)\n#define gii(x,y) read(x),read(y)\n#define giii(x,y,z) read(x),read(y),read(z)\nnamespace IO{\n    #define gc getchar()\n    #define pc(x) putchar(x)\n    template<typename T>inline void read(T &x){\n        x=0;int f=1;char ch=gc;while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc;x*=f;return;\n    }\n    template<typename T>inline void write(T x=0){\n        T wr[51];wr[0]=0;if(x<0)pc('-'),x=-x;if(!x)pc(48);\n        while(x)wr[++wr[0]]=x%10,x/=10;while(wr[0])pc(48+wr[wr[0]--]);return;\n    }\n}\nusing IO::read;\nusing IO::write;\ntypedef long long ll;\ntypedef double db;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nconst int N=1e5+11;\nll tot,ans;\nint n,A,B;\nint p[N],las[N],nxt[N],s[N],pos[N],t[N];\ninline void ins(int x,int v){\n\tfor(;x;x-=x&-x)\n\t\ts[x]+=v;\n}\ninline int query(int x){\n\tint res=0;\n\tfor(;x<=n;x+=x&-x)\n\t\tres+=s[x];\n\treturn res;\n}\ninline void add(int x,int v){\n\tfor(;x<=n;x+=x&-x)\n\t\tt[x]+=v;\n}\ninline int ask(int x){\n\tint res=0;\n\tfor(;x;x-=x&-x)\n\t\tres+=t[x];\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&B,&A);\n\trep(i,1,n)\n\t\tscanf(\"%d\",p+i);\n\tans=1e18;\n\trep(i,0,n){\n\t\ttot=0;\n\t\trep(j,1,n)\n\t\t\tpos[p[j]]=j,t[j]=s[j]=0;\n\t\t//printf(\"now %d\\n\",i);\n\t\trep(j,1,i){\n\t\t\tint v=query(pos[j])+pos[j];\n\t\t\t//printf(\"%d %d\\n\",j,v);\n\t\t\tif(v!=j)tot+=A,ins(pos[j],1);\n\t\t}\n\t\t_rep(j,n,i+1){\n\t\t\tint v=ask(pos[j])+query(pos[j])+pos[j];\n\t\t\t//printf(\"%d %d\\n\",j,v);\n\t\t\tif(v!=j)tot+=B,add(pos[j],-1);\n\t\t}\n\t\t//printf(\"%lld\\n\",tot);\n\t\tans=min(ans,tot);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define rep(i, n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) do{}while(0)\n#endif\n\n\n\nvector<int> p;\nll n, a, b;\n\n\n/*\n\t右へ移動するコストA\n\t左へ移動するコストB\n\t移動しなかった数だけを選ぶと単調増加数列になる\n\t\n\tp0～piで移動しなかった数の最大値がj以下のとき、コストの最小値がdp[i][j]\n*/\n\nint main(){\n\tcin >> n >> a >> b;\n\tp.resize(n+1);\n\tp[0] = 0;\n\trep(i,n)\n\t\tcin >> p[i+1];\n\tn++;\n\t\n\t\n\tvector<ll> dp(n);\n\tfor ( int i = 1; i < n; i++ ){\n\t\tint pi = p[i];\n\t\tll dppi1 = dp[pi-1];\n\t\t\n\t\trep(j,n){\n\t\t\tif ( j < pi ){\n\t\t\t\tdp[j] += a;\n\t\t\t}\n\t\t\telse if ( j == pi ){\n\t\t\t\tdp[j] = dppi1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j] = min( dp[j]+b, dppi1 );\n\t\t\t}\n\t\t}\n\t\t\n\t\t//rep(k,n)\n\t\t//\tcout << dp[k] << \" \";\n\t\t//cout << endl;\n\t}\n\t\n\tcout << dp[n-1] << endl;\n\t\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (ll)x.size()\n#define f first\n#define s second\n#define MAXN 5010\n\nll P[MAXN];\nll indexof[MAXN];\nll mem[MAXN][MAXN];\nll N,A,B;\n\nll ask(ll i, ll j){\n\tif (mem[i][j] != -1)return mem[i][j];\n\tif (i == j)return mem[i][j] = 0;\n\tll can_left = 1;\n\tll ind = indexof[i];\n\tfor (ll k=1;k<ind;++k)if(P[k] >= i && P[k] <= j)can_left = 0;\n\n\tll can_right = 1;\n\tind = indexof[j];\n\tfor (ll k=ind+1;k<=N;++k)if(P[k] >= i && P[k] <= j)can_right = 0;\n\t// cout<<can_left<<' '<<can_right<<'\\n';\n\tll a = ask(i+1,j);\n\tif (!can_left) a += A;\n\tll b = ask(i,j-1);\n\tif (!can_right) b += B;\n\t// cout<<i<<' '<<j<<' '<<min(a,b)<<'\\n';\n\treturn mem[i][j] = min(a,b);\n}\n\nint main(){\n\tcin>>N>>A>>B;\n\tfor (ll i=1;i<=N;++i){\n\t\tcin>>P[i];\n\t\tindexof[P[i]] = i;\n\t}\n\n\tmemset(mem,-1,sizeof(mem));\n\n\tcout<<ask(1,N);\n\t// cout<<ask(3,4);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\nconst ll MOD = 1000000007LL;\n\nll dp[5005][5005];\n// 数字iまで見たときに、iを絶対位置j番目に置くような場合の数\n\nint main() {\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n\n    ll n, a, b;\n    cin >> n >> a >> b;\n\n    ll p[n];\n    map <ll, int> pos;\n    for (int i = 0; i < n; i++) {\n        cin >> p[i];\n        pos[p[i]] = i;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (j < pos[i]) dp[i][j] += b;\n            if (j > pos[i]) dp[i][j] += a;\n            if (j) dp[i][j] = min(dp[i][j], dp[i][j-1]);\n        }\n    }\n\n    cout << dp[n][n-1] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * \tThe way if it's all predetermined\n * \t\tAnd the way i should go all my life\n * \t\t\tI swear to go wherever will be\n * \t\t\t\t'Cause there'll be something to see and to find\n * \tI don't know the meaning of life\n * \t\tBut i know what's truly precious\n * \t\t\tThe way it's leading me to be in love\n * \t\t\t\tNo fear i can find me always in my heart\n * \tThe life it's not for comparing things\n * \t\tSo i hold both of light and shadow\n * \t\t\tThe rays of stars will bring me to you\n * \t\t\t\tThrought the dark night skies\n * \t\t\t\t\tSee the way to be shined\n * \tI dont know what's right for our lives\n * \t\tBut i know the truth of my love\n * \t\t\tThe way it feels our breaths at the wind\n * \t\t\t\tAnd the way i should go all my life\n * \t\t\t\t\tI swear to go wherever will be\n * \t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\tWill always in my heart\n * \t\t\t\t\t\t\t\tThus the grace i wouldn't have\n * \t\t\t\t\t\t\t\t\tWill always in my heart\n */\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#ifndef rd\n#define endl '\\n'\n#endif\n#ifdef rd\n#define trace(...) cout<<\"Line:\"<<__LINE__<<\" \"; __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n\tcout<<name<<\" : \"<<arg1<<endl;\n}\ntemplate<typename Arg1, typename ... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n\tconst char* comma=strchr(names+1,',');\n\tcout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";\n\t__f(comma+1,args...);\n}\n#else\n#define trace(...)\n#endif\n#define deb cout<<\"Line: \"<<__LINE__<<\" plz \"\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double f80;\n#define double long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define sz(x) ((long long)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\nconst ll infl=2e18;\nconst int infi=2e9;\nconst int mod=1e9+7;\ntypedef vector<int> vi;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;\nmt19937 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nauto clk=clock();\nint rng(int lim) {\n\tuniform_int_distribution<int> uid(0,lim-1);\n\treturn uid(rang);\n}\n\nint dp[5005][5005];\nint p[5005];\nint peb[5005];\nint bac[5005];\nvoid solve() {\n\tint n,a,b;\n\tcin>>n>>a>>b;\n\tfr(i,1,n) {\n\t\tcin>>p[i];\n\t}\n\tfr(i,1,n) {\n\t\tpeb[p[i]]=n+1;\n\t\tfr(j,1,i) {\n\t\t\tif(p[i]<p[j]) {\n\t\t\t\tpeb[p[i]]=min(peb[p[i]],p[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfr(i,1,n) {\n\t\tbac[p[i]]=0;\n\t\tfr(j,i,n) {\n\t\t\tif(p[j]<p[i]) {\n\t\t\t\tbac[p[i]]=max(bac[p[i]],p[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n+1; i++)\n\t\tfill(dp[i],dp[i]+n+2,infl);\n\tdp[0][n+1]=0;\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=n+1; j>1; j--) {\n\t\t\tif(peb[i+1]>=j) {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\t} else {\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n\t\t\t}\n\t\t\tif(bac[j-1]<=i) {\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\t} else\n\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]+a);\n\t\t}\n\t}\n//\tcout<<dp[]\n\tint ans=infl;\n\tfor(int i=0; i<=n; i++) {\n\t\tfor(int j=0; j<=n; j++) {\n\t\t\tif(i+1>=j)\n\t\t\t\tans=min(ans,dp[i][i+1]);\n\t\t}\n\t}\n\tassert(ans<infl);\n\tassert(ans<=(n-1)*a);\n\tassert(ans<=(n-1)*b);\n\tcout<<ans<<endl;\n}\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::high_resolution_clock::now().time_since_epoch().count());\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t\tsolve();\n#ifdef rd\n\tcerr<<endl<<endl<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * =template=.cpp\n * Copyright (C) 2017 hzw <hzw@huzhenweideMacBook.local>\n *\n * Distributed under terms of the MIT license.\n */\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<signal.h>\n#include<unistd.h>\n#define FR first\n#define SC second\n#define MP make_pair\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define pb push_back\n#define ws wss\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\nvoid read(int &x)\n{\n\tchar ch;int fu=1;\n\twhile ((ch=getchar())<=32);\n\tx=0;\n\tif (ch=='-') fu=-1;else x=ch-48;\n\twhile ((ch=getchar())>32) x=x*10+ch-48;\n\tx*=fu;\n}\ntemplate<class T> void upmax(T &a,T b) { if (a<b) a=b;}\ntemplate<class T> void upmin(T &a,T b) { if (a>b) a=b;}\n\n//---------template--------------\nconst int N=1000100,p=998244353;\nint c[7123],bit[7777];\nLL f[7777];\nint n,a,b;\nvoid C(int i) { for (;i<=n;i+=i&-i) bit[i]++;}\nint  Q(int i) { int res=0;for (;i;i-=i&-i) res+=bit[i];return res;}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&c[i]);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++) bit[j]=0;\n\t\tf[i]=1LL<<60;\n\t\tfor (int j=i-1,k=0;j>=0;j--)\n\t\t{\n\t\t//\tprintf(\"%d %d\\n\",i,j);\n\t\t\tint l=Q(c[j]);\n\t\t\tif (c[j]<c[i]&&l+k==i-j-1) { f[i]=min(f[i],f[j]+1LL*l*b+1LL*k*a);}\n\t\t\tif (j>0) C(c[j]);\n\t\t\tif (c[j]>c[i]) k++;\n\t\t}\n\t}\n\tLL ans=1LL<<60;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint flag=0;\n//\t\tprintf(\"%lld \",f[i]);\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (c[j]>c[i]) { flag=1;break;}\n\t\tif (flag) continue;\n\t\tans=min(ans,f[i]+1LL*(n-i)*b);\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define trav(a,x) for(auto &a:x)\n#define all(x) x.begin(),x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    ll aa, bb;\n    cin >> n >> aa >> bb;\n    vector<int> a(n);\n    rep(i,0,n) {\n        cin >> a[i];\n        --a[i];\n    }\n    vector<ll> dp(n);\n    rep(i,0,n) {\n        vector<ll> next(n);\n        rep(j,0,n) if(j!=a[i]) {\n            next[j] = dp[j];\n            if(a[i]<j) next[j]+=bb;\n            else next[j]+=aa;\n        }\n        ll best = LLONG_MAX;\n        rep(j,0,a[i]+1) best = min(best, dp[j]);\n        next[a[i]] = best;\n        swap(next,dp);\n    }\n    ll best = LLONG_MAX;\n    rep(i,0,n) best =min(best,dp[i]);\n    cout<<best<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll n,x,y,res=INF;\nvl a;\nvvl dp,L,R;\n\nvvl f(){\n\tvvl b(n,vl(n+1));\n\tfor(int i=0;i<n;i++){\n\t\tfor(auto j:a){\n\t\t\tif(j==i) break;\n\t\t\tb[i][j+1]++;\n\t\t}\n\t\tfor(int j=1;j<=n;j++) b[i][j]+=b[i][j-1];\n\t}\n\treverse(a.begin(),a.end());\n\treturn b;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n>>x>>y;\n\ta=vl(n);\n\tdp=vvl(n+1,vl(n+1,INF));\n\tfor(auto &i:a) cin>>i,i--;\n\tL=f(),R=f();\n\tdp[0][0]=0;\n\tfor(int r=0;r<=n;r++){\n\t\tfor(int l=0;l<n-r;l++){\n\t\t\tll t=dp[l][r];\n\t\t\tdp[l+1][r]=min(dp[l+1][r],t+(L[l][n-r]-L[l][l]==0?0:y));\n\t\t\tdp[l][r+1]=min(dp[l][r+1],t+(R[n-r-1][n-r]-R[n-r-1][l]==0?0:x));\n\t\t}\n\t\tres=min(res,dp[n-r][r]);\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n// スパーステーブルをまずは検討しよう\n#ifdef _MSC_VER\ninline unsigned int __builtin_clz(unsigned int x){unsigned long r;_BitScanReverse(&r,x);return 31-r;}\n#endif // _MSC_VER\ntemplate<class V> struct SparseTableMax { // [L,R)\n    const V def = -1;\n    inline V comp(V a, V b) { return max(a,b); }\n\n    int n; vector<V> a, b[20]; inline int __lg(int x) { return 32 - 1 - __builtin_clz(x); }\n    void init(vector<V> v) {\n        int nn = v.size(); n = 1; while (n < nn) n *= 2; a.resize(n);\n        rep(i, 0, 20) b[i].resize(n); rep(i, 0, nn) a[i] = v[i];\n\n        int d = 1 << __lg(n - 1), e = d << 1;\n        for (int h = 0, f; (f = 1 << h) <= d; ++h) {\n            for (int i = f, r = f << 1; i < e; i += r) {\n                b[h][i - 1] = a[i - 1];\n                for (int j = i - 2; j >= i - f; --j) b[h][j] = comp(b[h][j + 1], a[j]);\n                b[h][i] = a[i];\n                for (int j = i + 1; j < i + f; ++j) b[h][j] = comp(b[h][j - 1], a[j]);\n            }\n        }\n    }\n\n    V get(int L,int R){\n        assert(0<=L&&L<=R);\n        if(L==R)return def;R--;if(L==R)return a[L];int h=__lg(L^R);\n        return comp(b[h][L],b[h][R]);}};\ntemplate<class V> struct SparseTableMin { // [L,R)\n    const V def = inf;\n    inline V comp(V a, V b) { return min(a,b); }\n\n    int n; vector<V> a, b[20]; inline int __lg(int x) { return 32 - 1 - __builtin_clz(x); }\n    void init(vector<V> v) {\n        int nn = v.size(); n = 1; while (n < nn) n *= 2; a.resize(n);\n        rep(i, 0, 20) b[i].resize(n); rep(i, 0, nn) a[i] = v[i];\n\n        int d = 1 << __lg(n - 1), e = d << 1;\n        for (int h = 0, f; (f = 1 << h) <= d; ++h) {\n            for (int i = f, r = f << 1; i < e; i += r) {\n                b[h][i - 1] = a[i - 1];\n                for (int j = i - 2; j >= i - f; --j) b[h][j] = comp(b[h][j + 1], a[j]);\n                b[h][i] = a[i];\n                for (int j = i + 1; j < i + f; ++j) b[h][j] = comp(b[h][j - 1], a[j]);\n            }\n        }\n    }\n\n    V get(int L,int R){assert(0<=L&&L<=R);if(L==R)return def;R--;if(L==R)return a[L];int h=__lg(L^R);\n        return comp(b[h][L],b[h][R]);}};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N, A, B, P[5010];\nSparseTableMax<int> stmax;\nSparseTableMin<int> stmin;\n//---------------------------------------------------------------------------------------------------\nint rev[5010];\nll dp[5010][5010];\nll f(int L, int R) {\n    if (0 <= dp[L][R]) return dp[L][R];\n    if (L == R) return 0;\n\n    dp[L][R] = infl;\n\n    // ←\n    auto lft = stmin.get(L + 1, R + 1);\n    if (lft < rev[L]) chmin(dp[L][R], f(L + 1, R) + B);\n    else chmin(dp[L][R], f(L + 1, R));\n\n    // →\n    auto rht = stmax.get(L, R);\n    if (rev[R] < rht) chmin(dp[L][R], f(L, R - 1) + A);\n    else chmin(dp[L][R], f(L, R - 1));\n\n    return dp[L][R];\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> A >> B;\n    rep(i, 0, N) cin >> P[i];\n\n    rep(i, 0, N) rev[P[i]] = i;\n    vector<int> v(N + 1);\n    rep(i, 1, N + 1) v[P[i]] = rev[P[i]];\n    stmax.init(v);\n    stmin.init(v);\n\n    rep(i, 0, N + 1) rep(j, 0, N + 1) dp[i][j] = -1;\n    cout << f(1, N) << endl;\n\n    //rep(i, 1, N + 1) rep(j, i, N + 1) printf(\"dp[%d][%d] = %lld\\n\", i, j, f(i, j));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr ll INF=1000000000000000000;\nvoid solve(){\n    int n,a,b,p[5010],q[5010];\n    ll dp[5010][10010];\n    cin>>n>>a>>b;\n    rep(i,n){\n        cin>>p[i];\n        q[p[i]-1]=i+1;\n    }\n    rep(i,n+1)rep(j,2*n+2)dp[i][j]=INF;\n    dp[0][1]=0;\n    rep(i,n){\n        ll cur=INF;\n        for(int j=1;j<=2*n+1;j++){\n            if(j%2==1){\n                chmin(cur,dp[i][j]);\n                chmin(cur,dp[i][j-1]);\n            }\n            if(j>q[i]*2)chmin(dp[i+1][j],cur+a);\n            if(j<q[i]*2)chmin(dp[i+1][j],cur+b);\n            if(j==q[i]*2)chmin(dp[i+1][j],cur);\n        }\n    }\n    ll ans=INF;\n    rep(j,2*n+2)chmin(ans,dp[n][j]);\n    cout<<ans<<endl;\n}\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,f[5005];\nlong long dp[5005][5005];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++)\n    {\n        int x;\n        scanf(\"%d\",&x);\n        f[x]=i;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        int pos=f[i];\n        long long t=1e18;\n        for(int j=1;j<=n;j++)\n        {\n            int p;\n            if(pos==j) p=0;\n            else if(pos>j) p=b;\n            else p=a;\n            t=min(t,dp[i-1][j]);\n            dp[i][j]=t+p;\n        }\n    }\n    long long ans=1e18;\n    for(int i=1;i<=n;i++)\n        ans=min(ans,dp[n][i]);\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 5e3 + 20;\nconst int INF = 2e9;\nint MIN[MAXN][MAXN];\nint MAX[MAXN][MAXN];\nint BIG[MAXN][MAXN];\nint SMA[MAXN][MAXN];\nlint dp[MAXN][MAXN];\nlint n, A, B, p[MAXN];\ninline lint val1(int l, int r) {\n\treturn p[l] < MIN[l + 1][r] ? 0 : min(A, BIG[l][r] * B);\n}\ninline lint val2(int l, int r) {\n\treturn p[r] > MAX[l][r - 1] ? 0 : min(B, SMA[l][r] * A);\n}\ninline lint dfs(int l, int r) {\n\tif (~dp[l][r]) return dp[l][r];\n\tlint ret = 1e18;\n\tret = min(ret, dfs(l + 1, r) + val1(l, r));\n\tret = min(ret, dfs(l, r - 1) + val2(l, r));\n\treturn dp[l][r] = ret;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL), cout.tie(NULL);\n\tcin >> n >> A >> B;\n\tmemset(dp, -1, sizeof(dp));\n\trep (i, 1, n) {\n\t\tcin >> p[i];\n\t\tdp[i][i] = 0;\n\t}\n\trep (i, 1, n) {\n\t\tint Max = -INF;\n\t\tint Min = +INF;\n\t\trep (j, i, n) {\n\t\t\tMax = max(Max, int(p[j]));\n\t\t\tMin = min(Min, int(p[j]));\n\t\t\tMAX[i][j] = Max;\n\t\t\tMIN[i][j] = Min;\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\trep (j, i + 1, n) {\n\t\t\tBIG[i][j] = BIG[i][j - 1] + (p[j] < p[i]);\n\t\t}\n\t}\n\trep (j, 1, n) {\n\t\tper (i, j - 1, 1) {\n\t\t\tSMA[i][j] = SMA[i + 1][j] + (p[j] < p[i]);\n\t\t}\n\t}\n\tcout << dfs(1, n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nint N;\nll A,B;\nint p[5000];\nll dp[5000];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>N>>A>>B;\n    rep(i,0,N){\n        cin>>p[i];\n        p[i]--;\n    }\n    rep(i,0,N){\n        bool t=false;\n        int cnt=0;\n        int u;\n        rep(j,0,N){\n            if(p[j]>i&&j>0){\n                dp[j]=dp[j-1];\n            }\n            if(t&&p[j]<i){\n                cnt++;\n                dp[j]=min(A+dp[j], B*cnt+dp[u]);\n            }\n            if(p[j]==i){\n                u=j;\n                t=true;\n            }\n        }\n    }\n    cout <<dp[N-1]<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#define NDEBUG 1\n#endif\n#include<bits/stdc++.h>\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint number, leftMoveCost, rightMoveCost; std::cin>>number>>rightMoveCost>>leftMoveCost;\n\tstd::vector<int> data(number), pos(number);\n\tfor(int index=0;index<number;++index) {\n\t\tauto& item=data[index];\n\t\tstd::cin>>item;--item; \n\t\tpos[item]=index;\n\t}\n\n\tstd::vector<std::vector<int64_t>> f(number+1, std::vector<int64_t>(number+1, INT64_MAX));\n\tf[0][0]=0;\n\n\t// f[a][b]=minimum cost to move a smallest numbers to the left, and\n\t// b numbers at first indices(including those that may be moved to the left)\n\t// to an arbitrary position to the right)\n\tfor(int a=0;a<number;++a) {\n\t\tstd::vector<int> uncoveredSuffix(number+1);\n\t\tfor(int cur=0,index=number; index--;){\n\t\t\tuncoveredSuffix[index]=cur+=(data[index]>=a);\n\t\t}\n\n\n\t\tfor(int b=0;b<=number;++b) if(f[a][b]!=INT64_MAX) {\n\t\t\tauto const cur=f[a][b];\n\t\t\tf[a+1][b]=std::min(f[a+1][b], cur+leftMoveCost);\n\t\t\tauto const rightMoveCount=std::max(0,uncoveredSuffix[b]-uncoveredSuffix[pos[a]]);\n\t\t\tauto& next2=f[a+1][b+rightMoveCount];\n\t\t\tnext2=std::min(next2, cur+(int64_t)rightMoveCost*rightMoveCount);\n\t\t}\n\t}\n\n\tstd::cout<<*std::min_element(begin(f[number]),end(f[number]))<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n#include <cmath>\n#include <stdio.h>\n#include <functional>\n\nusing namespace std;\nusing ll = long long;\nusing ld = double;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll, ll>; //(x, y, dx, dy)\nconst ll INF = 1e17;\nconst ld eps = 1e-10;\nconst ll MOD = 1e9 + 7;\n\nconst double pi = acos(-1.0);\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll N, A, B;\n\tcin >> N >> A >> B;\n\tvector<ll> p(N);\n\tfor (int i = 0;i < N;i++) {\n\t\tcin >> p[i];\n\t\tp[i]--;\n\t}\n\tvector<ll> minimax(N, -1);\n\tfor (int base = 0;base < N;base++) {\n\t\tfor (int i = base + 1;i < N;i++) {\n\t\t\tif (p[i] < p[base])\n\t\t\t\tminimax[base] = max(minimax[base], p[i]);\n\t\t}\n\t}\n\tvector<vector<ll>> dp(N + 1, vector<ll>(N, INF));\n\tdp[0][0] = 0;\n\tfor (int i = 0;i < N;i++) {\n\t\tll nowmini = INF;\n\t\tfor (int j = 0;j < N;j++) { // jより小さいやつは飛ばす\n\t\t\tif (p[i] < j)\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + B);\n\t\t\telse {\n\t\t\t\tif (minimax[i] >= j)\n\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + A);\n\t\t\t\telse\n\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\tnowmini = min(nowmini, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\tdp[i + 1][p[i]] = min(dp[i + 1][p[i]], nowmini);\n\t}\n\tll ans = INF;\n\tfor (int i = 0;i < N;i++)\n\t\tans = min(ans, dp[N][i]);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef long double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst ll INF = 1ll << 60;\nconst int N = 5010;\nint n, A, B, per[N], mx[N], num[N], pla[N];\nll dp[N][N], ans;\nint main() {\n  read(n), read(A), read(B);\n  rep (i, 1, n) read(per[i]), pla[per[i]] = i;\n  memset(dp, 0x3f, sizeof dp);\n  dp[n][n] = 0;\n  ans = INF;\n  rrp (i, n, 1) {\n    rep (j, 1, n) {\n      num[j] = 0;\n      mx[j] = 0;\n      if (per[j] <= i) num[j] = 1, mx[j] = per[j];\n    }\n    rep (j, 2, n) mx[j] = max(mx[j], mx[j-1]);\n    rep (j, 2, n) num[j] += num[j-1];\n    rep (j, 1, n) {\n      int p = pla[mx[j]];\n      if (!p) {\n\tckmn(ans, dp[i][j]);\n\tcontinue;\n      }\n      if (mx[j] < i) ckmn(dp[i-1][j], dp[i][j]);\n      ckmn(dp[i-1][j], dp[i][j] + A);\n      ckmn(dp[i-1][p-1], dp[i][j] + 1ll * B * (num[j] - num[p]));\n    }\n  }\n  rep (i, 0, n) ckmn(ans, dp[i][0]), ckmn(ans, dp[0][i]);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main() {\n  int n;\n  ll a, b;\n  scanf(\"%d%lld%lld\", &n, &a, &b);\n  vector<ll> f(n + 1, 1ll << 55);\n  f[0] = 0;\n  for (int _ = 1; _ <= n; _++) {\n    int x;\n    scanf(\"%d\", &x);\n    vector<ll> g(n + 1, 1ll << 55);\n    for (int i = 0; i <= n; i++) if (f[i] != 1ll << 55) {\n      if (x > i) {\n        g[x] = min(g[x], f[i]);\n        g[i] = min(g[i], f[i] + a);\n      } else {\n        g[i] = min(g[i], f[i] + b);\n      }\n    }\n    f = g;\n  }\n  ll ans = f[0];\n  for (int i = 1; i <= n; i++) {\n    ans = min(ans, f[i]);\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int N=1005;\nint pos[N],g[N],a[N];\nLL f[N][N],ans;\nint n,A,B;\n\nvoid upmin(LL &x,LL y){if(y<x) x=y;}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",a+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpos[a[i]]=i;\n\t\tfor(int j=i-1;j;j--)\n\t\t\tif(a[j]>a[i]) g[i]++;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tf[i][j]=INT64_MAX;\n\tf[0][0]=0;\n\tfor(int i=0,tmp;i<n;i++)\n\t{\n\t\ttmp=pos[i+1];\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(j>g[tmp]) upmin(f[i+1][j-1],f[i][j]+A);\n\t\t\telse upmin(f[i+1][j],f[i][j]+B),upmin(f[i+1][g[tmp]],f[i][j]);\n\t}\n\tans=1e18;\n\tfor(int i=0;i<=n;i++)\n\t\tupmin(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define FORqr(i, m , n) for(int i = (n);i >=(m);--i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int (x); SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long (x); SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\n#define M0(x) memset(x,0,sizeof(x))\n#define FILL(x,y) memset(x,y,sizeof(x))\n#define MM(x) memset(x,-1,sizeof(x))\n#define ALL(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef pair<long long,long long> PLL;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n///////////////////////////////////////////////\nconst ll MOD = 1000000007;\nll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////\n\n/*（๑•﹏•๑｀) */\n\n\nint main() {\n    static ll a[5002] = {};\n    int N;\n    ll A;\n    ll B;\n    ll ans = 0;\n    static bool move[5002] = {};\n\n    cin >> N >> A >> B;\n    FORq(i,1,N){\n        cin >> a[i];\n    }\n\n\n    FORq(target,1,N){\n        int index;\n\n        FORq(i,1,N){\n            if (a[i] == target){\n                index = i;\n                break;\n            }\n        }\n\n        if (move[target]) break;\n\n        ll lcount = 0;\n        FORq(i,1,index-1){\n            if ((a[i] > target) and (!move[i])) lcount++;\n        }\n\n        ll nans = min(B,lcount * A);\n        if (lcount * A <= B){\n            FORq(i,1,index-1){\n                if (a[i] > target) move[i] = true;\n            }\n        }\n\n        ans = nans + ans;\n    }\n\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\nconst int maxn=5005;\nint n,a,b;\nll dp[maxn];\nint main(){\n    ios::sync_with_stdio(0);\n    memset(dp,0x3f,sizeof(dp));dp[0]=0;\n    cin>>n>>a>>b;\n    rep(i,1,n){\n        int num;cin>>num;\n        ll mi=1e18;\n        rep(j,0,num)mi=min(mi,dp[j]);\n        rep(j,0,num-1)dp[j]+=a;\n        rep(j,num+1,n)dp[j]+=b;\n        dp[num]=mi;\n    }\n    ll ans=1e18;\n    rep(i,1,n)ans=min(ans,dp[i]);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mino \"test\"\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n#define matrix vector<vector<ll>>\n#define FOR(i,a,b) for(int i=a; i<=b; i++)\n#define Down(i,a,b) for(int i=a; i>=b; i--)\n#define FOR_(i,a,b) for(int i=a; i<b; i++)\n#define turbo ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define oo 1e18\n\nconst int N = 5e3 + 5;\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\nint n;\nint a[N];\nll F[N][N];\nll A, B;\n\nvoid nhap()\n{\n    cin >> n >> A >> B;\n    FOR(i,1,n) cin >> a[i];\n\n    FOR(i,1,n) F[1][i] = oo;\n    F[1][a[1]] = 0;\n    F[1][0] = A;\n}\n\nvoid xuli()\n{\n    ll res = oo;\n    if(n == 1) res = 0;\n    FOR(i,2,n)\n    {\n        FOR(j,0,n) F[i][j] = oo;\n        FOR(j,0,n)\n        {\n            if(j > a[i]) F[i][j] = min(F[i][j], F[i-1][j] + B);\n            else if(j < a[i])\n            {\n                F[i][a[i]] = min(F[i][a[i]], F[i-1][j]);\n                F[i][j] = min(F[i][j], F[i-1][j] + A);\n            }\n            if(i == n) res = min(res, F[i][j]);\n        }\n    }\n    cout << res;\n}\n\nint main()\n{\n    //freopen(mino\".inp\",\"r\",stdin);\n    //freopen(mino\".out\",\"w\",stdout);\n    nhap();\n    xuli();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"d.in\", \"r\", stdin);\n  freopen(\"d.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    ++n;\n    vector<int> p(n );\n    for (int i = 1; i < n; i++) {\n      scanf(\"%d\", &p[i]);\n    }\n\n    vector<int> ps = p;\n    sort(ps.begin(), ps.end());\n\n    vector<ll> dp(n, a * 1LL * (n - 1));\n\n    for (int i = 0; i < n; i++) {\n      int from = find(ps.begin(), ps.end(), p[i]) - ps.begin();\n      ps.erase(ps.begin() + from);\n      for (int j = from; j < (int)ps.size(); j++) {\n        int v = ps[j];\n        if (v > p[i]) {\n          dp[v] = min(dp[v], dp[p[i]] - a + (b - a) * 1LL * (j - from));\n        }\n      }\n    }\n\n    printf(\"%lld\\n\", *min_element(dp.begin(), dp.end()));\n\n\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n#define int long long\nconst int N = 3e5 + 233;\nint n, A, B, a[N], dp[N];\nsigned main(void) {\n    read(n); read(A); read(B);\n    rep (i, n) read(a[i]);\n    memset(dp, 38, sizeof dp);\n    dp[0] = 0;\n    rep (i, n) {\n        int p = 0;\n        for (int k = i - 1; k >= 0; k--) {\n            a[k] > a[i] ? ++p : \n                dp[i] = min(dp[i], dp[k] + p * A + (i - k - 1 - p) * B);\n        }\n    }\n    cout << dp[n] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=5050;\nconst ll INF=1e16;\nint n,A,B,a[N];\nll ans,f[N][N];\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tFOR(i,1,n) scanf(\"%d\",&a[i]);\n\tFOR(i,0,n)FOR(j,0,n) f[i][j]=INF;\n\tf[0][0]=0;ans=INF;\n\tFOR(i,1,n){\n\t\tFOR(j,0,i-1){\n\t\t\tif(a[j]<a[i]){\n\t\t\t\tf[i][j]=min(f[i][j],f[i-1][j]+A);\n\t\t\t\tf[i][i]=min(f[i][i],f[i-1][j]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tf[i][j]=min(f[i][j],f[i-1][j]+B);\n\t\t}\n\t}\n\tFOR(i,1,n) ans=min(ans,f[n][i]);\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 5010;\n\ntypedef long long LL;\n\nint num[N]; LL dp[N];\n\nint main() {\n    int n, A, B; scanf(\"%d%d%d\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &num[i]);\n    memset(dp, 0x3f, sizeof(dp)), dp[0] = 0, num[n + 1] = n + 1, n++;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i - 1, l = 0, r = 0, mx = 0; j >= 0; j--) {\n            if (num[j] < num[i] && num[j] > mx) mx = num[j];\n            if (mx <= num[j] && num[j] < num[i]) \n                dp[i] = min(dp[i], dp[j] + (LL)l * B + (LL)r * A);\n            if (num[j] < num[i]) l++;\n            else r++;\n        }\n    }\n    printf(\"%lld\\n\", dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD=1e9+7;\n\n//const int MOD=998244353;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int n;\n    long long a,b;\n    cin>>n>>a>>b;\n    \n    vector<int> sp(n+1);\n    for(int i=1; i<=n; i++){\n        int x;\n        cin>>x;\n        sp[x]=i;\n    }\n    \n    vector<long long> dpCur(2*n+1), dpPrev(2*n+1);\n    \n    for(int i=0; i<=2*n; i++){\n        long long c=0;\n        int goal=2*sp[1]-1;\n        if(i!=goal){\n            c=i<goal?b:a;\n        }\n        dpPrev[i]=c;\n        if(i) dpPrev[i]=min(dpPrev[i],dpPrev[i-1]);\n    }\n    for(int i=2; i<=n; i++){\n        for(int j=0; j<=2*n; j++){\n            long long c=0;\n            int goal=2*sp[i]-1;\n            if(j!=goal){\n                c=j<goal?b:a;\n            }\n            dpCur[j]=(j%2?dpPrev[j-1]:dpPrev[j])+c;\n            if(j) dpCur[j]=min(dpCur[j],dpCur[j-1]);\n        }\n        dpPrev=dpCur;\n    }\n    cout<<dpCur[2*n];\n    \n    \n    \n    \n    \n    \n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nint n,a,b;\nint p[5001], f[10011], mn[10011], pos[5001];\n\nint32_t main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> n >> a >> b;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tcin >> p[i];\n\t\tpos[p[i]] = i*2;\n\t}\n\tmn[0] = 1e18;\n\tfor (int j=1;j<=n;j++)\n\t{\n    \tfor (int i=1;i<=2*n+1;i++)\n    \t{\n    \t\tint cost = 0;\n    \t\tif (i < pos[j]) cost = b;\n    \t\telse if (i > pos[j]) cost = a;\n    \t\tif (i%2 == 1)\n    \t\t\tf[i] = mn[i] + cost;\t\t\t\n    \t\telse\n    \t\t\tf[i] = mn[i-1] + cost;\n    \t}\n\t\tfor (int i=1;i<=2*n+1;i++)\n\t\t\tmn[i] = min(mn[i-1],f[i]);\n\t}\n\tcout << mn[2*n+1];\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#define N 5005\n#define ll long long\nusing namespace std;\nint n,a,b;\nint s[N];\nll f[N][N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&s[i]);\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tf[i][j]=1e15;\n\tf[0][0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(j<s[i]) f[i][s[i]]=min(f[i][s[i]],f[i-1][j]);\n\t\t\tif(j<s[i]) f[i][j]=min(f[i][j],f[i-1][j]+a);\n\t\t\tif(j>s[i]) f[i][j]=min(f[i][j],f[i-1][j]+b);\n\t\t}\n\t}\n\tll ans=1e15;\n\tfor(int i=1;i<=n;i++) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define int long long\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nll INF=1e18;\n\nll dp[5123][5123];\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,R,L;\n\t// n=5000; R=L=1000000000; --L;\n\tcin>>n>>R>>L;\n\tINF=ll(n-1)*min(L,R);\n\tvector<int> a(n); //rep(i,n) a[i]=n-1-i;\n\trep(i,n) cin>>a[i], --a[i];\n\tvector<int> toL(n),toR(n);\n\t{\n\t\tset<int> st{MOD};\n\t\trep(i,n){\n\t\t\ttoL[a[i]]=*st.lower_bound(a[i]);\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\t{\n\t\tset<int> st{-MOD};\n\t\trrep(i,n){\n\t\t\tauto it=st.lower_bound(a[i]); --it;\n\t\t\ttoR[a[i]]=*it;\n\t\t\tst.insert(a[i]);\n\t\t}\n\t}\n\t// out(toL,toR,1);\n\tfill(dp[0],dp[5123],INF);\n\tdp[0][n-1]=0;\n\trreps(d,2,n+1)rep(l,n+1-d){\n\t\tint r=l+d-1;\n\t\tMN(dp[l+1][r],dp[l][r]+(toL[l]>r?0:L));\n\t\tMN(dp[l][r-1],dp[l][r]+(toR[r]<l?0:R));\n\t}\n\t// rep(i,n){rep(j,n) cout<<dp[i][j]<<\",\";cout<<endl;}\n\tll re=INF;\n\trep(i,n) MN(re,dp[i][i]);\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n#define llong long long\nusing namespace std;\n \ninline int read()\n{\n    int x=0; bool f=1; char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=0;\n    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n    if(f) return x;\n    return -x;\n}\n \nconst int N = 5000;\nconst llong INF = 10000000000000000ll;\nint p[N+3],pp[N+3];\nllong dp[N+3][N+5],sdp[N+3][N+5];\nint n; llong arga,argb;\n \nvoid update(llong &x,llong y) {x = x<y?x:y;}\n \nint main()\n{\n    scanf(\"%d%lld%lld\",&n,&arga,&argb);\n    for(int i=1; i<=n; i++) {scanf(\"%d\",&p[i]); pp[p[i]] = i;}\n    for(int i=0; i<=n; i++) for(int j=0; j<=n; j++) dp[i][j] = INF;\n    for(int i=0; i<=n; i++) dp[0][i] = 0ll;\n    for(int i=1; i<=n; i++)\n    {\n        for(int j=0; j<=n; j++)\n        {\n            if(j==pp[i]) {update(dp[i][j],dp[i-1][j-1]);}\n            llong tmp = dp[i-1][j]+(j<pp[i]?argb:arga);\n            update(dp[i][j],tmp);\n        }\n        for(int j=1; j<=n; j++) dp[i][j] = min(dp[i][j-1],dp[i][j]);\n    }\n    llong ans = dp[n][n];\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N, A, B; cin >> N >> A >> B;\n    vec p(N); readv(p);\n\n    mat dp(N + 1, vec(N + 1, INF));\n    dp[0][0] = 0;\n    REP(i, N){\n        //REP(j, N + 1) dp[i + 1][j] = dp[i][j];\n        REP(j, N + 1){\n            if(j < p[i]) Min(dp[i + 1][p[i]], dp[i][j]);\n            if(j < p[i]) Min(dp[i + 1][j], dp[i][j] + A);\n            else Min(dp[i + 1][j], dp[i][j] + B);\n        }\n    }\n    int ans = INF;\n    REP(j, N + 1) Min(ans, dp[N][j]);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll INF = 1e18;\nconst int MAXN = 5007;\nll dp[MAXN][MAXN];\nint a[MAXN], p[MAXN];\nint main()\n{\n    int n; ll A, B; scanf(\"%d%lld%lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), p[a[i]] = i;\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j <= n; j++)\n            dp[i][j] = INF;\n    dp[0][0] = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        ll MIN = INF;\n        for (int j = 0; j <= n; j++) \n        {\n            MIN = min(MIN, dp[i - 1][j]);\n            if (j == p[i]) dp[i][p[i]] = min(dp[i][p[i]], MIN);\n            else if (j < p[i]) dp[i][j] = min(dp[i][j], MIN + B);\n            else dp[i][j] = min(dp[i][j], MIN + A);\n        }\n    }\n    // for (int i = 0; i <= n; i++)\n    //     for (int j = 0; j <= n; j++) printf(\"%lld%c\", dp[i][j], \" \\n\"[j == n]);\n    ll ans = INF;\n    for (int i = 0; i <= n; i++) ans = min(ans, dp[n][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define llong long long\nconst llong inf=0x3f3f3f3f3f3f3f3f;\nint n,A,B;\nint nu[5050];\nllong f[5050][5050];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&A,&B);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&nu[i]);\n    memset(f,0x3f,sizeof(f));\n    f[0][0]=0;\n    int x;\n    for(int i=0;i<n;++i)\n        for(int j=0;j<=n;++j)\n        {\n            if(f[i][j]==inf)continue;\n            x=nu[i+1];\n            if(j>x)f[i+1][j]=min(f[i+1][j],f[i][j]+B);\n            else\n            {\n                f[i+1][x]=min(f[i+1][x],f[i][j]);\n                f[i+1][j]=min(f[i+1][j],f[i][j]+A);\n            }\n        }\n    llong ans=inf;\n    for(int i=0;i<=n;++i)ans=min(ans,f[n][i]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MAX 5100000\nusing namespace std;\nusing Edge=pair<ll,ll>;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint main(){\n  ll N,A,B;\n  cin>>N>>A>>B;\n  vector<int> X(N);\n  REP(i,N){\n    int P;\n    cin>>P;\n    P--;\n    X[P]=i;\n  }\n  \n  vector<vector<ll>> DP(N+1,vector<ll>(N+1,INF));\n  REP(i,N+1) DP[0][i]=0;\n  \n  REP(i,N){\n    REP(j,N+1){\n      if(j>0) DP[i+1][j]=DP[i+1][j-1];\n      chmin(DP[i+1][j],DP[i][j]+(X[i]<=j-1 ? A : B));\n      if(X[i]==j-1) chmin(DP[i+1][j],DP[i][j-1]);\n    }\n  }\n  cout<<DP[N][N]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,x,y) for(ll i=x;i<y;i++)\n#define Rrep(i,y,x) for(ll i=y;i>x;i--)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll>\n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define UNIQUE_ARRAY(a,n) n = unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define print(x) cout << (x) << endl;\ntypedef long long ll;\nusing namespace std;\nll mod=1e9+7;\n\nint main(){\n    ll N,A,B;\n    ll inf=1e15;\n    cin>>N>>A>>B;\n    vector<vector<ll>> dp(N+1,vector<ll>(N+1,inf));\n    dp[0][0]=0;\n    vector<ll> P(N);\n    rep(i,0,N){\n        ll b;\n        cin>>b;\n        P.at(i)=b;\n    }\n    rep(i,1,N+1){\n        rep(j,0,N+1){\n            if (j < P[i-1]){\n                dp[i][P[i-1]]=min(dp[i][P[i-1]],dp[i-1][j]);\n                dp[i][j]=min(dp[i][j],dp[i-1][j]+A);\n            }\n            else{\n                dp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n            }\n        }\n    }\n    ll ans=inf;\n    rep(i,0,N+1){\n        ans=min(ans,dp[N][i]);\n    }\n    print(ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int N=5022;\nLL dp[N][N];\nint n,a,b,x[N],pos[N];\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]), pos[x[i]]=i;\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)dp[i][j]=1e18;\n    dp[0][0]=0;\n    for(int i=1;i<=n;i++){\n        LL mn=dp[i-1][0];\n        for(int j=0;j<=n+1;j++){\n            if(j==n+1)mn=min(mn,dp[i-1][j]);\n\n            if(j==pos[i]) dp[i][j]=mn;\n            else if(j<pos[i]) dp[i][j]=mn+min(1LL*b,1LL*a*(pos[i]-j));\n            else dp[i][j]=mn+min(1LL*a,1LL*b*(j-pos[i]));\n    \n            mn=min(mn,dp[i-1][j]);\n            //printf(\"dp[%d][%d]=%lld\\n\", i,j,dp[i][j]);\n        }\n    }\n    LL ans=1e18;\n    for(int i=0;i<=n+1;i++)ans=min(ans,dp[n][i]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"sse4\")\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ITER(it, a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = (LL)INF * INF;\n\nconst int MAX = 5007;\n\nLL dp[MAX][MAX];\nint p[MAX];\n\nvoid upd(LL& x, LL val)\n{\n\tx = min(x, val);\n}\n\nint main()\n{\n\t//ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n, a, b;\n\tcin >> n >> a >> b;\n\tFOR(i, 1, n + 1)\n\t\tcin >> p[i];\n\tFOR(i, 0, n + 1)\n\t\tFOR(j, 0, n + 1)\n\t\t\tdp[i][j] = LINF;\n\tdp[0][0] = 0;\n\tFOR(i, 0, n)\n\t\tFOR(j, 0, i + 1)\n\t\t{\n\t\t\tif(p[i + 1] > p[j])\n\t\t\t\tupd(dp[i + 1][i + 1], dp[i][j]);\n\t\t\tupd(dp[i + 1][j], dp[i][j] + (p[i + 1] > p[j] ? a : b));\n\t\t}\n\tLL ans = LINF;\n\tFOR(j, 0, n + 1)\n\t\tupd(ans, dp[n][j]);\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define INF (1LL<<50LL)\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n;\nll a,b;\n\nint main() {\n\tcin >> n >> a >> b;\n\tvector<ll> arr(5001);\n\tvector<ll> dp(5001);\n\tfor(int i = 0; i < n; i++) {\n\t\tint p;\n\t\tcin >> p;\n\t\tarr[p] = i+1;\n\t}\n\tfor(int num = 1; num <= n; num++) {\n\t\tint pos = arr[num];\n\t\tll temp_min = INF;\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\ttemp_min = min(temp_min,dp[i]);\n\t\t\tif(pos>i) {\n\t\t\t\tdp[i] = temp_min+b;\n\t\t\t}\n\t\t\tif(pos==i) {\n\t\t\t\tdp[i] = temp_min;\n\t\t\t}\n\t\t\tif(pos<i) {\n\t\t\t\tdp[i] = temp_min+a;\n\t\t\t}\n\t\t\t//cout << dp[i] << endl;\n\t\t}\n\t\t//cout << \"-----\" << endl;\n\t}\n\tll ans = INF;\n\tfor(int i = 0; i <= n; i++) {\n\t\tans = min(ans,dp[i]);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 5010;\ntypedef long long ll;\n\nint n, A, B, p[maxn], rp[maxn];\nll f[maxn][maxn];\nint sum[maxn], K[maxn][maxn], C[maxn][maxn];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &p[i]);\n\t\trp[p[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = n; j >= 1; j--) {\n\t\t\tK[i][j] = K[i][j+1];\n\t\t\tif (rp[j] >= i) K[i][j] = rp[j];\n\t\t}\n\t}\n\tfor (int j = 1; j <= n; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (p[i] >= j) sum[i] = sum[i-1] + 1;\n\t\t\telse sum[i] = sum[i-1];\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint k = K[i][j];\n\t\t\tif (k) {\n\t\t\t\tC[i][j] = sum[k]-sum[i-1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n; i >= 1; i--) {\n\t\tfor (int j = n; j >= 1; j--) {\n\t\t\tif (!K[i][j]) f[i][j] = 0;\n\t\t\telse {\n\t\t\t\tll c = C[i][j], k = K[i][j];\n\t\t\t\tf[i][j] = min(1ll*A*(c-1)+f[k+1][p[k]+1], B+f[i][p[k]+1]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[1][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define fi first\n#define se second\n#define pb push_back\n#define fastcin() ios_base::sync_with_stdio(0); cin.tie(0)\n#define all(x) (x).begin(), (x).end()\n#define heap priority_queue\nusing namespace std;\ntypedef pair<int, int> ii;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int maxn = 5065, INF = 1e18; \nint n, a, b, p[maxn], cnt[maxn][maxn]; \n\nint dp[maxn][maxn]; // first i elements are sorted, and the last element that remains in the same position is j. \n\nsigned main()\n{\n\tcin >> n >> a >> b; \n\tfor(int i = 1; i <= n; i++) \n\t \tcin >> p[i]; \n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tcnt[i][j] = cnt[i-1][j] + (p[i] <= j); \n\t\t}\n\t}\t\n\tfor(int i = 1; i <= n; i++) \n\t\tfor(int j = 1; j <= n; j++) \n\t\t\tdp[i][j] = INF; \n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif(p[i] >= j) {\n\t\t\t\tdp[i][j] = dp[i-1][j]; \n\t\t\t\tcontinue; \n\t\t\t} \n\t\t\tdp[i][j] = min(dp[i-1][j] + b, dp[i-1][p[i]] + a * (cnt[i][j] - cnt[i][p[i]])); \n\t\t}\n\t}\n\tcout << dp[n][n] << '\\n'; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nLL v[6000],p[6000],d[2][6000];\nint main(){LL N,L,R,k,b;\ncin>>N>>R>>L;\nfor(LL i=0;i<N;i++)cin>>v[i];\nfor(LL i=0;i<N;i++)p[v[i]]=i;\nfor(LL i=1;i<=N;i++){k=i&1;\nb=1e17;\nfor(LL j=0;j<=N+1;j++){\nb=min(b,d[k^1][j]);\nif(p[i]+1>j)d[k][j]=b+L;\nelse if(p[i]+1==j)d[i][j]=b;\nelse d[k][j]=b+R;}}\nR=1e17;\nfor(LL i=0;i<=N+1;i++)R=min(R,d[N&1][i]);\ncout<<r<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long dp[5100][5100];\nint p[5100];\nint at[5100];\nint RT[5100][5100];\nint LT[5100][5100];\nint X,Y;\nlong long calc(int a,int b){\n\tif(a>=b)return 0;\n\tif(~dp[a][b])return dp[a][b];\n\tlong long ret=inf;\n\tif(at[b]==RT[a][b]){\n\t\tret=min(ret,calc(a,b-1));\n\t}\n\tif(at[a]==LT[a][b]){\n\t\tret=min(ret,calc(a+1,b));\n\t}\n\tret=min(ret,calc(a,b-1)+X);\n\tret=min(ret,calc(a+1,b)+Y);\n\t\n\treturn dp[a][b]=ret;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);X=b;Y=c;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);p[i]--;\n\t\tat[p[i]]=i;\n\t}\n\tfor(int i=0;i<=a;i++)for(int j=0;j<=a;j++)\n\t\tdp[i][j]=-1;\n\tfor(int i=0;i<a;i++){\n\t\tint cur1=0;\n\t\tint cur2=a;\n\t\tfor(int j=i;j<a;j++){\n\t\t\tcur1=max(cur1,at[j]);\n\t\t\tcur2=min(cur2,at[j]);\n\t\t\tRT[i][j]=cur1;\n\t\t\tLT[i][j]=cur2;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",calc(0,a-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>\n\n#define int long long\n\nint n, a, b;\n\nint solve(vector <int> v) {\n\tif (v.size() <= 1)\n\t\treturn 0;\n\tvector <int> sml, el, big;\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] < v[0])\n\t\t\tsml.push_back(v[i]);\n\t\telse\n\t\t\tbig.push_back(v[i]);\n\t\tel.push_back(v[i]);\n\t}\n\treturn min((int)sml.size() * b + solve(big), a + solve(el));\n}\n\nint32_t main() {\n\tmakefast;\n\tcin >> n >> a >> b;\n\tvector <int> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tint t;\n\t\tcin >> t;\n\t\tv.push_back(t);\n\t}\n\tcout << solve(v);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<int> seg;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++) seg[i] = 0;\n\t}\n\t\n\tvoid update(int i, int val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = seg[i*2] + seg[i*2+1];\n\t\t}\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif(b < l || r < a) return 0;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn lval + rval;\n\t}\n\tint query(int a, int b)\n\t{\n\t\tif(a > b) return 0;\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nllint n;\nllint a, b;\nllint p[5005], pos[5005];\nllint dp[5005][5005];\nSegTree seg(13);\n\nint main(void)\n{\n\tcin >> n >> a >> b;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> p[i];\n\t\tpos[p[i]] = i;\n\t}\n\t\n\tfor(int i = 1; i <= n; i++) seg.update(i, 1);\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tdp[i][j] = inf;\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tif(pos[i+1] <= j) dp[i+1][j] = min(dp[i+1][j], dp[i][j]);\n\t\t\telse{\n\t\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + b);\n\t\t\t\tdp[i+1][pos[i+1]] = min(dp[i+1][pos[i+1]], dp[i][j] + a*seg.query(j+1, pos[i+1]-1));\n\t\t\t}\n\t\t}\n\t\tseg.update(pos[i+1], 0);\n\t}\n\t\n\t/*for(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\t\n\tllint ans = inf;\n\tfor(int i = 0; i <= n; i++) ans = min(ans, dp[n][i]);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst long long mod = 1000000007;\nconst long long inf = 1ll<<61;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\ntypedef pair<int, PP> PPP;\nstruct edge { int to; int to2; int cost; };\nint p[5005];\nvector<P>V;\nint dp[5005][5005];\nint rmin[5005];\nsigned main() {\n\tint n, a, b; cin >> n >> a >> b;\n\trep(i, n)cin >> p[i];\n\trep(i, n)V.push_back(P(p[i], i));\n\tsort(V.begin(), V.end());\n\trep(i, 5005)rep(j, 5005)dp[i][j] = inf;\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint pos = V[i - 1].second;\n\t\trep(j, n + 1)rmin[j] = dp[i - 1][j];\n\t\trep(j, n)rmin[j + 1] = min(rmin[j], rmin[j + 1]);\n\t\trep(j, n + 1) {\n\t\t\tif (j == pos)dp[i][j] = rmin[j];\n\t\telse if (j < pos) {\n\t\t\tdp[i][j] = rmin[j] + b;\n\t\t}\n\t\telse {\n\t\t\tdp[i][j] = rmin[j] + a;\n\t\t}\n\t\t}\n\t}\n\tint ans = inf;\n\trep(i, n + 1)ans = min(ans, dp[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<ctime>\n#include<cmath>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<string>\n#include<vector>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\n#define Rep(i,s,t) for(register int i=s;i<t;++i)\n#define go(x) for(register int e=las[x];e;e=nxt[e])\n#define re register\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define is insert\n#define es erase\n#define pii pair<int,int>\n#define ms(f,x) memset(f,x,sizeof f)\n#define mc(f,x) memcpy(f,x,sizeof f)\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define gi(x) read(x)\n#define gii(x,y) read(x),read(y)\n#define giii(x,y,z) read(x),read(y),read(z)\nnamespace IO{\n    #define gc getchar()\n    #define pc(x) putchar(x)\n    template<typename T>inline void read(T &x){\n        x=0;int f=1;char ch=gc;while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc;x*=f;return;\n    }\n    template<typename T>inline void write(T x=0){\n        T wr[51];wr[0]=0;if(x<0)pc('-'),x=-x;if(!x)pc(48);\n        while(x)wr[++wr[0]]=x%10,x/=10;while(wr[0])pc(48+wr[wr[0]--]);return;\n    }\n}\nusing IO::read;\nusing IO::write;\ntypedef long long ll;\ntypedef double db;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nconst int N=5011;\nint n,A,B;\nint p[N],b[N],c[N],s[N],pos[N];\nll dp[N][N];\ninline void ins(int x){\n\t++x;\n\tfor(;x<=n+1;x+=x&-x)\n\t\t--s[x];\n}\ninline int query(int x){\n\tint res=0;\n\t++x;\n\tfor(;x;x-=x&-x)\n\t\tres+=s[x];\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\trep(i,1,n)\n\t\tscanf(\"%d\",p+i),pos[p[i]]=i;\n\trep(i,0,n+1)\n\t\trep(j,0,n+1)\n\t\t\tdp[i][j]=1e18;\n\tdp[0][n+1]=0;\n\tll ans=1e18;\n\trep(i,0,n){\n\t\tif(i)\n\t\t\t--c[pos[i]],++c[i];\n\t\trep(j,1,n+2)\n\t\t\tb[j]=b[j-1]+c[j],s[j]=0;\n\t\t_rep(j,n+1,i+2){\n\t\t\tif(j!=n+1)ins(pos[j]);\n\t\t\t\t//printf(\"%d %d %d\\n\",i,j-1,pos[j-1]+b[pos[j-1]]+query(pos[j-1]));\n\t\t\t\tif(pos[j-1]+b[pos[j-1]]+query(pos[j-1])==j-1)\n\t\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\t\telse\n\t\t\t\t\tdp[i][j-1]=min(dp[i][j-1],dp[i][j]+A);\n\t\t\t\n\t\t\t\tif(pos[i+1]+b[pos[i+1]]+query(pos[i+1])==i+1)\n\t\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\t\telse\n\t\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+B);\n\t\t\t\n\t\t}\n\t}\n\t//rep(i,0,n)\n\t//\trep(j,i+1,n)\n\t//\t\tprintf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\trep(i,0,n)\n\t\tans=min(ans,dp[i][i+1]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n#define int long long\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nint A, B;\n\nsigned main() {\n\tscan n, A, B;\n\tvector<int> p(n);\n\tscan p;\n\tapply(p, x--);\n\tvector<int> at(n);\n\tf(i, n) {\n\t\tat[p[i]] = i;\n\t}\n\n\tvector<vector<int>> less(n, vector<int>(n + 1));\n\tfor (int i = 0; i < n; i++) {\n\t\tint offset = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (p[j] < p[i]) {\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\tless[i][n] = offset;\n\t\tfor (int j = n - 1; j > -1; j--) {\n\t\t\tless[i][j] = less[i][j + 1] + (at[j] < i);\n\t\t}\n\t}\n\n\tvector<vector<int>> greater(n, vector<int>(n + 1));\n\tfor (int i = 0; i < n; i++) {\n\t\tint offset = 0;\n\t\tfor (int j = n - 1; j > i; j--) {\n\t\t\tif (p[j] > p[i]) {\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\tgreater[i][0] = offset;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tgreater[i][j] = greater[i][j - 1] + (at[j - 1] > i);\n\t\t}\n\t}\n\n\n\tvector<vector<int>> dp(n + 2, vector<int>(n + 2, 1e14));\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\t{\n\t\t\t\tint w = B;\n\t\t\t\tif (at[i] == less[at[i]][n - j]) {\n\t\t\t\t\tw = 0;\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j] = min(dp[i][j] + w, dp[i + 1][j]);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint w = A;\n\t\t\t\tif (n - 1 - at[n - j - 1] == greater[at[n - j - 1]][i]) {\n\t\t\t\t\tw = 0;\n\t\t\t\t}\n\t\t\t\tdp[i][j + 1] = min(dp[i][j] + w, dp[i][j + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tint final = 1e14;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfinal = min(final, dp[i][n - i]);\n\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region kyopro_template\n#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x, v) for (auto &x : v)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define mem(a, val) memset(a, val, sizeof(a))\n#define ini(...)   \\\n  int __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inl(...)         \\\n  long long __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define ins(...)      \\\n  string __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inc(...)    \\\n  char __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define in2(s, t)                           \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i]);                         \\\n  }\n#define in3(s, t, u)                        \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i]);                   \\\n  }\n#define in4(s, t, u, v)                     \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i], v[i]);             \\\n  }\n#define rep(i, N) for (long long i = 0; i < (long long)(N); i++)\n#define repr(i, N) for (long long i = (long long)(N)-1; i >= 0; i--)\n#define rep1(i, N) for (long long i = 1; i <= (long long)(N); i++)\n#define repr1(i, N) for (long long i = (N); (long long)(i) > 0; i--)\nusing namespace std;\nvoid solve();\nusing ll = long long;\ntemplate <class T = ll>\nusing V = vector<T>;\nusing vi = vector<int>;\nusing vl = vector<long long>;\nusing vvi = vector<vector<int>>;\nusing vd = V<double>;\nusing vs = V<string>;\nusing vvl = vector<vector<long long>>;\nusing P = pair<long long, long long>;\nusing vp = vector<P>;\nusing pii = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nconstexpr int inf = 1001001001;\nconstexpr long long infLL = (1LL << 61) - 1;\ntemplate <typename T, typename U>\ninline bool amin(T &x, U y) {\n  return (y < x) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\ninline bool amax(T &x, U y) {\n  return (x < y) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\nll ceil(T a, U b) {\n  return (a + b - 1) / b;\n}\nconstexpr ll TEN(int n) {\n  ll ret = 1, x = 10;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x;\n    n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  int s = (int)v.size();\n  for (int i = 0; i < s; i++) os << (i ? \" \" : \"\") << v[i];\n  return os;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (auto &x : v) is >> x;\n  return is;\n}\nvoid in() {}\ntemplate <typename T, class... U>\nvoid in(T &t, U &... u) {\n  cin >> t;\n  in(u...);\n}\nvoid out() { cout << \"\\n\"; }\ntemplate <typename T, class... U>\nvoid out(const T &t, const U &... u) {\n  cout << t;\n  if (sizeof...(u)) cout << \" \";\n  out(u...);\n}\ntemplate <typename T>\nvoid die(T x) {\n  out(x);\n  exit(0);\n}\n\n#ifdef NyaanDebug\n#include \"NyaanDebug.h\"\n#define trc(...)                   \\\n  do {                             \\\n    cerr << #__VA_ARGS__ << \" = \"; \\\n    dbg_out(__VA_ARGS__);          \\\n  } while (0)\n#define trca(v, N)       \\\n  do {                   \\\n    cerr << #v << \" = \"; \\\n    array_out(v, N);     \\\n  } while (0)\n#define trcc(v)                             \\\n  do {                                      \\\n    cerr << #v << \" = {\";                   \\\n    each(x, v) { cerr << \" \" << x << \",\"; } \\\n    cerr << \"}\" << endl;                    \\\n  } while (0)\n#else\n#define trc(...)\n#define trca(...)\n#define trcc(...)\nint main() { solve(); }\n#endif\n\nstruct IoSetupNya {\n  IoSetupNya() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cerr << fixed << setprecision(7);\n  }\n} iosetupnya;\n\ninline int popcnt(unsigned long long a) { return __builtin_popcountll(a); }\ninline int lsb(unsigned long long a) { return __builtin_ctzll(a); }\ninline int msb(unsigned long long a) { return 63 - __builtin_clzll(a); }\ntemplate <typename T>\ninline int getbit(T a, int i) {\n  return (a >> i) & 1;\n}\ntemplate <typename T>\ninline void setbit(T &a, int i) {\n  a |= (1LL << i);\n}\ntemplate <typename T>\ninline void delbit(T &a, int i) {\n  a &= ~(1LL << i);\n}\ntemplate <typename T>\nint lb(const vector<T> &v, const T &a) {\n  return lower_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nint ub(const vector<T> &v, const T &a) {\n  return upper_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nvector<T> mkrui(const vector<T> &v) {\n  vector<T> ret(v.size() + 1);\n  for (int i = 0; i < int(v.size()); i++) ret[i + 1] = ret[i] + v[i];\n  return ret;\n};\n\ntemplate <typename T>\nvector<T> mkuni(const vector<T> &v) {\n  vector<T> ret(v);\n  sort(ret.begin(), ret.end());\n  ret.erase(unique(ret.begin(), ret.end()), ret.end());\n  return ret;\n}\n\ntemplate <typename F>\nvector<int> mkord(int N, F f) {\n  vector<int> ord(N);\n  iota(begin(ord), end(ord), 0);\n  sort(begin(ord), end(ord), f);\n  return ord;\n}\n\n#pragma endregion\n\nconstexpr long long MOD = /** 1000000007;  //*/ 998244353;\n\nll dp[5050][5050];\n\nvoid solve() {\n  inl(N, A, B);\n  vi p(N);\n  in(p);\n\n  rep(i, N + 1) rep(j, N + 1) dp[i][j] = infLL;\n\n  dp[0][0] = 0;\n  rep(i, N + 1) rep(j, N + 1) {\n    if(dp[i][j] == infLL)continue;\n    trc(i,j,dp[i][j]);\n    if(i == N) continue;\n    // 使う\n    if(j < p[i]){\n      amin(dp[i + 1][p[i]], dp[i][j]);\n    }\n    // 使わない\n    if(j < p[i]) amin(dp[i+1][j], dp[i][j] + A);\n    else amin(dp[i+1][j], dp[i][j] + B);\n  \n  }\n  ll ans = infLL;\n  rep(j,N+1) amin(ans, dp[N][j]);\n  out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5005;\nlong long s[N],p[N],f[N];\nint n,A,B;\nint main(){\n\tmemset(f,23,sizeof(f));\n\tscanf(\"%d%d%d\",&n,&A,&B),f[0]=0;\n\tfor(int i=1,x;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(j)\tp[j]=min(p[j-1],f[j]);\n\t\t\telse\tp[j]=f[j];\n\t\tfor(int j=0;j<=x;j++)\tf[j]+=A;\n\t\tfor(int j=x+1;j<=n;j++)\tf[j]+=B;\n\t\tf[x]=min(f[x],p[x]);\n\t}\n\tlong long ans=f[n+1];\n\tfor(int i=0;i<=n;i++)\tans=min(ans,f[i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define y1 A2Dalek\n#define y0 Cyberman\n#define yn RoseTyler\n#define j1 JackHarkness\n#define fs first\n#define sd second\nconst int N=5000;\nconst long long oo=1e16+5;\nint du[]={-1,0,0,1};\nint dv[]={0,-1,1,0};\nconst long long mod=1e9+7;\ntypedef pair<int,int> ii;\ntypedef pair<int,ii> iii;\nlong long sqr(long long x) {return x*x;}\nint getbit(int state, int i) {return ((state>>i)&1);}\n\nint n,a[N+5];\nlong long A,B,f[N+5];\nint main()\n{\n\t//freopen(\"Rotation Sort.inp\",\"r\",stdin);\n\t//freopen(\"Rotation Sort.out\",\"w\",stdout);\n\tios_base::sync_with_stdio(false);\n    cin>>n>>A>>B;\n    for (int i=1;i<=n;i++) cin>>a[i];\n    a[n+1]=n+1; n++;\n    for (int i=1;i<=n;i++)\n    {\n        f[i]=oo;\n        int dem1=0, dem2=0;\n        for (int j=i-1;j>=0;j--)\n        {\n            if (a[j]<a[i]) f[i]=min(f[i],f[j]+dem1*B+dem2*A);\n            if (a[j]<a[i]) dem1++; else dem2++;\n        }\n    }\n    cout<<f[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint n;\nint a[5005];\nint A, B;\nconst long long inf = 1e16;\nlong long mem[5005][5005];\n\nlong long dp(int cur, int last) {\n\tif(cur == n + 1) return 0;\n\tlong long &ans = mem[cur][last];\n\tif(ans != -1) return ans;\n\tans = inf;\n\tif(last < a[cur]) {\n\t\tans = min(ans, dp(cur + 1, a[cur]));\n\t\tans = min(ans, dp(cur + 1, last) + A);\n\t} else {\n\t\tans = min(ans, dp(cur + 1, last) + B);\n\t}\n\treturn ans;\n}\n\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d %d %d\", &n, &A, &B);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tmemset(mem, -1, sizeof mem);\n\tprintf(\"%lld\\n\", dp(1, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define ll long long\nusing namespace std;\n\nint n,a,b,p[5005];\nll dp[5005][5005];\n\nint main() {\n\t#ifdef kvutxdy\n\tfreopen(\"C:/Users/khanh/OneDrive/RoadtoPurple/Code/Codeforces/input.in\", \"r\", stdin);\n\t#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcin>>n>>a>>b;\n\tfor(int i=1;i<=n;++i){\n\t\tint x;\n\t\tcin>>x;\n\t\tp[x]=i;\n\t}\n\tmemset(dp,0x20,sizeof dp);\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<i;++j)\n\t\t\tif(p[i]>p[j]){\n\t\t\t\tdp[i][i]=min(dp[i][i],dp[i-1][j]);\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+b);\n\t\t\t}\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+a);\n\tcout<<*min_element(dp[n],dp[n]+n+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst long long inf = 1LL << 62;\nint main() {\n\tint N, A, B;\n\tcin >> N >> A >> B;\n\tvector<int> p(N);\n\tfor (int i = 0; i < N; ++i) cin >> p[i], --p[i];\n\tvector<long long> dp(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long nxt = inf;\n\t\tfor (int j = 0; j <= p[i]; ++j) {\n\t\t\tnxt = min(nxt, dp[j]);\n\t\t}\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (j < p[i]) dp[j] += A;\n\t\t\telse dp[j] += B;\n\t\t}\n\t\tdp[p[i]] = min(dp[p[i]], nxt);\n\t}\n\tcout << *min_element(dp.begin(), dp.end()) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cassert>\n#include <vector>\n\nusing namespace std;\n\nint N, M;\nconst int K = 4;\n\nstruct Node {\n  int n;\n  int adj[K];\n  int edge[K];\n\n  void Add(int a, int e) {\n    if (n < K) {\n      adj[n] = a;\n      edge[n] = e;\n    }\n    ++n;\n  }\n\n  int Next() const;\n};\n\nNode node[100020];\nint color[100020];\nbool visit[100020];\n\nint D = 0;\n\nint Node::Next() const {\n  for (int i = 0; i < n; ++i) {\n    int ii = (i+D)%K;\n    if (color[edge[ii]] < 0) {\n      return ii;\n    }\n  }\n  return -1;\n}\n\nint Solve() {\n  int cnt = 0;\n  vector<int> up{0};\n  int lv = 1;\n  while (!up.empty()) {\n    vector<int> st{up.back()};\n    up.pop_back();\n    while (true) {\n      int p = st.back();\n      if (visit[p]) {\n\tdo {\n\t  if (node[st.back()].Next() >= 0) {\n\t    up.push_back(st.back());\n\t  }\n\t  visit[st.back()] = false;\n\t  st.pop_back();\n\t} while (st.back() != p);\n\t++cnt;\n      }\n      const Node& nd = node[p];\n      int k = nd.Next();\n      if (k < 0) {\n\tst.pop_back();\n\tassert(st.empty());\n\tbreak;\n      }\n      visit[p] = true;\n      st.push_back(nd.adj[k]);\n      color[nd.edge[k]] = lv;\n    }\n  }\n  return cnt >= 3;\n}\n\nbool SolveK() {\n  for (int i = 0; i < K; ++i) {\n    D = i;\n    memset(color, -1, sizeof(color));\n    memset(visit, 0, sizeof(visit));\n    if (Solve()) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> N >> M) {\n    memset(node, 0, sizeof(node));\n    for (int i = 0; i < M; ++i) {\n      int a, b;\n      cin >> a >> b;\n      --a; --b;\n      node[a].Add(b, i);\n      node[b].Add(a, i);\n    }\n    bool odd = false;\n    bool quick = false;\n    for (int i = 0; i < N; ++i) {\n      odd = odd || (node[i].n % 2 == 1);\n      quick = quick || node[i].n > K;\n    }\n    if (!odd && (quick || SolveK())) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 5e3 + 5;\nint a[N], p[N], pos[N][N];\nlong long dp[N][N], A, B;\n\nlong long P(int i, int l, int r) {\n    return pos[i][r] - pos[i][l] + 1;\n}\nint main() {\n    int n; cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) cin >> a[i], p[a[i]] = i;\n    for (int i = 1; i <= n; i++) {\n        pos[i][0] = 1;\n        for (int j = 1; j <= n; j++) pos[i][j] = pos[i][j - 1] + (p[j] < p[i]);\n    }\n    memset(dp, 63, sizeof dp);\n    dp[0][n + 1] = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = n + 1; j > i; j--) {\n            if (i >= 1) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] +\n                           min((P(i, i, j - 1) - 1) * A, B));\n            }\n            if (j <= n) {\n                dp[i][j] = min(dp[i][j], dp[i][j + 1] +\n                           min((j - P(j, i + 1, j)) * B, A));\n            }\n        }\n    }\n    long long ans = 1e18;\n    for (int i = 0; i <= n; i++) ans = min(ans, dp[i][i + 1]);\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt dp[5400];\nInt p[5400];\nInt n, a, b;\nint main(){\n  fill(dp, dp + 5400, LINF);\n  cin >> n >> a >> b;\n  p[n] = n;\n  for(int i = 0;i <= n;i++){\n    if(i != n){cin >> p[i];p[i]--;}\n    Int tmp = 0;\n    Int maxima = -1;\n    for(int j = i-1;j >= 0;j--){\n      if(p[j] > p[i])tmp += a;\n      else{\n\tif(p[j] > maxima){\n\t  dp[i] = min(dp[i], dp[j] + tmp);\n\t  maxima = p[j];\n\t}\n\ttmp += b;\n      }\n    }\n    dp[i] = min(dp[i], tmp);\n  }\n  cout << dp[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  int n;\n  ll a, b;\n  cin >> n >> a >> b;\n  vector<int> p(n);\n  for (auto& e : p) {\n    cin >> e;\n    e--;\n  }\n\n  vector<pair<int, int>> v = {{p.front(), 1}};\n  for (int i = 1; i < n; i++) {\n    if (p[i - 1] + 1 == p[i]) {\n      rbegin(v)->second++;\n    } else {\n      v.push_back({p[i], 1});\n    }\n  }\n  vector<pair<int, int>> t;\n  for (auto e : v) t.push_back(e);\n  sort(begin(t), end(t));\n\n  ll c = 0;\n  int l = 0, r = v.size() - 1;\n  while (l < r) {\n    while (l < r && v[l] == t[l]) l++;\n    while (l < r && v[r] == t[r]) r--;\n    int li = find(begin(v) + l, begin(v) + r + 1, t[l]) - begin(v);\n    int ri = find(begin(v) + l, begin(v) + r + 1, t[r]) - begin(v);\n    ll lc = 0, rc = 0;\n    for (int i = l; i < li; i++) lc += a * v[i].second;\n    for (int i = r; i > ri; i--) rc += b * v[i].second;\n    if (a * v[ri].second - rc < b * v[li].second - lc) {\n      c += a * v[ri].second;\n      auto tmp = v[ri];\n      for (int i = ri + 1; i <= r; i++) {\n        v[i - 1] = v[i];\n      }\n      v[r] = tmp;\n      r--;\n    } else {\n      c += b * v[li].second;\n      auto tmp = v[li];\n      for (int i = li - 1; i >= l; i--) {\n        v[i + 1] = v[i];\n      }\n      v[l] = tmp;\n      l++;\n    }\n  }\n  cout << c << endl;\n\n  // for (auto e : v) {\n  //   cerr << e.first << \" \" << e.second << endl;\n  // }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nconst int MAX_M = 1e5 + 5;\n\nstruct edge {\n    int u, v;\n    int other(int x) { return x ^ u ^ v; }\n};\n\nint n, m;\nedge ed[MAX_M];\nset<int> g[MAX_N];\n\nbool mk[MAX_N];\n\nbool remove1() {\n    int u;\n    for (u = 1; u <= n && g[u].empty(); u++);\n    if (u == n + 1) return 0;\n    \n    fill_n(mk, n + 1, 0);\n    vector<pair<int, int>> rec{{-1, u}};\n    while (1) {\n        if (mk[u]) {\n            //cout << \"re \" << u << endl;\n            break;\n        }\n        mk[u] = 1;\n        //cout << \"cyc \" << u << endl;\n        if (g[u].empty()) return 0;\n        int e = *g[u].begin();\n        int v = ed[e].other(u);\n        g[u].erase(e);\n        g[v].erase(e);\n        rec.push_back({e, v});\n        u = v;\n    }\n    for (auto &p : rec) {\n        int e, v; tie(e, v) = p;\n        if (e != -1) {\n            g[ed[e].u].insert(e);\n            g[ed[e].v].insert(e);\n        }\n        if (v == u) break;\n    }\n    return 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(nullptr);\n\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        cin >> ed[i].u >> ed[i].v;\n        g[ed[i].u].insert(i);\n        g[ed[i].v].insert(i);\n    }\n\n    int odd = 0;\n    for (int u = 1; u <= n; u++) odd += g[u].size() % 2;\n\n    if (odd) cout << \"No\\n\";\n    else {\n        bool ok = 0;\n        mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n        for (int iter = 0; iter <= 25; iter++) {\n            shuffle(ed, ed + m, rng);\n            fill_n(g + 1, n, set<int>());\n            for (int i = 0; i < m; i++) {\n                g[ed[i].u].insert(i);\n                g[ed[i].v].insert(i);\n            }\n            if (!remove1());\n            else if (!remove1());\n            else if (!remove1());\n            else ok = 1;\n            if (ok) break;\n        }\n        cout << (ok ? \"Yes\\n\" : \"No\\n\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define int long long\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (ll i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((ll)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <ll, ll> pii ;\ntypedef vector <ll> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <ll> qi ;\ntypedef queue <pii> qii ;\ntypedef set <ll> si ;\ntypedef map <ll, ll> mii ;\ntypedef map <string, ll> msi ;\nconst ll maxn = 5e3 + 100 ;\nconst ll inf = 0x3f3f3f3f ;\nconst ll iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 998244353 ;\nconst double eps = 1e-7 ;\ntemplate <class T = ll> T chmin(T &a, T b) { return a = min(a, b);}\ntemplate <class T = ll> T chmax(T &a, T b) { return a = max(a, b);}\ntemplate <class T = ll> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, vl, vr, ans = linf;\n\nll a[maxn];\n\nll f[maxn][maxn];\n\nsigned main()\n{\n\tn = read(), vr = read(), vl = read();\n\trep(i, 1, n) a[i] = read();\n\tass(f, 0x3f);\n\tf[0][0] = 0;\n\trep(i, 0, n - 1)\n\t{\n\t\trep(j, 0, n)\n\t\t{\n\t\t\tchmin(f[i + 1][j], f[i][j] + (a[i + 1] > j ? vr : vl));\n\t\t\tif(a[i + 1] > j) chmin(f[i + 1][a[i + 1]], f[i][j]);\n\t\t}\n\t}\n\trep(i, 0, n) chmin(ans, f[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\nconst LL N = 1000000007;\n\nLL n,l,r;\nLL a[5005],dp[5005];\n\nint main(){\n\tmemset(dp,0x3f,sizeof(dp));\n\tcin >> n >> r >> l;\n\tfor(LL i = 1;i <= n;i ++){\n\t\tcin >> a[i];\n\t\ta[i] ++;\n\t}\n\ta[0] = 1; dp[0] = 0; a[n + 1] = n + 2;\n\tfor(LL i = 1;i <= n + 1;i ++){\n\t\tLL sr = 0,sl = 0;\n\t\tfor(LL j = i - 1;j >= 0;j --){\n\t\t\tif(a[j] < a[i]) dp[i] = min(dp[i],dp[j] + r * sr + l * sl);\n\t\t\tif(a[j] > a[i]) sr ++; if(a[j] < a[i]) sl ++;\n\t\t}\n\t}\n\tcout << dp[n + 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 5500;\nll dp[maxn][maxn];\nint n, A, B, p[maxn], f[maxn];\n// A: right, B: left\n\nvoid upd(ll& x, ll y) { x = min(x, y); }\nint main() {\n    memset(dp, 0x3f, sizeof dp);\n    scanf(\"%d%d%d\", &n, &A, &B);\n    rep(i, n) scanf(\"%d\", &p[i]), f[p[i]] = i;\n    \n    memset(dp[0], 0, sizeof(dp[0]));\n    for(int i = 0; i < n; ++i) {    \n        for(int j = 1; j <= n; ++j) dp[i][j] = min(dp[i][j-1], dp[i][j]);\n        for(int j = 1; j <= n; ++j) { // [0, j)\n            if(j == f[i+1]) upd(dp[i+1][j], dp[i][j]);\n            else if(j > f[i+1]) upd(dp[i+1][j], dp[i][j] + A);\n            else if(j < f[i+1]) upd(dp[i+1][j], dp[i][j] + B);\n        }\n    }\n    for(int i = 1; i <= n; ++i) dp[n][i] = min(dp[n][i-1], dp[n][i]);\n    printf(\"%lld\\n\", dp[n][n]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=5002;\nint n,A,B,a[N],i,j;\nll f[N][N],ans=1e18,tmp;\ninline void Min(ll &x,ll y){if(y<x)x=y;}\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tmemset(f,63,sizeof(f));\n\tf[0][0]=0;\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=0;j<=n;j++){\n\t\t\ttmp=f[i-1][j];\n\t\t\tif (j<a[i]) Min(f[i][a[i]],tmp),Min(f[i][j],tmp+A);\n\t\t\telse Min(f[i][j],tmp+B);\n\t\t}\n\tfor (i=1;i<=n;i++) Min(ans,f[n][i]);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 5001;\nconst int INF = 1e18 + 7;\nint n, A, B;\nint a[N];\nint p[N][N];\nint sum(int x1, int y1, int x2, int y2) {\n    if (x2 < x1 || y2 < y1) return 0;\n    return p[x2][y2] - p[x2][y1 - 1] - p[x1 - 1][y2] + p[x1 - 1][y1 - 1];\n}   \nint dp[N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    cin >> n >> A >> B;\n    int R = A; \n    int L = B;\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n        p[i][a[i]] = 1;\n    }   \n    bool sorted = 1;\n    for (int i = 1; i <= n - 1; ++i) {\n        sorted &= a[i] < a[i + 1];\n    }   \n    if (sorted) {\n        cout << \"0\\n\";\n        exit(0);\n    }   \n\n    #ifdef HOME\n    cout << \"L \" << L << '\\n';\n    cout << \"R \" << R << '\\n';\n    #endif\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            p[i][j] += p[i - 1][j] + p[i][j - 1] - p[i - 1][j - 1];\n        }   \n    }   \n    for (int i = 1; i <= n; ++i) {\n        dp[i] = 0;\n        for (int j = 1; j < i; ++j) {\n            if (dp[j] < a[i]) {\n                dp[i] += min(L, R);\n            }   \n            else {\n                dp[i] += R;\n            }   \n        }\n        for (int j = 1; j < i; ++j) {\n            if (a[j] < a[i]) {\n                dp[i] = min(dp[i], dp[j] + sum(j + 1, a[j], i - 1, a[i]) * min(L, R) + sum(j + 1, 1, i - 1, a[j]) * L + sum(j + 1, a[i], i - 1, n) * R);\n            }   \n        }   \n    }  \n    int ans = INF;\n    for (int i = 1; i <= n; ++i) {\n        int nn = dp[i];\n        for (int j = i + 1; j <= n; ++j) {\n            if (a[j] < a[i]) {\n                nn += L;\n            }   \n            else {\n                nn += min(L, R);\n            }   \n        }   \n        ans = min(ans, nn);\n    }   \n    cout << ans << '\\n';\n}   "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,a[5001],A,B,p[5001];\nlong long f[5001][5001],ans;\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]),p[a[i]]=i;\n\tfor (int i=0; i<=n; i++)\n\t\tfor (int j=0; j<=n; j++) f[i][j]=1000000000000000000ll;\n\tf[0][0]=0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<=n; j++)\n\t\t\tif (j<p[i]) f[i][j]=min(f[i][j],f[i-1][j]+B),f[i][p[i]]=min(f[i][p[i]],f[i-1][j]);\n\t\t\telse f[i][j]=min(f[i][j],f[i-1][j]+A);\n\tans=1000000000000000000ll;\n\tfor (int i=0; i<=n; i++) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n\nint count(const vi& xs, int min, int max) {\n    auto it = lower_bound(all(xs), min);\n    auto it2 = upper_bound(all(xs), max);\n    return it2 - it;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    ll L, R;\n    cin >> n >> L >> R;\n    vi p(n);\n    for (int i=0; i<n; i++) cin >> p[i], p[i]--;\n    vvi toL(n);\n    vvi toR(n);\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<i; j++) {\n            toL[p[i]].pb(p[j]);\n        }\n        for (int j=i+1; j<n; j++) {\n            toR[p[i]].pb(p[j]);\n        }\n        sort(all(toL[p[i]]));\n        sort(all(toR[p[i]]));\n    }\n    vvll dp(n+1, vll(n+1));\n    for (int l=0; l<=n; l++) for (int r=!l; r<=n; r++) {\n        if (l+r>n) continue;\n        dp[l][r] = 1ll << 62;\n        if (l>0) {\n            int dist = count(toL[l-1], l-1, n-r-1);\n            ll cost = min(R, dist*L);\n            dp[l][r] = min(dp[l][r], dp[l-1][r]+cost);\n        }\n        if (r>0) {\n            int dist = count(toR[n-r], l, n-r);\n            ll cost = min(L, dist*R);\n            dp[l][r] = min(dp[l][r], dp[l][r-1]+cost);\n        }\n    }\n    ll ans=1ll<<62;\n    for (int l=0; l<=n; l++)\n        ans = min(ans, dp[l][n-l]);\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst int maxn = 5000;\n\nint main() {\n  int n;\n  int right_cost, left_cost;\n  scanf(\"%d %d %d\", &n, &right_cost, &left_cost);\n  vector<int> perm(n), invperm(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &perm[i]), --perm[i];\n    invperm[perm[i]] = i;\n  }\n\n  vector<lint> prev_dp(n + 1);\n  vector<lint> dp(n + 1, 0LL);\n  for (int v = n - 1; v >= 0; --v) {\n    swap(dp, prev_dp);\n\n    int my_pos = invperm[v];\n    int bigger_before = 0;\n    for (int i = 0; i < my_pos; ++i)\n      if (perm[i] > v)\n        ++bigger_before;\n\n    for (int i = 0; i <= n; ++i) {\n      lint &res = dp[i];\n\n      if (my_pos < i) {\n        res = prev_dp[i];\n      } else if (bigger_before == 0) {\n        res = prev_dp[my_pos + 1];\n      } else {\n        res = min((lint)bigger_before * right_cost + prev_dp[my_pos + 1],\n                  left_cost + prev_dp[i]);\n      }\n\n      if (0 <= i && i < my_pos && perm[i] > v)\n        --bigger_before;\n    }\n  }\n\n  printf(\"%lld\\n\", dp[0]);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * There is a start and there is no end in the space. ---Infinity.\n * It ruins and goes though there is also a start in stars. ---Finite.\n * Only the man who has wisdom can read the most foolish one from the history.\n * Fishes living in the sea doesn't know the life in the land.\n * It also ruins and goes if they have wisdom.\n * It funnier that man exceeds the speed of light than fish start living in the land.\n * It can be said that this is an final ultimatum from the god to the people who can fight.\n *\n * Steins;Gate\n */\n\n#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N = 5010;\n\nLL f[N][N];\nint a[N], p[N];\n\nint main() {\n\n    int n;\n    LL A, B;\n    scanf(\"%d%lld%lld\", &n, &A, &B);\n    for(int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n        p[a[i]] = i;\n    }\n    memset(f, 0x3f, sizeof(f));\n    /// DP\n    f[0][0] = 0;\n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j < i; j++) {\n            /// f[i][j]\n            /*for(int k = 0; k < i; k++) {\n                /// f[i][j] <- f[i - 1][k]\n                if(p[i] < p[k]) {\n                    f[i][j] = std::min(f[i][j], f[i - 1][k] + A);\n                }\n                else {\n                    f[i][j] = std::min(f[i][j], f[i - 1][k] + B);\n                }\n            }*/\n            if(p[i] < p[j]) {\n                f[i][j] = f[i - 1][j] + A;\n            }\n            else {\n                f[i][j] = f[i - 1][j] + B;\n                f[i][i] = std::min(f[i][i], f[i - 1][j]);\n            }\n        }\n        /*for(int j = 0; j <= i; j++) {\n            printf(\"%3lld \", f[i][j]);\n        }\n        puts(\"\");*/\n    }\n\n\n    LL ans = 4e18;\n    for(int i = 0; i <= n; i++) {\n        ans = std::min(ans, f[n][i]);\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 5000 + 5 ; \nint n, A, B, p[N], dp[N][N], mx[N][N], f[N][N], mi[N][N] ; \nsigned main()\n{\n\tn = gi(), A = gi(), B = gi() ; \n\trep( i, 1, n ) p[i] = gi(), mx[i][i] = mi[i][i] = p[i] ;\n\trep( i, 1, n ) rep( j, i + 1, n ) \n\t\tmx[i][j] = max( mx[i][j - 1], p[j] ), mi[i][j] = min( mi[i][j - 1], p[j] ) ; \n\trep( l, 1, n ) rep( r, l, n ) {\n\t\tif( l == r ) f[l][r] = l ; \n\t\telse {\n\t\t\tf[l][r] = ( mx[l][f[l][r - 1]] < p[r] ) ? f[l][r - 1] : r ; \n\t\t}\n\t}\n\trep( k, 2, n ) {\n\t\trep( l, 1, n ) {\n\t\t\tint r = l + k - 1 ; \n\t\t\tif( r > n ) break ; \n\t\t\tdp[l][r] = min( dp[l + 1][r] + A, dp[l][r - 1] + B ) ;\n\t\t\tdp[l][r] = min( dp[l][r], dp[l][f[l][r]] + dp[f[l][r] + 1][r] ) ;\n\t\t}\n\t}\n\tcout << dp[1][n] << endl ; \n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n// スパーステーブルをまずは検討しよう\n#ifdef _MSC_VER\ninline unsigned int __builtin_clz(unsigned int x){unsigned long r;_BitScanReverse(&r,x);return 31-r;}\n#endif // _MSC_VER\ntemplate<class V> struct SparseTableMax { // [L,R)\n    const V def = -1;\n    inline V comp(V a, V b) { return max(a,b); }\n\n    int n; vector<V> a, b[20]; inline int __lg(int x) { return 32 - 1 - __builtin_clz(x); }\n    void init(vector<V> v) {\n        int nn = v.size(); n = 1; while (n < nn) n *= 2; a.resize(n);\n        rep(i, 0, 20) b[i].resize(n); rep(i, 0, nn) a[i] = v[i];\n\n        int d = 1 << __lg(n - 1), e = d << 1;\n        for (int h = 0, f; (f = 1 << h) <= d; ++h) {\n            for (int i = f, r = f << 1; i < e; i += r) {\n                b[h][i - 1] = a[i - 1];\n                for (int j = i - 2; j >= i - f; --j) b[h][j] = comp(b[h][j + 1], a[j]);\n                b[h][i] = a[i];\n                for (int j = i + 1; j < i + f; ++j) b[h][j] = comp(b[h][j - 1], a[j]);\n            }\n        }\n    }\n\n    V get(int L,int R){\n        assert(0<=L&&L<=R);\n        if(L==R)return def;R--;if(L==R)return a[L];int h=__lg(L^R);\n        return comp(b[h][L],b[h][R]);}};\ntemplate<class V> struct SparseTableMin { // [L,R)\n    const V def = inf;\n    inline V comp(V a, V b) { return min(a,b); }\n\n    int n; vector<V> a, b[20]; inline int __lg(int x) { return 32 - 1 - __builtin_clz(x); }\n    void init(vector<V> v) {\n        int nn = v.size(); n = 1; while (n < nn) n *= 2; a.resize(n);\n        rep(i, 0, 20) b[i].resize(n); rep(i, 0, nn) a[i] = v[i];\n\n        int d = 1 << __lg(n - 1), e = d << 1;\n        for (int h = 0, f; (f = 1 << h) <= d; ++h) {\n            for (int i = f, r = f << 1; i < e; i += r) {\n                b[h][i - 1] = a[i - 1];\n                for (int j = i - 2; j >= i - f; --j) b[h][j] = comp(b[h][j + 1], a[j]);\n                b[h][i] = a[i];\n                for (int j = i + 1; j < i + f; ++j) b[h][j] = comp(b[h][j - 1], a[j]);\n            }\n        }\n    }\n\n    V get(int L,int R){assert(0<=L&&L<=R);if(L==R)return def;R--;if(L==R)return a[L];int h=__lg(L^R);\n        return comp(b[h][L],b[h][R]);}};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N, A, B, P[5010];\nSparseTableMax<int> stmax;\nSparseTableMin<int> stmin;\n//---------------------------------------------------------------------------------------------------\nint rev[5010];\nll dp[5010][5010];\nll f(int L, int R) {\n    if (0 <= dp[L][R]) return dp[L][R];\n    if (L == R) return 0;\n\n    dp[L][R] = infl;\n\n    // ←\n    auto lft = stmin.get(L + 1, R + 1);\n    if (lft != infl and lft < rev[L]) chmin(dp[L][R], f(L + 1, R) + B);\n    else chmin(dp[L][R], f(L + 1, R));\n\n    // →\n    auto rht = stmax.get(L, R);\n    if (rht != -1 and rev[R] < rht) chmin(dp[L][R], f(L, R - 1) + A);\n    else chmin(dp[L][R], f(L, R - 1));\n\n    return dp[L][R];\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> A >> B;\n    rep(i, 0, N) cin >> P[i];\n\n    rep(i, 0, N) rev[P[i]] = i;\n    vector<int> v(N + 1);\n    rep(i, 0, N) v[P[i]] = rev[P[i]];\n    stmax.init(v);\n    stmin.init(v);\n\n    rep(i, 0, N + 1) rep(j, 0, N + 1) dp[i][j] = -1;\n    cout << f(1, N) << endl;\n\n    //rep(i, 1, N + 1) rep(j, i, N + 1) printf(\"dp[%d][%d] = %lld\\n\", i, j, f(i, j));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define INF 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef long long ll;\n\nll dp[6000][6000];\nint p[6000];\n\nint main(){\n\tint n,a,b;cin>>n>>a>>b;\n\trep(i,n)scanf(\"%d\",&p[i]);\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\trep(i,n)rep(j,n+1){\n\t\tif(dp[i][j]==INF)continue;\n\t\tif(j>p[i]){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+b);\n\t\t}\n\t\telse{\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+a);\n\t\t\tdp[i+1][p[i]]=min(dp[i+1][p[i]],dp[i][j]);\n\t\t}\n\t}\n\tcout<<*min_element(dp[n],dp[n]+n+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint main() {\n    int n;\n    long long a, b; cin >> n >> a >> b;\n    int P[n]; for (int i = 0; i < n; i++) cin >> P[i];\n\n    int lis[n] = {};\n    fill(lis, lis+n, 1<<30);\n    for (int i = 0; i < n; i++)\n        *lower_bound(lis, lis+n, P[i]) = P[i];\n    vector<int> s;\n    int m = lower_bound(lis, lis+n, 1<<30) - lis - 1;\n    // for (int i = 0; i <= m; i++) cerr << lis[i] << ' '; cerr << endl;\n    int prevv = 1<<30;\n    for (int i = n-1; i >= 0; i--) {\n        if (lis[m] <= P[i] && P[i] < prevv) {\n            s.push_back(i);\n            prevv = P[i];\n            m--;\n        }\n    }\n    // for (int x : s) cerr << x << ' '; cerr << endl;\n    reverse(s.begin(), s.end());\n    int Ps[s.size()];\n    bool in_lis[n] = {};\n    for (int i = 0; i < s.size(); i++) { Ps[i] = P[s[i]]; in_lis[s[i]] = true; }\n    int acc_min[n], acc_max[n];\n    int temp = 1<<30;\n    for (int i = n-1; i >= 0; i--) {\n        if (in_lis[i]) temp = min(temp, P[i]);\n        acc_min[i] = temp;\n    }\n    temp = 0;\n    for (int i = 0; i < n; i++) {\n        if (in_lis[i]) temp = max(temp, P[i]);\n        acc_max[i] = temp;\n    }\n    long long ans = 0;\n    for (int i = n-1; i >= 0; i--) {\n        if (in_lis[i]) continue;\n        int j = lower_bound(s.begin(), s.end(), i) - s.begin();\n        if (j != s.size() && P[i] > Ps[j]) {\n            int k = lower_bound(Ps + j, Ps + s.size(), P[i]) - Ps;\n            int m = k == s.size() ? n : s[k];\n            ans += min(a, b * (m-i-1));\n        } else if (j != 0 && P[i] < Ps[j-1]) {\n            int k = lower_bound(Ps, Ps + j, P[i]) - Ps;\n            int m = s[k];\n            ans += min(b, a * (i-m));\n        }\n        // cerr << i << ' ' << j << ' ' << P[i] << ' ' << Ps[j] << ' ' << ans << endl;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DEBUG_OUTPUT_ENABLED 1\n\t#define DBG(X) dout << #X << \"=\" << (X) << '\\n';\n\t#define SAY(X) dout << (X) << '\\n';\n#else\n\t#define DEBUG_OUTPUT_ENABLED 0\n\t#define DBG(X) 42;\n\t#define SAY(X) 42;\n#endif\n\n#define dout   __debug::instance\nusing namespace std;\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const set<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const multiset<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\nnamespace __debug {\n\tstruct DebugStream {\n\t\tprivate:\n\t\t\tbool is_first;\n\t\tpublic:\n\t\t\tDebugStream(bool _is_first): is_first(_is_first) {}\n\t\t\ttemplate<typename T> DebugStream operator<<(const T& value) const {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\tcout << value;\n\t\t\t\treturn DebugStream(false);\n\t\t\t};\n\n\t\t\ttemplate<typename T> DebugStream printArray(T* l, T* r) {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\twhile(l != r) {\n\t\t\t\t\tcout << (*l);\n\t\t\t\t\t++l;\n\t\t\t\t\tif(l == r) {\n\t\t\t\t\t\tcout << '\\n';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn DebugStream(false);\n\t\t\t}\n\t};\n\tDebugStream instance(true);\n};\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for(auto& elem: ret) cin >> elem; return ret; }\nconst int MAXN = 5007;\nll MoveLeft, MoveRight, dp[MAXN];\nint a[MAXN], b[MAXN], n;\nint F[MAXN];\ninline void clearFenv() {\n\tmemset(F, 0, sizeof(F));\n}\ninline void add(int pos, int val) {\n\tfor(; pos < MAXN; pos |= pos + 1) F[pos] += val;\n}\ninline int get(int r) {\n\tint rez = 0;\n\tfor(; r >= 0; r = (r & (r + 1)) - 1) rez += F[r];\n\treturn rez;\n}\ninline int get(int l, int r) {\n\tif(l <= r) return get(r) - get(l - 1);\n\telse return 0;\n}\nvoid solve() {\n\tcin >> n >> MoveRight >> MoveLeft;\n\tn += 2;\n\ta[0] = 0;\n\ta[n - 1] = n - 1;\n\tfor(int i = 1; i < n - 1; ++i) a[i] = fetch<int>();\n\tfor(int i = 1; i < n; ++i) {\n\t\tdp[i] = LL_INF;\n\t\tclearFenv();\n\t\tfor(int j = i - 1; j >= 0; --j) {\n\t\t\tif(a[j] < a[i]) {\n\t\t\t\tint ToLeft = get(a[j] - 1);\n\t\t\t\tint ToRight = get(a[i] + 1, MAXN - 1);\n\t\t\t\tll loc = MoveLeft * ToLeft + MoveRight * ToRight + dp[j];\n\t\t\t\tif(ToLeft + ToRight == i - j - 1) { \n\t\t\t\t\tdout << j << ' ' << i << '\\n';\n\t\t\t\t\tdp[i] = min(dp[i], loc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(a[j], 1);\n\t\t}\n\t}\n\t//for(int i = 0; i < n; ++i) dout << i << \": \" << dp[i] << '\\n';\n\tcout << dp[n - 1] << '\\n';\n}\n\nint main() {\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define ll __int128\n#define ll long long\n#define LEFT(a) ((a)<<1)\n#define RIGHT(a) (LEFT(a) + 1)\n#define MID(a,b) ((a+b)>>1)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define y1 y122\n/*\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"unroll-loops\")\n#pragma comment(linker, \"/STACK: 20000000005\")\n*/\n\nusing namespace std;\n\nconst ll N = 5005, MOD = 1e9 + 7;\n\nint n;\nll A, B;\n\nint a[N], b[N];\nint d[N][N];\nll dp[N][N];\n\n\nmain()\n{\n    //freopen (\"in.in\", \"r\", stdin);freopen (\"out.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin >> n >> B >> A;\n    for (int i = 1; i <= n; i++){\n        cin >> a[i];\n        b[a[i]] = i;\n    }\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            d[i][j] = d[i][j - 1] + (b[j] <= b[i]);\n    for (int i = n; i >= 1; i--)\n        for (int j = i + 1; j <= n; j++){\n            int x = d[i][j] - d[i][i - 1], y = d[j][j] - d[j][i - 1];\n            ll X = 0, Y = 0;\n            if (x > 1)\n                X = A;\n            if (y < j - i + 1)\n                Y = B;\n            dp[i][j] = min (dp[i + 1][j] + X, dp[i][j - 1] + Y);\n        }\n    cout << dp[1][n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=5005;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,A,B,pos[N];\nll f[N],ans;\nint main(){\n\tn=read();A=read();B=read();\n\tfor (int i=1;i<=n;i++) pos[read()]=i-1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++) f[j]=min(f[j],f[j-1]);\n\t\tfor (int j=0;j<=n;j++) f[j]+=(pos[i]==j) ? 0 : ((pos[i]<j) ? A : B);\n\t}\n\tans=inf;\n\tfor (int i=0;i<=n;i++) ans=min(ans,f[i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long INF = 1e18;\n\nint n, a, b;\nint f[5001];\nlong long dp[5001][5001];\n\nlong long solve(int i, int prv) {\n\tif (i == n) return 0;\n\tif (dp[i][prv] != -1) return dp[i][prv];\n\n\tlong long ans = INF;\n\tif (f[i] < prv) {\n\t\tans = min(ans, solve(i+1, prv) + b);\n\t} else {\n\t\tans = min(ans, solve(i+1, f[i]));\n\t\tans = min(ans, solve(i+1, prv) + a);\n\t}\n\treturn dp[i][prv] = ans;\n}\n\nsigned main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\t\n\tcin >> n >> a >> b;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> f[i];\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tcout << solve(0, 0) << '\\n';\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef pair<ii, int> ri3;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define sc second\n#define SZ(x) (int)(x).size()\n#define ALL(x) begin(x), end(x) \n#define REP(i, n) for (int i = 0; i < n; ++i) \n#define FOR(i, a, b) for (int i = a; i <= b; ++i)\n#define RFOR(i, a, b) for (int i = a; i >= b; --i)\n\nconst int N = 5005;\n\nint n, a, b;\nint arr[N], p[N];\nll res[N][N];\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> a >> b;\n    FOR(i,1,n){\n        cin >> arr[i];\n        p[arr[i]] = i;\n    }\n\n    memset(res[n+1], 0, sizeof res[n+1]);\n    RFOR(i, n, 1) {\n        ll minB[p[i]], minA[n+1];\n        minB[p[i]-1] = res[i+1][p[i]-1];\n        RFOR(y, p[i]-2, 0) minB[y] = min(minB[y+1], res[i+1][y]);\n\n        minA[n] = res[i+1][n];\n        RFOR(y, n-1, 0) minA[y] = min(minA[y+1], res[i+1][y]);\n\n\n        FOR(x, 0, n) {\n            res[i][x] = 1e18;\n\n            //res[i][x] = min(minB[p[i]-1] + b, minA[p[i]] + a);\n            res[i][x] = minA[max(x, p[i])] + a;\n            if (x < p[i]) res[i][x] = min(res[i][x], minB[x] + b);\n            //FOR(y,x,n){\n            //    if (y < p[i]) res[i][x] = min(res[i][x], res[i+1][y] + b);\n            //    else res[i][x] = min(res[i][x], res[i+1][y] + a);\n            //}\n            if (p[i] > x) res[i][x] = min(res[i][x], res[i+1][p[i]]);\n            //cout << i << \" \" << x << \" :: \" << res[i][x] << '\\n';\n        }\n    }\n    cout << res[1][0] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long \n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 5000+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 1e9+7;\n\nint n,a,b,f[maxn][maxn],p[maxn];\n\nsigned main() {\n    read(n),read(a),read(b);\n    for(int i=1,x;i<=n;i++) read(x),p[x]=i;\n    memset(f,63,sizeof f);\n    for(int i=1;i<=n+1;i++) f[0][i]=0;\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=p[i];j++) f[i][j]=f[i-1][j]+b;\n        for(int j=p[i]+1;j<=n+1;j++) f[i][j]=f[i-1][j]+a;\n        f[i][p[i]+1]=min(f[i][p[i]+1],f[i-1][p[i]]);\n        for(int j=2;j<=n+1;j++) f[i][j]=min(f[i][j],f[i][j-1]);\n        // for(int j=1;j<=n+1;j++) printf(\"%d \",f[i][j]);puts(\"\");\n    }\n    write(f[n][n+1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=5010;\nint n,a,b,x,p[N];\nll dp[N][N];\nint main() {\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\trep(i,1,n+1) scanf(\"%d\",&x),p[x]=i;\n\tmemset(dp,0x20,sizeof(dp));\n\tdp[0][0]=0;\n\trep(i,1,n+1) rep(j,0,i) {\n\t\tif (p[i]>p[j]) {\n\t\t\tdp[i][i]=min(dp[i][i],dp[i-1][j]);\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+b);\n\t\t} else\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+a);\n\t}\n\tprintf(\"%lld\\n\",*min_element(dp[n],dp[n]+n+1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll dp[5005][5005],a,b;\nint p[5005],n;\nint mx[5005][5005],mn[5005][5005];\nint f[5005][5005];\n\nint calc(int x1,int x2,int y1,int y2){\n\treturn f[x2][y2]+f[x1-1][y1-1]-f[x1-1][y2]-f[x2][y1-1];\n}\n\nint main(){\n\tscanf(\"%d %lld %lld\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&p[i]),f[i][p[i]]=1;\n\tfor(int l=1;l<=n;l++){\n\t\tmx[l][l]=mn[l][l]=p[l];\n\t\tfor(int r=l+1;r<=n;r++){\n\t\t\tmx[l][r]=max(mx[l][r-1],p[r]);\n\t\t\tmn[l][r]=min(mn[l][r-1],p[r]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) f[i][j]=f[i][j-1]+f[i-1][j]-f[i-1][j-1]+f[i][j];\n\t}\n\tfor(int len=2;len<=n;len++){\n\t\tfor(int l=1,r;l<=n-len+1;l++){\n\t\t\tr=l+len-1;\n\t\t\tdp[l][r]=min(dp[l][r-1]+min(b*(p[r]<mx[l][r-1]),1ll*a*calc(l,r-1,p[r],n)),dp[l+1][r]+min(a*(p[l]>mn[l+1][r]),1ll*b*calc(l+1,r,1,p[l])));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[1][n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  lint A, B; cin >> A >> B;\n  V<> p(n); for (auto&& e : p) cin >> e;\n  map< V<>, lint > mp;\n  auto fn = [&](const auto& fn, const V<>& p) -> lint {\n    int n = p.size();\n    if (n <= 1) return 0;\n    if (mp.count(p)) return mp[p];\n    int s = max_element(begin(p), end(p)) - begin(p);\n    lint res = 1e18;\n    {\n      auto q = p;\n      q.erase(begin(q) + s);\n      res = min(res, A + fn(fn, q));\n    }\n    {\n      auto q = p;\n      q.erase(begin(q) + s, end(q));\n      res = min(res, B * (n - 1 - s) + fn(fn, q));\n    }\n    return mp[p] = res;\n  };\n  cout << fn(fn, p) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nusing ll = long long;\n\nconst int nax = 5005;\nconst ll INF = 1e18L + 5;\nint A, B;\nint p[nax], inv[nax];\nll dp[nax][nax];\n\nint main() {\n    int n;\n    scanf(\"%d%d%d\", &n, &A, &B);\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d\", &p[i]);\n      --p[i];\n      inv[p[i]] = i;\n    }\n    for(int value = n - 1; value >= 0; --value) {\n      for(int pos = n - 1; pos >= 0; --pos) {\n        if(pos != n - 1) {\n          debug() << imie(value) imie(pos+1) imie(dp[value][pos+1]);\n        }\n        ll& me = dp[value][pos];\n        me = INF;\n        if(inv[value] < pos) {\n          me = dp[value+1][pos];\n          continue;\n        }\n        if(p[pos] < value) {\n          me = dp[value][pos+1];\n          continue;\n        }\n        if(p[pos] == value) {\n          me = dp[value+1][pos+1];\n          continue;\n        }\n        int where = inv[value];\n        //~ assert(where >= pos);\n        me = min(dp[value+1][pos] + B, dp[value+1][where+1] + (ll) A * (where - pos));\n      }\n    }\n    printf(\"%lld\\n\", dp[0][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 5005\n#define ll long long\nusing namespace std;\n\nint n,i,j,k,a[maxn],p[maxn],A,B,s[maxn][maxn];\nll f[maxn][maxn];\n\nint pd1(int l,int r,int i){\n\treturn s[i-1][r]-s[i-1][l-1]>0;\n}\nint pd2(int l,int r,int i){\n\treturn (s[n][r]-s[i][r])-(s[n][l-1]-s[i][l-1])>0;\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&a[i]),p[a[i]]=i;\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++)\t\n\t\ts[i][j]=s[i-1][j]+(a[i]<=j);\n\tfor(i=1;i<=n;i++) f[i][i]=0;\n\tfor(k=2;k<=n;k++) for(i=1;i+k-1<=n;i++) {\n\t\tj=i+k-1;\n\t\tf[i][j]=min(f[i+1][j]+pd1(i+1,j,p[i])*B,\n\t\t\t\t\tf[i][j-1]+pd2(i,j-1,p[j])*A);\n\t}\n\tprintf(\"%lld\",f[1][n]);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//constexpr ll MOD=1e9+7;\n//\nconstexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        if(A<0) return B;\n        if(B<0) return A;\n        return std::min(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vector<vector<int>> dp;\n    vector<int> dist;\n    Tree(vector<vector<int>> edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=1;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,A,B; cin>>N>>A>>B;\n    vi P(N);\n    rep(i,0,N){\n        cin>>P[i];\n        P[i]--;\n    }\n    vii front(N,vi(N+1)),back(N,vi(N+1));\n    rep(i,0,N){\n        ll cnt=0;\n        rep(j,0,i){\n            if(P[j]>P[i]){\n                cnt++;\n                front[P[i]][N-P[j]]--;\n            }\n        }\n        front[P[i]][0]=cnt;\n        REP(j,1,N) front[P[i]][j]+=front[P[i]][j-1];\n        REP(j,0,N) front[P[i]][j]=std::min(B,A*front[P[i]][j]);\n        cnt=0;\n        rep(j,i+1,N){\n            if(P[j]<P[i]){\n                cnt++;\n                back[P[i]][P[j]+1]--;\n            }\n        }\n        back[P[i]][0]=cnt;\n        REP(j,1,N) back[P[i]][j]+=back[P[i]][j-1];\n        REP(j,0,N) back[P[i]][j]=std::min(A,B*back[P[i]][j]);\n    }\n    vii dp(N+1,vi(N+1,inf));\n    dp[0][0]=0;\n    rep(i,0,N){\n        rep(j,0,N-i){\n            dp[i+1][j]=std::min(dp[i+1][j],dp[i][j]+front[i][j]);\n            dp[i][j+1]=std::min(dp[i][j+1],dp[i][j]+back[N-1-j][i]);\n        }\n    }\n    ll ans=inf;\n    REP(i,0,N){\n        ans=std::min(ans,dp[i][N-i]);\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define MOD(x) ((x)%mod)\n#define pii pair<int,int>\n#define mp(a,b) make_pair(a,b)\n#define ll long long\n#define inf 0x3f3f3f3f\nusing namespace std;\nint n;\nll A,B;\nint a[5005];\nll dp[2][5005];\nint now,last;\nint high[5005],low[5005];\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tfor(int j=1;j<i;j++)\n\t\t\tif(a[j]>a[i]) high[i]++;\n\t\t\t\telse low[i]++;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tlast=now;\n\t\tnow=!last;\n\t\tmemset(dp[now],-1,sizeof dp[now]);\n\t\tdp[now][a[i]]=A*high[i]+B*low[i];\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(dp[last][j]==-1) continue;\n\t\t\tif(a[i]>j) dp[now][j]=dp[last][j]+A;\n\t\t\tif(a[i]<j) dp[now][j]=dp[last][j]+B;\n\t\t\tif(a[i]>j) dp[now][a[i]]=min(dp[now][a[i]],dp[last][j]);\n\t\t}\n\t}\n\tll ans=dp[now][1];\n\tfor(int i=1;i<=n;i++)\n\t\tans=min(ans,dp[now][i]);\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define MP make_pair\n#define PB push_back\nusing namespace std;\nnamespace io{\n\tconst int Sz=1<<13;\n\tchar ibuf[Sz],*ips=ibuf+Sz-1;\n\tinline int getchar(){\n\t\tif(++ips==ibuf+Sz)fread(ips=ibuf,1,Sz,stdin);\n\t\treturn *ips;\n\t}\n\tchar obuf[Sz],*ops=obuf;\n\tinline void flush(){\n\t\tfwrite(obuf,1,ops-obuf,stdout);\n\t\tops=obuf;fflush(stdout);\n\t}\n\tinline void putchar(int c){\n\t\tif(ops==obuf+Sz)flush();\n\t\t*ops=c,ops++;\n\t}\n\tvoid gets(char *s){\n\t\tint c=getchar();\n\t\twhile(c<=32)c=getchar();\n\t\twhile(c>32)*s=c,++s,c=getchar();\n\t\t*s=0;\n\t}\n\tvoid puts(const char *s){\n\t\twhile(*s)putchar(*s),++s;\n\t}\n}\n#define getchar io::getchar\n#define putchar io::putchar\n#define gets io::gets\n#define puts io::puts\nint read(){\n\tint x=0,f=1,c=getchar();\n\tfor(;c<48||c>57;c=getchar())\n\t\tif(c=='-')f=-f;\n\tfor(;c>=48&&c<=57;c=getchar())\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tint stk[20],tp=0;\n\tif(!x)putchar(48);\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)stk[tp++]=(x-x/10*10)^48;\n\tfor(;tp;)putchar(stk[--tp]);\n}\nstruct Flusher{~Flusher(){io::flush();}}flusher;\n// ------------------------- Template End ------------------------- //\nconst int N=5005;\nint n,A,B;\nint p[N],ps[N];\nll dp[N][N],mndp[N][N];\nconst ll inf=0x3f3f3f3f3f3f3f3f;\nvoid chkmin(ll &x,ll y){if(y<x)x=y;}\nint main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=0;i<n;++i)p[i]=read(),ps[p[i]]=i<<1;\n\tmemset(dp,0x3f,sizeof dp);\n\tdp[0][0]=0;\n\tfor(int i=0;i<(n<<1);++i)mndp[0][i]=0;\n\tfor(int i=1;i<=n;++i)for(int k=0;k<(n<<1);++k){\n\t\tchkmin(dp[i][k],mndp[i-1][k]+(ps[i]==k?0:(ps[i]<k?A:B)));\n\t\tif(k)mndp[i][k]=mndp[i][k-1];else mndp[i][k]=inf;\n\t\tchkmin(mndp[i][k],dp[i][k]);\n\t}\n\twrite(mndp[n][(n<<1)-1]);putchar('\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stdint.h>\n\nint ps[5005];\nint64_t dp[5005];\n\nint main(){\n  int N,A,B;\n  scanf(\"%d %d %d\",&N,&A,&B);\n  for(int i=1;i<=N;i++){\n    scanf(\"%d\",&ps[i]);\n    for(int j=0;j<=N;j++){\n      if(j<ps[i]){\n\tdp[j]+=A;\n      }else if(j>ps[i]){\n\tdp[j]+=B;\n      }\n    }\n    for(int j=1;j<=N;j++){\n      dp[j]=std::min(dp[j],dp[j-1]);\n    }\n  }\n  printf(\"%ld\\n\",dp[N]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main() {\n    int n, A, B; cin >> n >> A >> B;\n    int p[n]; for (int i = 0; i < n; i++) cin >> p[i];\n    long long dp[2][n+1];\n    int cur = 0, prev = 1;\n    fill(dp[prev], dp[prev]+n+1, 0);\n    for (int i = n-1; i >= 0; i--) {\n        for (int j = 0; j <= n; j++) {\n            if (j < p[i]) dp[cur][j] = min(dp[prev][p[i]], dp[prev][j] + A);\n            else if (j > p[i]) dp[cur][j] = dp[prev][j] + B;\n        }\n        swap(cur, prev);\n    }\n    cout << dp[prev][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define ph push\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long) 1e18)//1234567890987654321\n#define INF 1234567890ll\n// #define cerr if(0)cout\n#define MAXN (5006)\nll n, a, b, A[MAXN], dp[2][MAXN], pos[MAXN], co[MAXN]; // dp(i, j) = dp(val i, at pos j -> 0 all the elements are in order);\nint main()\n{ // can be proven that each element moves once\n\tFAST\n\tcin>>n>>a>>b;\n\tFOR(i,1,n)cin>>A[i],pos[A[i]]=i;\n\tFOR(i,1,n) {\n\t\tmmst(dp[i%2],0);\n\t\tll x=pos[i];\n\t\tFOR(j,1,x-1) dp[i%2][j]=dp[i%2^1][j]; // storing history values (won't be changed), but might be referenced in the future\n\t\tFOR(j,x,n){ // legit ones\n\t\t\tdp[i%2][j]=min((j==x?LLINF:dp[i%2^1][j]+a), dp[i%2^1][x-1] + b * (co[j] - co[x])); // move all blocking elements to correct position, u'll end up at position i (cos i-p-1 items just got moved)\n\t\t}\n\t\tFOR(i,x,n) ++ co[i];\n\t\tFOR(j,1,n)cerr<<dp[i%2][j]<<' '; cerr<<'\\n';\n\t}\n\tcout<<dp[n%2][n]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  lint A, B; cin >> A >> B;\n  V<> p(n); for (auto&& e : p) cin >> e, --e;\n  V<lint> dp(n + 1);\n  for (int x = 0; x < n; ++x) {\n    int j = find(begin(p), end(p), x) - begin(p);\n    int c = 0;\n    for (int i = j + 1; ; ++i) {\n      if (c) dp[i] += A;\n      dp[i] = min(dp[i], B * c + dp[j]);\n      if (i == n) break;\n      c += p[i] < x;\n    }\n  }\n  cout << dp.back() << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=0x3f3f3f3f3f3f3f3fll;\nconst double pi=acos(-1.0);\n\nconst int maxn=5111;\n\nint n,a,b,p[maxn];\nLL dp[maxn][maxn];\ninline void upd(LL&x,LL y){if(x>y)x=y;}\n\nint main()\n{\n\tget3(n,a,b);\n\tfor(int i=1;i<=n;i++)get1(p[i]);\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[1][0]=0;\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=n;j++)\n\t{\n\t\t//go left\n\t\tupd(dp[i+1][max(j,p[i])],b+dp[i][j]);\n\t\t//stay\n\t\tif(p[i]>j)upd(dp[i+1][max(j,p[i])],dp[i][j]);\n\t\t//go right\n\t\tif(p[i]>j)upd(dp[i+1][j],dp[i][j]+a);\n\t}\n\tLL ans=Linf;\n\tfor(int j=0;j<=n;j++)ans=min(ans,dp[n+1][j]);\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n#define LL long long \n#define FOR(i,l,r) for(int i = l; i <= r; ++i)\n\nconst LL oo = 1e18;\n\nLL A,B;\nint C[5001],N;\nLL F[5001][5001];\n\nvoid minimize(LL &x,LL y){\n    x = min(x,y);\n}\nvoid update(int i,int j){\n    if(C[i + 1] < C[j]) minimize(F[i + 1][j],F[i][j] + B);\n    else{\n        minimize(F[i + 1][i + 1],F[i][j]);\n        minimize(F[i + 1][j],F[i][j] + A);\n    }\n}\nint main(){\n\n    cin >> N >> A >> B;\n    FOR(i,1,N) cin >> C[i];\n\n    FOR(i,1,N) FOR(j,0,i) F[i][j] = oo;\n\n    update(0,0);\n    FOR(i,1,N - 1) FOR(j,0,i) if(F[i][j] < oo) update(i,j);\n\n    LL res = oo;\n    FOR(i,1,N) res = min(res,F[N][i]);\n\n    cout << res;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint main() {\n    int n;\n    long long a, b; cin >> n >> a >> b;\n    int P[n]; for (int i = 0; i < n; i++) cin >> P[i];\n\n    int lis[n] = {};\n    fill(lis, lis+n, 1<<30);\n    for (int i = 0; i < n; i++)\n        *lower_bound(lis, lis+n, P[i]) = P[i];\n    vector<int> s;\n    int m = lower_bound(lis, lis+n, 1<<30) - lis - 1;\n    // for (int i = 0; i <= m; i++) cerr << lis[i] << ' '; cerr << endl;\n    int prevv = 1<<30;\n    for (int i = n-1; i >= 0; i--) {\n        if (lis[m] <= P[i] && P[i] < prevv) {\n            s.push_back(i);\n            prevv = P[i];\n            m--;\n        }\n    }\n    // for (int x : s) cerr << x << ' '; cerr << endl;\n    reverse(s.begin(), s.end());\n    int Ps[s.size()];\n    bool in_lis[n] = {};\n    for (int i = 0; i < s.size(); i++) { Ps[i] = P[s[i]]; in_lis[s[i]] = true; }\n    int acc_min[n], acc_max[n];\n    int temp = 1<<30;\n    for (int i = n-1; i >= 0; i--) {\n        if (in_lis[i]) temp = min(temp, P[i]);\n        acc_min[i] = temp;\n    }\n    temp = 0;\n    for (int i = 0; i < n; i++) {\n        if (in_lis[i]) temp = max(temp, P[i]);\n        acc_max[i] = temp;\n    }\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (in_lis[i]) continue;\n        int j = lower_bound(s.begin(), s.end(), i) - s.begin();\n        if (j != s.size() && P[i] > Ps[j]) {\n            int k = lower_bound(Ps + j, Ps + s.size(), P[i]) - Ps;\n            int m = k == s.size() ? n : s[k];\n            ans += min(a, b * (m-i-1));\n        } else if (j != 0 && P[i] < Ps[j-1]) {\n            int k = lower_bound(Ps, Ps + j, P[i]) - Ps;\n            int m = s[k];\n            ans += min(b, a * (i-m));\n        }\n        // cerr << i << ' ' << j << ' ' << P[i] << ' ' << Ps[j] << ' ' << ans << endl;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL N=5010;\nLL n, a, b, p[N], id[N], dp[N][N], s[N][N];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\tfor(LL i=1; i<=n; ++i)scanf(\"%lld\",&p[i]), id[p[i]]=i;\n\tmemset(s,0x3f,sizeof(s));\n\tfor(LL i=0; i<=n; ++i)s[0][i]=0;\n\tfor(LL i=1; i<=n; ++i)\n\t\tfor(LL j=1; j<=n; ++j){\n\t\t\tdp[i][j]=s[i-1][j]+(j>=id[i]?a:b);\n\t\t\tif(j==id[i])dp[i][j]=min(dp[i][j],s[i-1][j-1]);\n\t\t\tif(j>0)s[i][j]=min(s[i][j-1],dp[i][j]);else s[i][j]=dp[i][j];\n\t\t}\n\tLL mn=0x3f3f3f3f3f3f3f3f;\n\tfor(LL i=1; i<=n; ++i)mn=min(mn,dp[n][i]);\n\tprintf(\"%lld\",mn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.5.15 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\ninline int read() {\n    res s=0,ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=5e3+10;\nnamespace MAIN {\n    int n,A,B,pos[N];\n    LL dp[2][N],ans=inf;\n    inline void MAIN(){\n        n=read(),A=read(),B=read();\n        for(res i=1;i<=n;i++)pos[read()]=i,dp[0][i]=inf;\n        res cur=0;\n        for(res i=1;i<=n;i++){\n            for(res j=0;j<=i;j++)dp[cur^1][j]=inf;\n            for(res j=0;j<i;j++){\n                RG LL DP=dp[cur][j];\n                if(DP!=inf){\n                    if(pos[i]>pos[j])dp[cur^1][i]=min(dp[cur^1][i],DP),dp[cur^1][j]=min(dp[cur^1][j],DP+B);\n                    else dp[cur^1][j]=min(dp[cur^1][j],DP+A);\n                }\n            }\n            cur^=1;\n        }\n        for(res i=1;i<=n;i++)ans=min(ans,dp[cur][i]);\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"graph.in\",\"r\",stdin);\n//    freopen(\"graph.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 5005;const ll inf=1e16;\nint n,a,b,p[N],pos[N],mx[N][N],mn[N][N];\nll f[N][N];\nint main() {\n\tread(n);read(a);read(b);\n\trep(i,1,n)read(p[i]),pos[p[i]]=i;\n\trep(i,1,n)rep(j,i,n)f[i][j]=inf;\n\trep(i,1,n){\n\t\tmn[i][i]=mx[i][i]=pos[i];\n\t\trep(j,i+1,n)mn[i][j]=min(mn[i][j-1],pos[j]),mx[i][j]=max(mx[i][j-1],pos[j]);\n\t}\n\trep(l,1,n)rep(i,1,n-l+1){\n\t\tint j=i+l-1;\n\t\tf[i][j]=min(f[i+1][j]+(mn[i][j]<pos[i]?b:0),f[i][j-1]+(mx[i][j]>pos[j]?a:0));\n\t}\n\tcout<<f[1][n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ninline int read()\n{\n\tint s=0,f=1; char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=5e3+20;\nconst ll inf=1ll<<60;\n\nint n,A,B;\nint p[maxn];\nll dp[maxn];\nint s[maxn][maxn];\n\ninline void init()\n{\n\tn=read();A=read();B=read();\n\tREP(i,1,n)p[i]=read(); p[n+1]=n+1; \n\tREP(i,1,n+1)s[i][p[i]]++;\n\tREP(i,1,n+1)REP(j,1,n+1)s[i][j]+=s[i][j-1];\n\tREP(i,1,n+1)REP(j,1,n+1)s[i][j]+=s[i-1][j];\n}\n\ninline int Matrix(int x1,int x2,int y1,int y2)\n{\n\treturn s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];\n}\n\ninline void doing()\n{\n\tdp[0]=0;\n\tREP(i,1,n+1)\n\t{\n\t\tdp[i]=inf;\n\t\tREP(j,0,i-1)if(p[j]<p[i])\n\t\t{\n\t\t\tint num=Matrix(j+1,i-1,p[j]+1,p[i]-1);\n\t\t\tif(!num)\n\t\t\t{\n\t\t\t\tint a=Matrix(j+1,i-1,p[i]+1,n+1);\n\t\t\t\tint b=Matrix(j+1,i-1,1,p[j]-1);\n\t\t\t\tchkmin(dp[i],(ll)a*A+(ll)b*B+dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n+1]);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n    vector<int> p(n), pos(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i];\n        p[i]--;\n        pos[p[i]] = i;\n    }\n    vector<int> ld(n), rd(n);\n    for (int i = 0; i < n; ++i) {\n        ld[i] = i;\n        while (ld[i] + 1 < n && pos[ld[i] + 1] > pos[i]) ++ld[i];\n        rd[i] = i;\n        while (rd[i] - 1 >= 0 && pos[rd[i] - 1] < pos[i]) --rd[i];\n    }\n    constexpr int64_t kInf = 1'000'000'000'000'000'000;\n    vector<vector<int64_t>> dp(n, vector<int64_t>(n, kInf));\n    for (int i = 0; i < n; ++i) dp[i][i] = 0;\n    for (int p = 1; p < n; ++p) {\n        for (int i = 0; i + p < n; ++i) {\n            int j = i + p;\n            dp[i][j] = min(dp[i + 1][j] + b, dp[i][j - 1] + a);\n            if (ld[i] >= j) dp[i][j] = min(dp[i][j], dp[i + 1][j]);\n            if (rd[j] <= i) dp[i][j] = min(dp[i][j], dp[i][j - 1]);\n        }\n    }\n    cout << dp[0][n - 1] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 5007;\n\nll dp[N][N];\n\nconst ll Inf = 1e18;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, a, b;\n  cin >> n >> a >> b;\n  vector <int> p(n);\n  for (int i = 0; i < n; ++i) cin >> p[i];\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      dp[i][j] = Inf;\n    }\n  }\n  dp[0][0] = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      if (dp[i][j] == Inf) continue;\n      if (p[i] < j) {\n        dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + b);\n      } else {\n        dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + a);\n        dp[i + 1][p[i]] = min(dp[i + 1][p[i]], dp[i][j]);\n      }\n    }\n  }\n  ll ans = Inf;\n  for (int i = 0; i <= n; ++i) ans = min(ans, dp[n][i]);\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 5e3 + 10;\n\nint N, P[MAX_N], pre2d[MAX_N][MAX_N];\nll A, B, F[MAX_N];\n\nint count(int x1, int x2, int y1, int y2) {\n    return pre2d[x2][y2] - pre2d[x2][y1 - 1] - pre2d[x1 - 1][y2] + pre2d[x1 - 1][y1 - 1];\n}\n\nint main() {\n    scanf(\"%d%lld%lld\", &N, &A, &B);\n    for (int i = 1; i <= N; i++) scanf(\"%d\", &P[i]);\n    P[0] = 0; P[N + 1] = N + 1;\n    for (int i = 1; i <= N; i++) {\n        pre2d[i][P[i]] = 1;\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) pre2d[i][j] += pre2d[i][j - 1];\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) pre2d[i][j] += pre2d[i - 1][j];\n    }\n    for (int i = 1; i <= N + 1; i++) {\n        F[i] = LLONG_MAX;\n        for (int j = 0; j < i; j++) {\n            if (P[j] > P[i]) continue;\n            ll v = F[j];\n            int tot = i - j - 1, heavy;\n            if (A >= B) {\n                heavy = count(j + 1, i - 1, P[i], N);\n            } else {\n                heavy = count(j + 1, i - 1, 1, P[j]);\n            }\n            v += max(A, B) * heavy + min(A, B) * (tot - heavy);\n            F[i] = min(F[i], v);\n        }\n    }\n    printf(\"%lld\\n\", F[N + 1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define MN 5010\n\ntypedef long long ll;\n\nll Min[MN], lazy[MN];\n\nvoid add(int x, ll v) {lazy[x] += v; Min[x] += v;}\nvoid pushdown(int x)\n{\n\tif(lazy[x]) \n\t{\n\t\tadd(x << 1, lazy[x]);\n\t\tadd(x << 1 | 1, lazy[x]);\n\t\tlazy[x] = 0;\n\t}\n}\n\nvoid modify(int x, int l, int r, int L, int R, ll v, int t)\n{\n\tif(L > R) return;\n\tif(l == L && r == R)\n\t{\n\t\tif(t == 0) add(x, v);\n\t\telse Min[x] = v;\n\t\treturn;\n\t}\n\tpushdown(x); int mid = l + r >> 1;\n\tif(R <= mid) modify(x << 1, l, mid, L, R, v, t);\n\telse if(L > mid) modify(x << 1 | 1, mid + 1, r, L, R, v, t);\n\telse modify(x << 1, l, mid, L, mid, v, t), modify(x << 1 | 1, mid + 1, r, mid + 1, R, v, t);\n\tMin[x] = std::min(Min[x << 1], Min[x << 1 | 1]);\n}\n\nll query(int x, int l, int r, int L, int R)\n{\n\tif(l == L && r == R) return Min[x];\n\tpushdown(x); int mid = l + r >> 1;\n\tif(R <= mid) return query(x << 1, l, mid, L, R);\n\telse if(L > mid) return query(x << 1 | 1, mid + 1, r, L, R);\n\telse return std::min(query(x << 1, l, mid, L, mid), query(x << 1 | 1, mid + 1, r, mid + 1, R));\n}\n\nint main()\n{\n\tint n, a, b; \n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tmodify(1, 0, n, 0, n, 1e18, 0);\n\tmodify(1, 0, n, 0, 0, 0, 1);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint x; scanf(\"%d\", &x);\n\t\tmodify(1, 0, n, x, x, query(1, 0, n, 0, x), 1);\n\t\tmodify(1, 0, n, 0, x - 1, a, 0);\n\t\tmodify(1, 0, n, x + 1, n, b, 0);\n\t}\n\tprintf(\"%lld\\n\", query(1, 0, n, 0, n));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define int long long\nusing std::min;\nint n,A,B,p[5010],dp[5010][5010],ans;\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&A,&B);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&p[i]);\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;ans=0x3f3f3f3f3f3f3f3f;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(p[i]>j)dp[i][j]=min(dp[i][j],dp[i-1][j]+A),\n\t\t\t\tdp[i][p[i]]=min(dp[i][p[i]],dp[i-1][j]);\n\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n\tfor(int i=0;i<=n;i++)\n\t\tans=min(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint p[5001];\nint f1[5001][5002],f2[5001][5002];\nlong long f[5002];\nint main(){\n\tint n,a,b;\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&p[i]);\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i+1;j<=n+1;j++){\n\t\t\tf1[i][j]=f1[i][j-1]+(i!=0&&j!=n+1&&p[j]<p[i]);\n\t\t\t//printf(\"1:%d %d %d\\n\",i,j,f1[i][j]);\n\t\t}\n\tfor(int j=1;j<=n+1;j++)\n\t\tfor(int i=j-1;i>=0;i--){\n\t\t\tf2[i][j]=f2[i+1][j]+(i!=0&&j!=n+1&&p[j]<p[i]);\n\t\t\t//printf(\"2:%d %d %d\\n\",i,j,f2[i][j]);\n\t\t}\n\tfor(int i=1;i<=n+1;i++)\n\t\tf[i]=~0ull>>1;\n\tfor(int i=0;i<=n+1;i++){\n\t\t//printf(\"%d %lld\\n\",i,f[i]);\n\t\tfor(int j=i+1;j<=n+1;j++)\n\t\t\tif(!(i==0&&j==n+1)&&(i==0||j==n+1||p[j]>p[i])&&f1[i][j]+f2[i][j]==j-i-1){\n\t\t\t\tf[j]=min(f[j],f[i]+1ll*f1[i][j]*b+1ll*f2[i][j]*a);\n\t\t\t\t//printf(\"%d %d %lld\\n\",i,j,f[i]+1ll*f1[i][j]*b+1ll*f2[i][j]*a);\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n+1]);\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nconst int maxn = 5e3 + 10;\nconst long long max_val = 1LL << 62;\n \nlong long dp[maxn * 2], dp_min[maxn * 2];\nint p[maxn];\n \nlong long cost(int p1, int p2, int A, int B) {\n    if (p1 == p2) return 0;\n    else if (p1 > p2) return B;\n    else return A;\n}\n \nint main()\n{\n    int N, A, B, x;\n    cin >> N >> A >> B;\n    for (int i = 1; i <= N; i++) {\n        cin >> x;\n        p[x] = i;\n    }\n    for (int i = 1; i <= N; i++) for (int j = 0; j <= N; j++) dp[j] = max_val;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j <=  N; j++) {\n            dp[j] = dp_min[j] + cost(p[i], j, A, B);\n        }\n        dp_min[0] = dp[0];\n        for (int j = 1; j <=  N; j++) dp_min[j] = min(dp_min[j - 1], dp[j]);\n    }\n    cout << dp_min[ N] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\n\nlong long dp[5010];\nint a[5010], pos[5010];\n\nstruct Segment_tree{\n\tstruct Node{\n\t\tlong long minj, lazy;\n\t}T[20010];\n\tvoid pushup(int now){\n\t\tT[now].minj = min(T[now << 1].minj, T[now << 1 | 1].minj);\n\t}\n\tvoid pushdown(int now){\n\t\tif (T[now].lazy == INF) return ;\n\t\tlong long v = T[now].lazy; T[now].lazy = INF;\n\t\tT[now << 1].minj = min(T[now << 1].minj, v);\n\t\tT[now << 1].lazy = min(T[now << 1].lazy, v);\n\t\tT[now << 1 | 1].minj = min(T[now << 1 | 1].minj, v);\n\t\tT[now << 1 | 1].lazy = min(T[now << 1 | 1].lazy, v);\n\t}\n\tvoid Build(int now, int l, int r){\n\t\tT[now].minj = T[now].lazy = INF;\n\t\tif (l == r) return ;\n\t\tint mid = l + r >> 1;\n\t\tBuild(now << 1, l, mid), Build(now << 1 | 1, mid + 1, r);\n\t}\n\tvoid Update(int now, int l, int r, int L, int R, long long x){\n\t\tif (l == L && r == R){\n\t\t\tT[now].minj = min(T[now].minj, x);\n\t\t\tT[now].lazy = min(T[now].lazy, x);\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(now);\n\t\tint mid = l + r >> 1;\n\t\tif (R <= mid) Update(now << 1, l, mid, L, R, x);\n\t\telse if (L > mid) Update(now << 1 | 1, mid + 1, r, L, R, x);\n\t\telse Update(now << 1, l, mid, L, mid, x), Update(now << 1 | 1, mid + 1, r, mid + 1, R, x);\n\t\tpushup(now);\n\t}\n\tvoid get_dp(int now, int l, int r){\n\t\tif (l == r){\n\t\t\tdp[l] = T[now].minj;\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(now);\n\t\tint mid = l + r >> 1;\n\t\tget_dp(now << 1, l, mid), get_dp(now << 1 | 1, mid + 1, r);\n\t}\n}seg;\n\nint main(){\n\tint n, A, B;\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tpos[a[i]] = i + 1;\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tseg.Build(1, 0, n);\n\t\tint x = pos[i];\n\t\tfor (int j = 0; j <= n; j++){\n\t\t\tif (dp[j] == INF) continue;\n\t\t\tif (j < x) seg.Update(1, 0, n, j, x - 1, dp[j] + B);\n\t\t\tif (j <= x) seg.Update(1, 0, n, x, x, dp[j]);\n\t\t\tseg.Update(1, 0, n, max(x, j), n, dp[j] + A);\n\t\t}\n\t\tseg.get_dp(1, 0, n);\n\t}\n\tlong long ans = INF;\n\tfor (int i = 0; i <= n; i++){\n\t\tans = min(ans, dp[i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define fgx cerr<<\"-------------\"<<endl\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nvoid dbg(){cerr<<endl;}\ntemplate<typename A,typename... B>void dbg(A x,B... y){cerr<<x<<\" \";dbg(y...);}\n#define debug(...) cerr<<#__VA_ARGS__<<\"=\",dbg(__VA_ARGS__)\nint pl[5050],g[5050],a[5050]; ll f[5050][5050];\ninline void gao(ll &x,ll y){x=min(x,y);}\nint main()\n{\tint tmp,n,i,j,A,B; ll ans=1e18;\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tpl[a[i]]=i;\n\t\tfor(j=i-1;j;j--)\n\t\t\tif(a[j]>a[i])\n\t\t\t\tg[i]++;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=0;j<=n;j++)\n\t\t\tf[i][j]=1e18;\n\tf[0][0]=0; \n\tfor(i=0;i<n;i++)\n\t{\n\t\ttmp=pl[i+1];\n\t\tfor(j=0;j<=n;j++)\n\t\t{\n\t\t\tif(j>g[tmp]) gao(f[i+1][j-1],f[i][j]+A);\n\t\t\telse gao(f[i+1][j],f[i][j]+B),gao(f[i+1][g[tmp]],f[i][j]);\n\t\t}\n\t}\n\tfor(i=0;i<=n;i++) gao(ans,f[n][i]);\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n \n#include <algorithm>\n#include <tuple>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n \n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n \ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 5010;\nconst ll INF = 1LL << 60;\n\nint n, a, b;\nint p[N];\nll dp[N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; ++i)\n    cin >> p[i];\n  for (int i = 1; i <= n; ++i) {\n    fill(dp[i], dp[i] + n + 1, INF);\n    for (int j = 0; j <= n; ++j) {\n      if (p[i] <= j)\n        dp[i][j] = min(dp[i - 1][p[i] - 1], dp[i - 1][j] + b);\n      else\n        dp[i][j] = dp[i - 1][j] + a;\n      if (j)\n        dp[i][j] = min(dp[i][j], dp[i][j - 1]);\n    }\n  }\n  cout << dp[n][n] << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n#include <iomanip>\n#include <tuple>\n#define INF 1000000009\n#define LINF 1000000000000000009\n#define double long double\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n//ll mod = 1000000007;\n//ll mod = 998244353;\n\nint main() {\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tvector<ll> p(n);\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tvector<vector<ll>> dp(n + 1, vector<ll>(n + 1, LINF));\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tif (j < p[i]) {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + a);\n\t\t\t\tdp[i + 1][p[i]] = min(dp[i + 1][p[i]], dp[i][j]);\n\t\t\t}\n\t\t\tif (j > p[i]) {\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + b);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = LINF;\n\tfor (int i = 0; i <= n; i++) ans = min(ans, dp[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n#define sol k+k\n#define sag k+k+1\n#define orta ((bas+son)/2)\n#define mod 1000000007\n#define N 5005\nusing namespace std;\n\ntypedef long long ll;\n\nint mn[N][N], mx[N][N];\nll dp[N][N], n, A, B, a[N];\nvector < int > seg[4*N];\n\nvoid merge(int k){\n\tseg[k].clear();\n\tint i = 0, a = (int)seg[sol].size();\n\tint j = 0, b = (int)seg[sag].size();\n\twhile(i < a and j < b){\n\t\tif(seg[sol][i] < seg[sag][j])\n\t\t\tseg[k].pb(seg[sol][i++]);\n\t\telse\n\t\t\tseg[k].pb(seg[sag][j++]);\n\t}\n\twhile(i < a)seg[k].pb(seg[sol][i++]);\n\twhile(j < b)seg[k].pb(seg[sag][j++]);\n}\n\nint qu(int k, int bas, int son, int x, int y, int z){\n\tif(bas > y or son < x)\n\t\treturn 0;\n\tif(bas >= x and son <= y){\n\t\tint ind = lower_bound(seg[k].begin(), seg[k].end(), z) - seg[k].begin();\n\t\treturn (int)seg[k].size() - ind ;\n\t}\n\treturn qu(sol, bas, orta, x, y, z) + qu(sag, orta + 1, son, x, y, z);\n}\n\nint quu(int k, int bas, int son, int x, int y, int z){\n\tif(bas > y or son < x)\n\t\treturn 0;\n\tif(bas >= x and son <= y){\n\t\tint ind = lower_bound(seg[k].begin(), seg[k].end(), z) - seg[k].begin();\n\t\treturn ind;\n\t}\n\treturn quu(sol, bas, orta, x, y, z) + quu(sag, orta + 1, son, x, y, z);\n}\n\nvoid up(int k, int bas, int son, int x, int y){\n\tif(bas == son){\n\t\tseg[k].pb(y);\n\t\treturn;\n\t}\n\tif(x <= orta)\n\t\tup(sol, bas, orta, x, y);\n\telse\n\t\tup(sag, orta + 1, son, x, y);\n\tmerge(k);\n}\n\nll f(ll bas, ll son){\n\tif(bas == son)\n\t\treturn 0;\n\tll &r = dp[bas][son];\n\tif(r != -1)\n\t\treturn r;\n\tif(a[bas] == mn[bas][son])\n\t\treturn r = f(bas + 1, son);\n\tif(a[son] == mx[bas][son])\n\t\treturn r = f(bas, son - 1);\n\treturn r = min(f(bas + 1, son) + min(A, B*(quu(1, 1, n, bas + 1, son, a[bas])) ), f(bas, son - 1) + min(B, A*(qu(1, 1, n, bas, son - 1, a[son])) ) );\n}\n\nint main() {\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n\n\tmemset(dp, -1, sizeof dp);\n\n\tscanf(\"%lld %lld %lld\",&n ,&A ,&B);\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%lld\",a + i);\n\t\tup(1, 1, n, i, a[i]);\n\t}\n\t// cout << quu(1, 1, n, 1, 1, 3) << endl;\n\n\tfor(int i = 1; i <= n; i++){\n\t\tmx[i][i] = mn[i][i] = a[i];\n\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\tmn[i][j] = min(mn[i][j - 1], (int)a[j]);\n\t\t\tmx[i][j] = max(mx[i][j - 1], (int)a[j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f(1, n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:134217728\")\n\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <memory>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\ntypedef long long Int;\ntypedef pair<int,int> PII;\ntypedef vector<int> VInt;\n\n#define FOR(i, a, b) for(i = (a); i < (b); ++i)\n#define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i)\n#define CLEAR(a, b) memset(a, b, sizeof(a))\n#define SIZE(a) int((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define PB push_back\n#define MP make_pair\n\n#define INF (1LL << 60)\n\nInt R[5 << 10][5 << 10];\nint C[5 << 10][5 << 10];\n\nint main()\n{\n\tint N;\n\tInt A, B;\n\tscanf(\"%d%lld%lld\", &N, &A, &B);\n\n\tint i, j;\n\tVInt p(N);\n\tVInt q(N);\n\tFOR(i, 0, N)\n\t{\n\t\tscanf(\"%d\", &p[i]);\n\t\t--p[i];\n\t\tq[p[i]] = i;\n\t}\n\n\tCLEAR(C, 0);\n\tFOR(i, 0, N)\n\t\tRFOR(j, i, 0)\n\t\t{\n\t\t\tC[i][j] = C[i][j + 1];\n\t\t\tif (q[j] > q[i]) ++C[i][j];\n\t\t}\n\n\tFOR(i, 0, N + 1)\n\t\tFOR(j, 0, N + 1)\n\t\tR[i][j] = INF;\n\n\tR[0][0] = 0;\n\tFOR(i, 0, N)\n\t\tFOR(j, 0, N + 1)\n\t\tif(R[i][j] != INF)\n\t\t{\n\t\t\tif(p[i] <= j)\n\t\t\t{\n\t\t\t\tR[i + 1][max(j, p[i] + 1)] = min(R[i + 1][max(j, p[i] + 1)], R[i][j]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tR[i + 1][j] = min(R[i + 1][j], R[i][j] + A);\n\t\t\tR[i + 1][p[i] + 1] = min(R[i + 1][p[i] + 1], R[i][j] + B*C[p[i]][j]);\n\t\t}\n\n\tInt res = INF;\n\tFOR(i, 0, N + 1) res = min(res, R[N][i]);\n\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 5e3 + 5;\nint a[N], p[N];\nlong long dp[N][N], mn[N][N], A, B;\n\nint main() {\n    int n; cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) cin >> a[i], p[a[i]] = i;\n    memset(dp, 63, sizeof dp);\n    for (int x = 0; x <= n; x++) mn[0][x] = dp[0][x] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int x = 0; x <= n; x++) {\n            dp[i][x] = (p[i] <= x ? A : B) + mn[i - 1][x];\n            if (p[i] == x) dp[i][x] = min(dp[i][x], mn[i - 1][x - 1]);\n            else if (x) dp[i][x] = min(dp[i][x], (p[i] < x ? A : B) + mn[i - 1][x - 1]);\n            mn[i][x] = min((x ? mn[i][x - 1] : 1ll<<62), dp[i][x]);\n        }\n    }\n    cout << mn[n][n] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 200000;\nint a[N], A, B, p[N];\nint used[5002][5002];\nlong long dp[5002][5002];\nint f[5002][5002];\nlong long solve(int l, int r) {\n    if (used[l][r]) {\n        return dp[l][r];\n    }\n    if (l == r) {\n        return 0;\n    }\n    used[l][r] = 1;\n    dp[l][r] = 1e18;\n    int i = p[l];\n    int cnt = f[i][r] - f[i][l - 1];\n    assert(cnt >= 1);\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l + 1, r) + B);\n    }\n    i = p[r];\n    cnt = f[n][r] - f[n][l - 1] - (f[i - 1][r] - f[i - 1][l - 1]);\n    assert(cnt >= 1);\n    if (cnt == 1) {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1));\n    } else {\n        dp[l][r] = min(dp[l][r], solve(l, r - 1) + A);\n    }\n    return dp[l][r];\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        p[a[i]] = i;\n    }\n    for (int j = 1; j <= n; j++) {\n        for (int i = 1; i <= n; i++) {\n            f[i][j] = f[i - 1][j];\n            if (a[i] <= j) {\n                f[i][j]++;\n            }\n        }\n    }\n    cout << solve(1, n) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define fdto(i,a,b) for(int i=a; i>=b;--i)\n#define maxn 5009\n\nusing namespace std;\nint n,a[maxn],nex[maxn],pre[maxn];\nlong long l[maxn][maxn],A,B;\nint main()\n{\n    cin >> n >> A >> B;\n    fto(i,1,n) cin >> a[i];\n    fto(i,1,n){\n        pre[a[i]]=1e9;\n        nex[a[i]]=0;\n        fto(j,1,i-1)\n        if(a[j]>a[i])pre[a[i]]=min(pre[a[i]],a[j]);\n        fto(j,i+1,n)\n        if(a[j]<a[i])nex[a[i]]=max(nex[a[i]],a[j]);\n    }\n    fto(i,0,n+1)\n        fto(j,0,n+1)l[i][j]=1e16;\n    l[1][n]=0;\n    ll res=1e16;\n    if(n==1){\n        cout << 0; return 0;\n    }\n    fdto(i,n-1,1){\n        fto(j,1,n-i+1){\n            l[j][j+i-1]=min(l[j-1][j+i-1]+B,l[j][j+i]+A);\n            if(j!=1){\n                if(pre[j-1]>j+i-1)l[j][j+i-1]=min(l[j][j+i-1],l[j-1][j+i-1]);\n            }\n            if(j+i-1!=n){\n                if(nex[j+i]<j)l[j][j+i-1]=min(l[j][j+i-1],l[j][j+i]);\n            }\n            if(i==1)res=min(res,l[j][j]);\n        }\n    }\n    cout << res;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define fio ios_base::sync_with_stdio(false)\n#define pdl cout << \"*\" << endl\n#define MOD 1000000007\n#define INF 1000000000\n#define INFLL 1000000000000000000ll\n#define mp make_pair\n#define pb push_back\n#define ff first\n#define ss second\n#define long int64_t\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef priority_queue<pii, vector<pii>, greater<pii>> min_pq;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> OST;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<> dis(0, INF<<1);\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1> void __f(const char* name, Arg1&& arg1){ cerr << name << \" : \" << arg1 << endl; }\ntemplate <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args)\n{ const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1 << \" | \"; __f(comma+1, args...); }\n\nconst int N = 5001;\n\nlong dp[N];\nint b[N];\n\nint main()\n{\n\tfio;\n\tint n;\n\tlong A, B;\n\tcin >> n >> A >> B;\n\tfor(int i=1; i<=n; i++)\n\t\tcin >> b[i];\n\tlong ans = INFLL;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tdp[i] = INFLL;\n\t\tint c = 0;\n\t\tfor(int j=i-1; j>=0; j--)\n\t\t{\n\t\t\tif(b[i] > b[j])\n\t\t\t\tdp[i] = min(dp[i], dp[j] + c * A + (i - j - 1 - c) * B);\n\t\t\telse\n\t\t\t\tc++;\n\t\t}\n\t\tans = min(ans, dp[i] + (n - i) * B);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define all(vr) vr.begin(),vr.end()\nconst ll N=1e5+10,inf=1e18;\nll dp[N],p[N],n,A,B;\nint main()\n{\n    //freopen(\"ss.inp\",\"r\",stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>A>>B;\n    for (int i=1;i<=n;i++) cin>>p[i],dp[i]=inf;\n    dp[n+1]=inf;\n    p[n+1]=n+1;\n    for (int i=0;i<=n;i++)\n    {\n        ll cnt=0;\n        for (int j=i+1;j<=n+1;j++)\n            if (p[j]>p[i]) dp[j]=min(dp[j],dp[i]+(j-i-1-cnt)*A+cnt*B);\n            else cnt++;\n    }\n    cout<<dp[n+1];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n        int n, a, b;\n        scanf(\"%d%d%d\", &n, &a, &b);\n        vector<int> pos(n);\n        rep(i, n) {\n                int p;\n                scanf(\"%d\", &p);\n                p --;\n                pos[p] = i;\n        }\n        const long long inf = 1e18;\n        vector<vector<long long>> cur(n + 1, vector<long long> (2));\n        rep(i, n) {\n                vector<vector<long long>> next(n + 1, vector<long long> (2));\n                rep(j, n + 1) {\n                        next[j][0] = inf;\n                        next[j][1] = inf;\n                        int cost = 0;\n                        if (j < pos[i]) cost = b;\n                        if (j > pos[i]) cost = a;\n                        // hai\n                        if (j != n + 1) {\n                                rep(k, j) {\n                                        next[j][0] = min(next[j][0], cur[k][0] + cost);\n                                        next[j][0] = min(next[j][0], cur[k][1] + cost);\n                                }\n                                next[j][0] = min(next[j][0], cur[j][1] + cost);\n                        }\n                        // pro\n                        if (j == pos[i]) cost = b;\n                        rep(k, j) {\n                                next[j][1] = min(next[j][1], cur[k][0] + cost);\n                        }\n                        rep(k, j + 1) {\n                                next[j][1] = min(next[j][1], cur[k][1] + cost);\n                        }\n                }\n                // rep(j, n + 1) cerr << next[j][0] << ' '; cerr << endl;\n                // rep(j, n + 1) cerr << next[j][1] << ' '; cerr << endl;\n                cur.swap(next);\n        }      \n        long long ans = inf;\n        rep(i, n + 1) {\n                ans = min(ans, cur[i][0]);\n                ans = min(ans, cur[i][1]);\n        }\n        printf(\"%lld\\n\", ans);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\ntypedef long long int ll;\nusing namespace std;\n\n#define DEBUG 0\n\n#if DEBUG\n  #define DLOG(...) fprintf(stderr, __VA_ARGS__)\n#else\n  #define DLOG(...)\n#endif\n\nvoid debug(auto f) {\n#if DEBUG\n  f();\n#endif\n}\n\nll N, A, B;\nvector<ll> p;\nvector<ll> pos;\nvector<ll> tbl;\n\nvoid showtbl() {\n  debug([]() {\n      for (ll i = 0; i < 2*N+1; i++)  cerr << tbl.at(i) << \", \";\n      cerr << endl;\n    });\n}\n\nint main() {\n#if !DEBUG\n  ios_base::sync_with_stdio(false);\n#endif\n\n  cin >> N >> A >> B;\n  p.resize(N);\n  pos.resize(N);\n  for (ll i = 0; i < N; i++)  {\n    ll x;\n    cin >> x;\n    p.at(i) = x - 1;\n  }\n  for (ll i = 0; i < N; i++)  pos[p.at(i)] = i;\n  tbl.resize(2*N+1);\n  /*\n    2*i+1 ... just i\n    2*i+2 ... (i, i+1)\n   */\n\n  for (ll k = 0; k < N; k++) {\n    ll i0 = pos.at(k);\n    for (ll i = 0; i <= 2*i0; i++)  tbl.at(i) += B;\n    for (ll i = 2*i0 + 2; i < 2*N + 1; i++)  tbl.at(i) += A;\n    showtbl();\n    for (ll i = 1; i < 2*N+1; i++) {\n      tbl.at(i) = min(tbl.at(i-1), tbl.at(i));\n    }\n    showtbl();\n  }\n  cout << tbl.at(2*N) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ff first\n#define ss second\n#define pb emplace_back\n\nconst int MAXN = 5009;\nint dp[MAXN];\nint a[MAXN];\nint n, x, y;\nint inf = 1ll * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> y >> x;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    a[n + 1] = n + 1;\n    n += 2;\n    for (int i = 1; i < n; i++)\n    {\n        dp[i] = inf;\n        int cur = 0;\n        int ma = -1;\n        for (int e = i - 1; e >= 0; e--)\n        {\n            if (a[e] < a[i] && (ma == -1 || a[e] > ma))\n                dp[i] = min(dp[i], dp[e] + cur);\n            if (a[e] > a[i])\n                cur += y;\n            else\n            {\n                cur += x;\n                if (ma == -1)\n                    ma = a[e];\n                else\n                    ma = max(ma, a[e]);\n            }\n        }\n    }\n    cout << dp[n - 1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst LL INF = 1LL << 60;\n\nint N;\nLL A, B;\nint p[5145];\nLL dp[5145];\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N >> A >> B;\n\n  fill(dp, dp+N+1, INF);\n  reps(i, 1, N+1) {\n    cin >> p[i];\n  }\n\n  dp[0] = 0;\n  reps(i, 1, N+1) {\n    rep(j, p[i]) {\n      MN(dp[p[i]], dp[j]);\n      dp[j] += A;\n    }\n    \n    reps(j, p[i]+1, N+1) {\n      dp[j] += B;\n    }\n  }\n\n  LL ans = INF;\n  rep(i, N+1) MN(ans, dp[i]);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,i,A,B,j,ans,f[5010][5010],a[5010];\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&A,&B);\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tmemset(f,44,sizeof(f));\n\tf[0][0]=0;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(a[i]>j)f[i][a[i]]=min(f[i][a[i]],f[i-1][j]),f[i][j]=min(f[i][j],f[i-1][j]+A);\n\t\t\t else f[i][j]=min(f[i][j],f[i-1][j]+B);\n\t\t}\n\t}\n\tans=1e18;\n\tfor(i=1;i<=n;i++)ans=min(ans,f[n][i]);\n\tprintf(\"%lld\",ans);\n}\n/*\n枚举不动的数就行了 \n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 100000000000000000;\n\nll dp[5002][5002];\n\nint main()\n{\n    int n;\n    ll a, b;\n    cin >> n >> a >> b;\n    int p[5002], q[5002];\n    for(int i = 0; i < n; i++){\n        cin >> p[i];\n        p[i]--;\n        q[p[i]] = i;\n    }\n    int left[5002], right[5002];\n    fill(left, left + n, n);\n    fill(right, right + n, -1);\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < q[i]; j++){\n            if(p[j] > i) left[i] = min(left[i], p[j]);\n        }\n        for(int j = q[i] + 1; j < n; j++){\n            if(p[j] < i) right[i] = max(right[i], p[j]);\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++) dp[i][j] = INF;\n    }\n    dp[0][0] = 0;\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            if(dp[i - 1][j] == INF) continue;\n            if(j > p[i - 1] + 1) dp[i][j] = dp[i - 1][j] + b;\n            else dp[i][j] = dp[i - 1][j] + a;\n        }\n        for(int j = 0; j < p[i - 1] + 1; j++) dp[i][p[i - 1] + 1] = min(dp[i][p[i - 1] + 1], dp[i - 1][j]);\n    }\n    ll ans = INF;\n    for(int j = 0; j <= n; j++) ans = min(ans, dp[n][j]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define ll long long\nconst int Q=5005;\nll f[Q][Q];\nint ml[Q],mr[Q],p[Q];\nint main()\n{\n\tint n;\n\tll a,b;\n\tscanf(\"%d%lld%lld\",&n,&a,&b);\n\tif(n>500)return 1;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=p[i];\n\t\tml[x]=998244353,mr[x]=-1;\n\t\tfor(int j=1;j<i;j++)\n\t\t\tif(p[j]>x)ml[x]=min(ml[x],p[j]);\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(p[j]<x)mr[x]=max(mr[x],p[j]);\n\t}\n\tfor(int len=1;len<=n;len++)\n\t\tfor(int i=1;i+len-1<=n;i++){\n\t\t\tint j=i+len-1;\n\t\t\tif(i==j)f[i][j]=0;\n\t\t\telse f[i][j]=min(f[i][j-1]+(mr[j]<i?0:a),f[i+1][j]+(ml[i]>j?0:b));\n\t\t}\n\tprintf(\"%lld\\n\",f[1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing pi = pair<ll, ll>;\nusing vi = vector<ll>;\nconst int maxn = 5e3 + 55;\nll n, a, b, dp[maxn][maxn], p[maxn];\nll cost(int i, int j) {\n\tif(p[i]==j-1) return 0;\n\treturn p[i] < j-1 ? a : b;\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> a >> b;\n\tfor(int t, i = 1; i <= n; i++) {\n\t\tcin >> t;\n\t\tp[t] = i;\n\t}\n\tmemset(dp, 0x3f, sizeof dp);\n\tfor(int i = 0; i <= n+1; i++)\n\t\tdp[0][i] = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= n+1; j++) {\n\t\t\tdp[i][j] = min(dp[i][j-1], dp[i-1][j] + cost(i, j));\n\t\t}\n\t}\n\tcout << dp[n][n+1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\n\nclass Solution {\n  int n;\n  vector<int> A;\n  const long long INF = 1e18;\n  long long costA, costB;\n  long long dp[5000];\npublic:\n  void run() {\n    cin >> n >> costA >> costB;\n    A.resize(n);\n    long long ans = INF;\n    for (int i = 0; i < n; ++i) cin >> A[i];\n    for (int i = 0; i < n; ++i) {\n      long long tmp = 0;\n      dp[i] = INF;\n      for (int j = i - 1; j >= 0; --j) {\n        if (A[j] < A[i]) dp[i] = min(dp[j] + tmp, dp[i]);\n        tmp += A[j] < A[i] ? costB : costA;\n      }\n      dp[i] = min(dp[i], tmp);\n      tmp = 0;\n      for (int j = i + 1; j < n; ++j) {\n        if (A[j] > A[i]) {\n          tmp = INF;\n          break;\n        }\n        tmp += costB;\n      }\n      ans = min(ans, dp[i] + tmp);\n    }\n    cout << ans << '\\n';\n  }     \n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  Solution().run();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::min;\nusing std::max;\nconst int N=5005;\nlong long dp[N][N];\nint n,x,y,a[N],m,f[N],f2[N],ff[N],ff2[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tmemset(f,0x3f,sizeof(f));\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<i;j++)\n\t\t\tif (a[j]>a[i]) {\n\t\t\t\tif (a[j]<f[a[i]])\n\t\t\t\t\tff[a[i]]=f[a[i]],f[a[i]]=a[j];\n\t\t\t\telse ff[a[i]]=min(ff[a[i]],a[j]);\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (a[j]<a[i]) {\n\t\t\t\tif (a[j]>f2[a[i]])\n\t\t\t\t\tff2[a[i]]=f2[a[i]],f2[a[i]]=a[j];\n\t\t\t\telse f2[a[i]]=max(f2[a[i]],a[j]);\n\t\t\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][n+1]=0;\n\tlong long ans=1ll*x*n;\n\tfor (int l=0;l<n;l++)\n\t\tfor (int i=0;i<=l;i++)\n\t\t{\n\t\t\tint j=n-(l-i)+1;\n\t\t\tif (dp[i][j]>=ans) continue;\n\t\t\tif (f[i+1]>=j) dp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n\t\t\telse dp[i+1][j]=min(dp[i+1][j],dp[i][j]+y);\t\t\t\n\t\t\tif (ff[i+1]>=j) dp[i+1][j]=min(dp[i+1][j],dp[i][j]+x);\n\t\t\tif (f2[j-1]<=i) dp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n\t\t\telse dp[i][j-1]=min(dp[i][j-1],dp[i][j]+x);\n\t\t\tif (ff2[j-1]<=i) dp[i][j-1]=min(dp[i][j-1],dp[i][j]+y);\n\t\t} \n\tfor (int i=0;i<=n;i++)\n\t\tans=min(dp[i][i+1],ans);\n\tprintf(\"%lld\\n\",ans);\t\t \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int N = 5e3 + 10;\nint n, A, B, ans;\nvector <int> v;\n\nvoid solve(vector <int> vec) {\n\tif (!vec.size())\n\t\treturn;\n\t\t\n\tint mn = N, indx = 0;\n\tfor (int i = 0; i < vec.size(); i++)\n\t\tif (vec[i] < mn) {\n\t\t\tmn = vec[i];\n\t\t\tindx = i;\n\t\t}\n\t\n\tif (B < A * indx) {\n\t\tans += B;\n\t\tvec.erase(vec.begin() + indx);\n\t\tsolve(vec);\n\t}\n\telse {\n\t\tans += A * indx;\n\t\tfor (int i = 0; i <= indx; i++)\n\t\t\tvec.erase(vec.begin());\n\t\tsolve(vec);\n\t}\n}\n\nint32_t main() {\n\tcin >> n >> A >> B;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tv.push_back(x);\n\t}\n\tsolve(v);\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst long long INF=1e18;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N; ll A,B; cin >> N >> A >> B;\n    vector<int> p(N);\n    for (int i=0;i<N;++i) cin >> p[i];\n    vector<vector<ll>> dp(N+1,vector<ll>(N+1,INF));\n    dp[0][0]=0;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<=N;++j){\n            if (p[i]>j){\n                dp[i+1][p[i]]=min(dp[i+1][p[i]],dp[i][j]);\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+A);\n            } else dp[i+1][j]=min(dp[i+1][j],dp[i][j]+B);\n        }\n    }\n    ll ans=INF;\n    for (int j=0;j<=N;++j) ans=min(ans,dp[N][j]);\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nlint N, A, B;\nconstexpr lint INF = 1e18;\nint main()\n{\n    cin >> N >> A >> B;\n    vector<lint> p(N);\n    cin >> p;\n    vector<lint> dp(N + 1, INF); // dp[i] *文字目までsortして，fixする最後がi文字目\n    dp[0] = 0;\n    lint p_shmax = 0;\n    REP(i, N)\n    {\n        lint pnow = p[i];\n        IREP(prv, i + 1)\n        {\n            if (prv > 0 and pnow < p[prv - 1])\n            {\n                dp[prv] += B;\n            }\n            else\n            {\n                mmin(dp[i + 1], dp[prv]);\n                dp[prv] += A;\n            }\n        }\n        mmax(p_shmax, pnow);\n    // dbg(dp);\n    }\n    cout << *min_element(ALL(dp)) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=5e3+10;\nll dp[N][N];\nint P[N],D[N];\nconst ll INF=1e18;\nint main()\n{\n\tint n,A,B;scanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&D[i]);\n\tint tar=0;\n\tfor(int i=0;i<n;i++){\n\t\ttar++;int cnt=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(D[j]==tar){\n\t\t\t\tP[tar]=n-tar-cnt;\n\t\t\t\tbreak;\n\t\t\t}else if(D[j]>tar)cnt++;\n\t\t}\n\t}fill(&dp[0][0],&dp[N-1][N],INF);\n\tfor(int i=0;i<=n;i++)dp[0][i]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tll M=INF;\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tM=min(M,dp[i-1][j]);\n\t\t\t//n-j,P[i]\n\t\t\tif(P[i]+1==n-j)dp[i][j+1]=min(dp[i][j+1],M);\n\t\t\telse if(P[i]+1<n-j)dp[i][j+1]=min(dp[i][j+1],M+B);\n\t\t\telse dp[i][j]=min(dp[i][j],M+A);\n\t\t}\n\t}cout<<dp[n][n]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 5005\n#define ll long long \nusing namespace std;\n\nint n,i,j,k,a[maxn],A,B,s[maxn][maxn];\nll f[maxn];\n\nint pd(int l,int r){\n\treturn (s[r-1][a[r]-1]-s[l][a[r]-1])-(s[r-1][a[l]]-s[l][a[l]])==0;\n}\n\nll cnt1(int l,int r){\n\treturn s[r-1][a[l]-1]-s[l][a[l]-1];\n}\nll cnt2(int l,int r){\n\tif (r==n+1) return 0;\n\treturn (s[r-1][n]-s[r-1][a[r]])-(s[l][n]-s[l][a[r]]);\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B),a[0]=0,a[n+1]=n+1;\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) s[i][j]=s[i-1][j]+(a[i]<=j);\n\tmemset(f,127,sizeof(f)),f[0]=0;\n\tfor(i=1;i<=n+1;i++) for(j=0;j<i;j++) \n\t\tif (a[i]>a[j]&&pd(j,i))\n\t\t\tf[i]=min(f[i],f[j]+cnt1(j,i)*B+cnt2(j,i)*A);\n\tprintf(\"%lld\",f[n+1]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n#define int long long\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nint A, B;\n\nsigned main() {\n\tscan n, A, B;\n\tvector<int> p(n);\n\tscan p;\n\tapply(p, x--);\n\tvector<int> at(n);\n\tf(i, n) {\n\t\tat[p[i]] = i + 1;\n\t}\n\n\tvector<vector<int>> dp(n + 1, vector<int>(n + 1, 1e18));\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[0][i] = 0;\n\t}\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint w = 0;\n\t\t\tif (at[k - 1] < i) w = A;\n\t\t\telse if (at[k - 1] == i) w = 0;\n\t\t\telse if (at[k - 1] > i) w = B;\n\t\t\tdp[k][i] = dp[k - 1][i] + w;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdp[k][i] = min(dp[k][i], dp[k][i - 1]);\n\t\t}\n\t}\n\t// print dp[1][2];\n\tint final = 1e18;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfinal = min(final, dp[n][i]);\n\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int N=5002;\nLL dp[N][N];\nint n,a,b,x[N],pos[N];\nint mn[N][N],mx[N][N];\n\nint main(){\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&x[i]), pos[x[i]]=i;\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)dp[i][j]=1e18;\n    dp[0][n+1]=0;\n    for(int i=1;i<=n;i++){\n        mx[i][i]=mn[i][i]=pos[i];\n        for(int j=i+1;j<=n;j++){\n            mx[i][j]=max(mx[i][j-1],pos[j]);\n            mn[i][j]=min(mn[i][j-1],pos[j]);\n        }\n    }\n    for(int len=0;len<n;len++)\n    for(int i=0;i<=n;i++){\n        int lef=i,rig=n+1-(len-i);\n\n        // [1,lef], [rig,n]\n        if(lef+1<rig && rig<=n+1){\n            //printf(\"len=%d,lef=%d,rig=%d %lld\\n\", len,lef,rig,dp[lef][rig]);\n            dp[lef+1][rig]=min(dp[lef+1][rig], dp[lef][rig]+(LL)(pos[lef+1]==mn[lef+1][rig-1]?0:b));\n            dp[lef][rig-1]=min(dp[lef][rig-1], dp[lef][rig]+(LL)(pos[rig-1]==mx[lef+1][rig-1]?0:a));\n        }\n    }\n    LL ans=1e18;\n    for(int i=0;i<=n;i++)ans=min(ans,dp[i][i+1]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n#include <memory.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\n#define N 5002\n#define inf 4000000000000000000LL\nint p[N];\n\nlong long dp[N][N];\nlong long leftMoveCost,rightMoveCost;\n\nvoid solve() {\n  int n;\n  long long A,B;\n  scanf(\"%d %lld %lld \", &n,&A,&B);\n  leftMoveCost = B;\n  rightMoveCost = A;\n  for(int i=1;i<=n;++i) {\n    int num;\n    scanf(\"%d \",&num);\n    p[num] = i;\n  }\n  fill((long long*)dp,(long long*)dp+N*N,inf);\n  dp[0][0] = 0;\n  for(int i=1;i<=n;++i) {\n    int curInd = p[i];\n    long long mini = inf;\n    for(int j=0;j<=n;++j) {\n      mini = min(mini, dp[i-1][j]);\n      long long cost;\n      if(j+1==curInd) {\n        cost = 0;\n      } else if(j+1<curInd) {\n        cost = leftMoveCost;\n      } else {\n        cost = rightMoveCost;\n      }\n      dp[i][j] = cost + mini;\n    }\n  }\n  long long ret = inf;\n  for(int i=0;i<=n;++i) {\n    ret = min(ret, dp[n][i]);\n  }\n  printf(\"%lld\\n\", ret);\n}\n\nint main() {\n  //freopen(\"input.txt\",\"r\",stdin);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n    const int l=1<<20;\n    char buf[l],*s,*t,c;\n    inline void gc(){\n        if(s==t){\n            t=(s=buf)+fread(buf,1,l,stdin);\n            c=s==t?EOF:*s++;\n        }else c=*s++;\n    }\n    template<class IT>inline void gi(IT &x){\n        x=0;gc();while(c<'0'||c>'9')gc();\n        while('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n    }\n    char buf0[20];int a;\n    template<class IT>inline void pi(IT x){\n        if(x<0){putchar('-');x=-x;}\n        do buf0[++a]=x%10+48;while(x/=10);\n        while(a)putchar(buf0[a--]);\n        putchar('\\n');\n    }\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=5005,M=10005;\nll d[M],D[M];int x[N];\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n,i,j;ll a,b,t;\n    scanf(\"%d%lld%lld\",&n,&a,&b);\n    rep(i,1,n){scanf(\"%d\",&j);x[j]=i<<1;}\n\trep(i,1,n){\n        //printf(\"%d\\n\",x[i]);\n        t=1000000000000000000ll;\n        REP(j,1,M)D[j]=d[j-((j&1)^1)]+((j==x[i])?0ll:((j<x[i])?b:a));\n        d[1]=D[1];\n        REP(j,2,M)d[j]=min(d[j-1],D[j]);\n        //REP(j,1,9)printf(\"%lld \",d[j]);printf(\"\\n\");\n    }\n    printf(\"%lld\",d[M-1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\nconstexpr double EPS = 1e-10;\n//constexpr int INF = 1001001001;\nconstexpr ll INF = 1001001001001001001ll;\n\n\n\ntemplate< typename flow_t >\nstruct PushRelabel {\n  const flow_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    int rev;\n    bool isrev;\n    int idx;\n  };\n  vector< vector< edge > > graph;\n  vector< flow_t > ex;\n  int relabels, high;\n  vector< int > cnt, h;\n  vector< vector< int > > hs;\n\n  PushRelabel(int V) : graph(V), INF(numeric_limits< flow_t >::max()), hs(V + 1), high(0) {}\n\n\n  void add_edge(int from, int to, flow_t cap, int idx = -1) {\n    graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false, idx});\n    graph[to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1, true, idx});\n  }\n\n  void update_height(int idx, int nxt_height) {\n    ++relabels;\n    if(h[idx] != graph.size() + 1) {\n      --cnt[h[idx]];\n    }\n    h[idx] = nxt_height;\n    if(h[idx] != graph.size() + 1) {\n      high = nxt_height;\n      ++cnt[nxt_height];\n      if(ex[idx] > 0) hs[nxt_height].emplace_back(idx);\n    }\n  }\n\n  void global_relabel(int idx) {\n    for(int i = 0; i <= high; i++) hs[i].clear();\n    relabels = 0;\n    high = 0;\n    h.assign(graph.size(), graph.size() + 1);\n    cnt.assign(graph.size(), 0);\n    queue< int > que;\n    que.emplace(idx);\n    h[idx] = 0;\n    while(que.size()) {\n      int p = que.front();\n      que.pop();\n      for(auto &e : graph[p]) {\n        if(h[e.to] == graph.size() + 1 && graph[e.to][e.rev].cap > 0) {\n          que.emplace(e.to);\n          high = h[p] + 1;\n          update_height(e.to, high);\n        }\n      }\n    }\n  }\n\n\n  void push(int idx, edge &e) {\n    if(h[e.to] == graph.size() + 1) return;\n    if(ex[e.to] == 0) {\n      hs[h[e.to]].emplace_back(e.to);\n    }\n    flow_t df = min(ex[idx], e.cap);\n    e.cap -= df;\n    graph[e.to][e.rev].cap += df;\n    ex[idx] -= df;\n    ex[e.to] += df;\n  }\n\n  void discharge(int idx) {\n    int next_height = (int) graph.size() + 1;\n    for(auto &&e : graph[idx]) {\n      if(e.cap > 0) {\n        if(h[idx] == h[e.to] + 1) {\n          push(idx, e);\n          if(ex[idx] <= 0) return;\n        } else {\n          next_height = min(next_height, h[e.to] + 1);\n        }\n      }\n    }\n    if(cnt[h[idx]] > 1) {\n      update_height(idx, next_height);\n    } else {\n      for(; high >= h[idx]; hs[high--].clear()) {\n        for(int j : hs[high]) update_height(j, graph.size() + 1);\n      }\n    }\n  }\n\n  flow_t max_flow(int s, int t) {\n    ex.assign(graph.size(), 0);\n    ex[s] = INF;\n    ex[t] = -INF;\n    global_relabel(t);\n    for(auto &e : graph[s]) push(s, e);\n    for(; high >= 0; high--) {\n      while(!hs[high].empty()) {\n        int idx = hs[high].back();\n        hs[high].pop_back();\n        discharge(idx);\n        if(relabels >= graph.size() * 4) global_relabel(t);\n      }\n    }\n    return ex[t] + INF;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\nint main() {\n    int N; cin >> N;\n    ll A, B; cin >> A >> B;\n    vi p(N);\n    rep(i, N) {\n        cin >> p[i];\n        p[i]--;\n    }\n\n    PushRelabel<ll> di(N * 2 + 2);\n    int s = N * 2, t = s + 1;\n\n    rep(i, N) {\n        di.add_edge(s, i, A);\n        di.add_edge(i + N, t, B);\n    }\n    rep(i, N) {\n        for (int j = i + 1; j < N; j++) {\n            if (p[i] > p[j]) di.add_edge(p[i], p[j] + N, INF);\n        }\n    }\n\n    cout << di.max_flow(s, t) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n//#define debug(x) ;\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n\nostream& operator<<(ostream& cerr, vector<ll> aux) {\n    cerr << \"[\";\n    for (auto e : aux) cerr << e << ' ';\n    cerr << \"]\";\n    return cerr;\n}\n\nconst int maxN = 5011;\nconst ll inf = 1LL << 60;\n\nint n;\nint p[maxN];\nll A, B; // A right, B left\nll on_left[maxN];\nll on_right[maxN];\nll dp[maxN];\n\nint main()\n{\n    //freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d%lld%lld\", &n, &A, &B);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &p[i]);\n    p[n + 1] = n + 1;\n\n    dp[0] = 0;\n    for (int i = 1; i <= n + 1; i++) {\n        dp[i] = inf;\n\n        for (int j = i - 1; j >= 0; j--) {\n            if (p[j] < p[i]) {\n                if (on_left[j] + on_right[i] != i - j - 1) continue;\n                dp[i] = min(dp[i], dp[j] + on_left[j] * B + on_right[i] * A);\n            } else {\n                on_left[j]++;\n                on_right[i]++; \n            }\n        }\n    }\n\n    printf(\"%lld\", dp[n + 1]);\n\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define loop(i, a, b, inc) for(int i = a; i < (b); i += inc)\n#define rep(i, n) loop(i, 0, n, 1)\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nll total = 0;\nll l;\nll r;\n\npii merge(pii a, pii b) { // assume b lower than a, and a is left of b\n\tll al = a.second-a.first+1;\n\tll bl = b.second-b.first+1;\n\n\ttotal += min(al*l, bl*r);\n\n\treturn {b.first, a.second};\n}\n\nvoid fn(vector<pii> &vec) {\n\tlist<pii> arr;\n\tarr.insert(arr.begin(), vec.begin(), vec.end());\n\n\twhile (arr.size() != 1) {\n\t\tfor (auto it = arr.begin(); it != arr.end(); it++) {\n\t\t\tif (it->first == prev(it)->second + 1) {\n\t\t\t\t*it = {prev(it)->first, it->second};\n\t\t\t\tarr.erase(prev(it));\n\t\t\t\tif (it != arr.begin()) it = prev(it);\n\t\t\t} else if (prev(it)->first == it->second + 1) {\n\t\t\t\t*it = merge(*prev(it), *it);\n\t\t\t\tarr.erase(prev(it));\n\t\t\t\tif (it != arr.begin()) it = prev(it);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n >> l >> r;\n\n\tvector<pii> arr(n);\n\trep(i, n) {\n\t\tint x;\n\t\tcin >> x;\n\t\tarr[i] = {x, x};\n\t}\n\n\tfn(arr);\n\tcout << total << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 5000;\nint n, a, b, p[maxn + 10];\nint suf[maxn + 10][maxn + 10], sum[maxn + 10][maxn + 10];\nll f[maxn + 10][maxn + 10];\nint cmp(int x, int y) {\n\treturn !x ? y : !y ? x : p[x] < p[y] ? x : y;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &p[i]);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = n; j >= 1; --j)\n\t\t\tsuf[j][i] = cmp(suf[j + 1][i], p[j] >= i ? j : 0);\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tsum[j][i] = sum[j - 1][i] + (p[j] >= i);\n\t}\n\tfor (int i = n; i >= 1; --i) {\n\t\tfor (int j = n; j >= 1; --j) {\n\t\t\tf[i][j] = 1e18;\n\t\t\tint pos = suf[i][j];\n\t\t\tif (!pos) f[i][j] = 0;\n\t\t\telse {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][p[pos] + 1] + b);\n\t\t\t\tf[i][j] = min(f[i][j], 1ll * (sum[pos - 1][j] - sum[i - 1][j]) * a + f[pos + 1][p[pos] + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\", f[1][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll A,B;\nint P[5050];\nll dp[5050][5050];\nint mor[5050],les[5050];\n\nll hoge(int L,int R) {\n\tif(L==R) return 0;\n\tif(dp[L][R]>=0) return dp[L][R];\n\tvector<int> V;\n\tint i;\n\t\n\tif(mor[L]>R) return dp[L][R]=hoge(L+1,R);\n\tif(les[R]<L) return dp[L][R]=hoge(L,R-1);\n\t\n\t\n\treturn dp[L][R]=min(B+hoge(L+1,R),A+hoge(L,R-1));\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A>>B;\n\tFOR(i,N) cin>>P[i+1];\n\tMINUS(dp);\n\t\n\tfor(x=1;x<=N;x++) {\n\t\tmor[P[x]]=5050;\n\t\tles[P[x]]=-1;\n\t\tfor(y=1;y<x;y++) if(P[y]>P[x]) mor[P[x]]=min(mor[P[x]],P[y]);\n\t\tfor(y=x+1;y<=N;y++) if(P[y]<P[x]) les[P[x]]=max(les[P[x]],P[y]);\n\t}\n\t\n\tcout<<hoge(1,N)<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <functional>\n#include <list>\n\nusing namespace std;\ntypedef long long int ll;\n\n#define repi(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,a) repi(i,0,a)\n#define rrep(i,a) for(ll i=a-1;i>=0;i--)\n#define COSTMAX A * N\n\nll llmin(ll a, ll b){\n  return a < b ? a : b;\n}\n\nint main(){\n  ll N, A, B;\n  cin >> N >> A >> B;\n  ll idx[N];\n  rep(i, N){\n    ll p;\n    cin >> p;\n    idx[p-1] = i;\n  }\n\n  ll dp[N][N+1];\n  rep(i, N) rep(j, N+1) dp[i][j] = COSTMAX;\n  if(idx[0] == 0){\n    dp[0][0] = 0;\n  } else{\n    dp[0][0] = B;\n    dp[0][idx[0]] = 0;\n  }\n\n  rep(a, N-1){\n    rep(b, N+1){\n      if(dp[a][b] == COSTMAX) continue;\n      if(b <= idx[a+1]){\n        dp[a+1][b] = llmin(dp[a+1][b], dp[a][b] + B);\n        dp[a+1][idx[a+1]] = llmin(dp[a+1][idx[a+1]], dp[a][b]);\n      }\n      else{\n        dp[a+1][b] = llmin(dp[a+1][b], dp[a][b] + A);\n      }\n    }\n  }\n  ll ans = llmin(A, B) * N;\n  rep(i, N+1) ans = llmin(ans, dp[N-1][i]);\n  cout << ans << endl;\n  // rep(i, N){\n  //   rep(j, N+1) cout << dp[i][j] << \" \";\n  //   cout << endl;\n  // }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\nconst long long INF = 1LL<<60;\nint main() {\n    long long N, A, B; cin >> N >> A >> B;\n    vector<int> p(N);\n    for (int i = 0; i < N; ++i) cin >> p[i];\n\n    // dp[i][j] := i 個まで見て、右にうごさないことを確定した最大の値が j\n    vector<vector<long long> > dp(N+1, vector<long long>(N+1, INF));\n    dp[0][0] = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            if (dp[i][j] >= INF) continue;\n            if (p[i] > j) {\n                // p[i] は右にずらさない\n                chmin(dp[i+1][p[i]], dp[i][j]);\n\n                // p[i] を右にずらすことにする\n                chmin(dp[i+1][j], dp[i][j] + A);\n            }\n            else {\n                // p[i] を左にずらすしかない\n                chmin(dp[i+1][j], dp[i][j] + B);\n            }\n        }\n    }\n\n    // 集計\n    long long res = INF;\n    for (int j = 0; j <= N; ++j) chmin(res, dp[N][j]);\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 5010;\nconst long long oo = 1e18;\nint n, p[maxn], m;\nlong long A, B;\nlong long dp[maxn][maxn << 1], mx[maxn][maxn << 1];\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n >> A >> B;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\tp[a] = i * 2;\n\t}\n\tm = n * 2 + 1;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tmx[i][0] = oo;\n\t\tfor(int j = 1; j <= m; j ++)\n\t\t{\n\t\t\tlong long a = mx[i - 1][j - 1];\n\t\t\tif(j > p[i])\n\t\t\t\ta += A;\n\t\t\telse if(j < p[i])\n\t\t\t\ta += B;\n\t\t\tdp[i][j] = a;\n\t\t\tmx[i][j] = min(mx[i][j - 1], dp[i][j]);\n\t\t}\n\t}\n\tcout << mx[n][m] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nint main() {\n    int n; i64 a, b;\n    std::cin >> n >> a >> b;\n    std::vector<int> p(n + 1);\n    for (int i = 1; i <= n; i++) {\n        int in;\n        std::cin >> in;\n        p[in] = i * 2 - 1;\n    }\n    std::vector<std::vector<i64>> dp(n + 1, std::vector<i64>(2 * n + 2));\n    std::vector<i64> v(2 * n + 2);\n    for (int i = 1; i <= n; i++) {\n        v[0] = dp[i - 1][0];\n        for (int j = 0; j < 2 * n + 1; j++) {\n            v[j + 1] = std::min(v[j], dp[i - 1][j + 1]);\n        }\n        for (int j = 0; j <= 2 * n + 1; j++) {\n            dp[i][j] = v[j] + (p[i] < j ? a : p[i] == j ? 0 : b);\n        }\n    }\n    std::cout << *std::min_element(dp[n].begin(), dp[n].end()) << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for (int i = 0; i < int(n); i++)\n\ntypedef long long ll;\n\nconst int N = 5050;\n\n\n#define left __nico_left\n#define right __nico_right\nint n, p[N], r[N], left, right;\nll dp[N][N], gt[N][N];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >>n >> right >> left;\n    forn(i,n) {\n        cin >>p[i];\n        --p[i];\n        r[p[i]] = i;\n    }\n    forn(i,n) {\n        int pos = r[i];\n        for (int j = pos-1; j >= 0; j--) {\n            gt[i][j] = gt[i][j+1] + (p[j] > p[pos]);\n        }\n    }\n\n    for (int from = n-1; from >= 0; from--) {\n        for (int first = n-1; first >= 0; first--) {\n            if (r[first] < from) {\n                dp[from][first] = dp[from][first+1];\n            }\n            else {\n                ll cost = gt[first][from] > 0 ? left : 0;\n                dp[from][first] = min(\n                    cost + dp[from][first+1],\n                    (ll) right * gt[first][from] + dp[r[first]+1][first]\n                );\n            }\n        }\n    }\n    cout << dp[0][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint a;\nlong long int b,c;\nint x[5010];\nstd::pair<int,int> start[5010][5010];\nlong long int check[5010][5010];\nlong long int func(int s, int t)\n{\n\tif(s==t) return 0;\n\tif(check[s][t]!=-1) return check[s][t];\n\t\n\tif(start[s][t].first==0)\n\t{\n\t\tif(start[s][t+1].first!=0)\n\t\t{\n\t\t\tfor(int i=start[s][t+1].first;i<=a;i++)\n\t\t\t{\n\t\t\t\tif(x[i]<s) continue;\n\t\t\t\tif(x[i]>t) continue;\n\t\t\t\tstart[s][t].first = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=start[s-1][t].first;i<=a;i++)\n\t\t\t{\n\t\t\t\tif(x[i]<s) continue;\n\t\t\t\tif(x[i]>t) continue;\n\t\t\t\tstart[s][t].first = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(start[s][t].second==0)\n\t{\n\t\tif(start[s-1][t].second!=0)\n\t\t{\n\t\t\tfor(int i=start[s-1][t].second;i>=1;i--)\n\t\t\t{\n\t\t\t\tif(x[i]<s) continue;\n\t\t\t\tif(x[i]>t) continue;\n\t\t\t\tstart[s][t].second = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=start[s][t+1].second;i>=1;i--)\n\t\t\t{\n\t\t\t\tif(x[i]<s) continue;\n\t\t\t\tif(x[i]>t) continue;\n\t\t\t\tstart[s][t].second = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(x[start[s][t].first]==s) return func(s+1,t);\n\tif(x[start[s][t].second]==t) return func(s,t-1);\n\tlong long int s1 = func(s+1,t)+c;\n\tlong long int s2 = func(s,t-1)+b;\n\treturn check[s][t] = s1<s2?s1:s2;\n}\nint main()\n{\n\tscanf(\"%d%lld%lld\",&a,&b,&c);\n\tstart[1][a].first = 1;\n\tstart[1][a].second = a;\n\tfor(int i=1;i<=a;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=a;i++) for(int j=1;j<=a;j++) check[i][j] = -1;\n\tprintf(\"%lld\",func(1,a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\nusing ll = long long;\ntypedef pair<int, int> P;\nll Mod = 1000000007;\n\nint N;\nll A,B;\nint p[5012];\nll C[5012];\nbool Graph[5012][5012];\nbool Tr[5012];\nbool exist[5012];\nll max_S[5012];\n\nll DFS(int a,ll now) {\n  Tr[a] = true;\n  ll f = now;\n  if (max_S[a] >= now) {\n    return 0;\n  } else {\n    max_S[a] = now;\n  }\n  int min_num = 99999;\n  for (int i = a+1; i < N; i++) {\n    if (Graph[a][i]) {\n      Tr[i] = true;\n      if (min_num < p[i]) {\n        continue;\n        \n      } else {\n        min_num = p[i];\n      }\n      f = max(f,DFS(i,now+C[i])); \n    }\n  }\n  return f;\n}\n\nint main() {\n  cin >> N >> A >> B;\n  for (int i = 0; i < N; i++) {\n    cin >> p[i];\n    p[i]--;\n    max_S[i] = -1;\n  }\n  ll normal_cost = 0;\n  for (int i = 0; i < N; i++) {\n    if (p[i] > i) {\n      normal_cost += A;\n      C[i] = A;\n    } else if (p[i] < i) {\n      normal_cost += B;\n      C[i] = B;\n    } else {\n      C[i] = 0;\n    }\n  }\n  \n  for (int i = 0; i < N; i++) {\n    for (int j = i; j < N; j++) {\n      if (p[i] < p[j]) {\n        exist[i] = true;\n        Graph[i][j] = true;\n      }\n    } \n  }\n  ll ans = normal_cost;\n  ans = min(ans,A*(N-1));\n  ans = min(ans,B*(N-1));\n  for (int i = 0; i < N; i++) {\n    if (Tr[i]) {\n      continue;\n    }\n    ll res = normal_cost;\n    if (!exist[i]) {\n      continue;\n    }\n    res -= C[i];\n    res -= DFS(i,0LL);\n    ans = min(ans,res);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n\nconst int MAX_N = 5000 + 7;\n\nint n;\nint A[MAX_N];\nint lmin[MAX_N], rmax[MAX_N];\nll l, r;\nll dp[MAX_N][MAX_N];\n\n\nint main() {\n    scanf(\"%d%lld%lld\", &n, &r, &l);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &A[i]);\n    \n    for (int i = 1; i <= n; i++) {\n        lmin[A[i]] = 87878787;\n        for (int j = 1; j < i; j++)\n            if (A[j] > A[i])\n                lmin[A[i]] = min(lmin[A[i]], A[j]);\n        rmax[A[i]] = -1;\n        for (int j = n; j > i; j--)\n            if (A[j] < A[i])\n                rmax[A[i]] = max(rmax[A[i]], A[j]);\n    }\n\n    /*for (int i = 1; i <= n; i++)\n        printf(\"%d \", lmin[i]);\n    printf(\"\\n\");\n    for (int i = 1; i <= n; i++)\n        printf(\"%d \", rmax[i]);\n    printf(\"\\n\");*/\n\n    for (int i = 0; i <= n; i++)\n        dp[i][n - i] = 0;\n    for (int sum = n - 1; sum >= 0; sum--)\n        for (int i = 0; i <= sum; i++) {\n            int j = sum - i;\n            dp[i][j] = l + dp[i + 1][j];\n            if (lmin[i + 1] >= n - j + 1)\n                dp[i][j] = min(dp[i][j], dp[i + 1][j]);\n            dp[i][j] = min(dp[i][j], r + dp[i][j + 1]);\n            if (rmax[n - j] <= i)\n                dp[i][j] = min(dp[i][j], dp[i][j + 1]);\n            //printf(\"!!!!!%d %d: %lld\\n\", i, j, dp[i][j]);\n        }\n    printf(\"%lld\\n\", dp[0][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, a, b;\n\tcin >> n >> a >> b;\n\tvi v(n);\n\tREP(i, n) {\n\t\tcin >> v[i];\n\t}\n\tvvl dp(n + 1, vl(n+1, INF*INF));\n\tdp[0][0] = 0;\n\tREP(i, n) {\n\t\tll m = *min_element(dp[i].begin(), dp[i].begin() + v[i]);\n\t\tdp[i + 1][v[i]] = m;\n\t\tREP(j, v[i])dp[i + 1][j] = dp[i][j] + a;\n\t\tFOR(j, v[i] + 1, n + 1) dp[i + 1][j] = dp[i][j] + b;\n\t}\n\tcout << *min_element(ALL(dp[n])) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int N=5005;\nint n,A,B,p[N];long long dp[N][N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&p[i]);\n\tmemset(dp,63,sizeof(dp));\n\tfor(int i=1;i<=n;++i){\n\t\tdp[i][i]=min(dp[i][i],1ll*(i-1)*A);\n\t\tfor(int j=1;j<i;++j)\n\t\t\tif(p[j]<p[i]){\n\t\t\t\tdp[i][i]=min(dp[i][i],dp[i-1][j]);\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+A);\n\t\t\t}else{\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+B);\n\t\t\t}\n\t}\n\tlong long ans=dp[0][0];\n\tfor(int i=1;i<=n;++i)ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 5e3 + 11;\n#define LL long long\nLL f[N][N], A, B, a[N];\nint n;\nint main(){\n\tcin>>n>>A>>B;\n\tmemset(f, 127, sizeof(f));\n\tf[0][0] = 0;\n\tfor(int i = 1;i <= n; i++)cin>>a[i];\n\tfor(int i = 0;i < n; i++){\n\t\tLL x = a[i+1];\n\t\tfor(int j = 0;j <= n; j++){\n\t\t\tif(j <= x){\n\t\t\t\tf[i+1][j] = min(f[i+1][j], f[i][j] + A);\n\t\t\t\tf[i+1][x] = min(f[i+1][x], f[i][j]);\n\t\t\t}\n\t\t\tif(j > x){\n\t\t\t\tf[i+1][j] = min(f[i+1][j], f[i][j] + B);\n\t\t\t}\n\t\t}\n\t}\n\tLL ans = 1e18;\n\tfor(int i = 0;i <= n; i++){\n\t\tans = min(ans, f[n][i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 5000+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nint a[MAX_N];\nint pos[MAX_N];\nll dp[MAX_N][MAX_N];\nint d[MAX_N][MAX_N];\nint cnt[MAX_N][MAX_N];\nll n,l,r;\n\nint main()\n{\n    cin >> n >> r >> l;\n    for(int i = 1;i<=n;++i)\n        cin >> a[i],pos[a[i]] = i;\n    for(int i = n;i>=1;--i)\n        for(int j = pos[i];j<=n;++j)\n            d[j][i] = pos[i];\n    for(int i = 1;i<=n;++i)\n    {\n        for(int j = 1;j<=n;++j)\n        {\n            cnt[i][j] = cnt[i-1][j] + (a[i]<=j);\n        }\n    }\n    for(int i = 1;i<=n;++i)\n    {\n        for(int j = 1;j<=n;++j)\n        {\n            if (!d[i][j])\n            {\n                dp[i][j] = dp[i][j-1];\n                continue;\n            }\n            if (d[i][j]==i)\n            {\n                dp[i][j] = dp[i-1][j];\n                continue;\n            }\n            int t = cnt[i][j]-cnt[d[i][j]][j];\n            dp[i][j] = min(dp[i][j-1]+r,dp[d[i][j]][j-1]+l*t);\n        }\n    }\n    cout << dp[n][n];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef long long ll;\nconst ll inf=1e18;\nvoid fmin(ll&a,ll b){\n\tb<a?a=b:0;\n}\nint p[5010];\nll f[5010],g[5010],tf[5010],tg[5010];\nint main(){\n\tint n,a,b,i,j;\n\tll t;\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d\",&j);\n\t\tp[j]=i;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tt=inf;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tfmin(t,g[j-1]);\n\t\t\ttf[j]=t+(p[i]<j?a:(p[i]>j?b:0));\n\t\t\tfmin(t,f[j]);\n\t\t}\n\t\tt=inf;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tfmin(t,g[j]);\n\t\t\ttg[j]=t+(p[i]<=j?a:(p[i]>j?b:0));\n\t\t\tfmin(t,f[j+1]);\n\t\t}\n\t\tmemcpy(f,tf,sizeof(tf));\n\t\tmemcpy(g,tg,sizeof(tg));\n\t}\n\tt=inf;\n\tfor(i=1;i<=n;i++)fmin(t,f[i]);\n\tfor(i=0;i<=n;i++)fmin(t,g[i]);\n\tprintf(\"%lld\",t);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 5500;\nll c[maxn],f[maxn],ans;\nbool vis[maxn];\nint n,a[maxn];\nll A,B,C;\nll query(int x){\n    ll ans = 1ll<<60;\n    Rep(i,1,x) ans=min(ans,c[i]);\n    return ans;\n}\nvoid add(int x,int v){\n    c[x] = v;\n    vis[x] = true;\n}\nvoid modify(int x,int C){\n    Rep(i,x+1,n) if(vis[i])\n        c[i] += C;\n}\nint main(){\n    n = read(),A = read(),B = read();\n    Rep(i,1,n) a[i] = read();\n    if(A>B){\n        swap(A,B);\n        reverse(a+1,a+1+n);\n    }\n    C = min(A,B);assert(C==A);\n    ans = 1ll << 60;\n    Rep(i,1,n){//A是右移，B是左移 \n        f[i] = (i - 1) * A;\n        f[i] = min(f[i],query(a[i]) + i * C - C);\n//        writeln(query(a[i]));\n//        printf(\"f[%d] = %d\\n\",i,f[i]);\n        modify(a[i],B - C);\n        add(a[i],f[i] - i * C);\n        ans = min(ans,f[i] + B * (n - i));\n//        Rep(j,1,n) wri(c[j]);puts(\"\");\n    }writeln(ans);\n    return 0;\n}\n//f[3] = f[2]\n//[3,4,6,9]"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nint main() {\n    int n; i64 a, b;\n    std::cin >> n >> a >> b;\n    std::vector<int> p(n + 1);\n    for (int i = 1; i <= n; i++) {\n        int in;\n        std::cin >> in;\n        p[in] = i * 2 - 1;\n    }\n    std::vector<std::vector<i64>> dp(n + 1, std::vector<i64>(2 * n + 2));\n    std::vector<i64> v(2 * n + 2);\n    for (int i = 1; i <= n; i++) {\n        v[0] = std::numeric_limits<i64>::max();\n        dp[i][0] = dp[i - 1][0] + b;\n        for (int j = 0; j < 2 * n + 1; j++) {\n            v[j + 1] = std::min(v[j], dp[i - 1][j]);\n            dp[i][j + 1] = v[j + 1] + (p[i] < j + 1 ? a : p[i] == j + 1 ? 0 : b);\n        }\n    }\n    std::cout << *std::min_element(dp[n].begin(), dp[n].end()) << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout << (x) << '\\n'\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 1e9 + 7;\nconstexpr int MAX = 500050;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\n\n\n\nint p[5050];\nint dp[5050][5050];\nvoid solve() {\n\tint N, A, B; cin >> N >> A >> B;\n\tREP(i, N)cin >> p[i];\n\tREP(i, N + 1)REP(j, N + 1)dp[i][j] = LINF;\n\tdp[0][0] = 0;\n\tREP(i, N+1) {\n\t\tREP(j, N+1) {\n\t\t\tchmin(dp[i][j + 1], dp[i][j]);\n\t\t\tif (p[i] == j + 1)chmin(dp[i + 1][j + 1], dp[i][j]);\n\t\t\tif (p[i] > j + 1)chmin(dp[i + 1][j], dp[i][j]+A);\n\t\t\tif (p[i] < j + 1)chmin(dp[i + 1][j], dp[i][j]+B);\n\t\t}\n\t}\n\tprint(dp[N][N]);\n}\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll dp[5005][5005],a,b;\nint n,p[5005],pos[5005];\n\nint main(){\n\tscanf(\"%d %lld %lld\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&p[i]),pos[p[i]]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tdp[i][j]=1e18;\n\t\t\tif(j==pos[i]){dp[i][j]=min(dp[i][j],dp[i-1][j-1]);}\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+((j<pos[i])?b:a));\n\t\t}\n\t\tfor(int j=1;j<=n;j++) dp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t}\n\tprintf(\"%lld\\n\",dp[n][n]); \n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sort stable_sort\n#define all(x) (x).begin(),(x).end()\n#define rep(i,x) for (int (i)=(1);(i)<=(x);(i)++)\n#define rep2(i,x) for (int (i)=(x);(i)>=(1);(i)--)\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\nusing namespace std;\nlong long n,A,b,f[5005],pos[5005],ans,a[5005],c[5005];\nint main(){\n\tans=0x7f7f7f7f7f7f7f7fll;\n\tcin>>n>>A>>b;\n\trep(i,n) f[i]=ans;\n\trep(i,n){\n\t\tcin>>a[i];\n\t\tpos[a[i]]=i;\n\t}\n\trep(i,n){\n\t\tc[i]=c[i-1]+(i<a[i]?A:b);\n\t}\n\trep(i,n){\n\t\tlong long s=0;\n\t\tfor (int j=i-1;j>=0;j--){\n\t\t\tif (a[j]<a[i]){\n\t\t\t\tf[i]=min(f[i],f[j]+s);\n\t\t\t\ts+=b;\n\t\t\t} else {\n\t\t\t\ts+=A;\n\t\t\t}\n\t\t}\n\t\tans=min(ans,f[i]+(n-i)*b);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define MAX_V 1000\n\n//rev: G[to][rev]で逆辺にアクセスできるようにしている\nstruct edge {int to;ll cap;int rev;};\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, ll cap){\n\tG[from].push_back((edge){to, cap, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\n//vからtに流せたフローの量を返す　fはvが保持しているフローの量\nll dfs(int v, int t, ll f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tll d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nll max_flow(int s, int t){\n\tll flow = 0;\n\tfor(;;){\n\t\tmemset(used,0,sizeof(used));//usedを0で初期化してるだけ\n\t\tll f = dfs(s,t,LINF);\n\t\tif(f==0) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main(void){\n\tint n,p;\n\tll a,b;\n\tcin>>n>>a>>b;\n\tvector<int> P;\n\trep(i,n){\n\t\tcin>>p;\n\t\tP.push_back(p);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i>=j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(P[i]>P[j]){\n\t\t\t\tadd_edge(i+1,n+j+1,LINF);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n){\n\t\tadd_edge(0,i+1,a);\n\t}\n\trep(i,n){\n\t\tadd_edge(n+i+1,2*n+1,b);\n\t}/*\n\trep(i,2*n+2){\n\t\tcout<<i<<\" \";\n\t\trep(j,G[i].size()){\n\t\t\tcout << G[i][j].to << \" \" << G[i][j].cap<<\", \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\n\n\tcout<<max_flow(0,2*n+1)<<endl;;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define sz size()\n#define pb push_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\n\nint N;\nLL A, B;\n\nint p[10000], pos[10000];\n\nLL dp[6000][6000];\n\nLL cnt[6000][6000];\n\nLL memo(int idx, int largest) {\n\tif (idx < 0 || largest < 0)\n\t\treturn 0LL;\n\t\t\n\tLL &ret = dp[idx][largest];\n\tif (ret != -1)\n\t\treturn ret;\n\t\t\n\tif (p[idx] == largest)\n\t\treturn ret = memo(idx - 1, largest - 1);\n\t\t\n\tif (p[idx] > largest)\n\t\treturn ret = memo(idx - 1, largest);\n\t\t\n\tif (pos[largest] > idx)\n\t\treturn ret = memo(idx, largest - 1);\n\t\t\n\tret = A + memo(idx, largest - 1);\n\tLL tmp = B * (cnt[largest][idx + 1] - cnt[largest][pos[largest]]);\n/*\tffor (i, pos[largest], idx + 1)\n\t\tif (p[i] < largest)\n\t\t\ttmp += B;*/\n\tret = min(ret, tmp + memo(pos[largest] - 1, largest - 1));\n\t\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcin >> N >> A >> B;\n\t\n\tFOR (i, N) {\n\t\tcin >> p[i];\n\t\tp[i]--;\n\t\tpos[p[i]] = i;\n\t}\n\t\n\tFOR (i, N) {\n\t\tcnt[i][0] = 0;\n\t\tFOR (j, N)\n\t\t\tcnt[i][j + 1] = cnt[i][j] + (p[j] < i);\n\t}\n\t\n\tSET(dp, 255);\n\tcout << memo(N - 1, N - 1) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define pb push_back\n#define ppb pop_back\n#define F first\n#define S second\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 5003;\nint n, a, b, p[N], ind[N], fen[N];\nll dp[N];\n\nvoid upd(int x, int y) {\n\tfor (; x <= n + 1; x |= (x + 1)) {\n\t\tfen[x] += y;\n\t}\n}\n\nint get(int x) {\n\tint res = 0;\n\tfor (; x >= 0; x = (x & (x + 1)) - 1) {\n\t\tres += fen[x];\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tcin >> n >> a >> b;\n\tp[0] = 0;\n\tp[n + 1] = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> p[i];\n\t\tind[p[i]] = i;\n\t}\n\tind[0] = 0;\n\tind[n + 1] = n + 1;\n\tmemset(& dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tfor (int j = p[i] - 1; j >= 0; j--) {\n\t\t\tif (ind[j] < i) {\n\t\t\t\tll inner = get(i - 1) - get(ind[j]);\n\t\t\t\tll l = get(ind[j]);\n\t\t\t\tll r = get(n + 1) - get(i);\n\t\t\t\tdp[i] = min(dp[i], dp[ind[j]] + inner * min(a, b) + l * a + r * b);\n\t\t\t}\n\t\t\tupd(ind[j], 1);\n\t\t}\n\t\tfor (int j = p[i] - 1; j >= 0; j--) {\n\t\t\tupd(ind[j], -1);\n\t\t}\n\t}\n\tcout << dp[n + 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ts cout<<\"ok\"<<endl\n#define int long long\n#define hh puts(\"\")\n#define pc putchar\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\n//char buf[1<<21],*p1=buf,*p2=buf;\nusing namespace std;\nconst int N=5005;\nint n,A,B,a[N],pos[N],dp[N][N],s[N][N];\ninline int read(){\n    int ret=0,ff=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}\n    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}\n    return ret*ff;\n}\nvoid write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}\nvoid writeln(int x){write(x),hh;}\nvoid writesp(int x){write(x),pc(' ');}\nsigned main(){\n\tn=read(),A=read(),B=read();\n\tfor(int i=1;i<=n;i++) a[i]=read(),pos[a[i]]=i;\n\tmemset(dp,0x3f,sizeof(dp));\n\tmemset(s,0x3f,sizeof(s));\n\tfor(int i=0;i<=n;i++) s[0][i]=dp[0][i]=0;\n\tfor(int i=1;i<=n;i++){//从小到大放 \n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(pos[i]==j) dp[i][j]=min(dp[i][j],s[i-1][j-1]);\n\t\t\tdp[i][j]=min(dp[i][j],s[i-1][j]+(j<pos[i]?B:A));\n\t\t}\n\t\ts[i][0]=dp[i][0];\n\t\tfor(int j=1;j<=n;j++) s[i][j]=min(s[i][j-1],dp[i][j]);\n\t}\n\twrite(s[n][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,f[5005];\nlong long dp[5005][5005];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n;i++)\n    {\n        int x;\n        scanf(\"%d\",&x);\n        f[x]=i;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        int pos=f[i];\n        long long t=1e18;\n        for(int j=1;j<=n;j++)\n        {\n            t=min(t,dp[i-1][j]);\n            if(pos==j) dp[i][j]=t;\n            else if(pos>j) dp[i][j]=t+b;\n            else dp[i][j]=t+a;\n        }\n    }\n    long long ans=1e18;\n    for(int i=1;i<=n;i++)\n        ans=min(ans,dp[n][i]);\n    printf(\"%lld\\n\",ans);\n}\n/*dp[i][j]表示将第i个数搬移到前j个位置的最小价值*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEBUG\n#include \"better_io.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\nconstexpr int MAXN = 5042;\n\nint N, A, B;\nint V[MAXN];\nint pos[MAXN];\nll gt[MAXN][MAXN];\nll dp[MAXN][MAXN];\n\nll solve(int i, int x) {\n\tif(i == N) return 0;\n\tif(x == N-1) return 0;\n\tif(dp[i][x] != -1) return dp[i][x];\n\tdp[i][x] = min(solve(i, x + 1) + B, solve(pos[x] + 1, x + 1) + A * gt[i][pos[x]]);\n\treturn dp[i][x];\n}\n\nint main() {\n\tmemset(dp, -1, sizeof dp);\n\t\n\tcin >> N >> A >> B;\n\t\n\tfor(int i=0; i<N; i++) {\n\t\tcin >> V[i];\n\t\tV[i]--;\n\t\tpos[V[i]] = i;\n\t}\n\t\n\tfor(int j=0; j<N; j++) {\n\t\tfor(int i=j-1; i>=0; i--) {\n\t\t\tgt[i][j] = gt[i+1][j] + (V[i] > V[j]);\n\t\t}\n\t}\n\t\n\tcout << solve(0, 0) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 5005;\nconst long long INF = 1E18 + 7;\n\nint n, cl, cr, a[N], pl[N][N], pr[N][N];\nlong long dp[N][N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> cl >> cr;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = i; j >= 1; j--) {\n            pl[i][j] =  pl[i][j + 1] + (a[j] > a[i]);\n        }\n        for (int j = i; j <= n; j++) {\n            pr[i][j] =  pr[i][j - 1] + (a[j] < a[i]);\n        }\n    }\n    for (int l = n; l >= 1; l--) {\n        for (int r = l; r <= n; r++) {\n            dp[l][r] = min(dp[l][r - 1] + min(1LL * cr, 1LL * cl * pl[r][l]),\n                           dp[l + 1][r] + min(1LL * cl, 1LL * cr * pr[l][r]));\n        }\n    }\n    cout << dp[1][n];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(NULL);\n\n  int n, X, Y; cin >> n >> X >> Y;\n  vector<int> a(n);\n  for(int &x : a) cin >> x;\n\n  vector<vector<long long>> f(n + 1, vector<long long>(n + 2, 1e18));\n\n  f[0][0] = 0;\n  for(int i = 0; i < n; ++i) {\n    for(int j = 0; j <= n; ++j) {\n      if(j > 0) f[i][j] = min(f[i][j], f[i][j - 1]);\n\n      if(a[i] > j) {\n        f[i + 1][a[i]] = min(f[i + 1][a[i]], f[i][j]);\n        f[i + 1][j] = min(f[i + 1][j], f[i][j] + X);\n      }\n      else {\n        f[i + 1][j] = min(f[i + 1][j], f[i][j] + Y);\n      }\n    }\n  }\n\n  cout << *min_element(f[n].begin(), f[n].end()) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    int N;\n    long long A, B;\n    while(cin >> N >> A >> B){\n        vector<int> p(N);\n        for(auto& t : p) cin >> t;\n        vector<long long> dp(2*N+1, 0);\n        bool find1 = false;\n        for(int i=0;i<=2*N;i++){\n            if(i%2 == 1 && p[i/2] == 1){\n                find1 = true;\n            } else {\n                dp[i] = (find1 ? A : B);\n            }\n        }\n        for(int i=2;i<=N;i++){\n            vector<long long> next(2*N+1, 0);\n            long long m = dp[0];\n            bool find = false;\n            for(int j=0;j<=2*N;j++){\n                if(j%2 == 1){\n                    if(p[j/2] == i){\n                        next[j] = m;\n                        find = true;\n                    } else {\n                        next[j] = m + (find ? A : B);\n                    }\n                } else {\n                    next[j] = min(m, dp[j]) + (find ? A : B);\n                }\n                m = min(m, dp[j]);\n            }\n            dp = next;\n        }\n        cout << *min_element(dp.begin(), dp.end()) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\nauto constexpr INF32 = numeric_limits<int32_t>::max()/2-1;\nauto constexpr INF64 = numeric_limits<int64_t>::max()/2-1;\nauto constexpr INF   = numeric_limits<int>::max()/2-1;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#define dump(...) cerr << \"[\" << setw(3) << __LINE__ << \":\" << __FUNCTION__ << \"] \", dump_impl(#__VA_ARGS__, __VA_ARGS__)\n#define say(x) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \" << x << endl\n#define debug if (1)\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n\nint32_t main() {\n    int n,A,B; cin >> n >> A >> B;\n    vector<int> p(n); cin >> p;\n\n    auto dp = make_v<int,2>(n+1,n+1,INF);\n    dp[0][0] = 0;\n    rep (i,n) rep (j,n+1) if (dp[i][j] < INF) {\n        if (j < p[i]) {\n            chmin(dp[i+1][p[i]], dp[i][j]);\n            chmin(dp[i+1][j], dp[i][j] + A);\n        }\n        chmin(dp[i+1][max(j,p[i])], dp[i][j] + B);\n    }\n    dump(as_mat(dp));\n\n    cout << *min_element(all(dp[n])) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\n\nlong long dp[5010];\nint a[5010], pos[5010];\n\nvoid chmin(long long &a, long long b){a = a < b ? a : b;}\n\nstruct Segment_tree{\n\tlong long minj[20010], lazy[20010];\n\tvoid pushup(int now){\n\t\tminj[now] = min(minj[now << 1], minj[now << 1 | 1]);\n\t}\n\tvoid pushdown(int now){\n\t\tif (lazy[now] == INF) return ;\n\t\tlong long v = lazy[now]; lazy[now] = INF;\n\t\tchmin(minj[now << 1], v);\n\t\tchmin(lazy[now << 1], v);\n\t\tchmin(minj[now << 1 | 1], v);\n\t\tchmin(lazy[now << 1 | 1], v);\n\t}\n\tvoid Build(int now, int l, int r){\n\t\tmemset(minj, 0x3f, sizeof(minj));\n\t\tmemset(lazy, 0x3f, sizeof(lazy));\n\t}\n\tvoid Update(int now, int l, int r, int L, int R, long long x){\n\t\tif (l == L && r == R){\n\t\t\tchmin(minj[now], x);\n\t\t\tchmin(lazy[now], x);\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(now);\n\t\tint mid = l + r >> 1;\n\t\tif (R <= mid) Update(now << 1, l, mid, L, R, x);\n\t\telse if (L > mid) Update(now << 1 | 1, mid + 1, r, L, R, x);\n\t\telse Update(now << 1, l, mid, L, mid, x), Update(now << 1 | 1, mid + 1, r, mid + 1, R, x);\n\t\tpushup(now);\n\t}\n\tvoid get_dp(int now, int l, int r){\n\t\tif (l == r){\n\t\t\tdp[l] = minj[now];\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(now);\n\t\tint mid = l + r >> 1;\n\t\tget_dp(now << 1, l, mid), get_dp(now << 1 | 1, mid + 1, r);\n\t}\n}seg;\n\nint main(){\n\tint n, A, B;\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tpos[a[i]] = i + 1;\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[0] = 0;\n\tfor (register int i = 1; i <= n; i++){\n\t\tseg.Build(1, 0, n);\n\t\tint x = pos[i];\n\t\tfor (register int j = 0; j <= n; j++){\n\t\t\tif (dp[j] == INF) continue;\n\t\t\tif (j < x) seg.Update(1, 0, n, j, x - 1, dp[j] + B);\n\t\t\tif (j <= x) seg.Update(1, 0, n, x, x, dp[j]);\n\t\t\tseg.Update(1, 0, n, max(x, j), n, dp[j] + A);\n\t\t}\n\t\tseg.get_dp(1, 0, n);\n\t}\n\tlong long ans = INF;\n\tfor (int i = 0; i <= n; i++){\n\t\tchmin(ans, dp[i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nlong long dp[5010][5010];\n\n\nclass Solution {\n  int n;\n  vector<int> A;\n  long long costA, costB;\n  long long dfs(int i, int j) {\n    if (dp[i][j] != -1) return dp[i][j];\n    if (j - i == 1) return dp[i][j] = 0;\n    long long ans = 1e18;\n    for (int k = i + 1; k < j; ++k) {\n      if (A[i] < A[k] and A[k] < A[j]) {\n        ans = min(ans, dfs(i, k) + dfs(k, j));\n      }\n    }\n    if (ans == 1e18) {\n      ans = 0;\n      for (int k = i + 1; k < j; ++k) ans += A[k] < A[i] ? costB : costA;\n    }\n    return dp[i][j] = ans;\n  }\npublic:\n  void run() {\n    memset(dp, -1, sizeof(dp));\n    cin >> n;\n    cin >> costA >> costB;\n    A = {0};\n    for (int i = 0; i < n; ++i) {\n      int a; cin >> a;\n      A.push_back(a);\n    }\n    A.push_back(n + 1);\n    cout << dfs(0, n + 1) << '\\n';\n  }     \n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  Solution().run();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<ctime>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define mp(x,y) make_pair(x,y)\n#define qmin(x,y) (x=min(x,y))\n#define qmax(x,y) (x=max(x,y))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n\tint ans=0,fh=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-') fh=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t\tans=(ans<<1)+(ans<<3)+ch-'0',ch=getchar();\n\treturn ans*fh;\n}\nconst int maxn=5e3+100;\nint n,A,B,p[maxn];\nll f[maxn][maxn],g[maxn];\nint main(){\n\t//freopen(\"nh.in\",\"r\",stdin);\n\t//freopen(\"zhy.out\",\"w\",stdout);\n\tn=read(),A=read(),B=read();\n\tfor(int i=1;i<=n;i++) p[i]=read();\n\tp[++n]=n+1;\n\tmemset(f,0x3f,sizeof(f));\n\tmemset(g,0x3f,sizeof(g));\n\tfor(int i=0;i<=n;i++){\n\t\tf[i][i]=0;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tf[i][j]=f[i][j-1]+(p[j]>p[i]?A:B);\n\t}\n\tg[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t\tif(p[j]<p[i]) qmin(g[i],g[j]+f[j][i-1]);\n\tprintf(\"%lld\\n\",g[n]);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid solve() {\n  int n, a, b; cin >> n >> a >> b;\n  vi p(n); cin >> p;\n\n  const ll INFTY = 1LL<<60;\n\n  Graph<ll> dp(n+1, vl(n+1, INFTY));\n  dp[0][0] = 0;\n\n  rep(i,n) {\n    repeq(j,n) {\n      if (dp[i][j] != INFTY) {\n        if (j < p[i]) {\n          chmin(dp[i+1][p[i]], dp[i][j]);\n          chmin(dp[i+1][j], dp[i][j] + a);\n        } else {\n          chmin(dp[i+1][j], dp[i][j] + b);\n        }\n      }\n    }\n  }\n\n  cout << *min_element(ALL(dp[n])) << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(s) s.begin(), s.end()\n#define vi vector<int>\n#define pb push_back\n#define ii pair<int, int>\n#define x first\n#define y second\n#define int long long\n\nconst int N = 5005;\n\nint n, a, b;\nint p[N];\nint coor[N];\nint notMove[N];\nint dp[N][N], mn[N][N];\n\nmain() {\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> a >> b;\n    for (int i = 1; i <= n; i++) {\n        cin >> p[i];\n        coor[p[i]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n + 1; j++) {\n            int foo = mn[i - 1][j];\n            if (coor[i - 1] < j) foo = min(foo, notMove[i - 1]);\n            if (coor[i] >= j) {\n                dp[i][j] = foo + b; \n            } else {\n                dp[i][j] = foo + a;\n            }\n        }\n        int foo = mn[i - 1][coor[i]];\n        if (coor[i - 1] < coor[i]) {\n            foo = min(foo, notMove[i - 1]);\n        }\n        notMove[i] = foo;\n        mn[i][1] = dp[i][1];\n        for (int j = 2; j <= n + 1; j++) {\n            mn[i][j] = min(mn[i][j - 1], dp[i][j]);\n        }\n    }\n    cout << min(mn[n][n + 1], notMove[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define SZ(x) (int)x.size()-1\n#define F(i,a,b) for (int i=a;i<=b;++i)\n#define DF(i,a,b) for (int i=a;i>=b;--i)\n#define pb push_back\n#define ms(a,b) memset(a,b,sizeof a)\nusing namespace std;\nint read(){\n    char ch=getchar(); int w=1,c=0;\n    for (;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;\n    for (;isdigit(ch);ch=getchar()) c=(c<<3)+(c<<1)+(ch^48);\n    return w*c;\n}\nconst int M=5050;\nLL dp[M][M];\nint n,A,B,a[M],pos[M];\nint val(int x,int d){\n\tif (2*pos[x]<d) return A;\n\tif (2*pos[x]>d) return B;\n\treturn 0;\n}\nint main(){\n\tn=read(); A=read(); B=read();\n\tF(i,1,n) a[i]=read(),pos[a[i]]=i;\n\tms(dp,1); dp[0][0]=0;\n\tF(i,0,n){\n\t\tF(j,0,n){\n\t\t\tif (i) dp[i][j]=min(dp[i][j],dp[i-1][j]);\n\t\t\tif (j) dp[i][j]=min(dp[i][j],dp[i][j-1]+val(j,2*i+1));\n\t\t\tif (i&&j) dp[i][j]=min(dp[i][j],dp[i-1][j-1]+val(j,2*i));\n//\t\t\tcout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<\"   ouoh\\n\";\n\t\t}\n\t}\n\tcout<<dp[n][n]<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=5010;\nconst LL INF=1e15;\nint n;\nLL cl,cr,a[N],c[N];\nLL dp[N][N];\nvoid main() {\n    R(n,cl,cr);\n    REP1(i,1,n) R(a[i]);\n    REP1(i,1,n) c[i]=(a[i]>i?cl:cr);\n    REP1(i,1,n+1) REP1(j,1,n) dp[i][j]=INF;\n    dp[1][1]=0;\n    REP1(i,1,n) REP1(j,1,n) {\n        auto me=dp[i][j];\n        if ( me==INF) continue;\n        chkmin(dp[i+1][j],me+c[i]);\n        if ( j<=a[i] ) chkmin(dp[i+1][a[i]],me);\n    }\n    LL ans=INF;\n    REP1(i,1,n) chkmin(ans,dp[n+1][i]);\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nlong long dp[5100];\nint p[5100];\nint bit[5100];\nint sum(int a,int b){\n\tif(a)return sum(0,b)-sum(0,a-1);\n\tint ret=0;for(;b>=0;b=(b&(b+1))-1)ret+=bit[b];return ret;\n}\nvoid add(int a,int b){\n\tfor(;a<5100;a|=a+1)bit[a]+=b;\n}\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);p[i]--;\n\t}\n\tfor(int i=0;i<=a;i++)\n\t\tdp[i]=inf;\n\tdp[0]=0;\n\tlong long ret=inf;\n\tfor(int i=0;i<=a;i++){\n\t\tif(i>0){\n\t\t\tlong long tmp=dp[i];\n\t\t\tfor(int j=i;j<a;j++){\n\t\t\t\tif(p[j]<p[i-1])tmp+=c;\n\t\t\t\telse tmp+=b;\n\t\t\t}\n\t\t\tret=min(ret,tmp);\n\t\t}\n\t\tlong long ad=0;\n\t\tfor(int j=0;j<5100;j++)bit[j]=0;\n\t\tint C=0;\n\t\tint D=0;\n\t\tfor(int j=i;j<a;j++){\n\t\t\tif(i==0||p[i-1]<p[j]){\n\t\t\t\tint T=sum(0,p[j]);\n\t\t\t\tlong long ad=(long long)C*c+(long long)T*min(b,c)+(long long)(D-T)*b;\n\t\t\t\tdp[j+1]=min(dp[j+1],dp[i]+ad);\n\t\t\t}\n\t\t\tif(i&&p[i-1]>p[j])C++;\n\t\t\telse{\n\t\t\t\tD++;\n\t\t\t\tadd(p[j],1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  long long N, A, B;\n  cin >> N >> A >> B;\n\n  vector<int> p(N + 1);\n  vector<int> index(N + 1);\n  for (int i = 1; i <= N; i++) {\n    cin >> p[i];\n    index[p[i]] = i;\n  }\n\n  vector<vector <long long> > cost(N + 2, vector<long long>(N + 2, -1));\n  cost[0][N + 1] = 0;\n\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= i; j++) {\n      int left = j - 1;\n      int right = N - i + j + 1;\n      int nextLeft = left + 1;\n      int nextRight = right;\n      long long base = cost[left][right];\n      for (int k = 1; k < index[nextLeft]; k++) {\n        if (p[k] > nextLeft && p[k] < nextRight) {\n          base += B;\n          break;\n        }\n      }\n      if (cost[nextLeft][nextRight] == -1 || cost[nextLeft][nextRight] > base) {\n        cost[nextLeft][nextRight] = base;\n      }\n\n      nextLeft = left;\n      nextRight = right - 1;\n      base = cost[left][right];\n      for (int k = index[nextRight] + 1; k <= N; k++) {\n        if (p[k] > nextLeft && p[k] < nextRight) {\n          base += A;\n          break;\n        }\n      }\n      if (cost[nextLeft][nextRight] == -1 || cost[nextLeft][nextRight] > base) {\n        cost[nextLeft][nextRight] = base;\n      }\n    }\n  }\n\n  long long int ans = -1;\n  for (int i = 0; i <= N; i++) {\n    if (ans == -1 || ans > cost[i][i + 1]) {\n      ans = cost[i][i + 1];\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, A, B;\nint p[5005];\nint rev[5005];\nlong long memo[5005][5005];\n\nbool skipLeft[5005][5005];\nbool skipRight[5005][5005];\n\nlong long dp(int i, int j){\n    if(i > j){\n        return 0;\n    }else if(memo[i][j] != -1){\n        return memo[i][j];\n    }else{\n        /*vector<int> p2;\n        for(int k = 1; k <= N; k ++){\n            if(p[k] >= i && p[k] <= j){\n                p2.push_back(p[k]);\n            }\n        }*/\n\n        /*if(p2[0] == i){\n            return dp(i+1, j);\n        }else if(p2[j-i] == j){\n            return dp(i, j-1);\n        }*/\n\n        if(skipLeft[i][j]){\n            return dp(i+1, j);\n        }else if(skipRight[i][j]){\n            return dp(i, j-1);\n        }\n\n        return memo[i][j] = min(B + dp(i+1, j), A + dp(i, j-1));\n    }\n}\n\nint main(){\n    scanf(\"%d%d%d\", &N, &A, &B);\n\n    for(int i = 1; i <= N; i ++){\n        scanf(\"%d\", &p[i]);\n        rev[p[i]] = i;\n    }\n\n    for(int i = 1; i <= N; i ++){\n        skipLeft[i][i] = true;\n        for(int j = i+1; j <= N; j ++){\n            if(rev[j] < rev[i]){\n                // if j comes before i, then everything is false\n                skipLeft[i][j] = false;\n            }else{\n                skipLeft[i][j] = skipLeft[i][j-1];\n            }\n        }\n    }\n\n    for(int i = 1; i <= N; i ++){\n        skipRight[i][i] = true;\n        for(int j = i; j >= 1; j --){\n            if(rev[j] > rev[i]){\n                // if j comes before i, then everything is false\n                skipRight[i][j] = false;\n            }else{\n                skipRight[i][j] = skipRight[i][j+1];\n            }\n        }\n    }\n\n    memset(memo, -1, sizeof(memo));\n    printf(\"%lld\", dp(1, N));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N, A, B, INF = 10000000000000;\n\tvector<long long> P, DP;\n\tcin >> N >> A >> B;\n\tP.resize(N);\n\tDP.assign(N + 1, INF);\n\tDP[0] = 0;\n\tfor (int i = 0; i < N; i++) cin >> P[i], P[i]--;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long MIN = INF;\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (j == 0) {\n\t\t\t\tMIN = min(MIN, DP[j]);\n\t\t\t\tDP[j] += min(A, B);\n\t\t\t}\n\t\t\tif (0 < j && j < P[i]) {\n\t\t\t\tMIN = min(MIN, DP[j]);\n\t\t\t\tDP[j] += A;\n\t\t\t}\n\t\t\tif (j == P[i]) {\n\t\t\t\tDP[j] = MIN;\n\t\t\t}\n\t\t\tif (j > P[i]) {\n\t\t\t\tDP[j] += B;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = INF;\n\tfor (int i = 0; i <= N; i++) {\n\t\tANS = min(ANS, DP[i]);\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=5e3+10;\nll dp[N][N];\nint P[N],D[N];\nconst ll INF=1e18;\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"/home/zz7/CFInput\",\"r\",stdin);\n#endif\n\tint n,A,B;scanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&D[i]);\n\tint tar=0;\n\tfor(int i=0;i<n;i++){\n\t\ttar++;int cnt=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(D[j]==tar){\n\t\t\t\tP[tar]=n-tar-cnt;\n\t\t\t\tbreak;\n\t\t\t}else if(D[j]>tar)cnt++;\n\t\t}\n\t}fill(&dp[0][0],&dp[N-1][N],INF);\n\tfor(int i=0;i<=n;i++)dp[0][i]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tll M=INF;\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tM=min(M,dp[i-1][j]);\n\t\t\t//n-j,P[i]\n\t\t\tif(P[i]+1==n-j)dp[i][j+1]=min(dp[i][j+1],M);\n\t\t\telse if(P[i]+1<n-j)dp[i][j+1]=min(dp[i][j+1],M+B);\n\t\t\telse dp[i][j]=min(dp[i][j],M+A);\n\t\t}\n\t}cout<<dp[n][n]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fast        ios_base::sync_with_stdio(false); cin.tie(0);cout.tie(0);\n#define filein      freopen(\"input.txt\",\"r\",stdin)\n#define fileout     freopen(\"output.txt\",\"w\",stdout)\n#define ll          long long\n#define pii         pair<int,int>\nusing namespace std;\n\nll dp[5007][5007];\nll a,b,n;\nll arr[5007],pos[5007];\n\nll DP(int ind,int cur){\n    if(dp[ind][cur]!=-1) return dp[ind][cur];\n\n    if(ind==0) return dp[ind][cur]=0;\n\n    if(pos[ind]>cur) {\n        return dp[ind][cur] = DP(ind-1,cur)+b;\n    }\n\n    dp[ind][cur] = min(DP(ind-1,pos[ind]),DP(ind-1,cur)+a);\n    return dp[ind][cur];\n}\n\nint main(){\n    fast;\n    memset(dp,-1,sizeof dp);\n\n    cin>>n>>a>>b;\n\n    for(int i=1;i<=n;i++) {\n        cin>>arr[i];\n        pos[arr[i]] = i;\n    }\n\n    cout<<DP(n,n)<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2e3 + 10;\n\nint n, A, B, p[N];\nll dp[N];\n\nint main() {\n  scanf(\"%d %d %d\", &n, &A, &B);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &p[i]);\n  }\n  p[++n] = n;\n  for (int i = 1; i <= n; i++) {\n    dp[i] = (ll) 1e18;\n    ll tmp = 0;\n    for (int j = i - 1; j >= 0; j--) {\n      if (p[j] < p[i]) {\n        dp[i] = min(dp[i], dp[j] + tmp);\n        tmp += B;\n      } else {\n        tmp += A;\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nRathin Bhargava\nIIIT Bangalore\n\n*/\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\n#define mt make_tuple\n#define mp make_pair\n#define pu push_back\n#define INF 1e18\n#define MOD 1000000007\n#define EPS 1e-6\n#define ll long long int\n#define ld long double\n#define fi first\n#define se second\n#define all(v) v.begin(),v.end()\n#define pr(v) { for(int i=0;i<v.size();i++) { v[i]==INF? cout<<\"INF \" : cout<<v[i]<<\" \"; } cout<<endl;}\n#define t1(x)                cerr<<#x<<\" : \"<<x<<endl\n#define t2(x, y)             cerr<<#x<<\" : \"<<x<<\" \"<<#y<<\" : \"<<y<<endl\n#define t3(x, y, z)          cerr<<#x<<\" : \" <<x<<\" \"<<#y<<\" : \"<<y<<\" \"<<#z<<\" : \"<<z<<endl\n#define t4(a,b,c,d)          cerr<<#a<<\" : \"<<a<<\" \"<<#b<<\" : \"<<b<<\" \"<<#c<<\" : \"<<c<<\" \"<<#d<<\" : \"<<d<<endl\n#define t5(a,b,c,d,e)          cerr<<#a<<\" : \"<<a<<\" \"<<#b<<\" : \"<<b<<\" \"<<#c<<\" : \"<<c<<\" \"<<#d<<\" : \"<<d<<\" \"<<#e<<\" : \"<<e<<endl\n#define t6(a,b,c,d,e,f)          cerr<<#a<<\" : \"<<a<<\" \"<<#b<<\" : \"<<b<<\" \"<<#c<<\" : \"<<c<<\" \"<<#d<<\" : \"<<d<<\" \"<<#e<<\" : \"<<e<<\" \"<<#f<<\" : \"<<f<<endl\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define t(...) GET_MACRO(__VA_ARGS__,t6,t5, t4, t3, t2, t1)(__VA_ARGS__)\n#define _ cerr<<\"here\"<<endl;\n#define __ {ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);}\n\nusing namespace std;\ntemplate<class A, class B> ostream& operator<<(ostream& out, const pair<A, B> &a){ return out<<\"(\"<<a.first<<\", \"<<a.second<<\")\";}\ntemplate <int> ostream& operator<<(ostream& os, const vector<int>& v) { os << \"[\"; for (int i = 0; i < v.size(); ++i) { if(v[i]!=INF) os << v[i]; else os << \"INF\";if (i != v.size() - 1) os << \", \"; } os << \"]\\n\"; return os; } \ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) { os << \"[\"; for (int i = 0; i < v.size(); ++i) { os << v[i]; ;if (i != v.size() - 1) os << \", \"; } os << \"]\\n\"; return os; } \n\nll max(ll x, ll y)\n{\n  if(x>y) return x;\n  return y;\n}\n\nll min(ll x, ll y)\n{\n  if(x<y) return x;\n  return y;\n}\n\nint main()\n{\n  __;\n  int n;\n  cin >> n;\n  ll a,b;\n  cin >> a >> b;\n\n  vector<int> v(n+1);\n  map<int,int> d;\n  vector<vector<ll> > dp(n+2,vector<ll>(n+2));\n  vector<int> left(n+1),right(n+1);\n\n  for(int i=1;i<=n;i++) \n  {\n    cin >> v[i];\n    d[v[i]] = i;\n  }\n\n  set<int> s;\n  set<int,greater<int> > t; // Upper bound gives you a smaller element\n\n  s.insert(+1e9);\n  t.insert(-1e9);\n\n  for(int i=1;i<=n;i++)\n  {\n    left[i] = *s.upper_bound(v[i]);\n    s.insert(v[i]);\n  }\n\n  for(int i=n;i>0;i--)\n  {\n    right[i] = *t.upper_bound(v[i]);\n    t.insert(v[i]);\n  }\n\n  // t(left,right);\n  dp[0][n+1] = 0;\n  for(int sz=n+1;sz>=2;sz--)\n  {\n    for(int i=0;i<=n+2-sz;i++)\n    {\n      int j = sz+i-1;\n      dp[i][j] = INF;\n      if(i>0) \n      {\n        // Right rotate to sort the ith guy and send him to the left\n        // Right rotation is not necessary when\n        int idx = d[i];\n        if(left[idx]>=j)\n        {\n          dp[i][j] = min(dp[i][j],dp[i-1][j]);\n        }\n        else\n        {\n          dp[i][j] = min(dp[i][j],dp[i-1][j]+b);\n        }\n      }\n      // t(i,j,dp[i][j]);\n      if(j<=n) \n      {\n        // Left rotate to sort the ith guy and send him to the right\n        int idx = d[j];\n        if(right[idx]<=i)\n        {\n          dp[i][j] = min(dp[i][j],dp[i][j+1]);\n        }\n        else dp[i][j] = min(dp[i][j],dp[i][j+1]+a);\n      }\n      // t(i,j,dp[i][j]);\n\n    }\n  }\n\n  ll ans = INF;\n  for(int i=0;i<=n;i++) ans = min(ans,dp[i][i+1]);\n\n  cout << ans << endl;\n\n  // for(int i=0;i<=n+1;i++)\n  // {\n  //   for(int j=i;j<=n+1;j++)\n  //   {\n  //     t(i,j,dp[i][j]);\n  //   }\n  // }\n  // t(dp.size());\n  return 0; \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst int sz = 5005;\nll dp[sz][sz];\nbool used[5555];\n\nint main(){\n\n\tll n, a, b;cin >> n >> a >> b;\n\tvector<ll> v(n);\n\tREP(i, n)cin >> v[i],v[i]--;\n\n\tREP(i, sz)REP(j, sz)dp[i][j] = LLINF;\n\tdp[0][0] = 0;\n\n\tREP(i, n+1){\n\t\tif(i > 0)used[v[i-1]] = true;\n\t\tREP(j, n+1){\n\t\t\tif(used[j])dp[i][j+1] = min(dp[i][j+1], dp[i][j]);\n\t\t\telse dp[i][j+1] = min(dp[i][j+1], dp[i][j] + b);\n\t\t\tif(v[i] == j)dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j]);\n\t\t\tif(v[i] < j)dp[i+1][j] = min(dp[i+1][j], dp[i][j]);\n\t\t\telse dp[i+1][j] = min(dp[i+1][j], dp[i][j] + a);\n\t\t}\n\t}\n\n\tcout << dp[n][n] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pa pair<int,int>\nusing namespace std;\nconst int N = 5001;\nconst int inf = 2147483647;\n\nint _max(int x, int y) {return x > y ? x : y;}\nLL _min(LL x, LL y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint a[N]; LL f[N][N];\n\nint main() {\n\tint n = read(), A = read(), B = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tmemset(f, 63, sizeof(f)); f[0][0] = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tif(a[i] > j) {\n\t\t\t\tf[i][j] = _min(f[i][j], f[i - 1][j] + A);\n\t\t\t\tf[i][a[i]] = _min(f[i][a[i]], f[i - 1][j]);\n\t\t\t} else f[i][j] = _min(f[i][j], f[i - 1][j] + B);\n\t\t}\n\t} LL ans = f[0][1];\n\tfor(int i = 0; i <= n; i++) ans = _min(ans, f[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define LL long long\nusing namespace std;\nconst int maxn = 5e3 + 5;\nLL f[maxn][maxn];\nint trs[maxn][maxn][2], a[maxn], n, A, B;\nint vis[maxn], pos[maxn], pt;\nint main() {\n\tscanf(\"%d%d%d\", &n, &A, &B);\n\tfor(register int i = 1; i <= n; ++i) \n\t\tscanf(\"%d\", &a[i]), pos[a[i]] = i;\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0][n + 1] = 0, pt = 0, pos[n + 1] = n + 1;\n\tfor(register int l = 0; l <= n + 1; ++l) {\n\t\tvis[pos[l]] = 1;\n\t\twhile(vis[pt]) ++pt;\n\t\tint pl = pt, pr = n + 1;\n\t\tfor(register int r = n + 1; r > l; --r) {\n\t\t\tvis[pos[r]] = 1;\n\t\t\twhile(vis[pl]) ++pl;\n\t\t\twhile(vis[pr]) --pr;\n\t\t\tif(a[pl] == l + 1) trs[l][r][0] = 1;\n\t\t\tif(a[pr] == r - 1) trs[l][r][1] = 1;\n\t\t}\n\t\tfor(register int r = n; r > l; --r)\n\t\t\tvis[pos[r]] = 0;\n\t}\n\tfor(register int i = n + 2; i >= 3; --i) {\n\t\tfor(register int l = 0; l <= n + 2 - i; ++l) {\n\t\t\tint r = l + i - 1;\n\t\t\tif(trs[l][r][1]) f[l][r - 1] = min(f[l][r - 1], f[l][r]);\n\t\t\telse f[l][r - 1] = min(f[l][r - 1], f[l][r] + min((LL)A, 1ll * B * (r - l)));\n\t\t\tif(trs[l][r][0]) f[l + 1][r] = min(f[l + 1][r], f[l][r]);\n\t\t\telse f[l + 1][r] = min(f[l + 1][r], f[l][r] + min((LL)B, 1ll * A * (r - l)));\n\t\t}\n\t}\n\tLL ans = 0x3f3f3f3f3f3f3f3f;\n\tfor(register int i = 0; i <= n; ++i) {\n\t\tans = min(ans, f[i][i + 1]);\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1LL<<60\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll a,b;\nint p[5005];\nll dp[5005][5005];\nbool chl[5005][5005];\nbool chr[5005][5005];\nint cntr[5005];\nint cntl[5005];\nbool used[5005];\n\nint main(void){\n    scanf(\"%d%lld%lld\",&n,&a,&b);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&p[i]);\n        p[i]--;\n    }\n    memset(used,false,sizeof(used));\n    for(int i=0;i<n;i++){\n        used[p[i]]=true;\n        for(int j=0;j<p[i];j++){\n            if(!used[j]){\n                cntl[j]++;\n                chl[j][p[i]]=true;\n            }\n        }\n    }\n    memset(used,false,sizeof(used));\n    for(int i=n-1;i>=0;i--){\n        used[p[i]]=true;\n        for(int j=p[i];j<n;j++){\n            if(!used[j]){\n                cntr[j]++;\n                chr[j][p[i]]=true;\n            }\n        }\n    }\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            dp[i][j]=INF;\n        }\n    }\n    dp[0][n]=0;\n    for(int i=0;i<n;i++){\n        for(int j=n;j>i;j--){\n            int lv=i;\n            if(cntl[lv]==0){\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]);\n            }else{\n                dp[i+1][j]=min(dp[i+1][j],dp[i][j]+min(b,(ll)a*cntl[lv]));\n            }\n            if(chl[lv][j-1]){\n                cntl[lv]--;\n            }\n            int rv=j-1;\n            if(cntr[rv]==0){\n                dp[i][j-1]=min(dp[i][j-1],dp[i][j]);\n            }else{\n                dp[i][j-1]=min(dp[i][j-1],dp[i][j]+min(a,(ll)b*cntr[rv]));\n            }\n            //printf(\"%d %d %d %d %lld\\n\",i,j,cntl[lv],cntr[rv],dp[i][j]);\n\n        }\n        for(int j=0;j<n;j++){\n            if(chr[j][i]){\n                cntr[j]--;\n            }\n        }\n    }\n    ll ans=INF;\n    for(int i=0;i<n;i++){\n        ans=min(ans,dp[i][i]);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 5005;\nconst ll Inf = 4000000000000000000ll;\n\nint n, a, b;\nll dp[Maxn][Maxn];\n\nint main()\n{\n    fill((ll*)dp, (ll*)dp + Maxn * Maxn, Inf);\n    scanf(\"%d %d %d\", &n, &a, &b);\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++) {\n        int num; scanf(\"%d\", &num);\n        for (int j = 0; j <= n; j++) if (dp[i][j] < Inf)\n            if (j > num) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + ll(b));\n            else {\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + ll(a));\n                dp[i + 1][num] = min(dp[i + 1][num], dp[i][j]);\n            }\n    }\n    ll res = Inf;\n    for (int i = 0; i <= n; i++)\n        res = min(res, dp[n][i]);\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//!link: m,stdc++\n//!flag: -g,-DWAAUTOMATON\n// failed\n/*+lmake\n * DEFINE += WAAUTOMATON\n */\n#include <bits/stdc++.h>\n#ifdef WAAUTOMATON\n#define debug(args...)                                                                             \\\n    {                                                                                              \\\n        dbg, args;                                                                                 \\\n        cerr << endl;                                                                              \\\n    }\n#define massert(x) assert(x)\n#else\n#define debug(args...) // Just strip off all debug tokens\n#define massert(x)\n#endif\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef std::pair<int, int> pii;\ntypedef std::pair<LL, LL> pll;\nstruct debugger\n{\n    template <typename T>\n    debugger &operator,(const T &v)\n    {\n        std::cerr << v << \" \";\n        return *this;\n    }\n} dbg;\n\ntemplate <typename T>\ninline void chmax(T &a, T b)\n{\n    a = std::max(a, b);\n}\n\ntemplate <typename T>\ninline void chmin(T &a, T b)\n{\n    a = std::min(a, b);\n}\n\ntemplate <typename T>\ninline T sqr(const T& x)\n{\n\treturn x*x;\n}\n\ntemplate <size_t _I_Buffer_Size = 1 << 23, size_t _O_Buffer_Size = 1 << 23>\nstruct IO_Tp\n{\n    char _I_Buffer[_I_Buffer_Size];\n    char *_I_pos;\n    const char *_I_end;\n\n    char _O_Buffer[_O_Buffer_Size];\n    char *_O_pos;\n    const char *_O_end;\n\n    IO_Tp()\n        : _I_pos(_I_Buffer)\n        , _O_pos(_O_Buffer)\n        , _I_end(_I_Buffer + _I_Buffer_Size)\n        , _O_end(_O_Buffer + _O_Buffer_Size)\n    {\n    }\n\n    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }\n\n    inline char getchar()\n    {\n        char res = *_I_pos;\n        nextchar();\n        return res;\n    }\n\n    inline bool is_digit(const char ch) { return '0' <= ch && ch <= '9'; }\n\n    inline void nextchar()\n    {\n        ++_I_pos;\n        if (_I_pos == _I_end) {\n            fread(_I_Buffer, 1, _I_Buffer_Size, stdin);\n            _I_pos = _I_Buffer;\n        }\n    }\n\n    template <typename Int>\n    inline IO_Tp &operator>>(Int &res)\n    {\n        res = 0;\n        int k = 1;\n        while (!is_digit(*_I_pos)) {\n            if (*_I_pos == '-')\n                k = -1;\n            nextchar();\n        }\n        do {\n            (res *= 10) += (*_I_pos) - '0';\n            nextchar();\n        } while (is_digit(*_I_pos));\n        res *= k;\n        return *this;\n    }\n\n    inline IO_Tp &operator>>(char &res)\n    {\n        do {\n            res = *_I_pos;\n            nextchar();\n        } while (res == ' ' || res == '\\0' || res == '\\t' || res == '\\n' || res == '\\r');\n        return *this;\n    }\n\n    inline void putchar(char x)\n    {\n        if (_O_pos == _O_end) {\n            fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout);\n            _O_pos = _O_Buffer;\n        }\n        *_O_pos++ = x;\n    }\n    template <typename Int>\n    inline IO_Tp &operator<<(Int n)\n    {\n        if (n < 0) {\n            putchar('-');\n            n = -n;\n        }\n        static char _buf[20];\n        char *_pos(_buf);\n        do\n            *_pos++ = '0' + n % 10;\n        while (n /= 10);\n        while (_pos != _buf)\n            putchar(*--_pos);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(char ch)\n    {\n        putchar(ch);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(const char *s)\n    {\n        while (*s != 0) {\n            putchar(*s);\n            ++s;\n        }\n        return *this;\n    }\n};\nIO_Tp<> IO;\n\nconst int MAXN=5000;\nint a[MAXN+10];\nLL A,B;\nvector<int> in[MAXN+10],out[MAXN+10];\nint icnt[MAXN+10],ocnt[MAXN+10];\nvoid add(int x)\n{\n\tfor(auto v:out[x]) {\n\t\ticnt[v]++;\n\t}\n}\nbool b[MAXN+10];\nint main()\n{\n#ifdef WAAUTOMATON\n    freopen(\"./in_D_5.txt\", \"r\", stdin);\n#endif\n\tLL ans=LLONG_MAX/3;\n\tint n;\n\tIO>>n>>A>>B;\n\tfor(int i=1; i<=n; ++i) {\n\t\tIO>>a[i];\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=i+1; j<=n; ++j) {\n\t\t\tif (a[i]>a[j]) {\n\t\t\t\tin[a[i]].push_back(a[j]);\n\t\t\t\tout[a[j]].push_back(a[i]);\n\t\t\t\tocnt[a[j]]++;\n\t\t\t}\n\t\t}\n\t}\t\n\tLL cntb=n;\n\tfor(int i=1; i<=n; ++i) {\n\t\tif (ocnt[i]==0) --cntb;\n\t\telse if (ocnt[i]==1) {\n\t\t\tadd(i);\n\t\t}\n\t}\n\tchmin(ans,cntb*B);\n\tfor(LL cnta=1; cnta<=n; ++cnta) {\n\t\tint p=0;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tif (!b[i] && icnt[i]>=icnt[p]) {\n\t\t\t\tp=i;\n\t\t\t}\n\t\t}\n\t\tif (p==0) break;\n\t\tcntb-=icnt[p];\n\t\tb[p]=true;\n\t\tfor(auto v:in[p]) {\n\t\t\tocnt[v]--;\n\t\t\tif (ocnt[v]==1) {\n\t\t\t\tadd(v);\n\t\t\t}\n\t\t}\n\t\tchmin(ans,cnta*A+cntb*B);\n\t}\n\tIO<<ans<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 5000;\nconst ll INF = (1LL << 60);\n\nll dp[MAXN + 5];\n\nint p[MAXN + 5], N, A, B;\nint main() {\n\tscanf(\"%d%d%d\", &N, &A, &B);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\", &p[i]);\n\tp[N + 1] = N + 1;\n\t\n\tfor(int i=1;i<=N+1;i++) {\n\t\tdp[i] = INF; int nw = 0; ll del = 0;\n\t\tfor(int j=i-1;j>=1;j--) {\n\t\t\tif( p[j] < p[i] ) {\n\t\t\t\tif( nw < p[j] )\n\t\t\t\t\tdp[i] = min(dp[i], dp[j] + del), nw = p[j];\n\t\t\t\tdel += B;\n\t\t\t}\n\t\t\telse del += A;\n\t\t}\n\t\tif( !nw ) dp[i] = del;\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[N + 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, A, B, p[5009];\nlong long dp[5009][5009];\nconst long long INF = 1LL << 60;\n\nvoid u (long long &x, long long y)\n{\n    if (y < x)\n        x = y;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\", &N, &A, &B);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &p[i]);\nfor (int i=1; i<=N; i++)\n    for (int j=1; j<=N; j++)\n        dp[i][j] = INF;\nfor (int i=N + 1; i>1; i--)\n    for (int j=1; j<=N; j++)\n    {\n        if (p[i - 1] <= j)\n            u (dp[i - 1][p[i - 1]], dp[i][j]),\n            u (dp[i - 1][j], dp[i][j] + B);\n        u (dp[i - 1][min (j, p[i - 1])], dp[i][j] + A);\n    }\nlong long ans = INF;\nfor (int i=1; i<=N; i++)\n    ans = min (ans, dp[1][i]);\nprintf (\"%lld\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modInt {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n\n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modInt(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modInt(T v = 0, T m = 0) : val(v) { normalize(); }\n\n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modInt& a) { return os << a.val; }\n    friend bool operator==(const modInt& a, const modInt& b) { return a.val == b.val; }\n    friend bool operator!=(const modInt& a, const modInt& b) { return !(a == b); }\n\n    friend void check(modInt& a, modInt& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modInt operator+(modInt a, modInt b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modInt operator-(modInt a, modInt b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modInt operator-(const modInt& a) { return modInt(0)-a; }\n\n    friend modInt operator*(modInt a, modInt b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modInt exp(modInt a, ll p) {\n        modInt ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modInt inv(const modInt& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modInt operator/(modInt a, modInt b) { \n        check(a,b); return a*inv(b); \n    }\n};\n\ntypedef modInt<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,A,B, pos[5005];\nll dp[5005];\nvi P;\n\nint main() {\n    setIO(); re(N,A,B);\n    P.resz(N+2); FOR(i,1,N+1) re(P[i]);\n    P[N+1] = N+1;\n    F0R(i,N+2) pos[P[i]] = i;\n    FOR(i,1,N+2) dp[i] = INF;\n    F0R(i,N+1) {\n        int mn = MOD;\n        ll le = 0, ge = 0;\n        for (int j = pos[i]+1; j <= N+1; ++j) {\n            if (P[j] > i) {\n                ge ++;\n                ckmin(mn,P[j]);\n            } else le ++;\n            if (mn == P[j]) ckmin(dp[mn],dp[i]+le*B+(ge-1)*A);\n            // how \n        }\n    }\n    ps(dp[N+1]);\n    // dp[0] to dp[N+1]\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll A,B;\nint pos[5050];\n\nll from[10101];\nll to[10101];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A>>B;\n\tFOR(i,N) {\n\t\tcin>>x;\n\t\tpos[x]=i*2+1;\n\t}\n\t\n\tfor(i=1;i<=N;i++) {\n\t\tll mi=1LL<<60;\n\t\tFOR(j,2*N+1) {\n\t\t\tmi=min(mi,from[j]);\n\t\t\tif(j%2==0) {\n\t\t\t\tif(j<pos[i]) to[j]=mi+B;\n\t\t\t\tif(j>pos[i]) to[j]=mi+A;\n\t\t\t}\n\t\t\telse if(j==pos[i]) to[j]=mi;\n\t\t\telse to[j]=1LL<<60;\n\t\t}\n\t\t\n\t\tswap(to,from);\n\t}\n\t\n\t\n\tcout<<*min_element(from,from+2*N+1)<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define pa pair<int,int>\nusing namespace std;\nconst int N = 5001;\nconst int inf = 2147483647;\n\nint _max(int x, int y) {return x > y ? x : y;}\nLL _min(LL x, LL y) {return x < y ? x : y;}\ninline int read() {\n    int x = 0, f = 1; char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint a[N]; LL f[N][N];\n\nint main() {\n\tint n = read(), A = read(), B = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tmemset(f, 63, sizeof(f)); f[0][0] = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tif(a[i] > j) {\n\t\t\t\tf[i][j] = _min(f[i][j], f[i - 1][j] + A);\n\t\t\t\tf[i][a[i]] = _min(f[i][a[i]], f[i - 1][j]);\n\t\t\t} else f[i][j] = _min(f[i][a[i]], f[i - 1][j] + B);\n\t\t}\n\t} LL ans = f[0][1];\n\tfor(int i = 0; i <= n; i++) ans = _min(ans, f[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns #-}\n\n\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport System.IO\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Control.Monad.ST.Lazy (strictToLazyST, lazyToStrictST)\nimport qualified Control.Monad.ST.Lazy as STL\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\n\nmain :: IO ()\nmain = do\n  [n,a,b] <- map read . words <$> getLine\n  ps <- VU.unfoldrN n (runStateT rIntS) <$> BS.getLine\n  print $ query n a b ps\n\nquery :: Int -> Int -> Int -> VU.Vector Int -> Int\nquery n a b ps\n  = VU.last $ VU.foldl' join (VU.replicate n 0) (VU.generate n (+1))\n  where\n    costs !k\n      = VU.map (\\case 0 -> b; 1 -> 0; 2 -> a)\n        $ VU.postscanl' (\\ !c !l -> if | c /= 0    -> 2\n                                       | l /= k    -> 0\n                                       | otherwise -> 1) (0::Int) ps\n    join !vs !k\n      = VU.postscanl' min maxBound $ VU.zipWith (+) vs (costs k)\n\n\nrInt :: StateT BSL.ByteString Maybe Int\nrInt = StateT $ BSL.readInt . BSL.dropWhile (<'!')\nrIntS :: StateT BS.ByteString Maybe Int\nrIntS = StateT $ BS.readInt . BS.dropWhile (<'!')\n\n#define D(f,r,d) f::Integral a=>a->d;f=fromIntegral;r::String->d;r=read\n#define C(f,r,g,h,d) D(f,r,d);g,h::RealFrac a=>a->d;g=floor;h=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n{-# INLINE wrA #-}\nwrA = A.writeArray\n{-# INLINE rdA #-}\nrdA = A.readArray\n{-# INLINE mdA #-}\nmdA arr f i = do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' arr f i = do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE swapA #-}\nswapA arr i j = do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define N(f,g,a,m)\\\n  f :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> e -> m (a i e); f=A.newArray;\\\n  g :: forall e i s. (C(a,m)A.Ix i) => (i,i) -> m (a i e); g=A.newArray_\n#define C(a,m)\nN(newIOA,newIOA_,IOArray,IO)\nN(newSTA,newSTA_,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,IOUArray,IO)\nN(newSTUA,newSTUA_,STUArray s,ST s)\n#undef C\n#undef N\n\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null dp[5019][5019];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i <= n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (!i) {\n\t\t\t\tdp[i][j] = VERYBIG;\n\t\t\t\tdp[i][0] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// move\n\t\t\tif (j <= a[i - 1]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + ua;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + ub;\n\t\t\t}\n\n\t\t\t// printf(\"%lld \", dp[i][j]);\n\t\t}\n\t\t// puts(\"\");\n\n\t\tif (i) {\n\t\t\tsll x = VERYBIG;\n\t\t\tfor (j = 0; j <= a[i - 1]; j++) {\n\t\t\t\tx = smin(x, dp[i - 1][j]);\n\t\t\t}\n\t\t\tdp[i][a[i - 1]] = x;\n\t\t\t// printf(\"%lld\\n\", x);\n\t\t}\n\t}\n\tresult = VERYBIG;\n\tfor (i = 0; i < n; i++) {\n\t\tresult = smin(result, dp[n][i]);\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\tputs(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\tputs(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\tscanf(\"%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < k; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &d[i]);\n\t// \td[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef i64 flow_type;\n\nconst flow_type flow_inf = (i64) 5000 * 1000000000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid clear_graph (graph * const g) {\n  g->pointer = 0;\n  memset (g->start, -1, sizeof (int32_t) * g->vertex_num);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nvoid add_edge_undirected (graph * const g, const int32_t u, const int32_t v, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {v, g->start[u], capa};\n  g->start[u] = p;\n  g->edge[p + 1] = (flow_edge) {u, g->start[v], capa};\n  g->start[v] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef struct edge {\n  i32 from, to;\n  i64 capa;\n} edge;\n\ntypedef struct edge_list {\n  edge e;\n  struct edge_list *next;\n} list;\n\nconst i32 dummy = -1;\nlist* add (list *lst, i32 from, i32 to, i64 capa) {\n  if (from == dummy || to == dummy) return lst;\n  list *l = (list *) calloc (1, sizeof (list));\n  l->e = (edge) {from, to, capa};\n  l->next = lst;\n  return l;\n}\n\ni32 new_node (void) {\n  static i32 val = 0;\n  return val++;\n}\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  list *e = NULL;\n  const i32 src = new_node();\n  const i32 dst = new_node();\n  i32 *va = (i32 *) calloc (n, sizeof (i32));\n  i32 *vb = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n    va[i] = new_node();\n    e = add (e, src, va[i], a);\n    vb[i] = new_node();\n    e = add (e, vb[i], dst, b);\n  }\n  i32 k = 1;\n  while (k < n) k *= 2;\n  i32 *s = (i32 *) calloc (2 * k, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    s[i + k] = vb[i];\n  }\n  for (i32 i = n; i < k; ++i) {\n    s[i + k] = dummy;\n  }\n  for (i32 i = k - 1; i > 0; --i) {\n    if (s[2 * i] == dummy || s[2 * i + 1] == dummy) {\n      s[i] = dummy;\n    } else {\n      s[i] = new_node();\n      e = add (e, s[i], s[2 * i], flow_inf);\n      e = add (e, s[i], s[2 * i + 1], flow_inf);\n    }\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 l = k, r = p[i] + k; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) e = add (e, va[i], s[l++], flow_inf);\n      if (r & 1) e = add (e, va[i], s[--r], flow_inf);\n    }\n    s[k + p[i]] = dummy;\n    for (i32 x = (k + p[i]) / 2; x > 0; x >>= 1) {\n      if (s[2 * i] == dummy || s[2 * i + 1] == dummy) {\n        s[i] = s[2 * i] + s[2 * i + 1] - dummy;\n      } else if (s[x] != dummy) {\n        s[x] = new_node();\n        e = add (e, s[x], s[2 * x], flow_inf);\n        e = add (e, s[x], s[2 * x + 1], flow_inf);\n      }\n    }\n  }\n  i32 size = new_node();\n  graph *g = new_graph (size);\n  while (e != NULL) {\n    add_edge (g, e->e.from, e->e.to, e->e.capa);\n    e = e->next;\n  }\n  i64 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nint main(void){\n    long long arr[5005],pod[5005];\n    long long dp[5005][5005];\n    long long i,j,n,m,k,a,b,c,h,w,r=llinf,l,t;\n    scanf(\"%lld%lld%lld\",&n,&a,&b);\n    for(i=0;i<5005;i++){\n        for(j=0;j<5005;j++){\n            dp[i][j]=llinf;\n        }\n    }\n    dp[0][0]=0;\n    for(i=1;i<=n;i++){\n        scanf(\"%lld\",&arr[i]);\n        pod[arr[i]]=i;\n    }\n    for(i=1;i<=n;i++){\n        w=llinf;\n        for(j=0;j<=n+1;j++){\n            if(j==0){\n                dp[i][j]=b*i;\n            }\n            else if(j<pod[i]){\n                dp[i][j]=w+b;\n            }\n            else if(j==pod[i]){\n                dp[i][j]=w;\n            }\n            else{\n                dp[i][j]=w+a;\n            }\n            w=llmin(dp[i-1][j],w);\n        }\n    }\n    for(i=0;i<=n+1;i++){\n        r=llmin(dp[n][i],r);\n    }\n    printf(\"%lld\\n\",r);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define min(p,q)((p)<(q)?(p):(q))\n\nll n,a,b;\nll p[5010];\nll ip[5010];//pの逆引き\nll memo[5010][5010];\nll f(int R,int K){\n\tif(R<=0||K<0)return 0;\n\tif(memo[R][K])return memo[R][K]-1;\n\tif(ip[K]>=R)return (memo[R][K]=f(R,K-1)+1)-1;\n\t\n\tll cnt=0;\n\trep(i,ip[K],R)if(p[i]<K)cnt++;\n\t\n\tll ans;\n\tif(cnt){\n\t\tll v1=f(ip[K],K-1)+cnt*b;\n\t\tll v2=f(    R,K-1)+a;\n\t\tans=min(v1,v2);\n\t}else{\n\t\tans=f(R,K-1);\n\t}\n\treturn (memo[R][K]=ans+1)-1;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\trep(i,0,n){\n\t\tll t;\n\t\tscanf(\"%lld\",&t);\n\t\tt--;\n\t\tp[i]=t;\n\t\tip[t]=i;\n\t}\n\tprintf(\"%lld\",f(n,n-1));\n}"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define size 5005\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nlong long bit[33400]={0},bsize=32768;\nlong long sum(long long i){\n    long long s=0;\n    while(i>0){\n        s+=bit[i];\n        i-=i&(-i);\n    }\n    return s;\n}\nvoid add(long long i,long long x){\n    while(i<=bsize){\n        bit[i]+=x;\n        i+=i&(-i);\n    }\n}\n\nlong long arr[size],n,a,b;\nlong long pod[size];\nlong long dp[size][size];\n\nlong long rep(long long st,long long fi){\n  long long w,r,t;\n  if(st==fi){return 0;}\n  if(dp[st][fi]!=-1){return dp[st][fi];}\n\n  add(pod[st],-1);\n  w=llmax(0,sum(pod[st]));\n  t=llmin(b,w*a);\n  r=rep(st+1,fi)+t;\n  add(pod[st],1);\n\n  add(pod[fi],-1);\n  w=llmax(0,(fi-st)-sum(pod[fi]));\n  t=llmin(a,w*b);\n  r=llmin(r,rep(st,fi-1)+t);\n  add(pod[fi],1);\n\n  dp[st][fi]=r;\n  return dp[st][fi];\n}\n\nint main(void){\n  long long i,j,m,k,c,h,w,r=0,l,t;\n  scanf(\"%lld%lld%lld\",&n,&a,&b);\n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      dp[i][j]=-1;\n    }\n  }\n  for(i=1;i<=n;i++){\n    add(i,1);\n    scanf(\"%lld\",&arr[i]);\n    pod[arr[i]]=i;\n  }\n  printf(\"%lld\\n\",rep(1,n));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef i64 flow_type;\n\nconst flow_type flow_inf = (i64) 5000 * 1000000000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid clear_graph (graph * const g) {\n  g->pointer = 0;\n  memset (g->start, -1, sizeof (int32_t) * g->vertex_num);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nvoid add_edge_undirected (graph * const g, const int32_t u, const int32_t v, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {v, g->start[u], capa};\n  g->start[u] = p;\n  g->edge[p + 1] = (flow_edge) {u, g->start[v], capa};\n  g->start[v] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef struct edge {\n  i32 from, to;\n  i64 capa;\n} edge;\n\ntypedef struct edge_list {\n  edge e;\n  struct edge_list *next;\n} list;\n\nconst i32 dummy = -1;\nlist* add (list *lst, i32 from, i32 to, i64 capa) {\n  if (from == dummy || to == dummy) return lst;\n  list *l = (list *) calloc (1, sizeof (list));\n  l->e = (edge) {from, to, capa};\n  l->next = lst;\n  return l;\n}\n\ni32 new_node (void) {\n  static i32 val = 0;\n  return val++;\n}\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  list *e = NULL;\n  const i32 src = new_node();\n  const i32 dst = new_node();\n  i32 *va = (i32 *) calloc (n, sizeof (i32));\n  i32 *vb = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n    va[i] = new_node();\n    e = add (e, src, va[i], a);\n    vb[i] = new_node();\n    e = add (e, vb[i], dst, b);\n  }\n  i32 k = 1;\n  while (k < n) k *= 2;\n  i32 *s = (i32 *) calloc (2 * k, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    s[i + k] = vb[i];\n  }\n  for (i32 i = n; i < k; ++i) {\n    s[i + k] = dummy;\n  }\n  for (i32 i = k - 1; i > 0; --i) {\n    if (s[2 * i] == dummy || s[2 * i + 1] == dummy) {\n      s[i] = dummy;\n    } else {\n      s[i] = new_node();\n      e = add (e, s[i], s[2 * i], flow_inf);\n      e = add (e, s[i], s[2 * i + 1], flow_inf);\n    }\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 l = k, r = p[i] + k; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) e = add (e, va[i], s[l++], flow_inf);\n      if (r & 1) e = add (e, va[i], s[--r], flow_inf);\n    }\n    s[k + p[i]] = dummy;\n    for (i32 x = (k + p[i]) / 2; x > 0; x >>= 1) {\n      if (s[x] == dummy) continue;\n      if (s[2 * i] == dummy || s[2 * i + 1] == dummy) {\n\ts[i] = s[2 * i] + s[2 * i + 1] - dummy;\n      } else {\n        s[x] = new_node();\n        e = add (e, s[x], s[2 * x], flow_inf);\n        e = add (e, s[x], s[2 * x + 1], flow_inf);\n      }\n    }\n  }\n  i32 size = new_node();\n  graph *g = new_graph (size);\n  while (e != NULL) {\n    add_edge (g, e->e.from, e->e.to, e->e.capa);\n    e = e->next;\n  }\n  i64 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef i64 flow_type;\n\nconst flow_type flow_inf = (i64) 5000 * 1000000000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid clear_graph (graph * const g) {\n  g->pointer = 0;\n  memset (g->start, -1, sizeof (int32_t) * g->vertex_num);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nvoid add_edge_undirected (graph * const g, const int32_t u, const int32_t v, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {v, g->start[u], capa};\n  g->start[u] = p;\n  g->edge[p + 1] = (flow_edge) {u, g->start[v], capa};\n  g->start[v] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef struct edge {\n  i32 from, to;\n  i64 capa;\n} edge;\n\ntypedef struct edge_list {\n  edge e;\n  struct edge_list *next;\n} list;\n\nlist* add (list *lst, i32 from, i32 to, i64 capa) {\n  list *l = (list *) calloc (1, sizeof (list));\n  l->e = (edge) {from, to, capa};\n  l->next = lst;\n  return l;\n}\n\ni32 new_node (void) {\n  static i32 val = 0;\n  return val++;\n}\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  list *e = NULL;\n  const i32 src = new_node();\n  const i32 dst = new_node();\n  i32 *va = (i32 *) calloc (n, sizeof (i32));\n  i32 *vb = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n    va[i] = new_node();\n    e = add (e, src, va[i], a);\n    vb[i] = new_node();\n    e = add (e, vb[i], dst, b);\n  }\n  const i32 dummy = new_node();\n  i32 k = 1;\n  while (k < n) k *= 2;\n  i32 *s = (i32 *) calloc (2 * k, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    s[i + k] = vb[i];\n  }\n  for (i32 i = n; i < k; ++i) {\n    s[i + k] = dummy;\n  }\n  for (i32 i = k - 1; i > 0; --i) {\n    s[i] = new_node();\n    e = add (e, s[i], s[2 * i], flow_inf);\n    e = add (e, s[i], s[2 * i + 1], flow_inf);\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 l = k, r = p[i] + k; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) e = add (e, va[i], s[l++], flow_inf);\n      if (r & 1) e = add (e, va[i], s[--r], flow_inf);\n    }\n    s[k + p[i]] = dummy;\n    for (i32 x = (k + p[i]) / 2; x > 0; x >>= 1) {\n      s[x] = new_node();\n      e = add (e, s[x], s[2 * x], flow_inf);\n      e = add (e, s[x], s[2 * x + 1], flow_inf);\n    }\n  }\n  i32 size = new_node();\n  graph *g = new_graph (size);\n  while (e != NULL) {\n    add_edge (g, e->e.from, e->e.to, e->e.capa);\n    e = e->next;\n  }\n  i64 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nint main(void){\n    long long arr[5005],pod[5005];\n    long long dp[5005][5005];\n    long long i,j,n,m,k,a,b,c,h,w,r=llinf,l,t;\n    scanf(\"%lld%lld%lld\",&n,&a,&b);\n    for(i=0;i<5005;i++){\n        for(j=0;j<5005;j++){\n            dp[i][j]=llinf;\n        }\n    }\n    dp[0][0]=0;\n    for(i=1;i<=n;i++){\n        scanf(\"%lld\",&arr[i]);\n        pod[arr[i]]=i;\n    }\n    for(i=1;i<=n;i++){\n        w=dp[i][0];\n        for(j=0;j<=n;j++){\n            if(j==0){\n                dp[i][j]=b*i;\n            }\n            else if(j==pod[i]){\n                dp[i][j]=w;\n            }\n            else if(j<pod[i]){\n                dp[i][j]=b+llmin(w,dp[i-1][j]);\n            }\n            else{\n                dp[i][j]=a+llmin(w,dp[i-1][j]);\n            }\n            w=llmin(dp[i-1][j],w);\n        }\n    }\n    for(i=0;i<=n;i++){\n        r=llmin(dp[n][i],r);\n    }\n    printf(\"%lld\\n\",r);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nhttps://atcoder.jp/contests/agc032/submissions/4672338 を参照しました\np[i]を右に挿入することを S -> i へコストAの辺を貼ることで表現\n同様に左に挿入することを i + N -> T へコストBの辺を貼ることで表現\ni < j で p[i] > p[j] なら iを右に動かすか、jを左に動かさなければならないのでi -> j + N へINFを貼る\nこのグラフのS-T の最小カットが求めたいものとなる(らしい)\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n#include<math.h>\n\ntypedef int64_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 1000000000 * 5000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (capa <= 0 || level[u] <= level[v]) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = 0; i < n; ++i) {\n    add_edge (g, src, i, a);\n    add_edge (g, i + n, dst, b);\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 j = i + 1; j < n; ++j) {\n      if (p[i] > p[j]) {\n        add_edge (g, i, j + n, flow_inf);\n      }\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int64_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 1000000000 * 5000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t rev_index;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct flow_edge_vector {\n  flow_edge *edge;\n  int32_t length;\n  int32_t max_length;\n} flow_edge_vector;\n\ntypedef struct maxFlowGraph {\n  flow_edge_vector *from;\n  int32_t vertex_num;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  g->from = (flow_edge_vector *) calloc (vertex_num, sizeof (flow_edge_vector)); \n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->from[i].edge = (flow_edge *) calloc (vertex_num / 2, sizeof (flow_edge));\n    g->from[i].length = 0;\n    g->from[i].max_length = vertex_num / 2;\n  }\n  return g;\n}\n\nvoid add_edge_sub (flow_edge_vector *v, int32_t vertex, int32_t rev_index, int64_t capa) {\n  if (v->length == v->max_length) {\n    v->max_length *= 2;\n    v->edge = (flow_edge *) realloc (v->edge, sizeof (flow_edge) * v->max_length);\n  }\n  v->edge[v->length++] = (flow_edge) {vertex, rev_index, capa};\n}\n\nvoid add_edge (graph * const g, const int32_t src, const int32_t dst, const flow_type capa) {\n  add_edge_sub (&g->from[src], dst, g->from[dst].length, capa);\n  add_edge_sub (&g->from[dst], src, g->from[src].length - 1, 0);\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t src, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == src) return e;\n  flow_type sum = 0;\n  flow_edge_vector * const vec = &g->from[v];\n  for (int32_t p = iter[v]; p < vec->length; ++p, iter[v] = p) {\n    const int32_t u = vec->edge[p].vertex;\n    const flow_type capa = g->from[u].edge[vec->edge[p].rev_index].capacity;\n    if (level[u] >= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, src, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      vec->edge[p].capacity += f;\n      g->from[u].edge[vec->edge[p].rev_index].capacity -= f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[src] = 1;\n    queue[last++] = src;\n    while (front < last && level[dst] == 0) {\n      const int32_t v = queue[front++];\n      const flow_edge_vector *vec = &g->from[v];\n      for (int32_t p = 0; p < vec->length; ++p) {\n        const int32_t u = vec->edge[p].vertex;\n        if (vec->edge[p].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] + 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[dst] == 0) break;\n    memset (iter, 0, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (dst, g, src, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = 0; i < n; ++i) {\n    add_edge (g, i + n, dst, b);\n    add_edge (g, src, i, a);\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 j = i + 1; j < n; ++j) {\n      if (p[i] > p[j]) {\n        add_edge (g, i, j + n, flow_inf);\n      }\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nhttps://atcoder.jp/contests/agc032/submissions/4672338 を参照しました\np[i]を右に挿入することを S -> i へコストAの辺を貼ることで表現\n同様に左に挿入することを i + N -> T へコストBの辺を貼ることで表現\ni < j で p[i] > p[j] なら iを右に動かすか、jを左に動かさなければならないのでi -> j + N へINFを貼る\nこのグラフのS-T の最小カットが求めたいものとなる\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 2000000001;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      return f;\n    }\n  }\n  return 0;\n}\n\nint64_t dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int64_t flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  uint8_t *l = (uint8_t *) calloc (n, sizeof (uint8_t));\n  uint8_t *r = (uint8_t *) calloc (n, sizeof (uint8_t));\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 j = i + 1; j < n; ++j) {\n      if (p[i] > p[j]) {\n        add_edge (g, i, j + n, flow_inf);\n        l[j] = r[i] = 1;\n      }\n    }\n  }\n  for (i32 i = 0; i < n; ++i) {\n    if (l[i]) {\n      add_edge (g, i + n, dst, b);\n    }\n    if (r[i]) {\n      add_edge (g, src, i, a);\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nhttps://atcoder.jp/contests/agc032/submissions/4672338 を参照しました\np[i]を右に挿入することを S -> i へコストAの辺を貼ることで表現\n同様に左に挿入することを i + N -> T へコストBの辺を貼ることで表現\ni < j で p[i] > p[j] なら p[i]を右に動かすか、p[j]を左に動かさなければならないのでi -> j + N へINFを貼る\nこのグラフのS-T の最小カットが求めたいものとなる\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int64_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 1000000000 * 5000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t rev_index;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct flow_edge_vector {\n  flow_edge *edge;\n  int32_t length;\n  int32_t max_length;\n} flow_edge_vector;\n\ntypedef struct maxFlowGraph {\n  flow_edge_vector *from;\n  int32_t vertex_num;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  g->from = (flow_edge_vector *) calloc (vertex_num, sizeof (flow_edge_vector)); \n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->from[i].edge = (flow_edge *) calloc (1, sizeof (flow_edge));\n    g->from[i].length = 0;\n    g->from[i].max_length = 1;\n  }\n  return g;\n}\n\nvoid add_edge_sub (flow_edge_vector *v, int32_t vertex, int32_t rev_index, int64_t capa) {\n  if (v->length == v->max_length) {\n    v->max_length *= 2;\n    v->edge = (flow_edge *) realloc (v->edge, sizeof (flow_edge) * v->max_length);\n  }\n  v->edge[v->length++] = (flow_edge) {vertex, rev_index, capa};\n}\n\nvoid add_edge (graph * const g, const int32_t src, const int32_t dst, const flow_type capa) {\n  add_edge_sub (&g->from[src], dst, g->from[dst].length, capa);\n  add_edge_sub (&g->from[dst], src, g->from[src].length - 1, 0);\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t src, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == src) return e;\n  flow_type sum = 0;\n  flow_edge_vector * const vec = &g->from[v];\n  for (int32_t p = iter[v]; p < vec->length; ++p, iter[v] = p) {\n    const int32_t u = vec->edge[p].vertex;\n    const flow_type capa = g->from[u].edge[vec->edge[p].rev_index].capacity;\n    if (level[u] >= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, src, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      vec->edge[p].capacity += f;\n      g->from[u].edge[vec->edge[p].rev_index].capacity -= f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[src] = 1;\n    queue[last++] = src;\n    while (front < last && level[dst] == 0) {\n      const int32_t v = queue[front++];\n      const flow_edge_vector *vec = &g->from[v];\n      for (int32_t p = 0; p < vec->length; ++p) {\n        const int32_t u = vec->edge[p].vertex;\n        if (vec->edge[p].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] + 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[dst] == 0) break;\n    memset (iter, 0, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (dst, g, src, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = 0; i < n; ++i) {\n    add_edge (g, i + n, dst, b);\n    add_edge (g, src, i, a);\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 j = i + 1; j < n; ++j) {\n      if (p[i] > p[j]) {\n        add_edge (g, p[i], p[j] + n, flow_inf);\n      }\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef i64 flow_type;\n\nconst flow_type flow_inf = (i64) 5000 * 1000000000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid clear_graph (graph * const g) {\n  g->pointer = 0;\n  memset (g->start, -1, sizeof (int32_t) * g->vertex_num);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nvoid add_edge_undirected (graph * const g, const int32_t u, const int32_t v, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {v, g->start[u], capa};\n  g->start[u] = p;\n  g->edge[p + 1] = (flow_edge) {u, g->start[v], capa};\n  g->start[v] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef struct edge {\n  i32 from, to;\n  i64 capa;\n} edge;\n\ntypedef struct edge_list {\n  edge e;\n  struct edge_list *next;\n} list;\n\nconst i32 dummy = -1;\nlist* add (list *lst, i32 from, i32 to, i64 capa) {\n  if (from == dummy || to == dummy) return lst;\n  list *l = (list *) calloc (1, sizeof (list));\n  l->e = (edge) {from, to, capa};\n  l->next = lst;\n  return l;\n}\n\ni32 new_node (void) {\n  static i32 val = 0;\n  return val++;\n}\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  list *e = NULL;\n  const i32 src = new_node();\n  const i32 dst = new_node();\n  i32 *va = (i32 *) calloc (n, sizeof (i32));\n  i32 *vb = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n    va[i] = new_node();\n    e = add (e, src, va[i], a);\n    vb[i] = new_node();\n    e = add (e, vb[i], dst, b);\n  }\n  i32 k = 1;\n  while (k < n) k *= 2;\n  i32 *s = (i32 *) calloc (2 * k, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    s[i + k] = vb[i];\n  }\n  for (i32 i = n; i < k; ++i) {\n    s[i + k] = dummy;\n  }\n  for (i32 i = k - 1; i > 0; --i) {\n    if (s[2 * i] == dummy) {\n      s[i] = dummy;\n    } else if (s[2 * i + 1] == dummy) {\n      s[i] = s[2 * i];\n      continue;\n    } else {\n      s[i] = new_node();\n      e = add (e, s[i], s[2 * i], flow_inf);\n      e = add (e, s[i], s[2 * i + 1], flow_inf);\n    }\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 l = k, r = p[i] + k; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) e = add (e, va[i], s[l++], flow_inf);\n      if (r & 1) e = add (e, va[i], s[--r], flow_inf);\n    }\n    s[k + p[i]] = dummy;\n    for (i32 x = (k + p[i]) / 2; x > 0; x >>= 1) {\n      if (s[2 * x] == dummy && s[2 * x + 1] == dummy) {\n        s[x] = dummy;\n      } else if (s[2 * x] == dummy || s[2 * x + 1] == dummy) {\n        s[x] = s[2 * x] + s[2 * x + 1] - dummy;\n      } else {\n        s[x] = new_node();\n        e = add (e, s[x], s[2 * x], flow_inf);\n        e = add (e, s[x], s[2 * x + 1], flow_inf);\n      }\n    }\n  }\n  i32 size = new_node();\n  graph *g = new_graph (size);\n  while (e != NULL) {\n    add_edge (g, e->e.from, e->e.to, e->e.capa);\n    e = e->next;\n  }\n  i64 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef i64 flow_type;\n\nconst flow_type flow_inf = (i64) 5000 * 1000000000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid clear_graph (graph * const g) {\n  g->pointer = 0;\n  memset (g->start, -1, sizeof (int32_t) * g->vertex_num);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nvoid add_edge_undirected (graph * const g, const int32_t u, const int32_t v, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {v, g->start[u], capa};\n  g->start[u] = p;\n  g->edge[p + 1] = (flow_edge) {u, g->start[v], capa};\n  g->start[v] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef struct edge {\n  i32 from, to;\n  i64 capa;\n} edge;\n\ntypedef struct edge_list {\n  edge e;\n  struct edge_list *next;\n} list;\n\nlist* add (list *lst, i32 from, i32 to, i64 capa) {\n  list *l = (list *) calloc (1, sizeof (list));\n  l->e = (edge) {from, to, capa};\n  l->next = lst;\n  return l;\n}\n\ni32 new_node (void) {\n  static i32 val = 0;\n  return val++;\n}\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  list *e = NULL;\n  const i32 src = new_node();\n  const i32 dst = new_node();\n  i32 *va = (i32 *) calloc (n, sizeof (i32));\n  i32 *vb = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n    va[i] = new_node();\n    e = add (e, src, va[i], a);\n    vb[i] = new_node();\n    e = add (e, vb[i], dst, b);\n  }\n  const i32 dummy = -1;\n  i32 k = 1;\n  while (k < n) k *= 2;\n  i32 *s = (i32 *) calloc (2 * k, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    s[i + k] = vb[i];\n  }\n  for (i32 i = n; i < k; ++i) {\n    s[i + k] = dummy;\n  }\n  for (i32 i = k - 1; i > 0; --i) {\n    if (s[2 * i] == dummy) {\n      s[i] = dummy;\n      continue;\n    }\n    s[i] = new_node();\n    e = add (e, s[i], s[2 * i], flow_inf);\n    if (s[2 * i + 1] != dummy) e = add (e, s[i], s[2 * i + 1], flow_inf);\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 l = k, r = p[i] + k; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) {\n\tif (s[l] != dummy) e = add (e, va[i], s[l], flow_inf);\n\tl++;\n      }\n      if (r & 1) {\n\t--r;\n\tif (s[r] != dummy) e= add (e, va[i], s[r], flow_inf);\n      }\n    }\n    s[k + p[i]] = dummy;\n    for (i32 x = (k + p[i]) / 2; x > 0; x >>= 1) {\n      if (s[2 * x] == dummy && s[2 * x + 1] == dummy) {\n\ts[x] = dummy;\n\tcontinue;\n      }\n      s[x] = new_node();\n      if (s[2 * x] != dummy) e = add (e, s[x], s[2 * x], flow_inf);\n      if (s[2 * x + 1] != dummy) e = add (e, s[x], s[2 * x + 1], flow_inf);\n    }\n  }\n  i32 size = new_node();\n  graph *g = new_graph (size);\n  while (e != NULL) {\n    add_edge (g, e->e.from, e->e.to, e->e.capa);\n    e = e->next;\n  }\n  i64 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nhttps://atcoder.jp/contests/agc032/submissions/4672338 を参照しました\np[i]を右に挿入することを S -> i へコストAの辺を貼ることで表現\n同様に左に挿入することを i + N -> T へコストBの辺を貼ることで表現\ni < j で p[i] > p[j] なら p[i]を右に動かすか、p[j]を左に動かさなければならないのでi -> j + N へINFを貼る\nこのグラフのS-T の最小カットが求めたいものとなる\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int64_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 1000000000 * 5000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t rev_index;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct flow_edge_vector {\n  flow_edge *edge;\n  int32_t length;\n  int32_t max_length;\n} flow_edge_vector;\n\ntypedef struct maxFlowGraph {\n  flow_edge_vector *from;\n  int32_t vertex_num;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  g->from = (flow_edge_vector *) calloc (vertex_num, sizeof (flow_edge_vector)); \n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->from[i].edge = (flow_edge *) calloc (1, sizeof (flow_edge));\n    g->from[i].length = 0;\n    g->from[i].max_length = 1;\n  }\n  return g;\n}\n\nvoid add_edge_sub (flow_edge_vector *v, int32_t vertex, int32_t rev_index, int64_t capa) {\n  if (v->length == v->max_length) {\n    v->max_length *= 2;\n    v->edge = (flow_edge *) realloc (v->edge, sizeof (flow_edge) * v->max_length);\n  }\n  v->edge[v->length++] = (flow_edge) {vertex, rev_index, capa};\n}\n\nvoid add_edge (graph * const g, const int32_t src, const int32_t dst, const flow_type capa) {\n  add_edge_sub (&g->from[src], dst, g->from[dst].length, capa);\n  add_edge_sub (&g->from[dst], src, g->from[src].length - 1, 0);\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t src, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == src) return e;\n  flow_type sum = 0;\n  flow_edge_vector * const vec = &g->from[v];\n  for (int32_t p = iter[v]; p < vec->length; ++p, iter[v] = p) {\n    const int32_t u = vec->edge[p].vertex;\n    const flow_type capa = g->from[u].edge[vec->edge[p].rev_index].capacity;\n    if (level[u] >= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, src, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      vec->edge[p].capacity += f;\n      g->from[u].edge[vec->edge[p].rev_index].capacity -= f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[src] = 1;\n    queue[last++] = src;\n    while (front < last && level[dst] == 0) {\n      const int32_t v = queue[front++];\n      const flow_edge_vector *vec = &g->from[v];\n      for (int32_t p = 0; p < vec->length; ++p) {\n        const int32_t u = vec->edge[p].vertex;\n        if (vec->edge[p].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] + 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[dst] == 0) break;\n    memset (iter, 0, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (dst, g, src, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = 0; i < n; ++i) {\n    add_edge (g, i + n, dst, b);\n    add_edge (g, src, i, a);\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 j = i + 1; j < n; ++j) {\n      if (p[i] > p[j]) {\n        add_edge (g, p[i], p[j] + n, flow_inf);\n      }\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int64_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 1000000000 * 5000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = iter[v] = g->edge[p].next) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = n - 1; i >= 0; --i) {\n    for (i32 j = n - 1; j > i; --j) {\n      if (p[i] > p[j]) {\n        add_edge (g, i, j + n, flow_inf);\n      }\n    }\n  }\n  for (i32 i = n - 1; i >= 0; --i) {\n    add_edge (g, src, i, a);\n    add_edge (g, i + n, dst, b);\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define size 5005\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nlong long bit[33400]={0},bsize=32768;\nlong long sum(long long i){\n    long long s=0;\n    while(i>0){\n        s+=bit[i];\n        i-=i&(-i);\n    }\n    return s;\n}\nvoid add(long long i,long long x){\n    while(i<=bsize){\n        bit[i]+=x;\n        i+=i&(-i);\n    }\n}\n\nlong long arr[size],n,a,b;\nlong long pod[size];\nlong long dp[size][size];\n\nlong long rep(long long st,long long fi){\n  long long w,r;\n  if(st==fi){return 0;}\n  if(dp[st][fi]!=-1){return dp[st][fi];}\n\n  w=sum(pod[st])-1;\n  add(pod[st],-1);\n  r=rep(st+1,fi)+llmin(b,w*a);\n  add(pod[st],1);\n\n  w=(fi-st+1)-sum(pod[fi]);\n  add(pod[fi],-1);\n  r=llmin(r,rep(st,fi-1)+llmin(a,w*b));\n  add(pod[fi],1);\n\n  dp[st][fi]=r;\n  return dp[st][fi];\n}\n\nint main(void){\n  long long i,j,m,k,c,h,w,r=0,l,t;\n  scanf(\"%lld%lld%lld\",&n,&a,&b);\n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      dp[i][j]=-1;\n    }\n  }\n  for(i=1;i<=n;i++){\n    add(i,1);\n    scanf(\"%lld\",&arr[i]);\n    pod[arr[i]]=i;\n  }\n  printf(\"%lld\\n\",rep(1,n));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define min(p,q)((p)<(q)?(p):(q))\n\nll n,a,b;\nll p[5010];\nll ip[5010];//pの逆引き\nll cnt[5010][5010];//cnt[i][j]=区間[i,j)に存在する、p[i]より小さいものの個数\nll memo[5010][5010];\nll f(int R,int K){\n\tif(R<=0||K<0)return 0;\n\tif(memo[R][K])return memo[R][K]-1;\n\tif(ip[K]>=R)return (memo[R][K]=f(R,K-1)+1)-1;\n\t\n\tll ans;\n\tif(cnt[ip[K]][R]){\n\t\tll v1=f(ip[K],K-1)+cnt[ip[K]][R]*b;\n\t\tll v2=f(    R,K-1)+a;\n\t\tans=min(v1,v2);\n\t}else{\n\t\tans=f(R,K-1);\n\t}\n\treturn (memo[R][K]=ans+1)-1;\n}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&a,&b);\n\trep(i,0,n){\n\t\tll t;\n\t\tscanf(\"%lld\",&t);\n\t\tt--;\n\t\tp[i]=t;\n\t\tip[t]=i;\n\t}\n\trep(i,0,n){\n\t\tll c=0;\n\t\trep(j,i+1,n+1){\n\t\t\tcnt[i][j]=c;\n\t\t\tif(p[j]<p[i])c++;\n\t\t}\n\t}\n\tprintf(\"%lld\",f(n,n-1));\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define inf (int)(1e14)\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nsigned main(){\n\tint N, A, B, i, j;\n\tscanf(\"%lld%lld%lld\", &N, &A, &B);\n\tint *p = (int *)malloc(sizeof(int) * (N + 1));\n\tint *p_inv = (int *)malloc(sizeof(int) * (N + 1));\n\tfor(i = 1; i <= N; i++){\n\t\tscanf(\"%lld\", &p[i]);\n\t\tp_inv[p[i]] = i;\n\t}\n\tint **dp1 = (int **)malloc(sizeof(int *) * (N + 1));\n\tint **dp2 = (int **)malloc(sizeof(int *) * (N + 1));\n\tint **m1 = (int **)malloc(sizeof(int *) * (N + 1));\n\tint **m2 = (int **)malloc(sizeof(int *) * (N + 1));\n\tfor(i = 0; i <= N; i++){\n\t\tdp1[i] = (int *)malloc(sizeof(int) * (N + 1));\n\t\tdp2[i] = (int *)malloc(sizeof(int) * (N + 1));\n\t\tm1[i] = (int *)malloc(sizeof(int) * (N + 1));\n\t\tm2[i] = (int *)malloc(sizeof(int) * (N + 1));\n\t}\n\tfor(j = 0; j <= N; j++){\n\t\tdp1[0][j] = 0;\n\t\tdp2[0][j] = 0;\n\t\tm1[0][j] = 0;\n\t\tm2[0][j] = 0;\n\t}\n\tfor(i = 1; i <= N; i++){\n\t\tdp1[i][0] = inf;\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tdp1[i][j] = min(m1[i - 1][j - 1], m2[i - 1][j - 1]);\n\t\t\tif(j < p_inv[i]){\n\t\t\t\tdp1[i][j] += B;\n\t\t\t}\n\t\t\tif(j > p_inv[i]){\n\t\t\t\tdp1[i][j] += A;\n\t\t\t}\n\t\t}\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tdp2[i][j] = min(m1[i - 1][j], m2[i - 1][j]);\n\t\t\tif(j < p_inv[i]){\n\t\t\t\tdp2[i][j] += B;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp2[i][j] += A;\n\t\t\t}\n\t\t}\n\t\tm1[i][0] = dp1[i][0];\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tm1[i][j] = min(m1[i][j - 1], dp1[i][j]);\n\t\t}\n\t\tm2[i][0] = dp2[i][0];\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tm2[i][j] = min(m2[i][j - 1], dp2[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", min(m1[N][N], m2[N][N]));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef i64 flow_type;\n\nconst flow_type flow_inf = (i64) 5000 * 1000000000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid clear_graph (graph * const g) {\n  g->pointer = 0;\n  memset (g->start, -1, sizeof (int32_t) * g->vertex_num);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nvoid add_edge_undirected (graph * const g, const int32_t u, const int32_t v, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {v, g->start[u], capa};\n  g->start[u] = p;\n  g->edge[p + 1] = (flow_edge) {u, g->start[v], capa};\n  g->start[v] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n  }\n  graph *g = new_graph (2 * n + 2);\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = n - 1; i >= 0; --i) {\n    add_edge (g, src, i, a);\n    add_edge (g, i + n, dst, b);\n    for (i32 j = i + 1, max = 0; j < n; ++j) {\n      if (p[i] < p[j]) continue;\n      if (p[j] > max) {\n\tadd_edge (g, i, j, flow_inf);\n\tadd_edge (g, i, j + n, flow_inf);\n\tmax = p[j];\n      }\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nhttps://atcoder.jp/contests/agc032/submissions/4672338 を参照しました\np[i]を右に挿入することを S -> i へコストAの辺を貼ることで表現\n同様に左に挿入することを i + N -> T へコストBの辺を貼ることで表現\ni < j で p[i] > p[j] なら iを右に動かすか、jを左に動かさなければならないのでi -> j + N へINFを貼る\nこのグラフのS-T の最小カットが求めたいものとなる(らしい)\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n#include<math.h>\n\ntypedef int64_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 1000000000 * 5000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  uint8_t *l = (uint8_t *) calloc (n, sizeof (uint8_t));\n  uint8_t *r = (uint8_t *) calloc (n, sizeof (uint8_t));\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 j = i + 1; j < n; ++j) {\n      if (p[i] > p[j]) {\n        add_edge (g, i, j + n, flow_inf);\n\tl[j] = r[i] = 1;\n      }\n    }\n  }\n  for (i32 i = 0; i < n; ++i) {\n    if (l[i]) {\n      add_edge (g, i + n, dst, b);\n    }\n    if (r[i]) {\n      add_edge (g, src, i, a);\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nhttps://atcoder.jp/contests/agc032/submissions/4672338 を参照しました\np[i]を右に挿入することを S -> i へコストAの辺を貼ることで表現\n同様に左に挿入することを i + N -> T へコストBの辺を貼ることで表現\ni < j で p[i] > p[j] なら iを右に動かすか、jを左に動かさなければならないのでi -> j + N へINFを貼る\nこのグラフのS-T の最小カットが求めたいものとなる(らしい)\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n#include<math.h>\n\ntypedef int64_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 1000000000 * 5000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = 0; i < n; ++i) {\n    add_edge (g, src, i, a);\n    add_edge (g, i + n, dst, b);\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 j = i + 1; j < n; ++j) {\n      if (p[i] > p[j]) {\n\tadd_edge (g, i, j + n, flow_inf);\n      }\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define size 5005\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nlong long bit[33400]={0},bsize=32768;\nlong long sum(long long i){\n    long long s=0;\n    while(i>0){\n        s+=bit[i];\n        i-=i&(-i);\n    }\n    return s;\n}\nvoid add(long long i,long long x){\n    while(i<=bsize){\n        bit[i]+=x;\n        i+=i&(-i);\n    }\n}\n\nlong long arr[size],n,a,b;\nlong long pod[size];\nlong long dp[size][size];\n\nlong long rep(long long st,long long fi){\n  long long w,r,t;\n  if(st==fi){return 0;}\n  if(dp[st][fi]!=-1){return dp[st][fi];}\n\n  w=sum(pod[st])-1;\n  add(pod[st],-1);\n  t=llmin(b,w*a);\n  if(w==1){t=llmin(a,b);}\n  r=rep(st+1,fi)+t;\n  add(pod[st],1);\n\n  w=(fi-st+1)-sum(pod[fi]);\n  add(pod[fi],-1);\n  t=llmin(a,w*b);\n  if(w==1){t=llmin(a,b);}\n  r=llmin(r,rep(st,fi-1)+t);\n  add(pod[fi],1);\n\n  dp[st][fi]=r;\n  return dp[st][fi];\n}\n\nint main(void){\n  long long i,j,m,k,c,h,w,r=0,l,t;\n  scanf(\"%lld%lld%lld\",&n,&a,&b);\n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      dp[i][j]=-1;\n    }\n  }\n  for(i=1;i<=n;i++){\n    add(i,1);\n    scanf(\"%lld\",&arr[i]);\n    pod[arr[i]]=i;\n  }\n  printf(\"%lld\\n\",rep(1,n));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define size 5005\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nlong long bit[33400]={0},bsize=32768;\nlong long sum(long long i){\n    long long s=0;\n    while(i>0){\n        s+=bit[i];\n        i-=i&(-i);\n    }\n    return s;\n}\nvoid add(long long i,long long x){\n    while(i<=bsize){\n        bit[i]+=x;\n        i+=i&(-i);\n    }\n}\n\nlong long arr[size],n,a,b;\nlong long pod[size];\nlong long dp[size][size];\n\nlong long rep(long long st,long long fi){\n  long long w,r,t;\n  if(st==fi){return 0;}\n  if(dp[st][fi]!=llinf){return dp[st][fi];}\n\n  add(pod[st],-1);\n  w=llmax(0,sum(pod[st]));\n  t=llmin(b,w*a);\n  r=rep(st+1,fi)+t;\n  add(pod[st],1);\n\n  add(pod[fi],-1);\n  w=llmax(0,(fi-st)-sum(pod[fi]));\n  t=llmin(a,w*b);\n  r=llmin(r,rep(st,fi-1)+t);\n  add(pod[fi],1);\n\n  dp[st][fi]=r;\n  return dp[st][fi];\n}\n\nint main(void){\n  long long i,j,m,k,c,h,w,r=0,l,t;\n  scanf(\"%lld%lld%lld\",&n,&a,&b);\n  for(i=0;i<size;i++){\n    for(j=0;j<size;j++){\n      dp[i][j]=llinf;\n    }\n  }\n  for(i=1;i<=n;i++){\n    add(i,1);\n    scanf(\"%lld\",&arr[i]);\n    pod[arr[i]]=i;\n  }\n  printf(\"%lld\\n\",rep(1,n));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef i64 flow_type;\n\nconst flow_type flow_inf = (i64) 5000 * 1000000000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid clear_graph (graph * const g) {\n  g->pointer = 0;\n  memset (g->start, -1, sizeof (int32_t) * g->vertex_num);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nvoid add_edge_undirected (graph * const g, const int32_t u, const int32_t v, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {v, g->start[u], capa};\n  g->start[u] = p;\n  g->edge[p + 1] = (flow_edge) {u, g->start[v], capa};\n  g->start[v] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef struct edge {\n  i32 from, to;\n  i64 capa;\n} edge;\n\ntypedef struct edge_list {\n  edge e;\n  struct edge_list *next;\n} list;\n\nconst i32 dummy = -1;\nlist* add (list *lst, i32 from, i32 to, i64 capa) {\n  if (from == dummy || to == dummy) return lst;\n  list *l = (list *) calloc (1, sizeof (list));\n  l->e = (edge) {from, to, capa};\n  l->next = lst;\n  return l;\n}\n\ni32 new_node (void) {\n  static i32 val = 0;\n  return val++;\n}\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  list *e = NULL;\n  const i32 src = new_node();\n  const i32 dst = new_node();\n  i32 *va = (i32 *) calloc (n, sizeof (i32));\n  i32 *vb = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n    va[i] = new_node();\n    e = add (e, src, va[i], a);\n    vb[i] = new_node();\n    e = add (e, vb[i], dst, b);\n  }\n  i32 k = 1;\n  while (k < n) k *= 2;\n  i32 *s = (i32 *) calloc (2 * k, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    s[i + k] = vb[i];\n  }\n  for (i32 i = n; i < k; ++i) {\n    s[i + k] = dummy;\n  }\n  for (i32 i = k - 1; i > 0; --i) {\n    if (s[2 * i] == dummy || s[2 * i + 1] == dummy) {\n      s[i] = dummy;\n    } else {\n      s[i] = new_node();\n      e = add (e, s[i], s[2 * i], flow_inf);\n      e = add (e, s[i], s[2 * i + 1], flow_inf);\n    }\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 l = k, r = p[i] + k; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) e = add (e, va[i], s[l++], flow_inf);\n      if (r & 1) e = add (e, va[i], s[--r], flow_inf);\n    }\n    s[k + p[i]] = dummy;\n    for (i32 x = (k + p[i]) / 2; x > 0; x >>= 1) {\n      if (s[x] == dummy) continue;\n      if (s[2 * x] == dummy || s[2 * x + 1] == dummy) {\n\ts[i] = s[2 * x] + s[2 * x + 1] - dummy;\n      } else {\n        s[x] = new_node();\n        e = add (e, s[x], s[2 * x], flow_inf);\n        e = add (e, s[x], s[2 * x + 1], flow_inf);\n      }\n    }\n  }\n  i32 size = new_node();\n  graph *g = new_graph (size);\n  while (e != NULL) {\n    add_edge (g, e->e.from, e->e.to, e->e.capa);\n    e = e->next;\n  }\n  i64 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int64_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 1000000000 * 5000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = iter[v] = g->edge[p].next) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = n - 1; i >= 0; --i) {\n    for (i32 j = n - 1; j > i; --j) {\n      if (p[i] > p[j]) {\n\tadd_edge (g, p[i], p[j] + n, flow_inf);\n      }\n    }\n  }\n  for (i32 i = n - 1; i >= 0; --i) {\n    add_edge (g, src, i, a);\n    add_edge (g, i + n, dst, b);\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef i64 flow_type;\n\nconst flow_type flow_inf = (i64) 5000 * 1000000000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (void) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = 2;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (g->vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < g->vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid clear_graph (graph * const g) {\n  g->pointer = 0;\n  memset (g->start, -1, sizeof (int32_t) * g->vertex_num);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (from >= g->vertex_num || to >= g->vertex_num) {\n    int32_t x = from >= to ? from : to;\n    int32_t y = 2 * g->vertex_num <= x ? x : 2 * g->vertex_num;\n    g->start = realloc (g->start, sizeof (int32_t) * y);\n    for (int32_t i = g->vertex_num; i < y; ++i) {\n      g->start[i] = -1;\n    }\n    g->vertex_num = y;\n  }\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\nconst i32 dummy = -1;\nvoid add (graph *g, i32 from, i32 to, i64 capa) {\n  if (from == dummy || to == dummy) return;\n  add_edge (g, from, to, capa);\n}\n\ni32 new_node (void) {\n  static i32 val = 0;\n  return val++;\n}\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  graph *g = new_graph();\n  const i32 src = new_node();\n  const i32 dst = new_node();\n  i32 *va = (i32 *) calloc (n, sizeof (i32));\n  i32 *vb = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n    va[i] = new_node();\n    add (g, src, va[i], a);\n    vb[i] = new_node();\n    add (g, vb[i], dst, b);\n  }\n  i32 k = 1;\n  while (k < n) k *= 2;\n  i32 *s = (i32 *) calloc (2 * k, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    s[i + k] = vb[i];\n  }\n  for (i32 i = n; i < k; ++i) {\n    s[i + k] = dummy;\n  }\n  for (i32 i = k - 1; i > 0; --i) {\n    if (s[2 * i] == dummy || s[2 * i + 1] == dummy) {\n      s[i] = dummy;\n    } else {\n      s[i] = new_node();\n      add (g, s[i], s[2 * i], flow_inf);\n      add (g, s[i], s[2 * i + 1], flow_inf);\n    }\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 l = k, r = p[i] + k; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) add (g, va[i], s[l++], flow_inf);\n      if (r & 1) add (g, va[i], s[--r], flow_inf);\n    }\n    s[k + p[i]] = dummy;\n    for (i32 x = (k + p[i]) / 2; x > 0; x >>= 1) {\n      if (s[x] == dummy) continue;\n      if (s[2 * x] == dummy || s[2 * x + 1] == dummy) {\n        s[x] = s[2 * x] + s[2 * x + 1] - dummy;\n      } else {\n        s[x] = new_node();\n        add (g, s[x], s[2 * x], flow_inf);\n        add (g, s[x], s[2 * x + 1], flow_inf);\n      }\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef i64 flow_type;\n\nconst flow_type flow_inf = (i64) 5000 * 1000000000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid free_graph (graph * const g) {\n  free (g->edge);\n  free (g->start);\n  free (g);\n}\n\nvoid clear_graph (graph * const g) {\n  g->pointer = 0;\n  memset (g->start, -1, sizeof (int32_t) * g->vertex_num);\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nvoid add_edge_undirected (graph * const g, const int32_t u, const int32_t v, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {v, g->start[u], capa};\n  g->start[u] = p;\n  g->edge[p + 1] = (flow_edge) {u, g->start[v], capa};\n  g->start[v] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef struct edge {\n  i32 from, to;\n  i64 capa;\n} edge;\n\ntypedef struct edge_list {\n  edge e;\n  struct edge_list *next;\n} list;\n\nconst i32 dummy = -1;\nlist* add (list *lst, i32 from, i32 to, i64 capa) {\n  if (from == dummy || to == dummy) return lst;\n  list *l = (list *) calloc (1, sizeof (list));\n  l->e = (edge) {from, to, capa};\n  l->next = lst;\n  return l;\n}\n\ni32 new_node (void) {\n  static i32 val = 0;\n  return val++;\n}\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  list *e = NULL;\n  const i32 src = new_node();\n  const i32 dst = new_node();\n  i32 *va = (i32 *) calloc (n, sizeof (i32));\n  i32 *vb = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n    va[i] = new_node();\n    e = add (e, src, va[i], a);\n    vb[i] = new_node();\n    e = add (e, vb[i], dst, b);\n  }\n  i32 k = 1;\n  while (k < n) k *= 2;\n  i32 *s = (i32 *) calloc (2 * k, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    s[i + k] = vb[i];\n  }\n  for (i32 i = n; i < k; ++i) {\n    s[i + k] = dummy;\n  }\n  for (i32 i = k - 1; i > 0; --i) {\n    if (s[2 * i] == dummy || s[2 * i + 1] == dummy) {\n      s[i] = dummy;\n    } else {\n      s[i] = new_node();\n      e = add (e, s[i], s[2 * i], flow_inf);\n      e = add (e, s[i], s[2 * i + 1], flow_inf);\n    }\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 l = k, r = p[i] + k; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) e = add (e, va[i], s[l++], flow_inf);\n      if (r & 1) e = add (e, va[i], s[--r], flow_inf);\n    }\n    s[k + p[i]] = dummy;\n    for (i32 x = (k + p[i]) / 2; x > 0; x >>= 1) {\n      if (s[x] == dummy) continue;\n      if (s[2 * x] == dummy || s[2 * x + 1] == dummy) {\n        s[x] = s[2 * x] + s[2 * x + 1] - dummy;\n      } else {\n        s[x] = new_node();\n        e = add (e, s[x], s[2 * x], flow_inf);\n        e = add (e, s[x], s[2 * x + 1], flow_inf);\n      }\n    }\n  }\n  i32 size = new_node();\n  graph *g = new_graph (size);\n  while (e != NULL) {\n    add_edge (g, e->e.from, e->e.to, e->e.capa);\n    e = e->next;\n  }\n  i64 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nhttps://atcoder.jp/contests/agc032/submissions/4672338 を参照しました\np[i]を右に挿入することを S -> i へコストAの辺を貼ることで表現\n同様に左に挿入することを i + N -> T へコストBの辺を貼ることで表現\ni < j で p[i] > p[j] なら p[i]を右に動かすか、p[j]を左に動かさなければならないのでi -> j + N へINFを貼る\nこのグラフのS-T の最小カットが求めたいものとなる\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int64_t flow_type;\n\nconst flow_type flow_inf = (int64_t) 1000000000 * 5000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nint64_t dinic (graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int64_t flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nvoid run (void) {\n  i32 n, a, b;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &a, &b);\n  i32 *p = (i32 *) calloc (n, sizeof (i32));\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n    p[i]--;\n  }\n  graph *g = new_graph (2 * n + 2);\n  const i32 src = 2 * n;\n  const i32 dst = 2 * n + 1;\n  for (i32 i = 0; i < n; ++i) {\n    add_edge (g, i + n, dst, b);\n    add_edge (g, src, i, a);\n  }\n  for (i32 i = 0; i < n; ++i) {\n    for (i32 j = i + 1; j < n; ++j) {\n      if (p[i] > p[j]) {\n        add_edge (g, p[i], p[j] + n, flow_inf);\n      }\n    }\n  }\n  i64 ans = dinic (g, src, dst);\n  printf(\"%\" PRIi64 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DRotationSort solver = new DRotationSort();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DRotationSort {\n        long[][] answer;\n        int[] leftmostUpTo;\n        int[] rightmostDownTo;\n        int a;\n        int b;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            a = in.readInt();\n            b = in.readInt();\n            int[] p = in.readIntArray(n);\n            MiscUtils.decreaseByOne(p);\n            int[] pos = ArrayUtils.reversePermutation(p);\n            leftmostUpTo = new int[n];\n            for (int i = 0; i < n; i++) {\n                leftmostUpTo[i] = n - 1;\n                for (int j = i + 1; j < n; j++) {\n                    if (pos[j] < pos[i]) {\n                        leftmostUpTo[i] = j - 1;\n                        break;\n                    }\n                }\n            }\n            rightmostDownTo = new int[n];\n            for (int i = 0; i < n; i++) {\n                rightmostDownTo[i] = 0;\n                for (int j = i - 1; j >= 0; j--) {\n                    if (pos[j] > pos[i]) {\n                        rightmostDownTo[i] = j + 1;\n                        break;\n                    }\n                }\n            }\n            answer = new long[n][n];\n            ArrayUtils.fill(answer, -1);\n            out.printLine(go(0, n - 1));\n        }\n\n        private long go(int x, int y) {\n            if (x == y) {\n                return 0;\n            }\n            if (answer[x][y] != -1) {\n                return answer[x][y];\n            }\n            if (leftmostUpTo[x] >= y) {\n                return answer[x][y] = go(x + 1, y);\n            }\n            if (rightmostDownTo[y] <= x) {\n                return answer[x][y] = go(x, y - 1);\n            }\n            return answer[x][y] = Math.min(a + go(x, y - 1), b + go(x + 1, y));\n        }\n\n    }\n\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]--;\n                }\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void fill(long[][] array, long value) {\n            for (long[] row : array) {\n                Arrays.fill(row, value);\n            }\n        }\n\n        public static int[] reversePermutation(int[] permutation) {\n            int[] result = new int[permutation.length];\n            for (int i = 0; i < permutation.length; i++) {\n                result[permutation[i]] = i;\n            }\n            return result;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n// https://atcoder.jp/contests/agc032/tasks/agc032_d\npublic class RotationSort {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long a = sc.nextInt();\n        long b = sc.nextInt();\n        long[] p = new long[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = sc.nextInt();\n        }\n        // costDP[i][j] = cost to sort the first i elements, moving some to\n        // the right at cost A, such that the maximum element not moved to\n        // the right has value <=j.\n        long[][] costDP = new long[n][n + 1];\n        for (int i = 0; i < n; i++) {\n            costDP[i][0] = a * (i + 1);\n        }\n        for (int j = 0; j < p[0]; j++) {\n            costDP[0][j] = a;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (j < p[i]) {\n                    costDP[i][j] = Math.min(costDP[i][j - 1], costDP[i - 1][j] + a);\n                } else if (j > p[i]) {\n                    costDP[i][j] = Math.min(costDP[i][j - 1], costDP[i - 1][j] + b);\n                } else {\n                    costDP[i][j] = Math.min(costDP[i][j - 1], costDP[i - 1][j]);\n                }\n            }\n        }\n\n        long bestCost = costDP[n - 1][0];\n        for (int i = 1; i <= n; i++) {\n            bestCost = Math.min(costDP[n - 1][i], bestCost);\n        }\n        System.out.println(bestCost);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskD {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int b = in.readInt();\n            int a = in.readInt();\n            int[] perm = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                perm[i] = in.readInt();\n            }\n            int[] rank = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                rank[i] = 0;\n                for (int j = 1; j < i; j++) {\n                    if (perm[j] > perm[i]) {\n                        rank[i]++;\n                    }\n                }\n            }\n\n            long[][] dp = new long[n + 1][n + 1];\n            SequenceUtils.deepFill(dp, (long) 1e18);\n            dp[0][0] = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j <= n; j++) {\n                    if (dp[i][j] == (long) 1e18) {\n                        continue;\n                    }\n                    if (rank[i + 1] == 0) {\n                        dp[i + 1][0] = Math.min(dp[i + 1][0], dp[i][j]);\n                    }\n                    dp[i + 1][Math.min(rank[i + 1], j)] = Math.min(dp[i + 1][Math.min(rank[i + 1], j)], dp[i][j] + a);\n                    if (j >= rank[i + 1]) {\n                        dp[i + 1][rank[i + 1]] = Math.min(dp[i + 1][rank[i + 1]], dp[i][j]);\n                        dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j] + b);\n                    }\n                }\n            }\n\n            long ans = (long) 1e18;\n            for (int i = 0; i <= n; i++) {\n                ans = Math.min(ans, dp[n][i]);\n            }\n\n            out.println(ans);\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(long c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class SequenceUtils {\n        public static void deepFill(Object array, long val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof long[]) {\n                long[] longArray = (long[]) array;\n                Arrays.fill(longArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    void solve() {\n        int n = in.nextInt();\n        int a = in.nextInt();\n        int b = in.nextInt();\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = in.nextInt();\n        }\n        long[] dp = new long[n + 1];\n        long[] ndp = new long[n + 1];\n        for (int v : nums) {\n            Arrays.fill(ndp, Long.MAX_VALUE / 2);\n            for (int curMax = 0; curMax <= n; curMax++) {\n                long cost = dp[curMax];\n                if (v < curMax) {\n                    ndp[curMax] = Math.min(ndp[curMax], cost + b);\n                } else {\n                    ndp[curMax] = Math.min(ndp[curMax], cost + a);\n                    ndp[v] = Math.min(ndp[v], cost);\n                }\n            }\n            long[] tmp = dp;\n            dp = ndp;\n            ndp = tmp;\n        }\n        long res = Long.MAX_VALUE;\n        for (long z : dp) {\n            res = Math.min(res, z);\n        }\n        out.println(res);\n    }\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"Main.in\"));\n            out = new PrintWriter(new File(\"Main.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tlong a = scanInt(), b = scanInt();\n\t\tlong dyn[] = new long[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p = scanInt();\n\t\t\tlong c = Long.MAX_VALUE;\n\t\t\tfor (int j = 0; j < p; j++) {\n\t\t\t\tc = min(c, dyn[j]);\n\t\t\t\tdyn[j] += a;\n\t\t\t}\n\t\t\tdyn[p] = c;\n\t\t\tfor (int j = p + 1; j <= n; j++) {\n\t\t\t\tdyn[j] += b;\n\t\t\t}\n\t\t}\n\t\tlong ans = Long.MAX_VALUE;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tans = min(ans, dyn[i]);\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), A = ni(), B = ni();\n\t\tint[] a = na(n);\n\t\t\n\t\tStarrySkyTreeL sst = new StarrySkyTreeL(n+1);\n\t\tsst.add(1, n+1, Long.MAX_VALUE / 5);\n\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint v = a[i];\n\t\t\t\n\t\t\t// a > b: -> a: B\n\t\t\t// a < b: -> b: 0\n\t\t\t//      : -> a: A\n\t\t\tlong bcost = sst.min(0, v);\n\t\t\tsst.add(0, v, A);\n\t\t\tsst.add(v+1, n+1, B);\n\t\t\tsst.add(v, v+1, bcost - sst.min(v, v+1));\n\t\t}\n\t\tout.println(sst.min(0, n+1));\n\t}\n\t\n\tpublic static class StarrySkyTreeL {\n\t\tpublic int M, H, N;\n\t\tpublic long[] st;\n\t\tpublic long[] plus;\n\t\tpublic long I = Long.MAX_VALUE/4; // I+plus<long\n\t\t\n\t\tpublic StarrySkyTreeL(int n)\n\t\t{\n\t\t\tN = n;\n\t\t\tM = Integer.highestOneBit(Math.max(n-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new long[M];\n\t\t\tplus = new long[H];\n\t\t}\n\t\t\n\t\tpublic StarrySkyTreeL(long[] a)\n\t\t{\n\t\t\tN = a.length;\n\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new long[M];\n\t\t\tfor(int i = 0;i < N;i++){\n\t\t\t\tst[H+i] = a[i];\n\t\t\t}\n\t\t\tplus = new long[H];\n\t\t\tArrays.fill(st, H+N, M, I);\n\t\t\tfor(int i = H-1;i >= 1;i--)propagate(i);\n\t\t}\n\t\t\n\t\tprivate void propagate(int i)\n\t\t{\n\t\t\tst[i] = Math.min(st[2*i], st[2*i+1]) + plus[i];\n\t\t}\n\t\t\n\t\tpublic void add(int l, int r, long v){ if(l < r)add(l, r, v, 0, H, 1); }\n\t\t\n\t\tprivate void add(int l, int r, long v, int cl, int cr, int cur)\n\t\t{\n\t\t\tif(l <= cl && cr <= r){\n\t\t\t\tif(cur >= H){\n\t\t\t\t\tst[cur] += v;\n\t\t\t\t}else{\n\t\t\t\t\tplus[cur] += v;\n\t\t\t\t\tpropagate(cur);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint mid = cl+cr>>>1;\n\t\t\t\tif(cl < r && l < mid){\n\t\t\t\t\tadd(l, r, v, cl, mid, 2*cur);\n\t\t\t\t}\n\t\t\t\tif(mid < r && l < cr){\n\t\t\t\t\tadd(l, r, v, mid, cr, 2*cur+1);\n\t\t\t\t}\n\t\t\t\tpropagate(cur);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long min(int l, int r){ return l >= r ? I : min(l, r, 0, H, 1);}\n\t\t\n\t\tprivate long min(int l, int r, int cl, int cr, int cur)\n\t\t{\n\t\t\tif(l <= cl && cr <= r){\n\t\t\t\treturn st[cur];\n\t\t\t}else{\n\t\t\t\tint mid = cl+cr>>>1;\n\t\t\t\tlong ret = I;\n\t\t\t\tif(cl < r && l < mid){\n\t\t\t\t\tret = Math.min(ret, min(l, r, cl, mid, 2*cur));\n\t\t\t\t}\n\t\t\t\tif(mid < r && l < cr){\n\t\t\t\t\tret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));\n\t\t\t\t}\n\t\t\t\treturn ret + plus[cur];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void fall(int i)\n\t\t{\n\t\t\tif(i < H){\n\t\t\t\tif(2*i < H){\n\t\t\t\t\tplus[2*i] += plus[i];\n\t\t\t\t\tplus[2*i+1] += plus[i];\n\t\t\t\t}\n\t\t\t\tst[2*i] += plus[i];\n\t\t\t\tst[2*i+1] += plus[i];\n\t\t\t\tplus[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int firstle(int l, long v) {\n\t\t\tint cur = H+l;\n\t\t\tfor(int i = 1, j = Integer.numberOfTrailingZeros(H)-1;i <= cur;j--){\n\t\t\t\tfall(i);\n\t\t\t\ti = i*2|cur>>>j&1;\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tfall(cur);\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcur++;\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tcur = cur>>>Integer.numberOfTrailingZeros(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int lastle(int l, long v) {\n\t\t\tint cur = H+l;\n\t\t\tfor(int i = 1, j = Integer.numberOfTrailingZeros(H)-1;i <= cur;j--){\n\t\t\t\tfall(i);\n\t\t\t\ti = i*2|cur>>>j&1;\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tfall(cur);\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tcur = cur>>>Integer.numberOfTrailingZeros(cur);\n\t\t\t\t\tcur--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void addx(int l, int r, long v){\n\t\t\tif(l >= r)return;\n\t\t\twhile(l != 0){\n\t\t\t\tint f = l&-l;\n\t\t\t\tif(l+f > r)break;\n\t\t\t\tif(f == 1){\n\t\t\t\t\tst[(H+l)/f] += v;\n\t\t\t\t}else{\n\t\t\t\t\tplus[(H+l)/f] += v;\n\t\t\t\t}\n\t\t\t\tl += f;\n\t\t\t}\n\t\t\t\n\t\t\twhile(l < r){\n\t\t\t\tint f = r&-r;\n\t\t\t\tif(f == 1){\n\t\t\t\t\tst[(H+r)/f-1] += v;\n\t\t\t\t}else{\n\t\t\t\t\tplus[(H+r)/f-1] += v;\n\t\t\t\t}\n\t\t\t\tr -= f;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long minx(int l, int r){\n\t\t\tlong lmin = I;\n\t\t\tif(l >= r)return lmin;\n\t\t\tif(l != 0){\n\t\t\t\tfor(int d = 0;H>>>d > 0;d++){\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\tint id = (H+l-1>>>d);\n\t\t\t\t\t\tlmin += plus[id];\n\t\t\t\t\t}\n\t\t\t\t\tif(l<<~d<0 && l+(1<<d) <= r){\n\t\t\t\t\t\tlong v = st[H+l>>>d];\n\t\t\t\t\t\tif(v < lmin)lmin = v;\n\t\t\t\t\t\tl += 1<<d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong rmin = I;\n\t\t\tfor(int d = 0;H>>>d > 0;d++){\n\t\t\t\tif(d > 0 && r < H)rmin += plus[H+r>>>d];\n\t\t\t\tif(r<<~d<0 && l < r){\n\t\t\t\t\tlong v = st[(H+r>>>d)-1];\n\t\t\t\t\tif(v < rmin)rmin = v;\n\t\t\t\t\tr -= 1<<d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong min = Math.min(lmin, rmin);\n\t\t\treturn min;\n\t\t}\n\t\t\n\t\tpublic long[] toArray() { return toArray(1, 0, H, new long[H]); }\n\t\t\n\t\tprivate long[] toArray(int cur, int l, int r, long[] ret)\n\t\t{\n\t\t\tif(r-l == 1){\n\t\t\t\tret[cur-H] = st[cur];\n\t\t\t}else{\n\t\t\t\ttoArray(2*cur, l, l+r>>>1, ret);\n\t\t\t\ttoArray(2*cur+1, l+r>>>1, r, ret);\n\t\t\t\tfor(int i = l;i < r;i++)ret[i] += plus[cur];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t\n\tpublic static class LST {\n\t\tpublic long[][] set;\n\t\tpublic int n;\n//\t\tpublic int size;\n\t\t\n\t\tpublic LST(int n) {\n\t\t\tthis.n = n;\n\t\t\tint d = 1;\n\t\t\tfor(int m = n;m > 1;m>>>=6, d++);\n\t\t\t\n\t\t\tset = new long[d][];\n\t\t\tfor(int i = 0, m = n>>>6;i < d;i++, m>>>=6){\n\t\t\t\tset[i] = new long[m+1];\n\t\t\t}\n//\t\t\tsize = 0;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST setRange(int r)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\tfor(int j = 0;j < r>>>6;j++){\n\t\t\t\t\tset[i][j] = -1L;\n\t\t\t\t}\n\t\t\t\tif((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST unsetRange(int r)\n\t\t{\n\t\t\tif(r >= 0){\n\t\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\t\tfor(int j = 0;j < r+63>>>6;j++){\n\t\t\t\t\t\tset[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif((r&63) != 0)set[i][r>>>6] &= ~((1L<<r)-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST set(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(!get(pos))size++;\n\t\t\t\tfor(int i = 0;i < set.length;i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] |= 1L<<pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST unset(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(get(pos))size--;\n\t\t\t\tfor(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] &= ~(1L<<pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic boolean get(int pos)\n\t\t{\n\t\t\treturn pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;\n\t\t}\n\t\t\n\t\tpublic LST toggle(int pos)\n\t\t{\n\t\t\treturn get(pos) ? unset(pos) : set(pos);\n\t\t}\n\t\t\n\t\tpublic int prev(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){\n\t\t\t\tint pre = prev(set[i][pos>>>6], pos&63);\n\t\t\t\tif(pre != -1){\n\t\t\t\t\tpos = pos>>>6<<6|pre;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic int next(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){\n\t\t\t\tint nex = next(set[i][pos>>>6], pos&63);\n\t\t\t\tif(nex != -1){\n\t\t\t\t\tpos = pos>>>6<<6|nex;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tprivate static int prev(long set, int n)\n\t\t{\n\t\t\tlong h = set<<~n;\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn -Long.numberOfLeadingZeros(h)+n;\n\t\t}\n\t\t\n\t\tprivate static int next(long set, int n)\n\t\t{\n\t\t\tlong h = set>>>n;\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn Long.numberOfTrailingZeros(h)+n;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int pos = next(0);pos != -1;pos = next(pos+1)){\n\t\t\t\tlist.add(pos);\n\t\t\t}\n\t\t\treturn list.toString();\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tlong A = sc.nextInt();\n\t\tlong B = sc.nextInt();\n\t\tint[] p = new int[N + 1];\n\t\tp[N] = N;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tp[i] = sc.nextInt() - 1;\n\t\t}\n\t\tint[] lessToLeft = new int[N + 1];\n\t\tfor (int i = 0; i < N + 1; i++) {\n\t\t\tfor (int j = i + 1; j < N + 1; j++) {\n\t\t\t\tif (p[i] < p[j]) lessToLeft[j]++;\n\t\t\t}\n\t\t}\n\t\tlong[] tabla = new long[N + 1];\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\tint total = p[i];\n\t\t\tint fromLeft = lessToLeft[i];\n\t\t\ttabla[i] = fromLeft * A + (total - fromLeft) * B;\n\t\t\tint less = 0;\n\t\t\tfor (int j = i; j >= 0; j--) if (p[j] < p[i]) {\n\t\t\t\ttotal = p[i] - p[j] - 1;\n\t\t\t\tfromLeft = lessToLeft[i] - lessToLeft[j] - 1 - less;\n\t\t\t\ttabla[i] = Math.min(tabla[i], tabla[j] + fromLeft * A + (total - fromLeft) * B);\n\t\t\t\tless++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(tabla[N]);\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long a = in.nextLong();\n            long b = in.nextLong();\n            int[] p = new int[n];\n            for (int i = 0; i < n; ++i) {\n                p[i] = in.nextInt();\n            }\n            long[] best = new long[n + 2];\n            for (int i = 0; i < n + 1; ++i) {\n                best[i + 1] = Long.MAX_VALUE;\n                long extra = 0;\n                for (int j = i - 1; j >= -1; --j) {\n                    if (i == n || j < 0 || p[j] < p[i]) {\n                        best[i + 1] = Math.min(best[i + 1], best[j + 1] + extra);\n                    }\n                    if (j >= 0) {\n                        if (i == n || p[j] < p[i]) {\n                            extra += b;\n                        } else {\n                            extra += a;\n                        }\n                    }\n                }\n            }\n            out.println(best[n + 1]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tlong A = sc.nextInt();\n\t\tlong B = sc.nextInt();\n\t\tint[] p = new int[N];\n\t\tint[] pos = new int[N];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = sc.nextInt() - 1;\n\t\t\tpos[p[i]] = i;\n\t\t}\n\t\tint[][] left = new int[N][N], right = new int[N][N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tleft[i][i] = right[i][i] = pos[i];\n\t\t}\n\t\tfor (int largo = 2; largo <= N; largo++) {\n\t\t\tfor (int from = 0; from + largo - 1 < N; from++) {\n\t\t\t\tint to = from + largo - 1;\n\t\t\t\tleft[from][to] = Math.min(left[from][to -1], pos[to]);\n\t\t\t\tright[from][to] = Math.max(right[from][to -1], pos[to]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[][] tabla = new long[N][N];\n\t\tfor (int largo = 2; largo <= N; largo++) {\n\t\t\tfor (int from = 0; from + largo - 1 < N; from++) {\n\t\t\t\tint to = from + largo - 1;\n\t\t\t\tif (p[right[from][to]] == to) tabla[from][to] = tabla[from][to-1];\n\t\t\t\telse if (p[left[from][to]] == from) tabla[from][to] = tabla[from+1][to];\n\t\t\t\telse {\n\t\t\t\t\ttabla[from][to] = Math.min(A + tabla[from][to - 1], B + tabla[from + 1][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(tabla[0][N-1]);\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DRotationSort solver = new DRotationSort();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DRotationSort {\n        int n;\n        long[][] answer;\n        int[] p;\n        long a;\n        long b;\n        int[][] qty;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.readInt();\n            a = in.readInt();\n            b = in.readInt();\n            p = in.readIntArray(n);\n            MiscUtils.decreaseByOne(p);\n            answer = new long[n + 1][n + 1];\n            ArrayUtils.fill(answer, -1);\n            qty = new int[n + 1][n + 1];\n            for (int i = 1; i <= n; i++) {\n                for (int j = 0; j < n; j++) {\n                    qty[i][j + 1] = qty[i][j];\n                    if (p[j] < i) {\n                        qty[i][j + 1]++;\n                    }\n                }\n            }\n            out.printLine(go(0, 0));\n        }\n\n        private long go(int x, int y) {\n            if (x == n) {\n                return 0;\n            }\n            if (answer[x][y] != -1) {\n                return answer[x][y];\n            }\n            if (p[x] < y) {\n                return answer[x][y] = go(x + 1, y);\n            }\n            return answer[x][y] =\n                    Math.min(go(x + 1, y) + a, go(x + 1, Math.max(y, p[x])) + b * query(x + 1, n - 1, y, p[x] - 1));\n        }\n\n        private int query(int posFrom, int posTo, int valFrom, int valTo) {\n            if (valTo < valFrom) {\n                return 0;\n            }\n            return qty[valTo + 1][posTo + 1] - qty[valTo + 1][posFrom] - qty[valFrom][posTo + 1] +\n                    qty[valFrom][posFrom];\n        }\n\n    }\n\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]--;\n                }\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void fill(long[][] array, long value) {\n            for (long[] row : array) {\n                Arrays.fill(row, value);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint rgh = nextInt();\n\t\tint lft = nextInt();\n\t\t\n\t\tint[] p = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = nextInt() - 1;\n\t\t}\n\t\t\n\t\tint[] badL = new int[n];\n\t\tTreeSet<Integer> seen = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tInteger tmp = seen.higher(p[i]);\n\t\t\tbadL[p[i]] = (tmp == null) ? INF : tmp;\n\t\t\tseen.add(p[i]);\n\t\t}\n\t\t\n\t\tseen.clear();\n\t\tint[] badR = new int[n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tInteger tmp = seen.lower(p[i]);\n\t\t\tbadR[p[i]] = (tmp == null) ? -INF : tmp;\n\t\t\tseen.add(p[i]);\n\t\t}\n\t\t\n\t\tlong[][] dp = new long[n][n];\n\t\tfor (int len = 2; len <= n; len++) {\n\t\t\tfor (int l = 0; l + len <= n; l++) {\n\t\t\t\tint r = l + len - 1;\n\t\t\t\t\n\t\t\t\tint costR = l <= badR[r] ? rgh : 0;\n\t\t\t\tint costL = r >= badL[l] ? lft : 0;\n\t\t\t\t\n\t\t\t\tdp[l][r] = Math.min(dp[l + 1][r] + costL, dp[l][r - 1] + costR);\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(dp[0][n - 1]);\n\t}\n\t\n\tstatic final int INF = 1_000_000;\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskD {\n\n    public static final long inf = Long.MAX_VALUE / 4;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      int n = in.nextInt();\n      int ca = in.nextInt();\n      int cb = in.nextInt();\n      int[] a = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        a[i] = in.nextInt() - 1;\n      }\n      a[n] = n;\n      long[] d = new long[n + 2];\n      d[0] = 0;\n      d[1] = 0;\n      for (int i = 2; i <= n + 1; ++i) {\n        long cur = inf;\n        long inc = 0;\n        int cval = a[i - 1];\n        for (int j = i - 1; j >= 0; --j) {\n          int val = j > 0 ? a[j - 1] : -1;\n          if (val < cval) {\n            if (cur > d[j] + inc) {\n              cur = d[j] + inc;\n            }\n          }\n          if (val > cval) {\n            inc += ca;\n          } else {\n            inc += cb;\n          }\n        }\n        d[i] = cur;\n      }\n      out.printLine(d[n + 1]);\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        D solver = new D();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D {\n        Long[][] memo;\n        boolean[][] first;\n        boolean[][] last;\n        int a;\n        int b;\n        long best;\n\n        private long rec(int from, int to) {\n            if (memo[from][to] != null)\n                return memo[from][to];\n            if (to - from == 1) {\n                if (first[from][to])\n                    return memo[from][to] = 0L;\n                else\n                    return memo[from][to] = best;\n            }\n            if (first[from][to])\n                return memo[from][to] = rec(from + 1, to);\n            else if (last[from][to])\n                return memo[from][to] = rec(from, to - 1);\n            return memo[from][to] = Math.min(rec(from + 1, to) + b, rec(from, to - 1) + a);\n        }\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.ni();\n            a = in.ni();\n            b = in.ni();\n            best = Math.min(a, b);\n\n\n            int[] p = new int[n];\n            int[] pinv = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = in.ni() - 1;\n                pinv[p[i]] = i;\n            }\n            if (n == 1) {\n                out.println(0);\n                return;\n            }\n\n            first = new boolean[n][n];\n\n            last = new boolean[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (pinv[j] < pinv[i])\n                        break;\n                    first[i][j] = true;\n                }\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                for (int j = i - 1; j >= 0; j--) {\n                    if (pinv[j] > pinv[i])\n                        break;\n                    last[j][i] = true;\n                }\n            }\n            memo = new Long[n][n];\n            long ans = rec(0, n - 1);\n            out.println(ans);\n\n\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n    private static FastScanner sc = new FastScanner();\n    private static boolean DEBUG_FLG = false;\n\n    public static void main(String[] args) {\n    \tint N = sc.nextInt();\n    \tlong A = sc.nextLong();\n    \tlong B = sc.nextLong();\n    \tint[] p = new int[N];\n    \tfor(int i=0; i<N; i++) {\n    \t\tp[i] = sc.nextInt();\n    \t}\n    \tlong[][] dpc = new long[N][N];\n    \tint[][] dpmin = new int[N][N];\n    \tint[][] dpmin2 = new int[N][N];\n    \tint[][] dpmax = new int[N][N];\n    \tint[][] dpmax2 = new int[N][N];\n    \tfor(int i=0; i<N; i++) {\n    \t\tdpc[i][i] = 0;\n    \t\tdpmin[i][i] = p[i];\n    \t\tdpmax[i][i] = p[i];\n    \t\tdpmin2[i][i] = Integer.MAX_VALUE;\n    \t\tdpmax2[i][i] = -1;\n    \t}\n    \tfor(int d=1; d<N; d++) {\n    \t\tfor(int i=0; i<N-d; i++) {\n    \t\t\tif(p[i+d] < dpmin[i][i+d-1]) {\n    \t\t\t\tdpmin2[i][i+d] = dpmin[i][i+d-1];\n    \t\t\t\tdpmin[i][i+d] = p[i+d];\n    \t\t\t} else if(p[i+d] < dpmin2[i][i+d-1]) {\n    \t\t\t\tdpmin2[i][i+d] = p[i+d];\n    \t\t\t\tdpmin[i][i+d] = dpmin[i][i+d-1];\n    \t\t\t} else {\n    \t\t\t\tdpmin2[i][i+d] = dpmin2[i][i+d-1];\n    \t\t\t\tdpmin[i][i+d] = dpmin[i][i+d-1];\n    \t\t\t}\n    \t\t\tif(p[i+d] > dpmax[i][i+d-1]) {\n    \t\t\t\tdpmax2[i][i+d] = dpmax[i][i+d-1];\n    \t\t\t\tdpmax[i][i+d] = p[i+d];\n    \t\t\t} else if(p[i+d] > dpmax2[i][i+d-1]) {\n    \t\t\t\tdpmax2[i][i+d] = p[i+d];\n    \t\t\t\tdpmax[i][i+d] = dpmax[i][i+d-1];\n    \t\t\t} else {\n    \t\t\t\tdpmax2[i][i+d] = dpmax2[i][i+d-1];\n    \t\t\t\tdpmax[i][i+d] = dpmax[i][i+d-1];\n    \t\t\t}\n    \t\t\tlong rightcost = 0;\n    \t\t\tif(p[i+d] > dpmax[i][i+d-1]) {\n    \t\t\t\trightcost = dpc[i][i+d-1];\n    \t\t\t} else if(p[i+d] >  dpmax2[i][i+d-1]){\n    \t\t\t\trightcost = dpc[i][i+d-1] + Math.min(A, B);\n    \t\t\t} else {\n    \t\t\t\trightcost = dpc[i][i+d-1] + B;\n    \t\t\t}\n    \t\t\tlong leftcost = 0;\n    \t\t\tif(p[i] < dpmin[i+1][i+d]) {\n    \t\t\t\tleftcost = dpc[i+1][i+d];\n    \t\t\t} else if(p[i] < dpmin2[i+1][i+d]){\n    \t\t\t\tleftcost = dpc[i+1][i+d] + Math.min(A, B);\n    \t\t\t} else {\n    \t\t\t\tleftcost = dpc[i+1][i+d] + A;\n    \t\t\t}\n    \t\t\tdpc[i][i+d] = Math.min(leftcost, rightcost);\n    \t\t\tdebug(i, i+d, leftcost, rightcost, dpmin[i][i+d], dpmin2[i][i+d], dpmax[i][i+d], dpmax2[i][i+d]);\n    \t\t}\n    \t}\n    \tSystem.out.println(dpc[0][N-1]);\n    }\n\n    static void debug(long... args) {\n    \tif(!DEBUG_FLG) return;\n    \tboolean flg = false;\n    \tfor(long s : args) {\n    \t\tif(flg) System.out.print(\" \");\n    \t\tflg = true;\n    \t\tSystem.out.print(s);\n    \t}\n    \tSystem.out.println();\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), A = ni(), B = ni();\n\t\tint[] a = na(n);\n\t\tfor(int i = 0;i < n;i++)a[i]--;\n\t\tint[] ia = new int[n];\n\t\tfor(int i = 0;i < n;i++)ia[a[i]] = i;\n\t\t\n\t\tlong[][] dp = new long[n][n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tArrays.fill(dp[i], Long.MAX_VALUE / 2);\n\t\t}\n\t\tdp[0][n-1] = 0;\n\t\tfor(int len = n;len >= 2;len--){\n\t\t\tLST lst = new LST(n);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlst.set(ia[i]);\n\t\t\t\tif(i >= len-1){\n\t\t\t\t\tint l = i-(len-1), r = i;\n\t\t\t\t\t// [l,r]\n\t\t\t\t\tif(lst.prev(ia[l]-1) == -1){\n\t\t\t\t\t\tdp[l+1][r] = Math.min(dp[l+1][r], dp[l][r]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[l+1][r] = Math.min(dp[l+1][r], dp[l][r] + B);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(lst.next(ia[r]+1) == -1){\n\t\t\t\t\t\tdp[l][r-1] = Math.min(dp[l][r-1], dp[l][r]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[l][r-1] = Math.min(dp[l][r-1], dp[l][r] + A);\n\t\t\t\t\t}\n\t\t\t\t\tlst.unset(ia[l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans = Long.MAX_VALUE;\n\t\tfor(int i = 0;i < n;i++)ans = Math.min(ans, dp[i][i]);\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static class LST {\n\t\tpublic long[][] set;\n\t\tpublic int n;\n//\t\tpublic int size;\n\t\t\n\t\tpublic LST(int n) {\n\t\t\tthis.n = n;\n\t\t\tint d = 1;\n\t\t\tfor(int m = n;m > 1;m>>>=6, d++);\n\t\t\t\n\t\t\tset = new long[d][];\n\t\t\tfor(int i = 0, m = n>>>6;i < d;i++, m>>>=6){\n\t\t\t\tset[i] = new long[m+1];\n\t\t\t}\n//\t\t\tsize = 0;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST setRange(int r)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\tfor(int j = 0;j < r>>>6;j++){\n\t\t\t\t\tset[i][j] = -1L;\n\t\t\t\t}\n\t\t\t\tif((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST unsetRange(int r)\n\t\t{\n\t\t\tif(r >= 0){\n\t\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\t\tfor(int j = 0;j < r+63>>>6;j++){\n\t\t\t\t\t\tset[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif((r&63) != 0)set[i][r>>>6] &= ~((1L<<r)-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST set(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(!get(pos))size++;\n\t\t\t\tfor(int i = 0;i < set.length;i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] |= 1L<<pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST unset(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(get(pos))size--;\n\t\t\t\tfor(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] &= ~(1L<<pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic boolean get(int pos)\n\t\t{\n\t\t\treturn pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;\n\t\t}\n\t\t\n\t\tpublic LST toggle(int pos)\n\t\t{\n\t\t\treturn get(pos) ? unset(pos) : set(pos);\n\t\t}\n\t\t\n\t\tpublic int prev(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){\n\t\t\t\tint pre = prev(set[i][pos>>>6], pos&63);\n\t\t\t\tif(pre != -1){\n\t\t\t\t\tpos = pos>>>6<<6|pre;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic int next(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){\n\t\t\t\tint nex = next(set[i][pos>>>6], pos&63);\n\t\t\t\tif(nex != -1){\n\t\t\t\t\tpos = pos>>>6<<6|nex;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tprivate static int prev(long set, int n)\n\t\t{\n\t\t\tlong h = set<<~n;\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn -Long.numberOfLeadingZeros(h)+n;\n\t\t}\n\t\t\n\t\tprivate static int next(long set, int n)\n\t\t{\n\t\t\tlong h = set>>>n;\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn Long.numberOfTrailingZeros(h)+n;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int pos = next(0);pos != -1;pos = next(pos+1)){\n\t\t\t\tlist.add(pos);\n\t\t\t}\n\t\t\treturn list.toString();\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n// https://atcoder.jp/contests/agc032/tasks/agc032_d\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long a = sc.nextInt();\n        long b = sc.nextInt();\n        long[] p = new long[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = sc.nextInt();\n        }\n        // costDP[i][j] = cost to sort the first i elements, moving some to\n        // the right at cost A, such that the maximum element not moved to\n        // the right has value <=j.\n        long[][] costDP = new long[n][n + 1];\n        for (int i = 0; i < n; i++) {\n            costDP[i][0] = a * (i + 1);\n        }\n        for (int j = 0; j < p[0]; j++) {\n            costDP[0][j] = a;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (j < p[i]) {\n                    costDP[i][j] = Math.min(costDP[i][j - 1], costDP[i - 1][j] + a);\n                } else if (j > p[i]) {\n                    costDP[i][j] = Math.min(costDP[i][j - 1], costDP[i - 1][j] + b);\n                } else {\n                    costDP[i][j] = Math.min(costDP[i][j - 1], costDP[i - 1][j]);\n                }\n            }\n        }\n\n        long bestCost = costDP[n - 1][0];\n        for (int i = 1; i <= n; i++) {\n            bestCost = Math.min(costDP[n - 1][i], bestCost);\n        }\n        System.out.println(bestCost);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        D solver = new D();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            long A = in.nextLong();\n            long B = in.nextLong();\n            int[] pos = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt() - 1;\n                pos[a[i]] = i;\n            }\n\n            long[][] dp = new long[n + 1][n + 1];\n            for (long[] z : dp) {\n                Arrays.fill(z, Long.MAX_VALUE / 2);\n            }\n            dp[0][0] = 0;\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= n; j++) {\n                    if (i < n && a[i] == j) {\n                        dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j]);\n                    }\n                    if (i < n && a[i] > j) {\n                        dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + A);\n                    }\n                    if (i < n && a[i] < j) {\n                        dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j]);\n                    }\n                    if (j < n && pos[j] < i) {\n                        dp[i][j + 1] = Math.min(dp[i][j + 1], dp[i][j]);\n                    }\n                    if (j < n && pos[j] > i) {\n                        dp[i][j + 1] = Math.min(dp[i][j + 1], dp[i][j] + B);\n                    }\n                }\n            }\n\n//        System.out.println(Arrays.deepToString(dp));\n            out.println(dp[n][n]);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tlong fast(int[] p, int rgh, int lft) {\n\t\tint n = p.length;\n\t\tlong[] dp = new long[n + 1];\n\t\tArrays.fill(dp, LINF);\n\n\t\tdp[0] = 0;\n\n\t\tfor (int v : p) {\n\t\t\tv++;\n\t\t\tlong[] nxt = new long[n + 1];\n\t\t\tArrays.fill(nxt, LINF);\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tif (dp[i] == LINF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (v < i) {\n\t\t\t\t\tnxt[i] = Math.min(nxt[i], dp[i] + lft);\n\t\t\t\t} else {\n\t\t\t\t\tnxt[v] = Math.min(nxt[v], dp[i]);\n\t\t\t\t\tnxt[i] = Math.min(nxt[i], dp[i] + rgh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = nxt;\n\t\t}\n\n\t\treturn Arrays.stream(dp).min().getAsLong();\n\t}\n\n\tstatic class Perm {\n\t\tint[] p;\n\n\t\tpublic Perm(int[] p) {\n\t\t\tthis.p = p;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + Arrays.hashCode(p);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPerm other = (Perm) obj;\n\t\t\tif (!Arrays.equals(p, other.p))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class Dist implements Comparable<Dist> {\n\t\tPerm p;\n\t\tlong dist;\n\n\t\tpublic Dist(Perm p, long dist) {\n\t\t\tthis.p = p;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Dist o) {\n\t\t\treturn Long.compare(dist, o.dist);\n\t\t}\n\t}\n\n\tlong slow(int[] p, int rgh, int lft) {\n\t\tint n = p.length;\n\t\tPerm from = new Perm(p);\n\t\tPerm goal = new Perm(IntStream.range(0, n).toArray());\n\n\t\tHashMap<Perm, Long> dist = new HashMap<>();\n\t\tPriorityQueue<Dist> pq = new PriorityQueue<>();\n\n\t\tdist.put(from, 0L);\n\t\tpq.add(new Dist(from, 0));\n\n\t\twhile (!pq.isEmpty()) {\n\t\t\tDist tmp = pq.poll();\n\t\t\tPerm v = tmp.p;\n\t\t\tif (dist.get(v) != tmp.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (v.equals(goal)) {\n\t\t\t\treturn tmp.dist;\n\t\t\t}\n\n\t\t\tint[] arr = v.p;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint move = arr[i];\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tint[] to = arr.clone();\n\t\t\t\t\tfor (int k = i; k > j; k--) {\n\t\t\t\t\t\tto[k] = to[k - 1];\n\t\t\t\t\t}\n\t\t\t\t\tto[j] = move;\n\t\t\t\t\tPerm pto = new Perm(to);\n\t\t\t\t\tif (dist.getOrDefault(pto, LINF) > tmp.dist + lft) {\n\t\t\t\t\t\tdist.put(pto, tmp.dist + lft);\n\t\t\t\t\t\tpq.add(new Dist(pto, tmp.dist + lft));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tint[] to = arr.clone();\n\t\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\t\tto[k] = to[k + 1];\n\t\t\t\t\t}\n\t\t\t\t\tto[j] = move;\n\t\t\t\t\tPerm pto = new Perm(to);\n\t\t\t\t\tif (dist.getOrDefault(pto, LINF) > tmp.dist + rgh) {\n\t\t\t\t\t\tdist.put(pto, tmp.dist + rgh);\n\t\t\t\t\t\tpq.add(new Dist(pto, tmp.dist + rgh));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new AssertionError();\n\t}\n\n\tstatic final long LINF = Long.MAX_VALUE / 10;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint rgh = nextInt();\n\t\tint lft = nextInt();\n\n\t\tint[] p = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = nextInt() - 1;\n\t\t}\n\n\t\tout.println(fast(p, rgh, lft));\n\t}\n\n\tstatic final int INF = 1_000_000;\n\n\tvoid test() {\n\t\tSystem.err.println(fast(new int[] { 3, 0, 2, 4, 1 }, 1, 1));\n\t\tSystem.err.println(slow(new int[] { 3, 0, 2, 4, 1 }, 1, 1));\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tint n = rand(1, C);\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = rand(0, i);\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = i;\n\t\t\t}\n\t\t\tint rgh = rand(1, 100);\n\t\t\tint lft = rand(1, 100);\n\t\t\tif (fast(p, rgh, lft) != slow(p, rgh, lft)) {\n\t\t\t\tSystem.err.println(Arrays.toString(p));\n\t\t\t\tSystem.err.println(rgh + \" \" + lft);\n\t\t\t\tSystem.err.println(fast(p, rgh, lft));\n\t\t\t\tSystem.err.println(slow(p, rgh, lft));\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 7;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint n = ir.nextInt();\n\t\tint a = ir.nextInt();\n\t\tint b = ir.nextInt();\n\t\tint[] p = ir.nextIntArray(n);\n\t\t// [0,i)まで並べて操作を行わなかった最大値がjの時のコストの最小値\n\t\tlong[][] dp = new long[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tArrays.fill(dp[i], 1L << 60);\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tl.add(0);\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < l.size(); j++) {\n\t\t\t\tint x = l.get(j);\n\t\t\t\tif (p[i] > x) {\n\t\t\t\t\tdp[i + 1][p[i]] = Math.min(dp[i + 1][p[i]], dp[i][x]);\n\t\t\t\t\tdp[i + 1][x] = Math.min(dp[i + 1][x], dp[i][x] + a);\n\t\t\t\t} else\n\t\t\t\t\tdp[i + 1][x] = Math.min(dp[i + 1][x], dp[i][x] + b);\n\t\t\t}\n\t\t\tl.add(p[i]);\n\t\t}\n\t\tlong res = 1L << 60;\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tres = Math.min(res, dp[n][i]);\n\t\tout.println(res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), A = ni(), B = ni();\n\t\tint[] P = na(n);\n\t\tfor(int i = 0;i < n;i++)P[i]--;\n\t\tlong[][] dp = new long[n+1][n+1];\n\t\tfor(int i = 0;i <= n;i++)Arrays.fill(dp[i], Long.MAX_VALUE / 2);\n\t\tfor(int i = 0;i <= n;i++){\n\t\t\tfor(int j = 0;j <= n;j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}else if(i-1 >= 0 && j-1 >= 0 && P[i-1] == j-1){\n\t\t\t\t\tdp[i][j] = dp[i-1][j-1];\n\t\t\t\t}else{\n\t\t\t\t\tif(i-1 >= 0)dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + (P[i-1] <= j ? B : A));\n\t\t\t\t\tif(j-1 >= 0)dp[i][j] = Math.min(dp[i][j], dp[i][j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(dp[n][n]);\n\t}\n\t\n\t// 534761298\n\t// 123456789\n\t\n\t// 40 0 40 0 100 40 0\n\t// 5 34 7 6 12 9 8\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        D solver = new D();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D {\n        Long[][] memo;\n        boolean[][] first;\n        boolean[][] last;\n        int a;\n        int b;\n        long best;\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.ni();\n            a = in.ni();\n            b = in.ni();\n            best = Math.min(a, b);\n\n\n            int[] p = new int[n];\n            int[] pinv = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = in.ni() - 1;\n                pinv[p[i]] = i;\n            }\n            if (n == 1) {\n                out.println(0);\n                return;\n            }\n\n            first = new boolean[n][n];\n\n            last = new boolean[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (pinv[j] < pinv[i])\n                        break;\n                    first[i][j] = true;\n                }\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                for (int j = i - 1; j >= 0; j--) {\n                    if (pinv[j] > pinv[i])\n                        break;\n                    last[j][i] = true;\n                }\n            }\n            memo = new Long[n][n];\n            long[][] dp = new long[n][n];\n            for (int i = 0; i < n; i++) {\n                Arrays.fill(dp[i], Long.MAX_VALUE);\n            }\n            for (int i = 0; i < n - 1; i++) {\n                if (!first[i][i + 1])\n                    dp[i][i + 1] = best;\n                else\n                    dp[i][i + 1] = 0;\n            }\n            for (int len = 2; len < n; len++) {\n                for (int i = 0; i + len < n; i++) {\n                    if (first[i][i + len])\n                        dp[i][i + len] = dp[i + 1][i + len];\n                    else if (last[i][i + len])\n                        dp[i][i + len] = dp[i][i + len - 1];\n                    else\n                        dp[i][i + len] = Math.min(dp[i][i + len - 1] + a, dp[i + 1][i + len] + b);\n                }\n            }\n            long ans = dp[0][n - 1];\n            out.println(ans);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\n\nclass Program\n{\n    static string AnswerString;\n    static int N, A, B;\n    static string instr;\n    static void Main(string[] args)\n    {\n        var l1 = Console.ReadLine().Split(' ').Select(n => int.Parse(n)).ToArray();\n        N = l1[0];\n        A = l1[1];\n        B = l1[2];\n        var istr = Console.ReadLine().Split(' ').Select(n => (char)int.Parse(n)).ToArray();\n        var instr = new string(istr);\n\n        var ass = new char[N];\n        for (int i = 1; i <= N; i++)\n            ass[i - 1] = (char)i;\n        AnswerString = new string(ass);\n\n        dp[AnswerString] = 0;\n        var ans = F(instr, 0);\n        Console.WriteLine(ans);\n    }\n\n    static Stack<string> evs = new Stack<string>();\n    static Dictionary<string, int> dp = new Dictionary<string, int>();\n    static int F(string s, int depth)\n    {\n        if (dp.ContainsKey(s))\n            return dp[s];\n\n        int min = int.MaxValue;\n        for (int i = 0; i < N - 1; i++)\n        {\n            string ss;\n            int a;\n\n            int ia = s[0];\n            if (!(ia - 1 >= i))\n                goto L_B;\n            ss = s.Substring(1, i + 1) + s.Substring(0, 1) + s.Substring(i + 1 + 1, s.Length - i - 2);\n            if (evs.Contains(ss))\n                goto L_B;\n            evs.Push(ss);\n            a = F(ss, depth + 1);\n            evs.Pop();\n            if (a < min)\n            {\n                min = a + A;\n            }\n            L_B:\n            int ib = s[s.Length - 1];\n            if (!(ib - 1 >= i))\n                continue;\n            ss = s.Substring(0, i) + s.Substring(s.Length - 1, 1) + s.Substring(i, s.Length - i - 1);\n            if (evs.Contains(ss))\n                continue;\n            evs.Push(ss);\n            a = F(ss, depth + 1);\n            evs.Pop();\n            if (a < min)\n            {\n                min = a + B;\n            }\n        }\n        dp[s] = min;\n        return min;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.IO;\nusing System.Diagnostics;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n    Scanner cin;\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        long A = cin.nextInt();\n        long B = cin.nextInt();\n        int[] p = cin.ArrayInt(N);\n\n\n        long MAX = long.MaxValue / 4;\n\n        long[] dp = new long[N + 1];\n        for (int i = 0; i < N + 1; i++)\n        {\n            dp[i] = MAX;\n        }\n        dp[0] = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            long[] nextDP = new long[N + 1];\n            for (int j = 0; j < N + 1; j++)\n            {\n                nextDP[j] = MAX;\n            }\n\n            for (int j = 0; j < N + 1; j++)\n            {\n                if (j < p[i])\n                {\n                    nextDP[p[i]] = Math.Min(nextDP[p[i]], dp[j]);\n                    nextDP[j] = Math.Min(nextDP[j], dp[j] + A);\n\n\n                }\n                else\n                {\n                    nextDP[j] = Math.Min(nextDP[j], dp[j] + B);\n                }\n            }\n\n            dp = nextDP;\n        }\n\n\n        Console.WriteLine(dp.Min());\n    }\n\n    \n\n\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nclass AtCoder\n{\n    public void Slove()\n    {\n        var inputs = Console.ReadLine().Split();\n        int n = int.Parse(inputs[0]);\n        long a = int.Parse(inputs[1]);\n        long b = int.Parse(inputs[2]);\n        var array = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        long[] dp = \n            Enumerable.Repeat((long)int.MaxValue, n + 1).ToArray();\n        dp[0] = 0;\n        foreach(int num in array)\n        {\n            dp[num] = dp.Take(num).Min();\n            foreach(int i in Enumerable.Range(0, num))\n            {\n                dp[i] += a;\n            }\n            foreach(int i in Enumerable.Range(0, n + 1).Skip(num + 1))\n            {\n                dp[i] += b;\n            }\n            //System.Console.WriteLine(string.Join(\" \", dp));\n        }\n        System.Console.WriteLine(dp.Min());\n    }\n    static void Main()\n    {\n        var ac = new AtCoder();\n        ac.Slove();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main(string[] args)\n    {\n        int n;\n        long a, b;\n        sc.Multi(out n, out a, out b);\n        var p = sc.IntArr;\n        var dp = new long[n + 1];\n        for (int i = 0; i < n; i++)\n        {\n            dp[i + 1] = LM;\n        }\n        for (int i = 0; i < n; i++)\n        {\n            var nex = new long[n + 1];\n            for (int j = 0; j < n + 1; j++)\n            {\n                nex[j] = LM;\n            }\n            nex[0] = dp[0] + a;\n            nex[i + 1] = Math.Min(nex[i + 1], dp[0]);\n            for (int j = 0; j < i; j++)\n            {\n                if (p[j] < p[i]) {\n                    nex[i + 1] = Math.Min(nex[i + 1], dp[j + 1]);\n                    nex[j + 1] = Math.Min(nex[j + 1], dp[j + 1] + a);\n                }\n                else {\n                    nex[j + 1] = Math.Min(nex[j + 1], dp[j + 1] + b);\n                }\n            }\n            dp = nex;\n        }\n        Prt(dp.Min());\n        sw.Flush();\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tstring[] str = Console.ReadLine().Split();\n\t\tint N = int.Parse(str[0]);\n\t\tlong A = long.Parse(str[1]);\n\t\tlong B = long.Parse(str[2]);\n\t\tlong[]P = new long[N];\n\t\tlong[]P1 = new long[N];\n\t\tstring[] str2 = Console.ReadLine().Split();\n\t\tfor(var i=0;i<N;i++){\n\t\t\tP[i] = long.Parse(str2[i]);\n\t\t\tP1[P[i]-1] = i;\n\t\t}\n\t\tlong[,]D = new long[N+1,N*2+1];\n\t\tfor(var i=1;i<=N;i++){\n\t\t\tlong min = D[i-1,0];\n\t\t\tD[i,0] = D[i-1,0]+B;\n\t\t\tfor(var j=1;j<N*2+1;j++){\n\t\t\t\tmin = Math.Min(min,D[i-1,j]);\n\t\t\t\tif(j==P1[i-1]*2+1){\n\t\t\t\t\tD[i,j] = min;\n\t\t\t\t} else if(j%2==1){\n\t\t\t\t\tD[i,j] = 99999999999999999;\n\t\t\t\t} else if(j<P1[i-1]*2+1){\n\t\t\t\t\tD[i,j] = min+B;\n\t\t\t\t} else {\n\t\t\t\t\tD[i,j] = min+A;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans = 99999999999999999;\n\t\tfor(var j=0;j<N*2+1;j++){\n\t\t\tans = Math.Min(ans,D[N,j]);\n\t\t}\n\t\tConsole.WriteLine(ans);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nclass AtCoder\n{\n    public void Slove()\n    {\n        var inputs = Console.ReadLine().Split();\n        int n = int.Parse(inputs[0]);\n        long a = int.Parse(inputs[1]);\n        long b = int.Parse(inputs[2]);\n        var array = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        long[] dp = \n            Enumerable.Repeat((long)int.MaxValue, n + 1).ToArray();\n        long[] imos = new long[n + 2];\n        dp[0] = 0;\n        foreach(int num in array)\n        {\n            dp[num] = dp.Take(num).Min();\n            foreach(int i in Enumerable.Range(0, num))\n            {\n                dp[i] += a;\n            }\n            foreach(int i in Enumerable.Range(0, n + 1).Skip(num + 1))\n            {\n                dp[i] += b;\n            }\n            System.Console.WriteLine(string.Join(\" \", dp));\n        }\n        System.Console.WriteLine(dp.Min());\n    }\n    static void Main()\n    {\n        var ac = new AtCoder();\n        ac.Slove();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Text;\nusing System.Linq;\nusing static System.Math;\n\nclass Program{\n    static void Main(){\n        string[] s = Console.ReadLine().Split(' ');\n        int n = int.Parse(s[0]);\n        int a = int.Parse(s[1]);\n        int b = int.Parse(s[2]);\n        int[] p = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        List<int> c = new List<int>();\n        int count = 0;\n        for (int i = 0;i < n;i++){\n            count++;\n            if (i != n - 1 && p[i] + 1 != p[i + 1]){\n                c.Add(count);\n                count = 0;\n            }\n        }\n        c.Add(count);\n\n        //foreach (var i in c) Console.Write(\"{0} \",i);\n        //Console.WriteLine();\n\n        long ans = 0;\n        List<long> ls = new List<long>();\n        if (p[0] != 1) ls.Add(a);\n        if (p[n - 1] != n) ls.Add(b);\n        for (int i = 1;i < c.Count - 1;i++){\n            ls.Add(c[i] * Min(a,b));\n        }\n        if (ls.Count == 0){\n            Console.WriteLine(0);\n            return;\n        }\n        ans = ls.Sum();\n        ans -= ls.Max();\n        Console.WriteLine(ans);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.IO;\nusing System.Diagnostics;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n    Scanner cin;\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        long A = cin.nextInt();\n        long B = cin.nextInt();\n        int[] p = cin.ArrayInt(N);\n\n\n        long MAX = long.MaxValue / 4;\n\n        long[] dp = new long[N + 1];\n        for (int i = 0; i < N + 1; i++)\n        {\n            dp[i] = MAX;\n        }\n        dp[0] = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            long[] nextDP = new long[N + 1];\n            for (int j = 0; j < N + 1; j++)\n            {\n                nextDP[j] = MAX;\n            }\n\n            for (int j = 0; j < N; j++)\n            {\n                if (j < p[i])\n                {\n                    nextDP[p[i]] = Math.Min(nextDP[p[i]], dp[j]);\n                    nextDP[j] = Math.Min(nextDP[j], dp[j] + A);\n\n\n                }\n                else\n                {\n                    nextDP[j] = Math.Min(nextDP[j], dp[j] + B);\n                }\n            }\n\n            dp = nextDP;\n        }\n\n\n        Console.WriteLine(dp.Min());\n    }\n\n    \n\n\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Text;\nusing System.Linq;\nusing static System.Math;\n\nclass Program{\n    static void Main(){\n        string[] s = Console.ReadLine().Split(' ');\n        int n = int.Parse(s[0]);\n        int a = int.Parse(s[1]);\n        int b = int.Parse(s[2]);\n        int[] p = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        List<Pair> c = new List<Pair>();\n        int count = 0;\n        for (int i = 0;i < n;i++){\n            count++;\n            if (i != n - 1 && p[i] + 1 != p[i + 1]){\n                c.Add(new Pair(p[i - count + 1],count));\n                count = 0;\n            }\n        }\n        c.Add(new Pair(p[n - count],count));\n\n        n = c.Count;\n        long ans = 0;\n        for (int i = 0;i < n - 1;i++){\n            for (int j = n - 1;j > i;j--){\n                if (c[j - 1].x > c[j].c){\n                    ans += Min(c[j-1].y*a,c[j].y*b);\n                    Pair temp = c[j];\n                    c[j] = c[j - 1];\n                    c[j - 1] = temp;\n                }\n            }\n        }\n        Console.WriteLine(ans);\n    }\n}\n\nstruct Pair{\n    public int x;\n    public int y;\n\n    public Pair(int x,int y){\n        this.x = x;\n        this.y = y;\n    }\n}"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(macrolet ((def (name fname)\n             `(define-modify-macro ,name (new-value) ,fname)))\n  (def minf min)\n  (def maxf max)\n  (def mulf *)\n  (def divf /)\n  (def iorf logior)\n  (def xorf logxor)\n  (def andf logand))\n\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defconstant +inf+ most-positive-fixnum)\n(defun main ()\n  (declare #.OPT)\n  (let* ((n (read))\n         (a (read))\n         (b (read))\n         (ps (make-array n :element-type 'uint31 :initial-element 0))\n         (invs (make-array n :element-type 'uint31 :initial-element 0))\n         (dp (make-array '(5001 5001)\n                         :element-type 'uint62\n                         :initial-element +inf+)))\n    (declare (uint31 n a b))\n    (dotimes (i n)\n      (setf (aref invs (- (read) 1)) i))\n    (setf (aref dp 0 0) 0)\n    (dotimes (x (+ n 1))\n      (dotimes (y (+ n 1))\n        (when (< y n)\n          (minf (aref dp x (+ y 1))\n                (aref dp x y)))\n        (when (< x n)\n          (cond ((< (aref invs x) y)\n                 (minf (aref dp (+ x 1) y)\n                       (+ (aref dp x y) a)))\n                ((> (aref invs x) y)\n                 (minf (aref dp (+ x 1) y)\n                       (+ (aref dp x y) b)))\n                (t\n                 (minf (aref dp (+ x 1) (+ y 1))\n                       (aref dp x y)))))))\n    (println (aref dp n n))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 20 30\n3 1 2\n\"\n    \"20\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 20 30\n4 2 3 1\n\"\n    \"50\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"1 10 10\n1\n\"\n    \"0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 1000000000 1000000000\n4 3 2 1\n\"\n    \"3000000000\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"9 40 50\n5 3 4 7 6 1 2 9 8\n\"\n    \"220\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Max flow (Dinic's algorithm)\n;;;\n\n(defconstant +graph-inf-distance+ #xffffffff)\n\n(define-condition max-flow-overflow (error)\n  ((graph :initarg :graph :reader max-flow-overflow-graph))\n  (:report\n   (lambda (condition stream)\n     (format stream \"MOST-POSITIVE-FIXNUM or more units can flow on graph ~W.\"\n             (max-flow-overflow-graph condition)))))\n\n(defstruct (edge (:constructor %make-edge\n                     (to capacity reversed\n                      &aux (default-capacity capacity))))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (default-capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (reversed nil :type (or null edge)))\n\n(defmethod print-object ((edge edge) stream)\n  (let ((*print-circle* t))\n    (call-next-method)))\n\n(defun add-edge (graph from-idx to-idx capacity &key bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of lists of all the edges that goes from each vertex\n\nIf BIDIRECTIONAL is true, PUSH-EDGE adds the reversed edge of the same\ncapacity in addition.\"\n  (declare (optimize (speed 3))\n           ((simple-array list (*)) graph))\n  (let* ((dep (%make-edge to-idx capacity nil))\n         (ret (%make-edge from-idx\n                          (if bidirectional capacity 0)\n                          dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %fill-dist-table (graph src dist-table queue)\n  \"Does BFS and sets DIST-TABLE to the distance between SRC and each vertex of\nGRAPH, where an edge of zero capacity is regarded as disconnected.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src)\n           ((simple-array list (*)) graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table queue))\n  (let* ((q-front 0)\n         (q-end 0))\n    (declare ((integer 0 #.most-positive-fixnum) q-front q-end))\n    (labels ((enqueue (obj)\n               (setf (aref queue q-end) obj)\n               (incf q-end))\n             (dequeue ()\n               (prog1 (aref queue q-front)\n                 (incf q-front))))\n      (declare (inline enqueue dequeue))\n      (fill dist-table +graph-inf-distance+)\n      (setf (aref dist-table src) 0)\n      (enqueue src)\n      (loop until (= q-front q-end)\n            for vertex = (dequeue)\n            do (dolist (edge (aref graph vertex))\n                 (let ((neighbor (edge-to edge)))\n                   (when (and (> (edge-capacity edge) 0)\n                              (= +graph-inf-distance+ (aref dist-table neighbor)))\n                     (setf (aref dist-table neighbor)\n                           (+ 1 (aref dist-table vertex)))\n                     (enqueue neighbor)))))))\n  dist-table)\n\n(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional)) %find-path))\n(defun %find-path (src dest tmp-graph dist-table)\n  \"Finds an augmenting path, sends the maximum flow through it, and returns the\namount of the flow.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) tmp-graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table))\n  (labels ((dfs (v flow)\n             (declare ((integer 0 #.most-positive-fixnum) v flow))\n             (when (= v dest)\n               (return-from dfs flow))\n             (loop\n               (unless (aref tmp-graph v)\n                 (return 0))\n               (let ((edge (car (aref tmp-graph v))))\n                 (when (and (> (edge-capacity edge) 0)\n                            (< (aref dist-table v) (aref dist-table (edge-to edge))))\n                   (let ((result (dfs (edge-to edge) (min flow (edge-capacity edge)))))\n                     (declare ((integer 0 #.most-positive-fixnum) result))\n                     (when (> result 0)\n                       (decf (edge-capacity edge) result)\n                       (incf (edge-capacity (edge-reversed edge)) result)\n                       (return result)))))\n               (pop (aref tmp-graph v)))))\n    (dfs src most-positive-fixnum)))\n\n(declaim (ftype (function * (values (mod #.most-positive-fixnum) &optional)) max-flow!))\n(defun max-flow! (graph src dest)\n  \"Destructively sends the maximum flow from SRC to DEST and returns the amount\nof the flow. This function signals MAX-FLOW-OVERFLOW error when an infinite\nflow (to be precise, >= MOST-POSITIVE-FIXNUM) is possible.\"\n  (declare #+sbcl (muffle-conditions style-warning)\n           ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) graph))\n  (let* ((n (length graph))\n         (dist-table (make-array n :element-type '(unsigned-byte 32)))\n         (queue (make-array n :element-type '(unsigned-byte 32)))\n         (tmp-graph (make-array n :element-type 'list))\n         (result 0))\n    (declare ((integer 0 #.most-positive-fixnum) result))\n    (loop\n      (%fill-dist-table graph src dist-table queue)\n      (when (= (aref dist-table dest) +graph-inf-distance+)\n        ;; SRC and DEST are not connected on the current residual network.\n        (return result))\n      (dotimes (i n)\n        (setf (aref tmp-graph i) (aref graph i)))\n      (loop for delta = (%find-path src dest tmp-graph dist-table)\n            until (zerop delta)\n            do (when (>= (+ result delta) most-positive-fixnum)\n                 (error 'max-flow-overflow :graph graph))\n               (incf result delta)))))\n\n(declaim (inline reinitialize-flow-network))\n(defun reinitialize-flow-network (graph)\n  \"Sets the current CAPACITY of every edge in GRAPH to the default\ncapacity. That is, this function reinitialize the graph network to the state\nprior to sending flow.\"\n  (loop for edges across graph\n        do (dolist (edge edges)\n             (setf (edge-capacity edge) (edge-default-capacity edge)))))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((n (read))\n         (a (read))\n         (b (read))\n         (ps (make-array n :element-type 'uint31 :initial-element 0))\n         (graph (make-array (+ (* 2 n) 2) :element-type 'list :initial-element nil))\n         (source (* 2 n))\n         (sink (+ (* 2 n) 1)))\n    (dotimes (i n)\n      (setf (aref ps i) (- (read) 1)))\n    (dotimes (i n)\n      (add-edge graph source i a)\n      (add-edge graph (+ i n) sink b))\n    (dotimes (i n)\n      (loop for j from (+ i 1) below n\n            when (> (aref ps i) (aref ps j))\n            do (add-edge graph i (+ j n) most-positive-fixnum)))\n    (println (max-flow! graph source sink))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 20 30\n3 1 2\n\"\n    \"20\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 20 30\n4 2 3 1\n\"\n    \"50\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"1 10 10\n1\n\"\n    \"0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 1000000000 1000000000\n4 3 2 1\n\"\n    \"3000000000\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"9 40 50\n5 3 4 7 6 1 2 9 8\n\"\n    \"220\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n;;;\n;;; Max flow (Dinic's algorithm)\n;;;\n\n(defconstant +graph-inf-distance+ #xffffffff)\n\n(define-condition max-flow-overflow (error)\n  ((graph :initarg :graph :reader max-flow-overflow-graph))\n  (:report\n   (lambda (condition stream)\n     (format stream \"MOST-POSITIVE-FIXNUM or more units can flow on graph ~W.\"\n             (max-flow-overflow-graph condition)))))\n\n(declaim (inline edge-to edge-capacity edge-reversed))\n(defun edge-to (edge)\n  (the (integer 0 #.most-positive-fixnum) (car edge)))\n(defun edge-capacity (edge)\n  (the (integer 0 #.most-positive-fixnum) (cadr edge)))\n(defun edge-reversed (edge)\n  (the list (cddr edge)))\n\n(defun add-edge (graph from-idx to-idx capacity &key bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of lists of all the edges that goes from each vertex\n\nIf BIDIRECTIONAL is true, PUSH-EDGE adds the reversed edge of the same\ncapacity in addition.\"\n  (declare (optimize (speed 3))\n           ((simple-array list (*)) graph))\n  (let* ((dep (list* to-idx capacity nil))\n         (ret (list* from-idx\n                     (if bidirectional capacity 0)\n                     dep)))\n    (setf (cddr dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %fill-dist-table (graph src dist-table queue)\n  \"Does BFS and sets DIST-TABLE to the distance between SRC and each vertex of\nGRAPH, where an edge of zero capacity is regarded as disconnected.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src)\n           ((simple-array list (*)) graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table queue))\n  (let* ((q-front 0)\n         (q-end 0))\n    (declare ((integer 0 #.most-positive-fixnum) q-front q-end))\n    (labels ((enqueue (obj)\n               (setf (aref queue q-end) obj)\n               (incf q-end))\n             (dequeue ()\n               (prog1 (aref queue q-front)\n                 (incf q-front))))\n      (declare (inline enqueue dequeue))\n      (fill dist-table +graph-inf-distance+)\n      (setf (aref dist-table src) 0)\n      (enqueue src)\n      (loop until (= q-front q-end)\n            for vertex = (dequeue)\n            do (dolist (edge (aref graph vertex))\n                 (let ((neighbor (edge-to edge)))\n                   (when (and (> (edge-capacity edge) 0)\n                              (= +graph-inf-distance+ (aref dist-table neighbor)))\n                     (setf (aref dist-table neighbor)\n                           (+ 1 (aref dist-table vertex)))\n                     (enqueue neighbor)))))))\n  dist-table)\n\n(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional)) %find-path))\n(defun %find-path (src dest tmp-graph dist-table)\n  \"Finds an augmenting path, sends the maximum flow through it, and returns the\namount of the flow.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) tmp-graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table))\n  (labels ((dfs (v flow)\n             (declare ((integer 0 #.most-positive-fixnum) v flow))\n             (when (= v dest)\n               (return-from dfs flow))\n             (loop\n               (unless (aref tmp-graph v)\n                 (return 0))\n               (let ((edge (car (aref tmp-graph v))))\n                 (when (and (> (edge-capacity edge) 0)\n                            (< (aref dist-table v) (aref dist-table (edge-to edge))))\n                   (let ((result (dfs (edge-to edge) (min flow (edge-capacity edge)))))\n                     (declare ((integer 0 #.most-positive-fixnum) result))\n                     (when (> result 0)\n                       (decf (the uint62 (cadr edge)) result)\n                       (incf (the uint62 (cadr (cddr edge))) result)\n                       (return result)))))\n               (pop (aref tmp-graph v)))))\n    (dfs src most-positive-fixnum)))\n\n(declaim (ftype (function * (values (mod #.most-positive-fixnum) &optional)) max-flow!))\n(defun max-flow! (graph src dest)\n  \"Destructively sends the maximum flow from SRC to DEST and returns the amount\nof the flow. This function signals MAX-FLOW-OVERFLOW error when an infinite\nflow (to be precise, >= MOST-POSITIVE-FIXNUM) is possible.\"\n  (declare #+sbcl (muffle-conditions style-warning)\n           ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) graph))\n  (let* ((n (length graph))\n         (dist-table (make-array n :element-type '(unsigned-byte 32)))\n         (queue (make-array n :element-type '(unsigned-byte 32)))\n         (tmp-graph (make-array n :element-type 'list))\n         (result 0))\n    (declare ((integer 0 #.most-positive-fixnum) result))\n    (loop\n      (%fill-dist-table graph src dist-table queue)\n      (when (= (aref dist-table dest) +graph-inf-distance+)\n        ;; SRC and DEST are not connected on the current residual network.\n        (return result))\n      (dotimes (i n)\n        (setf (aref tmp-graph i) (aref graph i)))\n      (loop for delta = (%find-path src dest tmp-graph dist-table)\n            until (zerop delta)\n            do (when (>= (+ result delta) most-positive-fixnum)\n                 (error 'max-flow-overflow :graph graph))\n               (incf result delta)))))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((n (read))\n         (a (read))\n         (b (read))\n         (ps (make-array n :element-type 'uint31 :initial-element 0))\n         (graph (make-array (+ (* 2 n) 2) :element-type 'list :initial-element nil))\n         (source (* 2 n))\n         (sink (+ (* 2 n) 1)))\n    (dotimes (i n)\n      (setf (aref ps i) (- (read) 1)))\n    (dotimes (i n)\n      (add-edge graph source i a)\n      (add-edge graph (+ i n) sink b))\n    (dotimes (i n)\n      (loop for j from (+ i 1) below n\n            when (> (aref ps i) (aref ps j))\n            do (add-edge graph i (+ j n) most-positive-fixnum)))\n    (println (max-flow! graph source sink))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 20 30\n3 1 2\n\"\n    \"20\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 20 30\n4 2 3 1\n\"\n    \"50\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"1 10 10\n1\n\"\n    \"0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 1000000000 1000000000\n4 3 2 1\n\"\n    \"3000000000\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"9 40 50\n5 3 4 7 6 1 2 9 8\n\"\n    \"220\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(macrolet ((def (name fname)\n             `(define-modify-macro ,name (new-value) ,fname)))\n  (def minf min)\n  (def maxf max)\n  (def mulf *)\n  (def divf /)\n  (def iorf logior)\n  (def xorf logxor)\n  (def andf logand))\n\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defconstant +inf+ most-positive-fixnum)\n(defun main ()\n  (let* ((n (read))\n         (a (read))\n         (b (read))\n         (ps (make-array n :element-type 'uint31 :initial-element 0))\n         (invs (make-array n :element-type 'uint31 :initial-element 0))\n         (dp (make-array (list (+ n 1) (+ n 1))\n                         :element-type 'uint62\n                         :initial-element +inf+)))\n    (declare (uint31 n a b))\n    (dotimes (i n)\n      (setf (aref invs (- (read) 1)) i))\n    (setf (aref dp 0 0) 0)\n    (dotimes (x (+ n 1))\n      (dotimes (y (+ n 1))\n        (when (< y n)\n          (minf (aref dp x (+ y 1))\n                (aref dp x y)))\n        (when (< x n)\n          (cond ((< (aref invs x) y)\n                 (minf (aref dp (+ x 1) y)\n                       (+ (aref dp x y) a)))\n                ((> (aref invs x) y)\n                 (minf (aref dp (+ x 1) y)\n                       (+ (aref dp x y) b)))\n                (t\n                 (minf (aref dp (+ x 1) (+ y 1))\n                       (aref dp x y)))))))\n    (println (aref dp n n))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 20 30\n3 1 2\n\"\n    \"20\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 20 30\n4 2 3 1\n\"\n    \"50\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"1 10 10\n1\n\"\n    \"0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 1000000000 1000000000\n4 3 2 1\n\"\n    \"3000000000\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"9 40 50\n5 3 4 7 6 1 2 9 8\n\"\n    \"220\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n;;;\n;;; Max flow (Dinic's algorithm)\n;;;\n\n(defconstant +graph-inf-distance+ #xffffffff)\n\n(define-condition max-flow-overflow (error)\n  ((graph :initarg :graph :reader max-flow-overflow-graph))\n  (:report\n   (lambda (condition stream)\n     (format stream \"MOST-POSITIVE-FIXNUM or more units can flow on graph ~W.\"\n             (max-flow-overflow-graph condition)))))\n\n(declaim (inline edge-to edge-capacity edge-reversed))\n(defun edge-to (edge)\n  (the (integer 0 #.most-positive-fixnum) (car edge)))\n(defun edge-capacity (edge)\n  (the (integer 0 #.most-positive-fixnum) (cadr edge)))\n(defun edge-reversed (edge)\n  (the list (cddr edge)))\n\n(defun add-edge (graph from-idx to-idx capacity &key bidirectional)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of lists of all the edges that goes from each vertex\n\nIf BIDIRECTIONAL is true, PUSH-EDGE adds the reversed edge of the same\ncapacity in addition.\"\n  (declare (optimize (speed 3))\n           ((simple-array list (*)) graph))\n  (let* ((dep (list* to-idx capacity nil))\n         (ret (list* from-idx\n                     (if bidirectional capacity 0)\n                     dep)))\n    (setf (cddr dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n(defun %fill-dist-table (graph src dist-table queue)\n  \"Does BFS and sets DIST-TABLE to the distance between SRC and each vertex of\nGRAPH, where an edge of zero capacity is regarded as disconnected.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src)\n           ((simple-array list (*)) graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table queue))\n  (let* ((q-front 0)\n         (q-end 0))\n    (declare ((integer 0 #.most-positive-fixnum) q-front q-end))\n    (labels ((enqueue (obj)\n               (setf (aref queue q-end) obj)\n               (incf q-end))\n             (dequeue ()\n               (prog1 (aref queue q-front)\n                 (incf q-front))))\n      (declare (inline enqueue dequeue))\n      (fill dist-table +graph-inf-distance+)\n      (setf (aref dist-table src) 0)\n      (enqueue src)\n      (loop until (= q-front q-end)\n            for vertex = (dequeue)\n            do (dolist (edge (aref graph vertex))\n                 (let ((neighbor (edge-to edge)))\n                   (when (and (> (edge-capacity edge) 0)\n                              (= +graph-inf-distance+ (aref dist-table neighbor)))\n                     (setf (aref dist-table neighbor)\n                           (+ 1 (aref dist-table vertex)))\n                     (enqueue neighbor)))))))\n  dist-table)\n\n(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional)) %find-path))\n(defun %find-path (src dest tmp-graph dist-table)\n  \"Finds an augmenting path, sends the maximum flow through it, and returns the\namount of the flow.\"\n  (declare (optimize (speed 3) (safety 0))\n           ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) tmp-graph)\n           ((simple-array (unsigned-byte 32) (*)) dist-table))\n  (labels ((dfs (v flow)\n             (declare ((integer 0 #.most-positive-fixnum) v flow))\n             (when (= v dest)\n               (return-from dfs flow))\n             (loop\n               (unless (aref tmp-graph v)\n                 (return 0))\n               (let ((edge (car (aref tmp-graph v))))\n                 (when (and (> (edge-capacity edge) 0)\n                            (< (aref dist-table v) (aref dist-table (edge-to edge))))\n                   (let ((result (dfs (edge-to edge) (min flow (edge-capacity edge)))))\n                     (declare ((integer 0 #.most-positive-fixnum) result))\n                     (when (> result 0)\n                       (decf (the uint62 (cadr edge)) result)\n                       (incf (the uint62 (cadr (cddr edge))) result)\n                       (return result)))))\n               (pop (aref tmp-graph v)))))\n    (dfs src most-positive-fixnum)))\n\n(declaim (ftype (function * (values (mod #.most-positive-fixnum) &optional)) max-flow!))\n(defun max-flow! (graph src dest)\n  \"Destructively sends the maximum flow from SRC to DEST and returns the amount\nof the flow. This function signals MAX-FLOW-OVERFLOW error when an infinite\nflow (to be precise, >= MOST-POSITIVE-FIXNUM) is possible.\"\n  (declare #+sbcl (muffle-conditions style-warning)\n           ((integer 0 #.most-positive-fixnum) src dest)\n           ((simple-array list (*)) graph))\n  (let* ((n (length graph))\n         (dist-table (make-array n :element-type '(unsigned-byte 32)))\n         (queue (make-array n :element-type '(unsigned-byte 32)))\n         (tmp-graph (make-array n :element-type 'list))\n         (result 0))\n    (declare ((integer 0 #.most-positive-fixnum) result))\n    (loop\n      (%fill-dist-table graph src dist-table queue)\n      (when (= (aref dist-table dest) +graph-inf-distance+)\n        ;; SRC and DEST are not connected on the current residual network.\n        (return result))\n      (dotimes (i n)\n        (setf (aref tmp-graph i) (aref graph i)))\n      (loop for delta = (%find-path src dest tmp-graph dist-table)\n            until (zerop delta)\n            do (when (>= (+ result delta) most-positive-fixnum)\n                 (error 'max-flow-overflow :graph graph))\n               (incf result delta)))))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((n (read))\n         (a (read))\n         (b (read))\n         (ps (make-array n :element-type 'uint31 :initial-element 0))\n         (graph (make-array (+ (* 2 n) 2) :element-type 'list :initial-element nil))\n         (source (* 2 n))\n         (sink (+ (* 2 n) 1)))\n    (dotimes (i n)\n      (setf (aref ps i) (- (read) 1)))\n    (dotimes (i n)\n      (add-edge graph source i a)\n      (add-edge graph (+ i n) sink b))\n    (dotimes (i n)\n      (loop for j from (+ i 1) below n\n            when (> (aref ps i) (aref ps j))\n            do (add-edge graph i (+ j n) most-positive-fixnum)))\n    (println (max-flow! graph source sink))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 20 30\n3 1 2\n\"\n    \"20\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 20 30\n4 2 3 1\n\"\n    \"50\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"1 10 10\n1\n\"\n    \"0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"4 1000000000 1000000000\n4 3 2 1\n\"\n    \"3000000000\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"9 40 50\n5 3 4 7 6 1 2 9 8\n\"\n    \"220\n\")))\n"
  },
  {
    "language": "JavaScript",
    "code": "var GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nvar mod = 1e9+7;\n\nconsole.log(main());\nfunction main(){\n  var n = o.a();\n  var a = o.a();\n  var b = o.a();\n  var p = o.l();\n  var set = new Set();\n  set.add(0);\n  var dp = Array(n+1).fill(9e99);\n  dp[0] = 0;\n  for(var i = 0; i < n; i++){\n    for(var x of set){\n      if(x < p[i]){\n        if(dp[x] < dp[p[i]])dp[p[i]] = dp[x];\n        dp[x] += a;\n      }else{\n        dp[x] += b;\n      }\n    }\n    set.add(p[i]);\n  }\n  return Math.min(...dp);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nvar mod = 1e9+7;\n\nconsole.log(main());\nfunction main(){\n  var n = o.a();\n  var a = o.a();\n  var b = o.a();\n  var p = o.l();\n  var dp = Array(n+1).fill(9e17);\n  dp[0] = 0;\n  for(var i = 0; i < n; i++){\n    for(var x = 0; x <= n; x++){\n      if(p[i] === x || dp[x] === 9e17)continue;\n      if(x < p[i]){\n        if(dp[x] < dp[p[i]])dp[p[i]] = dp[x];\n        dp[x] += a;\n      }else{\n        dp[x] += b;\n      }\n    }\n  }\n  return Math.min(...dp);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string;\nimport std.array, std.range, std.algorithm, std.container;\nimport std.math, std.random, std.bigint, std.datetime, std.format;\nstring read(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\n\nint DEBUG_LEVEL = 0;\nvoid print()(){ writeln(\"\"); }\nvoid print(T, A ...)(T t, lazy A a){ write(t), print(a); }\nvoid print(int level, T, A ...)(T t, lazy A a){ if(level <= DEBUG_LEVEL) print(t, a); }\n\nvoid main(string[] args){\n\tif(args.length > 1 && args[1] == \"-debug\"){\n\t\tif(args.length > 2 && args[2].isNumeric) DEBUG_LEVEL = args[2].to!int;\n\t\telse DEBUG_LEVEL = 1;\n\t}\n\t\n\tint n = read.to!int;\n\tlong a = read.to!long;\n\tlong b = read.to!long;\n\t\n\tint[] ps;\n\tforeach(i; 0 .. n) ps ~= read.to!int - 1;\n\tprint!1(\"ps:\", ps);\n\t\n\t// us[p]: pより左にある、pより大きい最小の数\n\tint[] us = new int[](n);\n\tforeach(i; 0 .. n){\n\t\tint u = n * 2;\n\t\tforeach(j; 0 .. i) if(ps[j] > ps[i] && ps[j] < u) u = ps[j];\n\t\tus[ps[i]] = u;\n\t}\n\tprint!1(\"us:\", us);\n\t\n\t// vs[p]: pより右にある、pより小さい最大の数\n\tint[] vs = new int[](n);\n\tforeach(j; 0 .. n){\n\t\tint v = -1;\n\t\tforeach(i; j + 1 .. n) if(ps[i] < ps[j] && ps[i] > v) v = ps[i];\n\t\tvs[ps[j]] = v;\n\t}\n\tprint!1(\"vs:\", vs);\n\t\n\t// xs[k]: 0 .. k を左に、k + 1 .. n を右に寄せる最小のコスト\n\tlong[] xs = new long[](n);\n\tforeach(k; 0 .. n){\n\t\tlong x;\n\t\tforeach(i; 0 .. k) x += (us[i] >= k + 1? 0: b);\n\t\tforeach(j; k + 1 .. n) x += (vs[j] < k? 0 : a);\n\t\txs[k] = x;\n\t}\n\tprint!1(\"xs:\", xs);\n\t\n\t// xs[k]のうちで最小のものを探す\n\tlong ans = a * n + b * n;\n\tforeach(k; 0 .. n) if(xs[k] < ans) ans = xs[k];\n\t\n\tans.writeln;\n\t\n}\n\n/*\n\nローテーションと言っているのは要素を取って別の場所に挿入する操作\n同じ要素に対して2回行うことは無駄なので、高々1回しか行わない\n\n左へ移動して左からソートしていくか、右へ移動して右からソートしていくか？\n最終形としては、\n・ある項は固定されている\n・それより左は、左へ移動してソートした要素たち\n・それより右は、右へ移動してソートした要素たち\nという状態になるはず\n\nただし、元からソートされていて移動しなくてすむ要素というのがある\n「自分は、いくつまでが右へソートされたら左へソートしなくてすむのか」\n「自分は、いくつまでが左へソートされたら右へソートしなくてすむのか」\nをあらかじめ考えておく\n\nたとえばこの入力例5では\n> 9 40 50\n> 5 3 4 7 6 1 2 9 8\n\n3は、\n　もし5が右へ移動することになったなら自分は左へは移動する必要がない\n　もし1と2が左へ移動することになったなら自分は右へは移動する必要がない\n7は、\n　どんな場合にも左へ移動する必要がない\n　もし1と2と6が左へ移動することになったなら自分は右へは移動する必要がない\n\nこれは\n　自分より左にある、自分より大きい最小の数\n　自分より右にある、自分より小きい最大の数\n\nを調べるということ\n（N=5000なのでこれを求めるのは二重ループで良い）\n\nその上で\n　「0 .. kを左へ、k + 1 .. nを右へソートする場合のコスト」を求める\n　（最終的に求めるものは　min(k) x[k]　）\n\niより左にある、iより大きい最小の数 u[i]\njより右にある、jより小きい最大の数 v[j]\n0 .. kを左へ、k + 1 .. nを右へソートする場合のコスト x[k]\n\nx[k] = sum(i; 0 .. k) (u[i] >= k + 1? 0: A) + sum(j; k + 1 .. n) (v[j] < k? 0: B)\n\n*/\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string;\nimport std.array, std.range, std.algorithm, std.container;\nimport std.math, std.random, std.bigint, std.datetime, std.format;\nstring read(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\n\nint DEBUG_LEVEL = 0;\nvoid print()(){ writeln(\"\"); }\nvoid print(T, A ...)(T t, lazy A a){ write(t), print(a); }\nvoid print(int level, T, A ...)(T t, lazy A a){ if(level <= DEBUG_LEVEL) print(t, a); }\n\nvoid main(string[] args){\n\tif(args.length > 1 && args[1] == \"-debug\"){\n\t\tif(args.length > 2 && args[2].isNumeric) DEBUG_LEVEL = args[2].to!int;\n\t\telse DEBUG_LEVEL = 1;\n\t}\n\t\n\tint n = read.to!int;\n\tlong a = read.to!long;\n\tlong b = read.to!long;\n\t\n\tint[] ps;\n\tforeach(i; 0 .. n) ps ~= read.to!int - 1;\n\tprint!1(\"ps:\", ps);\n\t\n\t// us[p]: pより左にある、pより大きい最小の数\n\tint[] us = new int[](n);\n\tforeach(i; 0 .. n){\n\t\tint u = n * 2;\n\t\tforeach(j; 0 .. i) if(ps[j] > ps[i] && ps[j] < u) u = ps[j];\n\t\tus[ps[i]] = u;\n\t}\n\tprint!1(\"us:\", us);\n\t\n\t// vs[p]: pより右にある、pより小さい最大の数\n\tint[] vs = new int[](n);\n\tforeach(j; 0 .. n){\n\t\tint v = -1;\n\t\tforeach(i; j + 1 .. n) if(ps[i] < ps[j] && ps[i] > v) v = ps[i];\n\t\tvs[ps[j]] = v;\n\t}\n\tprint!1(\"vs:\", vs);\n\t\n\t// xs[i][j]: 0 .. i を左に、j .. n を右に寄せる最小のコスト\n\tlong[][] xs = new long[][](n + 1, n + 1);\n\tforeach(i; 0 .. n + 1) foreach_reverse(j; i .. n + 1){\n\t\tprint!1(\"i:\", i, \" j:\", j, \" xs:\", xs);\n\t\tif(i == 0 && j == n) xs[i][j] = 0;\n\t\telse if(i == 0) xs[i][j] = xs[i][j + 1] + ((vs[j] <= -1)? 0: a);\n\t\telse if(j == n) xs[i][j] = xs[i - 1][j] + ((us[i - 1] >= n)? 0: b);\n\t\telse xs[i][j] = min(\n\t\t\txs[i][j + 1] + ((vs[j] <= i - 1)? 0: a),\n\t\t\txs[i - 1][j] + ((us[i - 1] >= j)? 0: b)\n\t\t\t);\n\t}\n\tprint!1(\"xs:\", xs);\n\t\n\t// xs[i][i]のうちで最小のものを探す\n\tlong ans = a * n + b * n;\n\tforeach(i; 0 .. n + 1) if(xs[i][i] < ans) ans = xs[i][i];\n\t\n\tans.writeln;\n\t\n}\n\n/*\n\nローテーションと言っているのは要素を取って別の場所に挿入する操作\n同じ要素に対して2回行うことは無駄なので、高々1回しか行わない\n\n左へ移動して左からソートしていくか、右へ移動して右からソートしていくか\n最終形としては、ある位置より左は左へ移動してソートした要素たち\n同じ位置より右は右へ移動してソートした要素たち　という状態になるはず\n\nただし、元からソートされていて移動しなくてすむ要素というのがある\n「自分は、いくつまでが右へソートされたら左へソートしなくてすむのか」\n「自分は、いくつまでが左へソートされたら右へソートしなくてすむのか」\nをあらかじめ考えておく\n\nたとえばこの入力例5では\n> 9 40 50\n> 5 3 4 7 6 1 2 9 8\n\n3は、\n　もし5が右へ移動することになったなら自分は左へは移動する必要がない\n　もし1と2が左へ移動することになったなら自分は右へは移動する必要がない\n7は、\n　どんな場合にも左へ移動する必要がない\n　もし1と2と6が左へ移動することになったなら自分は右へは移動する必要がない\n\nこれは\n　自分より左にある、自分より大きい最小の数\n　自分より右にある、自分より小きい最大の数\n\nを調べるということ\n（N=5000なのでこれを求めるのは二重ループで良い）\n\nその上で\n　「0 .. iを左へ、j .. nを右へソートする場合のコスト」をDPで求める\n　（求めるものは　min(i) x[i][i]　）\n\niより左にある、iより大きい最小の数 u[i]\njより右にある、jより小きい最大の数 v[j]\ni以下を左へ、j以上を右へソートする場合のコスト x[i][j]\n\nx[0][n] = 0\nx[0][j] = x[i][j + 1] + (v[j] < i - 1? 0: A)\nx[i][n] = x[i - 1][j] + (u[i - 1] > j? 0: B)\nx[i][j] = min(\n x[i][j + 1] + (v[j] < i - 1? 0: A),\n x[i - 1][j] + (u[i - 1] > j? 0: B)\n )\n\n*/\n"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define ll            long long\n#define pb            emplace_back\n#define fi            first\n#define se            second\n#define mp            make_pair\n//#define int           int64_t\n\nusing namespace std;\n\ntypedef pair<ll, int> pii;\nconst int N = (int)5e3 + 5;\nconst ll inf = (ll)1e18;\n\nint n, A, B, a[N], pos[N];\nll f[N][N], mn;\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    #define FileName      \"test\"\n    if(fopen(FileName\".inp\", \"r\")) {\n       freopen(FileName\".inp\", \"r\", stdin);\n       freopen(FileName\".out\", \"w\", stdout);\n    }\n    cin >> n >> A >> B;\n    fill_n(&f[0][0], N * N, inf);\n    for(int i = 1; i <= n; ++i) cin >> a[i], pos[a[i]] = i - 1;\n    ///(0, 1], (1, 2], (2, 3], ..., (n - 1, n], (n, n + 1]\n    ///to the right A, to the left B\n    for(int i = 0; i <= n; ++i) f[1][i] = (i == pos[1]? 0: (i < pos[1]? B: A));\n    for(int i = 2; i <= n; ++i) { /// f(i, j) = sort 1 -> i, pos(i) in range (j, j + 1]\n        mn = inf;\n        for(int j = 0; j <= n; ++j) {\n            /// f(i, j) min f(i - 1, k) k < j\n            mn = min(mn, f[i - 1][j]);\n            f[i][j] = mn + (j == pos[i]? 0: (j < pos[i]? B: A));\n        }\n    }\n    cout << *min_element(f[n], f[n] + n + 1);\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\n/*\n    the problem is:\n        insert p[l] after position r cost A if l < r\n        else cost B\n    does the order of operators matter?\n    dp[i][last] -> sort all 1 2 3 ... i and the last time move the current permultation is last\n    how to insert i+1:\n        use cost A or B to move i+1 after i\n        use i * (cost B or A) to move (1...i) before i+1\n*/\nusing namespace std;\n#ifdef LDT\nconst int maxn = 50;\n#else\nconst int maxn = 5005;\n#endif\nint n, A, B;\nint p[maxn];\nint pos[maxn];\nlong long f[maxn][maxn];\nint best[maxn][maxn];\nint s[maxn][maxn];\nvoid optimize(long long &x, long long a) {\n    if (x > a) x = a;\n}\nint main() {\n#ifdef LDT\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> n >> A >> B;\n    for (int i = 1; i <= n; ++i)\n        cin >> p[i];\n    for (int i = 1; i <= n; ++i)\n        pos[p[i]] = i;\n    for (int i = 1; i <= n; ++i) {\n        best[i][i] = p[i];\n        for (int j = i + 1; j <= n; ++j)\n            best[i][j] = max(best[i][j - 1], p[j]);\n        s[i][0] = 0;\n        for (int j = 1; j <= n; ++j)\n            s[i][j] = s[i][j - 1] + (p[j] > i);\n    }\n    memset(f, 63, sizeof(f));\n    f[1][pos[1]] = 0;\n    for (int i = 1; i <= n; ++i) \n        for (int l = 1; l <= n; ++l) {\n            int nxt = pos[i + 1];\n            if (l < nxt && best[l][nxt] <= i + 1) {\n                optimize(f[i + 1][l], f[i][l]);\n                optimize(f[i + 1][nxt], f[i][l]);\n            }\n            else if (nxt < l) {\n                //move i + 1 after (1..i)\n                optimize(f[i + 1][l], f[i][l] + A);\n                //move (1..i) before i + 1\n                optimize(f[i + 1][nxt], f[i][l] + 1ll * i *  B);\n\n            }\n            else {\n                optimize(f[i + 1][l], f[i][l] + \n                    min(1ll * B, 1ll * A * (s[i][nxt - 1] - s[i][l])));\n                \n                optimize(f[i + 1][nxt], f[i][l] + 1ll * i *  A);\n            }\n        }\n    cout << *min_element(f[n] + 1, f[n] + 1 + n);\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define inf 9982443530000000\n#define maxn 5001\n#define int long long\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint n, A, B, a[maxn], b[maxn], pos[maxn], ans = inf, dp[maxn][maxn];\nsigned main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn = read(); A = read(); B = read();\n\tfor(int i = 1; i <= n; i++) a[i] = read(), pos[a[i]] = i;\n\tmemset(dp, 0x3f3f3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < i; j++)\n\t\t{\n\t\t\tif(pos[i] > pos[j]) {\n\t\t\t\tdp[i][i] = min(dp[i - 1][j], dp[i][i]);\n\t\t\t\tdp[i][j] = dp[i - 1][j] + B;\n\t\t\t}\n\t\t\telse dp[i][j] = dp[i - 1][j] + A;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) ans = min(ans, dp[n][i]);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 5e3 + 5;\nconst int maxm = 1e7 + 5;\n\nconst int mod = 1e9 + 7;\nint n , A , B;\nint pos[maxn] , a[maxn];\nint m = 0;\nll f[maxn][maxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\"))\n        freopen(taskname\".INP\",\"r\",stdin),\n        freopen(taskname\".OUT\",\"w\",stdout);\n    cin >> n >> A >> B;\n    for(int i = 1 ; i <= n ; ++i){\n        cin >> a[i];\n        pos[a[i]] = i;\n    }\n    memset(f,123,sizeof  f);\n    f[1][0] = 0;\n    ll res = 1e18;\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = 0 ; j < i ; ++j){\n            if(pos[i] > pos[j]){\n                f[i + 1][j] = min(f[i + 1][j] , f[i][j] + B);\n                f[i + 1][i] = min(f[i][j] , f[i + 1][i]);\n            }else{\n                f[i + 1][j] = min(f[i + 1][j] , f[i][j] + A);\n            }\n        }\n    }\n    cout << *min_element(f[n+1],f[n+1]+n);\n}\n\n"
  },
  {
    "language": "Nim",
    "code": "import algorithm\nimport future\nimport macros\nimport math\nimport queues\nimport sequtils\nimport sets\nimport strutils\nimport tables\n\nconst INF* = int(1e18 + 373)\n\nproc readLine*(): string =\n  stdin.readLine().strip()\nproc readSeq*(): seq[string] =\n  readLine().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeqWith(n, readLine())\nproc readIntSeq*(): seq[int] =\n  result = readSeq().map(parseInt)\nproc readIntSeq*(n: Natural): seq[int] =\n  result = readSeq(n).map(parseInt)\nproc readInt1*(): int =\n  readLine().parseInt()\nproc readInt2*(): (int, int) =\n  let a = readIntSeq(); return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readIntSeq(); return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readIntSeq(); return (a[0], a[1], a[2], a[3])\n\nproc newSeqOf*[T](n: Natural; e: T): seq[T] =\n  result = newSeq[T](n)\n  result.fill(e)\nproc newSeq*[T](n: Natural; e: T): seq[T] =\n  newSeqOf[T](n, e)\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] =\n  newSeqOf(n1, newSeq[T](n2))\nproc newSeq2*[T](n1, n2: Natural; e: T): seq2[T] =\n  newSeqOf(n1, newSeqOf(n2, e))\ntype seq3*[T] = seq[seq[seq[T]]]\nproc newSeq3*[T](n1, n2, n3: Natural): seq3[T] =\n  newSeqOf(n1, newSeqOf(n2, newSeq[T](n3)))\nproc newSeq3*[T](n1, n2, n3: Natural; e: T): seq3[T] =\n  newSeqOf(n1, newSeqOf(n2, newSeqOf(n3, e)))\n\nwhen defined(ENABLE_DEBUG_MACRO):\n  macro debug*(args: varargs[untyped]): untyped =\n    result = nnkStmtList.newTree()\n    for i in 0..<args.len():\n      let par1 = newIdentNode(\"stderr\")\n      let par2 = newLit(args[i].repr)\n      let par3 = newLit(\" = \")\n      let par4 = args[i]\n      result.add(newCall(\"write\", par1, par2, par3, par4))\n      if i + 1 < args.len():\n        result.add(newCall(\"write\", newIdentNode(\"stderr\"), newLit(\", \")))\n    result.add(newCall(\"writeLine\", newIdentNode(\"stderr\"), newLit(\"\")))\nelse:\n  macro debug*(args: varargs[untyped]): untyped =\n    result = nnkDiscardStmt.newTree(newLit(nil))\n\n#------------------------------------------------------------------------------#\n#------------------------------------------------------------------------------#\n# RIGHT: A\n# LEFT: B\nproc solve(p, ind: seq[int]; a, b, i, j: int; dp: var seq2[int]): int =\n  if dp[i][j] != -1:\n    return dp[i][j]\n\n  if i >= p.len():\n    return 0\n\n  if ind[i] < j:\n    dp[i][j] = a + solve(p, ind, a, b, i + 1, j, dp)\n    return dp[i][j]\n\n  let solL = b + solve(p, ind, a, b, i + 1, j, dp)\n  let keep = solve(p, ind, a, b, i + 1, max(j, ind[i]), dp)\n  let res = min(solL, keep)\n  dp[i][j] = res\n  return res\n\nproc main() =\n  let (n, a, b) = readInt3()\n  let p = readIntSeq().map(it => it - 1)\n  var ind = newSeq[int](n)\n  for i in 0..<n:\n    ind[p[i]] = i\n\n  var dp = newSeq2[int](n + 1, n + 1, -1)\n  echo solve(p, ind, a, b, 0, 0, dp)\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\nvar N:int\nvar A:int\nvar B:int\nvar p:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  A = nextInt()\n  B = nextInt()\n  p = newSeqWith(N, nextInt())\n#}}}\n\nproc main() =\n  dp := newSeqWith(N + 1, int.inf)\n  dp[0] = 0\n  for i in 0..<N:\n    dp2 := newSeqWith(N + 1, int.inf)\n    for prev in 0..<N:\n      if dp[prev] == int.inf: continue\n      if prev < p[i]:\n        # stay\n        dp2[p[i]].min=dp[prev]\n        # go right\n        dp2[prev].min=dp[prev] + A\n      elif prev > p[i]:\n        # cannot stay\n        # go left\n        dp2[prev].min=dp[prev] + B\n        # cannot go right\n      else:\n        doassert false\n    swap(dp, dp2)\n  print dp.min\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\nvar N:int\nvar A:int\nvar B:int\nvar p:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  A = nextInt()\n  B = nextInt()\n  p = newSeqWith(N, nextInt())\n#}}}\n\nproc main() =\n  dp := newSeqWith(N + 1, int.inf)\n  dp[0] = 0\n  for i in 0..<N:\n    dp2 := newSeqWith(N + 1, int.inf)\n    for prev in 0..N:\n      if dp[prev] == int.inf: continue\n      if prev < p[i]:\n        # stay\n        dp2[p[i]].min=dp[prev]\n        # go right\n        dp2[prev].min=dp[prev] + A\n      elif prev > p[i]:\n        # cannot stay\n        # go left\n        dp2[prev].min=dp[prev] + B\n        # cannot go right\n      else:\n        doassert false\n    swap(dp, dp2)\n  print dp.min\n  return\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n\n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n\n    def bfs(self, s):\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, rev in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n\n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, float('inf'))\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, float('inf'))\n\n\nn, a, b = map(int, input().split())\naaa = list(map(int, input().split()))\nmf = Dinic(2 * n + 2)\nt = 2 * n + 1\nfor i in range(1, n + 1):\n    mf.add_link(0, i, b)\n    mf.add_link(n + i, t, a)\nINF = 10 ** 18\nfor i in range(n):\n    r = aaa[i]\n    for l in reversed(aaa[:i]):\n        if l > r:\n            mf.add_link(r, l + n, INF)\n        if l + 1 == r:\n            mf.add_link(r, l, INF)\n            break\nprint(mf.max_flow(0, t))\n"
  },
  {
    "language": "Python",
    "code": "N,A,B=map(int,input().split())\np=list(map(int,input().split()))\np=[p[i]-1 for i in range(N)]\n\ndp=[[0 for i in range(N+1)] for j in range(N)]\n\nfor j in range(N+1):\n    if p[0]<=j:\n        dp[0][j]=0\n    else:\n        dp[0][j]=A\n\nfor i in range(1,N):\n    for j in range(N+1):\n        if p[i]<=j:\n            dp[i][j]=min(dp[i-1][p[i]],dp[i-1][j]+B)\n        else:\n            dp[i][j]=dp[i-1][j]+A\n\nprint(dp[-1][N])\n"
  },
  {
    "language": "Python",
    "code": "from functools import*\n@lru_cache(None)\ndef solve(p):\n    print(p)\n    if len(p)<2:\n        return 0\n    i=p.index(max(p))\n    return min(solve(t(p[:i]))+(len(p)-1-i)*b,solve(t(p[:i]+p[i+1:]))+a)\nn,a,b,*p=map(int,open(0).read().split())\nt=tuple\nprint(solve(t(p)))"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(itemgetter(0), sorted(enumerate(ppp, start=1), key=itemgetter(1))))\nINF = 10 ** 15\n\nprint(qqq)\n\n# dp = {0: 0}\n# for i in qqq:\n#     ndp = {}\n#     tmp_min_cost = INF\n#     stay_min_cost = INF\n#     for j, cost in sorted(dp.items()):\n#         if j <= i:\n#             if j < i:\n#                 stay_min_cost = min(stay_min_cost, cost)\n#             cost += b\n#             if tmp_min_cost > cost:\n#                 ndp[j] = tmp_min_cost = cost\n#         else:\n#             cost += a\n#             if tmp_min_cost > cost:\n#                 ndp[j] = tmp_min_cost = cost\n#     if stay_min_cost < INF:\n#         ndp[i] = min(ndp[i], stay_min_cost) if i in ndp else stay_min_cost\n#     dp = ndp\n#\n# print(min(dp.values()))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n\n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n\n    def bfs(self, s):\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, rev in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n\n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, float('inf'))\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, float('inf'))\n\n\nn, a, b = map(int, input().split())\naaa = list(map(int, input().split()))\nmf = Dinic(2 * n + 2)\nt = 2 * n + 1\nfor i in range(1, n + 1):\n    mf.add_link(0, i, b)\n    mf.add_link(n + i, t, a)\nINF = 10 ** 18\nfor i in range(n):\n    r = aaa[i]\n    for l in reversed(aaa[:i]):\n        if l > r:\n            mf.add_link(r, l + n, INF)\n        if l + 1 == r:\n            mf.add_link(r, l + n, INF)\n            break\nprint(mf.max_flow(0, t))\n"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\np = list(map(int, input().split()))\nq = [0] * n\nfor i, x in enumerate(p):\n    q[x - 1] = i\ndp = [[0] * (n + 1) for _ in range(n + 1)]\nmi = [[n] * (n + 1) for _ in range(n + 1)]\nma = [[0] * (n + 1) for _ in range(n + 1)]\nfor i in range(n + 1):\n    for j in range(i + 1, n + 1):\n        mi[i][j] = min(mi[i][j - 1], q[j - 1])\n        ma[i][j] = max(ma[i][j - 1], q[j - 1])\nfor i in range(1, n + 1):\n    for j in range(i + 1):\n        k = i - j\n        s, t = 1, 1\n        if j > 0 and j == p[mi[j - 1][n - k]]:\n            s = 0\n        if k > 0 and n - k + 1 == p[ma[j][n - k + 1]]:\n            t = 0\n        if j == 0:\n            dp[j][k] = dp[j][k - 1] + a * t\n        elif k == 0:\n            dp[j][k] = dp[j - 1][k] + b * s\n        else:\n            dp[j][k] = min(dp[j - 1][k] + b * s, dp[j][k - 1] + a * t)\nans = float('inf')\nfor i in range(n + 1):\n    ans = min(ans, dp[i][n - i])\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(itemgetter(0), sorted(enumerate(ppp, start=1), key=itemgetter(1))))\nINF = 10 ** 15\n\ndp = {0: 0}\nfor i in qqq:\n    ndp = {}\n    tmp_min_cost = INF\n    stay_min_cost = INF\n    for j, cost in sorted(dp.items()):\n        if j <= i:\n            if j < i:\n                stay_min_cost = min(stay_min_cost, cost)\n            cost += b\n            if tmp_min_cost > cost:\n                ndp[j] = tmp_min_cost = cost\n        else:\n            cost += a\n            if tmp_min_cost > cost:\n                ndp[j] = tmp_min_cost = cost\n    if stay_min_cost < INF:\n        ndp[i] = min(ndp[i], stay_min_cost) if i in ndp else stay_min_cost\n    dp = ndp\n\nprint(min(dp.values()))\n"
  },
  {
    "language": "Python",
    "code": "N, A, B = map(int, input().split())\nP = list(map(int, input().split()))\nPmin = [None]*N\nPmax = [None]*N\nfor i, p in enumerate(P):\n    k = 10000\n    for pj in P[:i]:\n        if pj > p:\n            k = min(k, pj)\n    Pmin[p-1] = k\n\nfor i, p in enumerate(P):\n    k = -1\n    for pj in P[:i:-1]:\n        if pj < p:\n            k = max(k, pj)\n    Pmax[p-1] = k\ndp = [[10**15]*(N+2) for _ in range(N+2)]\ndp[1][N] = 0\nfor k in range(N-1, -1, -1):\n    for i in range(1, N - k + 1):\n        x = dp[i][i+k]\n        if Pmax[i+k-1] + 1 <= i:\n            dp[i][i+k-1] = min(dp[i][i+k-1], x)\n        else:\n            dp[i][i+k-1] = min(dp[i][i+k-1], x+A)\n        if Pmin[i-1] - 1 >= i+k:\n            dp[i+1][i+k] = min(dp[i+1][i+k], x)\n        else:\n            dp[i+1][i+k] = min(dp[i+1][i+k], x+B)\nprint(min([dp[i][i] for i in range(1, N+1)]))"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\n\nn, a, b = map(int, input().split())\np = list(map(int, input().split()))\np.append(n+1)\np.insert(0,0)\n#'''\n#print (p)\n\nINF = (a+b)*n\nmin_ans =INF   # 仮のmin値\n\n# l-shift で　右端を整列する\ndef ptr_l_shift(p, cost, l, r):\n    for i in range(l, r+1):\n        if p[i] == r :\n            if r == i:\n                return (0 + solve(p, cost, l, r-1))\n            # l_shift(l, r)\n            p =    p[0:i] +p[i+1:r+1] +p[i:i+1] +p[r+1:]\n            ret = solve(p, cost, l, r-1)\n            p =    p[0:i] +p[r:r+1] +p[i:r] +p[r+1:]\n            return (a + ret)\n#    print(\"error l_shift\", p,l,r)\n\n\n# r-shift で　左端を整列する\ndef ptr_r_shift(p, cost, l, r) :\n    for i in range(l, r+1):\n        if p[i] == l :\n            if i == l :\n                return (0 + solve(p, cost, l+1, r))\n            # r_shift(i, j)\n            p =    p[0:l] +p[i:i+1] +p[l:i] +p[i+1:]\n            ret = solve(p, cost, l+1, r)\n            p =    p[0:l] +p[l+1:i+1] +p[l:l+1] +p[i+1:]\n            return (b + ret)\n#    print(\"error r_shift\", p,l,r)\n\ndef solve(p, cost, ptr_l, ptr_r):\n    global min_ans \n    if cost >= min_ans :\n        return (INF)\n\n    if ptr_l == ptr_r :\n        if cost < min_ans :\n            min_ans = cost\n        return (0)\n\n    if a < b :    # コストの小さい方を優先する\n        ll = ptr_l_shift(p, cost, ptr_l, ptr_r) \n        rr = ptr_r_shift(p, cost, ptr_l, ptr_r) \n    else:\n        rr = ptr_r_shift(p, cost, ptr_l, ptr_r) \n        ll = ptr_l_shift(p, cost, ptr_l, ptr_r) \n\n#    print (\"return ll, rr =\", ll, rr)\n    if ll > rr :\n#        if rr < min_ans :\n#            min_ans = rr\n        return (rr)\n    else :\n#        if ll < min_ans :\n#            min_ans = ll\n        return (ll)\n\ncost = 0\nprint (solve(p, cost, 1, n))"
  },
  {
    "language": "Python",
    "code": "import bisect\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nfor i in qqq:\n    ndp = []\n    app = ndp.append\n    tmp_min_cost = INF\n    stay_min_cost = INF\n    for j, cost in dp:\n        if j <= i:\n            if j < i:\n                stay_min_cost = cost\n            cost += b\n        else:\n            cost += a\n        if tmp_min_cost > cost:\n            app((j, cost))\n            tmp_min_cost = cost\n    if stay_min_cost < INF:\n        bisect.insort(ndp, (i, stay_min_cost))\n    dp = ndp\n\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nN, A, B = map(int, readline().split())\nP = list(map(int, readline().split()))\n\nINF = 1<<64\n\ndp = [INF]*(N+1)\ndp[0] = 0\n\nfor i in range(N):\n    p = P[i]\n    dp2 = [INF]*(N+1)\n    for j in range(N+1):\n        if p < j:\n            dp2[j] = dp[j] + B\n        if j < p:\n            dp2[p] = min(dp2[p], dp[j])\n            dp2[j] = dp[j] + A\n    dp = dp2\nprint(min(dp))"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nN,A,B,*P=map(int,open(0).read().split())\ndp=np.full(N+1,10**18,np.int64)\ndp[0]=0\nfor p in P:\n    dp[p]=min(dp[:p])\n    dp[p+1:]+=B\n    dp[:p]+=A\nprint(min(dp))"
  },
  {
    "language": "Python",
    "code": "N, A, B = map(int, input().split())\nP = list(map(int, input().split()))\nPmin = [None]*N\nPmax = [None]*N\nfor i, p in enumerate(P):\n    k = 20000\n    for pj in P[:i]:\n        if pj > p:\n            k = min(k, pj)\n    Pmin[p-1] = k\n\nfor i, p in enumerate(P):\n    k = -1\n    for pj in P[:i:-1]:\n        if pj < p:\n            k = max(k, pj)\n    Pmax[p-1] = k\ndp = [[10**15]*(N+2) for _ in range(N+2)]\ndp[1][N] = 0\nfor k in range(N-1, -1, -1):\n    for i in range(1, N - k + 1):\n        x = dp[i][i+k]\n        if Pmax[i+k-1] + 1 <= i:\n            dp[i][i+k-1] = min(dp[i][i+k-1], x)\n        else:\n            dp[i][i+k-1] = min(dp[i][i+k-1], x+A)\n        if Pmin[i-1] - 1 >= i+k:\n            dp[i+1][i+k] = min(dp[i+1][i+k], x)\n        else:\n            dp[i+1][i+k] = min(dp[i+1][i+k], x+B)\nprint(min([dp[i][i] for i in range(1, N+1)]))"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [0] * n\nfor i, p in enumerate(ppp, start=1):\n    qqq[p - 1] = i\n\ndp = [(0, 0)]\nfor i in qqq:\n    s = bisect(dp, (i,))\n    ndp = [(j, cost + b) for j, cost in dp[:s]]\n    stay_cost = dp[s - 1][1]\n    ndp.append((i, stay_cost))\n    ndp.extend((j, cost + a) for j, cost in dp[s:] if stay_cost > cost + a)\n    dp = ndp\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\ndp = [2 ** 60] * (n + 1)\ndp[0] = 0\np = list(map(int, input().split()))\nfor i in range(n):\n    dp[i + 1] = dp[0]\n    dp[0] += a\n    for j in range(i):\n        if p[j] < p[i]:\n            dp[i + 1] = min(dp[i + 1], dp[j + 1])\n            dp[j + 1] += a\n        else:\n            dp[j + 1] += b\nprint(min(dp))"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\nsys.setrecursionlimit(1000000)\n\n#A\ndef A():\n    n = I()\n    b = LI()\n    ans = []\n    d = max(b)\n    i = 0\n    while b:\n        j = len(b)-1\n        while j >= 0:\n            if b[j] > j+1:\n                print(-1)\n                quit()\n            elif b[j] == j+1:\n                ans.append(b[j])\n                b.pop(j)\n                break\n            j -= 1\n    for i in ans[::-1]:\n        print(i)\n#B\ndef B():\n    n = I()\n    if n%2:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n    else:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n+1-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n#C\ndef C():\n    return\n\n#D\ndef D():\n    n,a,b = LI()\n    pf = LI()\n    f_ans = float(\"inf\")\n    l = [pf[i] for i in range(n)]\n    l.sort()\n    f = defaultdict(int)\n    for i in pf:\n        f[i] = l.index(i)\n    for _ in range(2):\n        p = [pf[i] for i in range(n)]\n        ans = 0\n        while l != p:\n            d = []\n            i = 0\n            while i < n:\n                j = i\n                while j < n-1:\n                    if f[p[j+1]] != f[p[j]]+1:break\n                    j += 1\n                d.append(p[i:j+1])\n                i = j+1\n            m = len(d)\n            ld = [d[i] for i in range(m)]\n            ld.sort()\n            fd = defaultdict(int)\n            for i in d:\n                fd[str(i)] = ld.index(i)\n            if _ == 0:\n                for i in range(m)[::-1]:\n                    if d[i] != ld[i]:\n                        j = fd[str(d[i])]\n                        x = d[i]\n                        if j > i:\n                            k = 0\n                            for o in range(i+1,j+1):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(b*k,a*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n                        else:\n                            k = 0\n                            for o in range(j,i):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(a*k,b*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n            else:\n                for i in range(m)[::-1]:\n                    if d[i] != ld[i]:\n                        j = fd[str(d[i])]\n                        x = d[i]\n                        if j > i:\n                            k = 0\n                            for o in range(i+1,j+1):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(b*k,a*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n                        else:\n                            k = 0\n                            for o in range(j,i):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(a*k,b*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n            p = [None for i in range(n)]\n            s = 0\n            for i in range(len(d)):\n                for j in range(len(d[i])):\n                    p[s+j] = d[i][j]\n                s += len(d[i])\n        f_ans = min(f_ans,ans)\n    print(f_ans)\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    D()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    from functools import lru_cache\n    import sys\n    sys.setrecursionlimit(10**9)\n    @lru_cache(None)\n    def solve(p):\n        if len(p)<2:\n            return 0\n        j=i[len(p)]\n        return min(solve(t(p[:j]))+(len(p)-1-j)*b,solve(t(p[:j]+p[j+1:]))+a)\n    n,a,b,*p=map(int,open(0).read().split())\n    i=[0]*-~n\n    for j,v in enumerate(p):\n        i[v]=j-sum(t>v for t in p[:j])\n    t=tuple\n    print(solve(t(p)))\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n\n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n\n    def bfs(self, s):\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, rev in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n\n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, float('inf'))\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, float('inf'))\n\n\nn, a, b = map(int, input().split())\naaa = list(map(int, input().split()))\nmf = Dinic(2 * n + 2)\nt = 2 * n + 1\nfor i in range(1, n + 1):\n    mf.add_link(0, i, b)\n    mf.add_link(n + i, t, a)\nINF = 10 ** 18\ncompleted = [False] * (n + 1)\nfor i in range(n):\n    r = aaa[i]\n    for l in reversed(aaa[:i]):\n        if l > r:\n            mf.add_link(r, l + n, INF)\n        if l + 1 == r:\n            mf.add_link(r, l, INF)\n            break\nprint('Time for Construct Graph')  # Test\nexit()\nprint(mf.max_flow(0, t))\n"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\ndp = [2 ** 60] * (n + 1)\ndp[0] = 0\np = list(map(int, input().split()))\nfor i in range(n):\n    dp[i + 1] = dp[0]\n    dp[0] += a\n    for j in range(i):\n        if p[j] < p[i]:\n            dp[i + 1] = min(dp[i + 1], dp[j + 1])\n            dp[j + 1] += a\n        else:\n            dp[j + 1] += b\nprint(min(dp))"
  },
  {
    "language": "Python",
    "code": "N,A,B=map(int,input().split())\nP=[int(i) for i in input().split()]\ns=1e19\nd=[s]*(N+1)\nd[0]=0\nfor i in range(N):\n    e=[s]*(N+1)\n    for j in range(N+1):\n        if j < P[i]:\n            e[P[i]]=min(e[P[i]],d[j])\n            e[j]=min(e[j],d[j]+A)\n        else:\n            e[j]=min(e[j],d[j]+B)\n    d=e\nprint(min(d))\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nfor i in qqq:\n    ndp = []\n    s = bisect(dp, (i,))\n    tmp_min = INF\n    for j, cost in dp[:s]:\n        cost += b\n        ndp.append((j, cost))\n        tmp_min = cost\n    stay_cost = dp[s - 1][1]\n    if tmp_min > stay_cost:\n        ndp.append((i, stay_cost))\n        tmp_min = stay_cost\n    for j, cost in dp[s:]:\n        cost += a\n        if tmp_min > cost:\n            ndp.append((j, cost))\n            tmp_min = cost\n    dp = ndp\n\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "def rotation_sort(N: int, A: int, B: int, P: list) -> int:\n    # x0[v] = v の P 内での初期位置\n    x0 = {v: i for i, v in enumerate(P)}\n\n    # dp[k][x] = k が x0[k] から開区間 (x-1, x) に移動するときの最小コスト\n    # k が (x-1, x) に移動する際の最小コストは x0->(x-1, x) の移動コストを\n    # C とすると\n    # dp[k][x] = min(dp[k-1][0], ..., dp[k-1][x])\n    dp = [[float('inf')] * (N+1) for _ in range(N+1)]\n    dp[0] = [0] * (N+1)\n\n    for k in range(1, N+1):\n        # 要素 k-1 が (-inf, x+1) へ移動するための最小コスト\n        min_prev = float('inf')\n        for x in range(N+1):\n            if x == x0[k]:\n                # 移動なし\n                cost = 0\n            elif x < x0[k]:\n                # 左移動\n                cost = B\n            else:\n                # 右移動\n                cost = A\n            min_prev = min(min_prev, dp[k-1][x])\n            dp[k][x] = min_prev + cost\n\n    return min(dp[N])\n\n\nif __name__ == \"__main__\":\n    N, A, B = map(int, input().split())\n    P = [int(s) for s in input().split()]\n\n    ans = rotation_sort(N, A, B, P)\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\n### 方針\n### ソートの実行時間は最大でもN^2 / 2で収まるはず\n### 1から順番にソートをしようとすると最小試行回数を満たせない\n### 本来の場所からの距離を探索し、遠い+昇順で選択\n### 本来の数列ではなく、本来の場所からの距離を計算し、距離だけでソートを計算する\n\ndef turn_Left(c,start,end):\n    if (end - start > 1):\n        target_num=c[start]+end-start\n        for i in range(start,end):\n            c[i] = c[i+1] - 1\n        c[end] = target_num\n    else:\n        c[start]=0\n        c[end]=0\n    return c\n\ndef turn_Right(c,start,end):\n    if (end - start > 1):\n        target_num=c[end]-end+start\n        for i in reversed(range(start+1,end+1)):\n            c[i] = c[i-1] + 1\n        c[start] = target_num\n    else:\n        c[start]=0\n        c[end]=0\n    return c\n\ndef AtCoder_d(c,c_left,c_right):\n    if (abs(max(c)) > abs(min(c))):\n        if (max(c)*c_left > c_right ):\n            cost = c_right\n            c = turn_Right(c,np.argmax(c)-max(c),np.argmax(c))\n        else:\n            cost = c_left\n            c = turn_Left(c,np.argmax(c)-max(c),np.argmax(c))\n    else:\n        if (abs(min(c))*c_right > c_left ):\n            cost = c_left\n            c = turn_Left(c,np.argmin(c),np.argmin(c)+abs(min(c)))\n        else:\n            cost = c_right\n            c = turn_Right(c,np.argmin(c),np.argmin(c)+abs(min(c)))\n    return c,cost\n\nif __name__ == '__main__':\n    # 標準入力を受け取る\n    a = list(map(int,input().split()))\n    b = list(map(int,input().split()))\n    # a[0]：N、a[1]：左に移動するコスト、a[2]:右に移動するコスト\n    c=[0]*a[0]\n    c_left=a[1]\n    c_right=a[2]\n    # 本来の位置(正しい順列状態)との各数字の距離を計算\n    for i in range(a[0]):\n        c[i]=i + 1 - b[i]\n    #cost初期化\n    cost=0\n    #既に昇順に並んでいる場合を弾きつつ、ソート開始\n    while True:\n        if ( max(c) == 0 and min(c) == 0 ):\n            break\n        result = AtCoder_d(c,c_left,c_right)\n        c = result[0]\n        cost = cost + result[1]\n    print(cost)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(itemgetter(0), sorted(enumerate(ppp, start=1), key=itemgetter(1))))\n\ndp = {0: 0}\nfor i in qqq:\n    ndp = defaultdict(lambda: 10 ** 18)\n    for j, cost in dp.items():\n        if j < i:\n            ndp[i] = min(ndp[i], cost)\n            ndp[j] = min(ndp[j], cost + b)\n        else:\n            ndp[j] = min(ndp[j], cost + a)\n    dp = ndp\n\nprint(min(dp.values()))\n"
  },
  {
    "language": "Python",
    "code": "# AGC032 Problem-D\n\nn, a, b = map(int, input().split())\n#global p \np = list(map(int, input().split()))\np.append(n+1)\np.insert(0,0)\n#print (p)\n\n# l-shift で　右端を整列する\ndef ptr_l_shift(p, l, r):\n    for i in range(l, r+1):\n        if p[i] == r :\n            if r == i:\n                return (0 + solve(p, l, r-1))\n            # l_shift(l, r)\n#            print (\"l_shift i=\", i, \"r=\",r)\n#            print (p[0:i], p[i:i+1], p[i+1:r+1], p[r+1:])\n            p =    p[0:i] +p[i+1:r+1] +p[i:i+1] +p[r+1:]\n#            print (p)\n            return (a + solve(p, l, r-1))\n#    print(\"error l_shift\", p,l,r)\n\n\n# r-shift で　左端を整列する\ndef ptr_r_shift(p, l, r) :\n    for i in range(l, r+1):\n        if p[i] == l :\n            if i == l :\n                return (0 + solve(p, l+1, r))\n            # r_shift(i, j)\n#            print (\"r_shift  l=\", l, \"i=\",i)\n#            print (p[0:l], p[l:i], p[i:i+1], p[i+1:])\n            p =    p[0:l] +p[i:i+1] +p[l:i] +p[i+1:]\n#            print (p)\n            return (b + solve(p, l+1, r))\n#    print(\"error r_shift\", p,l,r)\n\ndef solve(p, ptr_l, ptr_r):\n    if (ptr_l, ptr_r) in memo :\n        return (memo[ptr_l, ptr_r])\n\n    if ptr_l == ptr_r :\n        return (0)\n    \n    ll = ptr_l_shift(p[:], ptr_l, ptr_r) \n    rr = ptr_r_shift(p[:], ptr_l, ptr_r) \n#    print (\"return ll, rr =\", ll, rr)\n    if ll > rr :\n        memo[(ptr_l, ptr_r)] = rr\n        return (rr)\n    else :\n        memo[(ptr_l, ptr_r)] = ll\n        return (ll)\n\nmemo = {}\n\nprint (solve(p, 1, n))\n#print (\"ans =\", solve(p, 1, n))\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    class Bit:\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n\n    N, R, L = map(int, input().split())\n    P = list(map(int, input().split()))\n\n    val2idx = [0] * (N+1)\n    for i, p in enumerate(P):\n        val2idx[p] = i + 1\n    inf = 10**14\n    dp = [[inf] * (N+1) for _ in range(N+1)]\n    dp[0][0] = 0\n    bit = Bit(N+1)\n    for p in range(1, N+1):\n        i = val2idx[p]\n        for j in range(N+1):\n            if i > j:\n                dp[p][j] = min(dp[p][j], dp[p-1][j] + L)\n                dp[p][i] = min(dp[p][i], dp[p-1][j] + R * (i - j - 1 - (bit.sum(i) - bit.sum(j))))\n            else:\n                dp[p][j] = min(dp[p][j], dp[p - 1][j])\n        bit.add(i, 1)\n    print(min(dp[-1]))\n    #[print(i, dp[i]) for i in range(N+1)]\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nlist = []\na = []\nfor i in range(n):\n  list.append(int(input))\n\nfor i in range(1, n):\n  for j in range(1, i):\n    if list[i] == j:\n      a.insert(j, j)\n\nif a == list:\n  for i in range(n):\n    print(list[i])\nelse:\n  print(-1)"
  },
  {
    "language": "Python",
    "code": "#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n#define MAX_N 5000\n#define INF 0x3f3f3f3f\n\nlong dp[MAX_N + 1][MAX_N + 1];\nint x0[MAX_N + 1], P[MAX_N];\n\nlong rotation_sort( int N, int A, int B )\n{\n    for ( int i = 0; i < N; i++ ) x0[P[i]] = i;\n\n    memset( dp, INF, sizeof( dp ) );\n    memset( dp[0], 0, sizeof( dp[0] ) );\n\n    for ( int k = 1; k <= N; k++ )\n    {\n        long min_prev = INF;\n\n        for ( int x = 0; x <= N; x++ )\n        {\n            int cost;\n            if ( x == x0[k] )\n                cost = 0;\n            else if ( x < x0[k] )\n                cost = B;\n            else\n                cost = A;\n\n            min_prev = min( min_prev, dp[k - 1][x] );\n            dp[k][x] = min_prev + cost;\n        }\n    }\n\n    long ans = INF;\n    for ( auto v : dp[N] ) ans = min( ans, v );\n\n    return ans;\n}\n\nint main( int argc, char **argv )\n{\n    long N, A, B;\n    cin >> N >> A >> B;\n\n    for ( int i = 0; i < N; i++ ) cin >> P[i];\n\n    cout << rotation_sort( N, A, B ) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\nsys.setrecursionlimit(1000000)\n\n#A\ndef A():\n    n = I()\n    b = LI()\n    ans = []\n    d = max(b)\n    i = 0\n    while b:\n        j = len(b)-1\n        while j >= 0:\n            if b[j] > j+1:\n                print(-1)\n                quit()\n            elif b[j] == j+1:\n                ans.append(b[j])\n                b.pop(j)\n                break\n            j -= 1\n    for i in ans[::-1]:\n        print(i)\n#B\ndef B():\n    n = I()\n    if n%2:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n    else:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n+1-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n#C\ndef C():\n    return\n\n#D\ndef D():\n    n,a,b = LI()\n    p = LI()\n    ans = 0\n    l = [p[i] for i in range(n)]\n    l.sort()\n    f = defaultdict(int)\n    for i in p:\n        f[i] = l.index(i)\n    ans = 0\n    while l != p:\n        d = []\n        i = 0\n        while i < n:\n            j = i\n            while j < n-1:\n                if f[p[j+1]] != f[p[j]]+1:break\n                j += 1\n            d.append([p[i:j+1],i])\n            i = j+1\n        m = len(d)\n        ld = [d[i][0] for i in range(m)]\n        ld.sort()\n        fd = defaultdict(int)\n        for i,j in d:\n            fd[str(i)] = ld.index(i)\n        for i in range(m)[::-1]:\n            if d[i][0] != ld[i]:\n                j = fd[str(d[i][0])]\n                x = d[i]\n                if j > i:\n                    k = d[j][1]-d[i][1]\n                    p = len(d[i][0])\n                    ans += min(b*k,a*p)\n                    d.pop(i)\n                    d.insert(j,x)\n                    break\n                else:\n                    k = d[i][1]-d[j][1]\n                    p = len(d[i][0])\n                    ans += min(a*k,b*p)\n                    d.pop(i)\n                    d.insert(j,x)\n                    break\n        p = [None for i in range(n)]\n        s = 0\n        for i in range(m):\n            for j in range(len(d[i][0])):\n                p[s+j] = d[i][0][j]\n            s += len(d[i][0])\n    print(ans)\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    D()\n"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\np = list(map(int, input().split()))\nq = [0] * n\nfor i, x in enumerate(p):\n    q[x - 1] = i\ndp = [[0] * (n + 1) for _ in range(n + 1)]\nmi = [[float('inf')] * (n + 1) for _ in range(n + 1)]\nma = [[0] * (n + 1) for _ in range(n + 1)]\nfor i in range(n + 1):\n    for j in range(i + 1, n + 1):\n        mi[i][j] = min(mi[i][j - 1], q[j - 1])\n        ma[i][j] = max(ma[i][j - 1], q[j - 1])\nfor i in range(1, n + 1):\n    for j in range(i + 1):\n        k = i - j\n        s, t = 1, 1\n        if j > 0 and j == p[mi[j - 1][n - k]]:\n            s = 0\n        if k > 0 and n - k + 1 == p[ma[j][n - k + 1]]:\n            t = 0\n        if j == 0:\n            dp[j][k] = dp[j][k - 1] + a * t\n        elif k == 0:\n            dp[j][k] = dp[j - 1][k] + b * s\n        else:\n            dp[j][k] = min(dp[j - 1][k] + b * s, dp[j][k - 1] + a * t)\nans = float('inf')\nfor i in range(n + 1):\n    ans = min(ans, dp[i][n - i])\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(itemgetter(0), sorted(enumerate(ppp, start=1), key=itemgetter(1))))\n\ndp = {0: 0}\nfor i in qqq:\n    ndp = defaultdict(lambda: 10 ** 18)\n    tmp_min_cost = 10 ** 18\n    for j, cost in sorted(dp.items()):\n        if cost >= tmp_min_cost:\n            continue\n        tmp_min_cost = cost\n        if j < i:\n            ndp[i] = min(ndp[i], cost)\n            ndp[j] = min(ndp[j], cost + b)\n        else:\n            ndp[j] = min(ndp[j], cost + a)\n    dp = ndp\n\nprint(min(dp.values()))\n"
  },
  {
    "language": "Python",
    "code": "ri = lambda: int(input())\nrl = lambda: list(map(int,input().split()))\nrr = lambda N: [ri() for _ in range(N)]\nYN = lambda b: print('YES') if b else print('NO')\nyn = lambda b: print('Yes') if b else print('No')\nOE = lambda x: print('Odd') if x%2 else print('Even')\nINF = 10**18\n\nN,A,B=rl()\nP=rl()\n\nfor i in range(N):\n    P[i] -= (i+1)\n\nans = 0\nwhile True:\n    abs_max = -1\n    ind = 0\n    for i in range(N):\n        a_p = abs(P[i])\n        if abs_max < a_p:\n            abs_max = a_p\n            ind = i\n    if abs_max == 0:\n        break\n\n    if P[ind] > 0:\n        ans += min(B,A*P[ind])\n        for i in range(ind+1,ind+P[ind]+1):\n            P[i] += 1\n        P[ind] = 0\n    else:\n        ans += min(A,B*(-P[ind]))\n        for i in range(ind+P[ind],ind):\n            P[i] -= 1\n        P[ind] = 0\n\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n, m = [int(i) for i in input().split()]\nE = [[] for i in range(n+1)]\nused = [False] * (n + 1)\nIN = [0] * (n + 1)\n\nfor i in range(m):\n    a, b = [int(i) for i in input().split()]\n    E[a].append(b)\n    E[b].append(a)\n    IN[a] += 1\n    IN[b] += 1\n\ncnt_4 = 0\ncnt_6 = 0\nv_4 = []\nfor j, i in enumerate(IN[1:]):\n    if i % 2 == 1 or i == 0:\n        print('No')\n        exit()\n    if i >= 4:\n        cnt_4 += 1\n        v_4.append(j + 1)\n    if i >= 6:\n        cnt_6 += 1\n\ndef dfs(p, v):\n    if v == v_4[0]:\n        return v_4[0]\n    if v == v_4[1]:\n        return v_4[1]\n\n    for e in E[v]:\n        if e == p:\n            continue\n        return dfs(v, e)\n\nif cnt_4 > 2 or cnt_6 >= 1:\n    print('Yes')\nelif cnt_4 == 2:\n    if all(dfs(v_4[0], e) == v_4[1] for e in E[v_4]):\n        print('No')\n    else:\n        print('Yes')\n\nelse:\n    print('No')\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n\n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n\n    def bfs(self, s):\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, rev in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n\n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, float('inf'))\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, float('inf'))\n\n\nn, a, b = map(int, input().split())\naaa = list(map(int, input().split()))\nmf = Dinic(2 * n + 2)\nt = 2 * n + 1\nfor i in range(1, n + 1):\n    mf.add_link(0, i, b)\n    mf.add_link(n + i, t, a)\nINF = 10 ** 18\nfor i in range(n):\n    r = aaa[i]\n    for l in aaa[:i]:\n        if l > r:\n            mf.add_link(r, l + n, INF)\n        if l + 1 == r:\n            mf.add_link(r, l, INF)\n            break\nprint(mf.max_flow(0, t))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nimport numpy as np\n### 方針\n### 1から順番にソートをしようとすると最小試行回数を満たせない\n### 本来の場所からの距離を探索し、遠い+昇順で選択\n### 本来の数列ではなく、本来の場所からの距離を計算し、距離だけでソートを計算する\n\ndef turn_Left(c,start,end):\n    if (end - start > 1):\n        target_num=c[start]+end-start\n        for i in range(start,end):\n            c[i] = c[i+1] - 1\n        c[end] = target_num\n    else:\n        c[start]=0\n        c[end]=0\n    return c\n\ndef turn_Right(c,start,end):\n    if (end - start > 1):\n        target_num=c[end]-end+start\n        for i in reversed(range(start+1,end+1)):\n            c[i] = c[i-1] + 1\n        c[start] = target_num\n    else:\n        c[start]=0\n        c[end]=0\n    return c\n\ndef AtCoder_d(c,c_left,c_right):\n    if (abs(max(c)) > abs(min(c))):\n        if (max(c)*c_left > c_right ):\n            cost = c_right\n            c = turn_Right(c,np.argmax(c)-max(c),np.argmax(c))\n        else:\n            cost = c_left\n            c = turn_Left(c,np.argmax(c)-max(c),np.argmax(c))\n    else:\n        if (abs(min(c))*c_right > c_left ):\n            cost = c_left\n            c = turn_Left(c,np.argmin(c),np.argmin(c)+abs(min(c)))\n        else:\n            cost = c_right\n            c = turn_Right(c,np.argmin(c),np.argmin(c)+abs(min(c)))\n    return c,cost\n\nif __name__ == '__main__':\n    # 標準入力を受け取る\n    a = list(map(int,input().split()))\n    b = list(map(int,input().split()))\n    # a[0]：N、a[1]：左に移動するコスト、a[2]:右に移動するコスト\n    c=[0]*a[0]\n    c_left=a[1]\n    c_right=a[2]\n    # 本来の位置(正しい順列状態)との各数字の距離を計算\n    for i in range(a[0]):\n        c[i]=i + 1 - b[i]\n    #cost初期化\n    cost=0\n    #既に昇順に並んでいる場合を弾きつつ、ソート開始\n    while True:\n        if ( max(c) == 0 and min(c) == 0 ):\n            break\n        if (max(c) == 1 and min(c) == -1):\n            cost += min(c_left,c_right)*c.count(1)\n            break\n        result = AtCoder_d(c,c_left,c_right)\n        c = result[0]\n        cost = cost + result[1]\n    print(cost)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Feb 16 20:52:46 2019\n\n@author: Owner\n\"\"\"\n\n\nimport collections\nimport scipy.misc\nimport sys\nimport numpy as np\nimport math\nfrom operator import itemgetter\nimport itertools\nimport copy\nimport bisect\n\n#素因数を並べる\ndef prime_decomposition(n):\n  i = 2\n  table = []\n  while i * i <= n:\n    while n % i == 0:\n      n /= i\n      table.append(int(i))\n    i += 1\n  if n > 1:\n    table.append(int(n))\n  return table   \n# 桁数を吐く\ndef digit(i):\n    if i > 0:\n        return digit(i//10) + [i%10]\n    else:\n        return []\n    \ndef getNearestValueIndex(list, num):\n    \"\"\"\n    概要: リストからある値に最も近い値のインデックスを取得する関数\n    @param list: データ配列\n    @param num: 対象値\n    @return 対象値に最も近い値\n    \"\"\"\n\n    # リスト要素と対象値の差分を計算し最小値のインデックスを取得\n    idx = np.abs(np.asarray(list) - num).argmin()\n    return idx\n\ndef find_index(l, x, default=False):\n    if x in l:\n        return l.index(x)\n    else:\n        return default\n\n\n\"\"\"\nN, X = map(int, input().split())\n\nx = [0]*N\nx[:] = map(int, input().split())\n\nP = [0]*N\nY = [0]*N\nfor n in range(N):\n    P[n], Y[n] = map(int, input().split())\n\n    \nall(nstr.count(c) for c in '753')\n\n# 複数配列を並び替え\nABT = zip(A, B, totAB)\nresult = 0\n# itemgetterには何番目の配列をキーにしたいか渡します\nsorted(ABT,key=itemgetter(2))\nA, B, totAB = zip(*ABT)\nA.sort(reverse=True)\n\n# 2進数のbit判定\n(x >> i) & 1\n\n# dp最小化問題\ndp = [np.inf]*N\nfor n in range(N):\n    if n == 0:\n        dp[n] = 0\n    else:\n        for k in range(1,K+1):\n            if n-k >= 0:\n                dp[n] = min(dp[n], dp[n-k] + abs(h[n]-h[n-k]))\n            else:\n                break\n\n\"\"\"\n\nN, A, B = map(int, input().split())\n\np = [0]*N\np[:] = map(int, input().split())\np_end = find_index(p, 1)\ncost = 0\nfor i in range(N-1):\n    n = i+2\n    i_idx = find_index(p,n)\n    tmp_p = p[i_idx]\n    if p_end == i_idx+1:\n        p_end += 1 \n    elif p_end > i_idx:\n        cost += A\n        p[i_idx:p_end] = p[i_idx+1:p_end+1] \n        p[p_end] = tmp_p\n    else:\n        cost += B\n        p[p_end+2:i_idx+1] = p[p_end+1:i_idx] \n        p[p_end+1] = tmp_p\n        p_end += 1\nprint(cost)\n\n"
  },
  {
    "language": "Python",
    "code": "# AGC032 Problem-D\n\nn, a, b = map(int, input().split())\n#global p \np = list(map(int, input().split()))\np.append(n+1)\np.insert(0,0)\n#print (p)\n\n# l-shift で　右端を整列する\ndef ptr_l_shift(p, l, r):\n    for i in range(l, r+1):\n        if p[i] == r :\n            if r == i:\n                return (0 + solve(p, l, r-1))\n            # l_shift(l, r)\n#            print (\"l_shift i=\", i, \"r=\",r)\n#            print (p[0:i], p[i:i+1], p[i+1:r+1], p[r+1:])\n            p =    p[0:i] +p[i+1:r+1] +p[i:i+1] +p[r+1:]\n#            print (p)\n            return (a + solve(p, l, r-1))\n    return(0)\n#    print(\"error l_shift\", p,l,r)\n\n\n# r-shift で　左端を整列する\ndef ptr_r_shift(p, l, r) :\n    for i in range(l, r+1):\n        if p[i] == l :\n            if i == l :\n                return (0 + solve(p, l+1, r))\n            # r_shift(i, j)\n#            print (\"r_shift  l=\", l, \"i=\",i)\n#            print (p[0:l], p[l:i], p[i:i+1], p[i+1:])\n            p =    p[0:l] +p[i:i+1] +p[l:i] +p[i+1:]\n#            print (p)\n            return (b + solve(p, l+1, r))\n    return(0)\n#    print(\"error r_shift\", p,l,r)\n\ndef solve(p, ptr_l, ptr_r):\n    if (ptr_l, ptr_r) in memo :\n        return (memo[ptr_l, ptr_r])\n\n    if ptr_l == ptr_r :\n        return (0)\n    \n    ll = ptr_l_shift(p[:], ptr_l, ptr_r) \n    rr = ptr_r_shift(p[:], ptr_l, ptr_r) \n#    print (\"return ll, rr =\", ll, rr)\n    if ll > rr :\n        memo[(ptr_l, ptr_r)] = rr\n        return (rr)\n    else :\n        memo[(ptr_l, ptr_r)] = ll\n        return (ll)\n\nmemo = {}\n\nprint (solve(p, 1, n))\n#print (\"ans =\", solve(p, 1, n))\n\n\n'''\ndef r_shift(l, r) :\n    global p\n    print (\"r_shft  l=\", l, \"r=\",r)\n    print (p[0:l], p[l:r], p[r:r+1], p[r+1:n+1])\n    p =    p[0:l] +p[r:r+1] +p[l:r] +p[r+1:n+1]\n    print (p)\n    return\n\ndef l_shift(l, r) :\n    global p\n    print (\"l_shift l=\", l, \"r=\",r)\n    print (p[0:l], p[l:l+1], p[l+1:r+1], p[r+1:])\n    p =    p[0:l] +p[l+1:r+1] +p[l:l+1] +p[r+1:]\n    print (p)\n    return\n'''\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    from functools import lru_cache\n    from bisect import bisect,insort\n    import sys\n    sys.setrecursionlimit(10**9)\n    @lru_cache(None)\n    def solve(p):\n        if len(p)<2:\n            return 0\n        j=i[len(p)]\n        return min(solve(t(p[:j]))+(len(p)-1-j)*b,solve(t(p[:j]+p[j+1:]))+a)\n    n,a,b,*p=map(int,open(0).read().split())\n    l=[0]*-~n\n    for i,v in enumerate(p):\n        l[v]=i\n    t=[]\n    i=[0]*-~n\n    for j,v in enumerate(l[1:],1):\n        i[j]=bisect(t,v)\n        insort(t,v)\n    t=tuple\n    print(solve(t(p)))\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/agc032/tasks/agc032_d\n\n圧倒的挿入ソート\nhttps://atcoder.jp/contests/abc006/tasks/abc006_4\nこれの、左右のコストが違うVer\n\n最長部分増加列を計算すれば、A=Bの時の答えは分かる\nその時の答えは, A * (N - 最長部分増加列の長さ)\n\n残りのカードが昇順になるように抜き出し、適切な場所に戻す。\n最長部分列として採用する or しないで dp?\n\ndp[i][部分増加列の最後の数字] = i番目まで見た時のコストの最小値 かな？\n\n増加列の最後に足せば、コストはかからない\n足さないとき、最後の数字より大きければ、A払う\n小さければ、B払う\n\nO(N**2)で解けた？\n\"\"\"\n\nN,A,B = map(int,input().split())\n\np = list(map(int,input().split()))\n\ndp = [float(\"inf\")] * (N+1)\ndp[0] = 0\n\nfor i in range(N):\n\n    ndp = [float(\"inf\")] * (N+1)\n\n    for j in range(N+1):\n\n        if p[i] >= j: #p[i]よりjがおおきいので、Aコスト & 更新ができる\n            ndp[j] = min(ndp[j] , dp[j] + A)\n            ndp[p[i]] = min(ndp[p[i]] , dp[j])\n\n        else: #Bコストでの更新\n            ndp[j] = min(ndp[j] , dp[j] + B)\n\n    dp = ndp\nprint (min(dp))\n"
  },
  {
    "language": "Python",
    "code": "def solve(p):\n    print(p)\n    if len(p)<2:\n        return 0\n    i=p.index(max(p))\n    return min(solve(p[:i])+(len(p)-1-i)*b,solve(p[:i]+p[i+1:])+a)\nn,a,b,*p=map(int,open(0).read().split())\nprint(solve(p))"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\np = list(map(int, input().split()))\nans = 0\nfor i in range(1, n+1):\n\tif i not in p:\n\t\tcontinue\n\tcur = 0\n\ttmp = 0\n\twhile p[cur] != i:\n\t\tif p[cur] > i:\n\t\t\ttmp += a\n\t\tcur += 1\n\tif tmp > b:\n\t\tans += b\n\t\tp = [x for x in p if x != i]\n\telse:\n\t\tfor j in range(cur+1, len(p)):\n\t\t\tif p[j] < i:\n\t\t\t\tans += a\n\t\t\t\tbreak\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\np = list(map(int, input().split()))\n\nINF = 10**13\ndp = [[INF for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0] = 0\n\nfor i in range(n):\n\tfor j in range(n+1):\n\t\tif j < p[i]:\n\t\t\tdp[i+1][p[i]] = min(dp[i+1][p[i]], dp[i][j])\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + a)\n\t\telse:\n\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + b)\n\nprint(min(dp[n]))"
  },
  {
    "language": "Python",
    "code": "import sys\n\n# Rotate selected partial list and return the full list\ndef reorder(list, index, newIndex):\n    tmp = list\n    ind = -1\n    if index > newIndex:\n        tmp.insert(newIndex, list[index])\n        tmp.pop(index + 1)\n    if index < newIndex:\n        tmp.insert(newIndex + 1, list[index])\n        tmp.pop(index)\n\n    # print(2,tmp)\n    return tmp\n\n\n# Calculate the distance a element from its original position\ndef distance(element, set):\n    return element - set.index(element) - 1\n\n\n# Calculate the cheapest way to make a rotation\n## to rotate a list of k elements to the right once\n## is the same as to rotate k-1 times to the left\ndef add_cost(bef, aft):\n    global A\n    global B\n\n    max_rot = abs(aft-bef)\n\n    if bef > aft:\n        if B > max_rot * A:\n            return max_rot * A\n        else:\n            return B\n    else:\n        if A > max_rot * B:\n            return max_rot * B\n        else:\n            return A\n\n\n# Get input and assign the proper variables\ninput = [int(i) for i in sys.stdin.readline().split(\"\\n\")[0].split(\" \")]\n\nN = input[0]\nA = input[1]\nB = input[2]\n\nlst = [int(i) for i in sys.stdin.readline().split(\"\\n\")[0].split(\" \")]\n\n# Sorted list for comparison\nreordered = [i for i in range(1, N+1)]\n\n## moved is a list of numbers that were rotated\nmoved = []\ncost = 0\n\n\n# Repeat until the original list is sorted\nwhile not lst == reordered:\n\n    dist = 0\n    dest = 5001\n    dist_tmp = 0\n    indexCur = -1\n    indexNew = -1\n\n    # Select the element that is the furthest\n    for i in lst:\n        if i not in moved:\n            dist_tmp = abs(distance(i, lst))\n            if dist_tmp > dist:\n                indexCur = lst.index(i)\n                dist = dist_tmp\n\n    # Find where to put the selected element\n    if not dist == 1:\n        for k in lst:\n            if not k == lst[indexCur]:\n                dist_tmp = abs(distance(k, lst))\n                if dist_tmp < dest:\n                    indexNew = lst.index(k)\n                    dest = dist_tmp\n                    continue\n                if dist_tmp == dest:\n                    if k < lst[indexCur]:\n                        indexNew = lst.index(k)\n                        continue\n\n    # Final Stage\n    # There are only 0s and 1s left\n    else:\n        try:\n            if distance(lst[indexCur + 1],lst) == -1:\n                indexNew = indexCur + 1\n        # Already moved the element with the highest distance [5,2,3,1,4]\n        except:\n            if distance(lst[indexCur - 1], lst) == 1:\n                indexNew = indexCur - 1\n\n    # Move element and count Cost\n    moved.append(lst[indexCur])\n    if not indexNew == -1 and not indexCur == indexNew:\n        # print(lst[indexCur], indexNew, add_cost(indexCur, indexNew))\n        lst = reorder(lst, indexCur, indexNew)\n        # print(lst)\n        cost += add_cost(indexCur, indexNew)\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nfor i in qqq:\n    ndp = []\n    app = ndp.append\n    tmp_min_cost = INF\n    stay_min_cost = INF\n    for j, cost in dp:\n        if j < i:\n            stay_min_cost = cost\n            cost += b\n        else:\n            cost += a\n        if tmp_min_cost > cost:\n            app((j, cost))\n            tmp_min_cost = cost\n    if stay_min_cost < INF:\n        item = (i, stay_min_cost)\n        k = bisect(ndp, item)\n        if len(ndp) == k:\n            app(item)\n        elif ndp[k - 1][0] == i:\n            continue\n        elif ndp[k][0] == i:\n            ndp[k] = item\n        else:\n            ndp.insert(k, item)\n    dp = ndp\n\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect, insort\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nstay_cost = 0\nfor i in qqq:\n    ndp = []\n    app = ndp.append\n    tmp_min_cost = INF\n    for j, cost in dp:\n        cost += b if j < i else a\n        if tmp_min_cost > cost:\n            app((j, cost))\n            tmp_min_cost = cost\n    stay_cost = dp[bisect(dp, (i,)) - 1][1]\n    insort(ndp, (i, stay_cost))\n    dp = ndp\n\nprint(min(stay_cost, dp[-1][1]))\n"
  },
  {
    "language": "Python",
    "code": "N,A,B=map(int,input().split())\nP=[int(i) for i in input().split()]\ndp=[10**19]*(N+1)\ndp[0]=0\nfor i in range(1,N+1):\n    ndp=[10**19]*(N+1)\n    for j in range(N+1):\n        if j < P[i-1]:\n            ndp[P[i-1]]=min(ndp[P[i-1]],dp[j])\n            ndp[j]=min(ndp[j],dp[j]+A)\n        else:\n            ndp[j]=min(ndp[j],dp[j]+B)\n    dp=ndp\nprint(min(dp))\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    N, R, L = map(int, input().split())\n    P = list(map(int, input().split()))\n\n    val2idx = [0] * (N+1)\n    for i, p in enumerate(P):\n        val2idx[p] = i + 1\n    bigger = [[0] * (N+1) for _ in range(N+1)]\n    for p in range(1, N+1):\n        for j in range(N):\n            if P[j] > p:\n                bigger[p][j+1] = bigger[p][j] + 1\n            else:\n                bigger[p][j + 1] = bigger[p][j]\n    #print(bigger)\n    inf = 10**14\n    dp = [[inf] * (N+1) for _ in range(N+1)]\n    dp[0][0] = 0\n\n    for p in range(1, N+1):\n        i = val2idx[p]\n        for j in range(N+1):\n            if i > j:\n                dp[p][j] = min(dp[p][j], dp[p-1][j] + L)\n                dp[p][i] = min(dp[p][i], dp[p-1][j] + R * (bigger[p][i] - bigger[p][j]))\n            else:\n                dp[p][j] = min(dp[p][j], dp[p - 1][j])\n    print(min(dp[-1]))\n    #[print(i, dp[i]) for i in range(N+1)]\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\ndef main():\n  n, a, b = map(int, input().split())\n  plist = list(map(int, input().split()))\n  dp = [[float('inf') for _ in range(n+1)] for _ in range(n+1)]\n  dp[0][0] = 0\n  for i in range(n):\n    for j in range(n+1):\n      if dp[i][j] == float('inf'):\n        continue\n      if plist[i] > j:\n        if dp[i+1][plist[i]] > dp[i][j]:\n          dp[i+1][plist[i]] = dp[i][j]\n        if dp[i+1][j] > dp[i][j] + a:\n          dp[i+1][j] = dp[i][j] + a\n      else:\n        if dp[i+1][j] > dp[i][j] + b:\n          dp[i+1][j] = dp[i][j] + b\n\n  ans = float('inf')\n  for i in range(n+1):\n    if ans > dp[n][i]:\n      ans = dp[n][i]\n  print(ans)\n\n\nif __name__ == '__main__':\n  main()\n"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\ndp = [0] + [2 ** 60] * n\np = list(map(int, input().split()))\nfor i in range(n):\n\tdp[i + 1] = dp[0]\n\tdp[0] += a\n\tfor j in range(i):\n\t\tif p[j] < p[i]: dp[i + 1] = min(dp[i + 1], dp[j + 1])\n\t\tdp[j + 1] += [b, a][p[j] < p[i]]\nprint(min(dp))"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect, insort\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nfor i in qqq:\n    ndp = []\n    app = ndp.append\n    tmp_min_cost = INF\n    for j, cost in dp:\n        cost += b if j < i else a\n        if tmp_min_cost > cost:\n            app((j, cost))\n            tmp_min_cost = cost\n    stay_cost = dp[bisect(dp, (i,)) - 1][1]\n    insort(ndp, (i, stay_cost))\n    dp = ndp\n\nprint(min(cost for i, cost in dp))\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\nsys.setrecursionlimit(1000000)\n\n#A\ndef A():\n    n = I()\n    b = LI()\n    ans = []\n    d = max(b)\n    i = 0\n    while b:\n        j = len(b)-1\n        while j >= 0:\n            if b[j] > j+1:\n                print(-1)\n                quit()\n            elif b[j] == j+1:\n                ans.append(b[j])\n                b.pop(j)\n                break\n            j -= 1\n    for i in ans[::-1]:\n        print(i)\n#B\ndef B():\n    n = I()\n    if n%2:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n    else:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n+1-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n#C\ndef C():\n    return\n\n#D\ndef D():\n    n,a,b = LI()\n    p = LI()\n    dp = [[float(\"inf\")]*(n+1) for i in range(n+1)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(n):\n            if p[i] == j:\n                cost = 0\n            elif p[i] < j:\n                cost = b\n            else:\n                cost = a\n            dp[i+1][j] = min(dp[i+1][j],dp[i][j]+cost)\n            dp[i][j+1] = min(dp[i][j+1],dp[i][j])\n            dp[i+1][j+1] = min(dp[i+1][j+1],dp[i][j]+cost)\n\n    print(dp[n][n])\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    D()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\n\nN,A,B=map(int,input().split())\nP=list(map(int,input().split()))\n\ndata=[0]*(N+1)\nflag=[0]*(N+1)\nfor i in range(N):\n    p=P[i]\n    flag[p]=1\n    cnt=0\n    for j in range(p+1,N+1):\n        if flag[j]==0:\n            data[j]=data[j-1]\n        else:\n            cnt+=1\n            data[j]=min(cnt*A+data[p-1],data[j]+B)\n\nprint(data[-1])"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nfor i in qqq:\n    ndp = []\n    s = bisect(dp, (i,))\n    tmp_min = INF\n    for j, cost in dp[:s]:\n        cost += b\n        ndp.append((j, cost))\n        tmp_min = cost\n    stay_cost = dp[s - 1][1]\n    if tmp_min > stay_cost:\n        ndp.append((i, stay_cost))\n        tmp_min = stay_cost\n    for j, cost in dp[s:]:\n        cost += a\n        if tmp_min > cost:\n            ndp.append((j, cost))\n            tmp_min = cost\n    dp = ndp\n\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [0] * n\nfor i, p in enumerate(ppp, start=1):\n    qqq[p - 1] = i\n\ndp = [(0, 0)]\nfor i in qqq:\n    s = bisect(dp, (i,))\n    ndp = [(j, cost + b) for j, cost in dp[:s]]\n    stay_cost = dp[s - 1][1]\n    ndp.append((i, stay_cost))\n    remain = iter(dp[s:])\n    for j, cost in remain:\n        if stay_cost > cost + a:\n            ndp.append((j, cost + a))\n            break\n    ndp.extend((j, cost + a) for j, cost in remain)\n    dp = ndp\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n, a, b = map(int, input().split())\n  plist = list(map(int, input().split()))\n  dp = [float('inf')] * (n+1)\n  dp[0] = 0\n  for i in range(n):\n    tmp_dp = [float('inf')] * (n+1)\n    for j in range(n+1):\n      if dp[j] == float('inf'):\n        continue\n      if plist[i] > j:\n        if tmp_dp[plist[i]] > dp[j]:\n          tmp_dp[plist[i]] = dp[j]\n        if tmp_dp[j] > dp[j] + a:\n          tmp_dp[j] = dp[j] + a\n      else:\n        if tmp_dp[j] > dp[j] + b:\n          tmp_dp[j] = dp[j] + b\n    dp = tmp_dp\n\n  ans = float('inf')\n  for i in range(n+1):\n    if ans > dp[i]:\n      ans = dp[i]\n  print(ans)\n\n\nif __name__ == '__main__':\n  main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(itemgetter(0), sorted(enumerate(ppp, start=1), key=itemgetter(1))))\n\ndp = {0: 0}\nfor i in qqq:\n    ndp = defaultdict(lambda: 1000000000000000)\n    tmp_min_cost = 1000000000000000\n    for j, cost in sorted(dp.items()):\n        if cost >= tmp_min_cost:\n            continue\n        tmp_min_cost = cost\n        if j < i:\n            ndp[i] = min(ndp[i], cost)\n            ndp[j] = min(ndp[j], cost + b)\n        else:\n            ndp[j] = min(ndp[j], cost + a)\n    dp = ndp\n\nprint(min(dp.values()))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nN, A, B = map(int, readline().split())\n*P, = map(int, readline().split())\nQ = [0]*N\nfor i, p in enumerate(P):\n    Q[p-1] = i\n\nINF = 10**18\ndp = [[INF]*(N+1) for i in range(N+1)]\ndp[0][0] = 0\nfor i in range(N):\n    qi = Q[i]\n    for j in range(N):\n        v = dp[i][j]\n        dp[i+1][j] = min(dp[i+1][j], v + (A if qi < j else B))\n        dp[i][j+1] = min(dp[i][j+1], v)\n        if Q[i] == j:\n            dp[i+1][j+1] = min(dp[i+1][j+1], v)\nfor i in range(N):\n    dp[i+1][N] = min(dp[i+1][N], dp[i][N] + A)\nfor j in range(N):\n    dp[N][j+1] = min(dp[N][j+1], dp[N][j])\nsys.stdout.write(\"%d\\n\" % dp[N][N])"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect, insort\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nfor i in qqq:\n    ndp = []\n    app = ndp.append\n    for j, cost in dp:\n        cost += b if j < i else a\n        app((j, cost))\n    stay_cost = dp[bisect(dp, (i,)) - 1][1]\n    insort(ndp, (i, stay_cost))\n    dp = ndp\n\nprint(min(cost for i, cost in dp))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n\n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n\n    def bfs(self, s):\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, rev in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n\n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, float('inf'))\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, float('inf'))\n\n\nn, a, b = map(int, input().split())\naaa = list(map(int, input().split()))\nmf = Dinic(2 * n + 2)\nt = 2 * n + 1\nfor i in range(1, n + 1):\n    mf.add_link(0, i, b)\n    mf.add_link(n + i, t, a)\nINF = 10 ** 18\nfor i in range(n):\n    r = aaa[i]\n    for l in aaa[:i]:\n        if l > r:\n            mf.add_link(r, l + n, INF)\n        if l + 1 == r:\n            mf.add_link(r, l + n, INF)\n            break\nprint(mf.max_flow(0, t))\n"
  },
  {
    "language": "Python",
    "code": "# AGC032 Problem-D1\n\n\nn, a, b = map(int, input().split())\n#global p \np = list(map(int, input().split()))\np.append(n+1)\np.insert(0,0)\n#print (p)\n\n# l-shift で　右端を整列する\ndef ptr_l_shift(p, l, r):\n    for i in range(l, r+1):\n        if p[i] == r :\n            if r == i:\n                return (0 + solve(p, l, r-1))\n            # l_shift(l, r)\n#            print (\"l_shift i=\", i, \"r=\",r)\n#            print (p[0:i], p[i:i+1], p[i+1:r+1], p[r+1:])\n            p =    p[0:i] +p[i+1:r+1] +p[i:i+1] +p[r+1:]\n#            print (p)\n            ret = solve(p, l, r-1)\n#            print (\"r_shift  l=\", l, \"i=\",i)\n#            print (p[0:l], p[l:i], p[i:i+1], p[i+1:])\n            p =    p[0:l] +p[i:i+1] +p[l:i] +p[i+1:]\n#            print (p)\n            return (a + ret)\n#    print(\"error l_shift\", p,l,r)\n\n\n# r-shift で　左端を整列する\ndef ptr_r_shift(p, l, r) :\n    for i in range(l, r+1):\n        if p[i] == l :\n            if i == l :\n                return (0 + solve(p, l+1, r))\n            # r_shift(i, j)\n#            print (\"r_shift  l=\", l, \"i=\",i)\n#            print (p[0:l], p[l:i], p[i:i+1], p[i+1:])\n            p =    p[0:l] +p[i:i+1] +p[l:i] +p[i+1:]\n#            print (p)\n            ret = solve(p, l+1, r)\n#            print (\"l_shift i=\", i, \"r=\",r)\n#            print (p[0:i], p[i:i+1], p[i+1:r+1], p[r+1:])\n            p =    p[0:i] +p[i+1:r+1] +p[i:i+1] +p[r+1:]\n#            print (p)\n            return (b + ret)\n#    print(\"error r_shift\", p,l,r)\n\ndef solve(p, ptr_l, ptr_r):\n    if (ptr_l, ptr_r) in memo :\n        return (memo[ptr_l, ptr_r])\n\n    if ptr_l == ptr_r :\n        return (0)\n    \n    ll = ptr_l_shift(p, ptr_l, ptr_r) \n    rr = ptr_r_shift(p, ptr_l, ptr_r) \n#    print (\"return ll, rr =\", ll, rr)\n    if ll > rr :\n        memo[(ptr_l, ptr_r)] = rr\n        return (rr)\n    else :\n        memo[(ptr_l, ptr_r)] = ll\n        return (ll)\n\nmemo = {}\n\nprint (solve(p, 1, n))\n#print (\"ans =\", solve(p, 1, n))\n"
  },
  {
    "language": "Python",
    "code": "from numpy import *\nN,A,B,*P=map(int,open(0).read().split());d=full(N+1,1<<60,'int');d[0]=0\nfor p in P:d[p]=min(d[:p]);d[p+1:]+=B;d[:p]+=A\nprint(min(d))"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\n\"\"\"\n各数字ごとに左移動・右移動・そのまま使う。全部コスト1ならLIS。\n左から見て、「最後にそのまま使った数、そこまでの数を並べるコスト」を持ってdp。\n\"\"\"\n\nN,A,B = map(int,input().split())\nP = [int(x) for x in input().split()]\n\nINF = 10**18\ndp = np.full(N+1,INF,dtype=np.int64)\ndp[0] = 0\nfor p in P:\n    # pを置く\n    dp[p] = dp[:p].min()\n    # pを左移動\n    dp[p+1:] += B\n    # pを右移動\n    dp[:p] += A\n\nanswer = dp.min()\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\nsys.setrecursionlimit(1000000)\n\n#A\ndef A():\n    n = I()\n    b = LI()\n    ans = []\n    d = max(b)\n    i = 0\n    while b:\n        j = len(b)-1\n        while j >= 0:\n            if b[j] > j+1:\n                print(-1)\n                quit()\n            elif b[j] == j+1:\n                ans.append(b[j])\n                b.pop(j)\n                break\n            j -= 1\n    for i in ans[::-1]:\n        print(i)\n#B\ndef B():\n    n = I()\n    if n%2:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n    else:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n+1-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n#C\ndef C():\n    return\n\n#D\ndef D():\n    n,a,b = LI()\n    pf = LI()\n    f_ans = float(\"inf\")\n    l = [pf[i] for i in range(n)]\n    l.sort()\n    f = defaultdict(int)\n    for i in pf:\n        f[i] = l.index(i)\n    for _ in range(2):\n        p = pf.copy()\n        ans = 0\n        while l != p:\n            d = []\n            i = 0\n            while i < n:\n                j = i\n                while j < n-1:\n                    if f[p[j+1]] != f[p[j]]+1:break\n                    j += 1\n                d.append(p[i:j+1])\n                i = j+1\n            m = len(d)\n            ld = [d[i] for i in range(m)]\n            ld.sort()\n            fd = defaultdict(int)\n            for i in d:\n                fd[str(i)] = ld.index(i)\n            if _ == 0:\n                for i in range(m)[::-1]:\n                    if d[i] != ld[i]:\n                        j = fd[str(d[i])]\n                        x = d[i]\n                        if j > i:\n                            k = 0\n                            for o in range(i+1,j+1):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(b*k,a*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n                        else:\n                            k = 0\n                            for o in range(j,i):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(a*k,b*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n            else:\n                for i in range(m)[::-1]:\n                    if d[i] != ld[i]:\n                        j = fd[str(d[i])]\n                        x = d[i]\n                        if j > i:\n                            k = 0\n                            for o in range(i+1,j+1):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(b*k,a*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n                        else:\n                            k = 0\n                            for o in range(j,i):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(a*k,b*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n            p = [None for i in range(n)]\n            s = 0\n            for i in range(len(d)):\n                for j in range(len(d[i])):\n                    p[s+j] = d[i][j]\n                s += len(d[i])\n        f_ans = min(f_ans,ans)\n    print(f_ans)\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    D()\n"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\np = list(map(int, input().split()))\nans = 0\nfor i in range(1, n+1):\n\tif i not in p:\n\t\tcontinue\n\tcur = 0\n\ttmp = 0\n\twhile p[cur] != i:\n\t\ttmp += a\n\t\tcur += 1\n\tif tmp <= b:\n\t\tans += tmp\n\t\tp = p[cur+1:]\n\telse:\n\t\tans += b\n\t\tp = [x for x in p if x != i]\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = map(itemgetter(0), sorted(enumerate(ppp, start=1), key=itemgetter(1)))\n\ndp = [(0, 0)]\nfor i in qqq:\n    s = bisect(dp, (i,))\n    ndp = [(j, cost + b) for j, cost in dp[:s]]\n    stay_cost = dp[s - 1][1]\n    ndp.append((i, stay_cost))\n    remain = iter(dp[s:])\n    for j, cost in remain:\n        if stay_cost > cost + a:\n            ndp.append((j, cost + a))\n            break\n    ndp.extend((j, cost + a) for j, cost in remain)\n    dp = ndp\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(itemgetter(0), sorted(enumerate(ppp, start=1), key=itemgetter(1))))\n\ndp = {0: 0}\nfor i in qqq:\n    ndp = defaultdict(lambda: 10 ** 18)\n    tmp_min_cost = 10 ** 18\n    for j, cost in sorted(dp.items()):\n        if cost >= tmp_min_cost:\n            continue\n        tmp_min_cost = cost\n        if j < i:\n            ndp[i] = min(ndp[i], cost)\n            ndp[j] = min(ndp[j], cost + b)\n        else:\n            ndp[j] = min(ndp[j], cost + a)\n    dp = ndp\n\nprint(min(dp.values()))\n"
  },
  {
    "language": "Python",
    "code": "N,A,B=map(int,input().split())\nP=[int(i) for i in input().split()]\ndp=[[10**19]*(N+1) for i in range(N+1)]\ndp[0][0]=0\nfor i in range(1,N+1):\n    for j in range(N+1):\n        #if dp[i-1][j]==10**19:\n            #continue\n        if j < P[i-1]:\n            dp[i][P[i-1]]=min(dp[i][P[i-1]],dp[i-1][j])\n            dp[i][j]=min(dp[i][j],dp[i-1][j]+A)\n        else:\n            dp[i][j]=min(dp[i][j],dp[i-1][j]+B)\n#print(dp)\nprint(min(dp[-1]))"
  },
  {
    "language": "Python",
    "code": "N, A, B = map(int, input().split())\nP = [int(a) - 1 for a in input().split()]\nX = [0] * N\nfor i in range(N):\n    pre = X\n    X = [0] * N\n    mi = pre[0]\n    for j in range(N):\n        mi = min(mi, pre[j])\n        X[j] = mi + (A if j < P[i] else B if j > P[i] else 0)\nprint(min(X))"
  },
  {
    "language": "Python",
    "code": "def main():\n    from functools import lru_cache\n    from bisect import bisect,insort\n    import sys\n    sys.setrecursionlimit(10**9)\n    @lru_cache(None)\n    def solve(n,m):\n        l=r=N=M=0\n        for j,v in enumerate(i[1:n],1):\n            if v<m:\n                if v<i[n]:\n                    l+=1\n                    N=max(N,j)\n                else:\n                    r+=1\n            M=max(M,j)\n        if l+r<1:\n            return 0\n        return min(solve(M,m)+a,solve(N,i[n])+r*b)\n        \n    n,a,b,*p=map(int,open(0).read().split())\n    i=[0]*-~n\n    for j,v in enumerate(p):\n        i[v]=j\n    print(solve(n,n))\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "n, a, b = 5000, 10000000, 10000000\np = list(range(n, 0, -1))\nq = [0] * n\nfor i, x in enumerate(p):\n    q[x - 1] = i\ndp = [[0] * (n + 1) for _ in range(n + 1)]\nmi = [[n] * (n + 1) for _ in range(n + 1)]\nma = [[0] * (n + 1) for _ in range(n + 1)]\nfor i in range(n + 1):\n    for j in range(i + 1, n + 1):\n        mi[i][j] = min(mi[i][j - 1], q[j - 1])\n        ma[i][j] = max(ma[i][j - 1], q[j - 1])\nfor i in range(1, n + 1):\n    for j in range(i + 1):\n        k = i - j\n        s, t = 1, 1\n        if j > 0 and j == p[mi[j - 1][n - k]]:\n            s = 0\n        if k > 0 and n - k + 1 == p[ma[j][n - k + 1]]:\n            t = 0\n        if j == 0:\n            dp[j][k] = dp[j][k - 1] + a * t\n        elif k == 0:\n            dp[j][k] = dp[j - 1][k] + b * s\n        else:\n            dp[j][k] = min(dp[j - 1][k] + b * s, dp[j][k - 1] + a * t)\nans = float('inf')\nfor i in range(n + 1):\n    ans = min(ans, dp[i][n - i])\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nfor i in qqq:\n    s = bisect(dp, (i,))\n    ndp = [(j, cost + b) for j, cost in dp[:s]]\n    stay_cost = dp[s - 1][1]\n    ndp.append((i, stay_cost))\n    ndp.extend((j, cost + a) for j, cost in dp[s:] if stay_cost > cost + a)\n    dp = ndp\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\np = list(map(int, input().split()))\nans = 0\nfor i in range(1, n+1):\n\tif i not in p:\n\t\tcontinue\n\tcur = 0\n\ttmp = 0\n\twhile p[cur] != i:\n\t\tif p[cur] > i:\n\t\t\ttmp += a\n\t\tcur += 1\n\tif tmp <= b:\n\t\tans += tmp\n\t\tp = p[cur+1:]\n\telse:\n\t\tans += b\n\t#p = [x for x in p if x != i]\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\ndef main():\n  n, a, b = map(int, input().split())\n  plist = list(map(int, input().split()))\n  dp = [[float('inf') for _ in range(n+1)] for _ in range(n+1)]\n  dp[0][0] = 0\n  for i in range(n):\n    for j in range(n+1):\n      if dp[i][j] == float('inf'):\n        continue\n      if plist[i] > j:\n        if dp[i+1][plist[i]] > dp[i][j]:\n          dp[i+1][plist[i]] = dp[i][j]\n        if dp[i+1][j] > dp[i][j] + a:\n          dp[i+1][j] = dp[i][j] + a\n      else:\n        if dp[i+1][j] > dp[i][j] + b:\n          dp[i+1][j] = dp[i][j] + b\n\n  ans = float('inf')\n  for i in range(n+1):\n    if ans > dp[n][i]:\n      ans = dp[n][i]\n  print(ans)\n\n\nif __name__ == '__main__':\n  main()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Feb 16 20:52:46 2019\n\n@author: Owner\n\"\"\"\n\n\nimport collections\nimport scipy.misc\nimport sys\nimport numpy as np\nimport math\nfrom operator import itemgetter\nimport itertools\nimport copy\nimport bisect\n\n#素因数を並べる\ndef prime_decomposition(n):\n  i = 2\n  table = []\n  while i * i <= n:\n    while n % i == 0:\n      n /= i\n      table.append(int(i))\n    i += 1\n  if n > 1:\n    table.append(int(n))\n  return table   \n# 桁数を吐く\ndef digit(i):\n    if i > 0:\n        return digit(i//10) + [i%10]\n    else:\n        return []\n    \ndef getNearestValueIndex(list, num):\n    \"\"\"\n    概要: リストからある値に最も近い値のインデックスを取得する関数\n    @param list: データ配列\n    @param num: 対象値\n    @return 対象値に最も近い値\n    \"\"\"\n\n    # リスト要素と対象値の差分を計算し最小値のインデックスを取得\n    idx = np.abs(np.asarray(list) - num).argmin()\n    return idx\n\ndef find_index(l, x, default=False):\n    if x in l:\n        return l.index(x)\n    else:\n        return default\n\n\n\"\"\"\nN, X = map(int, input().split())\n\nx = [0]*N\nx[:] = map(int, input().split())\n\nP = [0]*N\nY = [0]*N\nfor n in range(N):\n    P[n], Y[n] = map(int, input().split())\n\n    \nall(nstr.count(c) for c in '753')\n\n# 複数配列を並び替え\nABT = zip(A, B, totAB)\nresult = 0\n# itemgetterには何番目の配列をキーにしたいか渡します\nsorted(ABT,key=itemgetter(2))\nA, B, totAB = zip(*ABT)\nA.sort(reverse=True)\n\n# 2進数のbit判定\n(x >> i) & 1\n\n# dp最小化問題\ndp = [np.inf]*N\nfor n in range(N):\n    if n == 0:\n        dp[n] = 0\n    else:\n        for k in range(1,K+1):\n            if n-k >= 0:\n                dp[n] = min(dp[n], dp[n-k] + abs(h[n]-h[n-k]))\n            else:\n                break\n\n\"\"\"\n\nN, A, B = map(int, input().split())\n\np = [0]*N\np[:] = map(int, input().split())\np_end = find_index(p, 1)\ncost = 0\nfor i in range(N-1):\n    n = i+2\n    i_idx = find_index(p,n)\n    tmp_p = p[i_idx]\n    if p_end == i_idx-1:\n        p_end += 1 \n    elif p_end > i_idx:\n        cost += A\n        p[i_idx:p_end] = p[i_idx+1:p_end+1] \n        p[p_end] = tmp_p\n    else:\n        cost += B\n        p[p_end+2:i_idx+1] = p[p_end+1:i_idx] \n        p[p_end+1] = tmp_p\n        p_end += 1\n    print(n, p, p_end, i_idx)\nprint(cost)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n\n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n\n    def bfs(self, s):\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, rev in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n\n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, float('inf'))\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, float('inf'))\n\n\nn, a, b = map(int, input().split())\naaa = list(map(int, input().split()))\nmf = Dinic(2 * n + 2)\nt = 2 * n + 1\nfor i in range(1, n + 1):\n    mf.add_link(0, i, b)\n    mf.add_link(n + i, t, a)\nINF = 10 ** 18\nfor i in range(n):\n    r = aaa[i]\n    for l in aaa[:i]:\n        if l > r:\n            mf.add_link(r, l + n, INF)\nprint(mf.max_flow(0, t))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\n\nn, a, b = map(int, input().split())\np = list(map(int, input().split()))\np.append(n+1)\np.insert(0,0)\n#'''\n#print (p)\n\nINF = (a+b)*n\nmin_ans =INF   # 仮のmin値\n\n# l-shift で　右端を整列する\ndef ptr_l_shift(p, cost, l, r):\n    for i in range(l, r+1):\n        if p[i] == r :\n            if r == i:\n                return (0 + solve(p, cost, l, r-1))\n            # l_shift(l, r)\n            p =    p[0:i] +p[i+1:r+1] +p[i:i+1] +p[r+1:]\n            ret = solve(p, cost, l, r-1)\n            p =    p[0:i] +p[r:r+1] +p[i:r] +p[r+1:]\n            return (a + ret)\n#    print(\"error l_shift\", p,l,r)\n\n\n# r-shift で　左端を整列する\ndef ptr_r_shift(p, cost, l, r) :\n    for i in range(l, r+1):\n        if p[i] == l :\n            if i == l :\n                return (0 + solve(p, cost, l+1, r))\n            # r_shift(i, j)\n            p =    p[0:l] +p[i:i+1] +p[l:i] +p[i+1:]\n            ret = solve(p, cost, l+1, r)\n            p =    p[0:l] +p[l+1:i+1] +p[l:l+1] +p[i+1:]\n            return (b + ret)\n#    print(\"error r_shift\", p,l,r)\n\ndef solve(p, cost, ptr_l, ptr_r):\n    global min_ans \n    if cost >= min_ans :\n        return (INF)\n\n    if ptr_l == ptr_r :\n        return (0)\n\n    if a < b :    # コストの小さい方を優先する\n        ll = ptr_l_shift(p, cost, ptr_l, ptr_r) \n        rr = ptr_r_shift(p, cost, ptr_l, ptr_r) \n    else:\n        rr = ptr_r_shift(p, cost, ptr_l, ptr_r) \n        ll = ptr_l_shift(p, cost, ptr_l, ptr_r) \n\n#    print (\"return ll, rr =\", ll, rr)\n    if ll > rr :\n        if rr < min_ans :\n            min_ans = rr\n        return (rr)\n    else :\n        if ll < min_ans :\n            min_ans = ll\n        return (ll)\n\ncost = 0\nprint (solve(p, cost, 1, n))"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [0] * n\nfor i, p in enumerate(ppp, start=1):\n    qqq[p - 1] = i\n\ndp = [(0, 0)]\nfor i in qqq:\n    s = bisect(dp, (i,))\n    ndp = [(j, cost + b) for j, cost in dp[:s]]\n    stay_cost = dp[s - 1][1]\n    ndp.append((i, stay_cost))\n    remain = iter(dp[s:])\n    for j, cost in remain:\n        if stay_cost > cost + a:\n            break\n    ndp.extend((j, cost + a) for j, cost in remain)\n    dp = ndp\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "import bisect\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nfor i in qqq:\n    ndp = []\n    app = ndp.append\n    tmp_min_cost = INF\n    stay_min_cost = INF\n    for j, cost in dp:\n        if j <= i:\n            stay_min_cost = cost\n            cost += b\n        else:\n            cost += a\n        if tmp_min_cost > cost:\n            app((j, cost))\n            tmp_min_cost = cost\n    if stay_min_cost < INF:\n        bisect.insort(ndp, (i, stay_min_cost))\n    dp = ndp\n\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\nsys.setrecursionlimit(1000000)\n\n#A\ndef A():\n    n = I()\n    b = LI()\n    ans = []\n    d = max(b)\n    i = 0\n    while b:\n        j = len(b)-1\n        while j >= 0:\n            if b[j] > j+1:\n                print(-1)\n                quit()\n            elif b[j] == j+1:\n                ans.append(b[j])\n                b.pop(j)\n                break\n            j -= 1\n    for i in ans[::-1]:\n        print(i)\n#B\ndef B():\n    n = I()\n    if n%2:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n    else:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n+1-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n#C\ndef C():\n    return\n\n#D\ndef D():\n    n,a,b = LI()\n    pf = LI()\n    f_ans = float(\"inf\")\n    l = [pf[i] for i in range(n)]\n    l.sort()\n    f = defaultdict(int)\n    for i in pf:\n        f[i] = l.index(i)\n    for _ in range(1):\n        p = [pf[i] for i in range(n)]\n        ans = 0\n        while l != p:\n            d = []\n            i = 0\n            while i < n:\n                j = i\n                while j < n-1:\n                    if f[p[j+1]] != f[p[j]]+1:break\n                    j += 1\n                d.append(p[i:j+1])\n                i = j+1\n            m = len(d)\n            ld = [d[i] for i in range(m)]\n            ld.sort()\n            fd = defaultdict(int)\n            for i in d:\n                fd[str(i)] = ld.index(i)\n            if _ == 0:\n                for i in range(m)[::-1]:\n                    if d[i] != ld[i]:\n                        j = fd[str(d[i])]\n                        x = d[i]\n                        if j > i:\n                            k = 0\n                            for o in range(i+1,j+1):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(b*k,a*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n                        else:\n                            k = 0\n                            for o in range(j,i):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(a*k,b*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n            else:\n                for i in range(m)[::-1]:\n                    if d[i] != ld[i]:\n                        j = fd[str(d[i])]\n                        x = d[i]\n                        if j > i:\n                            k = 0\n                            for o in range(i+1,j+1):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(b*k,a*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n                        else:\n                            k = 0\n                            for o in range(j,i):\n                                k += len(d[o])\n                            p = len(d[i])\n                            ans += min(a*k,b*p)\n                            d.pop(i)\n                            d.insert(j,x)\n                            break\n            p = [None for i in range(n)]\n            s = 0\n            for i in range(len(d)):\n                for j in range(len(d[i])):\n                    p[s+j] = d[i][j]\n                s += len(d[i])\n        f_ans = min(f_ans,ans)\n    print(f_ans)\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    D()\n"
  },
  {
    "language": "Python",
    "code": "N, A, B = map(int, input().split())\nP = list(map(int, input().split()))\nPmin = [None]*N\nPmax = [None]*N\nfor i, p in enumerate(P):\n    k = 10000\n    for pj in P[:i]:\n        if pj > p:\n            k = min(k, pj)\n    Pmin[p-1] = k\n\nfor i, p in enumerate(P):\n    k = -1\n    for pj in P[:i:-1]:\n        if pj < p:\n            k = max(k, pj)\n    Pmax[p-1] = k\ndp = [[10**7]*(N+2) for _ in range(N+2)]\ndp[1][N] = 0\nfor k in range(N-1, -1, -1):\n    for i in range(1, N - k + 1):\n        x = dp[i][i+k]\n        if Pmax[i+k-1] + 1 <= i:\n            dp[i][i+k-1] = min(dp[i][i+k-1], x)\n        else:\n            dp[i][i+k-1] = min(dp[i][i+k-1], x+A)\n        if Pmin[i-1] - 1 >= i+k:\n            dp[i+1][i+k] = min(dp[i+1][i+k], x)\n        else:\n            dp[i+1][i+k] = min(dp[i+1][i+k], x+B)\nprint(min([dp[i][i] for i in range(1, N+1)]))"
  },
  {
    "language": "Python",
    "code": "from bisect import*\nn,a,b,*p=map(int,open(0).read().split())\nl=[]\nc=0\nfor i,q in enumerate(p):\n  j=bisect(l,q)\n  if j!=len(l):\n    r=len(l)-j\n    c+=min(b,a*r)\n    l[j]=q\n  else:\n    l.append(q)\nprint(c)"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = map(int, input().split())\nqqq = [i for i, p in sorted(enumerate(ppp, start=1), key=itemgetter(1))]\nINF = 10 ** 15\n\ndp = [(0, 0)]\nfor i in qqq:\n    ndp = []\n    app = ndp.append\n    tmp_min_cost = INF\n    for j, cost in dp:\n        if j < i:\n            cost += b\n        else:\n            cost += a\n        if tmp_min_cost > cost:\n            app((j, cost))\n            tmp_min_cost = cost\n    s = bisect(dp, (i,))\n    stay_cost = dp[s - 1][1]\n    item = (i, stay_cost)\n    k = bisect(ndp, item)\n    if len(ndp) == k:\n        app(item)\n    elif ndp[k - 1][0] == i:\n        continue\n    elif ndp[k][0] == i:\n        ndp[k] = item\n    else:\n        ndp.insert(k, item)\n    dp = ndp\n\nprint(dp[-1][1])\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\nsys.setrecursionlimit(1000000)\n\n#A\ndef A():\n    n = I()\n    b = LI()\n    ans = []\n    d = max(b)\n    i = 0\n    while b:\n        j = len(b)-1\n        while j >= 0:\n            if b[j] > j+1:\n                print(-1)\n                quit()\n            elif b[j] == j+1:\n                ans.append(b[j])\n                b.pop(j)\n                break\n            j -= 1\n    for i in ans[::-1]:\n        print(i)\n#B\ndef B():\n    n = I()\n    if n%2:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n    else:\n        ans = []\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if j != n+1-i and j != i:\n                    ans.append((min(i,j),max(i,j)))\n        ans = list(set(ans))\n        print(len(ans))\n        ans.sort()\n        for i in ans:\n            print(*i)\n#C\ndef C():\n    return\n\n#D\ndef D():\n    n,a,b = LI()\n    p = LI()\n    ans = 0\n    l = [p[i] for i in range(n)]\n    l.sort()\n    f = defaultdict(int)\n    for i in p:\n        f[i] = l.index(i)\n    ans = 0\n    while l != p:\n        d = []\n        i = 0\n        while i < n:\n            j = i\n            while j < n-1:\n                if f[p[j+1]] != f[p[j]]+1:break\n                j += 1\n            d.append([p[i:j+1],i])\n            i = j+1\n        m = len(d)\n        ld = [d[i][0] for i in range(m)]\n        ld.sort()\n        fd = defaultdict(int)\n        for i,j in d:\n            fd[str(i)] = ld.index(i)\n        for i in range(m)[::-1]:\n            if d[i][0] != ld[i]:\n                j = fd[str(d[i][0])]\n                x = d[i]\n                if j > i:\n                    k = d[j][1]-d[i][1]\n                    p = len(d[i][0])\n                    ans += min(b*k,a*p)\n                    d.pop(i)\n                    d.insert(j,x)\n                    break\n                else:\n                    k = d[i][1]-d[j][1]\n                    p = len(d[i][0])\n                    ans += min(a*k,b*p)\n                    d.pop(i)\n                    d.insert(j,x)\n                    break\n        p = [None for i in range(n)]\n        s = 0\n        for i in range(m):\n            for j in range(len(d[i][0])):\n                p[s+j] = d[i][0][j]\n            s += len(d[i][0])\n    print(ans)\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    D()\n"
  },
  {
    "language": "Python",
    "code": "n, a, b = map(int, input().split())\np = list(map(int, input().split()))\nans = 0\n\nmoved = [False for _ in range(n+1)]\nfor i in range(1, n):\n\ttmp = 0\n\twill_be_moved = []\n\tfor j in range(i):\n\t\tif p[j] > p[i] and not moved[p[j]]:\n\t\t\ttmp += a\n\t\t\twill_be_moved.append(j)\n\tif tmp > b:\n\t\tans += b\n\t\tmoved[p[i]] = True\n\telse:\n\t\tans += tmp\n\t\tfor m in will_be_moved:\n\t\t\tmoved[p[m]] = True\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# AGC032 Problem-D1\n\n\nn, a, b = map(int, input().split())\n#global p \np = list(map(int, input().split()))\np.append(n+1)\np.insert(0,0)\n#print (p)\n\n# l-shift で　右端を整列する\ndef ptr_l_shift(p, l, r):\n    for i in range(l, r+1):\n        if p[i] == r :\n            if r == i:\n                return (0 + solve(p, l, r-1))\n            # l_shift(l, r)\n#            print (\"l_shift i=\", i, \"r=\",r)\n#            print (p[0:i], p[i:i+1], p[i+1:r+1], p[r+1:])\n            p =    p[0:i] +p[i+1:r+1] +p[i:i+1] +p[r+1:]\n#            print (p)\n            ret = solve(p, l, r-1)\n#            print (\"r_shift  l=\", l, \"i=\",i)\n#            print (p[0:i], p[i:r], p[r:r+1], p[r+1:])\n            p =    p[0:i] +p[r:r+1] +p[i:r] +p[r+1:]\n#            print (p)\n            return (a + ret)\n#    print(\"error l_shift\", p,l,r)\n\n\n# r-shift で　左端を整列する\ndef ptr_r_shift(p, l, r) :\n    for i in range(l, r+1):\n        if p[i] == l :\n            if i == l :\n                return (0 + solve(p, l+1, r))\n            # r_shift(i, j)\n#            print (\"r_shift  l=\", l, \"i=\",i)\n#            print (p[0:l], p[l:i], p[i:i+1], p[i+1:])\n            p =    p[0:l] +p[i:i+1] +p[l:i] +p[i+1:]\n#            print (p)\n            ret = solve(p, l+1, r)\n#            print (\"l_shift i=\", i, \"r=\",r)\n#            print (p[0:l], p[l:l+1], p[l+1:i+1], p[i+1:])\n            p =    p[0:l] +p[l+1:i+1] +p[l:l+1] +p[i+1:]\n#            print (p)\n            return (b + ret)\n#    print(\"error r_shift\", p,l,r)\n\ndef solve(p, ptr_l, ptr_r):\n    if (ptr_l, ptr_r) in memo :\n        return (memo[ptr_l, ptr_r])\n\n    if ptr_l == ptr_r :\n        return (0)\n    \n    ll = ptr_l_shift(p, ptr_l, ptr_r) \n    rr = ptr_r_shift(p, ptr_l, ptr_r) \n#    print (\"return ll, rr =\", ll, rr)\n    if ll > rr :\n        memo[(ptr_l, ptr_r)] = rr\n        return (rr)\n    else :\n        memo[(ptr_l, ptr_r)] = ll\n        return (ll)\n\nmemo = {}\n\nprint (solve(p, 1, n))\n#print (\"ans =\", solve(p, 1, n))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom operator import itemgetter\n\nn, a, b = map(int, input().split())\nppp = list(map(int, input().split()))\nqqq = list(map(itemgetter(0), sorted(enumerate(ppp, start=1), key=itemgetter(1))))\n\ndp = {0: 0}\nfor i in qqq:\n    ndp = defaultdict(lambda: 1000_000_000_000_000)\n    tmp_min_cost = 1000_000_000_000_000\n    for j, cost in sorted(dp.items()):\n        if cost >= tmp_min_cost:\n            continue\n        tmp_min_cost = cost\n        if j < i:\n            ndp[i] = min(ndp[i], cost)\n            ndp[j] = min(ndp[j], cost + b)\n        else:\n            ndp[j] = min(ndp[j], cost + a)\n    dp = ndp\n\nprint(min(dp.values()))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n\n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n\n    def bfs(self, s):\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, rev in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n\n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, float('inf'))\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, float('inf'))\n\n\nn, a, b = map(int, input().split())\naaa = list(map(int, input().split()))\nmf = Dinic(2 * n + 2)\nt = 2 * n + 1\nfor i in range(1, n + 1):\n    mf.add_link(0, i, b)\n    mf.add_link(n + i, t, a)\nINF = 10 ** 18\nfor i in range(n):\n    r = aaa[i]\n    for l in aaa[:i]:\n        if l > r:\n            mf.add_link(r, l + n, INF)\nprint(mf.max_flow(0, t))\n"
  },
  {
    "language": "Python",
    "code": "from functools import*\n@lru_cache(None)\ndef solve(p):\n    #print(p)\n    if len(p)<2:\n        return 0\n    i=p.index(max(p))\n    return min(solve(t(p[:i]))+(len(p)-1-i)*b,solve(t(p[:i]+p[i+1:]))+a)\nn,a,b,*p=map(int,open(0).read().split())\nt=tuple\nprint(solve(t(p)))"
  },
  {
    "language": "Python",
    "code": "from functools import*\nimport sys\nsys.setrecursionlimit(10**9)\n@lru_cache(None)\ndef solve(p):\n    if len(p)<2:\n        return 0\n    i=p.index(max(p))\n    return min(solve(t(p[:i]))+(len(p)-1-i)*b,solve(t(p[:i]+p[i+1:]))+a)\nn,a,b,*p=map(int,open(0).read().split())\nt=tuple\nprint(solve(t(p)))"
  },
  {
    "language": "Python",
    "code": "def main():\n    from functools import lru_cache\n    from bisect import bisect,insort\n    import sys\n    sys.setrecursionlimit(10**9)\n    @lru_cache(None)\n    def solve(p):\n        if len(p)<2:\n            return 0\n        j=i[len(p)]\n        return min(solve(t(p[:j]))+(len(p)-1-j)*b,solve(t(p[:j]+p[j+1:]))+a)\n    n,a,b,*p=map(int,open(0).read().split())\n    l=[0]*-~n\n    for i,v in enumerate(p):\n        l[v]=i\n    t=[]\n    i=[0]*-~n\n    for j,v in enumerate(l[1:],1):\n        i[j]=bisect(t,v)\n        insort(t,v)\n    t=tuple\n    print(solve(t(p)))\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def main():\n    from functools import lru_cache\n    from bisect import bisect,insort\n    import sys\n    sys.setrecursionlimit(10**9)\n    @lru_cache(None)\n    def solve(p):\n        if len(p)<2:\n            return 0\n        n=len(p)\n        j=i[n]\n        x=sorted(p[:j])\n        z={}\n        for k in range(j):\n          z[x[k]]=k\n        q=t(z[i]for i in p[:j])\n        r=p[:j]+p[j+1:]\n        x=sorted(r)\n        z={}\n        for k in range(n-1):\n          z[x[k]]=k\n        r=t(z[i]for i in r)\n        return min(solve(q)+(n-1-j)*b,solve(r)+a)\n    n,a,b,*p=map(int,open(0).read().split())\n    l=[0]*-~n\n    for i,v in enumerate(p):\n        l[v]=i\n    t=[]\n    i=[0]*-~n\n    for j,v in enumerate(l[1:],1):\n        i[j]=bisect(t,v)\n        insort(t,v)\n    t=tuple\n    print(solve(t(p)))\nif __name__=='__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nimport numpy as np\n### 方針\n### 1から順番にソートをしようとすると最小試行回数を満たせない\n### 本来の場所からの距離を探索し、遠い+昇順で選択\n### 本来の数列ではなく、本来の場所からの距離を計算し、距離だけでソートを計算する\n\ndef turn_Left(c,start,end):\n    if (end - start > 1):\n        target_num=c[start]+end-start\n        for i in range(start,end):\n            c[i] = c[i+1] - 1\n        c[end] = target_num\n    else:\n        c[start]=0\n        c[end]=0\n    return c\n\ndef turn_Right(c,start,end):\n    if (end - start > 1):\n        target_num=c[end]-end+start\n        for i in reversed(range(start+1,end+1)):\n            c[i] = c[i-1] + 1\n        c[start] = target_num\n    else:\n        c[start]=0\n        c[end]=0\n    return c\n\ndef AtCoder_d(c,c_left,c_right):\n    if (abs(max(c)) > abs(min(c))):\n        if (max(c)*c_left > c_right ):\n            cost = c_right\n            c = turn_Right(c,np.argmax(c)-max(c),np.argmax(c))\n        else:\n            cost = c_left\n            c = turn_Left(c,np.argmax(c)-max(c),np.argmax(c))\n    else:\n        if (abs(min(c))*c_right > c_left ):\n            cost = c_left\n            c = turn_Left(c,np.argmin(c),np.argmin(c)+abs(min(c)))\n        else:\n            cost = c_right\n            c = turn_Right(c,np.argmin(c),np.argmin(c)+abs(min(c)))\n    return c,cost\n\nif __name__ == '__main__':\n    # 標準入力を受け取る\n    a = list(map(int,input().split()))\n    b = list(map(int,input().split()))\n    start = time.time()\n    # a[0]：N、a[1]：左に移動するコスト、a[2]:右に移動するコスト\n    c=[0]*a[0]\n    c_left=a[1]\n    c_right=a[2]\n    # 本来の位置(正しい順列状態)との各数字の距離を計算\n    for i in range(a[0]):\n        c[i]=i + 1 - b[i]\n    #cost初期化\n    cost=0\n    #既に昇順に並んでいる場合を弾きつつ、ソート開始\n    while True:\n        if ( max(c) == 0 and min(c) == 0 ):\n            break\n        if (max(c) == 1 and min(c) == -1):\n            cost += min(c_left,c_right)*c.count(1)\n            break\n        result = AtCoder_d(c,c_left,c_right)\n        c = result[0]\n        cost = cost + result[1]\n    print(cost)\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, non_snake_case)]\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n\n// {{{ input!\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n//}}}\n\n//{{{ read!\nmacro_rules! read {\n\t($($t:tt),*; $n:expr) => {{\n\t\tlet stdin = ::std::io::stdin();\n\t\tlet ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n\t\t\tlet line = line.unwrap();\n\t\t\tlet mut it = line.split_whitespace();\n\t\t\t_read!(it; $($t),*)\n\t\t}).collect::<Vec<_>>();\n\t\tret\n\t}};\n\t($($t:tt),*) => {{\n\t\tlet line = readln();\n\t\tlet mut it = line.split_whitespace();\n\t\t_read!(it; $($t),*)\n\t}};\n}\n\nmacro_rules! _read {\n\t($it:ident; [char]) => {\n\t\t_read!($it; String).chars().collect::<Vec<_>>()\n\t};\n\t($it:ident; [u8]) => {\n\t\tVec::from(_read!($it; String).into_bytes())\n\t};\n\t($it:ident; [$t:ty]) => {\n\t\t$it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n\t};\n\t($it:ident; $t:ty) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n\t};\n\t($it:ident; $($t:ty),+) => {\n\t\t($(_read!($it; $t)),*)\n\t};\n}\n//}}}\n\n//{{{ utility macros missing in 1.15.1\n// https://atcoder.jp/contests/nikkei2019-qual/submissions/4098548\nmacro_rules! eprint {\n\t($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = write!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! eprintln {\n\t() => { eprintln!(\"\"); };\n\t($($t:tt)*) => {{\n\t    use ::std::io::Write;\n            let _ = writeln!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! dbg {\n    ($val:expr) => {\n        match $val {\n            tmp => {\n                eprintln!(\n                    \"[{}:{}] {} = {:#?}\",\n                    file!(),\n                    line!(),\n                    stringify!($val),\n                    &tmp\n                );\n                tmp\n            }\n        }\n    };\n}\n//}}}\n\nfn run() {\n    input! {\n        n: usize,\n        a: usize,\n        b: usize,\n        p: [usize1; n],\n    }\n    let mut inv = vec![0; n];\n    eprintln!(\"{:?}\", p);\n    for i in 0..n {\n        inv[p[i]] = i;\n    }\n    let mut left = vec![vec![0; n + 1]; n + 1];\n    let mut right = vec![vec![0; n + 1]; n + 1];\n    let mut dp = vec![vec![usize::max_value(); n + 1]; n + 1];\n    for i in 0..n {\n        dp[i][i + 1] = 0;\n        left[i][i + 1] = inv[i];\n        right[i][i + 1] = inv[i];\n    }\n    for l in 1..n {\n        for i in 0..n {\n            let j = i + l;\n            if j > n {\n                continue;\n            }\n\n            if j < n {\n                let new_elem = j;\n                let place = inv[new_elem];\n                let (new_i, new_j) = (i, j + 1);\n                let cost = if right[i][j] <= place { 0 } else { a };\n                let new_left = min(left[i][j], place);\n                let new_right = max(right[i][j], place);\n                let new_dp = dp[i][j] + cost;\n                dp[new_i][new_j].set_min(new_dp);\n                left[new_i][new_j] = new_left;\n                right[new_i][new_j] = new_right;\n            }\n            if i > 0 {\n                let new_elem = i - 1;\n                let place = inv[new_elem];\n                let (new_i, new_j) = (i - 1, j);\n                let cost = if left[i][j] >= place { 0 } else { b };\n                let new_dp = dp[i][j] + cost;\n                let new_left = min(left[i][j], place);\n                let new_right = max(right[i][j], place);\n                dp[new_i][new_j].set_min(new_dp);\n                left[new_i][new_j] = new_left;\n                right[new_i][new_j] = new_right;\n            }\n        }\n    }\n    println!(\"{}\", dp[0][n]);\n}\n\n//{{{ template\nfn main() {\n    let _ = ::std::thread::Builder::new()\n        .name(\"run\".to_string())\n        .stack_size(256 * 1024 * 1024)\n        .spawn(run)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\npub trait SetMinMax {\n    fn set_min(&mut self, v: Self) -> bool;\n    fn set_max(&mut self, v: Self) -> bool;\n}\n\nimpl<T> SetMinMax for T\nwhere\n    T: PartialOrd,\n{\n    fn set_min(&mut self, v: T) -> bool {\n        *self > v && {\n            *self = v;\n            true\n        }\n    }\n    fn set_max(&mut self, v: T) -> bool {\n        *self < v && {\n            *self = v;\n            true\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(unused)] // This is defined for read! macro\nfn readln() -> String {\n    let mut line = String::new();\n    ::std::io::stdin()\n        .read_line(&mut line)\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    line\n}\n//}}}\n\n//{{{ https://github.com/ichyo/rust-algorithms.git\npub mod algonium {\n    #![doc = \" This library provides a collection of classic algorithms,\"]\n    #![doc = \" focusing on programming contests such as codeforces and atcoder.\"]\n    pub mod data_structure {\n        mod bit {\n            #[doc = \" Binary Indexed Tree (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure supports these two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[at]\"]\n            #[doc = \" 2. the sum of v[begin], v[begin+1], .., v[end-1]\"]\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            #[doc = \" Binary Indexed Tree (range-version) (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[begin], v[begin+1], ..., v[end-1]\"]\n            #[doc = \" 2. get the sum of v[begin], v[begin+1], ..., v[end-1]\"]\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {\n                #[doc = \" Constructs a new BIT of length `len`.\"]\n                #[doc = \" All values are initialized zero.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" # #[warn(unused_mut)]\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" ```\"]\n                pub fn new(len: usize) -> BIT {\n                    BIT { tree: vec![0; len] }\n                }\n                #[doc = \" Returns the number of elements in the BIT.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" assert_eq!(bit.len(), 100);\"]\n                #[doc = \" ```\"]\n                pub fn len(&self) -> usize {\n                    self.tree.len()\n                }\n                #[doc = \" Add a value `value` to a element of index `index`.\"]\n                #[doc = \" v[index] += value\"]\n                #[doc = \"\"]\n                #[doc = \" # Panics\"]\n                #[doc = \"\"]\n                #[doc = \" Panics if `index > len`\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(10);\"]\n                #[doc = \" bit.add(5, 100);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 100);\"]\n                #[doc = \" bit.add(5, 10);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 110);\"]\n                #[doc = \" ```\"]\n                pub fn add(&mut self, index: usize, value: i64) {\n                    assert!(index < self.tree.len());\n                    let mut idx = index;\n                    while idx < self.tree.len() {\n                        self.tree[idx] += value;\n                        idx |= idx + 1;\n                    }\n                }\n                #[doc = \" sum of v[idx] such that begin <= idx < end\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    let a = if end > 0 { self.cum(end - 1) } else { 0 };\n                    let b = if begin > 0 { self.cum(begin - 1) } else { 0 };\n                    a - b\n                }\n                #[doc = \" v[0] + ... + v[last]\"]\n                fn cum(&self, last: usize) -> i64 {\n                    assert!(last < self.tree.len());\n                    let mut res = 0;\n                    let mut idx = last as i64;\n                    while idx >= 0 {\n                        res += self.tree[idx as usize];\n                        idx = (idx & (idx + 1)) - 1;\n                    }\n                    res\n                }\n            }\n            impl BITRange {\n                pub fn new(n: usize) -> BITRange {\n                    BITRange {\n                        bit0: BIT::new(n + 1),\n                        bit1: BIT::new(n + 1),\n                    }\n                }\n                #[doc = \" v[begin], v[begin+1], ..., v[end-1] += by\"]\n                pub fn add(&mut self, begin: usize, end: usize, by: i64) {\n                    if begin >= end {\n                        return;\n                    }\n                    let a = begin as i64;\n                    let b = end as i64;\n                    self.bit0.add(begin, -by * a);\n                    self.bit0.add(end, by * b);\n                    self.bit1.add(begin, by);\n                    self.bit1.add(end, -by);\n                }\n                #[doc = \" v[begin] + ... + v[end-1]\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    self.cum(end) - self.cum(begin)\n                }\n                #[doc = \" v[0] + ... + v[end-1]\"]\n                fn cum(&self, end: usize) -> i64 {\n                    let a = self.bit0.get(0, end);\n                    let b = self.bit1.get(0, end);\n                    a + b * end as i64\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_add() {\n                    let mut bit = BIT::new(10);\n                    bit.add(100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_range_add() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(5, 100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_get() {\n                    let bit = BIT::new(10);\n                    bit.get(0, 1000);\n                }\n                #[test]\n                fn test_empty_range() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(9, 0, 100);\n                    bit.add(7, 3, 100);\n                    assert_eq!(0, bit.get(0, 9));\n                    assert_eq!(0, bit.get(0, 5));\n                    assert_eq!(0, bit.get(2, 5));\n                }\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        mod segment_tree {\n            use std::cmp;\n            use std::marker::PhantomData;\n            pub trait Monoid<T> {\n                fn id() -> Option<T> {\n                    None\n                }\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T>;\n            }\n            pub struct MinOp<T: Ord> {\n                phantom: PhantomData<T>,\n            }\n            impl<T: Ord + Clone> Monoid<T> for MinOp<T> {\n                #[inline]\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T> {\n                    match (l.clone(), r.clone()) {\n                        (Some(l), Some(r)) => Some(cmp::min(l, r)),\n                        (Some(l), None) => Some(l),\n                        (None, Some(r)) => Some(r),\n                        (None, None) => None,\n                    }\n                }\n            }\n            pub struct SegmentTree<M: Monoid<T>, T: Clone> {\n                phantom: PhantomData<M>,\n                data: Vec<Option<T>>,\n                size: usize,\n                size_p2: usize,\n            }\n            impl<M: Monoid<T>, T: Clone> SegmentTree<M, T> {\n                pub fn from_vec(v: Vec<T>) -> SegmentTree<M, T> {\n                    let size = v.len();\n                    let mut size_p2 = 1;\n                    while size_p2 < v.len() {\n                        size_p2 *= 2;\n                    }\n                    let mut data = vec![None; size_p2 * 2];\n                    for (i, x) in v.into_iter().enumerate() {\n                        data[size_p2 + i] = Some(x);\n                    }\n                    for i in (0..size_p2).rev() {\n                        data[i] = M::op(&data[i * 2 + 0], &data[i * 2 + 1]);\n                    }\n                    SegmentTree {\n                        phantom: PhantomData,\n                        data: data,\n                        size: size,\n                        size_p2: size_p2,\n                    }\n                }\n                pub fn size(&self) -> usize {\n                    self.size\n                }\n                pub fn update(&mut self, mut pos: usize, value: T) {\n                    assert!(pos < self.size);\n                    pos += self.size_p2;\n                    self.data[pos] = Some(value);\n                    loop {\n                        pos /= 2;\n                        if pos == 0 {\n                            break;\n                        }\n                        self.data[pos] = M::op(&self.data[pos * 2], &self.data[pos * 2 + 1]);\n                    }\n                }\n                pub fn query(&self, mut l: usize, mut r: usize) -> Option<T> {\n                    assert!(l <= r && r <= self.size);\n                    l += self.size_p2;\n                    r += self.size_p2;\n                    let mut res1 = M::id();\n                    let mut res2 = M::id();\n                    while l < r {\n                        if (l & 1) != 0 {\n                            res1 = M::op(&res1, &self.data[l]);\n                            l += 1;\n                        }\n                        if (r & 1) != 0 {\n                            r -= 1;\n                            res2 = M::op(&self.data[r], &res2);\n                        }\n                        l >>= 1;\n                        r >>= 1;\n                    }\n                    M::op(&res1, &res2)\n                }\n            }\n            #[doc = \" segment tree to get minimum value in a range\"]\n            pub type RMQ<T> = SegmentTree<MinOp<T>, T>;\n            #[cfg(test)]\n            mod tests {\n                use super::RMQ;\n                #[test]\n                fn test_rms() {\n                    let mut test = vec![1, 5, 4, 8, 6, 9, 2, 0, 8, 1];\n                    let mut rms = RMQ::from_vec(test.clone());\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                    rms.update(7, 5);\n                    test[7] = 5;\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                }\n            }\n        }\n        mod union_find {\n            #[doc = \" Disjoint-set data structure\"]\n            #[doc = \"\"]\n            #[doc = \" This provides operations for disjoint sets.\"]\n            #[doc = \" They runs in nearly constatant time.\"]\n            #[doc = \" (the actual time is `O(A(n))` where `A(n)` is the inverse of ackermann function.)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. unite(x, y) - unite a set including x and another set including y into one.\"]\n            #[doc = \" 2. same(x, y) - determine if x and y are in the same set.\"]\n            #[doc = \" 3. size(x) - calculate the number of elements of the set including x.\"]\n            #[doc = \"\"]\n            #[doc = \" [`UnionFind::new(n)`](#method.new) creates n disjoint sets. `i`-th set contains single element `i` (0-indexed).\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::data_structure::UnionFind;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut uf = UnionFind::new(4);\"]\n            #[doc = \" assert!(!uf.same(0, 1));\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(0, 1);\"]\n            #[doc = \" assert!(uf.same(0, 1));\"]\n            #[doc = \" assert_eq!(uf.size(0), 2);\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(1, 2);\"]\n            #[doc = \" assert!(uf.same(0, 2));\"]\n            #[doc = \" assert_eq!(uf.size(0), 3);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            #[doc = \" # Panics\"]\n            #[doc = \" panics if `x` or `y` is not less than number of elements given in the initialization method.\"]\n            #[doc = \"\"]\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {\n                #[doc = \" Creates a object with n disjoint sets. `i`-th set is `{ i }`.\"]\n                pub fn new(n: usize) -> UnionFind {\n                    UnionFind { data: vec![-1; n] }\n                }\n                #[doc = \" Unite a set including `x` and another set including y into one.\"]\n                #[doc = \" Returns `true` only if they were in different set.\"]\n                pub fn unite(&mut self, x: usize, y: usize) -> bool {\n                    let x = self.root(x);\n                    let y = self.root(y);\n                    if x != y {\n                        let (x, y) = if self.data[x] <= self.data[y] {\n                            (x, y)\n                        } else {\n                            (y, x)\n                        };\n                        self.data[x] += self.data[y];\n                        self.data[y] = x as i32;\n                    }\n                    x != y\n                }\n                #[doc = \" Returns `true` only if `x` and `y` are in a same set.\"]\n                pub fn same(&mut self, x: usize, y: usize) -> bool {\n                    self.root(x) == self.root(y)\n                }\n                #[doc = \" Returns the number of elements of a set including `x`.\"]\n                pub fn size(&mut self, x: usize) -> u32 {\n                    let r = self.root(x);\n                    (-self.data[r]) as u32\n                }\n                #[doc = \" internal method to return representative element of a set including `x`.\"]\n                pub fn root(&mut self, x: usize) -> usize {\n                    if self.data[x] < 0 {\n                        x\n                    } else {\n                        let nx = self.data[x] as usize;\n                        let r = self.root(nx);\n                        self.data[x] = r as i32;\n                        r\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n        pub use self::bit::{BITRange, BIT};\n        pub use self::segment_tree::{MinOp, Monoid, SegmentTree, RMQ};\n        pub use self::union_find::UnionFind;\n    }\n    pub mod math {\n        mod comb {\n            use super::mint::{Mint, Module};\n            #[doc = \" Useful struct to compute combinations\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Comb, Mod107, Mint107};\"]\n            #[doc = \" let comb: Comb<Mod107> = Comb::new(100);\"]\n            #[doc = \" assert_eq!(Mint107::from(24), comb.fact(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(1), comb.fact(4) * comb.factinv(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(12), comb.perm(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(6), comb.comb(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(10), comb.multi_comb(4, 2));\"]\n            #[doc = \" ```\"]\n            pub struct Comb<M: Module> {\n                fact: Vec<Mint<M>>,\n                factinv: Vec<Mint<M>>,\n            }\n            impl<M: Module> Comb<M> {\n                #[doc = \" Create a object that provides effiecint computation of combinations\"]\n                #[doc = \" for input smaller than `n`.\"]\n                #[doc = \"\"]\n                #[doc = \" This requires `O(n)` time.\"]\n                pub fn new(n: usize) -> Comb<M> {\n                    let mut fact: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    let mut factinv: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    fact[0] = 1.into();\n                    for i in 0..n {\n                        fact[i + 1] = fact[i] * (i + 1);\n                    }\n                    factinv[n] = fact[n].inv();\n                    for i in (0..n).rev() {\n                        factinv[i] = factinv[i + 1] * (i + 1);\n                    }\n                    Comb {\n                        fact: fact,\n                        factinv: factinv,\n                    }\n                }\n                #[doc = \" `n! = 1 * 2 * ... * n`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn fact(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.fact.get(n as usize) {\n                        *x\n                    } else if n >= M::module() as u64 {\n                        Mint::from(0)\n                    } else {\n                        let mut res = 1.into();\n                        for a in 1..(n + 1) {\n                            res *= a;\n                        }\n                        res\n                    }\n                }\n                #[doc = \" returns `y` such that `n! * y == 1`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn factinv(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.factinv.get(n as usize) {\n                        *x\n                    } else {\n                        self.fact(n).inv()\n                    }\n                }\n                #[doc = \" `nPr = n! / (n - r)!`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn perm(&self, n: u64, r: u64) -> Mint<M> {\n                    if n >= r {\n                        self.fact(n) * self.factinv((n - r) as u64)\n                    } else {\n                        0.into()\n                    }\n                }\n                #[doc = \" `nCr = n! / (n - r)! / r!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn comb(&self, n: u64, r: u64) -> Mint<M> {\n                    let m = M::module() as u64;\n                    if n >= m {\n                        self.comb(n % m, r % m) * self.comb(n / m, r / m)\n                    } else if n >= r {\n                        self.fact(n) * self.factinv(n - r) * self.factinv(r)\n                    } else {\n                        Mint::from(0)\n                    }\n                }\n                #[doc = \" `(n + k - 1)! / k!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn multi_comb(&self, n: u64, r: u64) -> Mint<M> {\n                    if r == 0 {\n                        Mint::from(1)\n                    } else {\n                        self.comb(n + r - 1, r)\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        mod mint {\n            use std::fmt;\n            use std::marker::PhantomData;\n            use std::mem;\n            use std::ops;\n            #[doc = \" Trait for `Mint`. `module()` should return prime number.\"]\n            pub trait Module: Copy + Clone {\n                fn module() -> u32;\n            }\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 7`\"]\n            pub const MOD_107: u32 = 1_000_000_007;\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 9`\"]\n            pub const MOD_109: u32 = 1_000_000_009;\n            #[doc = \" One of famous numbers in programming contest. `998_244_353`\"]\n            pub const MOD_998: u32 = 998_244_353;\n            #[doc = \" struct to implement Module trait. it returns `MOD_107`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod107;\n            impl Module for Mod107 {\n                fn module() -> u32 {\n                    MOD_107\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_109`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod109;\n            impl Module for Mod109 {\n                fn module() -> u32 {\n                    MOD_109\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_998`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod998;\n            impl Module for Mod998 {\n                fn module() -> u32 {\n                    MOD_998\n                }\n            }\n            #[doc = \" Wrapper class to compute mod `1_000_000_007` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" # // TODO: implement convert to u64\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint107 = Mint<Mod107>;\n            #[doc = \" Wrapper class to compute mod `1_000_000_009` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint109, MOD_109};\"]\n            #[doc = \" let x: Mint109 = 1234567.into();\"]\n            #[doc = \" let y: Mint109 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_109 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint109 = Mint<Mod109>;\n            #[doc = \" Wrapper class to compute mod `998_244_353` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint998, MOD_998};\"]\n            #[doc = \" let x: Mint998 = 1234567.into();\"]\n            #[doc = \" let y: Mint998 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_998 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint998 = Mint<Mod998>;\n            #[doc = \" Wrapper class to compute modulo operation.\"]\n            #[doc = \" See examples\"]\n            #[doc = \" [`Mint107`](type.Mint107.html),\"]\n            #[doc = \" [`Mint109`](type.Mint109.html),\"]\n            #[doc = \" [`Mint998`](type.Mint998.html)\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint<M: Module> {\n                #[doc = \" internal value. this is always less than `self.module()`.\"]\n                pub val: u32,\n                m: PhantomData<M>,\n            }\n            impl<M: Module> Mint<M> {\n                fn module(self) -> u32 {\n                    M::module()\n                }\n                fn new(val: u32) -> Mint<M> {\n                    assert!(val < M::module());\n                    Mint {\n                        val: val,\n                        m: PhantomData,\n                    }\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Add<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn add(self, other: T) -> Mint<M> {\n                    let nval = self.val + other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Sub<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn sub(self, other: T) -> Mint<M> {\n                    let nval = self.val + self.module() - other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Mul<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn mul(self, other: T) -> Mint<M> {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint::new((nval % (self.module() as u64)) as u32)\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Div<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn div(self, other: T) -> Mint<M> {\n                    self * other.into().inv()\n                }\n            }\n            impl<M: Module> Mint<M> {\n                #[doc = \" Returns number `y` that satisfies `x * y == 1` where `x` is the original value.\"]\n                #[doc = \"\"]\n                #[doc = \" This assumes `module()` returns prime number.\"]\n                pub fn inv(self) -> Mint<M> {\n                    let mut a = self.val as i32;\n                    let mut b = self.module() as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        mem::swap(&mut u, &mut v);\n                    }\n                    Mint::new(if u < 0 { u + self.module() as i32 } else { u } as u32)\n                }\n            }\n            impl<M: Module> PartialEq for Mint<M> {\n                fn eq(&self, other: &Mint<M>) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl<M: Module> fmt::Display for Mint<M> {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules ! impl_signed_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = ( x as i64 ) % ( M :: module ( ) as i64 ) ; if x >= 0 { Mint { val : t as u32 , m : PhantomData } } else { Mint { val : ( M :: module ( ) as i64 + t ) as u32 , m : PhantomData } } } } ) * ) }\n            macro_rules ! impl_unsigned_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = x as u64 % M :: module ( ) as u64 ; Mint :: new ( t as u32 ) } } ) * ) }\n            impl_signed_mint! { i8 i16 i32 i64 isize }\n            impl_unsigned_mint! { u8 u16 u32 u64 usize }\n            impl<T: Into<Mint<M>>, M: Module> ops::AddAssign<T> for Mint<M> {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::SubAssign<T> for Mint<M> {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::MulAssign<T> for Mint<M> {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::DivAssign<T> for Mint<M> {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint<Mod107> = Mint::from(3);\n                    let b: Mint<Mod107> = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % Mod107::module() as u64), a * b);\n                }\n            }\n        }\n        pub use self::comb::Comb;\n        pub use self::mint::{Mint, Module};\n        pub use self::mint::{Mint107, Mint109, Mint998};\n        pub use self::mint::{Mod107, Mod109, Mod998};\n        pub use self::mint::{MOD_107, MOD_109, MOD_998};\n    }\n    pub mod util {\n        mod permutation {\n            #[doc = \" It contains same methods as `std::next_permutaion` in C++.\"]\n            #[doc = \" these methods should rearrange the elements into the next/prev lexicographically greater permutation.\"]\n            #[doc = \"\"]\n            #[doc = \" This is implemented in [T] where T is Ord.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::Permutation;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [5, 0, 9, 2];\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 9, 0]);\"]\n            #[doc = \" assert!(perm.prev_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [4, 3, 2, 1, 0];\"]\n            #[doc = \" assert!(!perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [4, 3, 2, 1, 0]);\"]\n            #[doc = \" ```\"]\n            pub trait Permutation {\n                #[doc = \" It rearranges the elements into the next lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the last permutation.\"]\n                fn next_permutation(&mut self) -> bool;\n                #[doc = \" It rearranges the elements into the previous lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the first permutation.\"]\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        mod random {\n            use std::num::Wrapping;\n            #[doc = \" Not secure but fast random generator.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::XorShift;\"]\n            #[doc = \" let mut xorshift = XorShift::new();\"]\n            #[doc = \" assert_eq!(3701687786, xorshift.next_u32());\"]\n            #[doc = \" assert_eq!(458299110, xorshift.next_u32());\"]\n            #[doc = \" ```\"]\n            #[derive(Clone, Debug, Default)]\n            pub struct XorShift {\n                x: Wrapping<u32>,\n                y: Wrapping<u32>,\n                z: Wrapping<u32>,\n                w: Wrapping<u32>,\n            }\n            impl XorShift {\n                #[doc = \" Create object with default seed.\"]\n                pub fn new() -> XorShift {\n                    XorShift {\n                        x: Wrapping(123_456_789),\n                        y: Wrapping(362_436_069),\n                        z: Wrapping(521_288_629),\n                        w: Wrapping(88_675_123),\n                    }\n                }\n                #[doc = \" Get next random u32 number.\"]\n                pub fn next_u32(&mut self) -> u32 {\n                    let x = self.x;\n                    let t = x ^ (x << 11);\n                    self.x = self.y;\n                    self.y = self.z;\n                    self.z = self.w;\n                    let v = self.w;\n                    self.w = v ^ (v >> 19) ^ (t ^ (t >> 8));\n                    self.w.0\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::XorShift;\n                #[test]\n                fn test_basic() {\n                    let mut xorshift = XorShift::new();\n                    assert_eq!(3701687786, xorshift.next_u32());\n                    assert_eq!(458299110, xorshift.next_u32());\n                }\n            }\n        }\n        pub use self::permutation::Permutation;\n        pub use self::random::XorShift;\n    }\n}\n\n//}}}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc032/tasks/agc032_d\n//\n#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::*;\nuse std::io::*;\nuse std::str::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst INF: i64 = 1e18 as i64;\n\nfn main() {\n    input! {\n        n: usize, a: i64, b: i64,\n        p: [usize1; n]\n    };\n\n    let mut dp = vec![vec![INF; n + 1]; 2];\n    dp[0][n] = 0;\n\n    for i in 0..n {\n        let mut upper = 0;\n        let mut lower = 0;\n        for j in 0..i {\n            if p[i] < p[j] {\n                upper += 1;\n            } else {\n                lower += 1;\n            }\n        }\n\n        let fr = i % 2;\n        let to = 1 - fr;\n        for j in 0..n + 1 {\n            dp[to][j] = INF;\n        }\n\n        for j in 0..n + 1 {\n            if dp[fr][j] == INF {\n                continue;\n            }\n            let base = dp[fr][j];\n            if j == n {\n                dp[to][i] = min(dp[to][i], base + upper * a + lower * b);\n            } else {\n                if p[j] < p[i] {\n                    dp[to][i] = min(dp[to][i], base);\n                }\n            }\n            if j == n {\n                dp[to][j] = min(dp[to][j], base);\n            } else {\n                if p[i] > p[j] {\n                    dp[to][j] = min(dp[to][j], base + a);\n                } else {\n                    dp[to][j] = min(dp[to][j], base + b);\n                }\n            }\n        }\n    }\n    let mut ans = INF;\n    for i in 0..n {\n        ans = min(ans, dp[n % 2][i]);\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, non_snake_case)]\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n\n// {{{ input!\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n//}}}\n\n//{{{ read!\nmacro_rules! read {\n\t($($t:tt),*; $n:expr) => {{\n\t\tlet stdin = ::std::io::stdin();\n\t\tlet ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n\t\t\tlet line = line.unwrap();\n\t\t\tlet mut it = line.split_whitespace();\n\t\t\t_read!(it; $($t),*)\n\t\t}).collect::<Vec<_>>();\n\t\tret\n\t}};\n\t($($t:tt),*) => {{\n\t\tlet line = readln();\n\t\tlet mut it = line.split_whitespace();\n\t\t_read!(it; $($t),*)\n\t}};\n}\n\nmacro_rules! _read {\n\t($it:ident; [char]) => {\n\t\t_read!($it; String).chars().collect::<Vec<_>>()\n\t};\n\t($it:ident; [u8]) => {\n\t\tVec::from(_read!($it; String).into_bytes())\n\t};\n\t($it:ident; [$t:ty]) => {\n\t\t$it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n\t};\n\t($it:ident; $t:ty) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n\t};\n\t($it:ident; $($t:ty),+) => {\n\t\t($(_read!($it; $t)),*)\n\t};\n}\n//}}}\n\n//{{{ utility macros missing in 1.15.1\n// https://atcoder.jp/contests/nikkei2019-qual/submissions/4098548\nmacro_rules! eprint {\n\t($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = write!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! eprintln {\n\t() => { eprintln!(\"\"); };\n\t($($t:tt)*) => {{\n\t    use ::std::io::Write;\n            let _ = writeln!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! dbg {\n    ($val:expr) => {\n        match $val {\n            tmp => {\n                eprintln!(\n                    \"[{}:{}] {} = {:#?}\",\n                    file!(),\n                    line!(),\n                    stringify!($val),\n                    &tmp\n                );\n                tmp\n            }\n        }\n    };\n}\n//}}}\n\nfn run() {\n    input! {\n        n: usize,\n        a: usize,\n        b: usize,\n        p: [usize1; n],\n    }\n    let mut inv = vec![0; n];\n    for i in 0..n {\n        inv[p[i]] = i;\n    }\n    let mut left = vec![vec![usize::max_value(); n + 1]; n + 1];\n    let mut right = vec![vec![usize::max_value(); n + 1]; n + 1];\n    let mut dp = vec![vec![usize::max_value(); n + 1]; n + 1];\n    for i in 0..n {\n        dp[i][i + 1] = 0;\n        left[i][i + 1] = inv[i];\n        right[i][i + 1] = inv[i];\n    }\n    for l in 1..n {\n        for i in 0..n {\n            let j = i + l;\n            if j > n {\n                continue;\n            }\n            assert!(left[i][j] != usize::max_value());\n            assert!(right[i][j] != usize::max_value());\n            assert!(dp[i][j] != usize::max_value());\n\n            if j < n {\n                let new_elem = j;\n                let place = inv[new_elem];\n                let (new_i, new_j) = (i, j + 1);\n                assert!(right[i][j] != place);\n                let cost = if right[i][j] <= place { 0 } else { a };\n\n                let new_dp = dp[i][j] + cost;\n                let new_left = min(left[i][j], place);\n                let new_right = max(right[i][j], place);\n\n                dp[new_i][new_j].set_min(new_dp);\n                left[new_i][new_j] = new_left;\n                right[new_i][new_j] = new_right;\n            }\n            if i > 0 {\n                let new_elem = i - 1;\n                let place = inv[new_elem];\n                let (new_i, new_j) = (i - 1, j);\n                assert!(left[i][j] != place);\n                let cost = if left[i][j] >= place { 0 } else { b };\n\n                let new_dp = dp[i][j] + cost;\n                let new_left = min(left[i][j], place);\n                let new_right = max(right[i][j], place);\n\n                dp[new_i][new_j].set_min(new_dp);\n                left[new_i][new_j] = new_left;\n                right[new_i][new_j] = new_right;\n            }\n        }\n    }\n    println!(\"{}\", dp[0][n]);\n}\n\n//{{{ template\nfn main() {\n    let _ = ::std::thread::Builder::new()\n        .name(\"run\".to_string())\n        .stack_size(256 * 1024 * 1024)\n        .spawn(run)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\npub trait SetMinMax {\n    fn set_min(&mut self, v: Self) -> bool;\n    fn set_max(&mut self, v: Self) -> bool;\n}\n\nimpl<T> SetMinMax for T\nwhere\n    T: PartialOrd,\n{\n    fn set_min(&mut self, v: T) -> bool {\n        *self > v && {\n            *self = v;\n            true\n        }\n    }\n    fn set_max(&mut self, v: T) -> bool {\n        *self < v && {\n            *self = v;\n            true\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(unused)] // This is defined for read! macro\nfn readln() -> String {\n    let mut line = String::new();\n    ::std::io::stdin()\n        .read_line(&mut line)\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    line\n}\n//}}}\n\n//{{{ https://github.com/ichyo/rust-algorithms.git\npub mod algonium {\n    #![doc = \" This library provides a collection of classic algorithms,\"]\n    #![doc = \" focusing on programming contests such as codeforces and atcoder.\"]\n    pub mod data_structure {\n        mod bit {\n            #[doc = \" Binary Indexed Tree (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure supports these two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[at]\"]\n            #[doc = \" 2. the sum of v[begin], v[begin+1], .., v[end-1]\"]\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            #[doc = \" Binary Indexed Tree (range-version) (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[begin], v[begin+1], ..., v[end-1]\"]\n            #[doc = \" 2. get the sum of v[begin], v[begin+1], ..., v[end-1]\"]\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {\n                #[doc = \" Constructs a new BIT of length `len`.\"]\n                #[doc = \" All values are initialized zero.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" # #[warn(unused_mut)]\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" ```\"]\n                pub fn new(len: usize) -> BIT {\n                    BIT { tree: vec![0; len] }\n                }\n                #[doc = \" Returns the number of elements in the BIT.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" assert_eq!(bit.len(), 100);\"]\n                #[doc = \" ```\"]\n                pub fn len(&self) -> usize {\n                    self.tree.len()\n                }\n                #[doc = \" Add a value `value` to a element of index `index`.\"]\n                #[doc = \" v[index] += value\"]\n                #[doc = \"\"]\n                #[doc = \" # Panics\"]\n                #[doc = \"\"]\n                #[doc = \" Panics if `index > len`\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(10);\"]\n                #[doc = \" bit.add(5, 100);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 100);\"]\n                #[doc = \" bit.add(5, 10);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 110);\"]\n                #[doc = \" ```\"]\n                pub fn add(&mut self, index: usize, value: i64) {\n                    assert!(index < self.tree.len());\n                    let mut idx = index;\n                    while idx < self.tree.len() {\n                        self.tree[idx] += value;\n                        idx |= idx + 1;\n                    }\n                }\n                #[doc = \" sum of v[idx] such that begin <= idx < end\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    let a = if end > 0 { self.cum(end - 1) } else { 0 };\n                    let b = if begin > 0 { self.cum(begin - 1) } else { 0 };\n                    a - b\n                }\n                #[doc = \" v[0] + ... + v[last]\"]\n                fn cum(&self, last: usize) -> i64 {\n                    assert!(last < self.tree.len());\n                    let mut res = 0;\n                    let mut idx = last as i64;\n                    while idx >= 0 {\n                        res += self.tree[idx as usize];\n                        idx = (idx & (idx + 1)) - 1;\n                    }\n                    res\n                }\n            }\n            impl BITRange {\n                pub fn new(n: usize) -> BITRange {\n                    BITRange {\n                        bit0: BIT::new(n + 1),\n                        bit1: BIT::new(n + 1),\n                    }\n                }\n                #[doc = \" v[begin], v[begin+1], ..., v[end-1] += by\"]\n                pub fn add(&mut self, begin: usize, end: usize, by: i64) {\n                    if begin >= end {\n                        return;\n                    }\n                    let a = begin as i64;\n                    let b = end as i64;\n                    self.bit0.add(begin, -by * a);\n                    self.bit0.add(end, by * b);\n                    self.bit1.add(begin, by);\n                    self.bit1.add(end, -by);\n                }\n                #[doc = \" v[begin] + ... + v[end-1]\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    self.cum(end) - self.cum(begin)\n                }\n                #[doc = \" v[0] + ... + v[end-1]\"]\n                fn cum(&self, end: usize) -> i64 {\n                    let a = self.bit0.get(0, end);\n                    let b = self.bit1.get(0, end);\n                    a + b * end as i64\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_add() {\n                    let mut bit = BIT::new(10);\n                    bit.add(100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_range_add() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(5, 100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_get() {\n                    let bit = BIT::new(10);\n                    bit.get(0, 1000);\n                }\n                #[test]\n                fn test_empty_range() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(9, 0, 100);\n                    bit.add(7, 3, 100);\n                    assert_eq!(0, bit.get(0, 9));\n                    assert_eq!(0, bit.get(0, 5));\n                    assert_eq!(0, bit.get(2, 5));\n                }\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        mod segment_tree {\n            use std::cmp;\n            use std::marker::PhantomData;\n            pub trait Monoid<T> {\n                fn id() -> Option<T> {\n                    None\n                }\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T>;\n            }\n            pub struct MinOp<T: Ord> {\n                phantom: PhantomData<T>,\n            }\n            impl<T: Ord + Clone> Monoid<T> for MinOp<T> {\n                #[inline]\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T> {\n                    match (l.clone(), r.clone()) {\n                        (Some(l), Some(r)) => Some(cmp::min(l, r)),\n                        (Some(l), None) => Some(l),\n                        (None, Some(r)) => Some(r),\n                        (None, None) => None,\n                    }\n                }\n            }\n            pub struct SegmentTree<M: Monoid<T>, T: Clone> {\n                phantom: PhantomData<M>,\n                data: Vec<Option<T>>,\n                size: usize,\n                size_p2: usize,\n            }\n            impl<M: Monoid<T>, T: Clone> SegmentTree<M, T> {\n                pub fn from_vec(v: Vec<T>) -> SegmentTree<M, T> {\n                    let size = v.len();\n                    let mut size_p2 = 1;\n                    while size_p2 < v.len() {\n                        size_p2 *= 2;\n                    }\n                    let mut data = vec![None; size_p2 * 2];\n                    for (i, x) in v.into_iter().enumerate() {\n                        data[size_p2 + i] = Some(x);\n                    }\n                    for i in (0..size_p2).rev() {\n                        data[i] = M::op(&data[i * 2 + 0], &data[i * 2 + 1]);\n                    }\n                    SegmentTree {\n                        phantom: PhantomData,\n                        data: data,\n                        size: size,\n                        size_p2: size_p2,\n                    }\n                }\n                pub fn size(&self) -> usize {\n                    self.size\n                }\n                pub fn update(&mut self, mut pos: usize, value: T) {\n                    assert!(pos < self.size);\n                    pos += self.size_p2;\n                    self.data[pos] = Some(value);\n                    loop {\n                        pos /= 2;\n                        if pos == 0 {\n                            break;\n                        }\n                        self.data[pos] = M::op(&self.data[pos * 2], &self.data[pos * 2 + 1]);\n                    }\n                }\n                pub fn query(&self, mut l: usize, mut r: usize) -> Option<T> {\n                    assert!(l <= r && r <= self.size);\n                    l += self.size_p2;\n                    r += self.size_p2;\n                    let mut res1 = M::id();\n                    let mut res2 = M::id();\n                    while l < r {\n                        if (l & 1) != 0 {\n                            res1 = M::op(&res1, &self.data[l]);\n                            l += 1;\n                        }\n                        if (r & 1) != 0 {\n                            r -= 1;\n                            res2 = M::op(&self.data[r], &res2);\n                        }\n                        l >>= 1;\n                        r >>= 1;\n                    }\n                    M::op(&res1, &res2)\n                }\n            }\n            #[doc = \" segment tree to get minimum value in a range\"]\n            pub type RMQ<T> = SegmentTree<MinOp<T>, T>;\n            #[cfg(test)]\n            mod tests {\n                use super::RMQ;\n                #[test]\n                fn test_rms() {\n                    let mut test = vec![1, 5, 4, 8, 6, 9, 2, 0, 8, 1];\n                    let mut rms = RMQ::from_vec(test.clone());\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                    rms.update(7, 5);\n                    test[7] = 5;\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                }\n            }\n        }\n        mod union_find {\n            #[doc = \" Disjoint-set data structure\"]\n            #[doc = \"\"]\n            #[doc = \" This provides operations for disjoint sets.\"]\n            #[doc = \" They runs in nearly constatant time.\"]\n            #[doc = \" (the actual time is `O(A(n))` where `A(n)` is the inverse of ackermann function.)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. unite(x, y) - unite a set including x and another set including y into one.\"]\n            #[doc = \" 2. same(x, y) - determine if x and y are in the same set.\"]\n            #[doc = \" 3. size(x) - calculate the number of elements of the set including x.\"]\n            #[doc = \"\"]\n            #[doc = \" [`UnionFind::new(n)`](#method.new) creates n disjoint sets. `i`-th set contains single element `i` (0-indexed).\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::data_structure::UnionFind;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut uf = UnionFind::new(4);\"]\n            #[doc = \" assert!(!uf.same(0, 1));\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(0, 1);\"]\n            #[doc = \" assert!(uf.same(0, 1));\"]\n            #[doc = \" assert_eq!(uf.size(0), 2);\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(1, 2);\"]\n            #[doc = \" assert!(uf.same(0, 2));\"]\n            #[doc = \" assert_eq!(uf.size(0), 3);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            #[doc = \" # Panics\"]\n            #[doc = \" panics if `x` or `y` is not less than number of elements given in the initialization method.\"]\n            #[doc = \"\"]\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {\n                #[doc = \" Creates a object with n disjoint sets. `i`-th set is `{ i }`.\"]\n                pub fn new(n: usize) -> UnionFind {\n                    UnionFind { data: vec![-1; n] }\n                }\n                #[doc = \" Unite a set including `x` and another set including y into one.\"]\n                #[doc = \" Returns `true` only if they were in different set.\"]\n                pub fn unite(&mut self, x: usize, y: usize) -> bool {\n                    let x = self.root(x);\n                    let y = self.root(y);\n                    if x != y {\n                        let (x, y) = if self.data[x] <= self.data[y] {\n                            (x, y)\n                        } else {\n                            (y, x)\n                        };\n                        self.data[x] += self.data[y];\n                        self.data[y] = x as i32;\n                    }\n                    x != y\n                }\n                #[doc = \" Returns `true` only if `x` and `y` are in a same set.\"]\n                pub fn same(&mut self, x: usize, y: usize) -> bool {\n                    self.root(x) == self.root(y)\n                }\n                #[doc = \" Returns the number of elements of a set including `x`.\"]\n                pub fn size(&mut self, x: usize) -> u32 {\n                    let r = self.root(x);\n                    (-self.data[r]) as u32\n                }\n                #[doc = \" internal method to return representative element of a set including `x`.\"]\n                pub fn root(&mut self, x: usize) -> usize {\n                    if self.data[x] < 0 {\n                        x\n                    } else {\n                        let nx = self.data[x] as usize;\n                        let r = self.root(nx);\n                        self.data[x] = r as i32;\n                        r\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n        pub use self::bit::{BITRange, BIT};\n        pub use self::segment_tree::{MinOp, Monoid, SegmentTree, RMQ};\n        pub use self::union_find::UnionFind;\n    }\n    pub mod math {\n        mod comb {\n            use super::mint::{Mint, Module};\n            #[doc = \" Useful struct to compute combinations\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Comb, Mod107, Mint107};\"]\n            #[doc = \" let comb: Comb<Mod107> = Comb::new(100);\"]\n            #[doc = \" assert_eq!(Mint107::from(24), comb.fact(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(1), comb.fact(4) * comb.factinv(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(12), comb.perm(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(6), comb.comb(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(10), comb.multi_comb(4, 2));\"]\n            #[doc = \" ```\"]\n            pub struct Comb<M: Module> {\n                fact: Vec<Mint<M>>,\n                factinv: Vec<Mint<M>>,\n            }\n            impl<M: Module> Comb<M> {\n                #[doc = \" Create a object that provides effiecint computation of combinations\"]\n                #[doc = \" for input smaller than `n`.\"]\n                #[doc = \"\"]\n                #[doc = \" This requires `O(n)` time.\"]\n                pub fn new(n: usize) -> Comb<M> {\n                    let mut fact: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    let mut factinv: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    fact[0] = 1.into();\n                    for i in 0..n {\n                        fact[i + 1] = fact[i] * (i + 1);\n                    }\n                    factinv[n] = fact[n].inv();\n                    for i in (0..n).rev() {\n                        factinv[i] = factinv[i + 1] * (i + 1);\n                    }\n                    Comb {\n                        fact: fact,\n                        factinv: factinv,\n                    }\n                }\n                #[doc = \" `n! = 1 * 2 * ... * n`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn fact(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.fact.get(n as usize) {\n                        *x\n                    } else if n >= M::module() as u64 {\n                        Mint::from(0)\n                    } else {\n                        let mut res = 1.into();\n                        for a in 1..(n + 1) {\n                            res *= a;\n                        }\n                        res\n                    }\n                }\n                #[doc = \" returns `y` such that `n! * y == 1`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn factinv(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.factinv.get(n as usize) {\n                        *x\n                    } else {\n                        self.fact(n).inv()\n                    }\n                }\n                #[doc = \" `nPr = n! / (n - r)!`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn perm(&self, n: u64, r: u64) -> Mint<M> {\n                    if n >= r {\n                        self.fact(n) * self.factinv((n - r) as u64)\n                    } else {\n                        0.into()\n                    }\n                }\n                #[doc = \" `nCr = n! / (n - r)! / r!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn comb(&self, n: u64, r: u64) -> Mint<M> {\n                    let m = M::module() as u64;\n                    if n >= m {\n                        self.comb(n % m, r % m) * self.comb(n / m, r / m)\n                    } else if n >= r {\n                        self.fact(n) * self.factinv(n - r) * self.factinv(r)\n                    } else {\n                        Mint::from(0)\n                    }\n                }\n                #[doc = \" `(n + k - 1)! / k!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn multi_comb(&self, n: u64, r: u64) -> Mint<M> {\n                    if r == 0 {\n                        Mint::from(1)\n                    } else {\n                        self.comb(n + r - 1, r)\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        mod mint {\n            use std::fmt;\n            use std::marker::PhantomData;\n            use std::mem;\n            use std::ops;\n            #[doc = \" Trait for `Mint`. `module()` should return prime number.\"]\n            pub trait Module: Copy + Clone {\n                fn module() -> u32;\n            }\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 7`\"]\n            pub const MOD_107: u32 = 1_000_000_007;\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 9`\"]\n            pub const MOD_109: u32 = 1_000_000_009;\n            #[doc = \" One of famous numbers in programming contest. `998_244_353`\"]\n            pub const MOD_998: u32 = 998_244_353;\n            #[doc = \" struct to implement Module trait. it returns `MOD_107`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod107;\n            impl Module for Mod107 {\n                fn module() -> u32 {\n                    MOD_107\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_109`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod109;\n            impl Module for Mod109 {\n                fn module() -> u32 {\n                    MOD_109\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_998`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod998;\n            impl Module for Mod998 {\n                fn module() -> u32 {\n                    MOD_998\n                }\n            }\n            #[doc = \" Wrapper class to compute mod `1_000_000_007` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" # // TODO: implement convert to u64\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint107 = Mint<Mod107>;\n            #[doc = \" Wrapper class to compute mod `1_000_000_009` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint109, MOD_109};\"]\n            #[doc = \" let x: Mint109 = 1234567.into();\"]\n            #[doc = \" let y: Mint109 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_109 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint109 = Mint<Mod109>;\n            #[doc = \" Wrapper class to compute mod `998_244_353` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint998, MOD_998};\"]\n            #[doc = \" let x: Mint998 = 1234567.into();\"]\n            #[doc = \" let y: Mint998 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_998 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint998 = Mint<Mod998>;\n            #[doc = \" Wrapper class to compute modulo operation.\"]\n            #[doc = \" See examples\"]\n            #[doc = \" [`Mint107`](type.Mint107.html),\"]\n            #[doc = \" [`Mint109`](type.Mint109.html),\"]\n            #[doc = \" [`Mint998`](type.Mint998.html)\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint<M: Module> {\n                #[doc = \" internal value. this is always less than `self.module()`.\"]\n                pub val: u32,\n                m: PhantomData<M>,\n            }\n            impl<M: Module> Mint<M> {\n                fn module(self) -> u32 {\n                    M::module()\n                }\n                fn new(val: u32) -> Mint<M> {\n                    assert!(val < M::module());\n                    Mint {\n                        val: val,\n                        m: PhantomData,\n                    }\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Add<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn add(self, other: T) -> Mint<M> {\n                    let nval = self.val + other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Sub<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn sub(self, other: T) -> Mint<M> {\n                    let nval = self.val + self.module() - other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Mul<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn mul(self, other: T) -> Mint<M> {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint::new((nval % (self.module() as u64)) as u32)\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Div<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn div(self, other: T) -> Mint<M> {\n                    self * other.into().inv()\n                }\n            }\n            impl<M: Module> Mint<M> {\n                #[doc = \" Returns number `y` that satisfies `x * y == 1` where `x` is the original value.\"]\n                #[doc = \"\"]\n                #[doc = \" This assumes `module()` returns prime number.\"]\n                pub fn inv(self) -> Mint<M> {\n                    let mut a = self.val as i32;\n                    let mut b = self.module() as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        mem::swap(&mut u, &mut v);\n                    }\n                    Mint::new(if u < 0 { u + self.module() as i32 } else { u } as u32)\n                }\n            }\n            impl<M: Module> PartialEq for Mint<M> {\n                fn eq(&self, other: &Mint<M>) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl<M: Module> fmt::Display for Mint<M> {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules ! impl_signed_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = ( x as i64 ) % ( M :: module ( ) as i64 ) ; if x >= 0 { Mint { val : t as u32 , m : PhantomData } } else { Mint { val : ( M :: module ( ) as i64 + t ) as u32 , m : PhantomData } } } } ) * ) }\n            macro_rules ! impl_unsigned_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = x as u64 % M :: module ( ) as u64 ; Mint :: new ( t as u32 ) } } ) * ) }\n            impl_signed_mint! { i8 i16 i32 i64 isize }\n            impl_unsigned_mint! { u8 u16 u32 u64 usize }\n            impl<T: Into<Mint<M>>, M: Module> ops::AddAssign<T> for Mint<M> {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::SubAssign<T> for Mint<M> {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::MulAssign<T> for Mint<M> {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::DivAssign<T> for Mint<M> {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint<Mod107> = Mint::from(3);\n                    let b: Mint<Mod107> = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % Mod107::module() as u64), a * b);\n                }\n            }\n        }\n        pub use self::comb::Comb;\n        pub use self::mint::{Mint, Module};\n        pub use self::mint::{Mint107, Mint109, Mint998};\n        pub use self::mint::{Mod107, Mod109, Mod998};\n        pub use self::mint::{MOD_107, MOD_109, MOD_998};\n    }\n    pub mod util {\n        mod permutation {\n            #[doc = \" It contains same methods as `std::next_permutaion` in C++.\"]\n            #[doc = \" these methods should rearrange the elements into the next/prev lexicographically greater permutation.\"]\n            #[doc = \"\"]\n            #[doc = \" This is implemented in [T] where T is Ord.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::Permutation;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [5, 0, 9, 2];\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 9, 0]);\"]\n            #[doc = \" assert!(perm.prev_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [4, 3, 2, 1, 0];\"]\n            #[doc = \" assert!(!perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [4, 3, 2, 1, 0]);\"]\n            #[doc = \" ```\"]\n            pub trait Permutation {\n                #[doc = \" It rearranges the elements into the next lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the last permutation.\"]\n                fn next_permutation(&mut self) -> bool;\n                #[doc = \" It rearranges the elements into the previous lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the first permutation.\"]\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        mod random {\n            use std::num::Wrapping;\n            #[doc = \" Not secure but fast random generator.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::XorShift;\"]\n            #[doc = \" let mut xorshift = XorShift::new();\"]\n            #[doc = \" assert_eq!(3701687786, xorshift.next_u32());\"]\n            #[doc = \" assert_eq!(458299110, xorshift.next_u32());\"]\n            #[doc = \" ```\"]\n            #[derive(Clone, Debug, Default)]\n            pub struct XorShift {\n                x: Wrapping<u32>,\n                y: Wrapping<u32>,\n                z: Wrapping<u32>,\n                w: Wrapping<u32>,\n            }\n            impl XorShift {\n                #[doc = \" Create object with default seed.\"]\n                pub fn new() -> XorShift {\n                    XorShift {\n                        x: Wrapping(123_456_789),\n                        y: Wrapping(362_436_069),\n                        z: Wrapping(521_288_629),\n                        w: Wrapping(88_675_123),\n                    }\n                }\n                #[doc = \" Get next random u32 number.\"]\n                pub fn next_u32(&mut self) -> u32 {\n                    let x = self.x;\n                    let t = x ^ (x << 11);\n                    self.x = self.y;\n                    self.y = self.z;\n                    self.z = self.w;\n                    let v = self.w;\n                    self.w = v ^ (v >> 19) ^ (t ^ (t >> 8));\n                    self.w.0\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::XorShift;\n                #[test]\n                fn test_basic() {\n                    let mut xorshift = XorShift::new();\n                    assert_eq!(3701687786, xorshift.next_u32());\n                    assert_eq!(458299110, xorshift.next_u32());\n                }\n            }\n        }\n        pub use self::permutation::Permutation;\n        pub use self::random::XorShift;\n    }\n}\n\n//}}}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, non_snake_case)]\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n\n// {{{ input!\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n//}}}\n\n//{{{ read!\nmacro_rules! read {\n\t($($t:tt),*; $n:expr) => {{\n\t\tlet stdin = ::std::io::stdin();\n\t\tlet ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n\t\t\tlet line = line.unwrap();\n\t\t\tlet mut it = line.split_whitespace();\n\t\t\t_read!(it; $($t),*)\n\t\t}).collect::<Vec<_>>();\n\t\tret\n\t}};\n\t($($t:tt),*) => {{\n\t\tlet line = readln();\n\t\tlet mut it = line.split_whitespace();\n\t\t_read!(it; $($t),*)\n\t}};\n}\n\nmacro_rules! _read {\n\t($it:ident; [char]) => {\n\t\t_read!($it; String).chars().collect::<Vec<_>>()\n\t};\n\t($it:ident; [u8]) => {\n\t\tVec::from(_read!($it; String).into_bytes())\n\t};\n\t($it:ident; [$t:ty]) => {\n\t\t$it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n\t};\n\t($it:ident; $t:ty) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n\t};\n\t($it:ident; $($t:ty),+) => {\n\t\t($(_read!($it; $t)),*)\n\t};\n}\n//}}}\n\n//{{{ utility macros missing in 1.15.1\n// https://atcoder.jp/contests/nikkei2019-qual/submissions/4098548\nmacro_rules! eprint {\n\t($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = write!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! eprintln {\n\t() => { eprintln!(\"\"); };\n\t($($t:tt)*) => {{\n\t    use ::std::io::Write;\n            let _ = writeln!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! dbg {\n    ($val:expr) => {\n        match $val {\n            tmp => {\n                eprintln!(\n                    \"[{}:{}] {} = {:#?}\",\n                    file!(),\n                    line!(),\n                    stringify!($val),\n                    &tmp\n                );\n                tmp\n            }\n        }\n    };\n}\n//}}}\n\nfn run() {\n    input! {\n        n: usize,\n        a: usize,\n        b: usize,\n        p: [usize1; n],\n    }\n    let mut inv = vec![0; n];\n    for i in 0..n {\n        inv[p[i]] = i;\n    }\n    let mut left = vec![vec![0; n + 1]; n + 1];\n    let mut right = vec![vec![0; n + 1]; n + 1];\n    let mut dp = vec![vec![usize::max_value(); n + 1]; n + 1];\n    for i in 0..n {\n        dp[i][i + 1] = 0;\n        left[i][i + 1] = inv[i];\n        right[i][i + 1] = inv[i];\n    }\n    for l in 1..n {\n        for i in 0..n {\n            let j = i + l;\n            if j > n {\n                continue;\n            }\n\n            if j < n {\n                let new_elem = j;\n                let place = inv[new_elem];\n                let (new_i, new_j) = (i, j + 1);\n                let cost = if right[i][j] <= place { 0 } else { a };\n                let new_dp = dp[i][j] + cost;\n                dp[new_i][new_j].set_min(new_dp);\n                left[new_i][new_j].set_min(place);\n                right[new_i][new_j].set_max(place);\n            }\n            if i > 0 {\n                let new_elem = i - 1;\n                let place = inv[new_elem];\n                let (new_i, new_j) = (i - 1, j);\n                let cost = if left[i][j] >= place { 0 } else { b };\n                let new_dp = dp[i][j] + cost;\n                dp[new_i][new_j].set_min(new_dp);\n                left[new_i][new_j].set_min(place);\n                right[new_i][new_j].set_max(place);\n            }\n        }\n    }\n    println!(\"{}\", dp[0][n]);\n}\n\n//{{{ template\nfn main() {\n    let _ = ::std::thread::Builder::new()\n        .name(\"run\".to_string())\n        .stack_size(256 * 1024 * 1024)\n        .spawn(run)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\npub trait SetMinMax {\n    fn set_min(&mut self, v: Self) -> bool;\n    fn set_max(&mut self, v: Self) -> bool;\n}\n\nimpl<T> SetMinMax for T\nwhere\n    T: PartialOrd,\n{\n    fn set_min(&mut self, v: T) -> bool {\n        *self > v && {\n            *self = v;\n            true\n        }\n    }\n    fn set_max(&mut self, v: T) -> bool {\n        *self < v && {\n            *self = v;\n            true\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(unused)] // This is defined for read! macro\nfn readln() -> String {\n    let mut line = String::new();\n    ::std::io::stdin()\n        .read_line(&mut line)\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    line\n}\n//}}}\n\n//{{{ https://github.com/ichyo/rust-algorithms.git\npub mod algonium {\n    #![doc = \" This library provides a collection of classic algorithms,\"]\n    #![doc = \" focusing on programming contests such as codeforces and atcoder.\"]\n    pub mod data_structure {\n        mod bit {\n            #[doc = \" Binary Indexed Tree (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure supports these two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[at]\"]\n            #[doc = \" 2. the sum of v[begin], v[begin+1], .., v[end-1]\"]\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            #[doc = \" Binary Indexed Tree (range-version) (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[begin], v[begin+1], ..., v[end-1]\"]\n            #[doc = \" 2. get the sum of v[begin], v[begin+1], ..., v[end-1]\"]\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {\n                #[doc = \" Constructs a new BIT of length `len`.\"]\n                #[doc = \" All values are initialized zero.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" # #[warn(unused_mut)]\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" ```\"]\n                pub fn new(len: usize) -> BIT {\n                    BIT { tree: vec![0; len] }\n                }\n                #[doc = \" Returns the number of elements in the BIT.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" assert_eq!(bit.len(), 100);\"]\n                #[doc = \" ```\"]\n                pub fn len(&self) -> usize {\n                    self.tree.len()\n                }\n                #[doc = \" Add a value `value` to a element of index `index`.\"]\n                #[doc = \" v[index] += value\"]\n                #[doc = \"\"]\n                #[doc = \" # Panics\"]\n                #[doc = \"\"]\n                #[doc = \" Panics if `index > len`\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(10);\"]\n                #[doc = \" bit.add(5, 100);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 100);\"]\n                #[doc = \" bit.add(5, 10);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 110);\"]\n                #[doc = \" ```\"]\n                pub fn add(&mut self, index: usize, value: i64) {\n                    assert!(index < self.tree.len());\n                    let mut idx = index;\n                    while idx < self.tree.len() {\n                        self.tree[idx] += value;\n                        idx |= idx + 1;\n                    }\n                }\n                #[doc = \" sum of v[idx] such that begin <= idx < end\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    let a = if end > 0 { self.cum(end - 1) } else { 0 };\n                    let b = if begin > 0 { self.cum(begin - 1) } else { 0 };\n                    a - b\n                }\n                #[doc = \" v[0] + ... + v[last]\"]\n                fn cum(&self, last: usize) -> i64 {\n                    assert!(last < self.tree.len());\n                    let mut res = 0;\n                    let mut idx = last as i64;\n                    while idx >= 0 {\n                        res += self.tree[idx as usize];\n                        idx = (idx & (idx + 1)) - 1;\n                    }\n                    res\n                }\n            }\n            impl BITRange {\n                pub fn new(n: usize) -> BITRange {\n                    BITRange {\n                        bit0: BIT::new(n + 1),\n                        bit1: BIT::new(n + 1),\n                    }\n                }\n                #[doc = \" v[begin], v[begin+1], ..., v[end-1] += by\"]\n                pub fn add(&mut self, begin: usize, end: usize, by: i64) {\n                    if begin >= end {\n                        return;\n                    }\n                    let a = begin as i64;\n                    let b = end as i64;\n                    self.bit0.add(begin, -by * a);\n                    self.bit0.add(end, by * b);\n                    self.bit1.add(begin, by);\n                    self.bit1.add(end, -by);\n                }\n                #[doc = \" v[begin] + ... + v[end-1]\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    self.cum(end) - self.cum(begin)\n                }\n                #[doc = \" v[0] + ... + v[end-1]\"]\n                fn cum(&self, end: usize) -> i64 {\n                    let a = self.bit0.get(0, end);\n                    let b = self.bit1.get(0, end);\n                    a + b * end as i64\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_add() {\n                    let mut bit = BIT::new(10);\n                    bit.add(100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_range_add() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(5, 100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_get() {\n                    let bit = BIT::new(10);\n                    bit.get(0, 1000);\n                }\n                #[test]\n                fn test_empty_range() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(9, 0, 100);\n                    bit.add(7, 3, 100);\n                    assert_eq!(0, bit.get(0, 9));\n                    assert_eq!(0, bit.get(0, 5));\n                    assert_eq!(0, bit.get(2, 5));\n                }\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        mod segment_tree {\n            use std::cmp;\n            use std::marker::PhantomData;\n            pub trait Monoid<T> {\n                fn id() -> Option<T> {\n                    None\n                }\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T>;\n            }\n            pub struct MinOp<T: Ord> {\n                phantom: PhantomData<T>,\n            }\n            impl<T: Ord + Clone> Monoid<T> for MinOp<T> {\n                #[inline]\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T> {\n                    match (l.clone(), r.clone()) {\n                        (Some(l), Some(r)) => Some(cmp::min(l, r)),\n                        (Some(l), None) => Some(l),\n                        (None, Some(r)) => Some(r),\n                        (None, None) => None,\n                    }\n                }\n            }\n            pub struct SegmentTree<M: Monoid<T>, T: Clone> {\n                phantom: PhantomData<M>,\n                data: Vec<Option<T>>,\n                size: usize,\n                size_p2: usize,\n            }\n            impl<M: Monoid<T>, T: Clone> SegmentTree<M, T> {\n                pub fn from_vec(v: Vec<T>) -> SegmentTree<M, T> {\n                    let size = v.len();\n                    let mut size_p2 = 1;\n                    while size_p2 < v.len() {\n                        size_p2 *= 2;\n                    }\n                    let mut data = vec![None; size_p2 * 2];\n                    for (i, x) in v.into_iter().enumerate() {\n                        data[size_p2 + i] = Some(x);\n                    }\n                    for i in (0..size_p2).rev() {\n                        data[i] = M::op(&data[i * 2 + 0], &data[i * 2 + 1]);\n                    }\n                    SegmentTree {\n                        phantom: PhantomData,\n                        data: data,\n                        size: size,\n                        size_p2: size_p2,\n                    }\n                }\n                pub fn size(&self) -> usize {\n                    self.size\n                }\n                pub fn update(&mut self, mut pos: usize, value: T) {\n                    assert!(pos < self.size);\n                    pos += self.size_p2;\n                    self.data[pos] = Some(value);\n                    loop {\n                        pos /= 2;\n                        if pos == 0 {\n                            break;\n                        }\n                        self.data[pos] = M::op(&self.data[pos * 2], &self.data[pos * 2 + 1]);\n                    }\n                }\n                pub fn query(&self, mut l: usize, mut r: usize) -> Option<T> {\n                    assert!(l <= r && r <= self.size);\n                    l += self.size_p2;\n                    r += self.size_p2;\n                    let mut res1 = M::id();\n                    let mut res2 = M::id();\n                    while l < r {\n                        if (l & 1) != 0 {\n                            res1 = M::op(&res1, &self.data[l]);\n                            l += 1;\n                        }\n                        if (r & 1) != 0 {\n                            r -= 1;\n                            res2 = M::op(&self.data[r], &res2);\n                        }\n                        l >>= 1;\n                        r >>= 1;\n                    }\n                    M::op(&res1, &res2)\n                }\n            }\n            #[doc = \" segment tree to get minimum value in a range\"]\n            pub type RMQ<T> = SegmentTree<MinOp<T>, T>;\n            #[cfg(test)]\n            mod tests {\n                use super::RMQ;\n                #[test]\n                fn test_rms() {\n                    let mut test = vec![1, 5, 4, 8, 6, 9, 2, 0, 8, 1];\n                    let mut rms = RMQ::from_vec(test.clone());\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                    rms.update(7, 5);\n                    test[7] = 5;\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                }\n            }\n        }\n        mod union_find {\n            #[doc = \" Disjoint-set data structure\"]\n            #[doc = \"\"]\n            #[doc = \" This provides operations for disjoint sets.\"]\n            #[doc = \" They runs in nearly constatant time.\"]\n            #[doc = \" (the actual time is `O(A(n))` where `A(n)` is the inverse of ackermann function.)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. unite(x, y) - unite a set including x and another set including y into one.\"]\n            #[doc = \" 2. same(x, y) - determine if x and y are in the same set.\"]\n            #[doc = \" 3. size(x) - calculate the number of elements of the set including x.\"]\n            #[doc = \"\"]\n            #[doc = \" [`UnionFind::new(n)`](#method.new) creates n disjoint sets. `i`-th set contains single element `i` (0-indexed).\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::data_structure::UnionFind;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut uf = UnionFind::new(4);\"]\n            #[doc = \" assert!(!uf.same(0, 1));\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(0, 1);\"]\n            #[doc = \" assert!(uf.same(0, 1));\"]\n            #[doc = \" assert_eq!(uf.size(0), 2);\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(1, 2);\"]\n            #[doc = \" assert!(uf.same(0, 2));\"]\n            #[doc = \" assert_eq!(uf.size(0), 3);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            #[doc = \" # Panics\"]\n            #[doc = \" panics if `x` or `y` is not less than number of elements given in the initialization method.\"]\n            #[doc = \"\"]\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {\n                #[doc = \" Creates a object with n disjoint sets. `i`-th set is `{ i }`.\"]\n                pub fn new(n: usize) -> UnionFind {\n                    UnionFind { data: vec![-1; n] }\n                }\n                #[doc = \" Unite a set including `x` and another set including y into one.\"]\n                #[doc = \" Returns `true` only if they were in different set.\"]\n                pub fn unite(&mut self, x: usize, y: usize) -> bool {\n                    let x = self.root(x);\n                    let y = self.root(y);\n                    if x != y {\n                        let (x, y) = if self.data[x] <= self.data[y] {\n                            (x, y)\n                        } else {\n                            (y, x)\n                        };\n                        self.data[x] += self.data[y];\n                        self.data[y] = x as i32;\n                    }\n                    x != y\n                }\n                #[doc = \" Returns `true` only if `x` and `y` are in a same set.\"]\n                pub fn same(&mut self, x: usize, y: usize) -> bool {\n                    self.root(x) == self.root(y)\n                }\n                #[doc = \" Returns the number of elements of a set including `x`.\"]\n                pub fn size(&mut self, x: usize) -> u32 {\n                    let r = self.root(x);\n                    (-self.data[r]) as u32\n                }\n                #[doc = \" internal method to return representative element of a set including `x`.\"]\n                pub fn root(&mut self, x: usize) -> usize {\n                    if self.data[x] < 0 {\n                        x\n                    } else {\n                        let nx = self.data[x] as usize;\n                        let r = self.root(nx);\n                        self.data[x] = r as i32;\n                        r\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n        pub use self::bit::{BITRange, BIT};\n        pub use self::segment_tree::{MinOp, Monoid, SegmentTree, RMQ};\n        pub use self::union_find::UnionFind;\n    }\n    pub mod math {\n        mod comb {\n            use super::mint::{Mint, Module};\n            #[doc = \" Useful struct to compute combinations\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Comb, Mod107, Mint107};\"]\n            #[doc = \" let comb: Comb<Mod107> = Comb::new(100);\"]\n            #[doc = \" assert_eq!(Mint107::from(24), comb.fact(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(1), comb.fact(4) * comb.factinv(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(12), comb.perm(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(6), comb.comb(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(10), comb.multi_comb(4, 2));\"]\n            #[doc = \" ```\"]\n            pub struct Comb<M: Module> {\n                fact: Vec<Mint<M>>,\n                factinv: Vec<Mint<M>>,\n            }\n            impl<M: Module> Comb<M> {\n                #[doc = \" Create a object that provides effiecint computation of combinations\"]\n                #[doc = \" for input smaller than `n`.\"]\n                #[doc = \"\"]\n                #[doc = \" This requires `O(n)` time.\"]\n                pub fn new(n: usize) -> Comb<M> {\n                    let mut fact: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    let mut factinv: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    fact[0] = 1.into();\n                    for i in 0..n {\n                        fact[i + 1] = fact[i] * (i + 1);\n                    }\n                    factinv[n] = fact[n].inv();\n                    for i in (0..n).rev() {\n                        factinv[i] = factinv[i + 1] * (i + 1);\n                    }\n                    Comb {\n                        fact: fact,\n                        factinv: factinv,\n                    }\n                }\n                #[doc = \" `n! = 1 * 2 * ... * n`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn fact(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.fact.get(n as usize) {\n                        *x\n                    } else if n >= M::module() as u64 {\n                        Mint::from(0)\n                    } else {\n                        let mut res = 1.into();\n                        for a in 1..(n + 1) {\n                            res *= a;\n                        }\n                        res\n                    }\n                }\n                #[doc = \" returns `y` such that `n! * y == 1`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn factinv(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.factinv.get(n as usize) {\n                        *x\n                    } else {\n                        self.fact(n).inv()\n                    }\n                }\n                #[doc = \" `nPr = n! / (n - r)!`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn perm(&self, n: u64, r: u64) -> Mint<M> {\n                    if n >= r {\n                        self.fact(n) * self.factinv((n - r) as u64)\n                    } else {\n                        0.into()\n                    }\n                }\n                #[doc = \" `nCr = n! / (n - r)! / r!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn comb(&self, n: u64, r: u64) -> Mint<M> {\n                    let m = M::module() as u64;\n                    if n >= m {\n                        self.comb(n % m, r % m) * self.comb(n / m, r / m)\n                    } else if n >= r {\n                        self.fact(n) * self.factinv(n - r) * self.factinv(r)\n                    } else {\n                        Mint::from(0)\n                    }\n                }\n                #[doc = \" `(n + k - 1)! / k!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn multi_comb(&self, n: u64, r: u64) -> Mint<M> {\n                    if r == 0 {\n                        Mint::from(1)\n                    } else {\n                        self.comb(n + r - 1, r)\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        mod mint {\n            use std::fmt;\n            use std::marker::PhantomData;\n            use std::mem;\n            use std::ops;\n            #[doc = \" Trait for `Mint`. `module()` should return prime number.\"]\n            pub trait Module: Copy + Clone {\n                fn module() -> u32;\n            }\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 7`\"]\n            pub const MOD_107: u32 = 1_000_000_007;\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 9`\"]\n            pub const MOD_109: u32 = 1_000_000_009;\n            #[doc = \" One of famous numbers in programming contest. `998_244_353`\"]\n            pub const MOD_998: u32 = 998_244_353;\n            #[doc = \" struct to implement Module trait. it returns `MOD_107`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod107;\n            impl Module for Mod107 {\n                fn module() -> u32 {\n                    MOD_107\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_109`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod109;\n            impl Module for Mod109 {\n                fn module() -> u32 {\n                    MOD_109\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_998`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod998;\n            impl Module for Mod998 {\n                fn module() -> u32 {\n                    MOD_998\n                }\n            }\n            #[doc = \" Wrapper class to compute mod `1_000_000_007` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" # // TODO: implement convert to u64\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint107 = Mint<Mod107>;\n            #[doc = \" Wrapper class to compute mod `1_000_000_009` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint109, MOD_109};\"]\n            #[doc = \" let x: Mint109 = 1234567.into();\"]\n            #[doc = \" let y: Mint109 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_109 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint109 = Mint<Mod109>;\n            #[doc = \" Wrapper class to compute mod `998_244_353` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint998, MOD_998};\"]\n            #[doc = \" let x: Mint998 = 1234567.into();\"]\n            #[doc = \" let y: Mint998 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_998 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint998 = Mint<Mod998>;\n            #[doc = \" Wrapper class to compute modulo operation.\"]\n            #[doc = \" See examples\"]\n            #[doc = \" [`Mint107`](type.Mint107.html),\"]\n            #[doc = \" [`Mint109`](type.Mint109.html),\"]\n            #[doc = \" [`Mint998`](type.Mint998.html)\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint<M: Module> {\n                #[doc = \" internal value. this is always less than `self.module()`.\"]\n                pub val: u32,\n                m: PhantomData<M>,\n            }\n            impl<M: Module> Mint<M> {\n                fn module(self) -> u32 {\n                    M::module()\n                }\n                fn new(val: u32) -> Mint<M> {\n                    assert!(val < M::module());\n                    Mint {\n                        val: val,\n                        m: PhantomData,\n                    }\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Add<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn add(self, other: T) -> Mint<M> {\n                    let nval = self.val + other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Sub<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn sub(self, other: T) -> Mint<M> {\n                    let nval = self.val + self.module() - other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Mul<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn mul(self, other: T) -> Mint<M> {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint::new((nval % (self.module() as u64)) as u32)\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Div<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn div(self, other: T) -> Mint<M> {\n                    self * other.into().inv()\n                }\n            }\n            impl<M: Module> Mint<M> {\n                #[doc = \" Returns number `y` that satisfies `x * y == 1` where `x` is the original value.\"]\n                #[doc = \"\"]\n                #[doc = \" This assumes `module()` returns prime number.\"]\n                pub fn inv(self) -> Mint<M> {\n                    let mut a = self.val as i32;\n                    let mut b = self.module() as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        mem::swap(&mut u, &mut v);\n                    }\n                    Mint::new(if u < 0 { u + self.module() as i32 } else { u } as u32)\n                }\n            }\n            impl<M: Module> PartialEq for Mint<M> {\n                fn eq(&self, other: &Mint<M>) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl<M: Module> fmt::Display for Mint<M> {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules ! impl_signed_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = ( x as i64 ) % ( M :: module ( ) as i64 ) ; if x >= 0 { Mint { val : t as u32 , m : PhantomData } } else { Mint { val : ( M :: module ( ) as i64 + t ) as u32 , m : PhantomData } } } } ) * ) }\n            macro_rules ! impl_unsigned_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = x as u64 % M :: module ( ) as u64 ; Mint :: new ( t as u32 ) } } ) * ) }\n            impl_signed_mint! { i8 i16 i32 i64 isize }\n            impl_unsigned_mint! { u8 u16 u32 u64 usize }\n            impl<T: Into<Mint<M>>, M: Module> ops::AddAssign<T> for Mint<M> {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::SubAssign<T> for Mint<M> {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::MulAssign<T> for Mint<M> {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::DivAssign<T> for Mint<M> {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint<Mod107> = Mint::from(3);\n                    let b: Mint<Mod107> = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % Mod107::module() as u64), a * b);\n                }\n            }\n        }\n        pub use self::comb::Comb;\n        pub use self::mint::{Mint, Module};\n        pub use self::mint::{Mint107, Mint109, Mint998};\n        pub use self::mint::{Mod107, Mod109, Mod998};\n        pub use self::mint::{MOD_107, MOD_109, MOD_998};\n    }\n    pub mod util {\n        mod permutation {\n            #[doc = \" It contains same methods as `std::next_permutaion` in C++.\"]\n            #[doc = \" these methods should rearrange the elements into the next/prev lexicographically greater permutation.\"]\n            #[doc = \"\"]\n            #[doc = \" This is implemented in [T] where T is Ord.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::Permutation;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [5, 0, 9, 2];\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 9, 0]);\"]\n            #[doc = \" assert!(perm.prev_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [4, 3, 2, 1, 0];\"]\n            #[doc = \" assert!(!perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [4, 3, 2, 1, 0]);\"]\n            #[doc = \" ```\"]\n            pub trait Permutation {\n                #[doc = \" It rearranges the elements into the next lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the last permutation.\"]\n                fn next_permutation(&mut self) -> bool;\n                #[doc = \" It rearranges the elements into the previous lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the first permutation.\"]\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        mod random {\n            use std::num::Wrapping;\n            #[doc = \" Not secure but fast random generator.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::XorShift;\"]\n            #[doc = \" let mut xorshift = XorShift::new();\"]\n            #[doc = \" assert_eq!(3701687786, xorshift.next_u32());\"]\n            #[doc = \" assert_eq!(458299110, xorshift.next_u32());\"]\n            #[doc = \" ```\"]\n            #[derive(Clone, Debug, Default)]\n            pub struct XorShift {\n                x: Wrapping<u32>,\n                y: Wrapping<u32>,\n                z: Wrapping<u32>,\n                w: Wrapping<u32>,\n            }\n            impl XorShift {\n                #[doc = \" Create object with default seed.\"]\n                pub fn new() -> XorShift {\n                    XorShift {\n                        x: Wrapping(123_456_789),\n                        y: Wrapping(362_436_069),\n                        z: Wrapping(521_288_629),\n                        w: Wrapping(88_675_123),\n                    }\n                }\n                #[doc = \" Get next random u32 number.\"]\n                pub fn next_u32(&mut self) -> u32 {\n                    let x = self.x;\n                    let t = x ^ (x << 11);\n                    self.x = self.y;\n                    self.y = self.z;\n                    self.z = self.w;\n                    let v = self.w;\n                    self.w = v ^ (v >> 19) ^ (t ^ (t >> 8));\n                    self.w.0\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::XorShift;\n                #[test]\n                fn test_basic() {\n                    let mut xorshift = XorShift::new();\n                    assert_eq!(3701687786, xorshift.next_u32());\n                    assert_eq!(458299110, xorshift.next_u32());\n                }\n            }\n        }\n        pub use self::permutation::Permutation;\n        pub use self::random::XorShift;\n    }\n}\n\n//}}}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, non_snake_case)]\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n\n// {{{ input!\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n//}}}\n\n//{{{ read!\nmacro_rules! read {\n\t($($t:tt),*; $n:expr) => {{\n\t\tlet stdin = ::std::io::stdin();\n\t\tlet ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n\t\t\tlet line = line.unwrap();\n\t\t\tlet mut it = line.split_whitespace();\n\t\t\t_read!(it; $($t),*)\n\t\t}).collect::<Vec<_>>();\n\t\tret\n\t}};\n\t($($t:tt),*) => {{\n\t\tlet line = readln();\n\t\tlet mut it = line.split_whitespace();\n\t\t_read!(it; $($t),*)\n\t}};\n}\n\nmacro_rules! _read {\n\t($it:ident; [char]) => {\n\t\t_read!($it; String).chars().collect::<Vec<_>>()\n\t};\n\t($it:ident; [u8]) => {\n\t\tVec::from(_read!($it; String).into_bytes())\n\t};\n\t($it:ident; [$t:ty]) => {\n\t\t$it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n\t};\n\t($it:ident; $t:ty) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n\t};\n\t($it:ident; $($t:ty),+) => {\n\t\t($(_read!($it; $t)),*)\n\t};\n}\n//}}}\n\n//{{{ utility macros missing in 1.15.1\n// https://atcoder.jp/contests/nikkei2019-qual/submissions/4098548\nmacro_rules! eprint {\n\t($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = write!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! eprintln {\n\t() => { eprintln!(\"\"); };\n\t($($t:tt)*) => {{\n\t    use ::std::io::Write;\n            let _ = writeln!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! dbg {\n    ($val:expr) => {\n        match $val {\n            tmp => {\n                eprintln!(\n                    \"[{}:{}] {} = {:#?}\",\n                    file!(),\n                    line!(),\n                    stringify!($val),\n                    &tmp\n                );\n                tmp\n            }\n        }\n    };\n}\n//}}}\n\nfn run() {\n    input! {\n        n: usize,\n        a: usize,\n        b: usize,\n        p: [usize1; n],\n    }\n    let mut inv = vec![usize::max_value(); n];\n    for i in 0..n {\n        inv[p[i]] = i;\n    }\n\n    let mut left = vec![vec![usize::max_value(); n + 1]; n + 1];\n    let mut right = vec![vec![usize::max_value(); n + 1]; n + 1];\n    let mut dp = vec![vec![usize::max_value(); n + 1]; n + 1];\n    for i in 0..n {\n        dp[i][i + 1] = 0;\n        left[i][i + 1] = inv[i];\n        right[i][i + 1] = inv[i];\n    }\n    for l in 1..n + 1 {\n        for i in 0..n {\n            let j = i + l;\n            if j <= n {\n                assert!(left[i][j] != usize::max_value());\n                assert!(right[i][j] != usize::max_value());\n                assert!(dp[i][j] != usize::max_value());\n\n                if j < n {\n                    let place = inv[j];\n                    assert!(place != usize::max_value());\n                    let (new_i, new_j) = (i, j + 1);\n                    assert!(right[i][j] != place);\n                    let cost = if right[i][j] <= place { 0 } else { a };\n\n                    let new_dp = min(dp[new_i][new_j], dp[i][j] + cost);\n                    let new_left = min(left[i][j], place);\n                    let new_right = max(right[i][j], place);\n\n                    dp[new_i][new_j] = new_dp;\n                    left[new_i][new_j] = new_left;\n                    right[new_i][new_j] = new_right;\n                }\n                if i > 0 {\n                    let place = inv[i - 1];\n                    assert!(place != usize::max_value());\n                    let (new_i, new_j) = (i - 1, j);\n                    assert!(left[i][j] != place);\n                    let cost = if left[i][j] >= place { 0 } else { b };\n\n                    let new_dp = min(dp[new_i][new_j], dp[i][j] + cost);\n                    let new_left = min(left[i][j], place);\n                    let new_right = max(right[i][j], place);\n\n                    dp[new_i][new_j] = new_dp;\n                    left[new_i][new_j] = new_left;\n                    right[new_i][new_j] = new_right;\n                }\n            }\n        }\n    }\n    println!(\"{}\", dp[0][n]);\n}\n\n//{{{ template\nfn main() {\n    let _ = ::std::thread::Builder::new()\n        .name(\"run\".to_string())\n        .stack_size(256 * 1024 * 1024)\n        .spawn(run)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\npub trait SetMinMax {\n    fn set_min(&mut self, v: Self) -> bool;\n    fn set_max(&mut self, v: Self) -> bool;\n}\n\nimpl<T> SetMinMax for T\nwhere\n    T: PartialOrd,\n{\n    fn set_min(&mut self, v: T) -> bool {\n        *self > v && {\n            *self = v;\n            true\n        }\n    }\n    fn set_max(&mut self, v: T) -> bool {\n        *self < v && {\n            *self = v;\n            true\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(unused)] // This is defined for read! macro\nfn readln() -> String {\n    let mut line = String::new();\n    ::std::io::stdin()\n        .read_line(&mut line)\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    line\n}\n//}}}\n\n//{{{ https://github.com/ichyo/rust-algorithms.git\npub mod algonium {\n    #![doc = \" This library provides a collection of classic algorithms,\"]\n    #![doc = \" focusing on programming contests such as codeforces and atcoder.\"]\n    pub mod data_structure {\n        mod bit {\n            #[doc = \" Binary Indexed Tree (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure supports these two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[at]\"]\n            #[doc = \" 2. the sum of v[begin], v[begin+1], .., v[end-1]\"]\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            #[doc = \" Binary Indexed Tree (range-version) (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[begin], v[begin+1], ..., v[end-1]\"]\n            #[doc = \" 2. get the sum of v[begin], v[begin+1], ..., v[end-1]\"]\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {\n                #[doc = \" Constructs a new BIT of length `len`.\"]\n                #[doc = \" All values are initialized zero.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" # #[warn(unused_mut)]\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" ```\"]\n                pub fn new(len: usize) -> BIT {\n                    BIT { tree: vec![0; len] }\n                }\n                #[doc = \" Returns the number of elements in the BIT.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" assert_eq!(bit.len(), 100);\"]\n                #[doc = \" ```\"]\n                pub fn len(&self) -> usize {\n                    self.tree.len()\n                }\n                #[doc = \" Add a value `value` to a element of index `index`.\"]\n                #[doc = \" v[index] += value\"]\n                #[doc = \"\"]\n                #[doc = \" # Panics\"]\n                #[doc = \"\"]\n                #[doc = \" Panics if `index > len`\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(10);\"]\n                #[doc = \" bit.add(5, 100);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 100);\"]\n                #[doc = \" bit.add(5, 10);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 110);\"]\n                #[doc = \" ```\"]\n                pub fn add(&mut self, index: usize, value: i64) {\n                    assert!(index < self.tree.len());\n                    let mut idx = index;\n                    while idx < self.tree.len() {\n                        self.tree[idx] += value;\n                        idx |= idx + 1;\n                    }\n                }\n                #[doc = \" sum of v[idx] such that begin <= idx < end\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    let a = if end > 0 { self.cum(end - 1) } else { 0 };\n                    let b = if begin > 0 { self.cum(begin - 1) } else { 0 };\n                    a - b\n                }\n                #[doc = \" v[0] + ... + v[last]\"]\n                fn cum(&self, last: usize) -> i64 {\n                    assert!(last < self.tree.len());\n                    let mut res = 0;\n                    let mut idx = last as i64;\n                    while idx >= 0 {\n                        res += self.tree[idx as usize];\n                        idx = (idx & (idx + 1)) - 1;\n                    }\n                    res\n                }\n            }\n            impl BITRange {\n                pub fn new(n: usize) -> BITRange {\n                    BITRange {\n                        bit0: BIT::new(n + 1),\n                        bit1: BIT::new(n + 1),\n                    }\n                }\n                #[doc = \" v[begin], v[begin+1], ..., v[end-1] += by\"]\n                pub fn add(&mut self, begin: usize, end: usize, by: i64) {\n                    if begin >= end {\n                        return;\n                    }\n                    let a = begin as i64;\n                    let b = end as i64;\n                    self.bit0.add(begin, -by * a);\n                    self.bit0.add(end, by * b);\n                    self.bit1.add(begin, by);\n                    self.bit1.add(end, -by);\n                }\n                #[doc = \" v[begin] + ... + v[end-1]\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    self.cum(end) - self.cum(begin)\n                }\n                #[doc = \" v[0] + ... + v[end-1]\"]\n                fn cum(&self, end: usize) -> i64 {\n                    let a = self.bit0.get(0, end);\n                    let b = self.bit1.get(0, end);\n                    a + b * end as i64\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_add() {\n                    let mut bit = BIT::new(10);\n                    bit.add(100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_range_add() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(5, 100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_get() {\n                    let bit = BIT::new(10);\n                    bit.get(0, 1000);\n                }\n                #[test]\n                fn test_empty_range() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(9, 0, 100);\n                    bit.add(7, 3, 100);\n                    assert_eq!(0, bit.get(0, 9));\n                    assert_eq!(0, bit.get(0, 5));\n                    assert_eq!(0, bit.get(2, 5));\n                }\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        mod segment_tree {\n            use std::cmp;\n            use std::marker::PhantomData;\n            pub trait Monoid<T> {\n                fn id() -> Option<T> {\n                    None\n                }\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T>;\n            }\n            pub struct MinOp<T: Ord> {\n                phantom: PhantomData<T>,\n            }\n            impl<T: Ord + Clone> Monoid<T> for MinOp<T> {\n                #[inline]\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T> {\n                    match (l.clone(), r.clone()) {\n                        (Some(l), Some(r)) => Some(cmp::min(l, r)),\n                        (Some(l), None) => Some(l),\n                        (None, Some(r)) => Some(r),\n                        (None, None) => None,\n                    }\n                }\n            }\n            pub struct SegmentTree<M: Monoid<T>, T: Clone> {\n                phantom: PhantomData<M>,\n                data: Vec<Option<T>>,\n                size: usize,\n                size_p2: usize,\n            }\n            impl<M: Monoid<T>, T: Clone> SegmentTree<M, T> {\n                pub fn from_vec(v: Vec<T>) -> SegmentTree<M, T> {\n                    let size = v.len();\n                    let mut size_p2 = 1;\n                    while size_p2 < v.len() {\n                        size_p2 *= 2;\n                    }\n                    let mut data = vec![None; size_p2 * 2];\n                    for (i, x) in v.into_iter().enumerate() {\n                        data[size_p2 + i] = Some(x);\n                    }\n                    for i in (0..size_p2).rev() {\n                        data[i] = M::op(&data[i * 2 + 0], &data[i * 2 + 1]);\n                    }\n                    SegmentTree {\n                        phantom: PhantomData,\n                        data: data,\n                        size: size,\n                        size_p2: size_p2,\n                    }\n                }\n                pub fn size(&self) -> usize {\n                    self.size\n                }\n                pub fn update(&mut self, mut pos: usize, value: T) {\n                    assert!(pos < self.size);\n                    pos += self.size_p2;\n                    self.data[pos] = Some(value);\n                    loop {\n                        pos /= 2;\n                        if pos == 0 {\n                            break;\n                        }\n                        self.data[pos] = M::op(&self.data[pos * 2], &self.data[pos * 2 + 1]);\n                    }\n                }\n                pub fn query(&self, mut l: usize, mut r: usize) -> Option<T> {\n                    assert!(l <= r && r <= self.size);\n                    l += self.size_p2;\n                    r += self.size_p2;\n                    let mut res1 = M::id();\n                    let mut res2 = M::id();\n                    while l < r {\n                        if (l & 1) != 0 {\n                            res1 = M::op(&res1, &self.data[l]);\n                            l += 1;\n                        }\n                        if (r & 1) != 0 {\n                            r -= 1;\n                            res2 = M::op(&self.data[r], &res2);\n                        }\n                        l >>= 1;\n                        r >>= 1;\n                    }\n                    M::op(&res1, &res2)\n                }\n            }\n            #[doc = \" segment tree to get minimum value in a range\"]\n            pub type RMQ<T> = SegmentTree<MinOp<T>, T>;\n            #[cfg(test)]\n            mod tests {\n                use super::RMQ;\n                #[test]\n                fn test_rms() {\n                    let mut test = vec![1, 5, 4, 8, 6, 9, 2, 0, 8, 1];\n                    let mut rms = RMQ::from_vec(test.clone());\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                    rms.update(7, 5);\n                    test[7] = 5;\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                }\n            }\n        }\n        mod union_find {\n            #[doc = \" Disjoint-set data structure\"]\n            #[doc = \"\"]\n            #[doc = \" This provides operations for disjoint sets.\"]\n            #[doc = \" They runs in nearly constatant time.\"]\n            #[doc = \" (the actual time is `O(A(n))` where `A(n)` is the inverse of ackermann function.)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. unite(x, y) - unite a set including x and another set including y into one.\"]\n            #[doc = \" 2. same(x, y) - determine if x and y are in the same set.\"]\n            #[doc = \" 3. size(x) - calculate the number of elements of the set including x.\"]\n            #[doc = \"\"]\n            #[doc = \" [`UnionFind::new(n)`](#method.new) creates n disjoint sets. `i`-th set contains single element `i` (0-indexed).\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::data_structure::UnionFind;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut uf = UnionFind::new(4);\"]\n            #[doc = \" assert!(!uf.same(0, 1));\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(0, 1);\"]\n            #[doc = \" assert!(uf.same(0, 1));\"]\n            #[doc = \" assert_eq!(uf.size(0), 2);\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(1, 2);\"]\n            #[doc = \" assert!(uf.same(0, 2));\"]\n            #[doc = \" assert_eq!(uf.size(0), 3);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            #[doc = \" # Panics\"]\n            #[doc = \" panics if `x` or `y` is not less than number of elements given in the initialization method.\"]\n            #[doc = \"\"]\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {\n                #[doc = \" Creates a object with n disjoint sets. `i`-th set is `{ i }`.\"]\n                pub fn new(n: usize) -> UnionFind {\n                    UnionFind { data: vec![-1; n] }\n                }\n                #[doc = \" Unite a set including `x` and another set including y into one.\"]\n                #[doc = \" Returns `true` only if they were in different set.\"]\n                pub fn unite(&mut self, x: usize, y: usize) -> bool {\n                    let x = self.root(x);\n                    let y = self.root(y);\n                    if x != y {\n                        let (x, y) = if self.data[x] <= self.data[y] {\n                            (x, y)\n                        } else {\n                            (y, x)\n                        };\n                        self.data[x] += self.data[y];\n                        self.data[y] = x as i32;\n                    }\n                    x != y\n                }\n                #[doc = \" Returns `true` only if `x` and `y` are in a same set.\"]\n                pub fn same(&mut self, x: usize, y: usize) -> bool {\n                    self.root(x) == self.root(y)\n                }\n                #[doc = \" Returns the number of elements of a set including `x`.\"]\n                pub fn size(&mut self, x: usize) -> u32 {\n                    let r = self.root(x);\n                    (-self.data[r]) as u32\n                }\n                #[doc = \" internal method to return representative element of a set including `x`.\"]\n                pub fn root(&mut self, x: usize) -> usize {\n                    if self.data[x] < 0 {\n                        x\n                    } else {\n                        let nx = self.data[x] as usize;\n                        let r = self.root(nx);\n                        self.data[x] = r as i32;\n                        r\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n        pub use self::bit::{BITRange, BIT};\n        pub use self::segment_tree::{MinOp, Monoid, SegmentTree, RMQ};\n        pub use self::union_find::UnionFind;\n    }\n    pub mod math {\n        mod comb {\n            use super::mint::{Mint, Module};\n            #[doc = \" Useful struct to compute combinations\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Comb, Mod107, Mint107};\"]\n            #[doc = \" let comb: Comb<Mod107> = Comb::new(100);\"]\n            #[doc = \" assert_eq!(Mint107::from(24), comb.fact(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(1), comb.fact(4) * comb.factinv(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(12), comb.perm(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(6), comb.comb(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(10), comb.multi_comb(4, 2));\"]\n            #[doc = \" ```\"]\n            pub struct Comb<M: Module> {\n                fact: Vec<Mint<M>>,\n                factinv: Vec<Mint<M>>,\n            }\n            impl<M: Module> Comb<M> {\n                #[doc = \" Create a object that provides effiecint computation of combinations\"]\n                #[doc = \" for input smaller than `n`.\"]\n                #[doc = \"\"]\n                #[doc = \" This requires `O(n)` time.\"]\n                pub fn new(n: usize) -> Comb<M> {\n                    let mut fact: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    let mut factinv: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    fact[0] = 1.into();\n                    for i in 0..n {\n                        fact[i + 1] = fact[i] * (i + 1);\n                    }\n                    factinv[n] = fact[n].inv();\n                    for i in (0..n).rev() {\n                        factinv[i] = factinv[i + 1] * (i + 1);\n                    }\n                    Comb {\n                        fact: fact,\n                        factinv: factinv,\n                    }\n                }\n                #[doc = \" `n! = 1 * 2 * ... * n`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn fact(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.fact.get(n as usize) {\n                        *x\n                    } else if n >= M::module() as u64 {\n                        Mint::from(0)\n                    } else {\n                        let mut res = 1.into();\n                        for a in 1..(n + 1) {\n                            res *= a;\n                        }\n                        res\n                    }\n                }\n                #[doc = \" returns `y` such that `n! * y == 1`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn factinv(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.factinv.get(n as usize) {\n                        *x\n                    } else {\n                        self.fact(n).inv()\n                    }\n                }\n                #[doc = \" `nPr = n! / (n - r)!`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn perm(&self, n: u64, r: u64) -> Mint<M> {\n                    if n >= r {\n                        self.fact(n) * self.factinv((n - r) as u64)\n                    } else {\n                        0.into()\n                    }\n                }\n                #[doc = \" `nCr = n! / (n - r)! / r!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn comb(&self, n: u64, r: u64) -> Mint<M> {\n                    let m = M::module() as u64;\n                    if n >= m {\n                        self.comb(n % m, r % m) * self.comb(n / m, r / m)\n                    } else if n >= r {\n                        self.fact(n) * self.factinv(n - r) * self.factinv(r)\n                    } else {\n                        Mint::from(0)\n                    }\n                }\n                #[doc = \" `(n + k - 1)! / k!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn multi_comb(&self, n: u64, r: u64) -> Mint<M> {\n                    if r == 0 {\n                        Mint::from(1)\n                    } else {\n                        self.comb(n + r - 1, r)\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        mod mint {\n            use std::fmt;\n            use std::marker::PhantomData;\n            use std::mem;\n            use std::ops;\n            #[doc = \" Trait for `Mint`. `module()` should return prime number.\"]\n            pub trait Module: Copy + Clone {\n                fn module() -> u32;\n            }\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 7`\"]\n            pub const MOD_107: u32 = 1_000_000_007;\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 9`\"]\n            pub const MOD_109: u32 = 1_000_000_009;\n            #[doc = \" One of famous numbers in programming contest. `998_244_353`\"]\n            pub const MOD_998: u32 = 998_244_353;\n            #[doc = \" struct to implement Module trait. it returns `MOD_107`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod107;\n            impl Module for Mod107 {\n                fn module() -> u32 {\n                    MOD_107\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_109`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod109;\n            impl Module for Mod109 {\n                fn module() -> u32 {\n                    MOD_109\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_998`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod998;\n            impl Module for Mod998 {\n                fn module() -> u32 {\n                    MOD_998\n                }\n            }\n            #[doc = \" Wrapper class to compute mod `1_000_000_007` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" # // TODO: implement convert to u64\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint107 = Mint<Mod107>;\n            #[doc = \" Wrapper class to compute mod `1_000_000_009` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint109, MOD_109};\"]\n            #[doc = \" let x: Mint109 = 1234567.into();\"]\n            #[doc = \" let y: Mint109 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_109 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint109 = Mint<Mod109>;\n            #[doc = \" Wrapper class to compute mod `998_244_353` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint998, MOD_998};\"]\n            #[doc = \" let x: Mint998 = 1234567.into();\"]\n            #[doc = \" let y: Mint998 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_998 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint998 = Mint<Mod998>;\n            #[doc = \" Wrapper class to compute modulo operation.\"]\n            #[doc = \" See examples\"]\n            #[doc = \" [`Mint107`](type.Mint107.html),\"]\n            #[doc = \" [`Mint109`](type.Mint109.html),\"]\n            #[doc = \" [`Mint998`](type.Mint998.html)\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint<M: Module> {\n                #[doc = \" internal value. this is always less than `self.module()`.\"]\n                pub val: u32,\n                m: PhantomData<M>,\n            }\n            impl<M: Module> Mint<M> {\n                fn module(self) -> u32 {\n                    M::module()\n                }\n                fn new(val: u32) -> Mint<M> {\n                    assert!(val < M::module());\n                    Mint {\n                        val: val,\n                        m: PhantomData,\n                    }\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Add<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn add(self, other: T) -> Mint<M> {\n                    let nval = self.val + other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Sub<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn sub(self, other: T) -> Mint<M> {\n                    let nval = self.val + self.module() - other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Mul<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn mul(self, other: T) -> Mint<M> {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint::new((nval % (self.module() as u64)) as u32)\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Div<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn div(self, other: T) -> Mint<M> {\n                    self * other.into().inv()\n                }\n            }\n            impl<M: Module> Mint<M> {\n                #[doc = \" Returns number `y` that satisfies `x * y == 1` where `x` is the original value.\"]\n                #[doc = \"\"]\n                #[doc = \" This assumes `module()` returns prime number.\"]\n                pub fn inv(self) -> Mint<M> {\n                    let mut a = self.val as i32;\n                    let mut b = self.module() as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        mem::swap(&mut u, &mut v);\n                    }\n                    Mint::new(if u < 0 { u + self.module() as i32 } else { u } as u32)\n                }\n            }\n            impl<M: Module> PartialEq for Mint<M> {\n                fn eq(&self, other: &Mint<M>) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl<M: Module> fmt::Display for Mint<M> {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules ! impl_signed_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = ( x as i64 ) % ( M :: module ( ) as i64 ) ; if x >= 0 { Mint { val : t as u32 , m : PhantomData } } else { Mint { val : ( M :: module ( ) as i64 + t ) as u32 , m : PhantomData } } } } ) * ) }\n            macro_rules ! impl_unsigned_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = x as u64 % M :: module ( ) as u64 ; Mint :: new ( t as u32 ) } } ) * ) }\n            impl_signed_mint! { i8 i16 i32 i64 isize }\n            impl_unsigned_mint! { u8 u16 u32 u64 usize }\n            impl<T: Into<Mint<M>>, M: Module> ops::AddAssign<T> for Mint<M> {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::SubAssign<T> for Mint<M> {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::MulAssign<T> for Mint<M> {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::DivAssign<T> for Mint<M> {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint<Mod107> = Mint::from(3);\n                    let b: Mint<Mod107> = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % Mod107::module() as u64), a * b);\n                }\n            }\n        }\n        pub use self::comb::Comb;\n        pub use self::mint::{Mint, Module};\n        pub use self::mint::{Mint107, Mint109, Mint998};\n        pub use self::mint::{Mod107, Mod109, Mod998};\n        pub use self::mint::{MOD_107, MOD_109, MOD_998};\n    }\n    pub mod util {\n        mod permutation {\n            #[doc = \" It contains same methods as `std::next_permutaion` in C++.\"]\n            #[doc = \" these methods should rearrange the elements into the next/prev lexicographically greater permutation.\"]\n            #[doc = \"\"]\n            #[doc = \" This is implemented in [T] where T is Ord.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::Permutation;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [5, 0, 9, 2];\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 9, 0]);\"]\n            #[doc = \" assert!(perm.prev_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [4, 3, 2, 1, 0];\"]\n            #[doc = \" assert!(!perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [4, 3, 2, 1, 0]);\"]\n            #[doc = \" ```\"]\n            pub trait Permutation {\n                #[doc = \" It rearranges the elements into the next lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the last permutation.\"]\n                fn next_permutation(&mut self) -> bool;\n                #[doc = \" It rearranges the elements into the previous lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the first permutation.\"]\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        mod random {\n            use std::num::Wrapping;\n            #[doc = \" Not secure but fast random generator.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::XorShift;\"]\n            #[doc = \" let mut xorshift = XorShift::new();\"]\n            #[doc = \" assert_eq!(3701687786, xorshift.next_u32());\"]\n            #[doc = \" assert_eq!(458299110, xorshift.next_u32());\"]\n            #[doc = \" ```\"]\n            #[derive(Clone, Debug, Default)]\n            pub struct XorShift {\n                x: Wrapping<u32>,\n                y: Wrapping<u32>,\n                z: Wrapping<u32>,\n                w: Wrapping<u32>,\n            }\n            impl XorShift {\n                #[doc = \" Create object with default seed.\"]\n                pub fn new() -> XorShift {\n                    XorShift {\n                        x: Wrapping(123_456_789),\n                        y: Wrapping(362_436_069),\n                        z: Wrapping(521_288_629),\n                        w: Wrapping(88_675_123),\n                    }\n                }\n                #[doc = \" Get next random u32 number.\"]\n                pub fn next_u32(&mut self) -> u32 {\n                    let x = self.x;\n                    let t = x ^ (x << 11);\n                    self.x = self.y;\n                    self.y = self.z;\n                    self.z = self.w;\n                    let v = self.w;\n                    self.w = v ^ (v >> 19) ^ (t ^ (t >> 8));\n                    self.w.0\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::XorShift;\n                #[test]\n                fn test_basic() {\n                    let mut xorshift = XorShift::new();\n                    assert_eq!(3701687786, xorshift.next_u32());\n                    assert_eq!(458299110, xorshift.next_u32());\n                }\n            }\n        }\n        pub use self::permutation::Permutation;\n        pub use self::random::XorShift;\n    }\n}\n\n//}}}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        a: i64,\n        b: i64,\n        p: [usize1; n],\n    }\n    let mut lftma = vec![0; n];\n    let mut rgtmi = vec![0; n];\n    for i in 0..n {\n        let v = p[i];\n        let mut ma = n;\n        let mut mi = 0;\n        for j in 0..i {\n            if p[j] > v {\n                ma = min(ma, p[j]);\n            }\n        }\n        for j in i + 1..n {\n            if p[j] < v {\n                mi = max(mi, p[j]);\n            }\n        }\n        lftma[v] = ma;\n        rgtmi[v] = mi;\n    }\n    //eprintln!(\"lftma = {:?}\", lftma);\n    //eprintln!(\"rgtmi = {:?}\", rgtmi);\n    const INF: i64 = 1 << 50;\n    let mut dp = vec![vec![INF; n + 1]; n + 1];\n    dp[0][0] = 0;\n    for l in 0..n {\n        for r in 0..n - l {\n            // pass\n            let cost = if lftma[l] >= n - r {\n                0\n            } else {\n                b\n            };\n            dp[l + 1][r] = min(dp[l + 1][r], dp[l][r] + cost);\n            let cost = if rgtmi[n - 1 - r] < l {\n                0\n            } else {\n                a\n            };\n            dp[l][r + 1] = min(dp[l][r + 1], dp[l][r] + cost);\n        }\n    }\n    let mut mi = INF;\n    if 0 == 1 {\n        for i in 0..n + 1 {\n            // eprintln!(\"dp[{}] = {:?}\", i, dp[i]);\n        }\n    }\n    for i in 0..n + 1 {\n        mi = min(mi, dp[i][n - i]);\n    }\n    puts!(\"{}\\n\", mi);\n    \n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nuse std::cmp::*;\n\nfn run() {\n    input! {\n        n: usize,\n        a: usize,\n        b: usize,\n        p: [usize1; n],\n    }\n    let mut dp = vec![0; n];\n    for (i, &q) in p.iter().enumerate() {\n        let mut next = vec![(i + 1) * b; n];\n        let mut cnt = vec![0; n];\n        for &x in p[..i].iter() {\n            cnt[x] += 1;\n        }\n        for j in (0..(n - 1)).rev() {\n            cnt[j] += cnt[j + 1];\n        }\n        let mut score = (i + 1) * b;\n        for i in (0..n).rev() {\n            score = min(score, dp[i]);\n            if i <= q {\n                next[q] = min(next[q], dp[i]);\n            } else {\n                next[i] = min(next[i], dp[i] + b);\n                next[q] = min(next[q], score + cnt[q] * a);\n            }\n        }\n        dp = next;\n    }\n    let ans = dp.into_iter().min().unwrap();\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    macro_rules! debug {\n        //($($format:tt)*) => (eprintln!($($format)*));\n        ($($format:tt)*) => ();\n    }\n    input! {\n        n: usize,\n        a: i64,\n        b: i64,\n        p: [usize1; n],\n    }\n    let mut lftma = vec![0; n];\n    let mut rgtmi = vec![0; n];\n    for i in 0..n {\n        let v = p[i];\n        let mut ma = n;\n        let mut mi = 0;\n        for j in 0..i {\n            if p[j] > v {\n                ma = min(ma, p[j]);\n            }\n        }\n        for j in i + 1..n {\n            if p[j] < v {\n                mi = max(mi, p[j] + 1);\n            }\n        }\n        lftma[v] = ma;\n        rgtmi[v] = mi;\n    }\n    debug!(\"lftma = {:?}\", lftma);\n    debug!(\"rgtmi = {:?}\", rgtmi);\n    const INF: i64 = 1 << 50;\n    let mut dp = vec![vec![INF; n + 1]; n + 1];\n    dp[0][0] = 0;\n    for l in 0..n {\n        for r in 0..n - l {\n            // pass\n            let cost = if lftma[l] > n - r - 1 {\n                0\n            } else {\n                b\n            };\n            dp[l + 1][r] = min(dp[l + 1][r], dp[l][r] + cost);\n            let cost = if rgtmi[n - 1 - r] < l + 1 {\n                0\n            } else {\n                a\n            };\n            dp[l][r + 1] = min(dp[l][r + 1], dp[l][r] + cost);\n        }\n    }\n    let mut mi = INF;\n    for i in 0..n + 1 {\n        debug!(\"dp[{}] = {:?}\", i, dp[i]);\n    }\n    for i in 0..n {\n        mi = min(mi, dp[i][n - i - 1]);\n    }\n    puts!(\"{}\\n\", mi);\n    \n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// (AGC032 - D)\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nconst INF: i64 = 1e18 as i64;\n\nfn main() {\n    input! {\n        n: usize,\n        a: i64,\n        b: i64,\n        p: [usize; n]\n    };\n    let mut pos = vec![0; n+1];\n    for i in 0..n {\n        pos[p[i]] = (i+1)*2;\n    }\n\n    let mut dp = dvec!(INF; n+1, 2*n+2);\n    dp[0][0] = 0;\n    for i in 1..n+1 {\n        let mut best = INF;\n        for j in 0..2*n+2 {\n            best = min(best, dp[i-1][j]);\n            let cost = if j < pos[i] {\n                b\n            } else if j > pos[i] {\n                a\n            } else {\n                0\n            };\n            dp[i][j] = min(dp[i][j], best+cost);\n        }\n    }\n\n    let mut ans = INF;\n    for i in 0..2*n+2 {\n        ans = min(ans, dp[n][i]);\n    }\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin chmin, chmax ----------\ntrait ChangeMinMax {\n    fn chmin(&mut self, x: Self) -> bool;\n    fn chmax(&mut self, x: Self) -> bool;\n}\n\nimpl<T: PartialOrd> ChangeMinMax for T {\n    fn chmin(&mut self, x: Self) -> bool {\n        *self > x && {\n            *self = x;\n            true\n        }\n    }\n    fn chmax(&mut self, x: Self) -> bool {\n        *self < x && {\n            *self = x;\n            true\n        }\n    }\n}\n// ---------- end chmin, chmax ----------\n\nuse proconio::*;\n\nfn run() {\n    input! {\n        n: usize,\n        a: u64,\n        b: u64,\n        p: [usize; n],\n    }\n    let inf = 10u64.pow(9) * 5000 + 1;\n    let mut dp = vec![inf; n + 1];\n    dp[0] = 0;\n    for p in p {\n        let mut next = vec![inf; n + 1];\n        next[p].chmin(*dp[..=p].iter().min().unwrap());\n        for (next, dp) in next.iter_mut().zip(dp.iter()).take(p) {\n            next.chmin(*dp + a);\n        }\n        for (next, dp) in next.iter_mut().zip(dp.iter()).skip(p + 1) {\n            next.chmin(*dp + b);\n        }\n        dp = next;\n    }\n    let ans = dp.into_iter().min().unwrap();\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn calc(\n    depth: usize,\n    v: usize,\n    seq: &Vec<usize>,\n    costs: &Vec<i64>,\n    memo: &mut Vec<Vec<i64>>,\n) -> i64 {\n    let n = seq.len();\n    if depth == n {\n        return 0;\n    }\n    if memo[depth][v] != -1 {\n        return memo[depth][v];\n    }\n    let mut ret = 1 << 60;\n    if seq[depth] < v {\n        // left move\n        ret = std::cmp::min(ret, calc(depth + 1, v, seq, costs, memo) + costs[0]);\n    } else {\n        // right move\n        ret = std::cmp::min(ret, calc(depth + 1, v, seq, costs, memo) + costs[1]);\n        // nop\n        ret = std::cmp::min(ret, calc(depth + 1, seq[depth], seq, costs, memo));\n    };\n    // println!(\"{} {} {}\", depth, v, ret);\n    memo[depth][v] = ret;\n    return ret;\n}\n\nfn main() {\n    let n = read::<usize>();\n    let mut costs = vec![0, 0];\n    costs[1] = read::<i64>();\n    costs[0] = read::<i64>();\n    let mut seq = vec![0; n];\n    for i in 0..n {\n        seq[i] = read::<usize>() - 1;\n    }\n    let mut memo = vec![vec![-1; n]; n];\n    let ans = calc(0, 0, &seq, &costs, &mut memo);\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::*;\n\nfn run() {\n    input! {\n        n: usize,\n        a: u64,\n        b: u64,\n        p: [usize; n],\n    }\n    let inf = 10u64.pow(9) * 5000 + 1;\n    let mut dp = vec![inf; n + 1];\n    dp[0] = 0;\n    for p in p {\n        dp[p] = *dp.iter().take(p).min().unwrap();\n        for dp in dp.iter_mut().take(p) {\n            *dp += a;\n        }\n        for dp in dp.iter_mut().skip(p + 1) {\n            *dp += b;\n        }\n    }\n    let ans = dp.into_iter().min().unwrap();\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin Lazy Segment Tree ----------\npub trait TE {\n    type T: Clone;\n    type E: Clone;\n    fn fold(l: &Self::T, r: &Self::T) -> Self::T;\n    fn eval(x: &Self::T, f: &Self::E) -> Self::T;\n    fn merge(g: &Self::E, h: &Self::E) -> Self::E;\n    fn e() -> Self::T;\n    fn id() -> Self::E;\n}\n\npub struct LazySegmentTree<R: TE> {\n    size: usize,\n    bit: usize,\n    a: Vec<(R::T, R::E)>,\n}\n\nimpl <R: TE> LazySegmentTree<R> {\n    pub fn new(n: usize) -> LazySegmentTree<R> {\n        let size = n.next_power_of_two();\n        let bit = size.trailing_zeros() as usize;\n        LazySegmentTree {\n            size: size,\n            bit: bit,\n            a: vec![(R::e(), R::id()); 2 * size],\n        }\n    }\n    pub fn build_by(z: &[R::T]) -> LazySegmentTree<R> {\n        let mut seg = LazySegmentTree::<R>::new(z.len());\n        for (a, z) in seg.a[seg.size..].iter_mut().zip(z.iter()) {\n            a.0 = z.clone();\n        }\n        let a = &mut seg.a;\n        for i in (1..seg.size).rev() {\n            a[i].0 = R::fold(&a[2 * i].0, &a[2 * i + 1].0);\n        }\n        seg\n    }\n    fn apply(&mut self, x: usize, op: &R::E) {\n        let node = &mut self.a[x];\n        node.0 = R::eval(&node.0, op);\n        node.1 = R::merge(&node.1, op);\n    }\n    fn propagate(&mut self, x: usize) {\n        let mut op = R::id();\n        std::mem::swap(&mut op, &mut self.a[x].1);\n        self.apply(2 * x, &op);\n        self.apply(2 * x + 1, &op);\n    }\n    fn propagate_range(&mut self, l: usize, r: usize) {\n        let x = l + self.size;\n        let y = r + self.size;\n        let mut k = self.bit;\n        while (x >> k) == (y >> k) {\n            self.propagate(x >> k);\n            k -= 1;\n        }\n        for i in ((x.trailing_zeros() as usize + 1)..=k).rev() {\n            self.propagate(x >> i);\n        }\n        for i in ((y.trailing_zeros() as usize + 1)..=k).rev() {\n            self.propagate(y >> i);\n        }\n    }\n    fn save_range(&mut self, l: usize, r: usize) {\n        let mut x = l + self.size;\n        let mut y = r + self.size;\n        let mut p = (x & 1) == 1;\n        let mut q = (y & 1) == 1;\n        x >>= 1;\n        y >>= 1;\n        while 0 < x && x < y {\n            if p {\n                self.a[x].0 = R::fold(&self.a[2 * x].0, &self.a[2 * x + 1].0);\n            }\n            if q {\n                self.a[y].0 = R::fold(&self.a[2 * y].0, &self.a[2 * y + 1].0);\n            }\n            p |= (x & 1) == 1;\n            q |= (y & 1) == 1;\n            x >>= 1;\n            y >>= 1;\n        }\n        while 0 < x {\n            self.a[x].0 = R::fold(&self.a[2 * x].0, &self.a[2 * x + 1].0);\n            x >>= 1;\n        }\n    }\n    pub fn update(&mut self, l: usize, r: usize, op: R::E) {\n        self.propagate_range(l, r);\n        let mut x = l + self.size;\n        let mut y = r + self.size;\n        while x < y {\n            if x & 1 == 1 {\n                self.apply(x, &op);\n                x += 1;\n            }\n            if y & 1 == 1 {\n                y -= 1;\n                self.apply(y, &op);\n            }\n            x >>= 1;\n            y >>= 1;\n        }\n        self.save_range(l, r);\n    }\n    pub fn find(&mut self, l: usize, r: usize) -> R::T {\n        self.propagate_range(l, r);\n        let mut x = l + self.size;\n        let mut y = r + self.size;\n        let mut p = R::e();\n        let mut q = R::e();\n        while x < y {\n            if x & 1 == 1 {\n                p = R::fold(&p, &self.a[x].0);\n                x += 1;\n            }\n            if y & 1 == 1 {\n                y -= 1;\n                q = R::fold(&self.a[y].0, &q);\n            }\n            x >>= 1;\n            y >>= 1;\n        }\n        R::fold(&p, &q)\n    }\n    pub fn set_at(&mut self, x: usize, v: R::T) {\n        self.propagate_range(x, x + 1);\n        self.a[x + self.size] = (v, R::id());\n        self.save_range(x, x + 1);\n    }\n}\n// ---------- end Lazy Segment Tree ----------\n\nuse proconio::*;\nuse std::cmp::*;\n\nstruct R;\nimpl TE for R {\n    type T = u64;\n    type E = u64;\n    fn fold(l: &Self::T, r: &Self::T) -> Self::T {\n        min(*l, *r)\n    }\n    fn eval(x: &Self::T, f: &Self::E) -> Self::T {\n        *x + *f\n    }\n    fn merge(g: &Self::E, h: &Self::E) -> Self::E {\n        *g + *h\n    }\n    fn e() -> Self::T {\n        10u64.pow(9) * 5000 + 1\n    }\n    fn id() -> Self::E {\n        0\n    }\n}\n\nfn run() {\n    input! {\n        n: usize,\n        a: u64,\n        b: u64,\n        p: [usize; n],\n    }\n    let mut seg = LazySegmentTree::<R>::new(n + 2);\n    seg.set_at(0, 0);\n    for p in p {\n        let v = seg.find(0, p);\n        seg.set_at(p, v);\n        seg.update(0, p, a);\n        seg.update(p + 1, n + 2, b);\n    }\n    let ans = seg.find(0, n + 2);\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    macro_rules! debug {\n        //($($format:tt)*) => (eprintln!($($format)*));\n        ($($format:tt)*) => ();\n    }\n    input! {\n        n: usize,\n        a: i64,\n        b: i64,\n        p: [usize1; n],\n    }\n    let mut lftma = vec![0; n];\n    let mut rgtmi = vec![0; n];\n    for i in 0..n {\n        let v = p[i];\n        let mut ma = n;\n        let mut mi = 0;\n        for j in 0..i {\n            if p[j] > v {\n                ma = min(ma, p[j]);\n            }\n        }\n        for j in i + 1..n {\n            if p[j] < v {\n                mi = max(mi, p[j] + 1);\n            }\n        }\n        lftma[v] = ma;\n        rgtmi[v] = mi;\n    }\n    debug!(\"lftma = {:?}\", lftma);\n    debug!(\"rgtmi = {:?}\", rgtmi);\n    const INF: i64 = 1 << 50;\n    let mut dp = vec![vec![INF; n + 1]; n + 1];\n    dp[0][0] = 0;\n    for l in 0..n {\n        for r in 0..n - l {\n            // pass\n            let cost = if lftma[l] >= n - r {\n                0\n            } else {\n                b\n            };\n            dp[l + 1][r] = min(dp[l + 1][r], dp[l][r] + cost);\n            let cost = if rgtmi[n - 1 - r] < l + 1 {\n                0\n            } else {\n                a\n            };\n            dp[l][r + 1] = min(dp[l][r + 1], dp[l][r] + cost);\n        }\n    }\n    let mut mi = INF;\n    for i in 0..n + 1 {\n        debug!(\"dp[{}] = {:?}\", i, dp[i]);\n    }\n    for i in 0..n + 1 {\n        mi = min(mi, dp[i][n - i]);\n    }\n    puts!(\"{}\\n\", mi);\n    \n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc032/tasks/agc032_d\n//\n#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::*;\nuse std::io::*;\nuse std::str::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst INF: i64 = 1e18 as i64;\n\nfn main() {\n    input! {\n        n: usize, a: i64, b: i64,\n        p: [usize1; n]\n    };\n\n    let mut dp = vec![vec![INF; n + 10]; 2];\n    dp[0][n] = 0;\n\n    for i in 0..n {\n        let fr = i % 2;\n        let to = 1 - fr;\n        for j in 0..n + 1 {\n            dp[to][j] = INF;\n        }\n\n        for j in 0..n + 1 {\n            if dp[fr][j] == INF {\n                continue;\n            }\n            let base = dp[fr][j];\n            if j == n || p[j] < p[i] {\n                dp[to][i] = min(dp[to][i], base);\n            }\n            if i <= p[i] {\n                dp[to][j] = min(dp[to][j], base + a);\n            }\n            if i >= p[i] {\n                dp[to][j] = min(dp[to][j], base + b);\n            }\n        }\n    }\n    let mut ans = INF;\n    for i in 0..n + 1 {\n        ans = min(ans, dp[n % 2][i]);\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc032/tasks/agc032_d\n//\n#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::*;\nuse std::io::*;\nuse std::str::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst INF: i64 = 1e18 as i64;\n\nfn main() {\n    input! {\n        n: usize, a: i64, b: i64,\n        p: [usize1; n]\n    };\n\n    let mut dp = vec![vec![INF; n + 10]; 2];\n    dp[0][n] = 0;\n\n    for i in 0..n {\n        let fr = i % 2;\n        let to = 1 - fr;\n        for j in 0..n + 1 {\n            dp[to][j] = INF;\n        }\n\n        for j in 0..n + 1 {\n            if dp[fr][j] == INF {\n                continue;\n            }\n            let base = dp[fr][j];\n            if j == n || p[j] < p[i] {\n                dp[to][i] = min(dp[to][i], base);\n            }\n            if i < p[i] {\n                dp[to][j] = min(dp[to][j], base + a);\n            }\n            if i > p[i] {\n                dp[to][j] = min(dp[to][j], base + b);\n            }\n        }\n    }\n    let mut ans = INF;\n    for i in 0..n + 1 {\n        ans = min(ans, dp[n % 2][i]);\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nimpl<'a> Scanner<'a> {\n    #[inline]\n    pub fn new(s: &'a str) -> Self {\n        let iter = s.split_ascii_whitespace();\n        Self { iter }\n    }\n    #[inline]\n    pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n        T::scan(&mut self.iter).unwrap()\n    }\n    #[inline]\n    pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n        marker.mscan(&mut self.iter).unwrap()\n    }\n    #[inline]\n    pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n        (0..size)\n            .map(|_| T::scan(&mut self.iter).unwrap())\n            .collect()\n    }\n    #[inline]\n    pub fn scan_chars(&mut self) -> Vec<char> {\n        self.iter.next().unwrap().chars().collect::<Vec<char>>()\n    }\n}\nmod scanner_impls {\n    use super::*;\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String ) ;\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($($T ::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B ) ;\n    iter_scan_tuple_impl !(A B C ) ;\n    iter_scan_tuple_impl !(A B C D ) ;\n    iter_scan_tuple_impl !(A B C D E ) ;\n    iter_scan_tuple_impl !(A B C D E F ) ;\n    iter_scan_tuple_impl !(A B C D E F G ) ;\n    iter_scan_tuple_impl !(A B C D E F G H ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J K ) ;\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        fn next(&mut self) -> Option<Self::Item> {\n            T::scan(&mut self.inner.iter)\n        }\n    }\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n}\nmod marker {\n    use super::*;\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            usize::scan(iter).map(|x| x.wrapping_sub(1))\n        }\n    }\n    pub struct Isize1;\n    impl IterScan for Isize1 {\n        type Output = isize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            isize::scan(iter).map(|x| x.wrapping_sub(1))\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\nfn main() {\n    #[allow(unused_imports)]\n    use std::io::{Read as _, Write as _};\n    let __out = std::io::stdout();\n    let mut __in_buf = String::new();\n    std::io::stdin().read_to_string(&mut __in_buf).unwrap();\n    let mut __scanner = Scanner::new(&__in_buf);\n    #[allow(unused_macros)]\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;({$t :tt =>$f :expr } ) =>{$f (scan !($t ) ) } ;(chars ) =>{__scanner .scan_chars () } ;($t :ty ) =>{__scanner .scan ::<$t >() } ;}\n    let mut __out = std::io::BufWriter::new(__out.lock());\n    #[allow(unused_macros)]\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(__out ,$($arg ) *) .unwrap () ) }\n    #[allow(unused_macros)]\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(__out ,$($arg ) *) .unwrap () ) }\n    #[allow(unused_macros)]\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, \"\\n\")\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter;\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let a = scan!();\n    let b = scan!();\n    #[allow(unused_parens)]\n    let p = scan!([(marker::Usize1); n]);\n    let mut q = vec![0; n];\n    for (i, &p) in p.iter().enumerate() {\n        q[p] = i;\n    }\n    let mut dp = vec![vec![std::usize::MAX; n * 2 + 1]; n + 1];\n    dp[0][0] = 0;\n    for i in 0..n {\n        let mut d = std::usize::MAX;\n        for j in 0..n * 2 + 1 {\n            chmin!(d, dp[i][j]);\n            if j % 2 == 1 {\n                if j / 2 == q[i] {\n                    dp[i + 1][j] = d;\n                }\n            } else {\n                dp[i + 1][j] = d.saturating_add(if j < q[i] * 2 + 1 { b } else { a });\n            }\n        }\n    }\n    println!(\"{}\", dp[n].iter().min().unwrap());\n}"
  }
]