[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_SEGMENTS 100\n\ndouble calculateMaxDistance(int N, double* time_segments, double* speed_limits) {\n    double total_distance = 0;\n    double current_speed = 0;\n    \n    for (int i = 0; i < N; i++) {\n        double t = time_segments[i];\n        double v_limit = speed_limits[i];\n        \n        double max_speed_achievable = fmin(current_speed + t, v_limit);\n        double acceleration_time = (max_speed_achievable - current_speed) / 1.0;\n        double constant_speed_time = t - 2 * acceleration_time;\n        \n        double segment_distance = 0;\n        \n        if (constant_speed_time > 0) {\n            segment_distance = (current_speed + max_speed_achievable) * t / 2.0;\n        } else {\n            double peak_speed = current_speed + acceleration_time;\n            segment_distance = current_speed * acceleration_time + 0.5 * acceleration_time * acceleration_time;\n        }\n        \n        total_distance += segment_distance;\n        current_speed = max_speed_achievable;\n    }\n    \n    return total_distance;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    double time_segments[MAX_SEGMENTS];\n    double speed_limits[MAX_SEGMENTS];\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf\", &time_segments[i], &speed_limits[i]);\n    }\n    \n    double max_distance = calculateMaxDistance(N, time_segments, speed_limits);\n    \n    printf(\"%.10f\\n\", max_distance);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:13:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int *t = (int *)malloc(N * sizeof(int));\n    int *v = (int *)malloc(N * sizeof(int));\n    int total_time = 0;\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &t[i]);\n        total_time += t[i];\n    }\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &v[i]);\n    }\n\n    double *max_speed = (double *)malloc((total_time + 1) * sizeof(double));\n    for (int i = 0; i <= total_time; i++) {\n        max_speed[i] = 1e9;\n    }\n\n    int current_time = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= t[i]; j++) {\n            int time = current_time + j;\n            max_speed[time] = MIN(max_speed[time], v[i]);\n        }\n        current_time += t[i];\n    }\n\n    max_speed[0] = 0;\n    max_speed[total_time] = 0;\n\n    for (int i = 1; i <= total_time; i++) {\n        max_speed[i] = MIN(max_speed[i], max_speed[i-1] + 1);\n    }\n    for (int i = total_time - 1; i >= 0; i--) {\n        max_speed[i] = MIN(max_speed[i], max_speed[i+1] + 1);\n    }\n\n    double distance = 0.0;\n    for (int i = 0; i < total_time; i++) {\n        distance += (max_speed[i] + max_speed[i+1]) * 0.5;\n    }\n\n    printf(\"%.10f\\n\", distance);\n\n    free(t);\n    free(v);\n    free(max_speed);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:13:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> t(N), v(N);\n    for (int i = 0; i < N; ++i) cin >> t[i];\n    for (int i = 0; i < N; ++i) cin >> v[i];\n    \n    int T = 0;\n    for (int i = 0; i < N; ++i) T += t[i];\n    \n    vector<double> max_v(2 * T + 1, 1e9);\n    \n    int current_t = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = current_t; j <= current_t + t[i]; ++j) {\n            max_v[2 * j] = min(max_v[2 * j], (double)v[i]);\n        }\n        current_t += t[i];\n    }\n    max_v[0] = max_v[2 * T] = 0.0;\n    \n    for (int i = 1; i <= 2 * T; ++i) {\n        max_v[i] = min(max_v[i], max_v[i - 1] + 0.5);\n    }\n    for (int i = 2 * T - 1; i >= 0; --i) {\n        max_v[i] = min(max_v[i], max_v[i + 1] + 0.5);\n    }\n    \n    double distance = 0.0;\n    for (int i = 0; i < 2 * T; ++i) {\n        distance += (max_v[i] + max_v[i + 1]) * 0.25;\n    }\n    \n    cout << fixed << setprecision(10) << distance << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] t = new int[N];\n        int[] v = new int[N];\n        int totalTime = 0;\n        for (int i = 0; i < N; i++) {\n            t[i] = sc.nextInt();\n            totalTime += t[i];\n        }\n        for (int i = 0; i < N; i++) {\n            v[i] = sc.nextInt();\n        }\n\n        double[] maxV = new double[totalTime * 2 + 1];\n        Arrays.fill(maxV, Double.MAX_VALUE);\n        maxV[0] = 0;\n        maxV[totalTime * 2] = 0;\n\n        int currentTime = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= t[i] * 2; j++) {\n                int time = currentTime + j;\n                maxV[time] = Math.min(maxV[time], v[i]);\n            }\n            currentTime += t[i] * 2;\n        }\n\n        for (int i = 1; i <= totalTime * 2; i++) {\n            maxV[i] = Math.min(maxV[i], maxV[i - 1] + 0.5);\n        }\n        for (int i = totalTime * 2 - 1; i >= 0; i--) {\n            maxV[i] = Math.min(maxV[i], maxV[i + 1] + 0.5);\n        }\n\n        double distance = 0;\n        for (int i = 0; i < totalTime * 2; i++) {\n            distance += (maxV[i] + maxV[i + 1]) * 0.25;\n        }\n\n        System.out.println(distance);\n    }\n}",
    "timestamp": "2025-08-05 23:14:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AtCoderExpress {\n    public static double maxDistance(int[] times, int[] speeds) {\n        int n = times.length;\n        double maxDist = 0;\n        double currSpeed = 0;\n\n        for (int i = 0; i < n; i++) {\n            double t = times[i];\n            double v = speeds[i];\n            double maxAccel = 1.0;\n            double maxDecel = -1.0;\n\n            double targetSpeed = Math.min(v, maxAccelChange(currSpeed, t, maxAccel));\n            double distance = calcDistance(currSpeed, targetSpeed, t);\n            \n            maxDist += distance;\n            currSpeed = targetSpeed;\n        }\n\n        return maxDist;\n    }\n\n    private static double maxAccelChange(double currSpeed, double time, double maxAccel) {\n        return currSpeed + maxAccel * time;\n    }\n\n    private static double calcDistance(double startSpeed, double endSpeed, double time) {\n        return (startSpeed + endSpeed) * time / 2.0;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] times = new int[N];\n        int[] speeds = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            times[i] = scanner.nextInt();\n            speeds[i] = scanner.nextInt();\n        }\n\n        double result = maxDistance(times, speeds);\n        System.out.printf(\"%.10f\\n\", result);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:14:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ndouble maxDistance(int N, vector<int>& time, vector<int>& speedLimit) {\n    vector<double> velocity(N + 1, 0.0);\n    \n    for (int i = 0; i < N; i++) {\n        double maxV = min((double)speedLimit[i], velocity[i] + time[i]);\n        double minV = max(0.0, velocity[i] - time[i]);\n        velocity[i+1] = min(maxV, minV);\n    }\n    \n    double totalDistance = 0.0;\n    for (int i = 0; i < N; i++) {\n        double avgVelocity = (velocity[i] + velocity[i+1]) / 2.0;\n        totalDistance += avgVelocity * time[i];\n    }\n    \n    return totalDistance;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> time(N);\n    vector<int> speedLimit(N);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> time[i] >> speedLimit[i];\n    }\n    \n    cout << fixed << setprecision(10) << maxDistance(N, time, speedLimit) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_distance(N, T, V):\n    max_speed = [float('inf')] * (T + 1)\n    max_speed[0] = 0\n    max_speed[T] = 0\n    \n    time_index = 0\n    for i in range(N):\n        max_speed_at_interval = V[i]\n        for _ in range(times[i]):\n            max_speed[time_index] = min(max_speed[time_index], max_speed_at_interval)\n            time_index += 1\n    \n    for i in range(1, T + 1):\n        max_speed[i] = min(max_speed[i], max_speed[i - 1] + 1)\n    \n    for i in range(T - 1, -1, -1):\n        max_speed[i] = min(max_speed[i], max_speed[i + 1] + 1)\n    \n    distance = 0\n    for i in range(T):\n        distance += (max_speed[i] + max_speed[i + 1]) / 2\n    \n    return distance\n\ndef main():\n    N = int(input().strip())\n    times = list(map(int, input().strip().split()))\n    velocities = list(map(int, input().strip().split()))\n    T = sum(times)\n    print(max_distance(N, times, velocities))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 14:11:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class AtCoderExpress {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Read number of segments\n        int N = scanner.nextInt();\n        int[] t = new int[N];\n        int[] v = new int[N];\n        \n        // Read time durations\n        for (int i = 0; i < N; i++) {\n            t[i] = scanner.nextInt();\n        }\n\n        // Read speed limits\n        for (int i = 0; i < N; i++) {\n            v[i] = scanner.nextInt();\n        }\n        \n        // Close scanner\n        scanner.close();\n\n        // Calculate total time of journey\n        int totalTime = 0;\n        for (int time : t) {\n            totalTime += time;\n        }\n\n        // Initialize arrays for maximum speeds at each second\n        double[] maxSpeeds = new double[totalTime + 1];\n        \n        // Set constraints for speed profile from start\n        for (int i = 0, currentSecond = 0; i < N; i++) {\n            for (int j = 0; j < t[i]; j++) {\n                maxSpeeds[currentSecond] = Math.min(v[i], currentSecond);\n                currentSecond++;\n            }\n        }\n\n        // Set constraints for speed profile from end\n        for (int i = N - 1, currentSecond = totalTime; i >= 0; i--) {\n            for (int j = 0; j < t[i]; j++) {\n                currentSecond--;\n                maxSpeeds[currentSecond] = Math.min(maxSpeeds[currentSecond], v[i]);\n                maxSpeeds[currentSecond] = Math.min(maxSpeeds[currentSecond], currentSecond - totalTime + t[N - 1 - i]);\n            }\n        }\n\n        // Calculate maximum possible distance\n        double distance = 0.0;\n        double currentSpeed = 0.0;\n        for (int i = 0; i < totalTime; i++) {\n            if (currentSpeed < maxSpeeds[i]) {\n                currentSpeed = Math.min(currentSpeed + 1.0, maxSpeeds[i]);\n            } else if (currentSpeed > maxSpeeds[i]) {\n                currentSpeed = Math.max(currentSpeed - 1.0, maxSpeeds[i]);\n            }\n            distance += currentSpeed;\n        }\n\n        // Print the maximum possible distance\n        System.out.printf(\"%.6f\\n\", distance);\n    }\n}",
    "timestamp": "2025-08-13 14:11:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int t[N], v[N];\n    int total_time = 0;\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &t[i], &v[i]);\n        total_time += t[i];\n    }\n\n    double max_speeds[total_time + 1];\n    for (int i = 0; i <= total_time; i++) {\n        max_speeds[i] = 0;\n    }\n\n    int current_time = 0;\n    for (int i = 0; i < N; i++) {\n        int segment_time = t[i];\n        int segment_speed_limit = v[i];\n        for (int j = current_time; j <= current_time + segment_time; j++) {\n            max_speeds[j] = segment_speed_limit;\n        }\n        current_time += segment_time;\n    }\n\n    double min_speed[total_time + 1];\n    min_speed[0] = 0;\n    for (int i = 0; i < total_time; i++) {\n        min_speed[i + 1] = MIN(min_speed[i] + 1, max_speeds[i + 1]);\n    }\n\n    double max_speed[total_time + 1];\n    max_speed[total_time] = 0;\n    for (int i = total_time; i > 0; i--) {\n        max_speed[i - 1] = MIN(max_speed[i] + 1, max_speeds[i - 1]);\n    }\n\n    double actual_max_speed[total_time + 1];\n    for (int i = 0; i <= total_time; i++) {\n        actual_max_speed[i] = MIN(min_speed[i], max_speed[i]);\n    }\n\n    double distance = 0.0;\n    for (int i = 0; i < total_time; i++) {\n        distance += (actual_max_speed[i] + actual_max_speed[i + 1]) / 2.0;\n    }\n\n    printf(\"%.10f\\n\", distance);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:11:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxDistance(t, v) {\n    const N = t.length;\n    const timeSegments = [];\n    let totalTime = 0;\n    for (let i = 0; i < N; i++) {\n        totalTime += t[i];\n        for (let j = 0; j < t[i]; j++) {\n            timeSegments.push(v[i]);\n        }\n    }\n\n    const maxVelocity = Array(totalTime).fill(0);\n    let currentVelocity = 0;\n    \n    for (let i = 0; i < totalTime; i++) {\n        currentVelocity = Math.min(currentVelocity + 1, timeSegments[i]);\n        maxVelocity[i] = currentVelocity;\n    }\n    \n    currentVelocity = 0;\n    for (let i = totalTime - 1; i >= 0; i--) {\n        currentVelocity = Math.min(currentVelocity + 1, timeSegments[i]);\n        maxVelocity[i] = Math.min(maxVelocity[i], currentVelocity);\n    }\n    \n    let distance = 0;\n    for (let i = 0; i < totalTime; i++) {\n        distance += maxVelocity[i];\n    }\n    \n    return distance;\n}\n\n// Example usage:\n// const t = [3, 1, 2]; \n// const v = [2, 3, 1];\n// console.log(maxDistance(t, v)); // Output example",
    "timestamp": "2025-08-13 14:11:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_distance(t_N, v_N):\n    def can_achieve_distance(target_distance):\n        velocity = [0] * (len(t_N) + 1)\n        \n        for i in range(len(t_N)):\n            max_reachable_v = min(v_N[i], velocity[i] + t_N[i])\n            \n            peak_time = (max_reachable_v - velocity[i]) / 2\n            \n            if peak_time > t_N[i]:\n                peak_time = t_N[i]\n            \n            peak_v = velocity[i] + peak_time\n            \n            if peak_v > v_N[i]:\n                peak_v = v_N[i]\n                peak_time = (peak_v - velocity[i])\n            \n            remaining_time = t_N[i] - peak_time\n            \n            if remaining_time > 0:\n                velocity[i+1] = max(peak_v - remaining_time, 0)\n            else:\n                velocity[i+1] = peak_v\n        \n        distance = 0\n        current_v = 0\n        \n        for i in range(len(t_N)):\n            max_reachable_v = min(v_N[i], current_v + t_N[i])\n            \n            peak_time = (max_reachable_v - current_v) / 2\n            \n            if peak_time > t_N[i]:\n                peak_time = t_N[i]\n            \n            peak_v = current_v + peak_time\n            \n            if peak_v > v_N[i]:\n                peak_v = v_N[i]\n                peak_time = (peak_v - current_v)\n            \n            segment_distance = (current_v + peak_v) * peak_time / 2\n            \n            remaining_time = t_N[i] - peak_time\n            \n            if remaining_time > 0:\n                segment_distance += peak_v * remaining_time\n                current_v = max(peak_v - remaining_time, 0)\n            else:\n                current_v = peak_v\n            \n            distance += segment_distance\n        \n        return distance >= target_distance\n    \n    left, right = 0, 10**9\n    \n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        \n        if can_achieve_distance(mid):\n            left = mid\n        else:\n            right = mid\n    \n    return left\n\n# Input handling and execution\nN = int(input())\nt_N = list(map(int, input().split()))\nv_N = list(map(int, input().split()))\n\nresult = max_distance(t_N, v_N)\nprint(f\"{result:.6f}\")",
    "timestamp": "2025-08-13 14:12:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxDistance(N, times, speedLimits) {\n    let dp = new Array(N + 1).fill(0);\n    \n    for (let i = 1; i <= N; i++) {\n        for (let j = 0; j < i; j++) {\n            let time = times[i-1];\n            let maxSpeed = speedLimits[i-1];\n            \n            let acceleration = (maxSpeed - (j === 0 ? 0 : dp[j] / times[j])) / time;\n            \n            if (Math.abs(acceleration) <= 1) {\n                dp[i] = Math.max(dp[i], dp[j] + maxSpeed * time);\n            }\n        }\n    }\n    \n    return dp[N];\n}",
    "timestamp": "2025-08-13 14:12:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    N = int(sys.stdin.readline())\n    t = list(map(int, sys.stdin.readline().split()))\n    v = list(map(int, sys.stdin.readline().split()))\n    \n    total_time = sum(t)\n    max_speed = [0.0] * (total_time * 2 + 1)\n    \n    # Initialize constraints from the segments\n    current_t = 0\n    for ti, vi in zip(t, v):\n        for i in range(current_t, current_t + ti * 2 + 1):\n            max_speed[i] = min(max_speed[i], vi) if i < len(max_speed) else vi\n        current_t += ti * 2\n    \n    # Start and end must be 0\n    max_speed[0] = 0.0\n    max_speed[-1] = 0.0\n    \n    # Forward pass\n    for i in range(1, len(max_speed)):\n        max_speed[i] = min(max_speed[i], max_speed[i-1] + 0.5)\n    \n    # Backward pass\n    for i in range(len(max_speed)-2, -1, -1):\n        max_speed[i] = min(max_speed[i], max_speed[i+1] + 0.5)\n    \n    # Calculate distance\n    distance = 0.0\n    for i in range(len(max_speed)-1):\n        distance += (max_speed[i] + max_speed[i+1]) * 0.25\n    \n    print(distance)\n\nsolve()",
    "timestamp": "2025-08-13 14:12:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const N = parseInt(input[0], 10);\n    const t = input[1].split(' ').map(Number);\n    const v = input[2].split(' ').map(Number);\n    \n    const totalTime = t.reduce((acc, val) => acc + val, 0);\n    const timeLimits = new Array(totalTime + 1).fill(Infinity);\n    \n    let currentTime = 0;\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j <= t[i]; j++) {\n            timeLimits[currentTime + j] = Math.min(timeLimits[currentTime + j], v[i]);\n        }\n        currentTime += t[i];\n    }\n    \n    timeLimits[0] = 0;\n    timeLimits[totalTime] = 0;\n    \n    for (let i = 1; i <= totalTime; i++) {\n        timeLimits[i] = Math.min(timeLimits[i], timeLimits[i - 1] + 1);\n    }\n    \n    for (let i = totalTime - 1; i >= 0; i--) {\n        timeLimits[i] = Math.min(timeLimits[i], timeLimits[i + 1] + 1);\n    }\n    \n    let distance = 0;\n    for (let i = 0; i < totalTime; i++) {\n        distance += (timeLimits[i] + timeLimits[i + 1]) * 0.5;\n    }\n    \n    console.log(distance.toFixed(10));\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:12:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> t(N), v(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> t[i];\n    }\n\n    for (int i = 0; i < N; ++i) {\n        cin >> v[i];\n    }\n\n    int totalTime = 0;\n    for (int i = 0; i < N; ++i) {\n        totalTime += t[i];\n    }\n\n    vector<double> speed(totalTime + 1, 0.0);\n\n    for (int i = 0; i <= totalTime; ++i) {\n        double maxSpeed = 1e9;\n        int elapsedTime = 0;\n        \n        for (int j = 0; j < N; ++j) {\n            if (elapsedTime <= i && i < elapsedTime + t[j]) {\n                maxSpeed = min(maxSpeed, (double)v[j]);\n            }\n            maxSpeed = min(maxSpeed, (double)v[j] + abs(i - elapsedTime - t[j]));\n            maxSpeed = min(maxSpeed, (double)v[j] + abs(elapsedTime - i));\n            elapsedTime += t[j];\n        }\n\n        if (i > 0) {\n            maxSpeed = min(maxSpeed, speed[i - 1] + 1);\n        }\n        if (i < totalTime) {\n            maxSpeed = min(maxSpeed, speed[i + 1] + 1);\n        }\n\n        speed[i] = maxSpeed;\n    }\n\n    double distance = 0.0;\n    for (int i = 0; i < totalTime; ++i) {\n        distance += (speed[i] + speed[i + 1]) / 2.0;\n    }\n\n    cout << fixed << setprecision(9) << distance << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:42:35"
  }
]