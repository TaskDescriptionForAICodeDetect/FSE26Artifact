[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 100005\n#define MAX_M 200005\n\nint parent[MAX_N];\nint rank[MAX_N];\n\nvoid init_union_find(int n) {\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int root_x = find(x);\n    int root_y = find(y);\n    \n    if (root_x == root_y) return;\n    \n    if (rank[root_x] < rank[root_y]) {\n        parent[root_x] = root_y;\n    } else {\n        parent[root_y] = root_x;\n        if (rank[root_x] == rank[root_y]) {\n            rank[root_x]++;\n        }\n    }\n}\n\nbool is_same(int x, int y) {\n    return find(x) == find(y);\n}\n\nint main() {\n    int N, M, Q;\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    \n    int clues[MAX_M][3];\n    for (int i = 0; i < Q; i++) {\n        scanf(\"%d %d %d\", &clues[i][0], &clues[i][1], &clues[i][2]);\n        clues[i][0]--; \n        clues[i][1]--;\n    }\n    \n    bool possible = false;\n    for (int mask = 0; mask < (1 << Q); mask++) {\n        init_union_find(N);\n        bool valid = true;\n        \n        for (int i = 0; i < Q; i++) {\n            int a = clues[i][0], b = clues[i][1], c = clues[i][2];\n            bool connect = (mask & (1 << i)) > 0;\n            \n            if (c == 0) {\n                if (connect) {\n                    valid = false;\n                    break;\n                }\n                if (!is_same(a, b)) {\n                    unite(a, b);\n                }\n            } else {\n                if (!connect) {\n                    valid = false;\n                    break;\n                }\n                unite(a, b);\n            }\n        }\n        \n        if (valid) {\n            possible = true;\n            break;\n        }\n    }\n    \n    printf(\"%s\\n\", possible ? \"Yes\" : \"No\");\n    return 0;\n}",
    "timestamp": "2025-08-05 22:43:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100\n#define MAX_Q 100\n\ntypedef struct {\n    int parent;\n    int rank;\n} UnionFind;\n\nUnionFind uf[MAX_N];\n\nvoid init_union_find(int n) {\n    for (int i = 0; i < n; i++) {\n        uf[i].parent = i;\n        uf[i].rank = 0;\n    }\n}\n\nint find(int x) {\n    if (uf[x].parent != x) {\n        uf[x].parent = find(uf[x].parent);\n    }\n    return uf[x].parent;\n}\n\nvoid union_sets(int x, int y) {\n    int x_root = find(x);\n    int y_root = find(y);\n    if (x_root == y_root) return;\n    if (uf[x_root].rank < uf[y_root].rank) {\n        uf[x_root].parent = y_root;\n    } else if (uf[x_root].rank > uf[y_root].rank) {\n        uf[y_root].parent = x_root;\n    } else {\n        uf[y_root].parent = x_root;\n        uf[x_root].rank++;\n    }\n}\n\nint main() {\n    int N, M, Q;\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    \n    init_union_find(N);\n    \n    int possible = 1;\n    \n    for (int i = 0; i < Q; i++) {\n        int A, B, C;\n        scanf(\"%d %d %d\", &A, &B, &C);\n        \n        int a_root = find(A);\n        int b_root = find(B);\n        \n        if (C == 0) {\n            if (a_root != b_root) {\n                union_sets(A, B);\n            } else {\n                possible = 0;\n            }\n        } else {\n            if (a_root == b_root) {\n                possible = 0;\n            }\n        }\n    }\n    \n    printf(\"%s\\n\", possible ? \"Yes\" : \"No\");\n    return 0;\n}",
    "timestamp": "2025-08-05 22:43:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct DSU {\n    vector<int> parent, rank;\n    DSU(int n) : parent(n), rank(n, 1) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    int find(int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    }\n    bool unite(int u, int v) {\n        u = find(u), v = find(v);\n        if (u == v) return false;\n        if (rank[u] > rank[v]) swap(u, v);\n        parent[u] = v;\n        if (rank[u] == rank[v]) rank[v]++;\n        return true;\n    }\n};\n\nint main() {\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    vector<pair<int, int>> edges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n    vector<tuple<int, int, int>> clues(Q);\n    for (int i = 0; i < Q; ++i) {\n        int A, B, C;\n        cin >> A >> B >> C;\n        clues[i] = {A, B, C};\n    }\n\n    DSU dsu(N);\n    for (auto [u, v] : edges) {\n        dsu.unite(u, v);\n    }\n\n    bool possible = true;\n    for (auto [A, B, C] : clues) {\n        if (C == 0) {\n            if (dsu.find(A) != dsu.find(B)) {\n                possible = false;\n                break;\n            }\n        } else {\n            if (dsu.find(A) == dsu.find(B)) {\n                possible = false;\n                break;\n            }\n        }\n    }\n\n    cout << (possible ? \"Yes\" : \"No\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:43:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public boolean union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) {\n            return false;\n        }\n        if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return true;\n    }\n\n    public boolean isConnected(int x, int y) {\n        return find(x) == find(y);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int Q = scanner.nextInt();\n\n        List<int[]> zeroClues = new ArrayList<>();\n        List<int[]> oneClues = new ArrayList<>();\n\n        for (int i = 0; i < Q; i++) {\n            int A = scanner.nextInt();\n            int B = scanner.nextInt();\n            int C = scanner.nextInt();\n            if (C == 0) {\n                zeroClues.add(new int[]{A, B});\n            } else {\n                oneClues.add(new int[]{A, B});\n            }\n        }\n\n        UnionFind uf = new UnionFind(N);\n\n        for (int[] clue : zeroClues) {\n            uf.union(clue[0], clue[1]);\n        }\n\n        boolean possible = true;\n        for (int[] clue : oneClues) {\n            if (uf.isConnected(clue[0], clue[1])) {\n                possible = false;\n                break;\n            }\n        }\n\n        System.out.println(possible ? \"Yes\" : \"No\");\n    }\n}",
    "timestamp": "2025-08-05 22:44:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class SnukeGraph {\n    static int N, M, Q;\n    static int[] parent;\n    static int[] rank;\n\n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) return;\n        \n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n\n    static boolean checkPathCount(int a, int b, int c) {\n        int[] count = new int[N];\n        for (int i = 0; i < N; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (find(i) != find(j)) {\n                    union(i, j);\n                    count[find(i)]++;\n                }\n            }\n        }\n\n        int pathCount = 0;\n        for (int i = 0; i < N; i++) {\n            if (find(a) == find(i) && find(b) == find(i)) {\n                pathCount++;\n            }\n        }\n\n        return (c == 0 && pathCount == 1) || (c == 1 && pathCount > 1);\n    }\n\n    public static void solve(InputReader in, PrintWriter out) {\n        N = in.nextInt();\n        M = in.nextInt();\n        Q = in.nextInt();\n\n        parent = new int[N];\n        rank = new int[N];\n\n        boolean possible = true;\n        for (int i = 0; i < Q; i++) {\n            int a = in.nextInt() - 1;\n            int b = in.nextInt() - 1;\n            int c = in.nextInt();\n\n            if (!checkPathCount(a, b, c)) {\n                possible = false;\n                break;\n            }\n        }\n\n        out.println(possible ? \"Yes\" : \"No\");\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        solve(in, out);\n        out.close();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:44:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return false;\n        \n        if (rank[x] < rank[y]) swap(x, y);\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n        return true;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int N, M, Q;\n    cin >> N >> M >> Q;\n    \n    vector<tuple<int,int,int>> queries(Q);\n    for (auto& [a, b, c] : queries) {\n        cin >> a >> b >> c;\n        a--; b--;\n    }\n    \n    bool possible = false;\n    for (int mask = 0; mask < (1 << M); mask++) {\n        UnionFind uf(N);\n        int edges_used = 0;\n        \n        for (int j = 0; j < M; j++) {\n            if (mask & (1 << j)) {\n                int u, v;\n                cin >> u >> v;\n                u--; v--;\n                if (uf.unite(u, v)) edges_used++;\n            }\n        }\n        \n        bool valid = true;\n        for (auto [a, b, c] : queries) {\n            bool has_path = uf.same(a, b);\n            if (c == 0 && edges_used > N - 1) valid = false;\n            if (c == 1 && !has_path) valid = false;\n        }\n        \n        if (valid) {\n            possible = true;\n            break;\n        }\n    }\n    \n    cout << (possible ? \"Yes\" : \"No\") << '\\n';\n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.parent[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.parent[rootX] = rootY\n            else:\n                self.parent[rootY] = rootX\n                self.rank[rootX] += 1\n            return True\n        else:\n            return False\n\ndef is_valid_graph(N, clues):\n    uf = UnionFind(N)\n    mult_paths_set = set()\n\n    for A_i, B_i, C_i in clues:\n        if C_i == 0:\n            if not uf.union(A_i, B_i):\n                return False\n        elif C_i == 1:\n            mult_paths_set.add((uf.find(A_i), uf.find(B_i)))\n\n    return all(uf.find(A_i) != uf.find(B_i) for A_i, B_i in mult_paths_set)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    Q = int(data[2])\n    \n    clues = []\n    index = 3\n    for _ in range(Q):\n        A_i = int(data[index])\n        B_i = int(data[index + 1])\n        C_i = int(data[index + 2])\n        clues.append((A_i, B_i, C_i))\n        index += 3\n    \n    if is_valid_graph(N, clues):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:16:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SnukeGraphSolver {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int q = scanner.nextInt();\n        \n        ArrayList<int[]> clues = new ArrayList<>();\n        for (int i = 0; i < q; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int c = scanner.nextInt();\n            clues.add(new int[]{a, b, c});\n        }\n        \n        UnionFind uf = new UnionFind(n);\n        boolean possible = true;\n        \n        for (int[] clue : clues) {\n            int a = clue[0];\n            int b = clue[1];\n            int c = clue[2];\n            boolean connected = uf.isConnected(a, b);\n            \n            if (c == 0) {\n                if (connected) {\n                    possible = false;\n                    break;\n                } else {\n                    uf.union(a, b);\n                }\n            }\n        }\n        \n        if (possible) {\n            Set<String> multiPathPairs = new HashSet<>();\n            for (int[] clue : clues) {\n                int a = clue[0];\n                int b = clue[1];\n                int c = clue[2];\n                \n                if (c == 1 && !multiPathPairs.contains(a + \",\" + b)) {\n                    // Assure we don’t create multiple paths on the same link\n                    multiPathPairs.add(a + \",\" + b);\n                }\n            }\n        \n            // Each pair must allow multiple connecting through cycle creation\n            for (String pair : multiPathPairs) {\n                String[] nodes = pair.split(\",\");\n                int u = Integer.parseInt(nodes[0]);\n                int v = Integer.parseInt(nodes[1]);\n                \n                if (!uf.isConnected(u, v)) {\n                    uf.union(u, v);\n                } else {\n                    // Already connected, interprets whether we can switch to two paths\n                    possible = false;\n                    break;\n                }\n            }\n        }\n\n        System.out.println(possible ? \"Yes\" : \"No\");\n    }\n    \n    static class UnionFind {\n        private int[] parent;\n        private int[] rank;\n        \n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n        \n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        public boolean isConnected(int x, int y) {\n            return find(x) == find(y);\n        }\n        \n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX != rootY) {\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX;\n                } else if (rank[rootX] < rank[rootY]) {\n                    parent[rootX] = rootY;\n                } else {\n                    parent[rootY] = rootX;\n                    rank[rootX]++;\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:16:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 1000\n#define MAX_M 10000\n\ntypedef struct {\n    int parent[MAX_N];\n    int rank[MAX_N];\n} UnionFind;\n\nvoid uf_init(UnionFind *uf, int n) {\n    for (int i = 0; i < n; i++) {\n        uf->parent[i] = i;\n        uf->rank[i] = 0;\n    }\n}\n\nint uf_find(UnionFind *uf, int x) {\n    if (uf->parent[x] != x) {\n        uf->parent[x] = uf_find(uf, uf->parent[x]);\n    }\n    return uf->parent[x];\n}\n\nbool uf_union(UnionFind *uf, int x, int y) {\n    int rootX = uf_find(uf, x);\n    int rootY = uf_find(uf, y);\n    if (rootX == rootY) {\n        return false;\n    }\n    if (uf->rank[rootX] < uf->rank[rootY]) {\n        uf->parent[rootX] = rootY;\n    } else if (uf->rank[rootX] > uf->rank[rootY]) {\n        uf->parent[rootY] = rootX;\n    } else {\n        uf->parent[rootY] = rootX;\n        uf->rank[rootX]++;\n    }\n    return true;\n}\n\nbool check_clues(int n, int q, int A[], int B[], int C[]) {\n    UnionFind uf;\n    uf_init(&uf, n);\n\n    for (int i = 0; i < q; i++) {\n        if (C[i] == 0) {\n            if (!uf_union(&uf, A[i], B[i])) {\n                return false;\n            }\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        if (C[i] == 1) {\n            if (uf_find(&uf, A[i]) == uf_find(&uf, B[i])) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int n, m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    \n    int *A = (int *)malloc(q * sizeof(int));\n    int *B = (int *)malloc(q * sizeof(int));\n    int *C = (int *)malloc(q * sizeof(int));\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n    }\n\n    if (check_clues(n, q, A, B, C)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    free(A);\n    free(B);\n    free(C);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:16:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function canSatisfyClues(N, M, clues) {\n    function find(parent, x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n\n    function union(parent, rank, x, y) {\n        let rootX = find(parent, x);\n        let rootY = find(parent, y);\n\n        if (rootX !== rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            return true;\n        }\n        return false;\n    }\n    \n    const parent = Array.from({ length: N }, (_, i) => i);\n    const rank = new Array(N).fill(0);\n\n    // Process clues where C_i = 0 (exactly one simple path)\n    for (const [A_i, B_i, C_i] of clues) {\n        if (C_i === 0) {\n            if (find(parent, A_i) === find(parent, B_i)) {\n                return false;\n            }\n            union(parent, rank, A_i, B_i);\n        }\n    }\n    \n    // Check clues where C_i = 1 (two or more simple paths)\n    for (const [A_i, B_i, C_i] of clues) {\n        if (C_i === 1 && find(parent, A_i) === find(parent, B_i)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n// Sample usage:\n// console.log(canSatisfyClues(4, 0, [[0, 1, 0], [1, 2, 1], [2, 3, 0], [0, 3, 1]]));",
    "timestamp": "2025-08-13 12:16:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve(N, M, Q, clues):\n    def count_paths(graph, start, end):\n        visited = [False] * N\n        path_count = 0\n        \n        def dfs(node, target, curr_path):\n            nonlocal path_count\n            \n            if node == target:\n                path_count += 1\n                return\n            \n            visited[node] = True\n            \n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor, target, curr_path + [neighbor])\n            \n            visited[node] = False\n        \n        dfs(start, end, [start])\n        return path_count\n\n    def is_valid_graph():\n        for a, b, c in clues:\n            graph = defaultdict(list)\n            edges_added = set()\n            \n            # Try to construct a graph with the given constraint\n            if c == 0:  # exactly one path\n                # Attempt to create a graph with exactly one path\n                for u, v in combinations(range(N), 2):\n                    if len(graph[u]) < 2 and len(graph[v]) < 2:\n                        if (u, v) not in edges_added and (v, u) not in edges_added:\n                            graph[u].append(v)\n                            graph[v].append(u)\n                            edges_added.add((u, v))\n                    \n                    if len(graph) >= M:\n                        break\n                \n                # Check path constraint\n                paths = count_paths(graph, a, b)\n                if paths != 1:\n                    return False\n            \n            else:  # two or more paths\n                # Attempt to create a graph with multiple paths\n                for u, v in combinations(range(N), 2):\n                    if (u, v) not in edges_added and (v, u) not in edges_added:\n                        graph[u].append(v)\n                        graph[v].append(u)\n                        edges_added.add((u, v))\n                    \n                    if len(graph) >= M:\n                        break\n                \n                # Check path constraint\n                paths = count_paths(graph, a, b)\n                if paths < 2:\n                    return False\n        \n        return True\n\n    from itertools import combinations\n    return \"Yes\" if is_valid_graph() else \"No\"\n\n# Input handling\ndef main():\n    N, M, Q = map(int, input().split())\n    clues = []\n    for _ in range(Q):\n        a, b, c = map(int, input().split())\n        clues.append((a-1, b-1, c))\n    \n    print(solve(N, M, Q, clues))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:17:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function canConstructGraph(N, M, Q, clues) {\n    // Disjoint set (Union-Find) data structure\n    class UnionFind {\n        constructor(n) {\n            this.parent = Array.from({length: n}, (_, i) => i);\n            this.rank = new Array(n).fill(0);\n        }\n        \n        find(x) {\n            if (this.parent[x] !== x) {\n                this.parent[x] = this.find(this.parent[x]);\n            }\n            return this.parent[x];\n        }\n        \n        union(x, y) {\n            let rootX = this.find(x);\n            let rootY = this.find(y);\n            \n            if (rootX === rootY) return false;\n            \n            if (this.rank[rootX] < this.rank[rootY]) {\n                [rootX, rootY] = [rootY, rootX];\n            }\n            \n            this.parent[rootY] = rootX;\n            \n            if (this.rank[rootX] === this.rank[rootY]) {\n                this.rank[rootX]++;\n            }\n            \n            return true;\n        }\n    }\n    \n    // Try to satisfy the clues\n    for (let mask = 0; mask < (1 << Q); mask++) {\n        let uf = new UnionFind(N);\n        let edgeCount = 0;\n        let valid = true;\n        \n        // Process clues based on current mask\n        for (let i = 0; i < Q; i++) {\n            let [a, b, c] = clues[i];\n            \n            // If 1-bit path clue, force multiple paths by skipping union\n            if (c === 1 && ((mask & (1 << i)) === 0)) {\n                if (uf.find(a) === uf.find(b)) {\n                    valid = false;\n                    break;\n                }\n            }\n            // If 0-bit path clue, ensure single path\n            else if (c === 0) {\n                if (!uf.union(a, b)) {\n                    valid = false;\n                    break;\n                }\n                edgeCount++;\n            }\n        }\n        \n        // Check total edge count and connectivity\n        if (valid && edgeCount <= M) {\n            let roots = new Set();\n            for (let i = 0; i < N; i++) {\n                roots.add(uf.find(i));\n            }\n            \n            if (roots.size === 1) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}",
    "timestamp": "2025-08-13 12:17:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom sys import stdin\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return False  # Already in the same set\n        if self.rank[x_root] < self.rank[y_root]:\n            self.parent[x_root] = y_root\n        else:\n            self.parent[y_root] = x_root\n            if self.rank[x_root] == self.rank[y_root]:\n                self.rank[x_root] += 1\n        return True\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    Q = int(input[ptr])\n    ptr += 1\n\n    uf = UnionFind(N)\n    adj = [[] for _ in range(N)]\n    clues = []\n\n    for _ in range(M):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        adj[a].append(b)\n        adj[b].append(a)\n        uf.union(a, b)\n\n    # Check for cycles (bipartite check)\n    color = [-1] * N\n    bipartite = [True] * N  # bipartite[component] indicates if component is bipartite\n\n    for i in range(N):\n        if color[i] == -1:\n            queue = [i]\n            color[i] = 0\n            component_root = uf.find(i)\n            is_bipartite = True\n            while queue:\n                v = queue.pop()\n                for u in adj[v]:\n                    if color[u] == -1:\n                        color[u] = color[v] ^ 1\n                        queue.append(u)\n                    else:\n                        if color[u] == color[v]:\n                            is_bipartite = False\n            bipartite[component_root] = is_bipartite\n\n    # Process clues\n    possible = True\n    for _ in range(Q):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        if uf.find(a) != uf.find(b):\n            possible = False\n        else:\n            root = uf.find(a)\n            if c == 0:\n                if not bipartite[root]:\n                    possible = False\n            else:\n                if bipartite[root]:\n                    possible = False\n\n    print(\"Yes\" if possible else \"No\")\n\nsolve()",
    "timestamp": "2025-08-13 12:17:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, M, Q] = input[0].split(' ').map(Number);\n    const parent = new Array(N).fill(-1);\n    const rank = new Array(N).fill(0);\n    const clues = [];\n\n    const find = (u) => {\n        if (parent[u] === -1) return u;\n        return find(parent[u]);\n    };\n\n    const union = (u, v) => {\n        const rootU = find(u);\n        const rootV = find(v);\n        if (rootU === rootV) return false; // Already in the same set\n        if (rank[rootU] > rank[rootV]) {\n            parent[rootV] = rootU;\n        } else if (rank[rootU] < rank[rootV]) {\n            parent[rootU] = rootV;\n        } else {\n            parent[rootV] = rootU;\n            rank[rootU]++;\n        }\n        return true;\n    };\n\n    // Process edges (M lines)\n    let index = 1;\n    for (let i = 0; i < M; i++) {\n        const [a, b] = input[index++].split(' ').map(Number);\n        union(a, b);\n    }\n\n    // Process clues (Q lines)\n    for (let i = 0; i < Q; i++) {\n        const [a, b, c] = input[index++].split(' ').map(Number);\n        clues.push({ a, b, c });\n    }\n\n    // Check each clue\n    for (const { a, b, c } of clues) {\n        const sameComponent = find(a) === find(b);\n        if (c === 0 && !sameComponent) continue;\n        if (c === 1 && sameComponent) continue;\n        return false;\n    }\n    return true;\n};\n\nconsole.log(solve() ? \"Yes\" : \"No\");",
    "timestamp": "2025-08-13 12:17:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 1000;\nint parent[MAX_N];\nint dist[MAX_N];\nbool hasCycle[MAX_N];\nbool visited[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSets(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        parent[rootX] = rootY;\n    }\n}\n\nbool bfs(int start, const vector<set<int>>& adj) {\n    memset(dist, -1, sizeof(dist));\n    memset(hasCycle, false, sizeof(hasCycle));\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        \n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            } else if (dist[v] >= dist[u]) {\n                hasCycle[v] = true;\n            }\n        }\n    }\n    \n    return any_of(hasCycle, hasCycle + adj.size(), [](bool b) { return b; });\n}\n\nbool graphExists(int N, vector<tuple<int, int, int>>& clues) {\n    vector<set<int>> adj(N);\n    \n    for (int i = 0; i < N; ++i) {\n        parent[i] = i;\n    }\n    \n    for (auto& clue : clues) {\n        int A, B, C;\n        tie(A, B, C) = clue;\n        \n        if (C == 0) {\n            if (find(A) == find(B)) {\n                return false;\n            }\n            adj[A].insert(B);\n            adj[B].insert(A);\n            unionSets(A, B);\n        } else {\n            if (find(A) == find(B)) {\n                continue;\n            }\n            adj[A].insert(B);\n            adj[B].insert(A);\n        }\n    }\n    \n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            if (bfs(i, adj)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    \n    vector<tuple<int, int, int>> clues(Q);\n    \n    for (int i = 0; i < Q; ++i) {\n        int A, B, C;\n        cin >> A >> B >> C;\n        clues[i] = make_tuple(A, B, C);\n    }\n    \n    cout << (graphExists(N, clues) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:33:58"
  }
]