[
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            chain_t c = use_generic(i, true);\n            return c * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            chain_t c = use_generic(i, false);\n            return c * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        REP (y, n) acc = acc * go_row(y);\n        REP (x, n) acc = acc * go_col(x);\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\nconst int p=1e9+7;\n\nint Pow(int a,int b){\n\tint res=1;\n\tfor (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;\n\treturn res;\n}\n\nstruct Edge{\n\tint y,nxt;\n} E[N*2];\n\nVi V[N],P;\nint fac[N],inv[N],las[N],vis[N],chk[N],nxt[N],sz[N],deg[N];\nint n,num,tmp,ans,cnt,v,e,a,b,v2,num2,tmp2,alb,x,y;\n\nint C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%p*inv[n-m]%p;\n}\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tv++;\n\tfor (int i=las[x],y;~i;i=E[i].nxt){\n\t\te++;\n\t\tif (!vis[y=E[i].y]) dfs(y);\n\t}\n}\nvoid dfs(int x,int fa){\n\tP.pb(x);\n\tchk[x]=1;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (i!=fa){\n\t\t\tif (!chk[y=E[i].y]){\n\t\t\t\tdfs(y,i^1);\n\t\t\t} else{\n\t\t\t\ta=x,b=y;\n\t\t\t}\n\t\t}\n}\nvoid gao(int x,int fa){\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif ((y=E[i].y)!=fa){\n\t\t\tif (x==a&&y==b) continue;\n\t\t\tif (x==b&&y==a) continue;\n\t\t\tnxt[y]=x;\n\t\t\tgao(y,x);\n\t\t}\n}\nint bao(int x){\n\tchk[x]=2;\n\tint ans=1;\n\tsz[x]=0;\n\tfor (int y:V[x]){\n\t\tans=1ll*ans*bao(y)%p*C(sz[x]+sz[y],sz[y])%p;\n\t\tsz[x]+=sz[y];\n\t}\n\tsz[x]++;\n\treturn ans;\n}\nvoid Work(int x){\n\tP.clear();\n\ttmp=0;\n\tdfs(x,-1);\n\t\n\talb=1;\n\tgao(a,-1);\n\tnxt[a]=b;\n\tfor (int i:P) if (i<nxt[nxt[i]]){\n\t\tV[nxt[i]].pb(i);\n\t\tdeg[i]++;\n\t}\n\tnum2=0;\n\tfor (int i:P) if (deg[i]==0&&chk[i]!=2){\n\t\talb=1ll*alb*bao(i)%p*C(num2+sz[i],sz[i])%p;\n\t\tnum2+=sz[i];\n\t}\n\tfor (int i:P){\n\t\tV[i].clear();\n\t\tdeg[i]=0;\n\t\tchk[i]=0;\n\t}\n\t//printf(\"%d\\n\",alb);\n\ttmp=(tmp+alb)%p;\n\t\n\talb=1;\n\tgao(b,-1);\n\tnxt[b]=a;\n\tfor (int i:P) if (i<nxt[nxt[i]]){\n\t\tV[nxt[i]].pb(i);\n\t\tdeg[i]++;\n\t}\n\tnum2=0;\n\tfor (int i:P) if (deg[i]==0&&chk[i]!=2){\n\t\talb=1ll*alb*bao(i)%p*C(num2+sz[i],sz[i])%p;\n\t\tnum2+=sz[i];\n\t}\n\t//printf(\"%d\\n\",alb);\n\ttmp=(tmp+alb)%p;\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tfac[0]=1;\n\tFor(i,1,N) fac[i]=1ll*fac[i-1]*i%p;\n\tinv[N-1]=Pow(fac[N-1],p-2);\n\tfor (int i=N-1;i;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tn=IN()*2;\n\tFor(i,1,n+1){\n\t\tx=IN(),y=IN();\n\t\tLink(x,y+n/2);\n\t}\n\tans=1;\n\tFor(i,1,n+1) if (!vis[i]){\n\t\tv=0,e=0;\n\t\tdfs(i);\n\t\tif (v!=e/2){\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tWork(i);\n\t\tans=1ll*ans*tmp%p*C(num+v,v)%p;\n\t\tnum+=v;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n\nusing namespace std;\nconst int maxn = 1e5 + 10 , mod = 1e9 + 7;\nclass Edges{\npublic:\n\tint next , to , v;\n};\nint first[maxn * 2] , te = 1 , n;\nEdges edge[maxn * 4];\nbool flag[maxn * 2];\nint fac[maxn * 2] , deg[maxn * 2] , ifac[maxn * 2];\nint rev[maxn * 2];\n\nvoid add(int s , int t , int v){\n\t++ te;\n\tedge[te].to = t;\n\tedge[te].next = first[s];\n\tedge[te].v = v;\n\tfirst[s] = te;\n\tdeg[s] ++;\n}\n\nvoid init(){\n\tfac[0] = fac[1] = 1;\n\tfor(int i = 2 ; i <= 200000 ; ++ i)\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\trev[0] = rev[1] = 1;\n\tfor(int i = 2 ; i <= 200000 ; ++ i)\n\t\trev[i] = mod - 1ll * (mod / i) * rev[mod % i] % mod;\n\tifac[0] = ifac[1] = 1;\n\tfor(int i = 2 ; i <= 200000 ; ++ i)\n\t\tifac[i] = 1ll * ifac[i - 1] * rev[i] % mod;\n}\nint C(int a , int b){\n\tif(a < b || a < 0 || b < 0) return 0;\n\treturn 1ll * fac[a] * ifac[a - b] % mod * ifac[b] % mod;\n}\n\nint p[maxn * 2] , sum = 0;\nint cnte = 0;\nvoid go(int x){\n\tflag[x] = 1;\n\tp[++ sum] = x;\n\tfor(int e = first[x] ; e ; e = edge[e].next){\n\t\tcnte ++;\n\t\tint to = edge[e].to;\n\t\tif(!flag[to]) go(to);\n\t}\n}\n\nint match[maxn * 2];\nint cycle[maxn * 2] , cnt = 0;\nint pr[maxn * 2] , nt[maxn * 2];\nbool mark[maxn * 2];\nqueue <int> q;\n\nvoid find_cycle(int x){\n\tmark[x] = 1;\n\tint y = x;\n\tfor(int i = 1 ; i <= sum ; ++ i)\n\t\tfor(int e = first[y] ; e ; e = edge[e].next){\n\t\t\tint to = edge[e].to;\n\t\t\tif(!mark[to] || i == sum && to == x){\n\t\t\t\tmark[to] = 1;\n\t\t\t\tpr[to] = (1 ^ e);\n\t\t\t\tnt[y] = e;\n\t\t\t\ty = to;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n}\n\nEdges edge1[maxn * 2];\nint first2[maxn * 2] , te1 = 0 , deg1[maxn * 2];\nint size[maxn * 2];\n\nint dfs(int x){\n\tsize[x] = 0;\n\tint now = 1;\n\tfor(int e = first2[x] ; e ; e = edge1[e].next){\n\t\tint to = edge1[e].to;\n\t\tnow = 1ll * now * dfs(to) % mod * C(size[x] + size[to] , size[to]) % mod;\n\t\tsize[x] += size[to];\n\t}\n\tsize[x] ++;\n\treturn now;\n}\n\nvoid add1(int s , int t){\n\t++ te1;\n\tedge1[te1].to = t;\n\tedge1[te1].next = first2[s];\n\tfirst2[s] = te1;\n\tdeg1[t] ++;\n}\n\nint work(){\n\tte1 = 0;\n\tfor(int i = 1 ; i <= sum ; ++ i)\n\t\tfirst2[p[i]] = 0;\n\tfor(int i = 1 ; i <= sum ; ++ i)\n\t\tdeg1[p[i]] = 0;\n\tfor(int i = 1 ; i <= sum ; ++ i){\n\t\tint v = edge[match[p[i]]].v;\n\t\tfor(int e = first[p[i]] ; e ; e = edge[e].next)\n\t\t\tif(edge[e].v < v)\n\t\t\t\tadd1(p[i] , edge[e].to);\n\t}\n\tfirst2[0] = 0;\n\tfor(int i = 1 ; i <= sum ; ++ i)\n\t\tif(deg1[p[i]] == 0)\n\t\t\tadd1(0 , p[i]);\n\treturn dfs(0);\n}\n\nint solve(int x){\n\tsum = cnte = cnt = 0;\n\tgo(x);\n\tif(sum != cnte / 2){\n\t\tcout << 0 << endl;\n\t\texit(0);\n\t}\n\tfor(int i = 1 ; i <= sum ; ++ i)\n\t\tmark[p[i]] = 0;\n\tfor(int i = 1 ; i <= sum ; ++ i)\n\t\tif(deg[p[i]] == 1)\n\t\t\tq.push(p[i]);\n\twhile(q.size()){\n\t\tint now = q.front();\n\t\tmark[now] = 1;\n\t\tfor(int e = first[now] ; e ; e = edge[e].next){\n\t\t\tint to = edge[e].to;\n\t\t\tif(mark[to]) continue;\n\t\t\tmatch[now] = e;\n\t\t\tdeg[to] --;\n\t\t\tif(deg[to] == 1) q.push(to);\n\t\t}\n\t\tq.pop();\n\t}\n\tfor(int i = 1 ; i <= sum ; ++ i)\n\t\tif(!mark[p[i]])\n\t\t\tcycle[++ cnt] = p[i];\n\tfind_cycle(cycle[1]);\n\tfor(int i = 1 ; i <= cnt ; ++ i)\n\t\tmatch[cycle[i]] = nt[cycle[i]];\n\tint ret = work();\n\tfor(int i = 1 ; i <= cnt ; ++ i)\n\t\tmatch[cycle[i]] = pr[cycle[i]];\n\tret = (ret + work()) % mod;\n\treturn ret;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin >> n;\n\tfor(int i = 1 ; i <= 2 * n ; ++ i){\n\t\tint x0 , y0;\n\t\tcin >> x0 >> y0;\n\t\tadd(x0 , y0 + n , x0 + y0);\n\t\tadd(y0 + n , x0 , x0 + y0);\n\t}\n\tinit();\n\tint ans = 1 , last = 0;\n\tfor(int i = 1 ; i <= 2 * n ; ++ i)\n\t\tif(!flag[i]){\n\t\t\tans = 1ll * ans * solve(i) % mod * C(last + sum , last) % mod;\n\t\t\tlast += sum;\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\nint read() {\n\tint x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) flag *= (ch == '-' ? -1 : 1);\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';\n\treturn flag * x;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 3e5 + 9, Mod = 1e9 + 7;\nnamespace Math {\n\tint fpm(int base, int tims) {\n\t\tint r = 1;\n\t\tfor (; tims; base = 1ll * base * base % Mod, tims >>= 1) \n\t\t\tif (tims & 1) r = 1ll * r * base % Mod;\n\t\treturn r;\n\t}\n\tint fac[Maxn], invFac[Maxn];\n\tvoid Init() {\n\t\tfac[0] = 1;\n\t\trep (i, 1, Maxn - 1) \n\t\t\tfac[i] = fac[i - 1] * 1ll * i % Mod;\n\t\tinvFac[Maxn - 1] = fpm(fac[Maxn - 1], Mod - 2);\n\t\tdrep (i, Maxn - 2, 0) invFac[i] = invFac[i + 1] * (i + 1ll) % Mod;\n\t}\n\tint C(int _n, int _m) {\n\t\tif (_n < _m) return 0;\n\t\treturn fac[_n] * 1ll * invFac[_n - _m] % Mod * invFac[_m] % Mod;\n\t}\n}\nusing namespace Math;\n\nstruct node { int u, v, w; };\nstruct edge { int to, nxt, w; }g[Maxn << 2], g1[Maxn << 2];\nint head[Maxn], e;\nint head1[Maxn], e1;\nvoid add(int u, int v, int w) { g[++e] = (edge){v, head[u], w}, head[u] = e; }\nvoid add1(int u, int v, int w = 0) { g1[++e1] = (edge){v, head1[u], w}, head1[u] = e1; }\n\nint vis[Maxn], inCir[Maxn], found, _top, delta, n;\nnode stk[Maxn];\nvector <node> cir;\nvector <int> cus, cun;\n\nvoid dfsCir(int u, int pa) {\n\tif (found) return ;\n\tvis[u] = 1; \n\t\t\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tif (!vis[v]) {\n\t\t\t\tstk[++_top] = (node){u, v, g[i].w};\n\t\t\t\tdfsCir(v, u);\n\t\t\t\t--_top;\n\t\t\t} else if (!found) {\n\t\t\t\tnode tmp; int bak = _top;\n\t\t\t\tdo {\n\t\t\t\t\ttmp = stk[bak--];\n\t\t\t\t\tcir.push_back(tmp);\n\t\t\t\t\tif (!inCir[tmp.u]) cus.push_back(tmp.u);\n\t\t\t\t\tif (!inCir[tmp.v]) cus.push_back(tmp.v);\n\t\t\t\t\tinCir[tmp.u] = inCir[tmp.v] = 1;\n\t\t\t\t} while (tmp.u != v);\n\t\t\t\tcir.push_back((node){u, v, g[i].w});\n\t\t\t\tfound = 1;\n\t\t\t\treturn;\n\t\t\t} \n\t\t}\n\t\tif (found) return;\n\t}\n}\n\nint val[Maxn], fa[Maxn];\nint find(int x) {\n\treturn fa[x] ^ x ? fa[x] = find(fa[x]) : x;\n}\nvoid dfs1(int u, int pa) {\n\tif (delta > n) return;\n\tcun.push_back(u); ++delta; \n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (!inCir[v] && v != pa) val[v] = g[i].w, dfs1(v, u);\n\t}\n}\n\nint size[Maxn], dp[Maxn];\nvoid dfsDp(int u, int pa) {\n\tdp[u] = 1;\n\tint sum = 0;\n\tfor (int i = head1[u]; ~i; i = g1[i].nxt) {\n\t\tint v = g1[i].to;\n\t\tif (v != pa) {\n\t\t\tdfsDp(v, u);\n\t\t\tsize[u] += size[v];\n\t\t\tdp[u] = 1ll * dp[u] * dp[v] % Mod * C(size[u], sum) % Mod;\n\t\t\tsum += size[v];\n\t\t}\n\t}\n\t++size[u];\n}\nint deg[Maxn];\nint calc() {\n\te1 = 0;\n\trep (i, 0, cun.size() - 1) {\n\t\tint u = cun[i];\n\t\tsize[u] = dp[u] = deg[u] = 0;\n\t\thead1[u] = -1;\n\t}\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (g[i].w < val[u]) {\n\t\t\t\tadd1(u, v), ++deg[v];\n\t\t\t\t//cout << u << \" \" << v << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 1, sum = 0;\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tif (!deg[u]) {\n\t\t\tdfsDp(u, 0);\n\t\t\tres = 1ll * res * dp[u] * C(sum + size[u], sum) % Mod;\n\t\t\tsum += size[u];\n\t\t}\n\t}\n\t//cout << res << endl;\n//\tputs(\"\");\n\treturn res;\n}\n\nint main() {\n//\tfreopen(\"robot.in\", \"r\", stdin);\n\t//freopen(\"robot.out\", \"w\", stdout);\n\n\tstatic int x[Maxn], y[Maxn], xjig[Maxn], amt = 0;\n\n\tclar (head, -1), e = 0;\n\tMath :: Init();\n\n\tn = read() << 1;\n\trep (i, 1, n) fa[i] = i;\n\trep (i, 1, n) {\n\t\tx[i] = read(), y[i] = read();\n\t\tadd(x[i], y[i] + n / 2, x[i] + y[i]);\n\t\tadd(y[i] + n / 2, x[i], x[i] + y[i]);\n\t\tif (!xjig[x[i]]) ++amt, xjig[x[i]] = 1;\n\t\tif (!xjig[y[i] + n / 2]) ++amt, xjig[y[i] + n / 2] = 1;\n\t\tif (find(x[i]) != find(y[i] + n / 2)) fa[find(x[i])] = fa[find(y[i] + n / 2)];\n//\t\tcout << x[i] << \" \" << y[i] + n / 2 << endl;\n\t}\n\tif (amt != n) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tLL ans = 1, sum = 0;\n\trep (i, 1, n) \n\t\tif (fa[i] == i) {\n\t\t\tint res = 0; _top = 0, cir.clear(), found = 0, delta = 0, cus.clear(), cun.clear();\n\t\t\tdfsCir(i, 0);\n\t\t\tif (!found) {\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep (j, 0, cus.size() - 1) dfs1(cus[j], 0);\n\t\t\tif (delta > n) {\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].u] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].v] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\n\t\t\tans = 1ll * ans * res % Mod * C(sum += delta, delta) % Mod;\n\t\t}\n\tprintf(\"%d\\n\", 1ll * ans * fpm(fac[n], Mod - 1) % Mod);\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res;\nint f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\tdfs(x,V[x][i]);\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o,xx,yy,s=0,Res=0;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;res=1;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\ttp=3;res=1;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pct puts(\"------ visit ------\");\n#define rep(a, b, c) for(int a = (b); a <= (c); ++ a)\n#define per(a, b, c) for(int a = (b); a >= (c); -- a)\nusing namespace std;\ntemplate <class T> void rd(T &x){\n  x = 0; int f = 1; char ch = getchar();\n  while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }\n  while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();\n  x *= f;\n}\n\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nint n, sdu, tim = 2;\nint mrk[maxn], to[maxn], siz[maxn];\nint p[maxn], cntp;\nint r[maxn], cntr;\nvector <int> h, g[maxn];\nbool ok[maxn], isr[maxn];\n\nnamespace mathematics{\n  ll fac[maxn], fin[maxn];\n\n  ll qpow(ll x, ll n){\n\tll y = 1;\n\tfor(; n; n >>= 1, x = x * x % mod)\n\t  if(n & 1) y = y * x % mod;\n\treturn y;\n  }\n\n#define inv(x) qpow(x, mod - 2)\n\n  ll C(ll n, ll m){ return fac[n] * fin[m] % mod * fin[n - m] % mod; }\n\n  void init(int n){\n\tfac[0] = 1; rep(i, 1, n) fac[i] = fac[i - 1] * i % mod;\n\tfin[n] = inv(fac[n]);\n\tper(i, n, 1) fin[i - 1] = fin[i] * i % mod;\n  }\n\n  void add(ll &a, ll b){ a = (a + b) % mod; }\n\n  void mul(ll &a, ll b){ a = (a * b) % mod; }\n}\nusing namespace mathematics;\n\nstruct edge{ int v, nxt; }; vector <edge> e; int head[maxn];\n\nvoid adde(int u, int v){\n  e.push_back((edge){v, head[u]});\n  head[u] = e.size() - 1;\n}\n\nvoid rebuild(int u, int f){\n  mrk[u] = tim;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v; if(v == f) continue;\n\tif(mrk[v] == tim && v < u) continue;\n\tif(to[u] == v){\n\t  if(to[v] > u) g[v].push_back(u), ok[u] = true;\n\t}\n\telse{\n\t  if(to[u] > v) g[u].push_back(v), ok[v] = true;\n\t}\n\tif(mrk[v] != tim) rebuild(v, u);\n  }\n}\n\nvoid getsize(int u, int f){\n  siz[u] = 1;\n  for(int i = 0; i < g[u].size(); ++ i){\n\tint v = g[u][i];\n\tgetsize(v, u);\n\tsiz[u] += siz[v];\n  }\n}\n\nll getdp(int u, int f){\n  int tot = siz[u] - 1;\n  ll res = 1;\n  for(int i = 0; i < g[u].size(); ++ i){\n\tint v = g[u][i];\n\tmul(res, C(tot, siz[v]) * getdp(v, u) % mod);\n\ttot -= siz[v];\n  }\n  return res;\n}\n\nll query(){\n  ++ tim; \n  rep(i, 1, cntp) ok[i] = false;\n  rebuild(p[1], 0);\n  /*\n  rep(i, 1, cntp) if(g[p[i]].size()){\n\tfor(int j = 0; j < g[p[i]].size(); ++ j)\n\t  printf(\"%d -> %d\\n\", p[i], g[p[i]][j]);\n  }\n  */\n  int tot = cntp;\n  ll res = 1;\n  rep(i, 1, cntp) if(!ok[p[i]]){\n\tgetsize(p[i], 0);\n\tmul(res, C(tot, siz[p[i]]) * getdp(p[i], 0) % mod);\n\ttot -= siz[p[i]];\n  }\n  rep(i, 1, cntp) g[p[i]].clear();\n  return res;\n}\n\nbool getroll(int u, int f){\n  h.push_back(u);\n  mrk[u] = 2;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v;\n\tif(v == f) continue;\n\tif(mrk[v] != 2){\n\t  if(getroll(v, u)) return true;\n\t}\n\telse if(mrk[v] == 2){\n\t  int t = -1;\n\t  while(t != v){\n\t\tt = h.back();\n\t\th.pop_back();\n\t\tr[cntr ++] = t;\n\t\tisr[t] = 1;\n\t  }\n\t  return true;\n\t}\n  }\n  h.pop_back();\n  return false;\n}\n\nvoid match(int u, int f){\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v; if(v == f || isr[v]) continue;\n\tto[v] = u; match(v, u);\n  }\n}\n\nll cal(){\n  if(cntp != sdu){\n\tputs(\"0\");\n\texit(0);\n  }\n  cntr = 0;\n  h.clear();\n  getroll(p[1], 0);\n  rep(i, 0, cntr - 1) match(r[i], 0);\n  rep(i, 0, cntr - 1) to[r[i]] = r[(i + 1) % cntr];\n  ll res = query();\n  rep(i, 0, cntr - 1) to[r[i]] = r[(i + cntr - 1) % cntr];\n  add(res, query());\n  return res;\n}\n\nvoid dfs(int u){\n  p[++ cntp] = u;\n  mrk[u] = 1;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v;\n\tsdu ++;\n\tif(mrk[v]) continue;\n\tdfs(v);\n  }\n}\n\nvoid sol(){\n  int tot = 2 * n;\n  ll res = 1;\n  rep(i, 1, 2 * n) if(!mrk[i]){\n\tcntp = sdu = 0;\n\tdfs(i);\n\tsdu /= 2;\n\tmul(res, C(tot, cntp) * cal() % mod);\n\ttot -= cntp;\n  }\n  printf(\"%lld\\n\", res);\n}\n\nint main(){\n  memset(head, -1, sizeof(head));\n  rd(n);\n  init(2 * n);\n  rep(i, 1, 2 * n){\n\tint u, v; rd(u), rd(v);\n\tadde(u, v + n);\n\tadde(v + n, u);\n  }\n  sol();\n  return 0;\n}\n/*\n6\n1 1\n1 4\n2 2\n2 4\n3 1\n3 3\n4 4\n4 3\n5 2 \n5 5\n6 5\n3 6\n*/\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 200005, MOD = 1000000007;\ntypedef long long i64;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N << 2];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n  e[++cnt] = (Edge){head[v], u}, head[v] = cnt;\n}\n\nint N, vis[MAX_N], num_e, num_v, st[MAX_N];\nvoid dfs(int u, int v) {\n  static int tot;\n  st[++num_v] = u, vis[u] = ++tot;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v) {\n      if (!vis[e[i].to]) num_e++, dfs(e[i].to, u);\n      else if (vis[e[i].to] < vis[u]) num_e++;\n    }\n}\n\ni64 fac[MAX_N], ifac[MAX_N], inv[MAX_N];\ni64 binom(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nbool flag;\nint top, cir[MAX_N];\n\nvoid find_circle(int u, int v) {\n  if (flag) return;\n  static int ti[MAX_N], fa[MAX_N];\n  \n  fa[u] = v, ti[u] = 1;\n  \n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v) {\n      if (flag) return;\n      if (!ti[e[i].to]) find_circle(e[i].to, u);\n      else {\n\tint temp = u;\n\tdo {\n\t  cir[top++] = temp;\n\t  temp = fa[temp];\n\t} while (temp != e[i].to);\n\tcir[top++] = e[i].to;\n\tflag = 1;\n      }\n    }\n}\n\nint on[MAX_N], target[MAX_N], in[MAX_N];\n\nvoid dfs2(int u, int v) {\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v && !on[e[i].to]) {\n      target[e[i].to] = u;\n      dfs2(e[i].to, u);\n    }\n}\n\nint sz[MAX_N];\n\ni64 dfs3(int u, int v) {\n  sz[u] = 0;\n  i64 now = 1;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to < target[u]) {\n      i64 temp = dfs3(e[i].to, u);\n      now = now * temp % MOD * binom(sz[u] + sz[e[i].to], sz[u]) % MOD;\n      sz[u] += sz[e[i].to];\n    }\n  sz[u]++;\n  // printf(\"%lld\\n\", now);\n  return now;\n}\n\ni64 calc() {\n  for (int i = 1; i <= num_v; ++i) in[st[i]] = 0;\n  for (int i = 1; i <= num_v; ++i) {\n    for (int j = head[st[i]]; j; j = e[j].nxt)\n      if (e[j].to < target[st[i]]) in[e[j].to]++;\n  }\n  i64 res = 1;\n  int size = 0;\n  for (int i = 1; i <= num_v; ++i)\n    if (in[st[i]] == 0) {\n      res = res * dfs3(st[i], 0) % MOD * binom(sz[st[i]] + size, size) % MOD;\n      size += sz[st[i]];\n    }\n  return res;\n}\n\ni64 work() {\n  flag = 0;\n  find_circle(st[1], 0);\n  for (int i = 0; i < top; ++i) on[cir[i]] = 1;\n  for (int i = 0; i < top; ++i)\n    dfs2(cir[i], 0);\n  i64 now = 0;\n  for (int i = 0; i < top; ++i) target[cir[i]] = cir[(i + 1) % top];\n  now = (now + calc()) % MOD;\n  for (int i = 0; i < top; ++i) target[cir[i]] = cir[(i - 1 + top) % top];\n  now = (now + calc()) % MOD;\n  return now;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1, x, y; i <= N << 1; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    addedge(x, y + N);\n  }\n\n  fac[0] = ifac[0] = inv[1] = 1;\n  for (int i = 1; i <= N << 1; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i <= N << 1; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i <= N << 1; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n  \n  i64 result = 1;\n  int size = 0;\n    \n  for (int i = 1; i <= N << 1; ++i) \n    if (!vis[i]) {\n      num_e = 0, num_v = 0;\n      dfs(i, 0);\n      if (num_e != num_v) {\n\tputs(\"0\");\n\treturn 0;\n      }\n      result = result * work() % MOD * binom(size + num_v, num_v) % MOD;\n      size += num_v;\n    }\n\n  printf(\"%lld\\n\", (result + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 4];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G, loop;\nint dfn[MAXN], fa[MAXN], s, t, cnt = 0, edge = 0;\nvoid GetLoop(int x) // 找环 \n{\n\tG.push_back(x); // 森林中的一棵树 \n\tdfn[x] = ++cnt;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == fa[x])\n\t\t\tcontinue;\n\t\tif (dfn[y]) \n\t\t{\n\t\t\tif (dfn[y] < dfn[x]) continue;\n\t\t\tloop.push_back(y);\n\t\t\tfor (; y != x; y = fa[y])\n\t\t\t\tloop.push_back(fa[y]);\n\t\t}\n\t\telse { fa[y] = x; GetLoop(y); }\n\t}\n} \n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[cnt];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tscanf(\"%d\", &n);;\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!dfn[i])\n\t\t{\n\t\t\tcnt = edge = 0;\n\t\t\tGetLoop(i);\n\t\t\tif (cnt << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\ts = loop[0], t = loop[loop.size() - 1]; // 环的起点、终点 \n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tloop.clear();\n\t\t\tG.clear();\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#define MN 200000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvector<int> v[MN+5];\nint n,head[MN+5],cnt,ans=1,in[MN+5],c[MN+5],num,vis[MN+5],found,Fa[MN+5],q[MN+5],top,p[MN+5],inv[MN+5],size[MN+5],d[MN+5],f[MN+5];\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n    e[++cnt]=(edge){t,head[f]};head[f]=cnt;\n    e[++cnt]=(edge){f,head[t]};head[t]=cnt;\n}\nvoid dfs(int x,int fa)\n{\n    vis[x]=1;q[++top]=x;\n    for(int i=head[x];i;i=e[i].next)\n        if(!vis[e[i].to]) Fa[e[i].to]=x,dfs(e[i].to,x);\n        else if(e[i].to!=fa&&!found)\n        {\n            for(int t=x;t!=e[i].to;t=Fa[t]) c[++num]=t;\n            c[++num]=e[i].to;found=1;\n        }\n}\nvoid Mark(int x,int fa)\n{\n    Fa[x]=fa;\n    for(int i=head[x];i;i=e[i].next)\n        if(e[i].to!=fa&&!in[e[i].to]) Mark(e[i].to,x);\n}\ninline int CC(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid Solve(int x)\n{\n    size[x]=1;f[x]=1;\n    for(int i=0;i<v[x].size();++i)\n    {\n        Solve(v[x][i]);\n        f[x]=1LL*f[x]*f[v[x][i]]%mod*CC(size[v[x][i]]+size[x]-1,size[v[x][i]])%mod;\n        size[x]+=size[v[x][i]];\n    }\n}\nint main()\n{\n    n=read();p[0]=inv[0]=p[1]=inv[1]=1;\n    for(int i=2;i<=n<<1;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2;i<=n<<1;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n    for(int i=1;i<=n<<1;++i)\n    {\n        int x=read(),y=read();\n        ins(x,y+n);\n    }\n    for(int i=1;i<=n<<1;++i) if(!vis[i])\n    {\n        found=num=top=0;int res=0,way=1;\n        dfs(i,0);if(!found) return 0*puts(\"0\");\n        for(int j=1;j<=num;++j) in[c[j]]=j;\n        for(int j=1;j<=num;++j) Mark(c[j],0);\n        for(int j=1;j<=top;++j)\n        {\n            int to=in[q[j]]?c[in[q[j]]%num+1]:Fa[q[j]];\n            for(int k=head[q[j]];k;k=e[k].next)\n                if(e[k].to!=to&&e[k].to<to) v[q[j]].push_back(e[k].to),++d[e[k].to];\n        }\n        for(int j=1;j<=top;++j) if(!d[q[j]]) Solve(q[j]),way=1LL*way*f[q[j]]%mod*inv[size[q[j]]]%mod;\n        res=way;way=1;\n        for(int j=1;j<=top;++j) v[q[j]].clear(),d[q[j]]=0;\n        for(int j=1;j<=top;++j)\n        {\n            int to=in[q[j]]?c[(in[q[j]]+num-2)%num+1]:Fa[q[j]];\n            for(int k=head[q[j]];k;k=e[k].next)\n                if(e[k].to!=to&&e[k].to<to) v[q[j]].push_back(e[k].to),++d[e[k].to];\n        }\n        for(int j=1;j<=top;++j) if(!d[q[j]]) Solve(q[j]),way=1LL*way*f[q[j]]%mod*inv[size[q[j]]]%mod;\n        ans=1LL*ans*(res+way)%mod;\n    }\n    printf(\"%d\",1LL*ans*p[n*2]%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res;\nint f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\tdfs(x,V[x][i]);\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o,xx,yy,s=0,Res=0;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;res=1;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\ttp=3;res=1;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define N 400005\nusing namespace std;\nconst int mo=1e9+7;\nvector <int> H,M,D;\nint S,a[N],b[N],g[N],nex[N],E[N],d[N],l,r,n,x,y,w[N],R[N],f[N],v[N],s[N],e[N]; LL ans,tmp,P[N],Q[N];\nvoid fly(int x){\n\tH.push_back(x); v[x]=1;\n\tfor (int i=g[x];i;i=nex[i])\n\tif (!v[b[i]]) fly(b[i]);\n}\nvoid dfs(int x){\n\tfor (int i=g[x];i;i=nex[i])\n\tif (!E[i]) E[i]=1,E[i>n?i-n:i+n]=-1,dfs(b[i]);\n}\nLL po(LL x,int y){\n\tLL z=1;\n\tfor (;y;y>>=1,x=x*x%mo)\n\tif (y&1) z=z*x%mo;\n\treturn z;\n}\nLL C(int n,int m){\n\treturn P[n]*Q[m]%mo*Q[n-m]%mo;\n}\nint go(){\n\tfor (int i=0;i<H.size();++i) f[H[i]]=1,s[H[i]]=R[H[i]]=0;\n\tl=r=f[0]=1; s[0]=0;\n\tfor (int i=0;i<M.size();++i)\n\t\tif (E[M[i]]==1) e[a[M[i]]]=b[M[i]];\n\tfor (int i=0;i<H.size();++i)\n\t\tif (H[i]<e[e[H[i]]]) ++R[e[H[i]]];\n\tfor (int i=0;i<H.size();++i)\n\t\tif (!R[H[i]]) d[r++]=H[i];\n\twhile (l<r){\n\t\tint x=d[l]; ++s[x];\n\t\tif (x<e[e[x]]){\n\t\t\t--R[e[x]]; if (!R[e[x]]) d[r++]=e[x];\n\t\t\t(f[e[x]]*=f[x]*C(s[e[x]]+=s[x],s[x])%mo)%=mo;\n\t\t}else (f[0]*=f[x]*C(s[0]+=s[x],s[x])%mo)%=mo;\n\t\t++l;\n\t}\n\treturn f[0];\n}\nint main(){\n\tscanf(\"%d\",&n); ans=1;\n\tfor (int i=1;i<=n+n;++i){\n\t\tscanf(\"%d%d\",&x,&y); y+=n;\n\t\t++w[x]; ++w[y];\n\t\ta[i]=x; b[i]=y; nex[i]=g[x]; g[x]=i;\n\t\ta[i+n+n]=y; b[i+n+n]=x;\n\t\tnex[i+n+n]=g[y]; g[y]=i+n+n;\n\t}\n\tn+=n;\n\tP[0]=1; for (int i=1;i<=n;++i) P[i]=P[i-1]*i%mo;\n\tQ[n]=po(P[n],mo-2); for (int i=n-1;~i;--i) Q[i]=Q[i+1]*(i+1)%mo;\n\tfor (int i=1;i<=n;++i)\n\t\tif (!w[x]) return puts(\"0\"),0;\n\tfor (int I=1;I<=n;++I)\n\tif (!v[I]){\n\t\tH.clear(); M.clear(); fly(I); l=r=1;\n\t\tfor (int i=0;i<H.size();++i)\n\t\tfor (int j=g[H[i]];j;j=nex[j])\n\t\t\tM.push_back(j);\n\t\tfor (int i=0;i<H.size();++i)\n\t\t\tif (w[H[i]]==1) d[r++]=H[i];\n\t\twhile (l<r){\n\t\t\tfor (int i=g[d[l]];i;i=nex[i])\n\t\t\tif (!E[i]){\n\t\t\t\tE[i]=1; E[i>n?i-n:i+n]=-1;\n\t\t\t\t--w[a[i]]; --w[b[i]];\n\t\t\t\tif (w[b[i]]==1) d[r++]=b[i];\n\t\t\t}\n\t\t\t++l;\n\t\t}\n\t\tD.clear();\n\t\tfor (int i=0;i<H.size();++i)\n\t\t\tif (w[H[i]]&&w[H[i]]!=2) return puts(\"0\"),0;\n\t\tfor (int i=0;i<M.size();++i)\n\t\t\tif (!E[M[i]]) D.push_back(M[i]);\n\t\tdfs(a[D[0]]);\n\t\ttmp=go();\n\t\tfor (int i=0;i<D.size();++i) E[D[i]]*=-1;\n\t\t(tmp+=go())%=mo;\n\t\tans=ans*tmp%mo*C(S+=H.size(),H.size())%mo;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nconst int N = 5 * 100000 + 100;\nconst int MOD = 1000000007;\nconst int oo = 1e9;\n\nint n , x , y, take[N], in[N], sz[N];\nbool inStack[N], vis[N];\nll fact[N], inv[N];\n\nvector<int> g[N], tree[N], cycle, my;\nstack<int> st;\n\nvoid findCycle(int u , int p) {\n\tif (inStack[u]) {\n\t\twhile (1) {\n\t\t\tcycle.pb(st.top());\n\t\t\tst.pop();\n\t\t\tif (cycle.back() == u)break;\n\t\t}\n\t\tfor (int i = 0; i < cycle.size(); ++i) st.push(cycle[i]);\n\t\treturn;\n\t}\n\tif (vis[u])return;\n\tmy.pb(u);\n\ttake[u] = p;\n\tvis[u] = 1;\n\tinStack[u] = 1;\n\tst.push(u);\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tfindCycle(v, u);\n\t}\n\tinStack[u] = 0;\n\tst.pop();\n}\nbool getType(int idx) {\n\treturn idx > n;\n}\nll fast(ll a , ll b) {\n\tif (!b)return 1ll;\n\tll res = fast(a, b / 2);\n\tres = (res * res) % MOD;\n\tif (b & 1)\n\t\treturn (res * a) % MOD;\n\treturn res;\n}\nll nCk(ll n , ll k) {\n\treturn ((fact[n] * inv[n - k]) % MOD * inv[k]) % MOD;\n}\nll calc(int u) {\n\tsz[u] = 0;\n\tll ans = 1;\n\tfor (int i = 0; i < tree[u].size(); ++i) {\n\t\tint v = tree[u][i];\n\t\tll ff = calc(v);\n\t\tans = (((ans * ff ) % MOD * nCk(sz[u] + sz[v], sz[v]))) % MOD;\n\t\tsz[u] += sz[v];\n\t}\n\tsz[u]++;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tg[x + n].pb(y);\n\t\tg[y].pb(x + n);\n\t}\n\tfact[0] = 1;\n\tinv[0] = fast(fact[0], MOD - 2);\n\tfor (int i = 1 ; i <= 2 * n ; ++i) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv[i] = fast(fact[i], MOD - 2);\n\t}\n\tll ans = 1;\n\tint len = 0;\n\tfor (int node = 1 ; node <= 2 * n ; ++node) {\n\t\tif (vis[node])continue;\n\t\tcycle.clear();\n\t\tmy.clear();\n\t\tfindCycle(node, -1);\n\t\tif (cycle.size()) {\n\t\t\tfor (int i = 0; i < my.size(); ++i) {\n\t\t\t\tinStack[my[i]] = vis[my[i]] = 0;\n\t\t\t}\n\t\t\tint root = cycle[0];\n\t\t\tcycle.clear();\n\t\t\tmy.clear();\n\t\t\tfindCycle(root, -1);\n\t\t}\n\t\tint E = 0;\n\t\tfor (int i = 0; i < my.size(); ++i) {\n\t\t\tE += g[my[i]].size();\n\t\t}\n\t\tif (E != 2 * my.size()) {\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tll res = 0;\n\t\tfor (int it = 0; it < 2 ; ++it) {\n\t\t\tfor (int i = 0 ; i < my.size(); ++i) {\n\t\t\t\tin[my[i]] = 0;\n\t\t\t\ttree[my[i]].clear();\n\t\t\t}\n\t\t\ttree[0].clear();\n\t\t\tfor (int j = 0 ; j < cycle.size(); ++j) {\n\t\t\t\ttake[cycle[j]] = (it == 0 ? cycle[(j + 1) % cycle.size()] :  cycle[(j - 1 + cycle.size()) % cycle.size()]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size() ; ++i) {\n\t\t\t\tint f = my[i];\n\t\t\t\tfor (int j = 0 ; j < g[f].size(); ++j) {\n\t\t\t\t\tint v = g[f][j];\n\t\t\t\t\tif (getType(take[f]) == getType(v) && v < take[f]) {\n\t\t\t\t\t\ttree[f].pb(v);\n\t\t\t\t\t\tin[v]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size(); ++i) {\n\t\t\t\tif (!in[my[i]]) {\n\t\t\t\t\ttree[0].push_back(my[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = (res + calc(0)) % MOD;\n\t\t}\n\n\t\tans = (ans * res ) % MOD;\n\t\tans = (ans * nCk(len + my.size(), my.size())) % MOD;\n\t\tlen += my.size();\n\t}\n\tprintf(\"%lld\\n\", ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"2,Ofast,inline\")\n#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst int mod = 1e9 + 7;\n\ntemplate <typename T> T read(T &x) {\n\tint f = 0;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') f |= (c == '-'), c = getchar();\n\tfor (x = 0; c >= '0' && c <= '9'; c = getchar())\n\t\tx = (x << 3) + (x << 1) + (c ^ 48);\n\tif (f) x = -x;\n\treturn x;\n}\n\nint n, E, tim;\nint top, st[N], inv[N];\nint x[N], y[N], dir[N];\nint fir[N], nex[N], arr[N], num[N];\nint vis[N], used[N], incir[N], dp[N];\nvector<int> X[N], Y[N], cir, Eg, Eg2, node;\n\ninline void Add_Edge(int x, int y, int t) {\n \tnex[++E] = fir[x];\n\tfir[x] = E; arr[E] = y; num[E] = t;\n}\n\nvoid dfs(int x, int fa) {\n\tvis[x] = ++tim;\n\tnode.push_back(x);\n\tst[++top] = x;\n\tfor (int i = fir[x]; i; i = nex[i]) {\n\t\tif (!used[num[i]]) {\n\t\t\tEg.push_back(num[i]);\n\t\t\tused[num[i]] = 1;\n\t\t}\n\t\tif (arr[i] == fa) continue;\n\t\tif (!vis[arr[i]]) dfs(arr[i], x);\n\t\telse if (vis[arr[i]] < vis[x]) {\n\t\t\tfor (int j = top; st[j] != arr[i]; --j) {\n\t\t\t\tcir.push_back(st[j]);\n\t\t\t}\n\t\t\tcir.push_back(arr[i]);\n\t\t}\n\t}\n\t--top;\n}\n\nvoid dfs2(int x, int fa) {\n\tfor (int i = fir[x]; i; i = nex[i]) {\n\t\tif (arr[i] == fa) continue;\n\t\tif (incir[arr[i]]) continue;\n\t\tdir[num[i]] = arr[i];\n\t\tdfs2(arr[i], x);\n\t}\n}\n\nint dp_solve(int t) {\n\tif (~dp[t]) return dp[t];\n\tdp[t] = 1;\n\tif (dir[t] <= n) {\n\t\tfor (int i = 0; i < Y[y[t]].size(); ++i) {\n\t\t\tif (x[Y[y[t]][i]] < x[t]) dp[t] += dp_solve(Y[y[t]][i]);\n\t\t}\n\t}\n\tif (dir[t] > n) {\n\t\tfor (int i = 0; i < X[x[t]].size(); ++i) {\n\t\t\tif (y[X[x[t]][i]] < y[t]) dp[t] += dp_solve(X[x[t]][i]);\n\t\t}\n\t}\n\treturn dp[t];\n}\n\nint doit() {\n\tint ans = 1;\n\tfor (int i = 0; i < Eg.size(); ++i) {\n\t\tdp[Eg[i]] = -1;\n\t}\n\tfor (int i = 0; i < Eg.size(); ++i) {\n\t\tans = 1LL * ans * inv[dp_solve(Eg[i])] % mod;\n\t}\n\treturn ans;\n}\n\nvoid dfs3(int x, int fa, int beg) {\n\tfor (int i = fir[x]; i; i = nex[i]) {\n\t\tif (!incir[arr[i]]) continue;\n\t\tif (arr[i] == fa) continue;\n\t\tEg2.push_back(num[i]);\n\t\tif (arr[i] != beg) dfs3(arr[i], x, beg);\n\t}\n}\n\nint solve(int c) {\n\tint ans = 0;\n\ttop = 0;\n\tEg.clear();\n\tcir.clear();\n\tnode.clear();\n\tdfs(c, 0);\n\tif (Eg.size() != node.size()) return 0;\n\tfor (int i = 0; i < cir.size(); ++i) {\n\t\tincir[cir[i]] = 1;\n\t}\n\tfor (int i = 0; i < cir.size(); ++i) {\n\t\tdfs2(cir[i], 0);\n\t}\n\tEg2.clear();\n\tfor (int i = fir[cir[0]]; i; i = nex[i]) {\n\t\tif (arr[i] == cir[1]) {\n\t\t\tEg2.push_back(num[i]);\n\t\t\tdfs3(cir[1], cir[0], cir[0]);\n\t\t}\n\t}\n\tcir.push_back(cir[0]);\n\tfor (int i = 0; i < cir.size() - 1; ++i) {\n\t\tdir[Eg2[i]] = cir[i + 1];\n\t}\n\tans += doit();\n\tassert(cir.size() > 2);\n\tfor (int i = 0; i < cir.size() - 1; ++i) {\n\t\tdir[Eg2[i]] = cir[i];\n\t}\n\tans += doit();\n\treturn ans % mod;\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n * 2; ++i) {\n\t\tread(x[i]); read(y[i]);\n\t\tAdd_Edge(x[i] + n, y[i], i);\n\t\tAdd_Edge(y[i], x[i] + n, i);\n\t\tX[x[i]].push_back(i);\n\t\tY[y[i]].push_back(i);\n\t}\n\tinv[1] = 1;\n\tfor (int i = 2; i < N; ++i) {\n\t\tinv[i] = 1LL * -mod / i * inv[mod % i] % mod + mod;\n\t}\n\tint ans = 1;\n\tfor (int i = 1; i <= n * 2; ++i) {\n\t\tif (!vis[i]) ans = 1LL * ans * solve(i) % mod;\n\t}\n\tfor (int i = 1; i <= n * 2; ++i)\n\t\tans = 1LL * ans * i % mod;\n\tcout << ans << endl;\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint fac[200111],invf[200111];\nint cal(int x,int y){return 1ll*fac[x+y]*invf[x]%mod*invf[y]%mod;}\npii comb(pii x,pii y){return mp(1ll*x.ff*y.ff%mod*cal(x.ss,y.ss)%mod,x.ss+y.ss);}\n\nvector<int> g[200111],g2[200111];\nint n,vs[200111],tot,cyc[200111],len,to[200111],dgr[200111];\n\nbool incyc[200111],use[200111];\nint stk[200111],top,cnt,dep[200111];\n\npii dfs2(int x)\n{\n\tpii ret=mp(1,0);\n\tfor(int i=0;i<(int)g2[x].size();i++)\n\t\tret=comb(ret,dfs2(g2[x][i]));\n\tret.ss++;return ret;\n}\nvoid dfs(int x,int f=0)\n{\n\tstk[++top]=x;dep[x]=top;cnt+=2;\n\tvs[++tot]=x;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t{\n\t\tcnt--;\n\t\tif(g[x][i]==f)continue;\n\t\tif(!dep[g[x][i]])\n\t\t\tdfs(g[x][i],x);\n\t\telse if(dep[g[x][i]]<dep[x]&&len==0)\n\t\t{\n\t\t\tfor(int j=dep[g[x][i]];j<=top;j++){cyc[++len]=stk[j];incyc[stk[j]]=1;}\n\t\t}\n\t}\n\ttop--;\n}\nvoid rdfs(int x,int f=0)\n{\n\tto[x]=f;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f&&!incyc[g[x][i]])\n\t\t\trdfs(g[x][i],x);\n}\n\nint calc()\n{\n\tfor(int i=1;i<=tot;i++){g2[vs[i]].clear();dgr[vs[i]]=0;}\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tfor(int j=0;j<(int)g[vs[i]].size();j++)\n\t\t{\n\t\t\tif(to[vs[i]]>g[vs[i]][j])\n\t\t\t{\n\t\t\t\tg2[vs[i]].pb(g[vs[i]][j]);\n\t\t\t\tdgr[g[vs[i]][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tpii ret=mp(1,0);\n\tfor(int i=1;i<=tot;i++)if(dgr[vs[i]]==0)ret=comb(ret,dfs2(vs[i]));\n\treturn ret.ff;\n}\nint main()\n{\n\tfac[0]=invf[0]=1;for(int i=1;i<200111;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinvf[200111-1]=power(fac[200111-1],mod-2);\n\tfor(int i=200111-2;i>=0;i--)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\t\n\tget1(n);\n\tfor(int i=1,x,y;i<=n+n;i++)\n\t{\n\t\tget2(x,y);\n\t\tg[x].pb(y+n);\n\t\tg[y+n].pb(x);\n\t}\n\tn<<=1;\n\t\n\tpii now=mp(1,0);\n\tfor(int _=1;_<=n;_++)\n\t{\n\t\tif(dep[_])continue;\n\t\ttot=len=0;dfs(_);\n\t\tif(cnt)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=len;i++)rdfs(cyc[i]);\n\t\tint sum=0;\n\t\tfor(int i=1;i<=len;i++)to[cyc[i]]=cyc[i%len+1];\n\t\tsum+=calc();\n\t\tfor(int i=1;i<=len;i++)to[cyc[i%len+1]]=cyc[i];\n\t\tsum+=calc();if(sum>=mod)sum-=mod;\n\t\tnow=comb(now,mp(sum,tot));\n\t}\n\t\n\tprintendl(now.ff);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2000005,mod=1e9+7;\nint n,cc,tt,tp,ans,a[N],b[N],c[N],fa[N],f[N],dep[N],stk[N],val[N],hd[N],rt[N],cir[N],sz[N],fac[N],ifac[N];\nvector<int>G[N];\nstruct E{int v,nxt,w;}e[N];\ninline void add(int u,int v,int w){e[++cc]=(E){v,hd[u],w};hd[u]=cc;}\ninline int pw(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)r=1ll*r*a%mod;return r;} \nvoid dfs(int x,int p)\n{\n\tc[++c[0]]=stk[++tp]=x;fa[x]=p;dep[x]=dep[p]+1;\n\tfor(int i=hd[x];i;i=e[i].nxt)if(e[i].v!=p)\n\t{\n\t\tval[tp]=e[i].w;\n\t\tif(!dep[e[i].v])dep[e[i].v]=dep[x]+1,dfs(e[i].v,x);\n\t\telse for(int j=tp-dep[x]+dep[e[i].v];j<=tp;j++)cir[stk[j]]=1,a[++tt]=stk[j],b[tt]=val[j];\n\t}\n\ttp--;\n} \nvoid dfs1(int x,int p){for(int i=hd[x];i;i=e[i].nxt)if(e[i].v!=p)val[e[i].v]=e[i].w,dfs1(e[i].v,x);}\nvoid dfs2(int x)\n{\n\tf[x]=sz[x]=1;\n\tfor(int i=0,y;i<G[x].size();i++)dfs2(y=G[x][i]),sz[x]+=sz[y],f[x]=1ll*f[x]*f[y]%mod*ifac[sz[y]]%mod;\n\tf[x]=1ll*f[x]*fac[sz[x]-1]%mod;\n}\nint sol()\n{\n\tint res=1;\n\tfor(int i=1;i<=c[0];i++)G[c[i]].clear(),rt[c[i]]=0;\n\tfor(int i=1;i<=c[0];i++)for(int j=hd[c[i]];j;j=e[j].nxt)if(e[j].w<val[c[i]])G[c[i]].push_back(e[j].v),rt[e[j].v]=1;\n\tfor(int i=1;i<=c[0];i++)if(!rt[c[i]])dfs2(c[i]),res=1ll*res*f[c[i]]%mod*ifac[sz[c[i]]]%mod;\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=fac[0]=1;i<=2*n;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[2*n]=pw(fac[2*n],mod-2);\n\tfor(int i=2*n;i;i--)ifac[i-1]=1ll*ifac[i]*i%mod;\n\tfor(int i=1,u,v;i<=2*n;i++)scanf(\"%d%d\",&u,&v),add(u,v+n,u+v),add(v+n,u,u+v);\n\tans=fac[2*n];\n\tfor(int i=1;i<=2*n;i++)if(!dep[i])\n\t{\n\t\ttt=c[0]=0;dep[i]=1;dfs(i,i);\n\t\tfor(int j=1;j<=tt;j++)for(int k=hd[a[j]];k;k=e[k].nxt)if(!cir[e[k].v])val[e[k].v]=e[k].w,dfs1(e[k].v,a[j]);\n\t\tfor(int j=1;j<=tt;j++)val[a[j]]=b[j];\n\t\tint res=sol();\n\t\tfor(int j=1;j<tt;j++)val[a[j+1]]=b[j];val[a[1]]=b[tt];\n\t\tans=1ll*ans*(res+sol())%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,o,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\tdfs(x,V[x][i]);\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vx[X][i]!=o){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vy[Y][i]!=o){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\to=0;int xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\tw[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\tw[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tprintf(\"1\");\n\treturn 0;\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\n#define int long long\nusing namespace std;\nconst int p = 1000000007;\nint n;\nint head[N],ver[N],nxt[N],tot;\nvoid add(int a,int b)\n{\n    tot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;return ;\n}\nint jie[N],ni[N];\nint c(int x,int y)\n{\n    return 1LL*jie[x]*ni[y]%p*ni[x-y]%p;\n}\nint v[N],dian,bian,st[N],top;\nint pi[N],cir[N],sz,q[N];\nvoid dfs(int x,int fa)\n{\n    st[++top]=x;\n    v[x]=1;q[++dian]=x;\n    for(int i=head[x];i;i=nxt[i])\n    {\n        bian++;\n        if(!v[ver[i]])dfs(ver[i],x);\n        else if(ver[i]!=fa&&!sz)\n        {\n            for(int j=top;j>=1;j--)\n            {\n                cir[++sz]=st[j];\n                if(st[j]==ver[i])break;\n            }\n        }\n    }\n    top--;\n    return ;\n}\nint now;\nvoid sao(int x,int f)\n{\n    for(int i=head[x];i;i=nxt[i])\n    {\n        if(ver[i]==f)continue;\n        pi[ver[i]]=x;\n        if(ver[i]==now)continue;\n        sao(ver[i],x);\n    }\n}\nvector<int>vv[N];\nint size[N],fa[N],f[N];\nvoid dp(int x)\n{\n    f[x]=1;size[x]=1;\n    for(int i=0;i<vv[x].size();i++)\n    {\n        dp(vv[x][i]);\n        size[x]+=size[vv[x][i]];\n        f[x]=1LL*f[x]*f[vv[x][i]]%p*c(size[x]-1,size[vv[x][i]])%p;\n    }\n}\nint solve()\n{\n    for(int j=1;j<=dian;j++)fa[q[j]]=0;\n    for(int j=1;j<=dian;j++)\n    {\n        int u=q[j];vv[u].clear();\n        for(int k=head[u];k;k=nxt[k])\n        {\n            if(ver[k]<pi[u])\n            {\n                vv[u].push_back(ver[k]),fa[ver[k]]=u;\n            }\n        }\n    }\n    int ans=1;int szzz=0;\n    for(int j=1;j<=dian;j++)\n    {\n        if(!fa[q[j]])\n        {\n            dp(q[j]);szzz+=size[q[j]];\n            ans=1LL*ans*f[q[j]]%p*c(szzz,size[q[j]])%p;\n        }\n    }\n    return ans;\n}\nsigned main()\n{\n    scanf(\"%lld\",&n);\n    jie[0]=ni[0]=ni[1]=1;\n    for(int i=1;i<=2*n;i++)jie[i]=1LL*jie[i-1]*i%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*(p-p/i)*ni[p%i]%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*ni[i-1]*ni[i]%p;\n    for(int i=1;i<=2*n;i++)\n    {\n        int t1,t2;scanf(\"%lld%lld\",&t1,&t2);\n        add(t1,t2+n);add(t2+n,t1);\n    }\n    int ans=1;int nw=2*n;\n    for(int i=1;i<=2*n;i++)\n    {\n        if(v[i])continue;\n        dian=sz=bian=0;\n        dfs(i,-1);bian/=2;\n        if(dian!=bian)return puts(\"0\"),0;\n        now=cir[sz];\n        sao(cir[sz],-1);\n        cir[sz+1]=cir[1];\n        int as=solve();\n        for(int j=1;j<=sz;j++)pi[cir[j]]=cir[j+1];\n        as+=solve();\n        ans=1LL*ans*c(nw,dian)%p*as%p;\n        nw-=dian;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2e5 + 10, mod = 1e9 + 7;\n\nint n, cntv, cnte, ans, oth, root, fac[maxn], ifac[maxn], par[maxn], dep[maxn], siz[maxn], flag;\nbool vis[maxn], on_cyc[maxn], isr[maxn][2], viss[maxn];\nstd::vector<int> dag[maxn][2], cur;\n\nstruct edge {\n\tint to, id;\n\n\tedge() {}\n\tedge(int to, int id): to(to), id(id) {}\n};\n\nstd::vector<edge> g[maxn];\n\ninline int pow_mod(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * x * y % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < maxn; ++i) {\n\t\tfac[i] = (long long) i * fac[i - 1] % mod;\n\t}\n\tifac[maxn - 1] = pow_mod(fac[maxn - 1], mod - 2);\n\tfor (int i = maxn - 1; i; --i) {\n\t\tifac[i - 1] = (long long) i * ifac[i] % mod;\n\t}\n\treturn;\n}\n\ninline void dfs1(int u, int p = -1, int d = 0) {\n\tcur.push_back(u);\n\tvis[u] = 1;\n\tpar[u] = p;\n\tdep[u] = d;\n\t++cntv;\n\tcnte += (int) g[u].size();\n\tfor (auto &e: g[u]) {\n\t\tint v = e.to;\n\t\tif(v == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[v]) {\n\t\t\troot = dep[u] < dep[v] ? v : u;\n\t\t\toth = u + v - root;\n\t\t}\n\t\telse {\n\t\t\tdfs1(v, u, d + 1);\n\t\t}\n\t}\n\treturn;\n}\n\ninline void dfs2(int u, int p = -1) {\n\tviss[u] = 1;\n\tpar[u] = p;\n\tfor (auto &e: g[u]) {\n\t\tint v = e.to;\n\t\tif(!viss[v]) {\n\t\t\tdfs2(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\ninline int DP(int u) {\n\tsiz[u] = 1;\n\tint ret = 1;\n\tfor (int &v: dag[u][flag]) {\n\t\tret = (long long) DP(v) * ret % mod;\n\t\tsiz[u] += siz[v];\n\t\tret = (long long) ret * ifac[siz[v]] % mod;\n\t}\n\treturn (long long) ret * fac[siz[u] - 1] % mod;\n}\n\nint main() {\n\tprepare();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x;\n\t\ty += n - 1;\n\t\tg[x].push_back(edge(y, i));\n\t\tg[y].push_back(edge(x, i));\n\t}\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tisr[i][0] = isr[i][1] = 1;\n\t}\n\tans = fac[n << 1];\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tif(!vis[i]) {\n\t\t\tcur.clear();\n\t\t\tcntv = cnte = 0;\n\t\t\tdfs1(i);\n\t\t\tif((cntv << 1) != cnte) {\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tflag = 0;\n\t\t\tint ban;\n\t\t\tfor (int u = root; u != oth; u = par[u]) {\n\t\t\t\ton_cyc[u] = 1;\n\t\t\t}\n\t\t\ton_cyc[oth] = 1;\n\t\t\tfor (auto &e: g[root]) {\n\t\t\t\tif(on_cyc[e.to]) {\n\t\t\t\t\tban = e.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u = root; ; ) {\n\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\tif(on_cyc[v] && i != ban) {\n\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tban = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u == root) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs2(root);\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(!on_cyc[u]) {\n\t\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\t\tif(v == par[u]) {\n\t\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res1 = 1;\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(isr[u][flag]) {\n\t\t\t\t\tres1 = (long long) DP(u) * res1 % mod * ifac[siz[u]] % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = 1;\n\t\t\tfor (auto &e: g[root]) {\n\t\t\t\tif(on_cyc[e.to]) {\n\t\t\t\t\tban = e.id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u = root; ; ) {\n\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\tif(on_cyc[v] && i != ban) {\n\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tban = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u == root) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs2(root);\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(!on_cyc[u]) {\n\t\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\t\tif(v == par[u]) {\n\t\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res2 = 1;\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(isr[u][flag]) {\n\t\t\t\t\tres2 = (long long) DP(u) * res2 % mod * ifac[siz[u]] % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = (long long) (res1 + res2) * ans % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ΔARC083F\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 222222;\nconst int MO = 1e9+7;\nint mul(int x,int y){\n\treturn (LL)x*y%MO;\n}\nint fpow(int x,int y=MO-2){\n\tint z=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tz=mul(z,x);\n\t\ty>>=1;\n\t\tx=mul(x,x);\n\t}\n\treturn z;\n}\nint fac[N];\nint n,a[N],b[N],c[N],p[N],r[N],t[N];\nvector<int> v[N],h[N],g[N],w,e;\nint tx,ty,tz;\nvoid dfs1(int u,int fa){\n\tint i,x;\n\tc[u]=1;\n\tw.push_back(u);\n\tfor(i=0;i<v[u].size();i=i+1){\n\t\tx=v[u][i];\n\t\tif(x==fa)\n\t\t\tcontinue;\n\t\tif(c[x]){\n\t\t\tif(u<x)\n\t\t\t\te.push_back(h[u][i]);\n\t\t\ttx=u,ty=x,tz=h[u][i];\n\t\t\tcontinue;\n\t\t}\n\t\te.push_back(h[u][i]);\n\t\tdfs1(x,u);\n\t}\n}\nvoid dfs2(int u,int fa){\n\tint i,x;\n\tfor(i=0;i<v[u].size();i=i+1){\n\t\tx=v[u][i];\n\t\tif(x<0||x==fa)\n\t\t\tcontinue;\n\t\tp[h[u][i]]=x;\n\t\tr[x]=h[u][i];\n\t\tdfs2(x,u);\n\t}\n}\nvoid dfs3(int u){\n\tif(t[u])\n\t\treturn;\n\tint i,x;\n\tt[u]=1;\n\tfor(i=0;i<g[u].size();i=i+1){\n\t\tx=g[u][i];\n\t\tdfs3(x);\n\t\tt[u]+=t[x];\n\t}\n}\nint solve(){\n\tint i,x,y;\n\tfor(i=0;i<w.size();i=i+1){\n\t\tx=r[w[i]];\n\t\tif(w[i]<=n){\n\t\t\ty=r[n+b[x]];\n\t\t\tif(a[y]>a[x])\n\t\t\t\tg[y].push_back(x);\n\t\t}\n\t\telse{\n\t\t\ty=r[a[x]];\n\t\t\tif(b[y]>b[x])\n\t\t\t\tg[y].push_back(x);\n\t\t}\n\t}\n\tfor(i=0;i<e.size();i=i+1)\n\t\tt[e[i]]=0;\n\tfor(i=0;i<e.size();i=i+1)\n\t\tif(!t[e[i]])\n\t\t\tdfs3(e[i]);\n\tx=1;\n\tfor(i=0;i<e.size();i=i+1)\n\t\tx=mul(x,t[e[i]]),g[e[i]].clear();\n\treturn fpow(x);\n}\nint main()\n{\n\tint i,j,s,o;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n+n;i=i+1){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tv[a[i]].push_back(n+b[i]);\n\t\th[a[i]].push_back(i);\n\t\tv[n+b[i]].push_back(a[i]);\n\t\th[n+b[i]].push_back(i);\n\t}\n\tfac[0]=1;\n\tfor(i=1;i<=n+n;i=i+1)\n\t\tfac[i]=mul(fac[i-1],i);\n\ts=fac[n+n];\n\tfor(i=1;i<=n+n;i=i+1){\n\t\tif(!c[i]){\n\t\t\tw.clear();\n\t\t\te.clear();\n\t\t\ttx=0,ty=0,tz=0;\n\t\t\tdfs1(i,0);\n\t\t\tif(w.size()!=e.size()){\n\t\t\t\tcout<<0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor(j=0;j<v[tx].size();j=j+1)\n\t\t\t\tif(v[tx][j]==ty)\n\t\t\t\t\tv[tx][j]=-1;\n\t\t\tfor(j=0;j<v[ty].size();j=j+1)\n\t\t\t\tif(v[ty][j]==tx)\n\t\t\t\t\tv[ty][j]=-1;\n\t\t\tp[tz]=tx,r[tx]=tz;\n\t\t\tdfs2(tx,0);\n\t\t\to=solve();\n\t\t\tp[tz]=ty,r[ty]=tz;\n\t\t\tdfs2(ty,0);\n\t\t\to+=solve();\n\t\t\ts=mul(s,o);\n\t\t}\n\t}\n\tcout<<s;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR(i,a,b) for(int i=a;i>=b;i--)\n#define FO(i,a,b) for(int i=a;i<=b;i++)\n#define FE(i,a,b) for(int i=a;i<b;i++)\n#define R(i) i=read()\nusing namespace std;\ntypedef long long ll;\nconst int N=200005,MOD=1e9+7;\nint fac[N+10],inv[N+10],head[N],nxt[2*N],to[2*N];\nint pd[N],vis[N],in_cycle[N],f[N],sz[N],instack[N],use[2*N],ass[N],dg[N];\nint n,t,find_cycle,node_cnt,edge_cnt;\nstruct ANS {\n\tint size,ans;\n};\nstack <int> S;\nvector <int> E[N],cycle,Node;\nvector <ANS> Ans;\nint read() {\n\tint x=0;char c=getchar();\n\twhile((c<48||c>57)&&c!='-') c=getchar();\n\tif(c=='-') {c=getchar();while(c>=48&&c<=57) x=x*10-c+48,c=getchar();}\n\telse while(c>=48&&c<=57) x=x*10+c-48,c=getchar();\n\treturn x;\n}\nvoid add(int x,int y) {\n\tnxt[++t]=head[x],head[x]=t,to[t]=y;\n//\tcout<<x<<\" ---> \"<<y<<endl;\n}\nint qmd(int a,int b,int p) {\n\tint t=1;\n\twhile(b) {\n\t\tif(b&1) t=(ll) t*a%MOD;\n\t\ta=(ll) a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn t;\n}\nvoid dfs_cycle(int u,int fa) {\n\tS.push(u);instack[u]=1;\n\tfor(int i=head[u];i!=-1;i=nxt[i]) {\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tif(instack[v]) {\n\t\t\tfind_cycle=1;\n\t\t\tint now=-1;\n\t\t\twhile(now!=v) {\n\t\t\t\tnow=S.top();S.pop();instack[now]=0;\n\t\t\t\tcycle.push_back(now),in_cycle[now]=1;\n\t\t\t}\n\t\t}\n\t\telse dfs_cycle(v,u); \n\t\tif(find_cycle) return ;\n\t}\n\tS.pop(),instack[u]=0;\n}\nvoid dfs_all(int u,int fa) {\n\tvis[u]=1,Node.push_back(u);node_cnt++;\n\tfor(int i=head[u];i!=-1;i=nxt[i]) {\n\t\tint v=to[i];\n\t\tif(!use[i]&&!use[i^1]) edge_cnt++,use[i]=use[i^1]=1;\n\t\tif(!vis[v]&&v!=fa) dfs_all(v,u);\n\t}\n}\nvoid dfs(int u,int fa) {\n\tpd[u]=1;\n\tfor(int i=head[u];i!=-1;i=nxt[i]) {\n\t\tint v=to[i];\n\t\tif(!pd[v]&&v!=fa) \n\t\t\tdfs(v,u);\n\t}\n\tif(!in_cycle[u]) ass[u]=fa;\n}\nvoid dfs_cal(int u) {\n\tint lim=E[u].size(),sum=0,mul=1,aans;\n\tFE(i,0,lim) {\n\t\tdfs_cal(E[u][i]);\n\t\tsum+=sz[E[u][i]],mul=(ll) mul*f[E[u][i]]%MOD;\n\t}\n\taans=fac[sum];\n\tFE(i,0,lim)\n\t\taans=(ll) aans*inv[sz[E[u][i]]]%MOD;\n\taans=(ll) aans*mul%MOD;\n\tsz[u]=sum+1,f[u]=aans;\n}\nint work(int u) {\n\tfind_cycle=0,cycle.clear(),Node.clear();\n\twhile(!S.empty()) instack[S.top()]=0,S.pop();\n\tint l_node_cnt=node_cnt,l_edge_cnt=edge_cnt;\n\tdfs_all(u,0);\n\tif(node_cnt-l_node_cnt!=edge_cnt-l_edge_cnt) return 0;\n\tdfs_cycle(u,0);\n\t\n//\tint tmp=cycle.size();\n//\tcout<<\"cycle : \";\n//\tFE(i,0,tmp) cout<<cycle[i]<<' ';\n//\tcout<<endl;\n\t\n\tdfs(cycle[0],0);\n\t\n\tint lim=cycle.size();\n\tFE(i,0,lim) ass[cycle[i]]=cycle[(i-1+lim)%lim];\n\tlim=Node.size();\n\tFE(i,0,lim) E[Node[i]].clear(),dg[Node[i]]=0;\t//先清零dg[] \n\tFE(i,0,lim) {\n\t\tint u=Node[i];\n\t\tfor(int j=head[u];j!=-1;j=nxt[j]) {\n\t\t\tint v=to[j];\n\t\t\tif(v<ass[u]) \n\t\t\t\tE[u].push_back(v),dg[v]++;\n//\t\t\t\tcout<<u<<\" ---> \"<<v<<endl;\n\t\t}\n\t}\n\t\n//\tcout<<endl<<endl;\n\t\n\t\n\tE[0].clear();\n\tFE(i,0,lim) if(dg[Node[i]]==0) E[0].push_back(Node[i]);\n\tf[0]=0;\n\tdfs_cal(0);\n\tint ans1=f[0];\n\tlim=cycle.size();\n\tFE(i,0,lim) ass[cycle[i]]=cycle[(i+1)%lim];\n\tlim=Node.size();\n\tFE(i,0,lim) E[Node[i]].clear(),dg[Node[i]]=0;\n\tFE(i,0,lim) {\n\t\tint u=Node[i];\n\t\tfor(int j=head[u];j!=-1;j=nxt[j]) {\n\t\t\tint v=to[j];\n\t\t\tif(v<ass[u]) \n\t\t\t\tE[u].push_back(v),dg[v]++;\n//\t\t\t\tcout<<u<<\" ---> \"<<v<<endl;\n\t\t}\n\t}\n\tE[0].clear();\n\tFE(i,0,lim) if(dg[Node[i]]==0) E[0].push_back(Node[i]);\n\tf[0]=0;\n\tdfs_cal(0);\n\tint ans2=f[0];\n\tAns.push_back((ANS) {Node.size(),(ans1+ans2)%MOD});\n\treturn 1;\n}\nvoid init() {\n\tfac[0]=inv[0]=1;\n\tFO(i,1,N) \n\t\tfac[i]=((ll)fac[i-1]*i)%MOD;\n\tFO(i,1,N) inv[i]=qmd(fac[i],MOD-2,MOD);\n\tmemset(head,-1,sizeof(head));\n\tt=-1;\n}\nint main() {\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tinit();\n\tcin>>n;\n\tint a,b;\n\tFO(i,1,2*n) cin>>a>>b,add(a,n+b),add(n+b,a);\n\tFO(i,1,2*n) \n\t\tif(!vis[i])\n\t\t\tif(!work(i)) {cout<<-1;return 0;}\n\tint lim=Ans.size(),sum=0,mul=1,ans;\n\tFE(i,0,lim) \n\t\tsum+=Ans[i].size,mul=(ll) mul*Ans[i].ans%MOD;\n\tans=fac[sum];\n\tFE(i,0,lim)\n\t\tans=(ll) ans*inv[Ans[i].size]%MOD;\n\tans=(ll) ans*mul%MOD;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main() {\n  puts(\"0\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\n#include<set>\n#define lowbit(o) o&(-o)\n#define P 1000000007\n#define N 200005\nusing namespace std;\nint i,j,k,l,s,r,n,m,jc[N],ny[N],fa[N],A[2][N],B[2][N],tot,T,vis[2][N],id[N];\nint ans,Ans,si,G[N];\nset<int>GT[2][N],V[2][N];\nset<int>::iterator GTW;\nstruct orz {\n\tint x,y;\n}a[N],q[N],Q[N];\nstruct node {\n\tint tot,last[N],to[N],next[N];\n\tinline void add(int x,int y) {\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A1;\nstruct Node {\n\tint tot,chu[N],ru[N],l,r,last[N],next[N],to[N],f[N],si[N];\n\torz q[N];\n\tinline void add(int x,int y) {\n\t\tchu[x]++; ru[y]++;\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A2;\ninline bool cmp(int x,int y) {\n\treturn G[x]<G[y];\n}\ninline int findl(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=0;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]<x) s=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn s+1;\n}\ninline int findr(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=2*n+1;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]>x) s=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn s-1;\n}\ninline int quick(int x,int y) {\n\tint s=1;\n\twhile (y) {\n\t\tif (y&1) s=1ll*s*x%P;\n\t\tx=1ll*x*x%P;\n\t\ty>>=1;\n\t}\n\treturn s;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\ninline int C(int x,int y) {\n\treturn 1ll*jc[x]*ny[y]%P*ny[x-y]%P;\n}\ninline int getans(int r) {\n\tT=s=0;\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].insert(q[i].y);\n//\tfor (int i=0;i<=1;i++) for (int j=1;j<=n;j++) if (get(i*n+j)==get(q[1].x*n+q[1].y)) {\n\tint L=findl(get(q[1].x*n+q[1].y)),R=findr(get(q[1].x*n+q[1].y));\n\tfor (int i=L;i<=R;i++) {\n\t\ts++;\n\t\tQ[++T].x=(id[i]-1)/n,Q[T].y=(id[i]-1)%n+1;\n\t\tif (A[Q[T].x][Q[T].y]) {\n \t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>A[Q[T].x][Q[T].y]) break;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>B[Q[T].x][Q[T].y]) break;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t}\n\tA2.l=A2.r=0;\n\tA2.f[A2.si[0]=0]=1;\n\tfor (int i=1;i<=T;i++) A2.f[Q[i].x*n+Q[i].y]=1;\n\tfor (int i=1;i<=T;i++) if (!A2.chu[Q[i].x*n+Q[i].y]) A2.add(Q[i].x*n+Q[i].y,0);\n\tfor (int i=1;i<=T;i++) if (!A2.ru[Q[i].x*n+Q[i].y]) A2.q[++A2.r].x=Q[i].x,A2.q[A2.r].y=Q[i].y;\n\twhile (A2.l<A2.r) {\n\t\tA2.l++;\n\t\tA2.si[A2.q[A2.l].x*n+A2.q[A2.l].y]++;\n\t\tfor (int i=A2.last[A2.q[A2.l].x*n+A2.q[A2.l].y];i;i=A2.next[i]) {\n\t\t\tA2.ru[A2.to[i]]--;\n\t\t\tA2.si[A2.to[i]]+=A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y];\n\t\t\t(A2.f[A2.to[i]]=1ll*A2.f[A2.to[i]]*A2.f[A2.q[A2.l].x*n+A2.q[A2.l].y]%P*C(A2.si[A2.to[i]],A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y])%P);\n\t\t\tif (!A2.ru[A2.to[i]]) A2.q[++A2.r].x=(A2.to[i]-1)/n,A2.q[A2.r].y=(A2.to[i]-1)%n+1;\n\t\t}\n\t}\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].erase(q[i].y);\n\tA2.tot=0;\n\tfor (int i=1;i<=A2.r;i++) A2.last[A2.q[i].x*n+A2.q[i].y]=0,A2.chu[A2.q[i].x*n+A2.q[i].y]=A2.ru[A2.q[i].x*n+A2.q[i].y]=0;\n\tfor (int i=1;i<=T;i++) A2.f[A2.q[i].x*n+A2.q[i].y]=A2.si[A2.q[i].x*n+A2.q[i].y]=0;\n\treturn A2.f[0];\n}\ninline void work(int x,int y) {\n\tvis[x][y]=1;\n\tint l=0,r=1; q[1].x=x,q[1].y=y;\n\twhile (l<r) {\n\t\t++l;\n\t\tfor (GTW=GT[q[l].x][q[l].y].begin();GTW!=GT[q[l].x][q[l].y].end();GTW++) if (!vis[q[l].x^1][(*GTW)]) q[++r].x=q[l].x^1,q[r].y=(*GTW),vis[q[r].x][q[r].y]=1;\n\t}\n\tfor (int i=1;i<=r;i++) for (GTW=GT[q[i].x][q[i].y].begin();GTW!=GT[q[i].x][q[i].y].end();GTW++) A1.add(q[i].x*n+q[i].y,(*GTW));\n\tint xx=x,yy=y;\n\tB[xx][yy]=A1.to[A1.last[xx*n+yy]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) if (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tAns=getans(r);\n\t\n\tfor (int i=1;i<=r;i++) B[q[i].x][q[i].y]=0;\n\tB[xx][yy]=A1.to[A1.next[A1.last[xx*n+yy]]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) if (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tA1.tot=0;\n\tfor (int i=1;i<=r;i++) A1.last[q[i].x*n+q[i].y]=0;\n\t(Ans+=getans(r))%=P;\n\tsi+=s;\n\t(ans=1ll*ans*Ans%P*C(si,s)%P);\n}\ninline void doit() {\n\tjc[0]=1;\n\tfor (int i=1;i<=200000;i++) jc[i]=1ll*jc[i-1]*i%P;\n\tny[200000]=quick(jc[200000],P-2);\n\tfor (int i=199999;i;i--) ny[i]=1ll*ny[i+1]*(i+1)%P;\n\tny[0]=1;\n}\nint main() {\n\tdoit();\n\tans=1; si=0;\n\tscanf(\"%d\",&n);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) fa[i*n+j]=i*n+j;\n\tfor (i=1;i<=2*n;i++) {\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tif (get(a[i].x)!=get(n+a[i].y)) fa[get(a[i].x)]=get(n+a[i].y);\n\t\tGT[0][a[i].x].insert(a[i].y);\n\t\tGT[1][a[i].y].insert(a[i].x);\n\t}\n\tfor (i=1;i<=2*n;i++) if (get(id[i]=i)==i) G[i]=++tot;\n\tfor (i=1;i<=2*n;i++) G[i]=G[get(i)];\n\ttot=0;\n\tsort(id+1,id+1+2*n,cmp);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!GT[i][j].size()) return puts(\"0\"),0;\n\telse if (GT[i][j].size()==1) q[++r].x=i,q[r].y=j;\n\twhile (l<r) {\n\t\t++l;\n\t\tif (!GT[q[l].x][q[l].y].size()) return puts(\"0\"),0;\n\t\tA[q[l].x][q[l].y]=(*GT[q[l].x][q[l].y].begin());\n\t\tGT[q[l].x^1][A[q[l].x][q[l].y]].erase(q[l].y);\n\t\tif (GT[q[l].x^1][A[q[l].x][q[l].y]].size()==1) q[++r].x=q[l].x^1,q[r].y=A[q[l].x][q[l].y];\n\t}\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (A[i][j]) V[i^1][A[i][j]].insert(j);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!vis[i][j]&&GT[i][j].size()==2) \n\twork(i,j);\n\tprintf(\"%d\\n\",ans);\n}\n "
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nconst int mod=1e9+7;\nint n,ans;\nint x[maxn],y[maxn],par[maxn],dep[maxn],deg[maxn];\nbool vis[maxn],incyc[maxn],done[maxn];\nvector<int>edge[maxn],cyc,nedge[maxn],path,qryx[maxn],qryy[maxn];\nint fac[maxn],ifac[maxn],dp[maxn],sz[maxn];\nbool ok;\nvector<pii>xs[maxn],ys[maxn];\n\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nvoid dfs1(int x,int p,int d){\n\tvis[x]=true;\n\tpar[x]=p;\n\tdep[x]=d;\n\tpath.pb(x);\n\trep(i,edge[x].size()){\n\t\tint y=edge[x][i];\n\t\tif(y==p||incyc[y])continue;\n\t\tif(!vis[y])dfs1(y,x,d+1);\n\t\telse if(dep[y]<dep[x]){\n\t\t\tif(!cyc.empty())ok=false;\n\t\t\tint z=x;\n\t\t\twhile(z!=y)cyc.pb(z),z=par[z];\n\t\t\tcyc.pb(z);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x){\n\tdp[x]=1;\n\tsz[x]=0;\n\trep(i,nedge[x].size()){\n\t\tint y=nedge[x][i];\n\t\tdfs2(y);\n\t\tdp[x]=1LL*dp[x]*C(sz[x]+sz[y],sz[y])%mod*dp[y]%mod; \n\t\tsz[x]+=sz[y];\n\t}\n\tsz[x]++;\n}\n\nvoid add(int cur,int nxt){\n\tif(cur<=n){\n\t\tint pos=lower_bound(xs[cur].begin(),xs[cur].end(),mp(nxt-n,0))-xs[cur].begin();\n\t\tqryx[cur].pb(pos);\n//\t\tcout<<\"add: \"<<cur<<\" \"<<pos<<endl;\n\t}\n\telse{\n\t\tint pos=lower_bound(ys[cur-n].begin(),ys[cur-n].end(),mp(nxt,0))-ys[cur-n].begin();\n\t\tqryy[cur-n].pb(pos);\n//\t\tcout<<\"add: \"<<cur-n<<\" \"<<pos<<endl;\n\t}\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2*n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,2*n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tREP(i,2*n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\txs[x[i]].pb(mp(y[i],i));\n\t\tys[y[i]].pb(mp(x[i],i));\n\t\tedge[x[i]].pb(y[i]+n);\n\t\tedge[y[i]+n].pb(x[i]);\n\t}\n\tREP(i,n){\n\t\tsort(xs[i].begin(),xs[i].end());\n\t\tsort(ys[i].begin(),ys[i].end());\n\t}\n\tans=1;\n\tint tsz=0;\n\tREP(i,2*n)if(!vis[i]){\n\t\tok=true;\n\t\tcyc.clear();\n\t\tpath.clear();\n\t\tdfs1(i,0,0);\n\t\tif(cyc.empty())ok=false;\n\t\tif(!ok){\n\t\t\tans=0;\n\t\t\tbreak;\n\t\t}\n\t\trep(j,cyc.size())incyc[cyc[j]]=true;//,cout<<cyc[j]<<\" \";\n//\t\tcout<<endl;\n\t\trep(j,path.size())vis[path[j]]=false;\n\t\tpath.clear();\n\t\trep(j,cyc.size())dfs1(cyc[j],0,0);\n//\t\trep(j,path.size())if(!incyc[path[j]])cout<<path[j]<<\" \"<<par[path[j]]<<endl;\n\t\tint sum=0;\n\t\tfor(int t=-1;t<=1;t+=2){\n\t\t\trep(j,path.size())nedge[path[j]].clear(),deg[path[j]]=0,done[path[j]]=false;\n\t\t\trep(j,path.size())if(!incyc[path[j]])add(path[j],par[path[j]]);\n\t\t\trep(j,cyc.size())add(cyc[j],cyc[(j+t+int(cyc.size()))%int(cyc.size())]);\n\t\t\trep(j,path.size()){\n\t\t\t\tint x=path[j];\n\t\t\t\tif(done[x])continue;\n\t\t\t\tdone[x]=true;\n\t\t\t\tif(x<=n){\n\t\t\t\t\tsort(qryx[x].begin(),qryx[x].end());\n\t\t\t\t\tint last=-1;\n\t\t\t\t\trep(k,qryx[x].size()){\n\t\t\t\t\t\tfor(int p=last+1;p<qryx[x][k];p++){\n\t\t\t\t\t\t\tnedge[xs[x][qryx[x][k]].snd].pb(xs[x][p].snd);\n\t\t\t\t\t\t\tdeg[xs[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryx[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryx[x].clear();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx-=n;\n\t\t\t\t\tsort(qryy[x].begin(),qryy[x].end());\n\t\t\t\t\tint last=-1;\n\t\t\t\t\trep(k,qryy[x].size()){\n\t\t\t\t\t\tfor(int p=last+1;p<qryy[x][k];p++){\n\t\t\t\t\t\t\tnedge[ys[x][qryy[x][k]].snd].pb(ys[x][p].snd);\n\t\t\t\t\t\t\tdeg[ys[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryy[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryy[x].clear();\n\t\t\t\t}\n\t\t\t}\n//\t\t\tREP(i,2*n)rep(j,nedge[i].size())cout<<\"nedge: \"<<i<<\" \"<<nedge[i][j]<<endl; \n\t\t\tint cur=1,csz=0;\n\t\t\trep(j,path.size())if(!deg[path[j]]){\n\t\t\t\tdfs2(path[j]);\n\t\t\t\tcur=1LL*cur*dp[path[j]]%mod*C(csz+sz[path[j]],sz[path[j]])%mod;\n//\t\t\t\tcout<<path[j]<<\" \"<<dp[path[j]]<<endl;\n\t\t\t\tcsz+=sz[path[j]];\n\t\t\t}\n\t\t\tsum=(sum+cur)%mod;\n\t\t}\n\t\tans=1LL*ans*sum%mod*C(tsz+path.size(),path.size())%mod;\n\t\ttsz+=path.size();\n\t}\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tint sz=V[x].size();\n\t\tref(i,0,sz-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\t/*\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n\t*/\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\nint n,fac[200100],inv[200100],ans,cntv,cnte,a[200100],deg[200100],link[200100],s[200100];\nbool flag[200100];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[600100],*tp=pool,*fst[200100],*fst2[200100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nint c(int n,int m)\n{\n    return LL(fac[n])*inv[m]%p*inv[n-m]%p;\n}\n\nvoid addedge(int u,int v,edge **fst)\n{\n    *tp=(edge){v,fst[u]},fst[u]=tp++;\n}\n\nvoid dfs1(int x)\n{\n    flag[x]=1,a[++cntv]=x;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (flag[i->v])\n            ++cnte,++deg[x],++deg[i->v];\n        else\n            dfs1(i->v);\n}\n\nint dfs2(int x)\n{\n    int ret=s[x]=1;\n    for (edge *i=fst2[x]; i; i=i->nxt)\n    {\n        ret=LL(ret)*dfs2(i->v)%p;\n        s[x]+=s[i->v],ret=LL(ret)*c(s[x]-1,s[i->v])%p;\n    }\n    return ret;\n}\n\nint calc()\n{\n    static bool flag[200100];\n    edge *t=tp;\n    repu(i,1,cntv)\n        flag[a[i]]=0;\n    repu(i,1,cntv)\n        for (edge *j=fst[a[i]]; j; j=j->nxt)\n            if (j->v<link[a[i]])\n                addedge(a[i],j->v,fst2),flag[j->v]=1;\n    int sum=0,ret=1;\n    repu(i,1,cntv)\n        if (!flag[a[i]])\n        {\n            ret=LL(ret)*dfs2(a[i])%p;\n            ret=LL(ret)*c(sum+=s[a[i]],s[a[i]])%p;\n        }\n    tp=t;\n    repu(i,1,cntv)\n        fst2[a[i]]=0;\n    return ret;\n}\n\nint solve(int x)\n{\n    cntv=cnte=0,dfs1(x);\n    if (cntv!=cnte)\n    {\n        puts(\"0\");\n        exit(0);\n    }\n    repu(i,1,cntv)\n        if (deg[a[i]]==1)\n            for (int j=a[i],nxt=0; j; j=nxt,nxt=0)\n                for (edge *k=fst[j]; k; k=k->nxt)\n                    if (deg[k->v]>1)\n                    {\n                        link[j]=k->v;\n                        if (--deg[k->v]==1)\n                            nxt=k->v;\n                    }\n    static int cyc[200100],tot;\n    repu(i,1,cntv)\n        if (deg[a[i]]>1)\n        {\n            cyc[tot=1]=a[i];\n            while (tot==1 || cyc[tot]!=a[i])\n                for (edge *j=fst[cyc[tot]]; j; j=j->nxt)\n                    if (deg[j->v]>1 && cyc[tot-1]!=j->v)\n                    {\n                        cyc[++tot]=j->v;\n                        break;\n                    }\n            --tot;\n            break;\n        }\n    repu(i,1,tot)\n        link[cyc[i]]=cyc[i+1];\n    int sum=calc();\n    repu(i,1,tot)\n        link[cyc[i+1]]=cyc[i];\n    (sum+=calc())%=p,ans=LL(ans)*sum%p;\n    return cntv;\n}\n\nint main()\n{\n    n=getint(),ans=1;\n    repu(i,1,n*2)\n    {\n        int u=getint(),v=getint()+n;\n        addedge(u,v,fst),addedge(v,u,fst);\n    }\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    repu(i,2,n*2)\n        inv[i]=LL(p-p/i)*inv[p%i]%p;\n    repu(i,2,n*2)\n        fac[i]=LL(fac[i-1])*i%p,inv[i]=LL(inv[i-1])*inv[i]%p;\n    int sum=0;\n    repu(i,1,n*2)\n        if (!flag[i])\n        {\n            int cnt=solve(i);\n            ans=LL(ans)*c(sum+=cnt,cnt)%p;\n        }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nnamespace Tzh{\n\t\n\ttypedef long long ll;\n\tconst int maxn=200010;\n\tconst ll p=1e9+7;\n\tint st[maxn],top,all,vis[maxn],head[maxn],cnt=1,n,fa[maxn],eid[maxn],flag,size[maxn],point[maxn],num;\n\tll fac[maxn],ans; int val[maxn];\n\n\tll qpow(ll a,ll b){ ll sum=1;\n\t\twhile(b){\n\t\t\tif(b&1) sum=sum*a%p;\n\t\t\ta=a*a%p; b>>=1;\n\t\t}\t\n\t\treturn sum;\n\t}\n\n\tstruct ed{\n\t\tint next,to,w,vis;\n\t}e[maxn<<1];\n\n\tvoid add(int u,int v,int w){\n\t\te[++cnt]=(ed){head[u],v,w,0}; head[u]=cnt;\n\t\te[++cnt]=(ed){head[v],u,w,0}; head[v]=cnt;\n\t}\n\n\tvoid dfs(int now,int f){ vis[now]=1; all++;\n\t\tfor(int i=head[now];i;i=e[i].next){\n\t\t\tint tt=e[i].to; if(tt==f) continue;\n\t\t\tst[++top]=i; if(vis[tt]){\n\t\t\t\tif(flag) {top--; continue;}\n\t\t\t\tint tmp=top; int mx=0,pos=0;\n\t\t\t\twhile(e[st[tmp]^1].to!=e[i].to) tmp--;\n\t\t\t\tfor(int i=tmp;i<=top;i++) \n\t\t\t\t\tif(e[st[i]].w>mx) mx=e[st[i]].w,pos=st[i];\t\n\t\t\t\tflag=pos; top--; continue;\n\t\t\t} dfs(tt,now); top--; \n\t\t}\n\t}\n\n\tvoid dfs2(int now,int f){ fa[now]=f; \n\t\tfor(int i=head[now];i;i=e[i].next){\n\t\t\tint tt=e[i].to; if(tt==f||e[i].vis) continue;\n\t\t\tpoint[++num]=tt; eid[num]=i; dfs2(tt,now);\n\t\t}\n\t}\n\n\tvoid dfs3(int now,int f){ size[now]=1;\n\t\tfor(int i=head[now];i;i=e[i].next){\n\t\t\tint tt=e[i].to; if(tt==f||e[i].vis) continue;\n\t\t\tdfs3(tt,now); size[now]+=size[tt];\n\t\t}\n\t\tans=ans*size[now]%p;\n\t}\n\n\tll suan(int now){\n\t\tans=1; dfs3(now,0); ans=fac[size[now]]*qpow(ans,p-2)%p;\n\t\treturn ans;\n\t}\n\n\tll cal(int now,int f){\n\t\tnum=0; dfs2(now,0); static int st[maxn],top; top=0;\n\t\tstatic ll g[maxn],sz[maxn]; st[++top]=now; fa[now]=f;\n\t\tfor(int i=1;i<=num;i++){int cur=point[i];\n\t\t\tif(fa[fa[cur]]&&fa[fa[cur]]<cur) \n\t\t\t   e[eid[i]].vis=e[eid[i]^1].vis=1,st[++top]=cur;\n\t\t} ll sum=0;\n\t\tfor(int i=1;i<=top;i++) g[i]=suan(st[i]),sz[i]=size[st[i]];\n\t\tfor(int i=1;i<=top;i++) sum=sum+sz[i]; sum=fac[sum];\n\t\tfor(int i=1;i<=top;i++) sum=sum*qpow(fac[sz[i]],p-2)%p;\n\t\tfor(int i=1;i<=top;i++) sum=sum*g[i]%p;\n\t\tfor(int i=1;i<=num;i++) e[eid[i]].vis=e[eid[i]^1].vis=0;\n\t\treturn sum;\n\t}\n\n\tint ffa(int x){return fa[x]==x?x:fa[x]=ffa(fa[x]);}\n\n\tvoid work(){\n\t\tscanf(\"%d\",&n); n*=2; fac[0]=1;\n\t\tfor(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%p;\n\t\tstatic int sz[maxn],tot; static ll F[maxn]; int x,y;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,val[i]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d%d\",&x,&y),add(x,y+(n>>1),x+y);\n\t\t\tint a=x,b=y=n>>1; if(ffa(a)==ffa(b)) val[ffa(a)]--;\n\t\t\tval[ffa(b)]+=val[ffa(a)]-1; fa[ffa(a)]=ffa(b);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) if(val[ffa(i)]!=0) {puts(\"0\"); return ;}\n\t\tmemset(fa,0,sizeof(fa));\n\t\tfor(int i=1;i<=n;i++) if(!vis[i]){\n\t\t\tflag=0; all=0; dfs(i,0); \n\t\t\tif(!flag) {puts(\"0\"); return ;}\n\t\t\te[flag].vis=e[flag^1].vis=1; \n\t\t\tF[++tot]=(cal(e[flag^1].to,e[flag].to)+cal(e[flag].to,e[flag^1].to))%p;\n\t\t\tsz[tot]=all; \n\t\t} ll sum=0;\n\t\tfor(int i=1;i<=tot;i++) sum+=sz[i]; sum=fac[sum];\n\t\tfor(int i=1;i<=tot;i++) sum=sum*qpow(fac[sz[i]],p-2)%p;\n\t\tfor(int i=1;i<=tot;i++) sum=sum*F[i]%p;\n\t\tprintf(\"%lld\",sum);\n\t\treturn ;\n\t}\n}\n\nint main(){\n\tTzh::work();\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst int mod=1e9+7;\nvector<int> num[200010],vec[200010];\nstruct node{\n\tint y,next;\n}a[400010];int len=1,last[200010];\nstruct point{\n\tint x,y;\n}p[200010];\nint n,d[200010],fa[200010];\nLL ans=1;\nvoid ins(int x,int y)\n{\n\ta[++len].y=y;\n\ta[len].next=last[x];last[x]=len;\n}\nint findfa(int x) {return fa[x]==x?x:fa[x]=findfa(fa[x]);}\nint top,sta[200010],c[200010],cnt,f[200010],b[200010];\nbool ring[200010],vis[200010],ty;\nvoid pre(int x,int fr)\n{\n\tsta[++top]=x;vis[x]=true;\n\tfor(int i=last[x];i;i=a[i].next)\n\t{\n\t\tif(i==(fr^1)) continue;\n\t\tint y=a[i].y;\n\t\tif(vis[y])\n\t\t{\n\t\t\tcnt=-1;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tc[++cnt]=sta[top--];\n\t\t\t\tif(sta[top]==y) continue;\n\t\t\t}\n\t\t\tty=true;return;\n\t\t}\n\t\tpre(y,i);\n\t\tif(ty) return;\n\t}\n\ttop--;\n}\nvoid dfs(int x,int fr)\n{\n\tif(fr) f[x]=fr/2;\n\tfor(int i=last[x];i;i=a[i].next)\n\t{\n\t\tif(i==(fr^1)||ring[a[i].y]) continue;\n\t\tint y=a[i].y;\n\t\tdfs(y,i);\n\t}\n}\nvoid solve(int k)\n{\n\tty=false;top=0;pre(k,0);\n\tif(!ty) {puts(\"0\");exit(0);}\n\tfor(int x=0;x<cnt;x++)\n\t{\n\t\tint z=c[(x+1)%cnt];ring[c[x]]=true;\n\t\tfor(int i=last[c[x]];i;i=a[i].next) if(a[i].y==z) b[x]=i/2;\n\t}\n\tfor(int i=0;i<cnt;i++) dfs(c[i],0);\n\t\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=2*n;i++) fa[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x,y;scanf(\"%d %d\",&x,&y);\n\t\tp[i].x=x;p[i].y=y;\n\t\tins(x,y+n);ins(y+n,x);\n\t\td[x]++;d[y+n]++;\n\t\tfa[findfa(x)]=findfa(y+n);\n\t}\n\tmemset(ring,false,sizeof(ring));\n\tmemset(vis,false,sizeof(vis));\n\tfor(int i=1;i<=2*n;i++) num[findfa(i)].push_back(i);\n\tfor(int i=1;i<=2*n;i++) if(fa[i]==i) solve(i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\ntypedef long long lint;\nconst int N=1e5+5;\nconst int mod=1e9+7;\nint n;\n\nnamespace utils{\n\ttemplate <class T> inline void apx(T &x,const T y){\n\t\tx<y?x=y:0;\n\t}\n\ttemplate <class T> inline void apn(T &x,const T y){\n\t\tx>y?x=y:0;\n\t}\n\tinline int nxi(FILE *fd=stdin){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=fgetc(fd))>'9'||c<'0')&&c!='-');\n\t\tconst bool f=(c=='-')&&(c=fgetc(fd));\n\t\twhile(x=x*10-48+c,(c=fgetc(fd))>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\ntemplate <class T>\ninline int fpow(int x,T t){\n\tint ans=1;\n\tfor(; t; x=(lint)x*x%mod,t>>=1){\n\t\tif(t&1) ans=(lint)ans*x%mod;\n\t}\n\treturn ans;\n}\n\nnamespace G{\n\tint rt,ans,cnt,fir[N<<1];\n\tint cir_dep,dep[N<<1];\n\tint eg_cnt,nd_cnt;\n\tbool vis[N];\n\tstd::vector <int> cir_l;\n\tstruct edge{\n\t\tint to,nx;\n\t}eg[N<<2];\n\n\tinline void add(const int a,const int b){\n\t\teg[++cnt]=(edge){b,fir[a]};\n\t\tfir[a]=cnt;\n\t}\n\n\tbool dfs_cir(const int x,const int fa){\n\t\t++nd_cnt;\n\t\tvis[x]=1;\n\t\tbool on_cir=0;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tconst int y=eg[i].to;\n\t\t\t++eg_cnt;\n\t\t\tif(y==fa) continue;\n\t\t\tif(vis[y]){\n\t\t\t\tif(~cir_dep) continue;\n\t\t\t\tcir_dep=dep[y];\n\t\t\t\ton_cir=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\ton_cir|=dfs_cir(y,x);\n\t\t\t}\n\t\t}\n\t\ton_cir&=dep[x]>=cir_dep;\n\t\tif(on_cir) cir_l.push_back(x);\n\t\treturn on_cir;\n\t}\n\n\tint dfs_tot(const int x,const int fa){\n\t\tint sz=1;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tconst int y=eg[i].to;\n\t\t\tif(y==rt&&y!=fa) assert(y>fa);\n\t\t\tif(y==fa||y==rt) continue;\n\t\t\tif(y<fa) sz+=dfs_tot(y,x);\n\t\t\telse dfs_tot(y,x);\n\t\t}\n\t\tans=(lint)ans*sz%mod;\n\t\treturn sz;\n\t}\n\n\tint solve(const int x){\n\t\tcir_l.clear();\n\t\teg_cnt=nd_cnt=0;\n\t\tcir_dep=-1;\n\t\tdfs_cir(x,0);\n\t\tif(eg_cnt!=nd_cnt<<1) return 0;\n\t\tconst int sz=cir_l.size();\n\t\tassert(sz);\n\t\tint r=0,res=0;\n\t\tfor(int i=1; i<(int)cir_l.size(); ++i){\n\t\t\tif(cir_l[i]<cir_l[r]) r=i;\n\t\t}\n\t\t{\n\t\t\tint f,x;\n\t\t\tif((f=r-1)<0) f=sz-1;\n\t\t\tif((x=f-1)<0) x=sz-1;\n\t\t\tans=1;\n\t\t\tG::rt=cir_l[x];\n\t\t\tdfs_tot(cir_l[x],cir_l[f]);\n\t\t\tres=(res+fpow(ans,mod-2))%mod;\n\t\t}\n\t\t{\n\t\t\tint f,x;\n\t\t\tif((f=r+1)==sz) f=0;\n\t\t\tif((x=f+1)==sz) x=0;\n\t\t\tans=1;\n\t\t\tG::rt=cir_l[x];\n\t\t\tdfs_tot(cir_l[x],cir_l[f]);\n\t\t\tres=(res+fpow(ans,mod-2))%mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n\tn=nxi();\n\tfor(int i=1; i<=n<<1; ++i){\n\t\tint x=nxi(),y=nxi();\n\t\tG::add(x,y+n);\n\t\tG::add(y+n,x);\n\t}\n\tint res=1;\n\tfor(int i=1; res&&i<=n; ++i){\n\t\tif(!G::vis[i]) res=(lint)res*G::solve(i)%mod;\n\t}\n\tfor(int i=1; i<=n<<1; ++i){\n\t\tres=(lint)res*i%mod;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n有点恶心。\n每个机器人看做一个点，平面上的每个点看做连接机器人的边。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) // fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 400005, mod = 1000000007;\nint head[maxn], nxt[maxn << 2], to[maxn << 2], hp = 1;\n\ninline ll power(ll x, int k) {\n\tif(k < 0) k += mod - 1;\n\tll res = 1;\n\twhile(k) {\n\t\tif(k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline void add(int u, int v, int *h) {\n\tnxt[++ hp] = h[u];\n\th[u] = hp;\n\tto[hp] = v;\n}\n\nint tmp[maxn], tp;\nbool vis[maxn];\nint cx, cy;\nvoid dfs(int u, int f) {\n\t/* debug(\"%d -> %d\\n\", f, u); */\n\ttmp[++ tp] = u;\n\tvis[u] = 1;\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f) {\n\t\t\tif(vis[to[i]]) {\n\t\t\t\tcx = u;\n\t\t\t\tcy = to[i];\n\t\t\t} else\n\t\t\t\tdfs(to[i], u);\n\t\t}\n}\n\nint match[maxn];\nvoid mdfs(int u, int f) {\n\t/* debug(\"%d %d\\n\", u, f); */\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f and to[i] != cx) {\n\t\t\tmatch[to[i]] = u;\n\t\t\tmdfs(to[i], u);\n\t\t}\n}\n\nint Head[maxn];\nint deg[maxn];\nint stack[maxn], sp;\nll f[maxn];\nint size[maxn];\nll fac[maxn], ifac[maxn];\n\ninline ll C(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint force_count;\nvoid dp(int u) {\n\t++ force_count;\n\tif(force_count >= maxn * 2) {\n\t\tputs(\"0\");\n\t\texit(0);\n\t}\n\n\tsize[u] = 0;\n\tf[u] = 1;\n\tfor(int i = Head[u]; i; i = nxt[i]) {\n\t\tdp(to[i]);\n\t\tsize[u] += size[to[i]];\n\t\t(f[u] *= f[to[i]]) %= mod;\n\t\t(f[u] *= C(size[u], size[to[i]])) %= mod;\n\t}\n\t++ size[u];\n\tdebug(\"%d : %lld %d\\n\", u, f[u], size[u]);\n}\n\nint HP;\nll solve() {\n\tdebug(\"solve %d %d\\n\", cx, cy);\n\tmdfs(cx, cy);\n\tmatch[cx] = cy;\n\n\thp = HP;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tdeg[tmp[i]] = Head[tmp[i]] = 0;\n\n\tfor(int id = 1; id <= tp; id ++) {\n\t\tint u = tmp[id];\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] < match[u]) {\n\t\t\t\tdebug(\"%d -> %d\\n\", u, to[i]);\n\t\t\t\tadd(u, to[i], Head);\n\t\t\t\t++ deg[to[i]];\n\t\t\t}\n\t}\n\n\tHead[0] = 0;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tif(!deg[tmp[i]])\n\t\t\tadd(0, tmp[i], Head);\n\n\tdp(0);\n\tdebug(\"get %lld\\n\", f[0]);\n\n\treturn f[0];\n}\n\nint main() {\n\tint n = read;\n\n\tint N = n << 1 | 1;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[N] = power(fac[N], -1);\n\tfor(int i = N; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n\n\tfor(int i = 1; i < N; i ++) {\n\t\tint x = read, y = read;\n\t\tadd(x, n + y, head);\n\t\tadd(n + y, x, head);\n\t}\n\n\tHP = hp;\n\tll ans = 1;\n\tint SIZE = 0;\n\n\tfor(int r = 1; r < N; r ++)\n\t\tif(!vis[r]) {\n\t\t\ttp = 0;\n\t\t\tdfs(r, 0);\n\t\t\tll now = solve();\n\t\t\tstd::swap(cx, cy);\n\t\t\tnow += solve();\n\t\t\tSIZE += size[0] - 1;\n\t\t\t(ans *= now) %= mod;\n\t\t\t(ans *= C(SIZE, size[0] - 1)) %= mod;\n\t\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\nconst int N=500007,P=1e9+7;\nint n;\nstruct edge{\n\tint to,nx,del;\n}e[N];\nint e0[N],ep=2,cn,cm,deg[N],fa[N],fr[N],ss[N],sp=0,col[N],ff[N];\ni64 fac[N],fiv[N];\ni64 pw(i64 a,i64 n){\n\ti64 v=1;\n\tfor(;n;n>>=1,a=a*a%P)if(n&1)v=v*a%P;\n\treturn v;\n}\nvoid ae(int a,int b){\n\te[ep]=(edge){b,e0[a],0};e0[a]=ep++;++deg[b];\n}\nvoid del(int w){\n\trec:\n\tdeg[ss[++sp]=w]=0;\n\tfor(int i=e0[w];i;i=e[i].nx)if(!e[i].del){\n\t\te[i].del=e[i^1].del=1;\n\t\tint u=e[i].to;\n\t\tfa[w]=u;\n\t\tif(--deg[u]==1){w=u;goto rec;}\n\t}\n}\nstruct num{\n\ti64 v;\n\tint sz;\n\tvoid add(const num&w){v+=w.v,sz=w.sz;}\n\tvoid ins(const num&w){v=v*w.v%P,sz+=w.sz;}\n\tvoid inc(){v=v*fac[sz]%P*fiv[sz+1]%P;++sz;}\n\ti64 val(){return v*fac[sz]%P;}\n}v1[N],v2[N],v3[N],ans=(num){1,0};\nvoid cal(){\n\tfor(int i=1;i<=n*2;++i){\n\t\tff[i]=fa[fa[i]]>i?fa[i]:0;\n\t\tv1[i]=v2[i]=(num){1,0};\n\t\tdeg[i]=0;\n\t}\n\tfor(int i=1;i<=n*2;++i)++deg[ff[i]];\n\tfor(int i=1;i<=n*2;++i)if(!deg[i]){\n\t\tfor(int w=i,f;deg[w]=-1,f=ff[w];w=f){\n\t\t\tv1[w].inc();\n\t\t\tv1[f].ins(v1[w]);\n\t\t\tif(--deg[f])break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n*2;++i)if(!ff[i]){\n\t\tint f=col[i];\n\t\tv1[i].inc();\n\t\tv2[f].ins(v1[i]);\n\t}\n\tfor(int i=1;i<=n*2;++i)if(col[i]==i)v3[i].add(v2[i]);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=fac[0]=1;i<=n*2;++i)fac[i]=i*fac[i-1]%P;\n\tfiv[n*2]=pw(fac[n*2],P-2);\n\tfor(int i=n*2;i;--i)fiv[i-1]=i*fiv[i]%P;\n\tfor(int i=1,a,b;i<=n*2;++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tb+=n;\n\t\tae(a,b),ae(b,a);\n\t}\n\tfor(int i=1;i<=n*2;++i)if(deg[i]==1)del(i);\n\tfor(int i=1;i<=n*2;++i)if(deg[i]&&deg[i]!=2)return puts(\"0\"),0;\n\tfor(int i=1;i<=n*2;++i)if(deg[i]){\n\t\tint p=sp+1;\n\t\tdel(i);\n\t\tss[sp+1]=ss[p];\n\t\tfor(int j=p;j<=sp;++j)fr[ss[j+1]]=ss[j];\n\t\tint w=ss[sp];\n\t\tcol[w]=w;\n\t}\n\tfor(int i=sp;i;--i){\n\t\tint w=ss[i];\n\t\tif(!col[w])col[w]=col[fa[w]];\n\t}\n\tcal();\n\tfor(int i=1;i<=n*2;++i)if(fr[i])fa[i]=fr[i];\n\tcal();\n\tfor(int i=1,tot=0;i<=n*2;++i)if(col[i]==i)ans.ins(v3[i]);\n\tprintf(\"%lld\\n\",ans.val());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nll fac[200111],ifac[200111];\nint n;\nint head[200111],nxt[400111],to[400111],tot=1;\nint f[200111];\nint gf(int x){return f[x]==x?x:f[x]=gf(f[x]);}\nint tcnt[200111];\nvector<int> g[200111];\nbool vis[200111];\nint pe[200111];\nvector<int> cyc,cyce;\nint st[200111],stn;\nbool onc[200111],inst[200111];\nvoid dfs(int x,int pre=-1)\n{\n//\tcerr<<\"dfs:\"<<x<<\",\"<<pre<<endl;\n\tst[stn++]=x;vis[x]=inst[x]=1;\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tint u=to[i];\n\t\tif(u==pre)continue;\n\t\tif(!vis[u])pe[u]=i,dfs(u,x);\n\t\telse if(inst[u])\n\t\t{\n\t\t\tint it=stn-1;\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tcyc.PB(st[it]);\n\t\t\t\tonc[st[it]]=1;\n\t\t\t\tif(st[it]==u)\n\t\t\t\t{\n\t\t\t\t\tcyce.PB(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse cyce.PB(pe[st[it]]);\n\t\t\t\tit--;\n\t\t\t}\n\t\t}\n\t}\n\tstn--;inst[x]=0;\n}\nint mt[200111],sz[200111];\nvector<int> con[200111];\nvoid calcsz(int x)\n{\n\tsz[x]=1;\n\tfor(int i=0;i<con[x].size();i++)\n\t{\n\t\tint u=con[x][i];\n\t\tif(!sz[u])calcsz(u);\n\t\tsz[x]+=sz[u];\n\t}\n}\nll calc(vector<int> v)\n{\n//\tfor(int i=1;i<=n;i++)cerr<<mt[i]<<\":\"<<to[mt[i]^1]<<\",\"<<to[mt[i]]<<\" \";cerr<<endl;\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tint x=v[i];\n\t\tfor(int j=head[x];j;j=nxt[j])con[j>>1].clear(),sz[j>>1]=0;\n\t}\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tint x=v[i];\n\t\tfor(int j=head[x];j;j=nxt[j])\n\t\t{\n\t\t\tif(to[j]<to[mt[x]])\n\t\t\t{\n\t\t\t\tcon[mt[x]>>1].PB(j>>1);\n\t\t\t}\n\t\t}\n\t}\n\tll ret=1;\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tint x=v[i];\n\t\tfor(int j=head[x];j;j=nxt[j])\n\t\t{\n\t\t\tif(!sz[j>>1])\n\t\t\t{\n\t\t\t\tcalcsz(j>>1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<v.size();i++)ret=ret*sz[mt[v[i]]>>1]%mod;\n\treturn ret;\n}\nvoid dfs2(int x,int pre=-1)\n{\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tint u=to[i];\n\t\tif(onc[u]||u==pre)continue;\n\t\tmt[u]=i^1;\n\t\tdfs2(u,x);\n\t}\n}\nll solve(vector<int> v)\n{\n//\tcerr<<\"solve:\"<<endl;\n//\tfor(int i=0;i<v.size();i++)cerr<<v[i]<<\" \";cerr<<endl;\n\tcyc.clear();\n\tcyce.clear();\n\tdfs(v[0]);\n//\tfor(int i=0;i<cyc.size();i++)cerr<<cyc[i]<<\" \";cerr<<endl;\n//\tfor(int i=0;i<cyce.size();i++)cerr<<to[cyce[i]^1]<<\",\"<<to[cyce[i]]<<\" \";cerr<<endl;\n\t\n\tfor(int i=0;i<cyc.size();i++)\n\t{\n\t\tdfs2(cyc[i]);\n\t}\n\tll ans=0;\n\tfor(int i=0;i<cyce.size();i++)\n\t{\n\t\tint e=cyce[i];\n\t\tmt[to[e^1]]=e;\n\t}\n\tans+=fac[v.size()]*qpow(calc(v),mod-2)%mod;\n\tfor(int i=0;i<cyce.size();i++)\n\t{\n\t\tint e=cyce[i];\n\t\tmt[to[e]]=e^1;\n\t}\n\tans+=fac[v.size()]*qpow(calc(v),mod-2)%mod;\n\treturn ans;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=200005;i++)fac[i]=fac[i-1]*i%mod;\n\tifac[200005]=qpow(fac[200005],mod-2);\n\tfor(int i=200004;i>=0;i--)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tgeti(n);\n\tfor(int i=1;i<=2*n;i++)f[i]=i;\n\tfor(int i=1;i<=2*n;i++)\n\t{\n\t\tint x,y;\n\t\tgetii(x,y);\n\t\ty+=n;\n//\t\tcerr<<x<<\",\"<<y<<endl;\n\t\tnxt[++tot]=head[x];\n\t\thead[x]=tot;\n\t\tto[tot]=y;\n\t\tnxt[++tot]=head[y];\n\t\thead[y]=tot;\n\t\tto[tot]=x;\n\t\tf[gf(x)]=gf(y);\n\t}\n\tn*=2;\n\tfor(int i=1;i<=n;i++)tcnt[gf(to[i<<1])]++,tcnt[gf(i)]--,g[gf(i)].PB(i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(tcnt[i]!=0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tll ans=fac[n];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(g[i].size()>0)\n\t\t{\n\t\t\tll cur=solve(g[i]);\n\t\t\tans=ans*cur%mod*ifac[g[i].size()]%mod;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll MAX=300053;\nconst ll MOD=1000000007;\nvector<ll> conn[MAX],dir[MAX],now;\npll edge[MAX];\nll N,cnt[MAX],par[MAX],fact[MAX],chk[MAX],fin=1,npar[MAX],inv_dir[MAX];\nvoid build(ll x, ll px){\n    if(npar[x]!=0) return;\n    npar[x]=px; now.push_back(x);\n    for(ll i=0;i<conn[x].size();i++) if(px!=conn[x][i]) build(conn[x][i],x);\n}\nll power(ll x,ll y){\n    if(y==0) return 1;\n    ll t=power(x,y/2);\n    if(y%2) return t*t%MOD*x%MOD;\n    return t*t%MOD;\n}\npll counter(ll x){\n    ll t1=1,t2=1;\n    for(ll i=0;i<dir[x].size();i++){\n        pll tmp=counter(dir[x][i]);\n        t1+=tmp.first,t2*=tmp.second*power(fact[tmp.first],MOD-2)%MOD; t2%=MOD;\n    }\n    t2*=fact[t1-1]; t2%=MOD;\n    return make_pair(t1,t2);\n}\nll calc(ll x){\n    ll val[2]={1,1};\n    for(ll i=0;i<2;i++){\n        build(x,conn[x][i]);\n        for(ll j=0;j<now.size();j++) {\n            ll t=now[j];\n            for(ll k=0;k<conn[t].size();k++) {\n                if(conn[t][k]!=npar[t]) dir[t].push_back(conn[t][k]),inv_dir[conn[t][k]]++;\n                else break;\n            }\n        }\n        for(ll j=0;j<now.size();j++) {\n            ll t=now[j];\n            if(chk[t]==0&&inv_dir[t]==0) {\n                pll tmp=counter(t);\n                val[i]*=tmp.second*power(fact[tmp.first],MOD-2)%MOD; val[i]%=MOD;;\n            }\n        }\n        val[i]%=MOD;\n        while(!now.empty()){ll t=now.back(); dir[t].clear(); inv_dir[t]=0; npar[t]=0; chk[t]=i; now.pop_back();}\n    }\n    return (val[0]+val[1])%MOD;\n}\nint main(){\n    scanf(\"%lld\",&N);\n    for(ll i=1;i<=2*N;i++){\n        ll t1,t2;\n        scanf(\" %lld %lld\",&t1,&t2); t2+=N;\n        edge[i]=make_pair(t1,t2);\n        cnt[t1]++, cnt[t2]++;\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    for(ll i=1;i<=2*N;i++) sort(conn[i].begin(),conn[i].end());\n    for(ll i=1;i<=2*N;i++) {\n        if(cnt[i]<=1) now.push_back(i);\n    }\n    while(!now.empty()){\n        ll u=now.back(),up=0;\n        now.pop_back();\n        if(cnt[u]==1){\n            cnt[u]=0;\n            for(ll i=0;i<conn[u].size();i++) if(par[conn[u][i]]==0){\n                cnt[conn[u][i]]--; up=conn[u][i];\n                if(cnt[conn[u][i]]<=1) now.push_back(conn[u][i]);\n            }\n            par[u]=up;\n        }\n        else{\n            printf(\"0\\n\");\n            return 0;\n        }\n    }\n    for(ll i=1;i<=2*N;i++) if(par[i]==0&&conn[i].size()<2){\n        printf(\"0\\n\");\n        return 0;\n    }\n    fact[0]=1;\n    for(ll i=1;i<=2*N;i++) fact[i]=fact[i-1]*i%MOD;\n    for(ll i=1;i<=2*N;i++) sort(conn[i].begin(),conn[i].end());\n    for(ll i=1;i<=2*N;i++){\n        if(par[i]==0&&chk[i]==0) {\n            fin*=calc(i),fin%=MOD;\n        }\n    }\n    fin*=fact[2*N],fin%=MOD;\n    printf(\"%lld\\n\",fin);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN << 1];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G, loop;\nint dfn[MAXN], fa[MAXN], s, t, cnt = 0, edge = 0;\nvoid GetLoop(int x) // 找环 \n{\n\tG.push_back(x); // 森林中的一棵树 \n\tdfn[x] = ++cnt;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == fa[x])\n\t\t\tcontinue;\n\t\tif (dfn[y]) \n\t\t{\n\t\t\tif (dfn[y] < dfn[x]) continue;\n\t\t\tloop.push_back(y);\n\t\t\tfor (; y != x; y = fa[y])\n\t\t\t\tloop.push_back(fa[y]);\n\t\t}\n\t\telse { fa[y] = x; GetLoop(y); }\n\t}\n} \n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[cnt];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tscanf(\"%d\", &n);;\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!dfn[i])\n\t\t{\n\t\t\tcnt = edge = 0;\n\t\t\tGetLoop(i);\n\t\t\tif (cnt << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\ts = loop[0], t = loop[loop.size() - 1]; // 环的起点、终点 \n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tloop.clear();\n\t\t\tG.clear();\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 1e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr, nos;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = nos = 0);\n\t\t// printf(\" findcr = %d, nos = %d\\n\", findcr, nos);\n\t\tif (!findcr || nos) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\t// assert(SZ(cir) > 1);\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) { ideg[u] = 0; T[u].clear(); }\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tauto lim = UB(DT[u], in[u]); \n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v]) {\t// find it!\n\t\t\tif (findcr) { nos = 1; return; }\n\t\t\twhile (top > 0 && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); if (top > 0) --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tSCir(v, u);\n\t\t// if (findcr) return;\n\t} if (top > 0 && S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,o,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vx[X][i]!=o){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vy[Y][i]!=o){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\to=0;int xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\tw[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\tw[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,o,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\n\nint dep;\n\nvoid dfs(int f,int x){\n\n\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\t\n\t\n\t\ndep++;\nif(dep>200000)return;\n\t\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\tdfs(x,V[x][i]);\n\tstk[top--]=0;instk[x]=0;\n\t\ndep--;\t\n\t\n}\nint dfs(int x){\n\n\ndep++;\nif(dep>200000)return;\n\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vx[X][i]!=o){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vy[Y][i]!=o){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\t\ndep--;\n\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\to=0;int xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\tw[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\tw[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll MAX=300053;\nconst ll MOD=1000000007;\nvector<ll> conn[MAX],dir[MAX],now;\nll N,cnt[MAX],par[MAX],fact[MAX],chk[MAX],fin=1,npar[MAX],inv_dir[MAX];\nvoid build(ll x, ll px){\n    if(npar[x]!=0) return;\n    npar[x]=px; now.push_back(x);\n    for(ll i=0;i<conn[x].size();i++) if(px!=conn[x][i]) build(conn[x][i],x);\n}\nll power(ll x,ll y){\n    if(y==0) return 1;\n    ll t=power(x,y/2);\n    if(y%2) return t*t%MOD*x%MOD;\n    return t*t%MOD;\n}\npll counter(ll x){\n    ll t1=1,t2=1;\n    for(ll i=0;i<dir[x].size();i++){\n        pll tmp=counter(dir[x][i]);\n        t1+=tmp.first,t2*=tmp.second*power(fact[tmp.first],MOD-2)%MOD; t2%=MOD;\n    }\n    t2*=fact[t1-1]; t2%=MOD;\n    return make_pair(t1,t2);\n}\nll calc(ll x){\n    ll val[2]={1,1};\n    for(ll i=0;i<2;i++){\n        build(x,conn[x][i]);\n        for(ll j=0;j<now.size();j++) {\n            ll t=now[j];\n            for(ll k=0;k<conn[t].size();k++) {\n                if(conn[t][k]!=npar[t]) dir[t].push_back(conn[t][k]),inv_dir[conn[t][k]]++;\n                else break;\n            }\n        }\n        for(ll j=0;j<now.size();j++) {\n            ll t=now[j];\n            if(chk[t]==0&&inv_dir[t]==0) {\n                pll tmp=counter(t);\n                val[i]*=tmp.second*power(fact[tmp.first],MOD-2)%MOD; val[i]%=MOD;;\n            }\n        }\n        val[i]%=MOD;\n        while(!now.empty()){ll t=now.back(); dir[t].clear(); inv_dir[t]=0; npar[t]=0; chk[t]=i; now.pop_back();}\n    }\n    return (val[0]+val[1])%MOD;\n}\nint main(){\n    scanf(\"%lld\",&N);\n    for(ll i=1;i<=2*N;i++){\n        ll t1,t2;\n        scanf(\" %lld %lld\",&t1,&t2); t2+=N;\n        cnt[t1]++, cnt[t2]++;\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    printf(\"%d\\n\",0);\n    return 0;\n    for(ll i=1;i<=2*N;i++) sort(conn[i].begin(),conn[i].end());\n    for(ll i=1;i<=2*N;i++) {\n        if(cnt[i]<=1) now.push_back(i);\n    }\n    while(!now.empty()){\n        ll u=now.back(),up=0;\n        now.pop_back();\n        if(cnt[u]==1){\n            cnt[u]=0;\n            for(ll i=0;i<conn[u].size();i++) if(par[conn[u][i]]==0){\n                cnt[conn[u][i]]--; up=conn[u][i];\n                if(cnt[conn[u][i]]<=1) now.push_back(conn[u][i]);\n            }\n            par[u]=up;\n        }\n        else{\n            printf(\"0\\n\");\n            return 0;\n        }\n    }\n    for(ll i=1;i<=2*N;i++) if(par[i]==0&&conn[i].size()<2){\n        printf(\"0\\n\");\n        return 0;\n    }\n    fact[0]=1;\n    for(ll i=1;i<=2*N;i++) fact[i]=fact[i-1]*i%MOD;\n    for(ll i=1;i<=2*N;i++){\n        if(par[i]==0&&chk[i]==0) {\n            fin*=calc(i),fin%=MOD;\n        }\n    }\n    fin*=fact[2*N],fin%=MOD;\n    printf(\"%lld\\n\",fin);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,o,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\tdfs(x,V[x][i]);\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vx[X][i]!=o){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vy[Y][i]!=o){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\to=0;int xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\tw[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\tw[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nconst int N=200200,P=1000000007;\nint i,j,k,n,m,ch,x,y,an,num;\nint z[N],a[N],d[N],p[N],f[N],sz[N],Jc[N],Jc_[N];\nstruct edge { int s,n;};\nvoid R(int &x) {\n\tx=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) ch=getchar();\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n}\nstruct graph {\n\tint En;\n\tint h[N],du[N];\n\tedge E[N<<1];\n\tvoid clear() {\n\t\tfor (int i=1;i<=an;i++) h[a[i]]=0,du[a[i]]=0;\n\t\tEn=0;\n\t}\n\tvoid add(int x,int y) {\n\t\tdu[y]++;\n\t\tE[++En].s=y;E[En].n=h[x];h[x]=En;\n\t}\n} G1,G2;\nint ksm(int x,int y) {\n\tint z=1;\n\tfor (;y;y>>=1,x=(ll) x*x%P) if (y&1) z=(ll) z*x%P;\n\treturn z;\n}\nvoid pre(int n) {\n\tint i;\n\tJc[0]=Jc_[0]=1;\n\tfor (i=1;i<=n;i++) Jc[i]=(ll) Jc[i-1]*i%P;\n\tJc_[n]=ksm(Jc[n],P-2);\n\tfor (i=n-1;i;i--) Jc_[i]=(ll) Jc_[i+1]*(i+1)%P;\n}\nint C(int n,int m) {\n\tif (m>n) return 0;\n\treturn (ll) Jc[n]*Jc_[m]%P*Jc_[n-m]%P;\n}\nvoid dfs(int x) {\n\tz[x]=1;a[++an]=x;\n\tfor (int k=G1.h[x];k;k=G1.E[k].n) {\n\t\tnum++;\n\t\tif (!z[G1.E[k].s]) dfs(G1.E[k].s);\n\t}\n}\nvoid Dfs(int x) {\n\tint sum=0;\n\tf[x]=1;sz[x]=0;\n\tfor (int k=G2.h[x];k;k=G2.E[k].n) {\n\t\tDfs(G2.E[k].s);\n\t\tsz[x]+=sz[G2.E[k].s];\n\t\tf[x]=(ll) f[x]*f[G2.E[k].s]%P*C(sz[x],sz[G2.E[k].s])%P;\n\t}\n\tsz[x]++;\n}\nint Js() {\n\tG2.clear();\n\tint i,j,k,ans=1;\n\tfor (i=1;i<=an;i++)\n\t\tfor (k=G1.h[a[i]];k;k=G1.E[k].n) if (G1.E[k].s<p[a[i]]) G2.add(a[i],G1.E[k].s);\n\tint sum=0;\n\tfor (i=1;i<=an;i++) if (G2.du[a[i]]==0) {\n\t\tDfs(a[i]);\n\t\tsum+=sz[a[i]];\n\t\tans=(ll) ans*f[a[i]]%P*C(sum,sz[a[i]])%P;\n\t}\n\treturn ans;\n}\nint work() {\n\tint i,j,k;\n\tj=0;\n\tfor (i=1;i<=an;i++) if (G1.du[a[i]]==1) d[++j]=a[i];\n\ti=0;\n\twhile (i<j) {\n\t\ti++;\n\t\tfor (k=G1.h[d[i]];k;k=G1.E[k].n) {\n\t\t\tint t=--G1.du[G1.E[k].s];\n\t\t\tif (t>=1) p[d[i]]=G1.E[k].s;\n\t\t\tif (t==1) d[++j]=G1.E[k].s;\n\t\t}\n\t}\n\tfor (k=1;k<=an;k++) if (G1.du[a[k]]==2) {\n\t\td[++j]=a[k];\n\t\tbreak;\n\t}\n\tint st=d[j],ans=0,tmp=j;\n\twhile (i<j) {\n\t\ti++;\n\t\tint t;\n\t\tfor (k=G1.h[d[i]];k;k=G1.E[k].n) if (G1.du[G1.E[k].s]==2 && G1.E[k].s!=d[i-1]) { t=G1.E[k].s;break;}\n\t\tif (t!=st) d[++j]=t;\n\t\tp[d[i]]=t;\n\t}\n\tans=(ans+Js())%P;\n\tj=tmp;i=tmp-1;\n\twhile (i<j) {\n\t\ti++;\n\t\tint t;\n\t\tfor (k=G1.h[d[i]];k;k=G1.E[k].n) if (G1.du[G1.E[k].s]==2 && G1.E[k].s!=d[i-1]) t=G1.E[k].s;\n\t\tif (t!=st) d[++j]=t;\n\t\tp[d[i]]=t;\n\t}\n\tans=(ans+Js())%P;\n\treturn ans;\n}\nint main() {\n\tR(n);m=n*2;\n\tpre(m);\n\tfor (i=1;i<=m;i++) {\n\t\tR(x);R(y);\n\t\tG1.add(x,n+y);\n\t\tG1.add(n+y,x);\n\t}\n\tint sum=0,ans=1;\n\tfor (i=1;i<=m;i++) if (!z[i]) {\n\t\tan=0;num=0;\n\t\tdfs(i);\n\t\tif (an*2!=num) return puts(\"0\"),0;\n\t\tsum+=an;\n\t\tans=(ll) ans*work()%P*C(sum,an)%P;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n\nconst int kN = 200000 + 5;\nconst int MOD = (int)1e9 + 7;\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a < 0) a += MOD;\n    else if (a >= MOD) a -= MOD;\n}\n\ninline int mul(int x)\n{\n    return x;\n}\n\ntemplate<typename... Args>\ninline int mul(int x, Args... args)\n{\n    return x * 1ll * mul(args...) % MOD;\n}\n\n\nint n;\nstd::vector<int> edges[kN], tree[kN];\nbool vis[kN], in[kN];\nstd::vector<int> vec;\nint F[kN], Finv[kN], Inv[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return mul(F[a], Finv[b], Finv[a - b]);\n}\n\nvoid dfs(int u)\n{\n    vis[u] = true;\n    vec.emplace_back(u);\n    for (int v : edges[u]) if (!vis[v])\n        dfs(v);\n}\n\nbool find_cycle(int u, int fa, int &s, int &t)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != fa) {\n        if (vis[v]) {\n            s = u;\n            t = v;\n            return true;\n        } else if (find_cycle(v, u, s, t)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int u, int target)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != target) {\n        if (!vis[v])\n            dfs2(v, u);\n        // printf(\"(u, target): (%d, %d)\\n\", u, target);\n        if (v < target) {\n            tree[u].emplace_back(v);\n            // printf(\"%d->%d\\n\", u, v);\n            in[v] = true;\n        }\n    }\n}\n\nusing Val = std::pair<int, int>;\n\nVal combine(Val a, Val b)\n{\n    return Val(a.first + b.first, mul(a.second, b.second, binom(a.first + b.first, a.first)));\n}\n\nVal calc(int u)\n{\n    Val ret(0, 1);\n    for (int v : tree[u]) {\n        ret = combine(ret, calc(v));\n    }\n    ret.first ++;\n    // printf(\"u = %d, ret = (%d, %d)\\n\", u, ret.first, ret.second);\n    return ret;\n}\n\nstd::pair<int, int> solve(int u)\n{\n    vec.clear();\n    dfs(u);\n    int e = 0;\n    for (int v : vec)\n        e += edges[v].size();\n    if (e / 2 != vec.size() || vec.size() % 2) {\n        return std::make_pair(0, 0);\n    }\n\n    for (int v : vec) vis[v] = false;\n    int s, t;\n    assert(find_cycle(u, -1, s, t));\n    int ways = 0;\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(s, t);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve0::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(t, s);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve1::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    return std::make_pair(vec.size(), ways);\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = mul(MOD - MOD / i, Inv[MOD % i]);\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = mul(F[i - 1], i);\n        Finv[i] = mul(Finv[i - 1], Inv[i]);\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n * 2; ++ i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b); a --; b --;\n        edges[a].emplace_back(n + b);\n        edges[n + b].emplace_back(a);\n    }\n    Val val(0, 1);\n    for (int i = 0; i < n; ++ i) if (!vis[i]) {\n        val = combine(val, solve(i));\n    }\n    printf(\"%d\\n\", val.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll fac[200010],finv[200010];\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll merge(ll a,ll b,ll asz,ll bsz){\n  ll f=((finv[asz]*finv[bsz])%mod)*fac[asz+bsz]%mod;\n  return ((f*a)%mod)*b%mod;\n}\n\nint N;\nvector<int> g[200001],t[200010];\nbool vis1[200010],vis2[200010];\nll ecnt=0;\nvector<int> vs,loop;\nint nxt[200001],indeg[200010];\nll tsz[200010];\n\nll predfs(int v){\n  vs.push_back(v);\n  vis1[v]=true;\n  ll sz=1;\n  for(int nv : g[v]){\n    ecnt++;\n    if(vis1[nv])continue;\n    sz+=predfs(nv);\n  }\n  return sz;\n}\n\nint dfs(int v,int pre){\n  vis2[v]=true;\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    if(vis2[nv]){\n      loop.push_back(nv); return nv;\n    }\n    int tmp=dfs(nv,v);\n    if(tmp!=-1){\n      if(nv==tmp) return -1;\n      else{\n        loop.push_back(nv); return tmp;\n      }\n    }\n  }\n  return -1;\n}\n\nll dfs2(int v){\n  vis2[v]=true;\n  ll res=1;\n  tsz[v]=0;\n  for(int nv : t[v]){\n    ll tmp=dfs2(nv);\n    res=merge(res,tmp,tsz[v],tsz[nv]);\n    tsz[v]+=tsz[nv];\n  }\n  tsz[v]++;\n  return res;\n}\n\nvoid dfs3(int v,int pre){\n  nxt[v]=pre;\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    dfs3(nv,v);\n  }\n}\n\nll calc(int v){\n  int V=vs.size();\n  rep(i,V)vis2[vs[i]]=false;\n  loop.clear();\n  dfs(v,-1);\n  int L=loop.size();\n\n  ll sum=0;\n  ll res1=1,res2=1;\n  { // +\n    rep(i,V)nxt[vs[i]]=-1;\n    rep(i,L){\n      nxt[loop[i]]=loop[(i+1)%L];\n      int crt=loop[i];\n      for(int nv : g[crt]){\n        if(nv==loop[(i+1)%L]||nv==loop[(i-1+L)%L])continue;\n        dfs3(nv,crt);\n      }\n    }\n    rep(i,V){\n      int crt=vs[i];\n      for(int nv : g[crt]){\n        if(nv<nxt[crt]){\n          t[crt].push_back(nv); indeg[nv]++;\n        }\n      }\n    }\n    rep(i,V)vis2[vs[i]]=false;\n    rep(i,V){\n      if(vis2[vs[i]]||indeg[vs[i]]>0)continue;\n      ll add=dfs2(vs[i]);\n      res1=merge(res1,add,sum,tsz[vs[i]]);\n      sum+=tsz[vs[i]];\n    }\n  }\n\n  sum=0;\n  { // +\n    rep(i,V){\n      nxt[vs[i]]=-1; indeg[vs[i]]=0;\n      t[vs[i]].clear(); tsz[vs[i]]=0;\n    }\n    rep(i,L){\n      nxt[loop[i]]=loop[(i-1+L)%L];\n      int crt=loop[i];\n      for(int nv : g[crt]){\n        if(nv==loop[(i+1)%L]||nv==loop[(i-1+L)%L])continue;\n        dfs3(nv,crt);\n      }\n    }\n    rep(i,V){\n      int crt=vs[i];\n      for(int nv : g[crt]){\n        if(nv<nxt[crt]){\n          t[crt].push_back(nv); indeg[nv]++;\n        }\n      }\n    }\n    rep(i,V)vis2[vs[i]]=false;\n    rep(i,V){\n      if(vis2[vs[i]]||indeg[vs[i]]>0)continue;\n      ll add=dfs2(vs[i]);\n      res2=merge(res2,add,sum,tsz[vs[i]]);\n      sum+=tsz[vs[i]];\n    }\n  }\n\n  return (res1+res2)%mod;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  fac[0]=1;\n  rep(i,200000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,200001)finv[i]=mod_pow(fac[i],mod-2);\n\n  cin>>N;\n  rep(i,2*N){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    g[x].push_back(N+y);\n    g[N+y].push_back(x);\n  }\n\n  ll res=1;\n  ll sum=0;\n  rep(i,2*N){\n    if(vis1[i])continue;\n    vs.clear(); ecnt=0;\n    ll sz=predfs(i); ecnt/=2;\n    if(sz!=ecnt) res=0;\n    else res=merge(res,calc(i),sum,sz);\n    sum+=sz;\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    return fact[n]*inv[n-k]%mod;\n}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N;\nint X[222222],Y[222222];\n\nvint G[222222];\nint sz[222222];\nint dfs(int v,int p){\n    sz[v]=0;\n    int ret=1;\n    for(auto u:G[v]){\n        ret=ret*dfs(u,v)%mod*nCk(sz[v]+sz[u],sz[u])%mod;\n        sz[v]+=sz[u];\n    }\n    sz[v]++;\n    return ret;\n}\nint calc2(vint to,vector<vint>&g){\n    int n=to.size();\n\n    vint tto(n,-1);\n    rep(i,n){\n        int j=to[i];\n        int k=to[j];\n        if(i<k)tto[i]=j;\n    }\n\n    rep(i,n+1)G[i].clear();\n    rep(i,n){\n        if(tto[i]==-1)G[n].pb(i);\n        else G[tto[i]].pb(i);\n    }\n\n    return dfs(n,-1);\n}\n\n\nint calc(vpint es){\n    int n=es.size();\n    vint lis;\n    rep(i,es.size())lis.pb(es[i].fi),lis.pb(es[i].se);\n    sort(all(lis));lis.erase(unique(all(lis)),lis.end());\n    rep(i,es.size()){\n        es[i].fi=lower_bound(all(lis),es[i].fi)-lis.begin();\n        es[i].se=lower_bound(all(lis),es[i].se)-lis.begin();\n    }\n\n    vector<vint>g(n);\n    vint deg(n);\n    for(auto &e:es){\n        g[e.fi].pb(e.se);\n        g[e.se].pb(e.fi);\n        deg[e.fi]++;deg[e.se]++;\n    }\n\n    queue<int>que;\n    rep(i,n)if(deg[i]==1)que.push(i);\n    vint to(n,-1);\n    while(que.size()){\n        int v=que.front();\n        que.pop();\n        for(auto u:g[v]){\n            if(to[u]!=-1)continue;\n            to[v]=u;\n            if(--deg[u]==1){\n                que.push(u);\n            }\n        }\n    }\n\n    int s;\n    rep(i,n)if(to[i]==-1)s=i;\n\n    int ret=0;\n    for(auto u:g[s]){\n        if(to[u]!=-1)continue;\n\n        vint tto=to;\n        tto[s]=u;\n        int v=u;\n        while(true){\n            int w=-1;\n            for(auto x:g[v]){\n                if(tto[x]!=-1)continue;\n                w=x;\n            }\n            if(w!=-1){\n                tto[v]=w;\n                v=w;\n            }\n            else{\n                tto[v]=s;\n                break;\n            }\n        }\n        ret=(ret+calc2(tto,g))%mod;\n    }\n    return ret;\n}\n\nsigned main(){\n    cin>>N;N*=2;\n    rep(i,N){\n        cin>>X[i]>>Y[i];\n        X[i]--;Y[i]--;\n        Y[i]+=N/2;\n    }\n\n    UnionFindTree uf(N);\n    rep(i,N){\n        uf.unite(X[i],Y[i]);\n    }\n\n    vint cnt(N);\n    rep(i,N)cnt[uf.find(X[i])]++;\n\n    rep(i,N)if(uf.find(i)==i&&cnt[i]!=uf.size(i)){\n        cout<<0<<endl;\n        return 0;\n    }\n\n    vector<vpint>lis(N);\n    rep(i,N){\n        lis[uf.find(X[i])].pb({X[i],Y[i]});\n    }\n\n    int ans=1;\n    int num=0;\n    rep(i,N){\n        if(lis[i].size()==0)continue;\n        ans=ans*calc(lis[i])%mod*nCk(num+lis[i].size(),num)%mod;\n        num+=lis[i].size();\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nusing pi = pair<int, int>;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nint n, sz[MAXN], indeg[MAXN];\nvector<pi> gph[MAXN];\nvector<int> tr[MAXN];\nvector<int> dfn;\nint deg[MAXN], vis[MAXN];\nint match[MAXN];\nlint fact[MAXN], invf[MAXN];\n\nlint dfs2(int x){\n\tsz[x] = 0;\n\tlint ret = 1;\n\tfor(auto &i : tr[x]){\n\t\tret *= dfs2(i);\n\t\tret %= mod;\n\t}\n\tfor(auto &i : tr[x]){\n\t\tsz[x] += sz[i];\n\t\tret *= invf[sz[i]];\n\t\tret %= mod;\n\t}\n\tret *= fact[sz[x]];\n\tret %= mod;\n\tsz[x]++;\n\treturn ret;\n}\n\nlint topsort(){\n\tvector<pi> edges; // fi -> se\n\tvector<int> edge_list;\n\tfor(auto &i : dfn){\n\t\tint to_match = -1;\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(match[i] == j.second){\n\t\t\t\tto_match = j.first;\n\t\t\t}\n\t\t}\n\t\tassert(to_match != -1);\n\t\tedge_list.push_back(to_match);\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(match[i] > j.second){\n\t\t\t\tedges.emplace_back(j.first, to_match);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto &i : edge_list) disj.pa[i] = i;\n\tfor(auto &i : edges){\n\t\tif(!disj.uni(i.first, i.second)){\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(auto &i : edges){\n\t\ttr[i.second].push_back(i.first);\n\t\tindeg[i.first]++;\n\t}\n\tlint ret = 1;\n\tfor(auto &i : edge_list){\n\t\tif(indeg[i] == 0){\n\t\t\tret *= dfs2(i) * invf[sz[i]] % mod;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret *= fact[edge_list.size()];\n\tfor(auto &i : edges){\n\t\tindeg[i.first] = 0;\n\t\ttr[i.second].clear();\n\t}\n\treturn ret % mod;\n}\n\nlint solve(){\n\tqueue<int> que;\n\tfor(auto &i : dfn){\n\t\tif(deg[i] == 1){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tint x = que.front(); que.pop();\n\t\tdeg[x]--;\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(deg[i.second]){\n\t\t\t\tmatch[x] = i.second;\n\t\t\t\tdeg[i.second]--;\n\t\t\t\tif(deg[i.second] == 1){\n\t\t\t\t\tque.push(i.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> cyc_ord;\n\tfor(auto &i : dfn){\n\t\tif(deg[i] == 2){\n\t\t\tfor(int j=i; deg[j]; ){\n\t\t\t\tdeg[j] = 0;\n\t\t\t\tcyc_ord.push_back(j);\n\t\t\t\tfor(auto &k : gph[j]){\n\t\t\t\t\tif(deg[k.second]){\n\t\t\t\t\t\tj = k.second;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i=0; i<cyc_ord.size(); i++){\n\t\tmatch[cyc_ord[i]] = cyc_ord[(i+1)%cyc_ord.size()];\n\t}\n\tret += topsort();\n\treverse(cyc_ord.begin(), cyc_ord.end());\n\tfor(int i=0; i<cyc_ord.size(); i++){\n\t\tmatch[cyc_ord[i]] = cyc_ord[(i+1)%cyc_ord.size()];\n\t}\n\tret += topsort();\n\treturn ret % mod;\n}\n\nint v, e;\n\nvoid dfs(int x){\n\tif(vis[x]) return;\n\tdfn.push_back(x);\n\tvis[x] = 1;\n\tv++;\n\te += gph[x].size();\n\tfor(auto &i : gph[x]) dfs(i.second);\n}\n\nlint ipow(lint x, lint p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint main(){\n\tfact[0] = invf[0] = 1;\n\tfor(int i=1; i<MAXN; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tinvf[i] = ipow(fact[i], mod - 2);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<2*n; i++){\n\t\tint x, y; scanf(\"%d %d\",&x,&y);\n\t\tx--, y += n - 1;\n\t\tgph[x].emplace_back(i, y);\n\t\tgph[y].emplace_back(i, x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tn <<= 1;\n\tdisj.init(n);\n\tlint ret = 1;\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i]){\n\t\t\tv = e = 0;\n\t\t\tdfn.clear();\n\t\t\tdfs(i);\n\t\t\tif(2 * v != e){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tret *= invf[v] * solve() % mod;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret *= fact[n];\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int maxn=2e5+10;\nconst int mo=1e9+7;\n\nint n,root,Ans=1,tote=1;\nint fa[maxn],fw[maxn],tmp[maxn],fac[maxn],ifac[maxn];\nint FIR[maxn],TO[maxn<<1],NEXT[maxn<<1],W[maxn<<1];\nint vis[maxn];\nint q[maxn];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nvoid addedge(int u,int v,int w)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tW[tote]=w;\n\tFIR[u]=tote;\n}\n\nvoid dfs1(int u,int F)\n{\n\tif (vis[u]) {root=u; return;}\n\tq[++q[0]]=u;\n\tvis[u]=1;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (v==F) continue;\n\t\tdfs1(v,u);\n\t}\n}\n\nvoid dfs2(int u)\n{\n\tif (vis[u]==2) return;\n\tvis[u]=2;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (v==fa[u]) continue;\n\t\tfa[v]=u;\n\t\tfw[v]=w;\n\t\tdfs2(v);\n\t}\n}\n\nnamespace Tree{\n\tint n,fa[maxn],dp[maxn],sz[maxn];\n\tint tote,FIR[maxn],TO[maxn<<1],NEXT[maxn<<1];\n\n\tvoid addedge(int u,int v)\n\t{\n//\t\tprintf(\"%d----->%d\\n\",u,v);\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t\tfa[v]=u;\n\t}\n\n\tvoid dfs(int u)\n\t{\n//\t\tprintf(\"u=%d\\n\",u);\n\t\tsz[u]=0;\n\t\tdp[u]=1;\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tdfs(v);\n\t\t\tsz[u]+=sz[v];\n\t\t\tdp[u]=(LL)dp[u]*dp[v]%mo;\n\t\t\tdp[u]=(LL)dp[u]*ifac[sz[v]]%mo;\n\t\t}\n\t\tdp[u]=(LL)dp[u]*fac[sz[u]]%mo;\n\t\tsz[u]++;\n\t}\n\n\tvoid solve(int &Ans)\n\t{\n\t\tint i,u;\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n\t\t\tif (!fa[u]) addedge(0,u);\n\t\t}\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n//\t\t\tprintf(\"%d : %d\\n\",u,fw[u]);\n\t\t}\n\n\t\tdfs(0);\n\t\t(Ans+=dp[0])%=mo;\n\n//\t\tprintf(\"Ans=%d\\nclear\\n\\n\\n\",Ans);\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t\tu=q[i],FIR[u]=fa[u]=dp[u]=sz[u]=0;\n\t\tFIR[0]=fa[0]=dp[0]=sz[0]=0;\n\t\ttote=0;\n\t}\n};\n\nvoid dfs3(int u)\n{\n\tif (vis[u]==3) return;\n\tvis[u]=3;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs3(v);\n\t}\n}\n\nvoid dfs4(int u)\n{\n\tif (vis[u]==4) return;\n\tvis[u]=4;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs4(v);\n\t}\n}\n\nint main()\n{\n\tint i,u,v;\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor (i=1;i<=n+n;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[n+n]=power(fac[n+n],mo-2);\n\tfor (i=n+n;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tfor (i=1;i<=n+n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,n+v,u+v);\n\t\taddedge(n+v,u,u+v);\n\t}\n\n\tfor (i=1;i<=n+n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tq[0]=0;\n\t\t\troot=0;\n\t\t\tdfs1(i,0);\n\t\t\tif (!root) {puts(\"0\"); return 0;}\n\t\t\tdfs2(root);\n\n\t\t\tint Sum=0;\n\n\t\t\tdfs3(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\ttmp[fa[u]]=fw[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\tfw[u]=tmp[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\n\t\t\tdfs4(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tAns=(LL)Ans*Sum%mo;\n//\t\t\tprintf(\"q0=%d\\n\",q[0]);\n\t\t\tAns=(LL)Ans*ifac[q[0]]%mo;\n\t\t}\n\tAns=(LL)Ans*fac[n+n]%mo;\n\tprintf(\"%d\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int maxn=400100;\nconst int mod=1000000007;\nint n,cir[maxn],f[maxn],rd[maxn],sz[maxn],tal,tci,o,cnte,now[maxn];\nbool vis[maxn];\nll jie[maxn],inv[maxn];\nll ksm(ll a,int b){ll r=1;for(;b;b>>=1){if(b&1)r=r*a%mod;a=a*a%mod;}return r;}\nll C(int a,int b){return jie[a]*inv[b]%mod*inv[a-b]%mod;}\nstruct edge\n{\n\tint t;\n\tedge *next;\n}*con[maxn],*gra[maxn];\nvoid ins(int x,int y,edge **a)\n{\n\tedge *p=new edge;\n\tp->t=y;\n\tp->next=a[x];\n\ta[x]=p;\n}\nvoid findcir(int v,int fa)\n{\n\tvis[v]=1;\n\tfor(edge *p=con[v];p&&!o;p=p->next)\n\t\tif(p->t!=fa)\n\t\t\t{if(!vis[p->t]) findcir(p->t,v);else {o=p->t;break;}}\n\t//cout<<\"findcir:\"<<v<<' '<<o<<endl;\t\t\n\tif(o) cir[++tci]=v;\n\telse vis[v]=0;\n\tif(v==o) o=0;\t\n}\nvoid check(int v)\n{\n\tvis[v]=1;\n\tnow[++tal]=v;\n\tfor(edge *p=con[v];p;cnte++,p=p->next)\n\t\tif(!vis[p->t]) check(p->t);\n}\nvoid dfs(int v)\n{\n\tvis[v]=1;\n\tfor(edge *p=con[v];p;p=p->next)\n\t\tif(!vis[p->t]) f[p->t]=v,dfs(p->t);\t\n}\nvoid build()\n{\n\tfor(int i=1;i<=tal;i++)\n\t\tgra[now[i]]=NULL,rd[now[i]]=0;\n\tgra[0]=NULL;\t\n\tfor(int i=1;i<=tal;i++)\n\t\tfor(edge *p=con[now[i]];p;p=p->next)\n\t\t\tif(p->t<f[now[i]]) ins(now[i],p->t,gra),rd[p->t]++;\n\tfor(int i=1;i<=tal;i++)\n\t\tif(rd[now[i]]==0) ins(0,now[i],gra);\n//\tcout<<\"f:\"<<endl;\n//\tfor(int i=1;i<=tal;i++)\n//\t\tcout<<now[i]<<','<<f[now[i]]<<' ';\n//\tcout<<endl;\t\t\n//\tfor(int i=0;i<=tal;i++)\n//\t\tfor(edge *p=gra[now[i]];p;p=p->next)\n//\t\t\tcout<<now[i]<<' '<<p->t<<endl;\t\t\t\n}\nll dp(int v,int fa)\n{\n\tll re=1;\n\tsz[v]=0;\n\tfor(edge *p=gra[v];p;p=p->next)\n\t\tif(p->t!=fa)\n\t\t{\n\t\t\tll tmp=dp(p->t,v);\n\t\t\tsz[v]+=sz[p->t];\n\t\t\tre=re*tmp%mod*C(sz[v],sz[p->t])%mod;\n\t\t\t//cout<<v<<' '<<p->t<<' '<<re<<' '<<sz[v]<<' '<<sz[p->t]<<endl;\n\t\t}\n\tsz[v]++;\n\t//cout<<\"dp:\"<<v<<' '<<re<<endl;\n\treturn re;\t\n}\nll work(int v)\n{\n\t//cout<<\"work:\"<<v<<endl;\n\tll re=0;\n\ttci=tal=o=cnte=0;\n\tcheck(v);\n\t//cout<<\"check:\"<<tal<<' '<<cnte<<endl;\n\tif(tal*2!=cnte) return 0;\n\tfor(int i=1;i<=tal;i++)\n\t\tvis[now[i]]=0;\n\tfindcir(v,-1); \n//\tcout<<tci<<endl;\n//\tfor(int i=1;i<=tci;i++)\n//\t\tcout<<cir[i]<<' ';\n//\tcout<<endl;\t\n\tfor(int i=1;i<=tci;i++)\n\t\tdfs(cir[i]);\n\tfor(int i=1;i<tci;i++)\n\t\tf[cir[i]]=cir[i+1];\n\tf[cir[tci]]=cir[1];\n\tbuild();\n\tre=(re+dp(0,-1))%mod;\n\tfor(int i=2;i<=tci;i++)\n\t\tf[cir[i]]=cir[i-1];\n\tf[cir[1]]=cir[tci];\n\tbuild();\t\t\n\tre=(re+dp(0,-1))%mod;\n\treturn re;\n}\nint main()\n{\n\t\n\tscanf(\"%d\",&n);\n\tjie[0]=1;\n\tfor(int i=1;i<=2*n;i++)\n\t\tjie[i]=jie[i-1]*i%mod;\n\tinv[2*n]=ksm(jie[2*n],mod-2);\n\tfor(int i=2*n-1;i>=0;i--)\n\t\tinv[i]=inv[i+1]*(i+1)%mod;\n\t//cout<<\"C:\"<<C(4,2)<<endl;\n\tfor(int i=1;i<=2*n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tins(x,y+n,con);\n\t\tins(y+n,x,con);\n\t}\n//\tfor(int i=1;i<=2*n;i++)\n//\t\tfor(edge *p=con[i];p;p=p->next)\n//\t\t\tcout<<i<<' '<<p->t<<endl;\n\tll ans=1;int tot=0;\n\tfor(int i=1;i<=2*n;i++)\n\t\tif(!vis[i]) \n\t\t{\n\t\t\tans=ans*work(i)%mod*C(tot+tal,tal)%mod;\n\t\t\ttot+=tal;\n\t\t}\n\tprintf(\"%lld\",ans);\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nint n,cnt=0,num=0;\nvi x,y,ax,ay,vis,b,c,d,used;\nvl dp;\nvvi g,G;\nvvp X,Y;\n\nint dfs(int v,int w){\n\tb.push_back(v);\n\tvis[v]++;cnt++;\n\tif(!ax[x[v]]) num++,ax[x[v]]=1;\n\tif(!ay[y[v]]) num++,ay[y[v]]=1;\n\tint t=-1;\n\tfor(auto u:g[v]) if(u!=-1&&u!=w){\n\t\tif(vis[u]&&w!=-1){\n\t\t\tint I=d.size()-1;\n/*\t\t\tpip p={{x[u],y[u]},u};\n\t\t\twhile(I>=0&&d[I]!=u){\n\t\t\t\tint u_=d[I--];\n\t\t\t\tp=min(p,{{x[u_],y[u_]},u_});\n\t\t\t}\n\t\t\tt=p.second;*/\n\t\t\tt=u;\n\t\t}\n\t\telse if(!vis[u]){\n\t\t\td.push_back(u);\n\t\t\tint t_=dfs(u,v);\n\t\t\tif(t_!=-1) t=t_;\n\t\t\td.pop_back();\n\t\t}\n\t}\n\treturn t;\n}\n\nvoid DFS(int v,int I){\n\tint u=g[v][I];\n\tif(u==-1||c[u]!=-1) return;\n\tc[u]=1-I%2;\n\tfor(int i=0;i<4;i++){\n\t\tint w=g[u][i];\n\t\tif(w!=-1&&c[w]==-1) DFS(u,i);\n\t}\n}\n\npll Rec(int v){\n\tll res=1,S=0;\n\tfor(auto u:G[v]){\n\t\tpll p=Rec(u);\n\t\tll T=p.second;\n\t\tres=Div(res*p.first%mod,F[T]);\n\t\tS+=T;\n\t}\n\t(res*=F[S])%=mod;\n\treturn {res,S+1};\n}\n\nll f(int v,int t){\n\tc[v]=t;\n\tfor(int i=0;i<4;i++) DFS(v,i%2*2+abs(i/2-t));\n\tfor(auto i:b){\n\t\tint u=g[i][c[i]];\n\t\twhile(u!=-1){\n\t\t\tG[i].push_back(u);\n\t\t\tused[u]=1;\n\t\t\tu=g[u][c[i]];\n\t\t}\n\t}\n\tfor(auto i:b) if(!used[i]) G[n].push_back(i);\n\tll res=Rec(n).first;\n\tfor(auto i:b){\n\t\tc[i]=-1;\n\t\tused[i]=0;\n\t\tG[i].clear();\n\t}\n\tG[n].clear();\n\treturn res;\n}\n\nint main(){\n\tInit();\n\tcin>>n;\n\tn*=2;\n\tx=y=ax=ay=vis=used=vi(n);\n\tc=vi(n,-1);\n\tX=Y=vvp(n);\n\tg=vvi(n,vi(4,-1));\n\tG=vvi(n+1);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tx[i]--;y[i]--;\n\t\tX[x[i]].push_back({y[i],i});\n\t\tY[y[i]].push_back({x[i],i});\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tsort(X[i].begin(),X[i].end());\n\t\tsort(Y[i].begin(),Y[i].end());\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<X[i].size();j++){\n\t\t\tint u=X[i][j-1].second,v=X[i][j].second;\n\t\t\tg[u][3]=v;g[v][1]=u;\n\t\t}\n\t\tfor(int j=1;j<Y[i].size();j++){\n\t\t\tint u=Y[i][j-1].second,v=Y[i][j].second;\n\t\t\tg[u][2]=v;g[v][0]=u;\n\t\t}\n\t}\n\tll res=F[n];\n\tfor(int i=0;i<n;i++) if(!vis[i]){\n\t\tcnt=0;num=0;\n\t\tb.clear();d.clear();\n\t\td.push_back(i);\n\t\tint v=dfs(i,-1);\n\t\td.pop_back();\n\t\tres=(cnt==num?Div(res*(f(v,0)+f(v,1))%mod,F[cnt]):0);\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*program by mangoyang*/\n#pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define inf (0x7f7f7f7f)\n#define Max(a, b) ((a) > (b) ? (a) : (b))\n#define Min(a, b) ((a) < (b) ? (a) : (b))\ntypedef long long ll;\nusing namespace std;\ntemplate <class T>\ninline void read(T &x){\n\tint ch = 0, f = 0; x = 0;\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') f = 1;\n\tfor(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\tif(f) x = -x;\n}\n#define fi first\n#define se second\nconst int N = 400005, mod = 1e9 + 7;\nvector<int> g[N];\nint inv[N], n;\ninline int Pow(int a, int b){\n\tint ans = 1;\n\tfor(; b; b >>= 1, a = 1ll * a * a % mod)\n\t\tif(b & 1) ans = 1ll * ans * a % mod;\n\treturn ans;\n}\nnamespace Camlia{\n\tvector<int> e[N];\n\tint sz[N], deg[N];\n\tinline int dfs(int u, int fa){\n\t\tll tmp = 1; sz[u] = 1;\n\t\tfor(auto v : e[u]) if(v != fa){\n\t\t\t(tmp *= dfs(v, u)) %= mod;\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t\treturn tmp * inv[sz[u]] % mod;\n\t}\n\tinline int gao(vector<pair<int, int> > &A){\n\t\tll res = 1;\n\t\tfor(auto x : A){\n\t\t\tdeg[x.fi] = deg[x.se] = 0;\n\t\t\te[x.fi].clear(), e[x.se].clear();\n\t\t}\n\t\tfor(auto x : A)\n\t\t\tfor(int i = 0; g[x.se][i] < x.fi; i++)\n\t\t\t\te[x.se].push_back(g[x.se][i]), deg[g[x.se][i]]++;\n\t\tfor(auto x : A){\n\t\t\tif(!deg[x.fi]) (res *= dfs(x.fi, 0)) %= mod, deg[x.fi]++;\n\t\t\tif(!deg[x.se]) (res *= dfs(x.se, 0)) %= mod, deg[x.se]++;\n\t\t}\n\t\treturn res;\n\t}\n}\nnamespace Rose{\n\tvector<int> cir[N];\n\tint vis[N], ins[N], inc[N], num;\n\tinline int getcircle(int u, int fa, vector<int> &A){\n\t\tif(ins[u]) return 1;\n\t\tins[u] = 1;\n\t\tfor(auto v : g[u]) if(v != fa){\n\t\t\tint gao = getcircle(v, u, A);\n\t\t\tif(gao == 0) continue;\n\t\t\tif(gao == 2) return 2;\n\t\t\tA.push_back(v);\n\t\t\treturn u == A[0] ? 2 : 1;\n\t\t}\n\t\treturn ins[u] = 0, 0;\n\t}\n\tinline pair<int, int> mark(int u){\n\t\tvis[u] = 1;\n\t\tpair<int, int> now; now.fi = 1, now.se = 0;\n\t\tfor(auto v : g[u]){\n\t\t\tif(vis[v]){ now.se++; continue; }\n\t\t\tpair<int, int> tmp = mark(v);\n\t\t\tnow.fi += tmp.fi, now.se += tmp.se + 1;\n\t\t}\n\t\treturn now;\n\t}\n\tinline void dfs(int u, int fa, vector<pair<int, int> > &A){\n\t\tif(fa) A.push_back(make_pair(fa, u));\n\t\tfor(auto v : g[u]) \n\t\t\tif(v != fa && !inc[v]) dfs(v, u, A);\n\t}\n\tinline void gao(){\n\t\tll res = 1;\n\t\tfor(int i = 1; i <= 2 * n; i++) if(!vis[i]){\n\t\t\tpair<int, int> now = mark(i);\n\t\t\tif(2 * now.fi != now.se){ puts(\"0\"); exit(0); }\n\t\t\tgetcircle(i, 0, cir[++num]);\n\t\t\tfor(auto x : cir[num]) inc[x] = 1;\n\t\t\tint size = cir[num].size();\n\t\t\tvector<pair<int, int> > Base, A, B;\n\t\t\tfor(auto x : cir[num]) dfs(x, 0, Base);\n\t\t\tA = B = Base;\n\t\t\tfor(int j = 1; j < size; j++)\n\t\t\t\tA.push_back(make_pair(cir[num][j-1], cir[num][j]));\n\t\t\tA.push_back(make_pair(cir[num][size-1], cir[num][0]));\n\t\t\tfor(int j = 1; j < size; j++)\n\t\t\t\tB.push_back(make_pair(cir[num][j], cir[num][j-1]));\n\t\t\tB.push_back(make_pair(cir[num][0], cir[num][size-1]));\n\t\t\t(res *= (Camlia::gao(A) + Camlia::gao(B)) % mod) %= mod;\n\t\t}\n\t\tfor(int i = 1; i <= 2 * n; i++) (res *= i) %= mod;\n\t\tprintf(\"%lld\\n\", res);\n\t}\n}\nint main(){\n\tread(n);\n\tfor(int i = 1, x, y; i <= 2 * n; i++){\n\t\tread(x), read(y), y += n;\n\t\tg[x].push_back(y), g[y].push_back(x);\n\t}\n\tfor(int i = 1; i <= 2 * n; i++) \n\t\tinv[i] = Pow(i, mod - 2);\n\tfor(int i = 1; i <= 2 * n; i++)\n\t\tsort(g[i].begin(), g[i].end());\n\tRose::gao();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \n\nusing namespace std;\n\nnamespace Tzh{\n\t\n\ttypedef long long ll;\n\tconst int maxn=200010;\n\tconst ll p=1e9+7;\n\tint st[maxn],top,all,vis[maxn],head[maxn],cnt=1,n,fa[maxn],eid[maxn],flag,size[maxn],point[maxn],num;\n\tll fac[maxn],ans; int val[maxn];\n\n\tll qpow(ll a,ll b){ ll sum=1;\n\t\twhile(b){\n\t\t\tif(b&1) sum=sum*a%p;\n\t\t\ta=a*a%p; b>>=1;\n\t\t}\t\n\t\treturn sum;\n\t}\n\n\tstruct ed{\n\t\tint next,to,w,vis;\n\t}e[maxn<<1];\n\n\tvoid add(int u,int v,int w){\n\t\te[++cnt]=(ed){head[u],v,w,0}; head[u]=cnt;\n\t\te[++cnt]=(ed){head[v],u,w,0}; head[v]=cnt;\n\t}\n\n\tvoid dfs(int now,int f){ vis[now]=1; all++;\n\t\tfor(int i=head[now];i;i=e[i].next){\n\t\t\tint tt=e[i].to; if(tt==f) continue;\n\t\t\tst[++top]=i; if(vis[tt]){\n\t\t\t\tif(flag) {top--; continue;}\n\t\t\t\tint tmp=top; int mx=0,pos=0;\n\t\t\t\twhile(e[st[tmp]^1].to!=e[i].to) tmp--;\n\t\t\t\tfor(int i=tmp;i<=top;i++) \n\t\t\t\t\tif(e[st[i]].w>mx) mx=e[st[i]].w,pos=st[i];\t\n\t\t\t\tflag=pos; top--; continue;\n\t\t\t} dfs(tt,now); top--; \n\t\t}\n\t}\n\n\tvoid dfs2(int now,int f){ fa[now]=f; \n\t\tfor(int i=head[now];i;i=e[i].next){\n\t\t\tint tt=e[i].to; if(tt==f||e[i].vis) continue;\n\t\t\tpoint[++num]=tt; eid[num]=i; dfs2(tt,now);\n\t\t}\n\t}\n\n\tvoid dfs3(int now,int f){ size[now]=1;\n\t\tfor(int i=head[now];i;i=e[i].next){\n\t\t\tint tt=e[i].to; if(tt==f||e[i].vis) continue;\n\t\t\tdfs3(tt,now); size[now]+=size[tt];\n\t\t}\n\t\tans=ans*size[now]%p;\n\t}\n\n\tll suan(int now){\n\t\tans=1; dfs3(now,0); ans=fac[size[now]]*qpow(ans,p-2)%p;\n\t\treturn ans;\n\t}\n\n\tll cal(int now,int f){\n\t\tnum=0; dfs2(now,0); static int st[maxn],top; top=0;\n\t\tstatic ll g[maxn],sz[maxn]; st[++top]=now; fa[now]=f;\n\t\tfor(int i=1;i<=num;i++){int cur=point[i];\n\t\t\tif(fa[fa[cur]]&&fa[fa[cur]]<cur) \n\t\t\t   e[eid[i]].vis=e[eid[i]^1].vis=1,st[++top]=cur;\n\t\t} ll sum=0;\n\t\tfor(int i=1;i<=top;i++) g[i]=suan(st[i]),sz[i]=size[st[i]];\n\t\tfor(int i=1;i<=top;i++) sum=sum+sz[i]; sum=fac[sum];\n\t\tfor(int i=1;i<=top;i++) sum=sum*qpow(fac[sz[i]],p-2)%p;\n\t\tfor(int i=1;i<=top;i++) sum=sum*g[i]%p;\n\t\tfor(int i=1;i<=num;i++) e[eid[i]].vis=e[eid[i]^1].vis=0;\n\t\treturn sum;\n\t}\n\n\tint ffa(int x){return fa[x]==x?x:fa[x]=ffa(fa[x]);}\n\n\tvoid work(){\n\t\tscanf(\"%lld\",&n); n*=2; fac[0]=1;\n\t\tfor(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%p;\n\t\tstatic int sz[maxn],tot; static ll F[maxn]; int x,y;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,val[i]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lld%lld\",&x,&y),add(x,y+(n>>1),x+y);\n\t\t\tint a=x,b=y=n>>1; if(ffa(a)==ffa(b)) val[ffa(a)]--;\n\t\t\tval[ffa(b)]+=val[ffa(a)]-1; fa[ffa(a)]=ffa(b);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) if(val[ffa(i)]!=0) {puts(\"0\"); return ;}\n\t\tmemset(fa,0,sizeof(fa));\n\t\tfor(int i=1;i<=n;i++) if(!vis[i]){\n\t\t\tflag=0; all=0; dfs(i,0); \n\t\t\tif(!flag) {puts(\"0\"); return ;}\n\t\t\te[flag].vis=e[flag^1].vis=1; \n\t\t\tF[++tot]=(cal(e[flag^1].to,e[flag].to)+cal(e[flag].to,e[flag^1].to))%p;\n\t\t\tsz[tot]=all; \n\t\t} ll sum=0;\n\t\tfor(int i=1;i<=tot;i++) sum+=sz[i]; sum=fac[sum];\n\t\tfor(int i=1;i<=tot;i++) sum=sum*qpow(fac[sz[i]],p-2)%p;\n\t\tfor(int i=1;i<=tot;i++) sum=sum*F[i]%p;\n\t\tprintf(\"%lld\",sum);\n\t\treturn ;\n\t}\n}\n\nsigned main(){\n\tTzh::work();\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    UnionFind(int);\n    int find(int);\n    void unite(int, int);\nprivate:\n    vector<int> table;\n};\n\nUnionFind::UnionFind(int size) {\n    table.resize(size);\n    fill(table.begin(), table.end(), -1);\n}\n\nint UnionFind::find(int x) {\n    while (0 <= table[x])\n        x = table[x];\n    return x;\n}\n\nvoid UnionFind::unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry) {\n        int dx = -table[rx];\n        int dy = -table[ry];\n        if (dx != dy) {\n            if (dx < dy) {\n                table[rx] = ry;\n            } else {\n                table[ry] = rx;\n            }\n        } else {\n            table[rx] -= 1;\n            table[ry] = rx;\n        }\n    }\n}\n\n\nconst long M = 1e9 + 7;\nint N;\nlong F[202020];\nint groups[202020];\nint pair_table[202020];\nint counts[202020];\nlong perms[202020];\nvector< vector<int> > edges;\nvector<bool> is_root;\n\n\nlong powmod(long a, long x, long m) {\n    long r = 1;\n    while (0 < x) {\n        if (x & 1) {\n            r *= a;\n            r %= m;\n        }\n        x >>= 1;\n        a *= a;\n        a %= m;\n    }\n    return r;\n}\n\n\nvoid calc_node(int node, const vector< vector<int> > &tree) {\n    if (tree[node].size() == 0) {\n        counts[node] = 1;\n        perms[node] = 1;\n    } else {\n        int c;\n        \n        c = 0;\n        for (int child : tree[node]) {\n            calc_node(child, tree);\n            c += counts[child];\n        }\n        counts[node] = c + 1;\n\n        long p;\n\n        p = F[c];\n        for (int child : tree[node]) {\n            p *= powmod(F[counts[child]], M - 2, M);\n            p %= M;\n            p *= perms[child];\n            p %= M;\n        }\n        perms[node] = p;\n    }\n}\n\nlong calc(const vector<int> &nodes) {\n    vector< vector<int> > tree;\n    int nv, nnv;\n    int c;\n    long p;\n\n    fill(is_root.begin(), is_root.end(), true);\n    tree.resize(2 * N);\n\n    for (int v : nodes) {\n        nv = pair_table[v];\n        nnv = pair_table[nv];\n        if (v < nnv) {\n            is_root[v] = false;\n            tree[nv].push_back(v);\n        }\n    }\n\n    c = 0;\n    for (int v : nodes) {\n        if (is_root[v]) {\n            calc_node(v, tree);\n            c += counts[v];\n        }\n    }\n\n    p = F[c];\n    for (int v : nodes) {\n        if (is_root[v]) {\n            p *= powmod(F[counts[v]], M - 2, M);\n            p %= M;\n            p *= perms[v];\n            p %= M;\n        }\n    }\n\n    return p;\n}\n\n\n\nlong solve(const vector<int> &nodes) {\n    int pv, nv;\n\n    for (int v : nodes) {\n        if (edges[v].size() == 1) {\n            nv = edges[v].back();\n            edges[v].pop_back();\n            pair_table[v] = nv;\n            edges[nv].erase(find(edges[nv].begin(), edges[nv].end(), v));\n            pv = v; v = nv;\n            while (edges[v].size() == 1) {\n                nv = edges[v].back();\n                edges[v].pop_back();\n                pair_table[v] = nv;\n                edges[nv].erase(find(edges[nv].begin(), edges[nv].end(), v));\n                pv = v; v = nv;\n            }\n        }\n    }\n\n    int v0 = 0;\n    int v1, v2;\n    for (int v : nodes) {\n        if (edges[v].size() != 0) {\n            v0 = v;\n            break;\n        }\n    }\n    v1 = edges[v0][0];\n    v2 = edges[v0][1];\n\n    long r = 0;\n    int v;\n    int nv0, nv1, nv2;\n    rep(d, 0, 2) {\n        nv0 = (d == 0) ? v1 : v2;\n        nv = nv0; v = v0;\n        pair_table[v] = nv;\n        pv = v; v = nv;\n        while (v != v0) {\n            nv1 = edges[v][0];\n            nv2 = edges[v][1];\n            nv = (nv1 != pv) ? nv1 : nv2;\n            pair_table[v] = nv;\n            pv = v; v = nv;\n        }\n        r += calc(nodes);\n        r %= M;\n    }\n\n    return r;\n}\n\n\nint main(int argc, const char * argv[]) {\n    vector< tuple<int, int> > balls;\n    int x, y;\n\n    cin >> N;\n    rep(i, 0, 2 * N) {\n        cin >> x >> y;\n        balls.push_back(make_tuple(x - 1, N + y - 1));\n    }\n\n    {\n        long p = 1;\n        rep(i, 1, 2 * N + 1) {\n            p *= i;\n            p %= M;\n            F[i] = p;\n        }\n    }\n\n    UnionFind uf(2 * N);\n    edges.resize(2 * N);\n    is_root.resize(2 * N);\n\n    for (tuple<int, int> t : balls) {\n        int x = get<0>(t);\n        int y = get<1>(t);\n        uf.unite(x, y);\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n\n    long ans = F[2 * N];\n    vector<int> nodes;\n    unsigned long num_nodes, num_edges;\n\n    \n    rep(i, 0, 2 * N) {\n        if (edges[i].empty()) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n\n    rep(i, 0, 2 * N) groups[i] = uf.find(i);\n    \n    rep(i, 0, 2 * N) {\n        if (groups[i] == i) {\n            nodes.clear();\n            rep(v, 0, 2 * N) {\n                if (groups[v] == i) {\n                    nodes.push_back(v);\n                }\n            }\n            num_nodes = nodes.size();\n            num_edges = 0;\n            for (int v : nodes) {\n                num_edges += edges[v].size();\n            }\n            num_edges /= 2;\n            if (num_nodes != num_edges) {\n                cout << 0 << endl;\n                return 0;\n            }\n            ans *= powmod(F[num_nodes], M - 2, M);\n            ans %= M;\n            ans *= solve(nodes);\n            ans %= M;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 400005\n#define P 1000000007\n#define ll long long\nusing namespace std;\nint n,rd[N],vis[N],fa[N],s1[N],s2[N],a[N],cnt,rt[N],flag[N];\nint fst[N],to[N*2],nxt[N],l;\nint inv[N],fac[N],ifac[N];\nvector<int>v[N];\nstruct T\n{\n\tint x,y;\n};\nint C(int x,int y)\n{\n\treturn (ll)fac[y]*ifac[x]%P*ifac[y-x]%P;\n}\nT operator+(T a,T b)\n{\n\treturn (T){(a.x+b.x)%P,a.y};\n}\nT operator*(T a,T b)\n{\n\treturn (T){(ll)a.x*b.x%P*C(a.y,a.y+b.y)%P,a.y+b.y};\n}\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n\trd[x]++;rd[y]++;\n}\nvoid dfs(int x)\n{\n\tif (vis[x]) return;\n\tvis[x]=1;\n\ta[++cnt]=x;\n\tfor (int i=fst[x];i;i=nxt[i])\n\t\tdfs(to[i]);\n}\nvoid Dfs(int x)\n{\n\trd[x]=-1;\n\tfor (int i=fst[x];i;i=nxt[i])\n\t\tif (rd[to[i]]!=-1)\n\t\t{\n\t\t\tfa[x]=to[i];rd[to[i]]--;\n\t\t\tif (rd[to[i]]==1) Dfs(to[i]);\n\t\t}\n}\nT solve(int x)\n{\n\tT ans=(T){1,0};\n\tfor (int i=0;i<v[x].size();i++)\n\t\tans=ans*solve(v[x][i]);\n\tans.y++;\n\treturn ans;\n}\nT work(int x)\n{\n\tcnt=0;\n\tdfs(x);\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tif (rd[a[i]]==1)\n\t\t\tDfs(a[i]);\n\t}\n\tint tmp;\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tif (rd[a[i]]!=-1)\n\t\t{\n\t\t\ttmp=a[i];\n\t\t\tfor (int j=fst[a[i]];j;j=nxt[j])\n\t\t\t\tif (rd[to[j]]!=-1)\n\t\t\t\t\tif (s1[a[i]]) s2[a[i]]=to[j];\n\t\t\t\t\telse s1[a[i]]=to[j];\n\t\t}\n\t}\n\t//puts(\"ok\");\n\tint lst=tmp;fa[tmp]=s2[tmp];\n\tfor (int i=s1[tmp];i!=tmp;)\n\t{\n\t\t//cout<<i<<' '<<tmp<<endl;\n\t\tfa[i]=lst;\n\t\tlst=i;\n\t\ti=s1[i]+s2[i]-fa[i];\n\t\t//swap(lst,tmp);\n\t\t//tmp=s1[lst]+s2[lst]-tmp;\n\t}\n\tfor (int i=1;i<=cnt;i++)\n\t\tflag[a[i]]=0;\n\tint ly=0;\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tfor (int j=fst[a[i]];j;j=nxt[j])\n\t\t\tif (fa[a[i]]>to[j])\n\t\t\t{\n\t\t\t\t//cout<<fa[a[i]]<<' '<<a[i]<<' '<<to[j]<<endl;\n\t\t\t\tv[a[i]].push_back(to[j]);flag[to[j]]=1;\n\t\t\t}\n\t\t//if (flag) rt[++ly]=i;\n\t}\n\tT A1=(T){1,0};\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tif (!flag[a[i]])\n\t\t\tA1=A1*solve(a[i]);\n\t}\n//\tcout<<A1.x<<' '<<A1.y<<endl;\n\t\n\tfor (int i=1;i<=cnt;i++)\n\t\tswap(s1[a[i]],s2[a[i]]);\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tfa[i]=0;\n\t\tv[a[i]].clear();\n\t}\n\tfor (int i=1;i<=cnt;i++)\n\t\tflag[a[i]]=0;\n\tlst=tmp;fa[tmp]=s2[tmp];ly=0;\n\tfor (int i=s1[tmp];i!=tmp;)\n\t{\n\t\tfa[i]=lst;\n\t\tlst=i;\n\t\ti=s1[i]+s2[i]-fa[i];\n\t}\n\tly=0;\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tfor (int j=fst[a[i]];j;j=nxt[j])\n\t\t\tif (fa[a[i]]>to[j]) v[a[i]].push_back(to[j]),flag[to[j]]=1;\n\t}\n\tT A2=(T){1,0};\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tif (!flag[a[i]])\n\t\tA2=A2*solve(a[i]);\n\t}\n\t\n\treturn A1+A2;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n*2;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y+n);\n\t}\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1;\n\tfor (int i=2;i<=n*2;i++)\n\t{\n\t\tinv[i]=(ll)(P-P/i)*inv[P%i]%P;\n\t\tfac[i]=(ll)fac[i-1]*i%P;\n\t\tifac[i]=(ll)ifac[i-1]*inv[i]%P;\n\t}\n\t//特判 \n\tfor (int i=1;i<=n*2;i++)\n\t\tif (rd[i]==0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\tT Ans=(T){1,0};\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (!vis[i])\n\t\t\tAns=Ans*work(i);\n\t}\n\tprintf(\"%d\\n\",Ans.x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\nint n,fac[200100],inv[200100],ans,cntv,cnte,a[200100],deg[200100],link[200100],s[200100];\nbool flag[200100];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[600100],*tp=pool,*fst[200100],*fst2[200100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nint c(int n,int m)\n{\n    return LL(fac[n])*inv[m]%p*inv[n-m]%p;\n}\n\nvoid addedge(int u,int v,edge **fst)\n{\n    *tp=(edge){v,fst[u]},fst[u]=tp++;\n}\n\nvoid dfs1(int x)\n{\n    flag[x]=1,a[++cntv]=x;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (flag[i->v])\n            ++cnte,++deg[x],++deg[i->v];\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (!flag[i->v])\n            dfs1(i->v);\n}\n\nint dfs2(int x)\n{\n    int ret=s[x]=1;\n    for (edge *i=fst2[x]; i; i=i->nxt)\n    {\n        ret=LL(ret)*dfs2(i->v)%p;\n        s[x]+=s[i->v],ret=LL(ret)*c(s[x]-1,s[i->v])%p;\n    }\n    return ret;\n}\n\nint calc()\n{\n    static bool flag[200100];\n    edge *t=tp;\n    repu(i,1,cntv)\n        flag[a[i]]=0;\n    repu(i,1,cntv)\n        for (edge *j=fst[a[i]]; j; j=j->nxt)\n            if (j->v<link[a[i]])\n                addedge(a[i],j->v,fst2),flag[j->v]=1;\n    int sum=0,ret=1;\n    repu(i,1,cntv)\n        if (!flag[a[i]])\n        {\n            ret=LL(ret)*dfs2(a[i])%p;\n            ret=LL(ret)*c(sum+=s[a[i]],s[a[i]])%p;\n        }\n    tp=t;\n    repu(i,1,cntv)\n        fst2[a[i]]=0;\n    return ret;\n}\n\nint solve(int x)\n{\n    cntv=cnte=0,dfs1(x);\n    if (cntv!=cnte)\n    {\n        puts(\"0\");\n        exit(0);\n    }\n    repu(i,1,cntv)\n        if (deg[a[i]]==1)\n            for (int j=a[i],nxt=0; j; j=nxt,nxt=0)\n                for (edge *k=fst[j]; k; k=k->nxt)\n                    if (deg[k->v]>1)\n                    {\n                        link[j]=k->v;\n                        if (--deg[k->v]==1)\n                            nxt=k->v;\n                    }\n    static int cyc[200100],tot;\n    repu(i,1,cntv)\n        if (deg[a[i]]>1)\n        {\n            cyc[tot=1]=a[i];\n            while (tot==1 || cyc[tot]!=a[i])\n                for (edge *j=fst[cyc[tot]]; j; j=j->nxt)\n                    if (deg[j->v]>1 && cyc[tot-1]!=j->v)\n                    {\n                        cyc[++tot]=j->v;\n                        break;\n                    }\n            --tot;\n            break;\n        }\n    repu(i,1,tot)\n        link[cyc[i]]=cyc[i+1];\n    int sum=calc();\n    repu(i,1,tot)\n        link[cyc[i+1]]=cyc[i];\n    (sum+=calc())%=p,ans=LL(ans)*sum%p;\n    return cntv;\n}\n\nint main()\n{\n    n=getint(),ans=1;\n    repu(i,1,n*2)\n    {\n        int u=getint(),v=getint()+n;\n        addedge(u,v,fst),addedge(v,u,fst);\n    }\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    repu(i,2,n*2)\n        inv[i]=LL(p-p/i)*inv[p%i]%p;\n    repu(i,2,n*2)\n        fac[i]=LL(fac[i-1])*i%p,inv[i]=LL(inv[i-1])*inv[i]%p;\n    int sum=0;\n    repu(i,1,n*2)\n        if (!flag[i])\n        {\n            int cnt=solve(i);\n            ans=LL(ans)*c(sum+=cnt,cnt)%p;\n        }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nstruct StronglyConnectedComponent {\n        int n;\n        vector<bool> used;\n        vector<int> order, cmp;\n        vector<vector<int>> g, rg;\n        StronglyConnectedComponent(int x) {\n                n = x;\n                g.resize(x);\n                rg.resize(x);\n                used.resize(x);\n                cmp.resize(x);\n        }\n        void add_edge(int from, int to) {\n                g[from].push_back(to);\n                rg[to].push_back(from);\n        }\n        void dfs(int u) {\n                used[u] = true;\n                for (auto v : g[u]) if (!used[v]) {\n                        dfs(v);\n                }\n                order.push_back(u);\n        }\n        void rdfs(int u, int k) {\n                used[u] = true;\n                cmp[u] = k;\n                for (auto v : rg[u]) if (!used[v]) {\n                        rdfs(v, k);\n                }\n        }\n        int init() {\n                used.assign(n, false);\n                for (int u = 0; u < n; u ++) {\n                        if (!used[u]) {\n                                dfs(u);\n                        }\n                }\n                used.assign(n, false);\n                int k = 0;\n                for (int i = order.size() - 1; i >= 0; i --) {\n                        if (!used[order[i]]) {\n                                rdfs(order[i], k ++);\n                        }\n                }\n                return k;\n        }\n};\n\nconst int N = 5000001;\nlong long fact[N];\nlong long invfact[N];\nlong long inv[N];\nvoid init() {\n        fact[0] = fact[1] = 1;\n        for (int i = 2; i < N; i ++) fact[i] = fact[i - 1] * i % MOD;\n        inv[1] = 1;\n        for (int i = 2; i < N; i ++) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;\n        invfact[0] = invfact[1] = 1;\n        for (int i = 2; i < N; i ++) invfact[i] = invfact[i - 1] * inv[i] % MOD;\n}\nlong long C(long long n, long long r) {\n        if (n < 0 || r < 0 || n < r) return 0;\n        return fact[n] * invfact[n - r] % MOD * invfact[r] % MOD;\n}\n\nlong long calc(vector<vector<int>> &forest) {\n\tint n = forest.size();\n\tStronglyConnectedComponent scc(n);\n\tfor (int i = 0; i < n; i ++) {\n\t\tfor (auto j : forest[i]) {\n\t\t\tscc.add_edge(i, j);\n\t\t\tcerr << i << ' ' << j << endl;\n\t\t}\n\t}\n\tscc.init();\n\tvector<int> idx(n);\n\trep(i, n) idx[i] = i;\n\tsort(idx.begin(), idx.end(), [&](const int &i, const int &j) {\n\t\treturn scc.cmp[i] < scc.cmp[j];\n\t});\n\tvector<bool> used(n);\n\tlong long res = 1;\n\tlong long resres = 1;\n\tint tot = 0;\n\tfunction<int (int, int)> dfs = [&](int u, int prev) {\n\t\tused[u] = true;\n\t\tint total = 0;\n\t\tfor (auto v : forest[u]) if (v != prev) {\n\t\t\tint szsz = dfs(v, u);\n\t\t\ttotal += szsz;\n\t\t\t(resres *= C(total, szsz)) %= MOD;\n\t\t}\n\t\treturn tot + 1;\n\t};\n\tfor (int i = 0; i < n; i ++) {\n\t\tint u = idx[i];\n\t\tif (!used[u]) {\n\t\t\tresres = 1;\n\t\t\tint sz = dfs(u, -1);\n\t\t\ttot += sz;\n\t\t\t(res *= C(tot, sz)) %= MOD;\n\t\t\t(res *= resres) %= MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tinit();\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<vector<int>> g(2 * n);\n\trep(i, 2 * n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx --, y --;\n\t\tg[x].push_back(y + n);\n\t\tg[y + n].push_back(x);\n\t}\n\n\tvector<vector<bool>> used(3, vector<bool> (n));\n\tvector<set<pair<int, int>>> eused(3);\n\tint ec = 0, nc = 0;\n\tvector<int> target(n, -1), app;\n\tint on_cycle = -1;\n\tfunction<void (int, int, int)> dfs = [&](int u, int prev, int num) {\n\t\tapp.push_back(u);\n\t\tnc ++;\n\t\tused[num][u] = true;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tif (eused[num].count(make_pair(min(u, v), max(u, v))) == 0) {\n\t\t\t\ttarget[v] = u;\n\t\t\t\teused[num].insert(make_pair(min(u, v), max(u, v)));\n\t\t\t\tec ++;\n\t\t\t\tif (used[num][v]) {\n\t\t\t\t\ton_cycle = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!used[num][v]) {\n\t\t\t\tdfs(v, u, num);\n\t\t\t}\n\t\t}\n\t};\n\tlong long ans = 1;\n\trep(i, 2 * n) if (!used[0][i]) {\n\t\tec = 0, nc = 0;\n\t\tdfs(i, -1, 0);\n\t\tif (ec != nc) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tlong long tmp = 0;\n\t\t// define target\n\t\tapp.clear();\n\t\tdfs(on_cycle, -1, 1);\n\t\t{\n\t\t\tmap<int, int> mp;\n\t\t\tint k = 0;\n\t\t\tfor (auto a : app) {\n\t\t\t\tassert(target[a] != -1);\n\t\t\t\tmp[a] = k ++;\n\t\t\t}\n\t\t\tvector<vector<int>> ggg(k);\n\t\t\tfor (auto a : app) {\n\t\t\t\tfor (auto v : g[a]) {\n\t\t\t\t\tif (v < target[a]) {\n\t\t\t\t\t\tggg[mp[a]].push_back(mp[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t(tmp += calc(ggg)) %= MOD;\n\t\t}\n\t\t// change target\n\t\treverse(g[on_cycle].begin(), g[on_cycle].end());\n\t\tapp.clear();\n\t\tdfs(on_cycle, -1, 2);\n\t\t{\n\t\t\tmap<int, int> mp;\n\t\t\tint k = 0;\n\t\t\tfor (auto a : app) {\n\t\t\t\tassert(target[a] != -1);\n\t\t\t\tmp[a] = k ++;\n\t\t\t}\n\t\t\tvector<vector<int>> ggg(k);\n\t\t\tfor (auto a : app) {\n\t\t\t\tfor (auto v : g[a]) {\n\t\t\t\t\tif (v < target[a]) {\n\t\t\t\t\t\tggg[mp[a]].push_back(mp[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t(tmp += calc(ggg)) %= MOD;\n\t\t}\n\t\t(ans *= tmp) %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst ll MOD = 1e9 + 7;\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\nconst int MAXN = 210000;\n\nll fc[MAXN];\nll bfc[MAXN]; \nint was[MAXN];\nvector<int> fr;\nvector<int> st;\nvector<int> vv;\nvector<int> eds[MAXN];\nint sz[MAXN];\nint en[MAXN];\n\nll cnk(int n, int k) {\n\tif (k > n)\n\t\treturn 0;\n\treturn fc[n] * bfc[k] % MOD * bfc[n - k] % MOD;\n}\n\nint dfs1(int v, int p) {\n\twas[v] = 1;\n\tst.push_back(v);\n\tfor (int u: eds[v]) {\n\t\tif (u == p)\n\t\t\tcontinue;\n\t\tif (was[u]) {\n\t\t\tfor (int j = 0; j < st.size(); ++j) {\n\t\t\t\tif (st[j] == u) {\n\t\t\t\t\tfor (int k = j; k < st.size(); ++k)\n\t\t\t\t\t\tvv.push_back(st[k]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (dfs1(u, v))\n\t\t\treturn 1;\n\t}\n\tst.pop_back();\n\treturn 0;\n}\n\npair<int, ll> dfs2(int v, int p, int tm) {\n\twas[v] = tm;\n\tint sz = 0;\n\tll cur = 1;\n\tfor (int u: eds[v]) {\n\t\tif (was[u] >= tm)\n\t\t\tcontinue;\n\t\tpair<int, ll> tmp = dfs2(u, v, tm);\n\t\tcur = (cur * tmp.second) % MOD;\n\t\tif (u > p) {\n\t\t\tfr.push_back(tmp.first);\n\t\t}\n\t\telse {\n\t\t\tcur = cur * cnk(sz + tmp.first, tmp.first) % MOD;\n\t\t\tsz += tmp.first;\n\t\t}\n\t}\n\treturn make_pair(sz + 1, cur);\n}\n\npair<ll, int> func(int k, int tm) {\n\tll cur = 1;\n\tfr.clear();\n\tfor (int i = 1; i <= k; ++i) {\n\t\tint go = vv[i + 1];\n\t\tint ng = vv[i - 1];\n\t\tpair<int, ll> tmp = dfs2(vv[i], go, tm);\n\t\tsz[i] = tmp.first;\n\t\tcur = (cur * tmp.second) % MOD;\n\t\tif (go < ng)\n\t\t\ten[i] = 1;\n\t\telse\n\t\t\ten[i] = 0;\n\t}\n\tint csz = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tif (en[i]) {\n\t\t\tif (csz)\n\t\t\t\tfr.push_back(csz);\n\t\t\tcsz = sz[i];\n\t\t}\n\t\telse if (!csz) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tcur = cur * cnk(csz + sz[i] - 1, sz[i] - 1) % MOD; \n\t\t\tcsz += sz[i];\n\t\t}\n\t}\n\tif (!csz)\n\t\tcur = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tif (en[i]) {\n\t\t\tif (csz)\n\t\t\t\tfr.push_back(csz);\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcur = cur * cnk(csz + sz[i] - 1, sz[i] - 1) % MOD; \n\t\t\tcsz += sz[i];\n\t\t}\n\t}\n\tcsz = 0;\n\tfor (int i: fr) {\n\t\tcsz += i;\n\t\tcur = (cur * cnk(csz, i)) % MOD;\n\t}\n\treturn make_pair(cur, csz);\n}\n\nint n;\n\nint main() {\n\tfc[0] = bfc[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tfc[i] = (fc[i - 1] * i) % MOD, bfc[i] = pw(fc[i], MOD - 2);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n * 2; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x, --y;\n\t\teds[x].push_back(y + n);\n\t\teds[y + n].push_back(x);\n\t}\n\tll ans = 1;\n\tint csz = 0;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tif (was[i])\n\t\t\tcontinue;\n\t\tvv.clear();\n\t\tst.clear();\n\t\tif (!dfs1(i, -1)) {\n\t\t\tcout << 0 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tint k = vv.size();\n\t\tvv.push_back(vv[0]);\n\t\tvv.push_back(vv[1]);\n\t\tll sum = 0;\n\t\tint sz = 0;\n\t\tfor (int u: vv)\n\t\t\twas[u] = 2;\n\t\ttie(sum, sz) = func(k, 2);\n\t\treverse(vv.begin(), vv.end());\n\t\tfor (int u: vv)\n\t\t\twas[u] = 3;\n\t\tsum = (sum + func(k, 3).first) % MOD;\n\t\tans = (ans * sum) % MOD;\n\t\tcsz += sz;\n\t\tans = (ans * cnk(csz, sz)) % MOD;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,o,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\n\nint dep;\n\nvoid dfs(int f,int x){\n\n\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\t\n\t\n\t\ndep++;\nif(dep>200000)return;\n\t\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\tdfs(x,V[x][i]);\n\tstk[top--]=0;instk[x]=0;\n\t\ndep--;\t\n\t\n}\nint dfs(int x){\n\n\ndep++;\nif(dep>200000)return 0;\n\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vx[X][i]!=o){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vy[Y][i]!=o){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\t\ndep--;\n\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\to=0;int xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\tw[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\tw[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\n#include<set>\n#define lowbit(o) o&(-o)\n#define P 1000000007\n#define N 200005\n#define M 400005\nusing namespace std;\nint i,j,k,l,s,r,n,m,jc[N],ny[N],fa[N],A[2][N],B[2][N],tot,T,vis[2][N],id[N];\nint ans,Ans,si,G[N];\nset<int>GT[2][N],V[2][N];\nset<int>::iterator GTW;\nstruct orz {\n\tint x,y;\n}a[N],q[N],Q[N];\nstruct node {\n\tint tot,last[N],to[M],next[M];\n\tinline void add(int x,int y) {\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A1;\nstruct Node {\n\tint tot,chu[N],ru[N],l,r,last[N],next[M],to[M],f[N],si[N];\n\torz q[N];\n\tinline void add(int x,int y) {\n\t\tchu[x]++; ru[y]++;\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A2;\ninline bool cmp(int x,int y) {\n\treturn G[x]<G[y];\n}\ninline int findl(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=0;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]<x) s=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn s+1;\n}\ninline int findr(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=2*n+1;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]>x) s=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn s-1;\n}\ninline int quick(int x,int y) {\n\tint s=1;\n\twhile (y) {\n\t\tif (y&1) s=1ll*s*x%P;\n\t\tx=1ll*x*x%P;\n\t\ty>>=1;\n\t}\n\treturn s;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\ninline int C(int x,int y) {\n\treturn 1ll*jc[x]*ny[y]%P*ny[x-y]%P;\n}\ninline int getans(int r) {\n\tT=s=0;\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].insert(q[i].y);\n//\tfor (int i=0;i<=1;i++) for (int j=1;j<=n;j++) if (get(i*n+j)==get(q[1].x*n+q[1].y)) {\n\tint L=findl(get(q[1].x*n+q[1].y)),R=findr(get(q[1].x*n+q[1].y));\n\tfor (int i=L;i<=R;i++) {\n\t\ts++;\n\t\tQ[++T].x=(id[i]-1)/n,Q[T].y=(id[i]-1)%n+1;\n\t\tif (A[Q[T].x][Q[T].y]) {\n \t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>A[Q[T].x][Q[T].y]) break;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>B[Q[T].x][Q[T].y]) break;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t}\n\tA2.l=A2.r=0;\n\tA2.f[A2.si[0]=0]=1;\n\tfor (int i=1;i<=T;i++) A2.f[Q[i].x*n+Q[i].y]=1;\n\tfor (int i=1;i<=T;i++) if (!A2.chu[Q[i].x*n+Q[i].y]) A2.add(Q[i].x*n+Q[i].y,0);\n\tfor (int i=1;i<=T;i++) if (!A2.ru[Q[i].x*n+Q[i].y]) A2.q[++A2.r].x=Q[i].x,A2.q[A2.r].y=Q[i].y;\n\twhile (A2.l<A2.r) {\n\t\tA2.l++;\n\t\tA2.si[A2.q[A2.l].x*n+A2.q[A2.l].y]++;\n\t\tfor (int i=A2.last[A2.q[A2.l].x*n+A2.q[A2.l].y];i;i=A2.next[i]) {\n\t\t\tA2.ru[A2.to[i]]--;\n\t\t\tA2.si[A2.to[i]]+=A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y];\n\t\t\t(A2.f[A2.to[i]]=1ll*A2.f[A2.to[i]]*A2.f[A2.q[A2.l].x*n+A2.q[A2.l].y]%P*C(A2.si[A2.to[i]],A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y])%P);\n\t\t\tif (!A2.ru[A2.to[i]]) A2.q[++A2.r].x=(A2.to[i]-1)/n,A2.q[A2.r].y=(A2.to[i]-1)%n+1;\n\t\t}\n\t}\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].erase(q[i].y);\n\tA2.tot=0;\n\tfor (int i=1;i<=A2.r;i++) A2.last[A2.q[i].x*n+A2.q[i].y]=0,A2.chu[A2.q[i].x*n+A2.q[i].y]=A2.ru[A2.q[i].x*n+A2.q[i].y]=0;\n\tfor (int i=1;i<=T;i++) A2.f[A2.q[i].x*n+A2.q[i].y]=A2.si[A2.q[i].x*n+A2.q[i].y]=0;\n\treturn A2.f[0];\n}\ninline void work(int x,int y) {\n\tvis[x][y]=1;\n\tint l=0,r=1; q[1].x=x,q[1].y=y;\n\twhile (l<r) {\n\t\t++l;\n\t\tfor (GTW=GT[q[l].x][q[l].y].begin();GTW!=GT[q[l].x][q[l].y].end();GTW++) if (!vis[q[l].x^1][(*GTW)]) q[++r].x=q[l].x^1,q[r].y=(*GTW),vis[q[r].x][q[r].y]=1;\n\t}\n\tfor (int i=1;i<=r;i++) \n\tfor (GTW=GT[q[i].x][q[i].y].begin();GTW!=GT[q[i].x][q[i].y].end();GTW++) A1.add(q[i].x*n+q[i].y,(*GTW));\n\tint xx=x,yy=y;\n\tB[xx][yy]=A1.to[A1.last[xx*n+yy]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) \n\t\tif (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tAns=getans(r);\n\t\n\tfor (int i=1;i<=r;i++) B[q[i].x][q[i].y]=0;\n\tB[xx][yy]=A1.to[A1.next[A1.last[xx*n+yy]]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) if (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tA1.tot=0;\n\tfor (int i=1;i<=r;i++) A1.last[q[i].x*n+q[i].y]=0;\n\t(Ans+=getans(r))%=P;\n\tsi+=s;\n\t(ans=1ll*ans*Ans%P*C(si,s)%P);\n}\ninline void doit() {\n\tjc[0]=1;\n\tfor (int i=1;i<=200000;i++) jc[i]=1ll*jc[i-1]*i%P;\n\tny[200000]=quick(jc[200000],P-2);\n\tfor (int i=199999;i;i--) ny[i]=1ll*ny[i+1]*(i+1)%P;\n\tny[0]=1;\n}\nint main() {\n\tdoit();\n\tans=1; si=0;\n\tscanf(\"%d\",&n);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) fa[i*n+j]=i*n+j;\n\tfor (i=1;i<=2*n;i++) {\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tif (get(a[i].x)!=get(n+a[i].y)) fa[get(a[i].x)]=get(n+a[i].y);\n\t\tGT[0][a[i].x].insert(a[i].y);\n\t\tGT[1][a[i].y].insert(a[i].x);\n\t}\n\tfor (i=1;i<=2*n;i++) if (get(id[i]=i)==i) G[i]=++tot;\n\tfor (i=1;i<=2*n;i++) G[i]=G[get(i)];\n\ttot=0;\n\tsort(id+1,id+1+2*n,cmp);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!GT[i][j].size()) return puts(\"0\"),0;\n\telse if (GT[i][j].size()==1) q[++r].x=i,q[r].y=j;\n\twhile (l<r) {\n\t\t++l;\n\t\tif (!GT[q[l].x][q[l].y].size()) return puts(\"0\"),0;\n\t\tA[q[l].x][q[l].y]=(*GT[q[l].x][q[l].y].begin());\n\t\tGT[q[l].x^1][A[q[l].x][q[l].y]].erase(q[l].y);\n\t\tif (GT[q[l].x^1][A[q[l].x][q[l].y]].size()==1) q[++r].x=q[l].x^1,q[r].y=A[q[l].x][q[l].y];\n\t}\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (A[i][j]) V[i^1][A[i][j]].insert(j);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!vis[i][j]&&GT[i][j].size()==2) \n\twork(i,j);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nconst int N = 5 * 100000 + 100;\nconst int MOD = 1000000007;\nconst int oo = 1e9;\n\nint n , x , y, take[N], in[N], sz[N];\nbool inStack[N], vis[N];\nll fact[N], inv[N];\n\nvector<int> g[N], tree[N], cycle, my;\nstack<int> st;\n\nvoid findCycle(int u , int p) {\n\tif (inStack[u]) {\n\t\twhile (1) {\n\t\t\tcycle.pb(st.top());\n\t\t\tst.pop();\n\t\t\tif (cycle.back() == u)break;\n\t\t}\n\t\tfor (int i = 0; i < cycle.size(); ++i) st.push(cycle[i]);\n\t\treturn;\n\t}\n\tif (vis[u])return;\n\tmy.pb(u);\n\ttake[u] = p;\n\tvis[u] = 1;\n\tinStack[u] = 1;\n\tst.push(u);\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tfindCycle(v, u);\n\t}\n\tinStack[u] = 0;\n\tst.pop();\n}\nbool getType(int idx) {\n\treturn idx > n;\n}\nll fast(ll a , ll b) {\n\tif (!b)return 1ll;\n\tll res = fast(a, b / 2);\n\tres = (res * res) % MOD;\n\tif (b & 1)\n\t\treturn (res * a) % MOD;\n\treturn res;\n}\nll nCk(ll n , ll k) {\n\treturn ((fact[n] * inv[n - k]) % MOD * inv[k]) % MOD;\n}\nll calc(int u) {\n\tsz[u] = 0;\n\tll ans = 1;\n\tfor (int i = 0; i < tree[u].size(); ++i) {\n\t\tint v = tree[u][i];\n\t\tll ff = calc(v);\n\t\tans = (((ans * ff ) % MOD * nCk(sz[u] + sz[v], sz[v])))%MOD;\n\t\tsz[u] += sz[v];\n\t}\n\tsz[u]++;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tg[x + n].pb(y);\n\t\tg[y].pb(x + n);\n\t}\n\tfact[0] = 1;\n\tinv[0] = fast(fact[0], MOD - 2);\n\tfor (int i = 1 ; i <= 2 * n ; ++i) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv[i] = fast(fact[i], MOD - 2);\n\t}\n\tll ans = 1;\n\tint len = 0;\n\tfor (int node = 1 ; node <= 2 * n ; ++node) {\n\t\tif (vis[node])continue;\n\t\tcycle.clear();\n\t\tmy.clear();\n\t\tfindCycle(node, -1);\n\t\tfor (int i = 0; i < my.size(); ++i){\n\t\t\tinStack[my[i]]=vis[my[i]]=0;\n\t\t}\n\t\tif(cycle.size()){\n\t\t\tint root = cycle[0];\n\t\t\tcycle.clear();\n\t\t\tmy.clear();\n\t\t\tfindCycle(root,-1);\n\t\t}\n\t\tint E = 0;\n\t\tfor (int i = 0; i < my.size(); ++i){\n\t\t\tE += g[my[i]].size();\n\t\t}\n\t\tif(E != 2*my.size()){\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tll res = 0;\n\t\tfor (int it = 0; it < 2 ; ++it) {\n\t\t\tfor (int i = 0 ; i < my.size(); ++i){\n\t\t\t\tin[my[i]] = 0;\n\t\t\t\ttree[my[i]].clear();\n\t\t\t}\n\t\t\ttree[0].clear();\n\t\t\tfor (int j = 0 ; j < cycle.size(); ++j) {\n\t\t\t\ttake[cycle[j]] = (it == 0 ? cycle[(j + 1) % cycle.size()] :  cycle[(j - 1 + cycle.size()) % cycle.size()]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size() ; ++i) {\n\t\t\t\tint f = my[i];\n\t\t\t\tfor (int j = 0 ; j < g[f].size(); ++j) {\n\t\t\t\t\tint v = g[f][j];\n\t\t\t\t\tif (getType(take[f]) == getType(v) && v < take[f]) {\n\t\t\t\t\t\ttree[f].pb(v);\n\t\t\t\t\t\tin[v]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size(); ++i) {\n\t\t\t\tif (!in[my[i]]) {\n\t\t\t\t\ttree[0].push_back(my[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = (res + calc(0)) % MOD;\n\t\t}\n\n\t\tans = (ans * res ) % MOD;\n\t\tans = (ans * nCk(len+my.size(),my.size()));\n\t\tlen += my.size();\n\t}\n\tprintf(\"%lld\\n\", ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int N=200005;\nconst int mod=1000000007;\n\nstruct E{\n\tint to,next;\n}mem[N<<1];\nint h,t,num,n,x,y,m,ans,res,sum,ns,siz,ssr;\nint dp[N],sz[N],head[N],tp[N],q[N],fac[N],inv[N],d[N];\nbool vis[N];\n\nvoid addedge(int x,int y){\n\tnum++;\n\tmem[num].to=y; mem[num].next=head[x];\n\thead[x]=num; d[x]++;\n}\n\nint quickpow(int x,int y){\n\tint s=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mod)\n\t\tif (y&1) s=1ll*s*x%mod;\n\treturn s;\n}\n\nvoid init(int n){\n\tint i; fac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=quickpow(fac[n],mod-2);\n\tfor (i=n-1;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int x,int y){\n\tif (x<y) return 0;\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nvoid add(int &x,int y){\n\tx+=y;\n\t(x>=mod)?x-=mod:0;\n}\n\nvoid bfs(int st){\n\tint k,u,j;\n\th=t=0; q[++t]=st;\n\twhile (h<t){\n\t\tk=q[++h]; vis[k]=1;\n\t\tfor (j=head[k];j;j=mem[j].next){\n\t\t\tu=mem[j].to;\n\t\t\tif (!vis[u]){\n\t\t\t\tq[++t]=u; vis[u]=1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid topsort(){\n\tint k,u,j;\n\twhile (h<t){\n\t\tk=tp[++h];\n\t\tfor (j=head[k];j;j=mem[j].next){\n\t\t\tu=mem[j].to; d[u]--;\n\t\t\tif (d[u]==1) tp[++t]=u;\n\t\t}\n\t}\n}\n\nvoid dfs(int k,int pre,int rt){\n\tint u,j; bool tag=0;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre||u==rt) continue;\n\t\tdfs(u,k,rt); tag=1;\n\t}\n\tif (!tag){\n\t\tsz[k]=dp[k]=1;\n\t\treturn;\n\t}\n\tsz[k]=0; dp[k]=1;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre||u==rt) continue;\n\t\tif (u<pre){\n\t\t\tdp[k]=1ll*dp[k]*C(sz[k]+sz[u],sz[u])%mod*dp[u]%mod;\n\t\t\tsz[k]+=sz[u];\n\t\t}\n\t\telse{\n\t\t\tssr=1ll*ssr*C(siz+sz[u],sz[u])%mod*dp[u]%mod;\n\t\t\tsiz+=sz[u];\n\t\t}\n\t}\n\tsz[k]++;\n}\n\nvoid solve(int x,int &res,int &ns){\n\tint i,j,k,st=0;\n\tns=0; res=0;\n\tbfs(x);\n\tns=t; m=0; h=t=0;\n\tfor (i=1;i<=ns;i++){\n\t\tk=q[i];\n\t\tfor (j=head[k];j;j=mem[j].next) m++;\n\t\tif (d[k]==1) tp[++t]=k;\n\t}\n\tif (m/2!=ns) return;\n\ttopsort(); t=0;\n\tfor (i=1;i<=ns;i++)\n\t\tif (d[q[i]]>1&&q[i]>st) st=q[i];\n\tfor (j=head[st];j;j=mem[j].next)\n\t\tif (d[mem[j].to]>1) tp[++t]=mem[j].to;\n\tfor (i=1;i<=t;i++){\n\t\tk=tp[i]; ssr=1; siz=0;\n\t\tdfs(st,k,st);\n\t\tssr=1ll*ssr*C(siz+sz[st],sz[st])%mod*dp[st]%mod;\n\t\tadd(res,ssr);\n\t}\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=2*n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y+n); addedge(y+n,x);\n\t}\n\tinit(n*2);\n\tans=1;\n\tfor (i=1;i<=n;i++)\n\t\tif (!vis[i]){\n\t\t\tsolve(i,res,ns);\n\t\t\tans=1ll*ans*C(sum+ns,ns)%mod*res%mod;\n\t\t\tsum+=ns;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x),z=y;i<z;i++)\nusing namespace std;\nconst int N=200002;\nconst int p=1e9+7;\nint n;\nvector<int> a[N];\n\nvoid read(int &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';\n}\n\nvoid read(LL &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';\n}\n\nLL inv[N];\nvoid init(){\n\tinv[1]=inv[0]=1; //??????\n\tfrl(i,2,N) inv[i]=-p/i*inv[p%i]%p;\n}\n\nint s[N<<1],L;\nint b[N],sz[N];\nvector<int> v;\nint d[N];\nLL sum;\nint predfs(int x,int fa){ //guaguade\n\tb[x]=1;int xx=0;\n\tfrl(i,0,a[x].size())\n\t if (a[x][i]!=fa){\n\t \tint tmp=a[x][i];\n\t \tif (b[tmp]||(xx=predfs(tmp,x))){\n\t \t\ts[++L]=x;\n\t \t\tif (xx==0) return tmp;\n\t \t\treturn x==xx?0:xx;\n\t\t}\n\t }\n\treturn 0;\n}\n\nvoid dfs(int x,int fa){\n\tsz[x]=1;b[x]=1;\n\tfrl(i,0,a[x].size()){\n\t\tint tmp=a[x][i];\n\t\tif (tmp==fa||d[tmp]==-1) continue;\n\t\tdfs(tmp,x);\n\t\tif (tmp<fa) sz[x]+=sz[tmp];\n\t}\n\tif (d[x]!=-1) sum=sum*inv[sz[x]]%p;\n}\n\nLL solve(int u){\n\tL=0;\n\tpredfs(u,0);\n\t/*if (L==0){\n\t\tputs(\"0\");\n\t\texit(0);\n\t}*/\n\tfr(i,1,L) d[s[i]]=-1;\n\tsum=1;fr(i,1,L) dfs(s[i],0);\n\tLL s1=1,s2=1;\n\tfr(i,1,L) s[i+L]=s[i];s[0]=s[L];s[2*L+1]=s[1];\n\tfr(o,1,L)\n\t if (s[o-1]>=s[o+1]){\n\t \tfrl(i,o,o+L)\n\t \t frl(j,0,a[s[i]].size())\n\t \t  if (a[s[i]][j]<s[i+1]) sz[s[i]]+=sz[a[s[i]][j]];\n\t \tfr(i,1,L) s1=s1*inv[sz[s[i]]]%p;\n\t \tbreak;\n\t }\n\tfr(i,1,L) sz[s[i]]=1;\n\trf(o,L<<1,L)\n\t if (s[o+1]>=s[o-1]){\n\t \trf(i,o,o-L+1)\n\t \t frl(j,0,a[s[i]].size())\n\t \t  if (a[s[i]][j]<s[i-1]) sz[s[i]]+=sz[a[s[i]][j]];\n\t \tfr(i,1,L) s2=s2*inv[sz[s[i]]]%p;\n\t \tbreak;\n\t }\n\treturn (s1+s2)*sum%p;\n}\n\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//int n=20;\n\tread(n);\n\tinit();\n\tint x,y;\n\tfr(i,1,n<<1){\n\t\tread(x);read(y);\n\t\ta[x].push_back(y+n);\n\t\ta[y+n].push_back(x);\n\t}\n\t//fr(i,1,n<<1) sort(a[i].begin(),a[i].end());\n\tfr(i,1,n<<1) if (a[i].size()==0) return puts(\"0\"),0;\n\tLL ans=1;\n\tfr(i,1,n<<1)\n\t if (!b[i]) ans=ans*solve(i)%p;\n\tans+=p;ans%=p;\n\tfr(i,1,2*n) ans=ans*i%p;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nchar buf[1 << 20], *p1, *p2;\n#define getchar() ((p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)\n\ntemplate<typename T>\nvoid read(T &x) \n{\n\tx = 0;\n\tint f = 1; char c = getchar();\n\twhile (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }\n\twhile (isdigit(c)) { x = x * 10 + c - 48; c = getchar(); }\n\tx *= f;\n}\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G;\nbool vis[MAXN];\nint edge = 0, s, t;\nvoid GetLoop(int x, int Fa) \n{\n\tG.push_back(x);\n\tvis[x] = true;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (!vis[y]) GetLoop(y, x);\n\t\telse if (y != Fa)\n\t\t\ts = x, t = y;\n\t}\n}\n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[G.size()];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tread(n);\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\ty += n;\n\t\tAdd(x, y), Add(y, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!vis[i])\n\t\t{\n\t\t\tGetLoop(i, 0);\n\t\t\tif (G.size() << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tG.clear();\n\t\t\tedge = 0;\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\n#define dputs(...) fputs(__VA_ARGS__,stderr)\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,fac[N],ifac[N];\nstruct node{int x,y;}ori[N<<1];\ninline int C(int x,int y){\n\tif(x<y) return 0;\n\treturn (ll)fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\ninline bool cmp(node a,node b){return mp(a.x,a.y)<mp(b.x,b.y);}\n\nint tcnt,cnt,root,w,dep[N],fa[N],val[N];\nbool vis[N];\nvector<pii> g[N],seq;\nvoid add(int x,int y,int z){\n//\tdprintf(\"%d %d %d\\n\",x,y,z);\n\tg[x].pb(mp(y,z));g[y].pb(mp(x,z));\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tcnt++;tcnt-=2;\n\tfor(auto i:g[x]){\n\t\ttcnt++;\n\t\tint y=i.FF;\n\t\tif(vis[y]){\n\t\t\tif(dep[y]>dep[x]){\n\t\t\t\tif(~w) continue;\n\t\t\t\tw=i.SS;\n\t\t\t\twhile(y!=x)\n\t\t\t\t\tgmax(w,val[y]),y=fa[y];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tdep[y]=dep[x]+1;fa[y]=x;val[y]=i.SS;\n\t\tdfs(y);\n\t}\n}\ninline pii dfs(int x,int f,int w){\n//\tdprintf(\"%d %d %d\\n\",x,f,w);\n\tint res=1,now=0;\n\tfor(auto i:g[x]){\n\t\tint y=i.FF;\n\t\tif(y==root||y==f) continue;\n\t\tpii t=dfs(y,x,i.SS);\n\t\tif(i.SS>w) seq.pb(t);\n\t\telse{\n\t\t\tnow+=t.SS;\n\t\t\tres=(ll)res*t.FF%mod*C(now,t.SS)%mod;\n\t\t}\n\t}\n\treturn mp(res,now+1);\n}\nint solve(int w,int flag){\n\tint u=ori[w].x,v=ori[w].y+n;\n\tif(flag) swap(u,v);\n\tseq.clear();root=u;\n\tseq.pb(dfs(u,v,w));\n\tint now=0,res=1;\n\tfor(auto i:seq) res=(ll)res*i.FF%mod*C(now+i.SS,i.SS)%mod,now+=i.SS;\n//\tfor(auto i:seq) dprintf(\"%d %d\\n\",i.FF,i.SS);\n//\tdputs(\"\\n\");\n\treturn res;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tn=200000;fac[0]=ifac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=exp(fac[n],mod-2);\n\tfor(int i=n-1;i;i--) ifac[i]=(ll)ifac[i+1]*(i+1)%mod;\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n*2;i++)\n\t\tscanf(\"%d%d\",&ori[i].x,&ori[i].y);\n\tsort(ori+1,ori+n*2+1,cmp);\n\tfor(int i=1;i<=n*2;i++)\n\t\tadd(ori[i].x,ori[i].y+n,i);\n\tint ans=1,now=0;\n\tfor(int i=1;i<=n*2;i++)\n\t\tif(!vis[i]){\n\t\t\tw=-1;tcnt=cnt=0;dfs(i);\n\t\t\tif(tcnt){puts(\"0\");return 0;}\n\t\t\tnow+=cnt;\n//\t\t\tdebug(w);\n\t\t\tans=(ll)ans*(solve(w,0)+solve(w,1))%mod*C(now,cnt)%mod;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge\n{\n\tint s,t,w,n;\n} e[1000000];\n\nint n,h[1000000],fac[1000000],ifac[1000000],vis[1000000],f[1000000],siz[1000000],ecnt,cnt,S,p,ans,res;\n\nint ksm(int a,int b)\n{\n\tint x=a;\n\ta=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\ta=1ll*a*x%1000000007;\n\t\tx=1ll*x*x%1000000007,b>>=1;\n\t}\n\treturn a;\n}\n\nint C(int n,int m)\n{\n\treturn 1ll*fac[n]*ifac[m]%1000000007*ifac[n-m]%1000000007;\n}\n\nvoid dfs(int x,int fa)\n{\n\tvis[x]=1,cnt++;\n\tfor(int i=h[x],y; y=e[i].t,i; ecnt++,i=e[i].n)\n\t\tif(!vis[y])\n\t\t\tf[y]=i,dfs(y,x);\n\t\telse if((y!=fa)&&(!S)) \n\t\t\tS=i;\n}\n\nvoid dfs2(int x,int fe)\n{\n\tsiz[x]=0,f[x]=1;\n\tfor(int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\tif((i!=fe)&&((i^p)>1))\n\t\t{\n\t\t\tdfs2(y,i^1);\n\t\t\tif(e[i].w>e[fe].w)\n\t\t\t\tres=1ll*res*ifac[siz[y]]%1000000007*f[y]%1000000007;\n\t\t\telse\n\t\t\t\tsiz[x]+=siz[y],f[x]=1ll*f[x]*f[y]%1000000007*C(siz[x],siz[y])%1000000007;\n\t\t}\n\tsiz[x]++;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),fac[0]=1;\n\tfor(int i=1; i<=2*n; i++)\n\t\tfac[i]=1ll*fac[i-1]*i%1000000007;\n\tifac[2*n]=ksm(fac[2*n],1000000007-2);\n\tfor(int i=2*n; i; i--)\n\t\tifac[i-1]=1ll*ifac[i]*i%1000000007;\n\tfor(int i=1,x,y,tot=1; i<=2*n; i++)\n\t{\n\t\tscanf(\"%d %d\",&x,&y),y+=n;\n\t\te[++tot]=(edge)\n\t\t{\n\t\t\tx,y,x+y,h[x]\n\t\t};\n\t\th[x]=tot;\n\t\te[++tot]=(edge)\n\t\t{\n\t\t\ty,x,x+y,h[y]\n\t\t};\n\t\th[y]=tot;\n\t}\n\tans=fac[2*n];\n\tfor(int i=1,s; i<=2*n; i++)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tecnt=cnt=S=s=0,dfs(i,0);\n\t\t\tif(cnt!=ecnt/2)\n\t\t\t{\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp=S;\n\t\t\tfor(int j=S; e[j].s!=e[S].t; j=f[e[j].s])\n\t\t\t\tp=(e[p].w<e[j].w?j:p);\n\t\t\tres=1;\n\t\t\tdfs2(e[p].s,p);\n\t\t\ts+=1ll*ifac[siz[e[p].s]]*f[e[p].s]%1000000007*res%1000000007;\n\t\t\tres=1;\n\t\t\tdfs2(e[p].t,p);\n\t\t\ts+=1ll*ifac[siz[e[p].t]]*f[e[p].t]%1000000007*res%1000000007;\n\t\t\tans=1ll*ans*s%1000000007;\n\t\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n神题\n行列建图，转化为环套树问题\n分2种情况讨论，每种情况可转化为内向树上拓扑序计数，树型DP\nO(n)\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 400010\n#define ll long long\n#define mod 1000000007\nusing namespace std;\n\nstruct edge{int x, y, next;}a[N*2], c[N];\nint n, l, p[N], x, y, jc[N], inv[N], l1, w[N], sum_v, sum_e, ans, ff, flag[N], fa[N], b[N], to[N], f1[N],\nans1, q[N], du[N], root, l2, f[N], size[N], sum, l3, d[N];\n\ninline void add(int x, int y){a[++l].x=x; a[l].y=y; a[l].next=p[x]; p[x]=l;}\ninline void dfs_circle(int x){\n\tflag[x]=1; sum_v++; d[++l3]=x;\n\tfor(int i=p[x]; i; i=a[i].next)if(fa[x]!=a[i].y){\n\t\tsum_e++;\n\t\tif(flag[a[i].y]){\n\t\t\tif(ff)continue; ff=1;\n\t\t\tl=1; b[0]=a[i].y; b[1]=x;\n\t\t}else{fa[a[i].y]=x; dfs_circle(a[i].y);}\n\t}\n}\ninline void dfs_tree(int x, int fa){\n\tto[x]=fa;\n\tfor(int i=p[x]; i; i=a[i].next)if(fa!=a[i].y&&!f1[a[i].y])dfs_tree(a[i].y, x);\n}\n\ninline void add1(int x, int y){c[++l2].x=x; c[l2].y=y; c[l2].next=q[x]; q[x]=l2;}\ninline void dp(int x){\n\tsize[x]=1;\n\tfor(int i=q[x]; i; i=c[i].next){dp(c[i].y); size[x]+=size[c[i].y];}\n\tf[x]=jc[size[x]-1];\n\tfor(int i=q[x]; i; i=c[i].next)f[x]=(ll)f[x]*f[c[i].y]%mod*inv[size[c[i].y]]%mod;\n}\ninline int solve(){\n\tl2=0; root=n*2+1; q[root]=0;\n\tfor(int i=1; i<=l3; i++)q[d[i]]=du[d[i]]=0;\n\tint x, y;\n\tfor(int i=1; i<=l3; i++){\n\t\tx=d[i]; y=to[x];\n\t\tfor(int j=p[x]; j; j=a[j].next)if(a[j].y<y){du[a[j].y]++; add1(x, a[j].y);}\n\t}\n\tfor(int i=1; i<=l3; i++)if(!du[d[i]])add1(root, d[i]);\n\tdp(root); return f[root];\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tl=0; memset(p, 0, sizeof(p));\n\tfor(int i=1; i<=n*2; i++){scanf(\"%d%d\", &x, &y); add(x, n+y); add(n+y, x);}\n\tjc[0]=1; for(int i=1; i<=n*2; i++)jc[i]=(ll)jc[i-1]*i%mod;\n\tinv[0]=inv[1]=1; for(int i=2; i<=n*2; i++)inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1; i<=n*2; i++)inv[i]=(ll)inv[i-1]*inv[i]%mod;\n\tmemset(flag, 0, sizeof(flag)); l1=0; ans=1;\n\tmemset(f1, 0, sizeof(f1));\n\tfor(int i=1; i<=n*2; i++)if(!flag[i]){\n\t\tff=sum_v=sum_e=0; fa[i]=0; l3=0; dfs_circle(i); sum_e--;\n\t\tif(sum_v!=sum_e){printf(\"0\"); return 0;}\n\t\tw[++l1]=sum_v;\n\t\tx=b[1]; while(x!=b[0]){x=fa[x]; b[++l]=x;} b[l+1]=b[1];\n\t\tfor(int j=1; j<=l; j++)f1[b[j]]=1;\n\t\tfor(int j=1; j<=l; j++){x=b[j]; dfs_tree(x, 0);}\n\t\tfor(int j=1; j<=l; j++)to[b[j]]=b[j-1]; ans1=solve();\n\t\tfor(int j=1; j<=l; j++)to[b[j]]=b[j+1]; ans1=(ans1+solve())%mod;\n\t\tans=(ll)ans*ans1%mod;\n\t}\n\tsum=0; for(int i=1; i<=l1; i++)sum+=w[i];\n\tans=(ll)ans*jc[sum]%mod;\n\tfor(int i=1; i<=l1; i++)ans=(ll)ans*inv[w[i]]%mod;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,O=1000000007;\ninline int fpow(int x,int n){\n\tint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\nint nlst[N],ns;\nint fac[N],invfac[N];\ninline void gmath(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=(lint)fac[i-1]*i%O;\n\t}\n\tinvfac[n]=inv(fac[n]);\n\tfor(int i=n;i>=1;i--){\n\t\tinvfac[i-1]=(lint)invfac[i]*i%O;\n\t}\n}\nnamespace G{\n\tconst int E=N;\n\tint to[E],bro[E],head[N],e=0;\n\tint size[N],ringe;\n\tint edg[N];\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tvoid getring(int x){\n\t\tnlst[++ns]=x;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])!=edg[x]){\n\t\t\t\tif(edg[v]){\n\t\t\t\t\tif(ringe==-1){\n\t\t\t\t\t\tringe=i;\n\t\t\t\t\t}else if(to[ringe]!=x){\n\t\t\t\t\t\tringe=-2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tedg[v]=x;\n\t\t\t\t\tgetring(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x){\n\t\tsize[x]=1;\n\t\tlint ans=1;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tans=ans*dfs(v)%O;\n\t\t\t\tans=ans*invfac[size[v]]%O;\n\t\t\t\tsize[x]+=size[v];\n\t\t\t}\n\t\t}\n\t\treturn ans*fac[size[x]-1]%O;\n\t}\n}\nint deg[N];\ninline int work2(){\n\tusing namespace G;\n\tfor(int i=1;i<=ns;i++){\n\t\tint x=nlst[i];\n\t\tdeg[x]=0;\n\t}\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tdeg[v]++;\n\t\t\t}\n\t\t}\n\t}\n\tlint ans=fac[ns];\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tif(deg[x]==0){\n\t\t\tans=ans*dfs(x)%O;\n\t\t\tans=ans*invfac[size[x]]%O;\n\t\t}\n\t}\n\treturn ans;\n}\ninline int work(int x){//kind*invfac[n]\n\tusing namespace G;\n\tns=0;\n\tringe=-1;\n\tedg[x]=-1;\n\tgetring(x);\n\tif(ringe<0)return 0;\n\tfor(int p=to[ringe],q=to[ringe^1];~p;swap(edg[p],q),swap(p,q));\n\tint ans=work2();\n\tfor(int p=to[ringe^1],q=to[ringe],tp=p;swap(edg[p],q),swap(p,q),p!=tp;);\n\treturn (lint)invfac[ns]*(ans+work2())%O;\n}\ninline int Main(){\n\tint n=ni,n2=n<<1;\n\tG::init();\n\tfor(int i=1;i<=n2;i++){\n\t\tG::add(ni,n+ni);\n\t}\n\tgmath(n<<1);\n\tlint ans=fac[n<<1];\n\tmemset(G::edg,0,sizeof(G::edg));\n\tfor(int i=1;i<=n2;i++){\n\t\tif(G::edg[i]==0){\n\t\t\t(ans*=work(i))%=O;\n\t\t\tif(ans==0)return 0;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tprintf(\"%d\\n\",Main());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int UF_MAX = 200020;\n\nclass UF{\n\tint x[UF_MAX];\n\tint co;\n\t\npublic:\n\t\n\tUF(){\n\t\tfill(x,x+UF_MAX,-1);\n\t\tco = 0;\n\t}\n\t\n\tint boss(int a){\n\t\tint s = a;\n\t\twhile(x[s] > -1) s = x[s];\n\t\tif(s != a) x[a] = s;\n\t\treturn s;\n\t}\n\t\n\tvoid uni(int a , int b){\n\t\tint s = boss(a);\n\t\tint t = boss(b);\n\t\tif(s != t){\n\t\t\t++co;\n\t\t\tif(x[s] < x[t]){\n\t\t\t\tx[s] += x[t];\n\t\t\t\tx[t] = s;\n\t\t\t} else {\n\t\t\t\tx[t] += x[s];\n\t\t\t\tx[s] = t;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool find(int a , int b){\n\t\treturn boss(a) == boss(b);\n\t}\n\t\n\tint count(){\n\t\treturn co;\n\t}\n\t\n\tint member(int a){\n\t\treturn -x[boss(a)];\n\t}\n} uf;\n\nconst int MC = 100010;\nconst LL mod = 1e9 + 7;\nint N;\nint x[MC*2] , y[MC*2];\nvector<int> V[MC*2];\nvector<int> C[MC*2];\nvector<int> G[MC*2];\nvector<int> rG[MC*2];\nint e[MC*2];\nint al[MC*2];\nint co[MC*2];\nint sz[MC*2];\nLL h[MC*2];\nLL fct[MC];\nLL inv[MC];\nLL ans;\n\nvoid build(){\n\tfct[0] = fct[1] = 1;\n\trepp(i,2,MC){\n\t\tfct[i] = fct[i-1] * i % mod;\n\t}\n\tLL x = fct[MC-1];\n\tinv[MC-1] = 1;\n\tfor(int i = mod - 2 ; i > 0 ; i >>= 1){\n\t\tif(i % 2 == 1) (inv[MC-1] *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t}\n\trepm(i,MC-1,0){\n\t\tinv[i-1] = inv[i] * i % mod;\n\t}\n}\n\nLL fanc(int z){\n\tqueue<int> Q;\n\tLL k = fct[(int)C[z].size()];\n\tfor(auto u : C[z]) rG[u].clear();\n\tfor(auto u : C[z]){\n\t\tG[u].clear();\n\t\tfor(auto w : V[u]){\n\t\t\tif(w == al[u]) break;\n\t\t\tG[u].PB(w);\n\t\t\trG[w].PB(u);\n\t\t}\n\t\tsz[u] = 0;\n\t\th[u] = 1;\n\t\tco[u] = G[u].size();\n\t\tif(co[u] == 0) Q.push(u);\n\t\t//cerr << u << ' ' << al[u] << endl;\n\t}\n\twhile(!Q.empty()){\n\t\tint u = Q.front(); Q.pop();\n\t\tsz[u] = 1;\n\t\tfor(auto w : G[u]){\n\t\t\t(h[u] *= h[w]) %= mod;\n\t\t\t(h[u] *= inv[sz[w]]) %= mod;\n\t\t\tsz[u] += sz[w];\n\t\t}\n\t\t(h[u] *= fct[sz[u]-1]) %= mod;\n\t\t//cerr << u << ' ' << h[u] << ' ' << sz[u] << endl;\n\t\tif(rG[u].size() == 0){\n\t\t\t(k *= h[u]) %= mod;\n\t\t\t(k *= inv[sz[u]]) %= mod;\n\t\t}\n\t\tfor(auto w : rG[u]){\n\t\t\t--co[w];\n\t\t\tif(co[w] == 0) Q.push(w);\n\t\t}\n\t}\n\t//cerr << k << endl;\n\treturn k;\n}\n\nLL calc(int z){\n\tqueue<int> Q;\n\tint t = 0;\n\tfor(auto u : C[z]) if(V[u].size() == 1) Q.push(u);\n\twhile(!Q.empty()){\n\t\tint p = Q.front(); Q.pop();\n\t\tfor(auto u : V[p]){\n\t\t\tif(al[u] == 0){\n\t\t\t\tal[p] = u;\n\t\t\t\t++co[u];\n\t\t\t\t++t;\n\t\t\t\tif(V[u].size() == co[u] + 1) Q.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tint r,s;\n\tfor(auto u : C[z]){\n\t\tif(al[u] == 0){\n\t\t\tr = s = u;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(C[z].size() > t + 1){\n\t\tfor(auto u : V[r]){\n\t\t\tif(al[u] == 0){\n\t\t\t\tal[r] = u;\n\t\t\t\tr = u;\n\t\t\t\t++t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tal[r] = s;\n\tLL rv = fanc(z);\n\tqueue<P2> Q2;\n\tr = s;\n\twhile(Q2.empty() || r != s){\n\t\tQ2.push(MP(al[r],r));\n\t\tr = al[r];\n\t}\n\twhile(!Q2.empty()){\n\t\tal[Q2.front().first] = Q2.front().second;\n\t\tQ2.pop();\n\t}\n\treturn (rv + fanc(z)) % mod;\n}\n\nint main(){\n\tbuild();\n\tcin >> N;\n\trepp(i,0,2*N){\n\t\tcin >> x[i] >> y[i];\n\t\tV[x[i]].PB(MC+y[i]);\n\t\tV[MC+y[i]].PB(x[i]);\n\t\tuf.uni(x[i],MC+y[i]);\n\t}\n\trepp(i,1,N+1){\n\t\tC[uf.boss(i)].PB(i);\n\t\te[uf.boss(i)] += V[i].size();\n\t\tC[uf.boss(MC+i)].PB(MC+i);\n\t\te[uf.boss(MC+i)] += V[MC+i].size();\n\t\tsort(V[i].begin(),V[i].end());\n\t\tsort(V[MC+i].begin(),V[MC+i].end());\n\t}\n\tans = fct[2*N];\n\trepp(i,1,N+1){\n\t\tif(uf.boss(i) == i){\n\t\t\tif(C[i].size() * 2 != e[i]){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t(ans *= calc(i)) %= mod;\n\t\t\t(ans *= inv[(int)C[i].size()]) %= mod;\n\t\t}\n\t\tif(uf.boss(MC+i) == MC+i){\n\t\t\tif(C[MC+i].size() * 2 != e[MC+i]){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t(ans *= calc(MC+i)) %= mod;\n\t\t\t(ans *= inv[(int)C[MC+i].size()]) %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define pb push_back\n\nconst int N=2e5+5,D=1e9+7;\nll mi(ll x,int y=D-2)\n{\n\tll ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ans=ans*x%D;\n\t\tx=x*x%D;y>>=1;\n\t}\n\treturn ans;\n}\nvector<int>lk[N];\nbool vis[N];\nll jie[N];\n\nint du[N],fa[N],sz[N];\nint q[N],tail,nq[N];\ninline bool link_fa(int x)\n{\n\treturn x<fa[fa[x]];\n}\nll solve(int rt)\n{\n\ttail=1;\n\tq[1]=rt;\n\tvis[rt]=1;\n\trep(head,1,tail)\n\t{\n\t\tint x=q[head];\n\t\tdu[x]=0;sz[x]=1;fa[x]=0;\n\t\tfor(auto y:lk[x])\n\t\tif(!vis[y])\n\t\t{\n\t\t\tq[++tail]=y;\n\t\t\tvis[y]=1;\n\t\t}\n\t}\n\tint ecnt=0;\n\trep(head,1,tail)\n\t{\n\t\tint x=q[head];\n\t\tfor(auto y:lk[x])\n\t\t{\n\t\t\t++du[y];\n\t\t\t++ecnt;\n\t\t}\n\t}\n\tecnt/=2;\n\tif(ecnt!=tail)return 0;\n\tint nq_tail=0;\n\trep(head,1,tail)\n\t{\n\t\tint x=q[head];\n\t\tif(du[x]==1)nq[++nq_tail]=x;\n\t}\n\trep(head,1,nq_tail)\n\t{\n\t\tint x=nq[head];\n\t\tfor(auto y:lk[x])\n\t\tif(--du[y]>0)\n\t\t{\n\t\t\tfa[x]=y;\n\t\t\tif(du[y]==1)nq[++nq_tail]=y;\n\t\t}\n\t}\n\trep(head,1,tail)\n\t{\n\t\tint x=q[head];\n\t\tif(du[x]>1)\n\t\t{\n\t\t\trt=x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int x=rt;;)\n\t{\n\t\tfor(auto y:lk[x])\n\t\tif(du[y]>1&&fa[y]!=x)\n\t\t{\n\t\t\tfa[x]=y;\n\t\t\tx=y;\n\t\t\tbreak;\n\t\t}\n\t\tif(x==rt)break;\n\t}\n//\tcerr<<tail<<\" \"<<nq_tail<<endl;\n//\trep(i,1,8)cerr<<fa[i]<<\" \";cerr<<endl;\n\tll ans=1;\n\trep(head,1,nq_tail)\n\t{\n\t\tint x=nq[head];\n\t\tif(!link_fa(x))(ans*=mi(sz[x]))%=D; \n\t\telse \n\t\t{\n\t\t\t(ans*=mi(sz[x]))%=D;\n\t\t\tsz[fa[x]]+=sz[x];\n\t\t}\n\t}\n\tfor(int x=rt;;)\n\t{\n\t\tif(!link_fa(x))\n\t\t{\n\t\t\trt=fa[x];\n\t\t\tbreak;\n\t\t}\n\t\tx=fa[x];\n\t\tif(x==rt)return 0;\n\t}\n\tfor(int x=rt;;)\n\t{\n\t\tif(!link_fa(x))(ans*=mi(sz[x]))%=D; \n\t\telse \n\t\t{\n\t\t\t(ans*=mi(sz[x]))%=D;\n\t\t\tsz[fa[x]]+=sz[x];\n\t\t}\n\t\tx=fa[x];\n\t\tif(x==rt)break;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,1,n*2)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ty+=n;\n\t\tlk[x].pb(y);lk[y].pb(x);\n\t}\n\tjie[0]=1;\n\trep(i,1,n*2)jie[i]=jie[i-1]*i%D;\n\t\n\tll ans=jie[n*2];\n\trep(x,1,n*2)\n\tif(!vis[x])\n\t{\n\t\tll s=solve(x);\n\t\trep(head,1,tail)\n\t\t{\n\t\t\tint x=q[head];\n\t\t\tvis[x]=0;\n\t\t\treverse(lk[x].begin(),lk[x].end());\n\t\t}\n\t\t(ans*=s+solve(x))%=D;\n\t}\n\t\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=4e5+10;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nconst int mod=1e9+7;\nint fac[N],inv[N],e[N];\nint head[N],nxt[N],to[N],w[N];\nint siz[N],ans,f[N],V,E,C;\nbool vis[N];\ninline int binom(int n,int m) { return 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod; }\ninline void dfs(int k,int fa) {\n\tvis[k]=true;V++;\n\tfor (int i=head[k];i;i=nxt[i],E++)\n\t\tif (!vis[to[i]])\n\t\t\te[to[i]]=i^1,dfs(to[i],k);\n\t\telse if (to[i]!=fa) C=i;\n}\ninline void dp(int k,int e) {\n\tf[k]=1;siz[k]=0;\n\tfor (int i=head[k];i;i=nxt[i])\n\t\tif (i/2!=C/2&&(i^1^e)) {\n\t\t\tdp(to[i],i);\n\t\t\tif (w[i]>w[e])\n\t\t\t\tans=1LL*ans*inv[siz[to[i]]]%mod*f[to[i]]%mod;\n\t\t\telse\n\t\t\t\tf[k]=1LL*f[k]*f[to[i]]%mod*binom(siz[k]+=siz[to[i]],siz[to[i]])%mod;\n\t\t}\n\tsiz[k]++;\n}\nint main()\n{\n\tint n=gi()*2,i,tot=1,a,b,sum,k;\n\t\n\tfor (i=fac[0]=1;i<=n;i++) fac[i]=1LL*fac[i-1]*i%mod;\n\tfor (i=2,inv[0]=inv[1]=1;i<=n;i++) inv[i]=mod-1LL*(mod/i)*inv[mod%i]%mod;\n\tfor (i=3;i<=n;i++) inv[i]=1LL*inv[i]*inv[i-1]%mod;\n\t\n\tfor (i=1;i<=n;i++) {\n\t\ta=gi(),b=gi()+n/2;\n\t\tto[++tot]=b,nxt[tot]=head[a],head[a]=tot;\n\t\tto[++tot]=a,nxt[tot]=head[b],head[b]=tot;\n\t\tw[tot]=w[tot^1]=a+b;\n\t}\n\n\tint res=fac[n];\n\tfor (k=1;k<=n;k++)\n\t\tif (!vis[k]) {\n\t\t\tV=E=C=0;\n\t\t\tdfs(k,0);\n\t\t\tif (V*2!=E) return puts(\"0\"),0;\n\t\t\tfor (a=to[C],b=to[C^1];a!=b;a=to[e[a]]) if (w[e[a]]>w[C]) C=e[a];\n\t\t\tans=1;\n\t\t\tdp(to[C],C);\n\t\t\tsum=1LL*ans*inv[siz[to[C]]]%mod*f[to[C]]%mod;\n\t\t\tans=1;\n\t\t\tdp(to[C^1],C);\n\t\t\tsum=(sum+1LL*ans*inv[siz[to[C^1]]]%mod*f[to[C^1]])%mod;\n\t\t\tres=1LL*res*sum%mod;\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\ninline void down(int &x,const int &y){if(x>y)x=y;}\nconst ll Mod = 1e9+7;\nconst int maxn = 410000;\n\nll pw(ll x,int k)\n{\n\tll re=1ll;\n\tfor(;k;k>>=1,x=x*x%Mod) if(k&1)\n\t\tre=re*x%Mod;\n\treturn re;\n}\nint n;\nll s[maxn],sN[maxn];\nvoid pre()\n{\n\ts[0]=1ll;\n\tfor(int i=1;i<=2*n;i++) s[i]=s[i-1]*(ll)i%Mod;\n\tsN[n<<1]=pw(s[n<<1],Mod-2);\n\tfor(int i=2*n-1;i>=0;i--) sN[i]=sN[i+1]*(ll)(i+1)%Mod;\n}\nll C(const int i,const int j){return s[i]*sN[j]%Mod*sN[i-j]%Mod;}\n\nstruct edge{int y,nex;}a[maxn<<1]; int len,fir[maxn];\ninline void ins(const int x,const int y){a[++len]=(edge){y,fir[x]};fir[x]=len;}\nstruct E{int y,c;};\ninline bool operator <(const E x,const E y){return x.c<y.c;}\nvector<E>V[maxn];\n\nint nt[maxn],t[maxn],tp,tn,en;\nint dfn[maxn],low[maxn],id;\nint cir[maxn],cnt; bool inc[maxn];\nvoid tarjan(const int x,const int fa)\n{\n\tdfn[x]=low[x]=++id; t[++tp]=x;\n\tnt[++tn]=x; en+=V[x].size();\n\tfor(int i=0;i<V[x].size();i++)\n\t{\n\t\tint y=V[x][i].y; if(y==fa) continue;\n\t\tif(!dfn[y]) \n\t\t{\n\t\t\ttarjan(y,x);\n\t\t\tif(low[y]==dfn[x])\n\t\t\t{\n\t\t\t\tcnt=0;\n\t\t\t\tint la=0;\n\t\t\t\twhile(la!=x)\n\t\t\t\t\tinc[cir[++cnt]=la=t[tp--]]=true;\n\t\t\t}\n\t\t\telse if(low[y]>dfn[x]) tp--;\n\t\t\tdown(low[x],low[y]);\n\t\t}\n\t\telse down(low[x],dfn[y]);\n\t}\n}\nint match[maxn];\nvoid divide(const int x,const int fa)\n{\n\tfor(int i=0;i<V[x].size();i++)\n\t{\n\t\tint y=V[x][i].y; if(inc[y]||y==fa)continue;\n\t\tmatch[y]=x;\n\t\tdivide(y,x);\n\t}\n}\nll f[maxn]; int siz[maxn];\nvoid dp(const int x)\n{\n\tsiz[x]=0;\n\tf[x]=1ll;\n\tfor(int k=fir[x],y=a[k].y;k;k=a[k].nex,y=a[k].y)\n\t{\n\t\tdp(y);\n\t\tf[x]=f[x]*f[y]%Mod*C((siz[x]+=siz[y]),siz[y])%Mod;\n\t}\n\tsiz[x]++;\n}\nint In[maxn];\nll count()\n{\n\tlen=0; for(int i=1,x=nt[i];i<=tn;i++,x=nt[i]) fir[x]=In[x]=siz[x]=0;\n\tfor(int i=1,x=nt[i];i<=tn;i++,x=nt[i])\n\t{\n\t\tfor(int j=0;j<V[x].size()&&V[x][j].y!=match[x];j++)\n\t\t\tins(x,V[x][j].y),In[V[x][j].y]++;\n\t}\n\tll ret=1; int sn=0;\n\tfor(int i=1,x=nt[i];i<=tn;i++,x=nt[i]) if(!In[x])\n\t{\n\t\tdp(x);\n\t\tret=ret*f[x]%Mod*C((sn+=siz[x]),siz[x]);\n\t}\n\treturn ret;\n}\nll re;\nvoid solve(const int i)\n{\n\tre=0;\n\ttn=en=0; tarjan(i,0); en>>=1;\n\tif(tn!=en) {re=0; return;}\n\tfor(int i=1;i<=cnt;i++) divide(cir[i],0);\n\tfor(int i=1;i<=cnt;i++) match[cir[i]]=i-1>0?cir[i-1]:cir[cnt];\n\tre+=count();\n\tfor(int i=1;i<=cnt;i++) match[cir[i]]=i+1<=cnt?cir[i+1]:cir[1];\n\tre+=count();\n}\n\nll ans; int nown;\nint main()\n{\n\tscanf(\"%d\",&n); pre();\n\tfor(int i=1;i<=2*n;i++)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tV[x].push_back((E){n+y,x+y});\n\t\tV[n+y].push_back((E){x,x+y});\n\t}\n\tfor(int i=1;i<=2*n;i++)\n\t\tsort(V[i].begin(),V[i].end());\n\t\n\tnown=0; ans=1ll;\n\tfor(int i=1;i<=n;i++) if(!dfn[i])\n\t{\n\t\tsolve(i);\n\t\tif(!re) {ans=0; break;}\n\t\tans=ans*re%Mod*C(nown+tn,tn)%Mod;\n\t\tnown+=tn;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 1e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = 0);\n\t\tif (!findcr) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\t// assert(SZ(cir) > 1);\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) ideg[u] = 0;\n\t\tfor (auto u : gt) {\n\t\t\tT[u].clear();\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tauto lim = UB(DT[u], in[u]); \n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v]) {\t// find it!\n\t\t\twhile (top && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); if (top) --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tSCir(v, u);\n\t\tif (findcr) return;\n\t} if (top && S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n;\n\nint H(int x,int y){return x*n+y;}\n\nstruct side{\n  int y,next;\n}e[N*8+9];\nint lin[2][N*2+9],cs;\n\nvoid Ins(int id,int x,int y){e[++cs].y=y;e[cs].next=lin[id][x];lin[id][x]=cs;}\nvoid Ins2(int id,int x,int y){Ins(id,x,y);Ins(id,y,x);}\n\nvoid into(){\n  scanf(\"%d\",&n);\n  cs=1;\n  for (int i=1;i<=n<<1;++i){\n\tint x,y;\n\tscanf(\"%d%d\",&x,&y);\n\tIns2(0,H(0,x),H(1,y));\n  }\n}\n\nint inv[N*2+9],fac[N*2+9],ifac[N*2+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n<<1;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint a[N*2+9],vis[N*2+9],ca;\nint st,td,ce;\n\nvoid Dfs_a(int k,int fa){\n  a[++ca]=k;vis[k]=1;\n  for (int i=lin[0][k];i;i=e[i].next){\n\t++ce;\n\tif (!vis[e[i].y]) Dfs_a(e[i].y,k);\n    else if (e[i].y^fa) st=k,td=e[i].y;\n  }\n}\n\nint pre[N*2+9];\n\nvoid Dfs_pre(int k,int fa){\n  for (int i=lin[0][k];i;i=e[i].next)\n\tif (e[i].y^fa&&e[i].y^st){\n\t  pre[e[i].y]=k;\n\t  Dfs_pre(e[i].y,k);\n\t}\n}\n\nint siz[N*2+9];\n\nvoid Dfs_siz(int k,int fa){\n  siz[k]=1;\n  for (int i=lin[1][k];i;i=e[i].next)\n\tif (e[i].y^fa){\n\t  Dfs_siz(e[i].y,k);\n\t  siz[k]+=siz[e[i].y];\n\t}\n}\n\nint deg[N*2+9];\n\nint Get_ans0(){\n  int res=fac[ca];\n  Dfs_pre(st,td);\n  pre[st]=td;\n  for (int i=1;i<=ca;++i) lin[1][a[i]]=0,deg[a[i]]=0;\n  for (int i=1;i<=ca;++i){\n\tint t=a[i];\n\tfor (int j=lin[0][i];j;j=e[j].next)\n\t  if (e[j].y<pre[i]) Ins(1,i,e[j].y),++deg[e[j].y];\n  }\n  for (int i=1;i<=ca;++i)\n\tif (!deg[a[i]]) Dfs_siz(a[i],0);\n  for (int i=1;i<=ca;++i) smul(res,inv[siz[a[i]]]);\n  return res;\n}\n\nint ans;\n\nvoid Get_ans(){\n  ans=fac[n<<1];\n  for (int i=1;i<=n<<1;++i)\n\tif (!vis[i]){\n\t  ca=ce=0;\n\t  Dfs_a(i,0);\n\t  if (ca<<1^ce) {ans=0;return;}\n\t  smul(ans,ifac[ca]);\n\t  int now=Get_ans0();\n\t  swap(st,td);\n\t  smul(ans,add(now,Get_ans0()));\n\t}\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    UnionFind(int);\n    int find(int);\n    void unite(int, int);\nprivate:\n    vector<int> table;\n};\n\nUnionFind::UnionFind(int size) {\n    table.resize(size);\n    fill(table.begin(), table.end(), -1);\n}\n\nint UnionFind::find(int x) {\n    while (0 <= table[x])\n        x = table[x];\n    return x;\n}\n\nvoid UnionFind::unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry) {\n        int dx = -table[rx];\n        int dy = -table[ry];\n        if (dx != dy) {\n            if (dx < dy) {\n                table[rx] = ry;\n            } else {\n                table[ry] = rx;\n            }\n        } else {\n            table[rx] -= 1;\n            table[ry] = rx;\n        }\n    }\n}\n\n\nconst long M = 1e9 + 7;\nint N;\nlong F[202020];\nint groups[202020];\nint pair_table[202020];\nint counts[202020];\nlong perms[202020];\nvector< vector<int> > edges;\nvector<bool> is_root;\n\n\nlong powmod(long a, long x, long m) {\n    long r = 1;\n    while (0 < x) {\n        if (x & 1) {\n            r *= a;\n            r %= m;\n        }\n        x >>= 1;\n        a *= a;\n        a %= m;\n    }\n    return r;\n}\n\n\nvoid calc_node(int node, const vector< vector<int> > &tree) {\n    if (tree[node].size() == 0) {\n        counts[node] = 1;\n        perms[node] = 1;\n    } else {\n        int c;\n        \n        c = 0;\n        for (int child : tree[node]) {\n            calc_node(child, tree);\n            c += counts[child];\n        }\n        counts[node] = c + 1;\n\n        long p;\n\n        p = F[c];\n        for (int child : tree[node]) {\n            p *= powmod(F[counts[child]], M - 2, M);\n            p %= M;\n            p *= perms[child];\n            p %= M;\n        }\n        perms[node] = p;\n    }\n}\n\nlong calc(const vector<int> &nodes) {\n    vector< vector<int> > tree;\n    int nv, nnv;\n    int c;\n    long p;\n\n    fill(is_root.begin(), is_root.end(), true);\n    tree.resize(2 * N);\n\n    for (int v : nodes) {\n        nv = pair_table[v];\n        nnv = pair_table[nv];\n        if (v < nnv) {\n            is_root[v] = false;\n            tree[nv].push_back(v);\n        }\n    }\n\n    c = 0;\n    for (int v : nodes) {\n        if (is_root[v]) {\n            calc_node(v, tree);\n            c += counts[v];\n        }\n    }\n\n    p = F[c];\n    for (int v : nodes) {\n        if (is_root[v]) {\n            p *= powmod(F[counts[v]], M - 2, M);\n            p %= M;\n            p *= perms[v];\n            p %= M;\n        }\n    }\n\n    return p;\n}\n\n\n\nlong solve(const vector<int> &nodes) {\n    int pv, nv;\n\n    for (int v : nodes) {\n        if (edges[v].size() == 1) {\n            nv = edges[v].back();\n            edges[v].pop_back();\n            pair_table[v] = nv;\n            edges[nv].erase(find(edges[nv].begin(), edges[nv].end(), v));\n            pv = v; v = nv;\n            while (edges[v].size() == 1) {\n                nv = edges[v].back();\n                edges[v].pop_back();\n                pair_table[v] = nv;\n                edges[nv].erase(find(edges[nv].begin(), edges[nv].end(), v));\n                pv = v; v = nv;\n            }\n        }\n    }\n\n    int v0 = 0;\n    int v1, v2;\n    for (int v : nodes) {\n        if (edges[v].size() != 0) {\n            v0 = v;\n            break;\n        }\n    }\n    v1 = edges[v0][0];\n    v2 = edges[v0][1];\n\n    long r = 0;\n    int v;\n    int nv0, nv1, nv2;\n    rep(d, 0, 2) {\n        nv0 = (d == 0) ? v1 : v2;\n        nv = nv0; v = v0;\n        pair_table[v] = nv;\n        pv = v; v = nv;\n        while (v != v0) {\n            nv1 = edges[v][0];\n            nv2 = edges[v][1];\n            nv = (nv1 != pv) ? nv1 : nv2;\n            pair_table[v] = nv;\n            pv = v; v = nv;\n        }\n        r += calc(nodes);\n        r %= M;\n    }\n\n    return r;\n}\n\n\nint main(int argc, const char * argv[]) {\n    vector< tuple<int, int> > balls;\n    int x, y;\n\n    cin >> N;\n    rep(i, 0, 2 * N) {\n        cin >> x >> y;\n        balls.push_back(make_tuple(x - 1, N + y - 1));\n    }\n\n    {\n        long p = 1;\n        rep(i, 1, 2 * N + 1) {\n            p *= i;\n            p %= M;\n            F[i] = p;\n        }\n    }\n\n    UnionFind uf(2 * N);\n    edges.resize(2 * N);\n    is_root.resize(2 * N);\n\n    for (tuple<int, int> t : balls) {\n        int x = get<0>(t);\n        int y = get<1>(t);\n        uf.unite(x, y);\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n\n    long ans = F[2 * N];\n    vector<int> nodes;\n    unsigned long num_nodes, num_edges;\n\n    \n    rep(i, 0, 2 * N) {\n        if (edges[i].empty()) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n\n    rep(i, 0, 2 * N) groups[i] = uf.find(i);\n    \n    rep(i, 0, 2 * N) {\n        if (groups[i] == i) {\n            nodes.clear();\n            rep(v, 0, 2 * N) {\n                if (groups[v] == i) {\n                    nodes.push_back(v);\n                }\n            }\n            num_nodes = nodes.size();\n            num_edges = 0;\n            for (int v : nodes) {\n                num_edges += edges[v].size();\n            }\n            num_edges /= 2;\n            if (num_nodes != num_edges) {\n                cout << 0 << endl;\n                return 0;\n            }\n            ans *= powmod(F[num_nodes], M - 2, M);\n            ans %= M;\n            ans *= solve(nodes);\n            ans %= M;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1000000 + 10;\nconst int MOD = 1000000007;\n\ninline int inc(int a, int b) { return (a + b >= MOD) ? (a + b - MOD) : (a + b); }\ninline int dec(int a, int b) { return (a >= b) ? (a - b) : (a + MOD - b); }\ninline int mul(int a, int b) { return 1LL * a * b % MOD; }\n\ninline int power(int x, int k) {\n  int tmp = 1;\n  while(k) {\n    if(k & 1) tmp = mul(tmp,x);\n    x = mul(x,x);\n    k >>= 1;\n\t}\n\treturn tmp;\n}\n\nint n, fac[maxn << 1], invfac[maxn << 1], inv[maxn << 1];\nstruct enode{\n  int v, n;\n  enode() {}\n  enode(int _v, int _n):v(_v), n(_n) {}\n};\n\nnamespace topo{\n\nvector<int> g[maxn << 1], p;\nint d[maxn << 1], vis[maxn << 1], sz[maxn];\n\ninline void init() {\n  p.clear();\n  memset(d,0,sizeof(d));\n}\n\ninline void addedge(int u, int v) { g[u].push_back(v); d[v] ++; }\n\nint dfs(int u, int fa) {\n\tvis[u] = 1;\n\tint tmp = 1, Sz = g[u].size(); sz[u] = 1;\n  for(int i = 0;i < Sz;i ++) {\n    int v = g[u][i];\n    if(v == fa || vis[v]) continue;\n    int now = dfs(v,u);\n    tmp = mul(tmp,now);\n    sz[u] += sz[v];\n\t}\n\ttmp = mul(tmp,inv[sz[u]]);\n\treturn tmp;\n}\n\ninline int solve() {\n\tint k = -1;\n\tint Sz = p.size();\n\tint Ans = 1;\n\tfor(int i = 0;i < Sz;i ++) {\n\t\tint u = p[i];\n\t  if(!d[u] && !vis[u]) {\n\t  \tint tmp = dfs(u,0);\n\t\t  Ans = mul(Ans,tmp);\n\t\t}\n\t}\n\tfor(int i = 0;i < Sz;i ++) {\n\t  int u = p[i];\n\t  d[u] = vis[u] = 0;\n\t  g[u].clear();\n\t}\n\treturn Ans;\n}\n\n}\n\nnamespace g{\n\nint h[maxn << 1], cnt, vis[maxn << 1];\nint Ecnt, Pcnt, found, in[maxn << 1], cir[maxn << 1], stk[maxn << 1], top;\nint bl[maxn << 1];\nenode e[maxn << 2];\n\ninline void init() {\n  cnt = 0;\n  memset(in,0,sizeof(in));\n  memset(h,-1,sizeof(h));\n  memset(vis,0,sizeof(vis));\n}\n\ninline void addedge(int u, int v) {\n//\tcout << \"g \" << u << ' ' << v << endl;\n  cnt ++; e[cnt] = enode(v,h[u]); h[u] = cnt;\n}\n\nvoid dfs(int u, int fa) {\n\tPcnt ++; \n\tvis[u] = 1;\n\tstk[++ top] = u;\n  for(int i = h[u];~ i;i = e[i].n) {\n    int v = e[i].v, p;\n    if(v == fa || in[v]) continue;\n//    cout << \"E \" << u << ' ' << v << endl;\n    Ecnt ++;\n    if(!found && vis[v]) {\n    \twhile(stk[top] != v) {\n    \t  p = stk[top --];\n    \t  in[p] = 1;\n    \t  cir[++ cir[0]] = p;\n\t\t\t}\n\t\t\tp = stk[top --];\n\t\t\tin[p] = 1;\n\t\t\tcir[++ cir[0]] = p;\n\t\t\tfound = 1;\n    }\n    if(!vis[v]) dfs(v,u);\n\t}\n\tif(top && stk[top] == u) top --;\n}\n\nvoid dfs1(int u, int fa) {\n  for(int i = h[u];~ i;i = e[i].n) {\n    int v = e[i].v;\n    if(v == fa || in[v]) continue;\n    bl[v] = u;\n    dfs1(v,u);\n\t}\n}\n\nvoid dfs2(int u, int fa) {\n  int ch = bl[u];\n  topo::p.push_back(u);\n  for(int i = h[u];~ i;i = e[i].n) {\n    int v = e[i].v;\n    if(v >= ch) continue;\n    topo::addedge(u,v);\n\t}\n\tfor(int i = h[u];~ i;i = e[i].n) {\n\t  int v = e[i].v;\n\t  if(v == fa || in[v]) continue;\n\t  dfs2(v,u);\n\t}\n}\n\ninline int work(int u) {\n\tEcnt = 0; Pcnt = 0;\n\tcir[0] = 0; top = 0;\n\tfound = 0;\n\tdfs(u,0);\n\tif(Pcnt != Ecnt) return 0;\n\tfor(int i = 1;i <= cir[0];i ++) {\n\t  dfs1(cir[i],0);\n\t}\n\tint tmp = 0;\n\t//1\n\ttopo::init();\n\tfor(int i = 1;i <= cir[0];i ++) {\n\t  int u = cir[i];\n\t  int v = cir[i % cir[0] + 1];\n\t  bl[u] = v;\n\t}\n\tfor(int i = 1;i <= cir[0];i ++) \n\t  dfs2(cir[i],0);\n\ttmp = inc(tmp,topo::solve());\n\t\n\t//2\n\ttopo::init();\n\tfor(int i = 1;i <= cir[0];i ++) {\n\t  int u = cir[i];\n\t  int v = cir[i % cir[0] + 1];\n\t  bl[v] = u;\n\t}\n\tfor(int i = 1;i <= cir[0];i ++)\n\t  dfs2(cir[i],0);\n\ttmp = inc(tmp,topo::solve());\n\treturn tmp;\n}\n\ninline void solve() {\n\tint Ans = 1;\n\tfor(int i = 1;i <= n;i ++) {\n\t  if(!vis[i]) {\n\t  \tint tmp = work(i);\n\t  \tif(!tmp) {\n\t  \t  puts(\"0\");\n\t  \t  return;\n\t\t\t}\n\t\t\tAns = mul(Ans,tmp);\n\t\t}\n\t}\n\tAns = mul(Ans,fac[n]);\n\tprintf(\"%d\\n\", Ans);\n}\n\n}\n\ninline void prepare(int n) {\n  fac[0] = 1; invfac[0] = 1;\n  for(int i = 1;i <= n;i ++) fac[i] = mul(fac[i - 1],i);\n  invfac[n] = power(fac[n],MOD - 2);\n  for(int i = n - 1;i >= 1;i --) invfac[i] = mul(i + 1,invfac[i + 1]);\n  inv[0] = 1; inv[1] = 1;\n  for(int i = 2;i <= n;i ++) inv[i] = mul(dec(MOD,MOD / i),inv[MOD % i]);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tprepare(2000000);\n\tg::init();\n\ttopo::init();\n\tfor(int i = 1;i <= 2 * n;i ++) {\n\t  int x, y;\n\t  scanf(\"%d%d\", &x, &y);\n\t  g::addedge(x,y + n);\n\t  g::addedge(y + n,x);\n\t}\n\tn <<= 1;\n\tg::solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\nconst int MAXN = (int) 2e5;\n\nint n;\n\nint x[MAXN + 5], y[MAXN + 5];\n\nvector<pii> adj[MAXN * 2 + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= 2 * n; ++i)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\t\tadj[u].emplace_back(n + v, u + v);\n\t\tadj[n + v].emplace_back(u, u + v);\n\t}\n}\n\nint dfn[MAXN * 2 + 5], dfn_cur = 0, edge_cnt = 0;\nvector<int> stk, P;\n\nint cir[MAXN * 2 + 5], len = 0;\n\ninline void dfs_cir(int u, int fa)\n{\n\tP.push_back(u);\n\tdfn[u] = ++dfn_cur;\n\n\tstk.push_back(u);\n\tfor(auto it : adj[u])\n\t{\n\t\tint v = it.fst;\n\t\t++edge_cnt;\n\t\tif(v != fa)\n\t\t{\n\t\t\tif(!dfn[v]) dfs_cir(v, u);\n\t\t\telse if(len == 0 && dfn[u] > dfn[v])\n\t\t\t{\n\t\t\t\tfor(int i = SZ(stk) - 1; stk[i] != v; --i) cir[++len] = stk[i];\n\t\t\t\tcir[++len] = v;\n\t\t\t}\n\t\t}\n\t}\n\tstk.pop_back();\n}\n\nint is_cir[MAXN * 2 + 5];\nint w[MAXN * 2 + 5];\n\ninline void dfs_w(int u, int fa)\n{\n\tfor(auto it : adj[u])\n\t{\n\t\tint v = it.fst;\n\t\tif(!is_cir[v] && v != fa) w[v] = it.snd, dfs_w(v, u);\n\t}\n}\n\nnamespace MATH\n{\n\tinline int fpm(int x, int y)\n\t{\n\t\tint res = 1;\n\t\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\t\treturn res;\n\t}\n\n\tint fac[MAXN * 2 + 5], ifac[MAXN * 2 + 5];\n\n\tinline int C(int N, int M) { return N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n\n\tinline void init(int N)\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= N; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[N] = fpm(fac[N], MOD - 2);\n\t\tfor(int i = N - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n}\nusing MATH::C;\n\nvector<int> sub[MAXN * 2 + 5];\nint fa[MAXN + 5];\n\nint f[MAXN + 5], size[MAXN + 5];\n\ninline void dfs_ans(int u)\n{\n\tf[u] = 1, size[u] = 1;\n\tfor(auto v : sub[u]) if(v != fa[u])\n\t{\n\t\tdfs_ans(v);\n\t\tf[u] = (LL) f[u] * C(size[u] - 1 + size[v], size[v]) % MOD * f[v] % MOD;\n\t\tsize[u] += size[v];\n\t}\n}\n\ninline int calc()\n{\n\tsub[0].clear();\n\tfor(auto i : P) fa[i] = 0, sub[i].clear();\n\n\tfor(auto u : P)\n\t\tfor(auto it : adj[u])\n\t\t{\n\t\t\tint v = it.fst, w0 = it.snd;\n\t\t\tif(w0 < w[u]) fa[v] = u, sub[u].push_back(v);\n\t\t}\n\tfor(auto i : P) if(fa[i] == 0) sub[0].push_back(i);\n\n\tdfs_ans(0);\n\treturn f[0];\n}\n\ninline void solve()\n{\n\tint ans = 1, sz = 0;\n\tfor(int rt = 1; rt <= 2 * n; ++rt) if(!dfn[rt])\n\t{\n\t\tP.clear(), stk.clear();\n\t\tdfn_cur = 0, edge_cnt = 0;\n\t\tlen = 0, dfs_cir(rt, 0);\n\t\tedge_cnt /= 2;\n\t\tif(dfn_cur != edge_cnt) { puts(\"0\"); return; }\n\n\t\tfor(int i = 1; i <= len; ++i) is_cir[cir[i]] = 1;\n\t\tfor(int i = 1; i <= len; ++i) dfs_w(cir[i], 0);\n\n\t\tMATH::init(2 * n);\n\n\t\tfor(int i = 1; i <= len; ++i)\n\t\t{\n\t\t\tint u = cir[i];\n\t\t\tfor(auto it : adj[u]) if(it.fst == cir[i % len + 1]) w[u] = it.snd;\n\t\t}\n\n\t\tint res = 0;\n\t\t(res += calc()) %= MOD;\n\n\t\tfor(int i = len + 1; i >= 1; --i) w[cir[i]] = w[cir[i - 1]];\n\t\tw[cir[1]] = w[cir[len + 1]];\n\n\t\t(res += calc()) %= MOD;\n\n\t\tans = (LL) ans * res % MOD * C(sz + dfn_cur, dfn_cur) % MOD;\n\t\tsz += dfn_cur;\n\t}\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3e5 + 5;\nconst LL mod = 1e9 + 7;\n\ntemplate <typename T> inline void Read(T &x) {\n  char ch; x = 0;\n  while (!isdigit(ch = getchar()));\n  do {x = (x << 1) + (x << 3) + ch - '0';} while (isdigit(ch = getchar()));\n}\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], top;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  //cerr << x << \" -> \" << y << endl;\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= top; i ++)\n    Fir[vertex[i]] = deg[vertex[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = top, i; u; u --) {\n    i = vertex[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = top, i = vertex[u]; u; u --, i = vertex[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  return res;\n}\n\nint main() {\n  pre();\n  Read(n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    Read(x[i]); Read(y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      top = 0;\n      dfs(k);\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      if (ans >= mod) ans -= mod;\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      tmp = tmp * C(p, top) % mod;\n      ans = ans * tmp % mod;\n      p -= top;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define pb push_back\n\nconst int N=2e5+5,D=1e9+7;\nll mi(ll x,int y=D-2)\n{\n\tll ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ans=ans*x%D;\n\t\tx=x*x%D;y>>=1;\n\t}\n\treturn ans;\n}\nvector<int>lk[N];\nbool vis[N];\n\nint du[N],fa[N],sz[N];\nint q[N],tail,nq[N];\ninline bool link_fa(int x)\n{\n\treturn x<fa[fa[x]];\n}\nll solve(int rt)\n{\n\ttail=1;\n\tq[1]=rt;\n\tvis[rt]=1;\n\trep(head,1,tail)\n\t{\n\t\tint x=q[head];\n\t\tdu[x]=0;sz[x]=1;fa[x]=0;\n\t\tfor(auto y:lk[x])\n\t\tif(!vis[y])\n\t\t{\n\t\t\tq[++tail]=y;\n\t\t\tvis[y]=1;\n\t\t}\n\t}\n\tint ecnt=0;\n\trep(head,1,tail)\n\t{\n\t\tint x=q[head];\n\t\tfor(auto y:lk[x])\n\t\t{\n\t\t\t++du[y];\n\t\t\t++ecnt;\n\t\t}\n\t}\n\tif(ecnt/2!=tail)return 0;\n\tint nq_tail=0;\n\trep(head,1,tail)\n\t{\n\t\tint x=q[head];\n\t\tif(du[x]==1)nq[++nq_tail]=x;\n\t}\n\trep(head,1,nq_tail)\n\t{\n\t\tint x=nq[head];\n\t\tfor(auto y:lk[x])\n\t\tif(--du[y]>0)\n\t\t{\n\t\t\tfa[x]=y;\n\t\t\tif(du[y]==1)nq[++nq_tail]=y;\n\t\t\telse rt=y;\n\t\t}\n\t}\n\tfor(int x=rt;;)\n\t{\n\t\tfor(auto y:lk[x])\n\t\tif(du[y]>1&&fa[y]!=x)\n\t\t{\n\t\t\tfa[x]=y;\n\t\t\tx=y;\n\t\t\tbreak;\n\t\t}\n\t\tif(x==rt)break;\n\t}\n\tll ans=1;\n\trep(head,1,nq_tail)\n\t{\n\t\tint x=nq[head];\n\t\t(ans*=sz[x])%=D; \n\t\tif(link_fa(x))sz[fa[x]]+=sz[x];\n\t}\n\tfor(int x=rt;;)\n\t{\n\t\tif(!link_fa(x))\n\t\t{\n\t\t\trt=fa[x];\n\t\t\tbreak;\n\t\t}\n\t\tx=fa[x];\n\t\tif(x==rt)return 0;\n\t}\n\tfor(int x=rt;;)\n\t{\n\t\t(ans*=sz[x])%=D; \n\t\tif(link_fa(x))sz[fa[x]]+=sz[x];\n\t\tx=fa[x];\n\t\tif(x==rt)break;\n\t}\n\treturn mi(ans);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,1,n*2)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ty+=n;\n\t\tlk[x].pb(y);lk[y].pb(x);\n\t}\n\t\n\tll ans=1;\n\trep(i,1,n*2)ans=ans*i%D;\n\trep(x,1,n*2)\n\tif(!vis[x])\n\t{\n\t\tll s=solve(x);\n\t\trep(head,1,tail)\n\t\t{\n\t\t\tint x=q[head];\n\t\t\tvis[x]=0;\n\t\t\treverse(lk[x].begin(),lk[x].end());\n\t\t}\n\t\t(ans*=s+solve(x))%=D;\n\t}\n\t\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint fac[200111],invf[200111];\nint cal(int x,int y){return 1ll*fac[x+y]*invf[x]%mod*invf[y]%mod;}\npii comb(pii x,pii y){return mp(1ll*x.ff*y.ff%mod*cal(x.ss,y.ss)%mod,x.ss+y.ss);}\n\nvector<int> g[200111],g2[200111];\nint n,vs[200111],tot,cyc[200111],len,to[200111],dgr[200111];\n\nbool incyc[200111],use[200111];\nint stk[200111],top,cnt,dep[200111];\n\npii dfs2(int x)\n{\n\tif(use[x])return mp(1,0);\n\tuse[x]=1;\n\tpii ret=mp(1,0);\n\tfor(int i=0;i<(int)g2[x].size();i++)\n\t\tret=comb(ret,dfs2(g2[x][i]));\n\tret.ss++;return ret;\n}\nvoid dfs(int x,int f=0)\n{\n\tstk[++top]=x;dep[x]=top;cnt++;\n\tvs[++tot]=x;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t{\n\t\tif(g[x][i]==f)continue;\n\t\tcnt--;\n\t\tif(!dep[g[x][i]])\n\t\t\tdfs(g[x][i],x);\n\t\telse if(dep[g[x][i]]<dep[x])\n\t\t{\n\t\t\tlen=0;\n\t\t\tfor(int j=dep[g[x][i]];j<=top;j++){cyc[++len]=stk[j];incyc[stk[j]]=1;}\n\t\t}\n\t\telse cnt++;\n\t}\n\ttop--;\n}\nvoid rdfs(int x,int f=0)\n{\n\tto[x]=f;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f&&!incyc[g[x][i]])\n\t\t\trdfs(g[x][i],x);\n}\n\nint calc()\n{\n\tfor(int i=1;i<=tot;i++){g2[vs[i]].clear();dgr[vs[i]]=0;}\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tfor(int j=0;j<(int)g[vs[i]].size();j++)\n\t\t{\n\t\t\tif(to[vs[i]]>g[vs[i]][j])\n\t\t\t{\n\t\t\t\tg2[vs[i]].pb(g[vs[i]][j]);\n\t\t\t\tdgr[g[vs[i]][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tpii ret=mp(1,0);\n\tfor(int i=1;i<=tot;i++)if(dgr[vs[i]]==0)ret=comb(ret,dfs2(vs[i]));\n\treturn ret.ff;\n}\nint main()\n{\n\tfac[0]=invf[0]=1;for(int i=1;i<200111;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinvf[200111-1]=power(fac[200111-1],mod-2);\n\tfor(int i=200111-2;i>=0;i--)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\t\n\tget1(n);\n\tfor(int i=1,x,y;i<=n+n;i++)\n\t{\n\t\tget2(x,y);\n\t\tg[x].pb(y+n);\n\t\tg[y+n].pb(x);\n\t}\n\tn<<=1;\n\t\n\tpii now=mp(1,0);\n\tfor(int _=1;_<=n;_++)\n\t{\n\t\tif(dep[_])continue;\n\t\ttot=0;dfs(_);\n\t\tif(cnt)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=len;i++)rdfs(cyc[i]);\n\t\tint sum=0;\n\t\tfor(int i=1;i<=len;i++)to[cyc[i]]=cyc[i%len+1];\n\t\tsum+=calc();\n\t\tfor(int i=1;i<=len;i++)to[cyc[i%len+1]]=cyc[i];\n\t\tsum+=calc();if(sum>=mod)sum-=mod;\n\t\tnow=comb(now,mp(sum,tot));\n\t}\n\t\n\tprintendl(now.ff);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define mod 1000000007\n#define ll long long\nnamespace mymyth{\n\tll f[nn],rf[nn];\n\tll qpow(ll x,ll y)\n\t{\n\t\tll res=1;\n\t\twhile(y)\n\t\t{\n\t\t\tif(y&1) res=res*x%mod;\n\t\t\ty=y/2;x=x*x%mod;\n\t\t}return res;\n\t}\n\tvoid ini()\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod,rf[i]=qpow(f[i],mod-2);\n\t}\n};\nusing namespace mymyth;\n#define pii pair<int,int> \n#define mp make_pair\nvector<int> v[nn];\nint n;pii dot[nn];\n#define err {puts(\"0\");exit(0);}\nvoid adde(int x,int y)\n{\n\tv[x].push_back(y);\n\tv[y].push_back(x);\n}\nint vis[nn];\nint siz[nn],esiz[nn];\nint pa[nn];vector<int> cir;\nvector<int> all;int dep[nn];\nvoid dfs(int x,int p)\n{\n\tsiz[x]=1;esiz[x]=0;vis[x]=1;\n\tall.push_back(x);\n\tpa[x]=p,dep[x]=dep[p]+1;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif(y==p) continue;//there cant be a multi-edge\n\t\tif(!vis[y])\n\t\t{\n\t\t\tdfs(y,x);\n\t\t\tsiz[x]+=siz[y];\n\t\t\tesiz[x]+=1+esiz[y];\n\t\t}\n\t\telse if(dep[y]<dep[x] and cir.size()==0)\n\t\t{\n\t\t\tesiz[x]++;\n\t\t\tint t=x;\n\t\t\twhile(x!=pa[y]) \n\t\t\t\tcir.push_back(x),x=pa[x];\n\t\t\tx=t;\n\t\t}\n\t}\n}\n\nunordered_map<int,vector<int> >trans ;\nvector<int> g[nn];int gs[nn];ll dp[nn];\nvoid give(int x,int y)\n{\n//\tcout<<x<<\"-\"<<y<<\"\\n\";\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\nvoid gfs(int x,int p)\n{\n\tgs[x]=1;dp[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t{\n\t\tint y=g[x][i];if(y==p) continue;\n\t\tgfs(y,x);\n\t\tdp[x]=dp[x]*dp[y]%mod*rf[gs[y]]%mod;gs[x]+=gs[y];\n\t}\n\tdp[x]=dp[x]*f[gs[x]-1]%mod;\n}\nint cf[nn];\nll solve()\n{\n\ttrans.clear();\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];g[all[i]].clear();cf[all[i]]=0;\n//\t\tcout<<x<<\"->\"<<y<<\"\\n\";\n\t\t\ttrans[y].push_back(x);\n\t}\n\tg[0].clear();//system(\"pause\");\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];vector<int> tmp=trans[x];\n\t\tfor(int j=0;j<tmp.size();j++)\n\t\t\tif(tmp[j]<y) give(all[i],tmp[j]),cf[tmp[j]]=1; \n\t}\n\tfor(int i=0;i<all.size();i++) if(!cf[all[i]]) give(all[i],0);\n\tgfs(0,-1);\n\treturn dp[0];\n}\n\nint vp[nn];\nvoid vps(int x,int p)\n{\n\tpa[x]=p;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==p or vp[v[x][i]]) continue;\n\t\tvps(v[x][i],x); \n\t}\n}\nint main()\n{\n\tini();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tscanf(\"%d%d\",&dot[i].first,&dot[i].second);\n\t\tadde(dot[i].first,dot[i].second+n);\n\t}\n\tll ans=1;\n\tfor(int i=1;i<=n*2;i++) \n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tcir.clear();all.clear();\n\t\t\tdfs(i,0);int cn=cir.size();\n\t\t\tif(siz[i]!=esiz[i]) err;\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tvp[cir[j]]=1,pa[cir[j]]=cir[(j+1)%cn];\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tvps(cir[j],pa[cir[j]]);\n\t\t\tll res=solve();\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tpa[cir[j]]=cir[(j-1+cn)%cn];\n\t\t\tres+=solve();\n\t\t\tans=res%mod*ans%mod*rf[all.size()]%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans*f[n+n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3e5 + 5;\nconst LL mod = 1e9 + 7;\n\ntemplate <typename T> inline void Read(T &x) {\n  char ch; x = 0;\n  while (!isdigit(ch = getchar()));\n  do {x = (x << 1) + (x << 3) + ch - '0';} while (isdigit(ch = getchar()));\n}\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], top;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  //cerr << x << \" -> \" << y << endl;\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= top; i ++)\n    Fir[vertex[i]] = deg[vertex[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = top, i; u; u --) {\n    i = vertex[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = top, i = vertex[u]; u; u --, i = vertex[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  return res;\n}\n\nint main() {\n  pre();\n  Read(n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    Read(x[i]); Read(y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      rt = top = 0;\n      dfs(k);\n      if (!rt) return !puts(\"0\");\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      ans = ans * tmp % mod * C(p, top) % mod;\n      p -= top;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 400005\n#define int long long\nusing namespace std;\nconst int p = 1000000007;\nint n;\nint head[N],ver[N],nxt[N],tot;\nvoid add(int a,int b)\n{\n    tot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;return ;\n}\nint jie[N],ni[N];\nint c(int x,int y)\n{\n    return 1LL*jie[x]*ni[y]%p*ni[x-y]%p;\n}\nint v[N],dian,bian,st[N],top;\nint pi[N],cir[N],sz,q[N];\nvoid dfs(int x,int fa)\n{\n    st[++top]=x;\n    v[x]=1;q[++dian]=x;\n    for(int i=head[x];i;i=nxt[i])\n    {\n        bian++;\n        if(!v[ver[i]])dfs(ver[i],x);\n        else if(ver[i]!=fa&&!sz)\n        {\n            for(int j=top;j>=1;j--)\n            {\n                cir[++sz]=st[j];\n                if(st[j]==ver[i])break;\n            }\n        }\n    }\n    top--;\n    return ;\n}\nint now;\nvoid sao(int x,int f)\n{\n    for(int i=head[x];i;i=nxt[i])\n    {\n        if(ver[i]==f)continue;\n        pi[ver[i]]=x;\n        if(ver[i]==now)continue;\n        sao(ver[i],x);\n    }\n}\nvector<int>vv[N];\nint size[N],fa[N],f[N];\nvoid dp(int x)\n{\n    f[x]=1;size[x]=1;\n    for(int i=0;i<vv[x].size();i++)\n    {\n        dp(vv[x][i]);\n        size[x]+=size[vv[x][i]];\n        f[x]=1LL*f[x]*f[vv[x][i]]%p*c(size[x]-1,size[vv[x][i]])%p;\n    }\n}\nint solve()\n{\n    for(int j=1;j<=dian;j++)fa[q[j]]=0;\n    for(int j=1;j<=dian;j++)\n    {\n        int u=q[j];vv[u].clear();\n        for(int k=head[u];k;k=nxt[k])\n        {\n            if(ver[k]<pi[u])\n            {\n                vv[u].push_back(ver[k]),fa[ver[k]]=u;\n            }\n        }\n    }\n    int ans=1;int szzz=0;\n    for(int j=1;j<=dian;j++)\n    {\n        if(!fa[q[j]])\n        {\n            dp(q[j]);szzz+=size[q[j]];\n            ans=1LL*ans*f[q[j]]%p*c(szzz,size[q[j]])%p;\n        }\n    }\n    return ans;\n}\nsigned main()\n{\n    scanf(\"%lld\",&n);\n    jie[0]=ni[0]=ni[1]=1;\n    for(int i=1;i<=2*n;i++)jie[i]=1LL*jie[i-1]*i%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*(p-p/i)*ni[p%i]%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*ni[i-1]*ni[i]%p;\n    for(int i=1;i<=2*n;i++)\n    {\n        int t1,t2;scanf(\"%lld%lld\",&t1,&t2);\n        add(t1,t2+n);add(t2+n,t1);\n    }\n    int ans=1;int nw=2*n;\n    for(int i=1;i<=2*n;i++)\n    {\n        if(v[i])continue;\n        dian=sz=bian=0;\n        dfs(i,-1);bian/=2;\n        if(dian!=bian)return puts(\"0\"),0;\n        now=cir[sz];\n        sao(cir[sz],-1);\n        cir[sz+1]=cir[1];\n        int as=solve();\n        for(int j=1;j<=sz;j++)pi[cir[j]]=cir[j+1];\n        as+=solve();\n        ans=1LL*ans*c(nw,dian)%p*as%p;\n        nw-=dian;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,o,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\n\nint dep;\n\nvoid dfs(int f,int x){\n\n\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\t\n\t\n\t\ndep++;\nif(dep>200000)return 0;\n\t\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\tdfs(x,V[x][i]);\n\tstk[top--]=0;instk[x]=0;\n\t\ndep--;\t\n\t\n}\nint dfs(int x){\n\n\ndep++;\nif(dep>200000)return;\n\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vx[X][i]!=o){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vy[Y][i]!=o){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\t\ndep--;\n\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\to=0;int xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\tw[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\tw[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define cbn(x,y) ((ll)fac[x]*inv[y]%mod*inv[(x)-(y)]%mod)\n#define N 200009\nusing namespace std;\n\nint n,m,E,ans,tot=1,tp,eg,q[N],fst[N],pnt[N<<1],len[N<<1],nxt[N<<1];\nint fa[N],f[N],sz[N],fac[N],inv[N],vis[N]; bool bo[N];\nvoid add(int x,int y,int z){\n\tpnt[++tot]=y; len[tot]=z; nxt[tot]=fst[x]; fst[x]=tot;\n}\nvoid dfs1(int x,int p){\n\tint i,y; vis[x]=1; q[++tp]=x;\n\tfor (i=fst[x]; i; i=nxt[i]) if (i^p^1){\n\t\ty=pnt[i];\n\t\tif (!bo[i>>1]){ bo[i>>1]=1; eg++; }\n\t\tif (!vis[y]) dfs1(y,i);\n\t}\n}\nvoid dfs2(int x,int p){\n\tint i,y,z; vis[x]=2;\n\tfor (i=fst[x]; i; i=nxt[i]) if (i^p^1){\n\t\ty=pnt[i];\n\t\tif (vis[y]!=2){\n\t\t\tfa[y]=i; dfs2(y,i);\n\t\t} else if (!E)\n\t\t\tfor (z=x,E=i; z!=y; z=pnt[fa[z]^1])\n\t\t\t\tif (len[fa[z]]>len[E]) E=fa[z];\n\t}\n}\nvoid dfs3(int x,int p){\n\tint i,y; sz[x]=f[x]=1;\n\tfor (i=fst[x]; i; i=nxt[i]) if ((i^p^1) && i!=E && (i^E^1)){\n\t\ty=pnt[i];\n\t\tdfs3(y,i);\n\t\tif (len[i]>len[p]) ans=(ll)ans*f[y]%mod*inv[sz[y]]%mod; else{\n\t\t\tsz[x]+=sz[y];\n\t\t\tf[x]=(ll)f[x]*f[y]%mod*cbn(sz[x]-1,sz[y])%mod;\n\t\t}\n\t}\n\tif (p==E) ans=(ll)ans*f[x]%mod*inv[sz[x]]%mod;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,x,y;\n\tfor (i=1; i<=(n<<1); i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y+n,x+y); add(y+n,x,x+y);\n\t}\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor (i=1; i<=(n<<1); i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tfor (i=2; i<=(n<<1); i++) inv[i]=mod-(ll)inv[mod%i]*(mod/i)%mod;\n\tfor (i=2; i<=(n<<1); i++) inv[i]=(ll)inv[i-1]*inv[i]%mod;\n\tint sum=fac[n<<1],tmp;\n\tfor (i=(n<<1); i; i--) if (!vis[i]){\n\t\teg=tp=0; dfs1(i,0);\n\t\tif (eg!=tp){ puts(\"0\"); return 0; }\n\t\tE=0; dfs2(i,0);\n\t\tans=1; dfs3(pnt[E],E); tmp=ans;\n\t\tans=1; dfs3(pnt[E^1],E); tmp+=ans;\n\t\tsum=(ll)sum*tmp%mod;\n\t}\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\tconst int p = 1000000007;\n\tconst int N = 2e5 + 5;\n\n\tint n, vis[N], fac[N], inv[N], invfac[N], size[N], fa[N], onloop[N];\n\tvector<int> E[N], tr[N], node, loop;\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tvoid init()\n\t{\n\t\tfac[0] = invfac[0] = inv[1] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfac[i] = (ll)fac[i - 1] * i % p;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tinv[i] = (ll)inv[p % i] * (p - p / i) % p;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tinvfac[i] = (ll)invfac[i - 1] * inv[i] % p;\n\t}\n\n\tvoid dfs1(const int u, const int f)\n\t{\n\t\tvis[u] = 1;\n\t\tnode.push_back(u);\n\t\tfor (auto v : E[u])\n\t\t\tif (v != f && !vis[v])\n\t\t\t\tdfs1(v, u);\n\t}\n\n\tbool findloop(const int u, const int f)\n\t{\n\t\tstatic int top, sta[N], in[N];\n\t\tsta[++top] = u, in[u] = 1;\n\t\tfor (auto v : E[u])\n\t\t\tif (v != f)\n\t\t\t{\n\t\t\t\tif (in[v])\n\t\t\t\t{\n\t\t\t\t\tdo \t\t\n\t\t\t\t\t{\n\t\t\t\t\t\tloop.push_back(sta[top]);\n\t\t\t\t\t\tonloop[sta[top--]] = 1;\n\t\t\t\t\t}\n\t\t\t\t\twhile (sta[top + 1] != v);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (findloop(v, u))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t--top, in[u] = 0;\n\t\treturn false;\n\t}\n\n\tvoid dfs2(const int u)\n\t{\n\t\tfor (auto v : E[u])\n\t\t\tif (v != fa[u] && !onloop[v])\n\t\t\t\tfa[v] = u, dfs2(v);\n\t}\n\n\tvoid dfs3(const int u)\n\t{\n\t\tsize[u] = 1;\n\t\tfor (auto v : tr[u])\n\t\t\tdfs3(v), size[u] += size[v];\n\t}\t\n\n\tint calc()\n\t{\n\t\tstatic int in[N];\n\t\tint nc = node.size();\n\t\tmemset(in, 0, sizeof(int[nc + 1]));\n\t\tfor (int i = 1; i <= nc; i++)\n\t\t\tfor (auto j : E[node[i - 1]])\n\t\t\t\tif (j < fa[node[i - 1]])\n\t\t\t\t\ttr[node[i - 1]].push_back(j), ++in[j];\n\t\tfor (int i = 1; i <= nc; i++)\n\t\t\tif (!in[node[i - 1]])\n\t\t\t\ttr[0].push_back(node[i - 1]);\n\t\tdfs3(0);\n\t\ttr[0].clear();\n\t\tfor (int i = 1; i <= nc; i++)\n\t\t\ttr[node[i - 1]].clear();\n\t\tint ans = fac[size[0] - 1];\n\t\tfor (int i = 1; i <= nc; i++)\n\t\t\tans = (ll)ans * inv[size[node[i - 1]]] % p;\n\t\treturn ans;\n\t}\n\n\tint solve(const int x)\n\t{\n\t\tnode.clear();\n\t\tdfs1(x, 0);\n\t\tint nc = node.size(), ec = 0;\n\t\tfor (auto i : node)\n\t\t\tec += E[i].size();\n\t\tif ((ec >> 1) != nc)\n\t\t\treturn 0;\n\n\t\tloop.clear();\n\t\tfindloop(x, 0);\n\t\tfor (auto i : loop)\n\t\t\tdfs2(i);\n\n\t\tint tot = loop.size(), u = 0, v = 0;\n\t\tfor (int i = 1; i < tot; i++)\n\t\t\tif (loop[i - 1] + loop[i] > u + v)\n\t\t\t\tu = loop[i - 1], v = loop[i];\n\t\tE[u].erase(find(E[u].begin(), E[u].end(), v));\n\t\tE[v].erase(find(E[v].begin(), E[v].end(), u));\n\n\t\tfa[loop[0]] = loop[tot - 1];\n\t\tfor (int i = 1; i < tot; i++)\n\t\t\tfa[loop[i]] = loop[i - 1];\n\t\tint sum = calc();\n\n\t\tfa[loop[tot - 1]] = loop[0];\n\t\tfor (int i = 1; i < tot; i++)\n\t\t\tfa[loop[i - 1]] = loop[i];\n\t\treturn int((ll)(sum + calc()) % p * invfac[nc] % p);\n\t}\n\n\tvoid work()\n\t{\n\t\tn = read() << 1;\n\t\tinit();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint x = read(), y = read() + (n >> 1);\n\t\t\tE[x].push_back(y);\n\t\t\tE[y].push_back(x);\n\t\t}\n\t\tint ans = fac[n];\n\t\tfor (int i = 1; i <= n && ans; i++)\n\t\t\tif (!vis[i])\n\t\t\t\tans = (ll)ans * solve(i) % p;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\nint main()\n{\n#ifdef DINO\n\tfreopen(\"3537.in\", \"r\", stdin);\n\tfreopen(\"3537.out\", \"w\", stdout);\n#endif\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 1e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = 0);\n\t\tif (!findcr) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\t// assert(SZ(cir) > 1);\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) { ideg[u] = 0; T[u].clear(); }\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tauto lim = UB(DT[u], in[u]); \n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v]) {\t// find it!\n\t\t\twhile (top > 0 && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); if (top > 0) --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tSCir(v, u);\n\t\tif (findcr) return;\n\t} if (top > 0 && S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <functional>\nusing namespace std;\nconst int mod = 1000000007;\nvector<int> fact, inv, factinv;\nint subsolve(int n, vector<int> x, vector<int> y) {\n\tvector<set<int> > cx(n), cy(n);\n\tvector<vector<int> > vx(n), vy(n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tcx[x[i]].insert(i);\n\t\tcy[y[i]].insert(i);\n\t\tvx[x[i]].push_back(i);\n\t\tvy[y[i]].push_back(i);\n\t}\n\tqueue<int> que;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cx[i].size() == 1) que.push(i);\n\t\tif (cy[i].size() == 1) que.push(i + n);\n\t}\n\tvector<int> part_col(2 * n, -1);\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tif (u < n) {\n\t\t\tint idx = *cx[u].begin();\n\t\t\tpart_col[idx] = 0;\n\t\t\tcy[y[idx]].erase(idx);\n\t\t\tif (cy[y[idx]].size() == 1) que.push(y[idx] + n);\n\t\t}\n\t\telse {\n\t\t\tint idx = *cy[u - n].begin();\n\t\t\tpart_col[idx] = 1;\n\t\t\tcx[x[idx]].erase(idx);\n\t\t\tif (cx[x[idx]].size() == 1) que.push(x[idx]);\n\t\t}\n\t}\n\tint src = -1;\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (part_col[i] == -1) {\n\t\t\tsrc = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < (src == -1 ? 1 : 2); i++) {\n\t\tvector<int> col = part_col;\n\t\tif (src != -1) {\n\t\t\tint cur = src, fl = 0;\n\t\t\twhile (col[cur] == -1) {\n\t\t\t\tcol[cur] = fl ^ i;\n\t\t\t\tif (fl == 0) {\n\t\t\t\t\tset<int>::iterator it = cx[x[cur]].begin();\n\t\t\t\t\twhile (*it == cur) it++;\n\t\t\t\t\tcur = *it;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tset<int>::iterator it = cy[y[cur]].begin();\n\t\t\t\t\twhile (*it == cur) it++;\n\t\t\t\t\tcur = *it;\n\t\t\t\t}\n\t\t\t\tfl ^= 1;\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > g(2 * n);\n\t\tvector<int> outdeg(2 * n);\n\t\tfor (int j = 0; j < 2 * n; j++) {\n\t\t\tif (col[j] == 0) {\n\t\t\t\tfor (int k : vx[x[j]]) {\n\t\t\t\t\tif (y[k] < y[j]) {\n\t\t\t\t\t\tg[j].push_back(k);\n\t\t\t\t\t\toutdeg[k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k : vy[y[j]]) {\n\t\t\t\t\tif (x[k] < x[j]) {\n\t\t\t\t\t\tg[j].push_back(k);\n\t\t\t\t\t\toutdeg[k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> sub_sz(2 * n);\n\t\tfunction<int(int)> calc = [&](int pos) {\n\t\t\tint ret = 1;\n\t\t\tsub_sz[pos] = 1;\n\t\t\tfor (int j : g[pos]) {\n\t\t\t\tint res = calc(j);\n\t\t\t\tret = 1LL * ret * res % mod * factinv[sub_sz[j]] % mod;\n\t\t\t\tsub_sz[pos] += sub_sz[j];\n\t\t\t}\n\t\t\tret = 1LL * ret * fact[sub_sz[pos] - 1] % mod;\n\t\t\treturn ret;\n\t\t};\n\t\tint res = fact[2 * n];\n\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\tif (outdeg[i] == 0) {\n\t\t\t\tint subres = calc(i);\n\t\t\t\tres = 1LL * res * subres % mod * factinv[sub_sz[i]] % mod;\n\t\t\t}\n\t\t}\n\t\tret = (ret + res) % mod;\n\t}\n\treturn ret;\n}\nint solve(int n, vector<int> x, vector<int> y) {\n\tfact = vector<int>(2 * n + 1); fact[0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tinv = vector<int>(2 * n + 1); inv[1] = 1;\n\tfor (int i = 2; i <= 2 * n; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfactinv = vector<int>(2 * n + 1); factinv[0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\tvector<vector<int> > g(2 * n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tg[x[i]].push_back(y[i] + n);\n\t\tg[y[i] + n].push_back(x[i]);\n\t}\n\tvector<int> col(2 * n, -1);\n\tint col_cnt = 0;\n\tfunction<void(int)> dfs = [&](int pos) {\n\t\tcol[pos] = col_cnt;\n\t\tfor (int i : g[pos]) {\n\t\t\tif (col[i] == -1) {\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (col[i] == -1) {\n\t\t\tdfs(i);\n\t\t\tcol_cnt++;\n\t\t}\n\t}\n\tvector<int> col_numa(col_cnt), col_numb(col_cnt);\n\tvector<int> idx(2 * n);\n\tfor (int i = 0; i < 2; i++) {\n\t\tvector<int> pre(n, -1);\n\t\tfor (int j = i * n; j < i * n + n; j++) {\n\t\t\tif (pre[col[j]] != -1) idx[j] = idx[pre[col[j]]] + 1;\n\t\t\tpre[col[j]] = j;\n\t\t\tif (i == 0) col_numa[col[j]]++;\n\t\t\tif (i == 1) col_numb[col[j]]++;\n\t\t}\n\t}\n\tvector<vector<int> > comps(col_cnt);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tcomps[col[x[i]]].push_back(i);\n\t}\n\tint ret = fact[2 * n];\n\tfor (int i = 0; i < col_cnt; i++) {\n\t\tif (col_numa[i] + col_numb[i] != comps[i].size() || col_numa[i] != col_numb[i]) return 0;\n\t\tint m = comps[i].size();\n\t\tvector<int> subx(m), suby(m);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tsubx[j] = idx[x[comps[i][j]]];\n\t\t\tsuby[j] = idx[y[comps[i][j]] + n];\n\t\t}\n\t\tint res = subsolve(comps[i].size() / 2, subx, suby);\n\t\tret = 1LL * ret * res % mod * factinv[m] % mod;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<int> x(2 * n), y(2 * n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--;\n\t\ty[i]--;\n\t}\n\tint ret = solve(n, x, y);\n\tcout << ret << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\ntemplate <typename T>\ninline void read(T &x) {\n  x = 0; char c = getchar();\n  for(; !isdigit(c); c = getchar());\n  for(;  isdigit(c); c = getchar())\n    x = x * 10 + c - '0';\n}\n\nconst int N = 2e5 + 50;\nconst int mod = 1e9 + 7;\n\n# define pb push_back\n# define row(x) ((x) <= n ? 1 : 0)\n# define inv(x) (mul(ifac[(x)], fac[(x) - 1]))\n\nint n, x, y, ans = 1, idx, dp[N], fac[N], ifac[N];\nint arr[N], vl[N], fa[N], dfn[N], loop[N];\nvector<int> g[N], E;\n\ninline void add(int &a, int b) {\n  a += b; if(a >= mod) a -= mod;\n}\ninline int mul(int a, int b) {\n  return (LL) a * b % mod;\n}\ninline int Pow(int a, int b) {\n  int r = 1;\n  for(; b; b >>= 1, a = mul(a, a))\n    if(b & 1) r = mul(r, a);  \n  return r;\n}\nvoid pre() {\n  fac[0] = 1;\n  for(int i = 1; i <= 2 * n; ++i)\n    fac[i] = mul(fac[i - 1], i);\n  ifac[2 * n] = Pow(fac[2 * n], mod - 2);\n  for(int i = 2 * n - 1; ~i; --i)\n    ifac[i] = mul(ifac[i + 1], i + 1);\n}\nnamespace jud {\n  int cntn, cnte, vis[N];\n  \n  void dfs(int u) {\n    vis[u] = 1;\n    ++cntn;\n    cnte += g[u].size();\n    for(auto v : g[u]) {\n      if(vis[v]) continue;\n      dfs(v);\n    }\n  }\n  void main(int u) {\n    cntn = cnte = 0;\n    dfs(u);\n    cnte >>= 1;\n    if(cntn != cnte) {\n      puts(\"0\");\n      exit(0);\n    }\n  }\n}\nvoid dfs(int u) {\n  static int icnt = 0;\n  E.pb(u);\n  dfn[u] = ++icnt;\n  for(auto v : g[u]) {\n    if(v == fa[u]) continue;\n    if(!dfn[v]) {\n      fa[v] = u;\n      dfs(v);\n    } else {\n      if(dfn[u] > dfn[v]) continue;\n      loop[++idx] = v;\n      for(int i = v; i != u; i = fa[i])\n        loop[++idx] = fa[i];\n    }\n  }\n}\nvoid Dfs(int u, int fa = 0) {\n  for(auto v : g[u]) {\n    if(v == fa || vl[v]) continue;\n    Dfs(v, u);\n    dp[v] = 1;\n    for(auto x : g[v]) {\n      if(x > u) continue;\n      dp[v] += dp[x];\n    }\n  }\n}\nvoid calc(int u) {\n  if(dp[arr[u]]) return ;\n  int v = arr[u], res = 1;\n  for(auto x : g[v]) {\n    if(vl[x] || x > u) continue;\n    res += dp[x];\n  }\n  if(arr[v] < u) {\n    calc(v);\n    res += dp[arr[v]];\n  } \n  return (void) (dp[v] = res);\n}\nint doit(int step) {\n  int res = 1;\n  loop[0] = loop[idx];\n  loop[idx + 1] = loop[1];\n  int s = (step > 0) ? 1 : idx;\n  for(; s && s <= idx; s += step) \n    arr[loop[s]] = loop[s + step];\n  for(int i = 1; i <= idx; ++i) dp[loop[i]] = 0;\n  for(int i = 1; i <= idx; ++i)\n    calc(loop[i]);\n  for(auto node : E) \n    res = mul(res, inv(dp[node]));\n  return res;\n}\nint solve(int U) {\n  jud :: main(U);\n  E.clear();\n  idx = 0, dfs(U);\n  for(int i = 1; i <= idx; ++i) \n    vl[loop[i]] = 1;\n  for(int i = 1; i <= idx; ++i)\n    Dfs(loop[i]); \n  //for(int i = 1; i <= idx; ++i)\n  //   cout << loop[i] << ' '; puts(\"\");\n  int ans = doit(1) + doit(-1);\n  if(ans >= mod) ans -= mod;\n  return ans;\n}\n\nint main() {\n  read(n);\n  pre();\n  for(int i = 1; i <= 2 * n; ++i) {\n    read(x), read(y);\n    g[x].pb(y + n);\n    g[y + n].pb(x);\n  }\n  for(int i = 1; i <= n; ++i)\n    if(!jud :: vis[i]) ans = mul(ans, solve(i));\n  printf(\"%d\\n\", mul(ans, fac[2 * n]));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tint sz=V[x].size();\n\t\tref(i,0,sz-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\t/*\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n\t*/\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\nint n,fac[200100],inv[200100],ans,cntv,cnte,a[200100],deg[200100],link[200100],s[200100];\nbool flag[200100];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[400100],*tp=pool,*fst[200100],*fst2[200100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nint c(int n,int m)\n{\n    return LL(fac[n])*inv[m]%p*inv[n-m]%p;\n}\n\nvoid addedge(int u,int v,edge **fst)\n{\n    *tp=(edge){v,fst[u]},fst[u]=tp++;\n}\n\nvoid dfs1(int x)\n{\n    flag[x]=1,a[++cntv]=x;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (flag[i->v])\n            ++cnte,++deg[x],++deg[i->v];\n        else\n            dfs1(i->v);\n}\n\nint dfs2(int x)\n{\n    int ret=s[x]=1;\n    for (edge *i=fst2[x]; i; i=i->nxt)\n    {\n        ret=LL(ret)*dfs2(i->v)%p;\n        s[x]+=s[i->v],ret=LL(ret)*c(s[x]-1,s[i->v])%p;\n    }\n    return ret;\n}\n\nint calc()\n{\n    static bool flag[200100];\n    edge *t=tp;\n    repu(i,1,cntv)\n        flag[a[i]]=0;\n    repu(i,1,cntv)\n        for (edge *j=fst[a[i]]; j; j=j->nxt)\n            if (j->v<link[a[i]])\n                addedge(a[i],j->v,fst2),flag[j->v]=1;\n    int sum=0,ret=1;\n    repu(i,1,cntv)\n        if (!flag[a[i]])\n        {\n            ret=LL(ret)*dfs2(a[i])%p;\n            ret=LL(ret)*c(sum+=s[a[i]],s[a[i]])%p;\n        }\n    tp=t;\n    repu(i,1,cntv)\n        fst2[a[i]]=0;\n    return ret;\n}\n\nint solve(int x)\n{\n    cntv=cnte=0,dfs1(x);\n    if (cntv>cnte)\n    {\n        puts(\"0\");\n        exit(0);\n    }\n    repu(i,1,cntv)\n        if (deg[a[i]]==1)\n            for (int j=a[i],nxt=0; j; j=nxt,nxt=0)\n                for (edge *k=fst[j]; k; k=k->nxt)\n                    if (deg[k->v]>1)\n                    {\n                        link[j]=k->v;\n                        if (--deg[k->v]==1)\n                            nxt=k->v;\n                    }\n    static int cyc[200100],tot;\n    repu(i,1,cntv)\n        if (deg[a[i]]>1)\n        {\n            cyc[tot=1]=a[i];\n            while (tot==1 || cyc[tot]!=a[i])\n                for (edge *j=fst[cyc[tot]]; j; j=j->nxt)\n                    if (deg[j->v]>1 && cyc[tot-1]!=j->v)\n                    {\n                        cyc[++tot]=j->v;\n                        break;\n                    }\n            --tot;\n            break;\n        }\n    repu(i,1,tot)\n        link[cyc[i]]=cyc[i+1];\n    int sum=calc();\n    repu(i,1,tot)\n        link[cyc[i+1]]=cyc[i];\n    (sum+=calc())%=p,ans=LL(ans)*sum%p;\n    return cntv;\n}\n\nint main()\n{\n    n=getint(),ans=1;\n    repu(i,1,n*2)\n    {\n        int u=getint(),v=getint()+n;\n        addedge(u,v,fst),addedge(v,u,fst);\n    }\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    repu(i,2,n*2)\n        inv[i]=LL(p-p/i)*inv[p%i]%p;\n    repu(i,2,n*2)\n        fac[i]=LL(fac[i-1])*i%p,inv[i]=LL(inv[i-1])*inv[i]%p;\n    int sum=0;\n    repu(i,1,n*2)\n        if (!flag[i])\n        {\n            int cnt=solve(i);\n            ans=LL(ans)*c(sum+=cnt,cnt)%p;\n        }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\nconst int MAXN = (int) 2e5;\n\nint n;\n\nint x[MAXN + 5], y[MAXN + 5];\n\nvector<pii> adj[MAXN * 2 + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= 2 * n; ++i)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\t\tadj[u].emplace_back(n + v, u + v);\n\t\tadj[n + v].emplace_back(u, u + v);\n\t}\n}\n\nint dfn[MAXN * 2 + 5], dfn_cur = 0, edge_cnt = 0;\nvector<int> stk, P;\n\nint cir[MAXN * 2 + 5], len = 0;\n\ninline void dfs_cir(int u, int fa)\n{\n\tP.push_back(u);\n\tdfn[u] = ++dfn_cur;\n\n\tstk.push_back(u);\n\tfor(auto it : adj[u])\n\t{\n\t\tint v = it.fst;\n\t\t++edge_cnt;\n\t\tif(v != fa)\n\t\t{\n\t\t\tif(!dfn[v]) dfs_cir(v, u);\n\t\t\telse if(dfn[u] > dfn[v])\n\t\t\t{\n\t\t\t\tfor(int i = SZ(stk) - 1; stk[i] != v; --i) cir[++len] = stk[i];\n\t\t\t\tcir[++len] = v;\n\t\t\t}\n\t\t}\n\t}\n\tstk.pop_back();\n}\n\nint is_cir[MAXN * 2 + 5];\nint w[MAXN * 2 + 5];\n\ninline void dfs_w(int u, int fa)\n{\n\tfor(auto it : adj[u])\n\t{\n\t\tint v = it.fst;\n\t\tif(!is_cir[v] && v != fa) w[v] = it.snd, dfs_w(v, u);\n\t}\n}\n\nnamespace MATH\n{\n\tinline int fpm(int x, int y)\n\t{\n\t\tint res = 1;\n\t\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\t\treturn res;\n\t}\n\n\tint fac[MAXN * 2 + 5], ifac[MAXN * 2 + 5];\n\n\tinline int C(int N, int M) { return N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n\n\tinline void init(int N)\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= N; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[N] = fpm(fac[N], MOD - 2);\n\t\tfor(int i = N - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n}\nusing MATH::C;\n\nvector<int> sub[MAXN * 2 + 5];\nint fa[MAXN + 5];\n\nint f[MAXN + 5], size[MAXN + 5];\n\ninline void dfs_ans(int u)\n{\n\tf[u] = 1, size[u] = 1;\n\tfor(auto v : sub[u]) if(v != fa[u])\n\t{\n\t\tdfs_ans(v);\n\t\tf[u] = (LL) f[u] * C(size[u] - 1 + size[v], size[v]) % MOD * f[v] % MOD;\n\t\tsize[u] += size[v];\n\t}\n}\n\ninline int calc()\n{\n\tsub[0].clear();\n\tfor(auto i : P) fa[i] = 0, sub[i].clear();\n\n\tfor(auto u : P)\n\t\tfor(auto it : adj[u])\n\t\t{\n\t\t\tint v = it.fst, w0 = it.snd;\n\t\t\tif(w0 < w[u]) fa[v] = u, sub[u].push_back(v);\n\t\t}\n\tfor(auto i : P) if(fa[i] == 0) sub[0].push_back(i);\n\n\tdfs_ans(0);\n\treturn f[0];\n}\n\ninline void solve()\n{\n\tint ans = 1, sz = 0;\n\tfor(int rt = 1; rt <= 2 * n; ++rt) if(!dfn[rt])\n\t{\n\t\tP.clear();\n\t\tdfn_cur = 0, edge_cnt = 0;\n\t\tlen = 0, dfs_cir(rt, 0);\n\t\tedge_cnt /= 2;\n\t\tif(dfn_cur != edge_cnt) { puts(\"0\"); return; }\n\n\t\tfor(int i = 1; i <= len; ++i) is_cir[cir[i]] = 1;\n\t\tfor(int i = 1; i <= len; ++i) dfs_w(cir[i], 0);\n\n\t\tMATH::init(2 * n);\n\n\t\tfor(int i = 1; i <= len; ++i)\n\t\t{\n\t\t\tint u = cir[i];\n\t\t\tfor(auto it : adj[u]) if(it.fst == cir[i % len + 1]) w[u] = it.snd;\n\t\t}\n\n\t\tint res = 0;\n\t\t(res += calc()) %= MOD;\n\n\t\tfor(int i = len + 1; i >= 1; --i) w[cir[i]] = w[cir[i - 1]];\n\t\tw[cir[1]] = w[cir[len + 1]];\n\n\t\t(res += calc()) %= MOD;\n\n\t\tans = (LL) ans * res % MOD * C(sz + dfn_cur, dfn_cur) % MOD;\n\t\tsz += dfn_cur;\n\t}\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2e5 + 10, mod = 1e9 + 7;\n\nint n, cntv, cnte, ans, oth, root, fac[maxn], ifac[maxn], par[maxn], dep[maxn], siz[maxn], flag;\nbool vis[maxn], on_cyc[maxn], isr[maxn][2], viss[maxn];\nstd::vector<int> dag[maxn][2], cur;\n\nstruct edge {\n\tint to, id;\n\n\tedge() {}\n\tedge(int to, int id): to(to), id(id) {}\n};\n\nstd::vector<edge> g[maxn];\n\ninline int pow_mod(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * x * y % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < maxn; ++i) {\n\t\tfac[i] = (long long) i * fac[i - 1] % mod;\n\t}\n\tifac[maxn - 1] = pow_mod(fac[maxn - 1], mod - 2);\n\tfor (int i = maxn - 1; i; --i) {\n\t\tifac[i - 1] = (long long) i * ifac[i] % mod;\n\t}\n\treturn;\n}\n\ninline void dfs1(int u, int p = -1, int d = 0) {\n\tcur.push_back(u);\n\tvis[u] = 1;\n\tpar[u] = p;\n\tdep[u] = d;\n\t++cntv;\n\tcnte += (int) g[u].size();\n\tfor (auto &e: g[u]) {\n\t\tint v = e.to;\n\t\tif(v == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[v]) {\n\t\t\troot = dep[u] < dep[v] ? v : u;\n\t\t\toth = u + v - root;\n\t\t}\n\t\telse {\n\t\t\tdfs1(v, u, d + 1);\n\t\t}\n\t}\n\treturn;\n}\n\ninline void dfs2(int u, int p = -1) {\n\tviss[u] = 1;\n\tpar[u] = p;\n\tfor (auto &e: g[u]) {\n\t\tint v = e.to;\n\t\tif(!viss[v]) {\n\t\t\tdfs2(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\ninline int DP(int u) {\n\tsiz[u] = 1;\n\tint ret = 1;\n\tfor (int &v: dag[u][flag]) {\n\t\tret = (long long) DP(v) * ret % mod;\n\t\tsiz[u] += siz[v];\n\t\tret = (long long) ret * ifac[siz[v]] % mod;\n\t}\n\treturn (long long) ret * fac[siz[u] - 1] % mod;\n}\n\nint main() {\n\tprepare();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x;\n\t\ty += n - 1;\n\t\tg[x].push_back(edge(y, i));\n\t\tg[y].push_back(edge(x, i));\n\t}\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tisr[i][0] = isr[i][1] = 1;\n\t}\n\tans = fac[n << 1];\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tif(!vis[i]) {\n\t\t\tcur.clear();\n\t\t\tcntv = cnte = 0;\n\t\t\tdfs1(i);\n\t\t\tif((cntv << 1) != cnte) {\n\t\t\t\tassert(0);\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tflag = 0;\n\t\t\tint ban;\n\t\t\tfor (int u = root; u != oth; u = par[u]) {\n\t\t\t\ton_cyc[u] = 1;\n\t\t\t}\n\t\t\ton_cyc[oth] = 1;\n\t\t\tfor (auto &e: g[root]) {\n\t\t\t\tif(on_cyc[e.to]) {\n\t\t\t\t\tban = e.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u = root; ; ) {\n\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\tif(on_cyc[v] && i != ban) {\n\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tban = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u == root) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs2(root);\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(!on_cyc[u]) {\n\t\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\t\tif(v == par[u]) {\n\t\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res1 = 1;\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(isr[u][flag]) {\n\t\t\t\t\tres1 = (long long) DP(u) * res1 % mod * ifac[siz[u]] % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = 1;\n\t\t\tfor (auto &e: g[root]) {\n\t\t\t\tif(on_cyc[e.to]) {\n\t\t\t\t\tban = e.id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u = root; ; ) {\n\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\tif(on_cyc[v] && i != ban) {\n\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tban = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u == root) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(!on_cyc[u]) {\n\t\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\t\tif(v == par[u]) {\n\t\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res2 = 1;\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(isr[u][flag]) {\n\t\t\t\t\tres2 = (long long) DP(u) * res2 % mod * ifac[siz[u]] % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = (long long) (res1 + res2) * ans % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\ni64 modpow(i64 a, int p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 tmp = modpow(a, p / 2);\n\ttmp = tmp * tmp % MOD;\n\tif (p % 2 == 1) tmp = tmp * a % MOD;\n\treturn tmp;\n}\n\nint N, X[101010], Y[101010];\ni64 fact[202020], facti[202020];\n\nvector<int> ax[101010], ay[101010];\n\nint uf[202020];\n\nint root(int p)\n{\n\treturn uf[p] < 0 ? p : (uf[p] = root(uf[p]));\n}\nbool join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\tif (p == q) return false;\n\tuf[p] += uf[q];\n\tuf[q] = p;\n\treturn true;\n}\n\nvector<int> grp[202020];\nint dir[202020]; // 0: down, 1: left\n\nset<int> sx[101010], sy[101010];\nvector<int> depends[202020];\nint depender[202020];\n\nvoid add_dependency(int p, int q)\n{\n\t// p depends on q\n\tdepends[p].push_back(q);\n\tdepender[q] = p;\n}\n\npair<int, i64> solve_dependency(int p)\n{\n\tint sz = 0;\n\ti64 pat = 1;\n\n\tfor (int q : depends[p]) {\n\t\t//printf(\"%d -> %d\\n\", p, q);\n\t\tauto sub = solve_dependency(q);\n\t\tpat = pat * sub.second % MOD;\n\t\tpat = pat * facti[sub.first] % MOD;\n\t\tsz += sub.first;\n\t}\n\tpat = pat * fact[sz] % MOD;\n\n\treturn{ sz + 1, pat };\n}\n\ni64 solve(int g)\n{\n\tset<int> xs, ys;\n\tfor (int c : grp[g]) {\n\t\txs.insert(X[c]);\n\t\tys.insert(Y[c]);\n\t}\n\tif (xs.size() + ys.size() != grp[g].size()) {\n\t\treturn 0;\n\t}\n\n\ti64 ret = 0;\n\tfor (int t = 0; t < 2; ++t) {\n\t\tfor (int c : grp[g]) {\n\t\t\tdepends[c].clear();\n\t\t\tdepender[c] = -1;\n\t\t\tdir[c] = -1;\n\t\t}\n\t\tfor (int x : xs) sx[x].clear();\n\t\tfor (int y : ys) sy[y].clear();\n\n\t\tfor (int c : grp[g]) {\n\t\t\tsx[X[c]].insert(c);\n\t\t\tsy[Y[c]].insert(c);\n\t\t}\n\t\tqueue<pair<int, int>> Q;\n\t\tfor (int x : xs) {\n\t\t\tif (sx[x].size() == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sx[x].size() == 1) {\n\t\t\t\tQ.push({ 0, *sx[x].begin() });\n\t\t\t}\n\t\t}\n\t\tfor (int y : ys) {\n\t\t\tif (sy[y].size() == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sy[y].size() == 1) {\n\t\t\t\tQ.push({ 1, *sy[y].begin() });\n\t\t\t}\n\t\t}\n\t\tint rem = grp[g].size();\n\n\t\twhile (rem > 0) {\n\t\t\tif (Q.empty()) {\n\t\t\t\tint tg = 0;\n\t\t\t\tfor (int x : xs) {\n\t\t\t\t\tif (sx[x].size() > 0) {\n\t\t\t\t\t\tQ.push({ t, *sx[x].begin() });\n\t\t\t\t\t\t//printf(\"force %d %d\\n\", *sx[x].begin(), t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tauto a = Q.front(); Q.pop();\n\t\t\t--rem;\n\n\t\t\tif (a.first == 0) {\n\t\t\t\tint p = a.second; // *sx[a.second].begin();\n\t\t\t\t//printf(\"decide %d %d\\n\", p, 0);\n\t\t\t\tdir[p] = 0;\n\t\t\t\tsx[X[p]].erase(p);\n\t\t\t\tsy[Y[p]].erase(p);\n\t\t\t\t//if (sy[Y[p]].size() == 0) return 0;\n\t\t\t\tif (sy[Y[p]].size() == 1) {\n\t\t\t\t\t//printf(\"%d\\n\", *sy[Y[p]].begin());\n\t\t\t\t\tQ.push({ 1, *sy[Y[p]].begin() });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint p = a.second; // *sy[a.second].begin();\n\t\t\t\t//printf(\"decide %d %d\\n\", p, 1);\n\t\t\t\tdir[p] = 1;\n\t\t\t\tsx[X[p]].erase(p);\n\t\t\t\tsy[Y[p]].erase(p);\n\t\t\t\t//if (sx[X[p]].size() == 0) return 0;\n\t\t\t\tif (sx[X[p]].size() == 1) {\n\t\t\t\t\tQ.push({ 0, *sx[X[p]].begin() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int c : grp[g]) {\n\t\t\tint x = X[c], y = Y[c];\n\t\t//\tprintf(\"%d %d: %d\\n\", x, y, dir[c]);\n\t\t\tif (dir[c] == 0) {\n\t\t\t\tfor (int d : ax[x]) {\n\t\t\t\t\tif (Y[d] < y) {\n\t\t\t\t\t\tadd_dependency(c, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (dir[c] == 1) {\n\t\t\t\tfor (int d : ay[y]) {\n\t\t\t\t\tif (X[d] < x) {\n\t\t\t\t\t\tadd_dependency(c, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tputs(\"><\");\n\t\t\t}\n\t\t}\n\n\t\ti64 pat = fact[grp[g].size()];\n\t\tfor (int c : grp[g]) {\n\t\t\tif (depender[c] == -1) {\n\t\t\t\tpair<int, i64> sz_pat = solve_dependency(c);\n\t\t\t\tpat = pat * facti[sz_pat.first] % MOD * sz_pat.second % MOD;\n\t\t\t}\n\t\t}\n\t\tADD(ret, pat);\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < 2 * N; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x; --y;\n\t\tX[i] = x;\n\t\tY[i] = y;\n\t\tax[x].push_back(i);\n\t\tay[y].push_back(i);\n\t}\n\tfact[0] = 1;\n\tfor (int i = 1; i <= 2 * N; ++i) fact[i] = fact[i - 1] * i % MOD;\n\tfor (int i = 0; i <= 2 * N; ++i) facti[i] = modpow(fact[i]);\n\n\tfor (int i = 0; i < 2 * N; ++i) uf[i] = -1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 1; j < ax[i].size(); ++j) {\n\t\t\tjoin(ax[i][j - 1], ax[i][j]);\n\t\t}\n\t\tfor (int j = 1; j < ay[i].size(); ++j) {\n\t\t\tjoin(ay[i][j - 1], ay[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < 2 * N; ++i) {\n\t\tgrp[root(i)].push_back(i);\n\t}\n\n\ti64 ret = fact[2 * N];\n\tfor (int i = 0; i < 2 * N; ++i) {\n\t\tif (grp[i].size() > 0) {\n\t\t\tret = ret * facti[grp[i].size()] % MOD * solve(i) % MOD;\n\t\t\tif (ret == 0) break;\n\t\t}\n\t}\n\n\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define f1(a,b,c) for(int c=a;c<=b;c++)\n#define f2(a,b,c) for(int c=a;c>=b;c--)\n#define f3(a,b,c) for(int c=a;c;c=b)\n#define so1(a,n) sort(a+1,a+n+1,mycmp);\n#define so2(a,n) sort(a+1,a+n+1);\n#define ll long long\n#define itn int\n#define ubt int \n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\nconst int twx=+100;\nconst int inf=0x3f3f3f3f;\nconst int MOD=1e9+7;\nll read()\n{\n    ll sum=0;\n    ll flag=1;\n    char c=getchar();\n    while(c<'0'||c>'9')\n    {\n        if(c=='-')\n        {\n            flag=-1;\n        }\n        c=getchar();\n    }\n    while(c>='0'&&c<='9')\n    {\n        sum=((sum*10)+c-'0');\n        c=getchar();\n    }\n    return sum*flag;\n}\nint n;\nvoid init()\n{\n\tn=read();\n}\nvoid work()\n{\n\t\n}\nvoid print()\n{\n\t\n}\nint main()\n{\n    puts(\"0\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\n//const uint mod=998244353;\nconst uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nmint sub(vc<pi> es){\n\tvi vs;\n\tfor(auto e:es){\n\t\tvs.pb(e.a);\n\t\tvs.pb(e.b);\n\t}\n\tmkuni(vs);\n\tint n=vs.size();\n\tif(n!=(int)es.size())\n\t\treturn 0;\n\t\n\tvvc<int> g(n);\n\tfor(auto&e:es){\n\t\te.a=lwb(vs,e.a);\n\t\te.b=lwb(vs,e.b);\n\t\tg[e.a].pb(e.b);\n\t\tg[e.b].pb(e.a);\n\t}\n\t\n\tvi deg(n);\n\trep(i,n)deg[i]=g[i].size();\n\t\n\tvi st;\n\trep(i,n)if(deg[i]==1)\n\t\tst.pb(i);\n\t\n\tvi to(n,-1);\n\twhile(st.size()){\n\t\tint v=st.back();\n\t\tst.pop_back();\n\t\t\n\t\tfor(auto i:g[v])if(deg[i]>1){\n\t\t\tto[v]=i;\n\t\t\tif(--deg[i]==1)\n\t\t\t\tst.push_back(i);\n\t\t}\n\t}\n\t\n\tvi c;\n\trep(i,n)if(deg[i]>1){\n\t\tassert(deg[i]==2);\n\t\tint x=i;\n\t\twhile(1){\n\t\t\tdeg[x]=1;\n\t\t\tc.pb(x);\n\t\t\tint nx=-1;\n\t\t\tfor(auto j:g[x])if(deg[j]==2)\n\t\t\t\tnx=j;\n\t\t\tif(nx==-1)break;\n\t\t\tx=nx;\n\t\t}\n\t\tbreak;\n\t}\n\t\n\tmint res;\n\trep(_,2){\n\t\trep(i,c.size())\n\t\t\tto[c[i]]=c[(i+1)%c.size()];\n\t\t\n\t\tvvc<int> t(n);\n\t\trep(i,n){\n\t\t\tsort(all(g[i]));\n\t\t\tfor(auto j:g[i]){\n\t\t\t\tif(j==to[i])break;\n\t\t\t\tt[i].pb(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi memo(n,-1);\n\t\tfunction<int(int)> dfs;\n\t\tdfs=[&](int v){\n\t\t\tif(memo[v]!=-1)return memo[v];\n\t\t\tmemo[v]=1;\n\t\t\tfor(auto ch:t[v])\n\t\t\t\tmemo[v]+=dfs(ch);\n\t\t\treturn memo[v];\n\t\t};\n\t\t\n\t\tmint w=1;\n\t\trep(i,n)\n\t\t\tw*=invs[dfs(i)];\n\t\tres+=w;\n\t\t\n\t\treverse(all(c));\n\t}\n\t\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint n;cin>>n;\n\tn*=2;\n\t\n\tunionfind uf(n);\n\tvc<pi> es;\n\trep(i,n){\n\t\tint x,y;cin>>x>>y;\n\t\tx--;y--;\n\t\ty+=n/2;\n\t\tes.eb(x,y);\n\t\tuf.unite(x,y);\n\t}\n\t\n\tvvc<pi> es2(n);\n\tfor(auto e:es)\n\t\tes2[uf.find(e.a)].pb(e);\n\t\n\tmint ans=1;\n\trep(i,n)if(uf.find(i)==i){\n\t\tans*=sub(es2[i]);\n\t}\n\t\n\tcout<<ans*fact[n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tint sz=V[x].size();\n\t\tref(i,0,sz-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::cerr;\nusing std::endl;\n\ninline int rd() {\n  int x; scanf(\"%d\", &x);\n  return x;\n}\n\nconst int N = 2e5 + 233, P = 1e9 + 7;\n\ninline long long fpow(long long x, int y) {\n  long long ret = 1;\n  for ( ; y; y >>= 1, x = x * x % P)\n    if (y & 1) ret = ret * x % P;\n  return ret;\n}\n\nint n, X[N], Y[N];\nstd::vector<int> G[N];\nlong long fac[N], inv[N];\n\n// sides of circle\nint sx, sy;\nint cnt_ver, cnt_edge;\nint vis[N];\n\nvoid dfs1(int x, int fa) {\n  vis[x] = 1;\n  ++cnt_ver;\n  for (int y : G[x]) {\n    ++cnt_edge;\n    if (y == fa)\n      continue;\n    if (vis[y]) {\n      sx = x;\n      sy = y;\n    } else {\n      dfs1(y, x);\n    }\n  }\n}\n\nint last[N];\nint stk[N], top;\n\nvoid dfs2(int x, int fa) {\n  last[x] = fa;\n  stk[++top] = x;\n  for (int y : G[x]) {\n    if (y != fa && y != sx) {\n      dfs2(y, x);\n    }\n  }\n}\n\nstd::vector<int> T[N];\nint deg[N];\nint size[N];\n\nvoid dfs3(int x, int fa) {\n  size[x] = 1;\n  for (int y : T[x]) {\n    if (y != fa) {\n      dfs3(y, x);\n      size[x] += size[y];\n    }\n  }\n}\n\ninline long long work() {\n  top = 0;\n  dfs2(sx, sy);\n\n  for (int v = 1; v <= top; ++v) {\n    int x = stk[v];\n    T[x].clear();\n    deg[x] = 0;\n  }\n\n  for (int v = 1; v <= top; ++v) {\n    int x = stk[v];\n    for (int y : G[x]) {\n      if (y < last[x]) {\n        T[x].push_back(y);\n        ++deg[y];\n      }\n    }\n  }\n\n  for (int v = 1; v <= top; ++v) {\n    int x = stk[v];\n    if (!deg[x]) {\n      dfs3(x, x);\n    }\n  }\n\n  long long ret = fac[cnt_ver];\n\n\n\n  for (int v = 1; v <= top; ++v) {\n    int x = stk[v];\n    ret = ret * fac[size[x] - 1] % P * inv[size[x]] % P;\n  }\n\n  return ret;\n\n}\n\nint main() {\n  n = rd();\n  for (int i = 1; i <= n * 2; ++i) {\n    X[i] = rd();\n    Y[i] = rd() + n;\n    G[X[i]].push_back(Y[i]);\n    G[Y[i]].push_back(X[i]);\n  }\n  n *= 2;\n\n  for (int i = fac[0] = 1; i <= n; ++i) {\n    fac[i] = fac[i - 1] * i % P;\n  }\n  inv[n] = fpow(fac[n], P - 2);\n  for (int i = n; i; --i) {\n    inv[i - 1] = inv[i] * i % P;\n  }\n\n\n  long long ans = fac[n];\n\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      cnt_edge = cnt_ver = 0;\n      dfs1(i, 0);\n      if (cnt_edge != cnt_ver * 2) {\n        puts(\"0\");\n        return 0;\n      }\n      long long tmp = work();\n      std::swap(sx, sy);\n      tmp += work();\n      ans = ans * tmp % P * inv[cnt_ver] % P;\n    }\n  }\n\n  std::cout << ans << std::endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v; };\n\nint f[300000], fi[300000];\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n>>=1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint inv_mod(int x, int p) {\n\treturn pow_mod(x, p - 2, p);\n}\n\nint C(int x, int y) {\n\treturn (ll)f[x] * fi[y] % MOD * fi[x - y] % MOD;\n}\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint prod;\n\nint dfs(int u, vector<vector<int> >& G) {\n\tint tot = 0;\n\tfor (int v: G[u]) {\n\t\tint sz = dfs(v, G);\n\t\ttot += sz;\n\t\tprod = (ll)prod * C(tot, sz) % MOD;\n\t}\n\treturn tot + 1;\n}\n\nint calc(int N, int M, vector<int> a, vector<int> b, vector<int> dir) {\n\treturn 0;\n\trep(i, N + M) if (dir[i] == -1) return 0;\n\tvector<int> unko(N + M);\n\trep(i, N + M) {\n\t\tif (dir[i] == 0) unko[a[i]]++;\n\t\tif (dir[i] == 1) unko[N + b[i]]++;\n\t}\n\trep(u, N + M) if (unko[u] != 1) return 0;\n\tvector<vector<i_i> > xs(N), ys(M);\n\trep(i, N + M) xs[a[i]].pb(i_i(b[i], i));\n\trep(i, N + M) ys[b[i]].pb(i_i(a[i], i));\n\tvector<vector<int> > G(N + M);\n\tvector<bool> root(N + M, true);\n\trep(k, N) {\n\t\tsort(xs[k].begin(), xs[k].end());\n\t\trep(l, xs[k].size()) {\n\t\t\tint i = xs[k][l].second;\n\t\t\tif (dir[i] == 0)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(xs[k][_l].second);\n\t\t}\n\t}\n\trep(k, N) {\n\t\tsort(ys[k].begin(), ys[k].end());\n\t\trep(l, ys[k].size()) {\n\t\t\tint i = ys[k][l].second;\n\t\t\tif (dir[i] == 1)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(ys[k][_l].second);\n\t\t}\n\t}\n\trep(u, N + M) for (int v: G[u]) root[v] = false;\n\tvector<int> to;\n\trep(u, N + M) if (root[u]) to.pb(u);\n\tG.pb(to);\n\tprod = 1;\n\tdfs(N + M, G);\n\treturn prod;\n}\n\nint solve(int N, int M, vector<int> a, vector<int> b) {\n\tif (N + M != a.size()) return 0;\n\tvector<vector<edge> > G(N + M);\n\trep(i, N + M) G[a[i]].pb(edge{i, N + b[i]}), G[N + b[i]].pb(edge{i, a[i]});\n\tvector<int> d(N + M);\n\trep(u, N + M) d[u] = G[u].size();\n\tqueue<int> q;\n\trep(u, N + M) if (d[u] == 1) q.push(u);\n\tvector<bool> exist(N + M, true);\n\tvector<int> dir(N + M, -1);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\texist[u] = false;\n\t\tint i;\n\t\tfor (edge e: G[u]) if (exist[e.v]) {\n\t\t\ti = e.i;\n\t\t\td[e.v]--;\n\t\t\tif (d[e.v] == 1) q.push(e.v);\n\t\t}\n\t\tdir[i] = (u >= N);\n\t}\n\tint i0 = -1;\n\trep(i, N + M) if (dir[i] == -1) i0 = i;\n\tif (i0 == -1) return calc(N, M, a, b, dir);\n\tvector<int> dir0 = dir;\n\tint ans = 0;\n\trep(t, 2) {\n\t\tdir = dir0;\n\t\tint s;\n\t\tif (t == 0) s = a[i0], dir[i0] = 0;\n\t\tif (t == 1) s = N + b[i0], dir[i0] = 1;\n\t\tvector<bool> vis(N + M); vis[s] = true;\n\t\tqueue<int> q; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (edge e: G[u]) if (dir[e.i] == -1) {\n\t\t\t\tdir[e.i] = (e.v >= N);\n\t\t\t\tif (!vis[e.v]) {\n\t\t\t\t\tvis[e.v] = true;\n\t\t\t\t\tq.push(e.v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (ans + calc(N, M, a, b, dir)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tf[0] = fi[0] = 1;\n\tfor (int x = 1; x < 300000; x++) {\n\t\tf[x] = (ll)f[x - 1] * x % MOD;\n\t\tfi[x] = (ll)fi[x - 1] * inv_mod(x, MOD) % MOD;\n\t}\n\tint N; cin >> N;\n\tvector<int> a(N * 2), b(N * 2);\n\trep(i, N * 2) scanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\tunion_find uf(N * 2);\n\trep(i, N * 2) uf.unite(a[i], b[i] + N);\n\tvector<vector<int> > vv(N * 2);\n\trep(i, N * 2) vv[uf.find(a[i])].pb(i);\n\tint ans = 1;\n\tfor (vector<int> v: vv) if (!v.empty()) {\n\t\tvector<int> _a, _b;\n\t\tfor (int i: v) _a.pb(a[i]), _b.pb(b[i]);\n\t\tvector<int> A = _a, B = _b;\n\t\tsort(A.begin(), A.end());\n\t\tsort(B.begin(), B.end());\n\t\tA.erase(unique(A.begin(), A.end()), A.end());\n\t\tB.erase(unique(B.begin(), B.end()), B.end());\n\t\tfor (int& u: _a) u = lower_bound(A.begin(), A.end(), u) - A.begin();\n\t\tfor (int& u: _b) u = lower_bound(B.begin(), B.end(), u) - B.begin();\n\t\tans = (ll)ans * solve(A.size(), B.size(), _a, _b) % MOD;\n\t}\n\tint tot = 0;\n\trep(u, N * 2) if (uf.root(u)) {\n\t\ttot += uf.size(u);\n\t\tans = (ll)ans * C(tot, uf.size(u)) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G, loop;\nint dfn[MAXN], fa[MAXN], s, t, cnt = 0, edge = 0;\nvoid GetLoop(int x) // 找环 \n{\n\tG.push_back(x); // 森林中的一棵树 \n\tdfn[x] = ++cnt;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == fa[x])\n\t\t\tcontinue;\n\t\tif (dfn[y]) \n\t\t{\n\t\t\tif (dfn[y] < dfn[x]) continue;\n\t\t\tloop.push_back(y);\n\t\t\tfor (; y != x; y = fa[y])\n\t\t\t\tloop.push_back(fa[y]);\n\t\t}\n\t\telse { fa[y] = x; GetLoop(y); }\n\t}\n} \n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[cnt];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tfreopen(\"robot.in\", \"r\", stdin);\n\tfreopen(\"robot.out\", \"w\", stdout);\n\tscanf(\"%d\", &n);;\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!dfn[i])\n\t\t{\n\t\t\tcnt = edge = 0;\n\t\t\tGetLoop(i);\n\t\t\tif (cnt << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\ts = loop[0], t = loop[loop.size() - 1]; // 环的起点、终点 \n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tloop.clear();\n\t\t\tG.clear();\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint fac[200111],invf[200111];\nint cal(int x,int y){return 1ll*fac[x+y]*invf[x]%mod*invf[y]%mod;}\npii comb(pii x,pii y){return mp(1ll*x.ff*y.ff%mod*cal(x.ss,y.ss)%mod,x.ss+y.ss);}\n\nvector<int> g[200111],g2[200111];\nint n,vs[200111],tot,cyc[200111],len,to[200111],dgr[200111];\n\nbool incyc[200111],use[200111];\nint stk[200111],top,cnt,dep[200111];\n\npii dfs2(int x)\n{\n\tpii ret=mp(1,0);\n\tfor(int i=0;i<(int)g2[x].size();i++)\n\t\tret=comb(ret,dfs2(g2[x][i]));\n\tret.ss++;return ret;\n}\nvoid dfs(int x,int f=0)\n{\n\tstk[++top]=x;dep[x]=top;cnt+=2;\n\tvs[++tot]=x;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t{\n\t\tcnt--;\n\t\tif(g[x][i]==f)continue;\n\t\tif(!dep[g[x][i]])\n\t\t\tdfs(g[x][i],x);\n\t\telse if(dep[g[x][i]]<dep[x])\n\t\t{\n\t\t\tlen=0;\n\t\t\tfor(int j=dep[g[x][i]];j<=top;j++){cyc[++len]=stk[j];incyc[stk[j]]=1;}\n\t\t}\n\t}\n\ttop--;\n}\nvoid rdfs(int x,int f=0)\n{\n\tto[x]=f;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f&&!incyc[g[x][i]])\n\t\t\trdfs(g[x][i],x);\n}\n\nint calc()\n{\n\tfor(int i=1;i<=tot;i++){g2[vs[i]].clear();dgr[vs[i]]=0;}\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tfor(int j=0;j<(int)g[vs[i]].size();j++)\n\t\t{\n\t\t\tif(to[vs[i]]>g[vs[i]][j])\n\t\t\t{\n\t\t\t\tg2[vs[i]].pb(g[vs[i]][j]);\n\t\t\t\tdgr[g[vs[i]][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tpii ret=mp(1,0);\n\tfor(int i=1;i<=tot;i++)if(dgr[vs[i]]==0)ret=comb(ret,dfs2(vs[i]));\n\treturn ret.ff;\n}\nint main()\n{\n\tfac[0]=invf[0]=1;for(int i=1;i<200111;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinvf[200111-1]=power(fac[200111-1],mod-2);\n\tfor(int i=200111-2;i>=0;i--)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\t\n\tget1(n);\n\tfor(int i=1,x,y;i<=n+n;i++)\n\t{\n\t\tget2(x,y);\n\t\tg[x].pb(y+n);\n\t\tg[y+n].pb(x);\n\t}\n\tn<<=1;\n\t\n\tpii now=mp(1,0);\n\tfor(int _=1;_<=n;_++)\n\t{\n\t\tif(dep[_])continue;\n\t\ttot=0;dfs(_);\n\t\tif(cnt)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=len;i++)rdfs(cyc[i]);\n\t\tint sum=0;\n\t\tfor(int i=1;i<=len;i++)to[cyc[i]]=cyc[i%len+1];\n\t\tsum+=calc();\n\t\tfor(int i=1;i<=len;i++)to[cyc[i%len+1]]=cyc[i];\n\t\tsum+=calc();if(sum>=mod)sum-=mod;\n\t\tnow=comb(now,mp(sum,tot));\n\t}\n\t\n\tprintendl(now.ff);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll fac[200010],finv[200010];\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll merge(ll a,ll b,ll asz,ll bsz){\n  ll f=((finv[asz]*finv[bsz])%mod)*fac[asz+bsz]%mod;\n  return ((f*a)%mod)*b%mod;\n}\n\nint N;\nvector<int> g[200001],t[200010];\nbool vis1[200010],vis2[200010];\nll ecnt=0;\nvector<int> vs,loop;\nint nxt[200001],indeg[200010];\nll tsz[200010];\n\nll predfs(int v){\n  vs.push_back(v);\n  vis1[v]=true;\n  ll sz=1;\n  for(int nv : g[v]){\n    ecnt++;\n    if(vis1[nv])continue;\n    sz+=predfs(nv);\n  }\n  return sz;\n}\n\nint dfs(int v,int pre){\n  vis2[v]=true;\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    if(vis2[nv]){\n      loop.push_back(nv); return nv;\n    }\n    int tmp=dfs(nv,v);\n    if(tmp!=-1){\n      if(nv==tmp) return -1;\n      else{\n        loop.push_back(nv); return tmp;\n      }\n    }\n  }\n  return -1;\n}\n\nll dfs2(int v){\n  vis2[v]=true;\n  ll res=1;\n  tsz[v]=0;\n  for(int nv : t[v]){\n    ll tmp=dfs2(nv);\n    res=merge(res,tmp,tsz[v],tsz[nv]);\n    tsz[v]+=tsz[nv];\n  }\n  tsz[v]++;\n  return res;\n}\n\nvoid dfs3(int v,int pre){\n  nxt[v]=pre;\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    dfs3(nv,v);\n  }\n}\n\nll calc(int v){\n  int V=vs.size();\n  rep(i,V)vis2[vs[i]]=false;\n  dfs(v,-1);\n\n  int L=loop.size();\n\n  ll sum=0;\n  ll res1=1,res2=1;\n  { // +\n    rep(i,V)nxt[vs[i]]=-1;\n    rep(i,L){\n      nxt[loop[i]]=loop[(i+1)%L];\n      int crt=loop[i];\n      for(int nv : g[crt]){\n        if(nv==loop[(i+1)%L]||nv==loop[(i-1+L)%L])continue;\n        dfs3(nv,crt);\n      }\n    }\n    rep(i,V){\n      int crt=vs[i];\n      for(int nv : g[crt]){\n        if(nv<nxt[crt]){\n          t[crt].push_back(nv); indeg[nv]++;\n        }\n      }\n    }\n    rep(i,V)vis2[vs[i]]=false;\n    rep(i,V){\n      if(vis2[vs[i]]||indeg[vs[i]]>0)continue;\n      ll add=dfs2(vs[i]);\n      res1=merge(res1,add,sum,tsz[vs[i]]);\n      sum+=tsz[vs[i]];\n    }\n  }\n\n  sum=0;\n  { // +\n    rep(i,V){\n      nxt[vs[i]]=-1; indeg[vs[i]]=0;\n      t[vs[i]].clear(); tsz[vs[i]]=0;\n    }\n    rep(i,L){\n      nxt[loop[i]]=loop[(i-1+L)%L];\n      int crt=loop[i];\n      for(int nv : g[crt]){\n        if(nv==loop[(i+1)%L]||nv==loop[(i-1+L)%L])continue;\n        dfs3(nv,crt);\n      }\n    }\n    rep(i,V){\n      int crt=vs[i];\n      for(int nv : g[crt]){\n        if(nv<nxt[crt]){\n          t[crt].push_back(nv); indeg[nv]++;\n        }\n      }\n    }\n    rep(i,V)vis2[vs[i]]=false;\n    rep(i,V){\n      if(vis2[vs[i]]||indeg[vs[i]]>0)continue;\n      ll add=dfs2(vs[i]);\n      res2=merge(res2,add,sum,tsz[vs[i]]);\n      sum+=tsz[vs[i]];\n    }\n  }\n\n  return (res1+res2)%mod;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  fac[0]=1;\n  rep(i,200000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,200001)finv[i]=mod_pow(fac[i],mod-2);\n\n  cin>>N;\n  rep(i,2*N){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    g[x].push_back(N+y);\n    g[N+y].push_back(x);\n  }\n\n  ll res=1;\n  ll sum=0;\n  rep(i,2*N){\n    if(vis1[i])continue;\n    vs.clear(); ecnt=0;\n    ll sz=predfs(i); ecnt/=2;\n    if(sz!=ecnt) res=0;\n    else res=merge(res,calc(i),sum,sz);\n    sum+=sz;\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3e5 + 5;\nconst LL mod = 1e9 + 7;\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], top;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  //cerr << x << \" -> \" << y << endl;\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n      break;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= top; i ++)\n    Fir[vertex[i]] = deg[vertex[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = top, i; u; u --) {\n    i = vertex[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = top, i = vertex[u]; u; u --, i = vertex[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  return res;\n}\n\nint main() {\n  pre();\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      top = 0;\n      dfs(k);\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      if (ans >= mod) ans -= mod;\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      tmp = tmp * C(p, top) % mod;\n      ans = ans * tmp % mod;\n      p -= top;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t200005\n#define P\t1000000007\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvector <int> a[MAXN], b[MAXN];\nint n, cnt, p[MAXN], cnte, x, y, size[MAXN], pr[MAXN];\nbool visited[MAXN], father[MAXN];\nlong long fac[MAXN], inv[MAXN], met[MAXN];\nlong long power(long long x, long long y) {\n\tif (y == 0) return 1;\n\tlong long tmp = power(x, y / 2);\n\tif (y % 2 == 0) return tmp * tmp % P;\n\telse return tmp * tmp % P * x % P;\n}\nlong long getc(long long x, long long y) {\n\treturn fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid init(int N) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tfac[i] = fac[i - 1] * i % P;\n\tinv[N] = power(fac[N], P - 2);\n\tfor (int i = N - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1) % P;\n}\nvoid dfs(int pos, int fa) {\n\tvisited[pos] = true;\n\tp[++cnt] = pos; cnte += a[pos].size();\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (!visited[a[pos][i]]) dfs(a[pos][i], pos);\n\t\telse if (a[pos][i] != fa) x = pos, y = a[pos][i]; \n}\nvoid work(int pos) {\n\tvisited[pos] = true;\n\tfor (unsigned i = 0; i < a[pos].size(); i++) {\n\t\tif (a[pos][i] == pr[pos]) continue;\n\t\tif (a[pos][i] < pr[pos]) {\n\t\t\tb[pos].push_back(a[pos][i]);\n\t\t\tfather[a[pos][i]] = true;\n\t\t}\n\t\tif (!visited[a[pos][i]]) {\n\t\t\tpr[a[pos][i]] = pos;\n\t\t\twork(a[pos][i]);\n\t\t}\n\t}\n}\nlong long dp(int pos) {\n\tsize[pos] = 0;\n\tlong long ans = 1;\n\tfor (unsigned i = 0; i < b[pos].size(); i++) {\n\t\tans = ans * dp(b[pos][i]) % P;\n\t\tsize[pos] += size[b[pos][i]];\n\t\tans = ans * getc(size[pos], size[b[pos][i]]) % P;\n\t}\n\tsize[pos]++;\n\treturn ans;\n}\nint main() {\n\tread(n); init(n * 2);\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\ta[x].push_back(y + n);\n\t\ta[y + n].push_back(x); \n\t}\n\tlong long ans = 1, all = 0;\n\tfor (int i = 1; i <= 2 * n; i++)\n\t\tif (!visited[i]) {\n\t\t\tcnt = cnte = 0; dfs(i, 0);\n\t\t\tif (cnt * 2 != cnte) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlong long tans = 0;\n\t\t\tb[0].clear();\n\t\t\tfor (int i = 1; i <= cnt; i++) {\n\t\t\t\tb[p[i]].clear(); pr[p[i]] = 0;\n\t\t\t\tfather[p[i]] = false;\n\t\t\t\tvisited[p[i]] = false;\n\t\t\t}\n\t\t\tpr[x] = y;\n\t\t\twork(x);\n\t\t\tfor (int i = 1; i <= cnt; i++)\n\t\t\t\tif (!father[p[i]]) b[0].push_back(p[i]);\n\t\t\ttans += dp(0);\n\t\t\tb[0].clear();\n\t\t\tfor (int i = 1; i <= cnt; i++) {\n\t\t\t\tb[p[i]].clear(); pr[p[i]] = 0;\n\t\t\t\tfather[p[i]] = false;\n\t\t\t\tvisited[p[i]] = false;\n\t\t\t}\n\t\t\tpr[y] = x;\n\t\t\twork(y);\n\t\t\tfor (int i = 1; i <= cnt; i++)\n\t\t\t\tif (!father[p[i]]) b[0].push_back(p[i]);\n\t\t\ttans += dp(0);\n\t\t\tall += cnt;\n\t\t\tans = ans * tans % P * getc(all, cnt);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m;\nvector<int>E[N];\n#define pb push_back\nvoid input()\n{\n\tint x,y;\n\tn=read<int>();\n\tFor(i,1,n<<1)\n\t{\n\t\tx=read<int>(),y=read<int>()+n;\n\t\tE[x].pb(y),E[y].pb(x);\n\t}\n}\nconst int mo=1e9+7;\nint ans,inv[N];\nint vis[N],edge;\nint node[N],cnt;\nint c[N],top;\nint fa[N];\nint stk[N],tp;\nvoid dfs1(int u,int pre)\n{\n\tnode[++cnt]=u;stk[++tp]=u,vis[u]=1,stk[tp+1]=0;\n\tedge+=(int)E[u].size();\n\tfor(int v:E[u])if(v^pre)\n\t{\n\t\tif(!vis[v])dfs1(v,u);\n\t\telse if(!top)\n\t\t{\n\t\t\twhile(stk[tp+1]!=v)vis[c[++top]=stk[tp--]]=2;\n\t\t\tc[0]=v;\n\t\t}\n\t}\n\t--tp;\n}\nvoid dfs2(int u,int pre)\n{\n\tfor(int v:E[u])if(v^pre&&vis[v]<2)\n\t{\n\t\tfa[v]=u;\n\t\tdfs2(v,u);\n\t}\n}\nvector<int>G[N];\nint d[N],sz[N];\nvoid dfs3(int u,int &res)\n{\n\tsz[u]=1;\n\tfor(int v:G[u])\n\t{\n\t\tdfs3(v,res);\n\t\tsz[u]+=sz[v];\n\t}\n\tres=1ll*res*inv[sz[u]]%mo;\n}\nint cal()\n{\n\tint res=1;\n\tFor(i,1,cnt)\n\t{\n\t\tres=1ll*res*i%mo;\n\t\td[node[i]]=0;\n\t\tG[node[i]].clear();\n\t}\n\tFor(i,1,cnt)\n\t{\n\t\tfor(int v:E[node[i]])if(v<fa[node[i]])\n\t\t{\n\t\t\tG[node[i]].pb(v);d[v]++;\n\t\t}\n\t}\n\tFor(i,1,cnt)if(!d[node[i]])dfs3(node[i],res);\n\treturn res;\n}\nvoid init(int st)\n{\n\tint res=0;\n\tcnt=top=tp=edge=0;\t\n\tdfs1(st,0);\t\n\tif(edge!=(cnt<<1)){puts(\"0\");exit(0);}\n\tFor(i,1,top)dfs2(c[i],0);\t\n\tFor(i,1,top)fa[c[i-1]]=c[i];\n\tres=cal();\n\tFor(i,1,top)fa[c[i]]=c[i-1];\n\tres=(res+cal())%mo;\n\tans=1ll*ans*res%mo;\n\tFor(i,1,cnt)ans=1ll*ans*inv[i]%mo;\n\t//cerr<<cnt<<endl;\n}\nvoid work()\n{\n\tans=1;\n\tinv[0]=inv[1]=1;\n\tFor(i,2,n<<1)ans=1ll*ans*i%mo,inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,n<<1)if(!vis[i])init(i);\n\twrite(ans,'\\n');\n}\nint main()\n{\n\tfile();\n\tinput();\n\twork();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 1e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr, nos;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = nos = 0);\n\t\t// printf(\" findcr = %d, nos = %d\\n\", findcr, nos);\n\t\tif (!findcr || nos) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\t// assert(SZ(cir) > 1);\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) { ideg[u] = 0; T[u].clear(); }\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tauto lim = UB(DT[u], in[u]); \n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v] && !onlp[v]) {\t// find it!\n\t\t\t// printf(\" u = %d, v = %d\\n\", u, v);\n\t\t\tif (findcr) { nos = 1; return; }\n\t\t\twhile (top > 0 && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); if (top > 0) --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (!vis[v]) SCir(v, u);\n\t\t// if (findcr) return;\n\t} if (top > 0 && S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define mod 1000000007\n#define next nxt\n \nint n,x[N],y[N],next[N],p[N],h[N],q[N],s[N],cnt,cmt,cir;\nlong long fac[N],inv[N],ans;\nvector<int> v[N];\n \nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n \nvoid travel(int x,int pre){\n\th[x]=true;q[++cnt]=x;\n\tfor (int t=p[x];t;t=next[t],cmt++)\n\t\tif (!h[y[t]]) travel(y[t],x);\n\t\telse if (y[t]!=pre) cir=t;\n}\n \nvoid build(int x,int pre){\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (y[t]!=pre){\n\t\t\tif (y[t]<pre) v[x].push_back(y[t]),h[y[t]]=true;\n\t\t\tif (t/2!=cir/2) build(y[t],x);\n\t\t}\n}\n \nlong long solve(int x){\n\ts[x]=0;long long ans=1;\n\tfor (int i=0;i<(int)v[x].size();i++){\n\t\tans=ans*solve(v[x][i])%mod;\n\t\ts[x]+=s[v[x][i]];\n\t\tans=ans*C(s[x],s[v[x][i]])%mod;\n\t}\n\ts[x]++;return ans;\n}\n \nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();\n\tfor (int i=1;i<=2*n;i++){\n\t\tx[2*i]=y[2*i+1]=read();\n\t\ty[2*i]=x[2*i+1]=n+read();\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t\tnext[2*i+1]=p[x[2*i+1]];p[x[2*i+1]]=2*i+1;\n\t}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tans=fac[2*n];\n\tfor (int i=1;i<=2*n;i++)\n\t\tif (!h[i]){\n\t\t\tcnt=cmt=0;travel(i,0);\n\t\t\tif (cmt!=cnt*2) {printf(\"0\\n\");return 0;}\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),h[q[i]]=false;\n\t\t\tbuild(y[cir],x[cir]);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!h[q[i]]) v[0].push_back(q[i]),h[q[i]]=true;\n\t\t\tlong long tmp=solve(0);\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),h[q[i]]=false;\n\t\t\tbuild(x[cir],y[cir]);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!h[q[i]]) v[0].push_back(q[i]),h[q[i]]=true;\n\t\t\ttmp+=solve(0);\n\t\t\t\n\t\t\tans=ans*tmp%mod*inv[cnt]%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=200005,mod=1e9+7;\nusing namespace std;\nbool vis[N],instk[N],f,in_cir[N],r[N];\nint n,top,val[N],par[N],size[N],p[N],inv[N];\ntemplate<typename T> inline bool chkmin(T a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T a, T b) { return a < b ? a = b, 1 : 0; }\nstruct Edge{\n    int v, w;\n    Edge() { }\n    Edge(int v, int w) : v(v), w(w) { }\n} ;\npair<int, int> stk[N];\nvector<pair<int, int> > circle;\nvector<int> node;\nvector<Edge> g[N];\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*1ll*x%mod)\n\t\tif (y&1) ans=ans*1ll*x%mod;\n\treturn ans;\n}\nint C(int x,int y){\n\treturn p[x]*1ll*inv[y]%mod*inv[x-y]%mod;\n}\nvoid init(){\n\tp[0]=1;\n\tfor (int i=1;i<=n;i++) p[i]=1ll*p[i-1]*1ll*i%mod;\n\tinv[n]=ksm(p[n],mod-2);\n\tfor (int i=n;i>=1;i--) inv[i-1]=1ll*inv[i]*i%mod;\n}\nvoid dfs_circle(int x, int fa, int edge)\n{\n    if (f) return;\n    stk[++top]=make_pair(x,edge);\n    instk[x]=1;\n    for (auto E:g[x]){\n        int u=E.v, w=E.w;\n        if (u==fa) continue;\n        if (!instk[u]) dfs_circle(u,x,w);\n        else{\n            int t=u;\n            do{\n                u=stk[top].first;\n                in_cir[u]=1;\n                circle.push_back(stk[top--]);\n            } while (u!=t);\n            circle.back().second=w;\n            f=1;\n            return;\n        }\n        if (f) return;\n    }\n    instk[x] = 0;\n    top--;\n}\n\nvoid dfs1(int x, int fa){\n    vis[x]= 1;\n    node.push_back(x);\n    for (auto E:g[x]){\n        int u=E.v, w=E.w;\n        if (u!=fa and !in_cir[u]){\n            val[u]=w;\n            dfs1(u, x);\n        }\n    }\n}\n\nint dfs2(int x){\n    int ret=1;\n    for (auto E:g[x]){\n        int u=E.v;\n        if (par[u]!=x) continue;\n        int t=dfs2(u);\n\t\tsize[x]+=size[u];\n        ret=1ll*ret*t%mod*C(size[x], size[u])%mod;\n    }\n    size[x]++;\n    return ret;\n}\n\nint calc(){\n    for (int u:node){\n        size[u] = 0;\n        par[u] = 0;\n    }\n    for (int u:node)\n        for (auto E:g[u]){\n            int v = E.v, w = E.w;\n            if (w < val[u]) par[v] = u;\n        }\n    int SIZE = 0, ans = 1;\n    for (int u:node)\n        if (!par[u]){\n            int t=dfs2(u);\n\t\t\tSIZE += size[u];\n            ans=1ll*ans*t%mod*C(SIZE, size[u])%mod;\n        }\n    return ans;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tn<<=1;\n\tinit(); \n\tint x,y;\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d%d\",&x,&y);\n        g[x].emplace_back(y+n/2,x+y);\n        g[y+n/2].emplace_back(x,x+y);\n        r[x]=r[y+n/2]=1;\n    }\n\tint cnt=0;\n    for (int i=1;i<=n;i++) cnt+=r[i];\n    if (cnt!=n){\n        puts(\"0\");\n        return 0;\n    }\n    int now=0,ans=1;\n    for (int i = 1; i <= n && ans; ++i){\n        if (!vis[i]){\n            int cur=0;\n            top=0;\n            f=0;\n            circle.clear();\n            dfs_circle(i, 0, 0);\n            node.clear();\n            for (auto j:circle) dfs1(j.first, 0);\n            for (auto j:circle) val[j.first]=j.second;\n            cur=(cur+calc())%mod; \n\n            circle.push_back(circle[0]);\n            for (int j=1;j<circle.size();++j)\n                val[circle[j].first]=circle[j-1].second;\n            cur=(cur+calc())%mod; \n\t\t\tnow+=node.size();\n            ans=1ll*ans*cur%mod*C(now,node.size())%mod;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<double, double> pdd;\n\nconst int MOD = 1e9 + 7;\n\nvector <int> E[200020];\nint deg[200020];\nint N;\n\nint p[200020]; int Find(int x) { return p[x] == x ? x : p[x] = Find(p[x]); }\nint z[200020];\nvector <int> C[200020];\nll ans;\nll F[200020];\nll IF[200020];\n\nint pw(int x, int y = MOD - 2) {\n\tint res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = (ll)res * x % MOD;\n\t\tx = (ll)x * x % MOD;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint chk[200020];\n\nvoid dfs2(int x, vector <int> &u) {\n\tu.pb(x);\n\tchk[x] = 1;\n\tfor(int e : E[x]) if(deg[e] > 0 && chk[e] == 0) dfs2(e, u);\n}\n\nint In[200020];\n\nvector <int> E2[200020];\n\nll Get(vector<int> &a) {\n\tint sum = 0;\n\tfor(int e : a) sum += e;\n\tll res = F[sum];\n\tfor(int e : a) res = res * IF[e] % MOD;\n\treturn res;\n}\n\nll TT;\nint dfs3(int x, int fa) {\n\tchk[x] = 2;\n\tvector <int> v;\n\tint res = 1;\n\tfor(int e : E2[x]) if(e != fa) {\n\t\tif(chk[e] == 2) {\n\t\t\treturn -1;\n\t\t}\n\t\tint t = dfs3(e, x);\n\t\tif(t == -1) return -1;\n\t\tv.pb(t);\n\t\tres += t;\n\t}\n\tTT = TT * Get(v) % MOD;\n\treturn res;\n}\n\nvoid solve(){\n\tF[0] = 1;\n\tfor(int i=1;i<200020;i++) F[i] = (ll)i * F[i-1] % MOD;\n\tIF[200019] = pw((int)F[200019]);\n\tfor(int i=200018;i>=0;i--) IF[i] = (ll)(i+1) * IF[i+1] % MOD;\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N+N;i++) p[i] = i;\n\tfor(int i=1;i<=N+N;i++) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tE[x].pb(N + y);\n\t\tE[N + y].pb(x);\n\t\tp[Find(N+y)] = Find(x);\n\t}\n\tfor(int i=1;i<=N+N;i++) z[Find(i)]++;\n\tfor(int i=1;i<=N+N;i++) C[Find(i)].pb(i);\n\tfor(int i=1;i<=N+N;i++) deg[i] = sz(E[i]);\n\tqueue <int> que;\n\tfor(int i=1;i<=N+N;i++) if(deg[i] == 0) {\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tfor(int i=1;i<=N+N;i++) if(deg[i] == 1) {\n\t\tque.push(i);\n\t}\n\twhile(!que.empty()) {\n\t\tint t = que.front(); que.pop();\n\t\tfor(int e : E[t]) {\n\t\t\tif(deg[e] > 0) {\n\t\t\t\t--deg[e]; --deg[t];\n\t\t\t\tIn[t] = e;\n\t\t\t\tif(deg[e] == 1) que.push(e);\n\t\t\t}\n\t\t}\n\t}\n\tans = F[N+N];\n\tfor(int i=1;i<=N+N;i++) ans = ans * IF[z[i]] % MOD;\n\t\n\tint deg2[200020] = {};\n\t\n\tfor(int i=1;i<=N+N;i++) if(sz(C[i])) {\n\t\tint r = -1;\n\t\tfor(int e : C[i]) {\n\t\t\tif(deg[e] > 0) { r = e; break; }\n\t\t}\n\t\tvector <int> cyc;\n\t\tdfs2(r, cyc);\n\t\tint m = sz(cyc);\n\t\tfor(int e : C[i]) chk[e] = 1;\n\t\t\n\t\tll sum = 0;\n\t\t\n\t\tfor(int i=0;i<m;i++) In[cyc[i]] = cyc[(i+1)%m];\n\t\t\n\t\tfor(int e : C[i]) {\n\t\t\tfor(int f : E[e]) {\n\t\t\t\tif(In[f] > e) E2[f].pb(e), deg2[e]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tll tans = 1;\n\t\tvector <int> v;\n\t\tint ok = 1;\n\t\tfor(int e : C[i]) {\n\t\t\tif(chk[e] == 1 && deg2[e] == 0) {\n\t\t\t\tTT = 1;\n\t\t\t\tint x = dfs3(e, -1);\n\t\t\t\tif(x == -1) ok = 0;\n\t\t\t\telse v.pb(x), tans = tans * TT % MOD;\n\t\t\t}\n\t\t}\n\t\ttans = tans * Get(v) % MOD;\n\t\tfor(int e : C[i]) if(chk[e] == 1) ok = 0;\n\t\tif(ok == 0) tans = 0;\n\t\tsum = (sum + tans) % MOD;\n\t\t\n\t\tfor(int e : C[i]) E2[e].clear(), chk[e] = 1, deg2[e] = 0;\n\t\t\n\t\tfor(int i=0;i<m;i++) In[cyc[i]] = cyc[(i+m-1)%m];\n\t\t\n\t\tfor(int e : C[i]) {\n\t\t\tfor(int f : E[e]) {\n\t\t\t\tif(In[f] > e) E2[f].pb(e), deg2[e]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\ttans = 1;\n\t\tv.clear();\n\t\tok = 1;\n\t\tfor(int e : C[i]) {\n\t\t\tif(chk[e] == 1 && deg2[e] == 0) {\n\t\t\t\tTT = 1;\n\t\t\t\tint x = dfs3(e, -1);\n\t\t\t\tif(x == -1) ok = 0;\n\t\t\t\telse v.pb(x), tans = tans * TT % MOD;\n\t\t\t}\n\t\t}\n\t\ttans = tans * Get(v) % MOD;\n\t\tfor(int e : C[i]) if(chk[e] == 1) ok = 0;\n\t\tif(ok == 0) tans = 0;\n\t\tsum = (sum + tans) % MOD;\n\t\t\n\t\tfor(int e : C[i]) E2[e].clear(), chk[e] = 1;\n\t\tans = ans * sum % MOD;\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\t// printf(\"Case #%d: \", tc);\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    //ios::sync_with_stdio(false); cin.tie(nullptr);\n    int A,B; cin >> A >> B;\n    int N = A + B;\n    while (!((B+1)*B > N+1));\n    cout << \"Impossible\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200100\n#define mod 1000000007\nusing namespace std;\nstruct edge{\n\tint r,nxt;\n}e[maxn<<1];\nint vis[maxn],q[maxn],head[maxn],esz,dp[maxn];\nvector<int>used;\nint a[maxn],eg,dt,sz[maxn],b[maxn],n,f[maxn],fa[maxn],ans=1,fac[maxn],inv[maxn];\nint qpow(int a,int b){\n\tint ans=1,tmp=a;\n\tfor(;b;b>>=1,tmp=1ll*tmp*tmp%mod)\n\t\tif(b&1)ans=1ll*ans*tmp%mod;\n\treturn ans;\n}\nint C(int x,int y){\n\tif(x<0||x>y)return 0;\n\treturn 1ll*fac[y]*inv[x]%mod*inv[y-x]%mod;\n}\nint find(int x){\n\treturn x==f[x]?x:f[x]=find(f[x]);\n}\nint calc(int u,int to){\n\tif(sz[u])return sz[u];\n\tsz[u]=1;\n\tfor(int t=head[u];t;t=e[t].nxt)if(e[t].r<to)\n\t\tcalc(e[t].r,u),sz[u]+=sz[e[t].r];\n\treturn sz[u];\n}\nvoid dfs(int u,int f){\n\tq[++dt]=u,vis[u]=1;\n\tfor(int t=head[u];t;t=e[t].nxt,eg++)if(e[t].r!=f)\n\t\tif(!vis[e[t].r])dfs(e[t].r,u);\n}\nvoid init(int u,int f,int fz){\n\tfa[u]=f;\n\tfor(int t=head[u];t;t=e[t].nxt)if(e[t].r!=f&&e[t].r!=fz)\n\t\tinit(e[t].r,u,fz);\n}\nint solve(int bg,int ed){\n\tinit(bg,0,bg),fa[bg]=ed;\n\tfor(int i=1;i<=dt;++i)dp[q[i]]=sz[q[i]]=0;\n\tint ret=1;\n\tfor(int i=1;i<=dt;++i)\n\t\tret=1ll*ret*inv[calc(q[i],fa[q[i]])]%mod;\n\treturn ret;\n}\nvoid addedge(int u,int v){\n\te[++esz].r=v;e[esz].nxt=head[u];head[u]=esz;\n\te[++esz].r=u;e[esz].nxt=head[v];head[v]=esz;\n}\nint main(){\n\tscanf(\"%d\",&n),fac[0]=inv[0]=1;\n\tfor(int i=1;i<=n*2;++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n*2]=qpow(fac[n*2],mod-2);\n\tfor(int i=n*2-1;i>=1;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod,inv[i+1]=1ll*fac[i]*inv[i+1]%mod;\n\t\n\tfor(int i=1;i<=n*2;++i)scanf(\"%d%d\",&a[i],&b[i]),b[i]+=n,addedge(a[i],b[i]);\n\tfor(int i=1;i<=n*2;++i)f[i]=i;\n\tint sum=n*2;\n\tfor(int i=1;i<=n*2;++i){\n\t\tans=1ll*ans*i%mod;\n\t\tif(find(a[i])==find(b[i])){\n\t\t\tdt=0,eg=0,dfs(a[i],0);\n\t\t\tif(dt*2!=eg)return puts(\"0\"),0;\n//\t\t\tprintf(\"[%d,%d]\",dt,sum);\n\t\t\tans=1ll*ans*(solve(a[i],b[i])+solve(b[i],a[i]))%mod;\n\t\t\tsum-=dt;\n\t\t} else {\n\t\t\tf[find(a[i])]=find(b[i]);\n\t\t}\n\t}\n//\tprintf(\"[%d]\",sum);\n\tif(sum!=0)puts(\"0\");\n\telse printf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 2e5 + 5, mo = 1e9 + 7 ;\nusing namespace std ;\n\nbool vis[N] ;\nint opt[N], d[N], sz[N], f[N], q[N] ;\nint n, e, ter[N << 1], nxt[N << 1], lnk[N], fac[N], inv[N], sum_ave, sum_sz ;\n\nvoid add(int x, int y) {\n\tter[++ e] = y, nxt[e] = lnk[x], lnk[x] = e, ++ d[x] ;\n}\n\nint mul(int a, int b) {\n\tint ans = 1, w = a % mo ;\n\tfor ( ; b; b /= 2) {\n\t\tif (b & 1) ans = (ll) ans * w % mo ;\n\t\tw = (ll) w * w % mo ;\n\t}\n\treturn ans ;\n}\n\nint C(int x, int y) {\n\treturn (ll) fac[x] * inv[y] % mo * inv[x - y] % mo ;\n}\n\nvoid upd(int &x, int y) {\n\tx = (x + y) % mo ;\n}\n\nvoid dfs(int p, int las, int rt) {\n\tbool flg = true ;\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las && ter[i] != rt) dfs(ter[i], p, rt), flg = false ;\n\tif (flg) {\n\t\tsz[p] = f[p] = 1 ;\n\t\treturn ;\n\t}\n\tf[p] = 1, sz[p] = 0 ;\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las && ter[i] != rt) {\n\t\tint v = ter[i] ;\n\t\tif (v < las) {\n\t\t\tf[p] = (ll) f[p] * C(sz[p] + sz[v], sz[v]) % mo * f[v] % mo ;\n\t\t\tsz[p] += sz[v] ;\n\t\t} else {\n\t\t\tsum_ave = (ll) sum_ave * C(sum_sz + sz[v], sz[v]) % mo * f[v] % mo ;\n\t\t\tsum_sz += sz[v] ;\n\t\t}\n\t}\n\t++ sz[p] ;\n}\n\nvoid solve(int x, int &_sz, int &ret) {\n\tint he = 0, ta = 1, tot = 0 ; ret = 0 ;\n\tq[1] = x, vis[x] = false ;\n\tfor ( ; he != ta ; ) {\n\t\tint u = q[++ he] ;\n\t\tfor (int i = lnk[u] ; i; i = nxt[i]) if (vis[ter[i]]) {\n\t\t\tvis[ter[i]] = false ;\n\t\t\tq[++ ta] = ter[i] ;\n\t\t}\n\t}\n\tq[0] = ta ;\n\trep(i, 1, q[0]) {\n\t\tint u = q[i] ;\n\t\tfor (int j = lnk[u] ; j; j = nxt[j]) ++ tot ;\n\t}\n\tif (tot != q[0] * 2) { ret = 0 ; return ; }\n\the = 0, ta = 0 ;\n\trep(i, 1, q[0]) if (d[q[i]] == 1) opt[++ ta] = q[i] ;\n\tfor ( ; he != ta ; ) {\n\t\tint u = opt[++ he] ;\n\t\tfor (int i = lnk[u] ; i; i = nxt[i]) {\n\t\t\tint v = ter[i] ;\n\t\t\t-- d[v] ;\n\t\t\tif (!d[v]) continue ;\n\t\t\tif (d[v] == 1) opt[++ ta] = v ;\n\t\t}\n\t}\n\tint k = 0, tmp[5] = {0} ;\n\trep(i, 1, q[0]) if (q[i] > k && d[q[i]] > 1) k = q[i] ;\n\tfor (int i = lnk[k] ; i; i = nxt[i]) if (d[ter[i]] > 1) tmp[++ tmp[0]] = ter[i] ;\n\trep(i, 1, tmp[0]) {\n\t\tsum_ave = 1, sum_sz = 0 ;\n\t\tdfs(k, tmp[i], k) ;\n\t\tsum_ave = (ll) sum_ave * C(sum_sz + sz[k], sz[k]) % mo * f[k] % mo ;\n\t\tupd(ret, sum_ave) ;\n\t} \n\t_sz = q[0] ;\n}\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\tint x, y ;\n\trep(i, 1, n * 2) {\n\t\tscanf(\"%d%d\", &x, &y) ;\n\t\tadd(x, n + y), add(n + y, x) ;\n\t}\n\tn <<= 1 ;\n\tfac[0] = inv[0] = 1 ;\n\trep(i, 1, n) fac[i] = (ll) fac[i - 1] * i % mo ;\n\tinv[n] = mul(fac[n], mo - 2) ;\n\tfor (int i = n - 1 ; i ; -- i) inv[i] = (ll) inv[i + 1] * (i + 1) % mo ;\n\tint ans = 1, las = 0, _sz, ret ;\n\trep(i, 1, n) vis[i] = true ;\n\trep(i, 1, n) if (vis[i]) {\n\t\tsolve(i, _sz, ret) ;\n\t\tans = (ll) ans * ret % mo *  C(_sz + las, _sz) % mo ;\n\t\tlas += _sz ;\n\t}\n\tprintf(\"%d\\n\", ans) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 2e+5+5;\nconst int mo = 1e+9+7;\n\nint n;\nstruct edge{\n\tint x,nxt;\n}e[N*2];\nint h[N],tot;\nint r[N];\nbool vis[N];\nint he,ta,k,sum;\nint que[N],cir[N],m;\nLL js[N],inv[N];\nint fa[N],dep[N];\nbool bz[N];\nLL ans;\nint xx[N],yy[N],kx,ky;\nint to[N],a[N],pk;\nint lef[N],rig[N];\nint siz[N];\n\nvoid inse(int x,int y){e[++tot].x=y;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid getto(int st){\n\tint qu[N],he=0,ta=1;\n\tqu[1]=st;\n\twhile(he<ta){\n\t\tint x=qu[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (!bz[e[p].x]&&!to[e[p].x]){\n\t\t\tto[e[p].x]=x;\n\t\t\tqu[++ta]=e[p].x;\n\t\t}\n\t}\n}\n\nLL solve_tree(int x){\n\tsiz[x]=1;\n\tLL tmp=1;\n\tfor(int y=lef[x];y;y=rig[y]){\n\t\ttmp=tmp*solve_tree(y)%mo;\n\t\tsiz[x]+=siz[y];\n\t\ttmp=tmp*inv[siz[y]]%mo;\n\t}\n\ttmp=tmp*js[siz[x]-1]%mo;\n\treturn tmp;\n}\n\nLL solve(){\n\tfo(i,1,k)r[que[i]]=lef[que[i]]=rig[que[i]]=0;\n\tfo(i,1,k){\n\t\tint x=que[i];\n\t\tif (x<to[to[x]]){\n\t\t\trig[x]=lef[to[x]];\n\t\t\tlef[to[x]]=x;\n\t\t\tr[x]=1;\n\t\t}\n\t}\n\tLL val=1;\n\tfo(i,1,k)\n\tif (!r[que[i]]){\n\t\tLL tmp=solve_tree(que[i]);\n\t\tval=val*tmp%mo*inv[siz[que[i]]]%mo;\n\t}\n\tval=val*js[k]%mo;\n\treturn val;\n}\n\nvoid bfs(int st){\n\the=0,ta=1;\n\tvis[que[1]=st]=dep[st]=1;\n\tsum=0;\n\twhile(he<ta){\n\t\tint x=que[++he];\n\t\tsum+=r[x];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (!vis[e[p].x]){\n\t\t\tfa[e[p].x]=x;\n\t\t\tdep[e[p].x]=dep[x]+1;\n\t\t\tvis[que[++ta]=e[p].x]=1;\n\t\t}\n\t}\n\tk=ta;\n\tsum/=2;\n\tif (sum!=k){ans=0;return;}\n\tint keyx=0,keyy;\n\tfo(i,1,k){\n\t\tint x=que[i];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (fa[e[p].x]!=x&&fa[x]!=e[p].x)keyx=x,keyy=e[p].x;\n\t\tif (keyx)break;\n\t}\n\tkx=ky=1;\n\txx[1]=keyx;yy[1]=keyy;\n\twhile(keyx!=keyy){\n\t\tif (dep[keyx]>dep[keyy])xx[++kx]=keyx=fa[keyx];\n\t\telse yy[++ky]=keyy=fa[keyy];\n\t}\n\tpk=kx+ky-1;\n\tfo(i,1,kx)a[i]=xx[i];\n\tfo(i,1,ky)a[pk-i+1]=yy[i];\n\tLL tmp=0;\n\tfo(i,1,pk)bz[a[i]]=1;\n\tfo(i,1,pk){\n\t\tto[a[i]]=a[i%pk+1];\n\t\tgetto(a[i]);\n\t}\n\ttmp=solve();\n\tfo(i,1,pk)to[a[i%pk+1]]=a[i];\n\ttmp=(tmp+solve())%mo;\n\tans=ans*tmp%mo;\n\tans=ans*inv[k]%mo;\n}\n\nint main(){\n\tn=get()*2;\n\tjs[0]=inv[0]=js[1]=inv[1]=1;\n\tfo(i,2,n)js[i]=js[i-1]*i%mo,inv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;\n\tfo(i,1,n)inv[i]=inv[i]*inv[i-1]%mo;\n\tfo(i,1,n){\n\t\tint x=get(),y=get()+n/2;\n\t\tinse(x,y),inse(y,x);\n\t\tr[x]++,r[y]++;\n\t}\n\tans=1;\n\tfo(i,1,n)\n\tif (!vis[i])bfs(i);\n\tans=ans*js[n]%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nchar buf[1 << 20], *p1, *p2;\n#define getchar() ((p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)\n\ntemplate<typename T>\nvoid read(T &x) \n{\n\tx = 0;\n\tint f = 1; char c = getchar();\n\twhile (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }\n\twhile (isdigit(c)) { x = x * 10 + c - 48; c = getchar(); }\n\tx *= f;\n}\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G, loop;\nint dfn[MAXN], fa[MAXN], s, t, cnt = 0, edge = 0;\nvoid GetLoop(int x) // 找环 \n{\n\tG.push_back(x); // 森林中的一棵树 \n\tdfn[x] = ++cnt;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == fa[x])\n\t\t\tcontinue;\n\t\tif (dfn[y]) \n\t\t{\n\t\t\tif (dfn[y] < dfn[x]) continue;\n\t\t\tloop.push_back(y);\n\t\t\tfor (; y != x; y = fa[y])\n\t\t\t\tloop.push_back(fa[y]);\n\t\t}\n\t\telse { fa[y] = x; GetLoop(y); }\n\t}\n} \n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x, int Fa) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == Fa) continue;\n\t\tDfs(y, x);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[cnt];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i, 0);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tread(n);\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!dfn[i])\n\t\t{\n\t\t\tcnt = edge = 0;\n\t\t\tGetLoop(i);\n\t\t\tif (cnt << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\ts = loop[0], t = loop[loop.size() - 1]; // 环的起点、终点 \n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tloop.clear();\n\t\t\tG.clear();\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\to=0;int xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x){\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 201000;\nstruct Edge {int v, nxt;} a[N*4];\nint head[N], Head[N], indeg[N];\nint sz[N], pr[N];\nbool vis[N];\nint n, _;\n\ninline void add(int x, int y, int*arr) {\n\ta[++_].v = y, a[_].nxt = arr[x], arr[x] = _;\n}\n\nconst int p = 1e9+7;\nint fac[N], ifac[N], inv[N];\n\nint st[N], tp;\n#define FID(i) for(int id=1,i;i=st[id],id<=tp;++id)\n\nint X, Y;\nint et, pt;\n\nvoid bfs(int x, int las) {\n\tvis[st[++tp] = x] = true, ++pt;\n\tfor(int i=head[x];i;++et,i=a[i].nxt)\n\t\tif(!vis[a[i].v]) bfs(a[i].v, x);\n\t\telse if(a[i].v != las) X = x, Y = a[i].v;\n}\n\nvoid tfs(int x, int las) {\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tif(a[i].v != las and a[i].v != X)\n\t\t\tpr[a[i].v] = x, tfs(a[i].v, x);\n}\n\nvoid dfs(int x, int las) {\n\tsz[x] = 1;\n\tfor(int i=Head[x];i;i=a[i].nxt)\n\t\tif(a[i].v != las)\n\t\t\tdfs(a[i].v, x), sz[x] += sz[a[i].v];\n}\n\nint solve() {\n\ttfs(X, Y);\n\tpr[X] = Y;\n\tFID(i) Head[i] = indeg[i] = 0;\n\tFID(x) for(int i=head[x];i;i=a[i].nxt)\n\t\tif(a[i].v < pr[x]) add(x, a[i].v, Head), ++indeg[a[i].v];\n\t\n\tFID(i) if(!indeg[i]) dfs(i, i);\n\tint Ans = fac[pt];\n\tFID(i) Ans = (ll)Ans * inv[sz[i]]%p;\n\treturn Ans;\n}\n\nint main() {\n\tread(n);\n\tfor(int i=1,x,y;i<=(n<<1);++i) {\n\t\tread(x), read(y), y += n;\n\t\tadd(x, y, head), add(y, x, head);\n\t}\n\t\n\tn <<= 1;\n\tfac[0] = fac[1] = inv[0] = inv[1] = ifac[0] = ifac[1] = 1;\n\tfor(int i=2;i<=n;++i) {\n\t\tfac[i] = (ll)fac[i-1] * i%p;\n\t\tinv[i] = (ll)(p-p/i) * inv[p%i]%p;\n\t\tifac[i] = (ll)ifac[i-1] * inv[i]%p;\n\t}\n\t\n\tint Ans = fac[n];\n\tfor(int i=1;i<=n;++i)\n\t\tif(!vis[i]) {\n\t\t\ttp = pt = et = 0;\n\t\t\tbfs(i, i);\n\t\t\tAns = (ll)Ans * ifac[pt]%p;\n\t\t\tif((pt << 1) != et) return puts(\"0\"), 0;\n\t\t\tint res = solve();\n\t\t\tX ^= Y, Y ^= X, X ^= Y;\n\t\t\tres += solve();\n\t\t\tAns = (ll)Ans * res%p;\n\t\t}\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define int LL\n#define P pair<int,int>\n#define fi first\n#define se second\nconst LL N=2e5+10;\nconst LL mod=1e9+7;\nconst LL inf=0x3f3f3f;\nconst double eps=1e-9;\nusing namespace std;\ntemplate<typename tp> inline void read(tp &x)\n{\n    x=0;char c=getchar();\n    bool f=0; for(; c<'0'||c>'9'; f|=(c=='-'),c = getchar());\n    for(; c>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0',c = getchar());\n    if(f) x=-x;\n}\nP wei[N<<1];\nmap<P,int> Map;\nvector<P> idd;\nvector<int> line[N],row[N],vec,node;\n  \nint n,found;\nint head[N<<1],cnt;\nint fa[N<<1],side[N<<1],vis[N<<1];\nint tou[N<<1],num;\nLL siz[N<<1];\n  \nstruct Node { int next,to,id;} edge[N<<3];\nstruct E {int next,to;} e[N<<3];\n  \nvoid add(int from,int to,int id) { edge[++cnt]= {head[from],to,id}; head[from]=cnt;}\nvoid insert(int from,int to,int id) { add(from,to,id); add(to,from,id);}\nvoid jia(int from,int to) {e[++num]= {tou[from],to}; tou[from]=num;}\nP calc(int x,int y) { if(x>y) swap(x,y); y-=n; return P(x,y);}\nLL KSM(LL a,LL b,LL ret=1) { while(b) { if(b&1) ret=ret*a%mod; a=a*a%mod; b>>=1; } return ret;}\nint ask(P x) { return lower_bound(idd.begin(),idd.end(),x)-idd.begin()+1;}\n \nvoid dfs(int now,int fath)\n{\n    vis[now]=1;\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        if(found==1) return ;\n        int to=edge[i].to;\n        if(to==fath) continue;\n        if(vis[to])\n        {\n            int flag=now;\n            while(flag!=to)\n            {\n                vec.push_back(flag);\n                flag=fa[flag];\n            }\n            vec.push_back(to);\n            found = 1;\n            return ;\n        }\n        fa[to]=now;\n        dfs(to,now);\n    }\n}\nvoid dfs_side_other(int now,int fa)\n{\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        int to=edge[i].to;\n        if(vis[to]==2||to==fa)\n            continue;\n        vis[to]=1;\n        if(to>n) side[edge[i].id]=2;\n        else side[edge[i].id]=1;\n        node.push_back(edge[i].id);\n        dfs_side_other(to,now);\n    }\n}\nLL dfs_size(int now)\n{\n    if(siz[now]) return siz[now];\n    siz[now]=1;\n    for(int i=tou[now]; i; i=e[i].next)\n    {\n        int to=e[i].to;\n        siz[now]+=dfs_size(to);\n    }\n    return siz[now];\n}\nvoid built()\n{\n    for(int i=0; i<node.size(); i++)\n    {\n        int x=wei[node[i]].fi,y=wei[node[i]].se;\n        if(side[node[i]]==1)\n        {\n            int pos=lower_bound(line[x].begin(),line[x].end(),y)-line[x].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(x,line[x][j])));\n        }\n        else\n        {\n            int pos=lower_bound(row[y].begin(),row[y].end(),x)-row[y].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(row[y][j],y)));\n        }\n    }\n}\nLL solve(int now)\n{\n    found = 0;\n    LL ret1=1,ret2=1;\n    vec.clear(), node.clear();\n    dfs(now,now);\n    for(int i=0; i<vec.size(); i++) vis[vec[i]]=2;\n    for(int i=0; i<vec.size(); i++) dfs_side_other(vec[i],vec[i]);\n    for(int i=0; i<vec.size()-1; i++)\n    {\n        side[ask(calc(vec[i],vec[i+1]))]=(vec[i+1]>n?1:2);\n        node.push_back(ask(calc(vec[i],vec[i+1])));\n    }\n    side[ask(calc(vec[vec.size()-1],vec[0]))]=(vec[0]>n?1:2);\n    node.push_back(ask(calc(vec[vec.size()-1],vec[0])));\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret1=ret1*KSM(dfs_size(node[i]),mod-2)%mod;\n    num=0;\n    for(int i=0; i<node.size(); i++) tou[node[i]]=0;\n    for(int i=vec.size()-1; i>0; i--)\n        side[ask(calc(vec[i],vec[i-1]))]=(vec[i-1]>n?1:2);\n    side[ask(calc(vec[0],vec[vec.size()-1]))]=(vec[vec.size()-1]>n?1:2);\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret2=ret2*KSM(dfs_size(node[i]),mod-2)%mod;\n    return ret1+ret2;\n}\nsigned main()\n{\n    read(n);\n    for(int i=1,x,y; i<=n*2; i++)\n    {\n        read(x),read(y);\n        idd.push_back(P(x,y));\n        line[x].push_back(y);\n        row[y].push_back(x);\n    }\n    sort(idd.begin(),idd.end());\n    for(int i=0;i<n*2;i++)\n    {\n        wei[i+1]=idd[i];\n        insert(idd[i].fi,idd[i].se+n,i+1);\n    }\n    for(int i=1; i<=n; i++)\n    {\n        sort(line[i].begin(),line[i].end()),\n        sort(row[i].begin(),row[i].end());\n        if(!line[i].size()||!row[i].size())\n            return 0*puts(\"0\");\n    }\n    LL ans=1;\n    for(int i=1; i<=n*2; i++)\n        if(!vis[i])\n            ans=ans*solve(i)%mod;\n    for(int i=1;i<=n*2;i++)\n        ans=ans*i*1LL%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int maxn=2e5+10;\nconst int mo=1e9+7;\n\nint n,root,Ans=1,tote=1;\nint fa[maxn],fw[maxn],tmp[maxn],fac[maxn],ifac[maxn];\nint FIR[maxn],TO[maxn<<1],NEXT[maxn<<1],W[maxn<<1];\nint vis[maxn];\nint q[maxn];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nvoid addedge(int u,int v,int w)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tW[tote]=w;\n\tFIR[u]=tote;\n}\n\nvoid dfs1(int u,int F)\n{\n\tif (vis[u]==1) {root=u; return;}\n\tvis[u]=1;\n\tq[++q[0]]=u;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (v==F) continue;\n\t\tdfs1(v,u);\n\t}\n}\n\nvoid dfs2(int u)\n{\n\tif (vis[u]==2) return;\n\tvis[u]=2;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (v==fa[u]) continue;\n\t\tfa[v]=u;\n\t\tfw[v]=w;\n\t\tdfs2(v);\n\t}\n}\n\nnamespace Tree{\n\tint n,fa[maxn],dp[maxn],sz[maxn];\n\tint tote,FIR[maxn],TO[maxn<<1],NEXT[maxn<<1];\n\n\tvoid addedge(int u,int v)\n\t{\n//\t\tprintf(\"%d----->%d\\n\",u,v);\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t\tfa[v]=u;\n\t}\n\n\tbool dfs(int u)\n\t{\n//\t\tprintf(\"u=%d\\n\",u);\n\t\tif (dp[u]) return 0;\n\t\tsz[u]=0;\n\t\tdp[u]=1;\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!dfs(v)) return 0;\n\t\t\tsz[u]+=sz[v];\n\t\t\tdp[u]=(LL)dp[u]*dp[v]%mo;\n\t\t\tdp[u]=(LL)dp[u]*ifac[sz[v]]%mo;\n\t\t}\n\t\tdp[u]=(LL)dp[u]*fac[sz[u]]%mo;\n\t\tsz[u]++;\n\t\treturn 1;\n\t}\n\n\tvoid solve(int &Ans)\n\t{\n\t\tint i,u;\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n\t\t\tif (!fa[u]) addedge(0,u);\n\t\t}\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n//\t\t\tprintf(\"%d : %d\\n\",u,fw[u]);\n\t\t}\n\n\t\tif (!dfs(0)) {Ans=0; return;}\n\t\t(Ans+=dp[0])%=mo;\n\n//\t\tprintf(\"Ans=%d\\nclear\\n\\n\\n\",Ans);\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t\tu=q[i],FIR[u]=fa[u]=dp[u]=sz[u]=0;\n\t\tFIR[0]=fa[0]=dp[0]=sz[0]=0;\n\t\ttote=0;\n\t}\n};\n\nvoid dfs3(int u)\n{\n\tif (vis[u]==3) return;\n\tvis[u]=3;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs3(v);\n\t}\n}\n\nvoid dfs4(int u)\n{\n\tif (vis[u]==4) return;\n\tvis[u]=4;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs4(v);\n\t}\n}\n\nint main()\n{\n\tint i,u,v;\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor (i=1;i<=n+n;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[n+n]=power(fac[n+n],mo-2);\n\tfor (i=n+n;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tfor (i=1;i<=n+n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,n+v,u+v);\n\t\taddedge(n+v,u,u+v);\n\t}\n\n\tfor (i=1;i<=n+n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tq[0]=0;\n\t\t\troot=0;\n\t\t\tdfs1(i,0);\n\t\t\tif (!root) {puts(\"0\"); return 0;}\n\t\t\tdfs2(root);\n\n\t\t\tint Sum=0;\n\n\t\t\tdfs3(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\ttmp[fa[u]]=fw[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\tfw[u]=tmp[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\n\t\t\tdfs4(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tAns=(LL)Ans*Sum%mo;\n//\t\t\tprintf(\"q0=%d\\n\",q[0]);\n\t\t\tAns=(LL)Ans*ifac[q[0]]%mo;\n\t\t}\n\tAns=(LL)Ans*fac[n+n]%mo;\n\tprintf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\n\nnamespace io {\n#define File(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n  const int SIZE = (1 << 21) + 1;\n  char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1;\n  inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);}\n  inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;}\n  inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();}\n  template<class T>\n  inline void read(T &x) {\n    char ch; int f = 1;\n    x = 0;\n    while(isspace(ch = getc()));\n    if(ch == '-') ch = getc(), f = -1;\n    do x = x * 10 + ch - '0'; while(isdigit(ch = getc()));\n    x *= f;\n  }\n  template<class T, class ...Args>\n  inline void read(T &x, Args&... args) {read(x); read(args...);}\n  template<class T>\n  inline void write(T x) {\n    static char stk[128];\n    int top = 0;\n    if(x == 0) {putc('0'); return;}\n    if(x < 0) putc('-'), x = -x;\n    while(x) stk[top++] = x % 10, x /= 10;\n    while(top) putc(stk[--top] + '0');\n  }\n  template<class T, class ...Args>\n  inline void write(T x, Args... args) {write(x); putc(' '); write(args...);}\n  inline void space() {putc(' ');}\n  inline void endl() {putc('\\n');}\n  struct _flush {~_flush() {flush();}} __flush;\n};\nusing io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc;\n\nconst int M = 1000000007;\ninline int add(int x, int y) {return x+y>=M ? x+y-M : x+y;}\ntemplate<class ...Args> inline int add(int x, int y, Args... args) {return add(add(x, y), args...);}\ninline int sub(int x, int y) {return x-y<0 ? x-y+M : x-y;}\ninline int mul(int x, int y) {return 1LL * x * y % M;}\ntemplate<class ...Args> inline int mul(int x, int y, Args... args) {return mul(mul(x, y), args...);}\ninline void inc(int &x, int y=1) {x += y; if(x >= M) x -= M;}\ninline void dec(int &x, int y=1) {x -= y; if(x < 0) x += M;}\ninline int power(int x, int y){\n  int res = 1;\n  for(; y; y>>=1, x = mul(x, x)) if(y & 1) res = mul(res, x);\n  return res;\n}\ninline int inv(int x){return power(x, M - 2);}\n\nconst int N = 400005;\nvector<int> G[N];\nint tfa[N];\nint indeg[N], siz[N];\nvector<int> circ, node;\n\nnamespace DSU {\nint fa[N], rk[N];\nbool circuit[N];\nint find(int x) {\n  if (!fa[x]) return x;\n  return fa[x] = find(fa[x]);\n}\nbool merge(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) {\n    if (circuit[x]) return false;\n    circuit[x] = true;\n    return true;\n  }\n  if (rk[x] < rk[y]) swap(x, y);\n  fa[y] = x, rk[x] += rk[x] == rk[y];\n  circuit[x] = circuit[x] || circuit[y];\n  return true;\n}\n}; // namespace DSU\n\nint fac[N], ifac[N];\nvoid pre(int n) {\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n  ifac[n] = inv(fac[n]);\n  for (int i = n - 1; i >= 0; --i) ifac[i] = mul(ifac[i + 1], i + 1);\n}\n\nbool vis[N];\nint from[N];\n\nvoid dfs(int x) {\n  vis[x] = true;\n  node.push_back(x);\n  for (int v : G[x]) {\n    if (v == from[x]) continue;\n    if (vis[v]) {\n      if (!circ.empty()) continue;\n      circ.push_back(v);\n      circ.push_back(x);\n      int t = from[x];\n      while (t != v) {\n        circ.push_back(t);\n        t = from[t];\n      }\n      continue;\n    }\n    from[v] = x;\n    dfs(v);\n  }\n}\nint fa[N];\nvoid dfs2(int x) {\n  for (int v : G[x]) {\n    if (fa[v]) continue;\n    fa[v] = x;\n    dfs2(v);\n  }\n}\nint topo_cnt() {\n  int res = 1;\n  queue<int> q;\n  for (int x : node) {\n    siz[x] = 1;\n    if (!indeg[x])\n      q.push(x);\n  }\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    res = mul(res, inv(siz[x]));\n    if (!tfa[x]) continue;\n    indeg[tfa[x]]--;\n    siz[tfa[x]] += siz[x];\n    if (indeg[tfa[x]] == 0)\n      q.push(tfa[x]);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  read(n);\n  pre(n * 2);\n  for (int i = 1; i <= n * 2; ++i) {\n    int x, y;\n    read(x, y);\n    G[x].push_back(n + y); G[n + y].push_back(x);\n    if (!DSU::merge(x, n + y)) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  for (int i = 1; i <= 2 * n; ++i)\n    sort(G[i].begin(), G[i].end());\n  int res = fac[n * 2];\n  for (int i = 1; i <= n * 2; ++i) {\n    int now = 0;\n    if (!vis[i]) {\n      node.clear();\n      circ.clear();\n      dfs(i);\n      int L = circ.size();\n      fa[circ[0]] = circ[L - 1];\n      for (int i = 1; i < L; ++i)\n        fa[circ[i]] = circ[i - 1];\n      for (int x : circ)\n        dfs2(x);\n      for (int x : node) {\n        for (int v : G[x]) {\n          if (v < fa[x])\n            tfa[v] = x, ++indeg[x];\n          else break;\n        }\n      }\n      now += topo_cnt();\n      for (int x : node)\n        tfa[x] = 0, indeg[x] = 0;\n      fa[circ[L - 1]] = circ[0];\n      for (int i = 0; i < L - 1; ++i)\n        fa[circ[i]] = circ[i + 1];\n      for (int x : node) {\n        for (int v : G[x])\n          if (v < fa[x]) tfa[v] = x, ++indeg[x];\n          else break;\n      }\n      now += topo_cnt();\n      now %= M;\n      res = mul(res, now);\n    }\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005; \nconst long long mod = 1000000007; \n\nusing namespace std;\n\nint n, T; \n\nbool oncir[N], vis[N]; \nint num, sum, cir[N], cur[N]; \n\nint tp, sta[N]; \nbool insta[N]; \n\nint match[N], ind[N], siz[N]; \nlong long f[N]; \n\nvector< int > G[N]; \nvector< int > S[N]; \n\nlong long fac[N], inv[N]; \n\nlong long Pow(long long a, long long e) {\n\tlong long ret=1, cnt=a;\n\twhile(e) {\n\t\tif(e & 1) ret = ret * cnt % mod;\n\t\tcnt = cnt * cnt % mod; \n\t\te >>= 1; \n\t} \n\treturn ret; \n}\n\nvoid prepare() {\n\tfac[1] = 1; \n\tfor(int i=2; i<=n; ++i) fac[i] = fac[i-1] * i % mod; \n\tinv[n] = Pow(fac[n], mod-2); \n\tfor(int i=n-1; i>=0; --i) inv[i] = inv[i+1] * (i+1) % mod;  \n}\n\nlong long C(int n, int m) {\n\treturn fac[n] * inv[n-m] % mod * inv[m] % mod; \n}\n\nvoid dfs_Circle(int u, int f) {\n\tif(insta[u]) {\n\t\tint now; \n\t\tdo {\n\t\t\tnow = sta[tp--];\n\t\t\tinsta[now] = 0; \n\t\t\tcir[++num] = now; \n\t\t\toncir[now] = 1; \n\t\t}while(now != u); \n\t\t++T; \n\t\treturn ; \n\t}\n\tvis[u] = 1; \n\tinsta[u] = 1; \n\tsta[++tp] = u; \n\tcur[++sum] = u; \n\tfor(int v : G[u]) {\n\t\tif(v == f || oncir[v]) continue; \n\t\tdfs_Circle(v, u); \n\t}\n\tinsta[u] = 0; \n\tsta[tp--] = 0; \n}\n\nvoid dfs_Tree(int u, int f) {\n\tmatch[u] = f; \n\tfor(int v : G[u]) {\n\t\tif(oncir[v] || v == f) continue; \n\t\tdfs_Tree(v, u); \n\t}\n}\n\nvoid dfs_calc(int u) {\n\tf[u] = 1; \n\tsiz[u] = 0; \n\tfor(int v : S[u]) {\n\t\tdfs_calc(v);\n\t\tsiz[u] += siz[v]; \n\t\tf[u] = 1ll * f[u] * f[v] % mod * C(siz[u], siz[v]) % mod; \n\t}\n\t++siz[u]; \n}\n\nlong long calc() {\n\tfor(int i=1; i<=sum; ++i) ind[cur[i]] = 0; \n\tfor(int i=1; i<=sum; ++i) {\n\t\tint u = cur[i];\n\t\tS[u].clear(); \n\t\tfor(int v : G[u]) {\n\t\t\tif(v == match[u]) break; \n\t\t\tS[u].push_back(v); \n\t\t\t++ind[v]; \n\t\t}\n\t}\n\tS[0].clear();\n\tfor(int i=1; i<=sum; ++i) \n\t\tif(!ind[cur[i]]) S[0].push_back(cur[i]);\n\tdfs_calc(0);\n\treturn f[0];  \n}\n\nint main() {\n\t\n\tint u, v; \n\t\n\tint psum=0; \n\tlong long ans = 1; \n\t\n\tcin >> n; \n\tfor(int i=1; i<=(n<<1); ++i) {\n\t\tcin >> u >> v;  \n\t\tG[u].push_back(v+n); \n\t\tG[v+n].push_back(u); \n\t}\n\t\n\tn <<= 1; \n\tfor(int i=1; i<=n; ++i) sort(G[i].begin(), G[i].end()); \n\t\n\tprepare(); \n\t\n\tfor(int i=1; i<=n; ++i) {\n\t\t\n\t\tif(vis[i]) continue; \n\t\t\n\t\tT = sum = num = tp = 0; \n\t\tdfs_Circle(i, 0); \n\t\t\n\t\tif(T > 1) {\n\t\t\tans = 0; \n\t\t\tbreak; \n\t\t}\n\t\t\n\t\tfor(int j=1; j<=num; ++j) dfs_Tree(cir[j], 0); \n\t\t\n\t\tlong long tmp = 0; \n\t\t\n\t\tfor(int j=2; j<=num; ++j) match[cir[j]] = cir[j-1]; \n\t\tmatch[cir[1]] = cir[num]; \n\t\ttmp += calc(); \n\t\t\n\t\tfor(int j=1; j<num; ++j)  match[cir[j]] = cir[j+1];\n\t\tmatch[cir[num]] = cir[1];\n\t\ttmp += calc(); \n\t\t\n\t\tpsum += sum; \n\t\tans = 1ll * ans * tmp % mod * C(psum, sum) % mod; \n\t\t\n\t}\n\t\n\tcout << ans << endl; \n\t\n\treturn 0; \n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,O=1000000007;\ninline int fpow(int x,int n){\n\tint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\nint nlst[N],ns,ecnt;\nint fac[N],invfac[N];\ninline void gmath(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=(lint)fac[i-1]*i%O;\n\t}\n\tinvfac[n]=inv(fac[n]);\n\tfor(int i=n;i>=1;i--){\n\t\tinvfac[i-1]=(lint)invfac[i]*i%O;\n\t}\n}\nnamespace G{\n\tconst int E=N<<1;\n\tint to[E],bro[E],head[N],e=0;\n\tint size[N],ringe;\n\tint edg[N];\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tvoid getring(int x){\n\t\tnlst[++ns]=x;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tecnt++;\n\t\t\tif((v=to[i])!=edg[x]){\n\t\t\t\tif(edg[v]){\n\t\t\t\t\tif(ringe==-1){\n\t\t\t\t\t\tringe=i;\n\t\t\t\t\t}else if(to[ringe]!=x){\n\t\t\t\t\t\tringe=-2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tedg[v]=x;\n\t\t\t\t\tgetring(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x){\n\t\tsize[x]=1;\n\t\tlint ans=1;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tans=ans*dfs(v)%O;\n\t\t\t\tans=ans*invfac[size[v]]%O;\n\t\t\t\tsize[x]+=size[v];\n\t\t\t}\n\t\t}\n\t\treturn ans*fac[size[x]-1]%O;\n\t}\n}\nint deg[N];\ninline int work2(){\n\tusing namespace G;\n\tfor(int i=1;i<=ns;i++){\n\t\tint x=nlst[i];\n\t\tdeg[x]=0;\n\t}\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tdeg[v]++;\n\t\t\t}\n\t\t}\n\t}\n\tlint ans=fac[ns];\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tif(deg[x]==0){\n\t\t\tans=ans*dfs(x)%O;\n\t\t\tans=ans*invfac[size[x]]%O;\n\t\t}\n\t}\n\treturn ans;\n}\ninline int work(int x){//kind*invfac[n]\n\tusing namespace G;\n\tns=0,ecnt=0;\n\tringe=-1;\n\tedg[x]=-1;\n\tgetring(x);\n\tif((ecnt>>1)!=ns)return 0;\n\tassert(ringe>=0);\n\tfor(int p=to[ringe],q=to[ringe^1];~p;swap(edg[p],q),swap(p,q));\n\tint ans=work2();\n\tfor(int p=to[ringe^1],q=to[ringe],tp=p;swap(edg[p],q),swap(p,q),p!=tp;);\n\treturn (lint)invfac[ns]*(ans+work2())%O;\n}\ninline int Main(){\n\tint n=ni,n2=n<<1;\n\tG::init();\n\tfor(int i=1;i<=n2;i++){\n\t\tG::add(ni,n+ni);\n\t}\n\tgmath(n<<1);\n\tlint ans=fac[n<<1];\n\tmemset(G::edg,0,sizeof(G::edg));\n\tmemset(G::size,0,sizeof(G::size));\n\tfor(int i=1;i<=n2;i++){\n\t\tif(G::edg[i]==0){\n\t\t\t(ans*=work(i))%=O;\n\t\t\tif(ans==0)return 0;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tprintf(\"%d\\n\",Main());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define int long long\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(u) for(int i=hd[u],v;v=e[i].v,i;i=e[i].n)\n#define REQ(u) for(int i=Hd[u],v;v=E[i].v,i;i=E[i].n)\nusing namespace std;\nconst int N=400400,M=N<<1,P=1e9+7;\nstruct edge{int n,v;}e[M],E[M];\nint n,m,u,v,fl,Fl,T,ans;\nint hd[N],in[N],vi[N],a[N],b[N],f[N],fa[N],du[N],sz[N],Hd[N];\nint iv[N],fc[N],vf[N];\nvector<int>ve;\nqueue<int>q;\nvoid add(int u,int v){e[++fl]=(edge){hd[u],v};hd[u]=fl;du[v]++;}\nvoid Add(int u,int v){E[++Fl]=(edge){Hd[u],v};Hd[u]=Fl;}\nvoid dfs0(int u){\n\tve.push_back(u);\n\tREP(u)if(in[v] && v!=fa[u]) fa[v]=u,dfs0(v);\n}\nvoid dfs1(int u){\n\tvi[u]=1;a[++T]=u;ve.push_back(u);\n\tREP(u) if(!vi[v]) dfs1(v);else if(in[v]) dfs0(v);\n}\nvoid dfs2(int u,int ff){\n\tREP(u)if(in[v] && v!=fa[u]){\n\t\tdfs2(v,u);\n\t\tif(ff>v) Add(u,v),b[v]=1;\n\t}\n}\nint dfs3(int u){\n\tint ret=1;sz[u]=f[u]=1;\n\tREQ(u) dfs3(v),f[u]=1ll*f[v]*f[u]%P,sz[u]+=sz[v];\n\tf[u]=1ll*f[u]*iv[sz[u]]%P;\n}\nint sol(){\n\tint ret=1;\n\tfor(int u:ve) Hd[u]=b[u]=0;Fl=0;\n\tFOR(j,1,T)if(a[j-1]>a[j+1]) Add(a[j],a[j+1]),b[a[j+1]]=1;\n\t//for(int u:ve){cout<<u<<':';REQ(u) cout<<v<<' ';cout<<'\\n';}\n\tFOR(j,1,T) dfs2(a[j],a[j-1]);\n\tfor(int u:ve)if(!b[u]) dfs3(u),ret=1ll*ret*f[u]%P;\n\treturn ret;\n}\nint work(int u){\n\tint ret=0;\n\tT=0;ve.clear();dfs1(u);\n\t//FOR(i,1,T) cout<<a[i]<<' ';cout<<'\\n';\n\ta[0]=a[T];a[T+1]=a[1];\n\t(ret+=sol())%=P;\n\treverse(a,a+T+2);\n\t(ret+=sol())%=P;\n\treturn ret;\n}\nsigned main(){\n\t//freopen(\"robot.in\",\"r\",stdin);\n\t//freopen(\"robot.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);m=2*n;\n\tiv[1]=fc[0]=vf[0]=1;\n\tFOR(i,2,m) iv[i]=1ll*(P-P/i)*iv[P%i]%P;\n\tFOR(i,1,m) fc[i]=1ll*fc[i-1]*i%P,vf[i]=1ll*vf[i-1]*iv[i]%P;\n\tFOR(i,1,m) scanf(\"%d%d\",&u,&v),add(u,v+n),add(v+n,u);\n\tFOR(i,1,m) if(!du[i]) return puts(\"0\"),0;\n\tFOR(i,1,m) if(du[i]==1) vi[i]=in[i]=1,q.push(i);\n\twhile(q.size()){\n\t\tu=q.front();q.pop();\n\t\tREP(u)if(!vi[v] && (--du[v])==1) vi[v]=in[v]=1,q.push(v); \n\t}\n\tans=1;\n\tFOR(i,1,m)if(!vi[i]) ans=1ll*ans*work(i)%P;\n\tprintf(\"%lld\\n\",1ll*fc[m]*ans%P);\n}/*\n4\n1 1\n1 2\n2 1\n2 2\n3 3\n3 4\n4 3\n4 4\n*/"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 1e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = 0);\n\t\tif (!findcr || SZ(cir) == 1) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\t// assert(SZ(cir) > 1);\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) ideg[u] = 0;\n\t\tfor (auto u : gt) {\n\t\t\tT[u].clear();\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tauto lim = UB(DT[u], in[u]); \n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v]) {\t// find it!\n\t\t\twhile (top && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tSCir(v, u);\n\t\tif (findcr) return;\n\t} if (S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2e5 + 10, mod = 1e9 + 7;\n\nint n, cntv, cnte, ans, oth, root, fac[maxn], ifac[maxn], par[maxn], dep[maxn], siz[maxn], flag;\nbool vis[maxn], on_cyc[maxn], isr[maxn][2], viss[maxn];\nstd::vector<int> dag[maxn][2], cur, ccur;\n\nstruct edge {\n\tint to, id;\n\n\tedge() {}\n\tedge(int to, int id): to(to), id(id) {}\n};\n\nstd::vector<edge> g[maxn];\n\ninline int pow_mod(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * x * y % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < maxn; ++i) {\n\t\tfac[i] = (long long) i * fac[i - 1] % mod;\n\t}\n\tifac[maxn - 1] = pow_mod(fac[maxn - 1], mod - 2);\n\tfor (int i = maxn - 1; i; --i) {\n\t\tifac[i - 1] = (long long) i * ifac[i] % mod;\n\t}\n\treturn;\n}\n\ninline void dfs1(int u, int p = -1, int d = 0) {\n\tcur.push_back(u);\n\tvis[u] = 1;\n\tpar[u] = p;\n\tdep[u] = d;\n\t++cntv;\n\tcnte += (int) g[u].size();\n\tfor (auto &e: g[u]) {\n\t\tint v = e.to;\n\t\tccur.push_back(e.id);\n\t\tif(v == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[v]) {\n\t\t\troot = dep[u] < dep[v] ? v : u;\n\t\t\toth = u + v - root;\n\t\t}\n\t\telse {\n\t\t\tdfs1(v, u, d + 1);\n\t\t}\n\t}\n\treturn;\n}\n\ninline void dfs2(int u, int p = -1) {\n\tviss[u] = 1;\n\tpar[u] = p;\n\tfor (auto &e: g[u]) {\n\t\tint v = e.to;\n\t\tif(!viss[v]) {\n\t\t\tdfs2(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\ninline int DP(int u) {\n\tsiz[u] = 1;\n\tint ret = 1;\n\tfor (int &v: dag[u][flag]) {\n\t\tret = (long long) DP(v) * ret % mod;\n\t\tsiz[u] += siz[v];\n\t\tret = (long long) ret * ifac[siz[v]] % mod;\n\t}\n\treturn (long long) ret * fac[siz[u] - 1] % mod;\n}\n\nint main() {\n\tprepare();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x;\n\t\ty += n - 1;\n\t\tg[x].push_back(edge(y, i));\n\t\tg[y].push_back(edge(x, i));\n\t}\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tisr[i][0] = isr[i][1] = 1;\n\t}\n\tans = fac[n << 1];\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tif(!vis[i]) {\n\t\t\tccur.clear();\n\t\t\tcur.clear();\n\t\t\tcntv = cnte = 0;\n\t\t\tdfs1(i);\n\t\t\tif((cntv << 1) != cnte) {\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int u = root; u != oth; u = par[u]) {\n\t\t\t\ton_cyc[u] = 1;\n\t\t\t}\n\t\t\ton_cyc[oth] = 1;\n\t\t\tstd::sort(ccur.begin(), ccur.end());\n\t\t\tccur.resize(std::unique(ccur.begin(), ccur.end()) - ccur.begin());\n\t\t\t\n\t\t\tflag = 0;\n\t\t\tint ban;\n\t\t\tfor (auto &e: g[root]) {\n\t\t\t\tif(on_cyc[e.to]) {\n\t\t\t\t\tban = e.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u = root; ; ) {\n\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\tif(on_cyc[v] && i != ban) {\n\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tban = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u == root) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs2(root);\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(!on_cyc[u]) {\n\t\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\t\tif(v == par[u]) {\n\t\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res1 = 1;\n\t\t\tfor (int &u: ccur) {\n\t\t\t\tif(isr[u][flag]) {\n\t\t\t\t\tres1 = (long long) DP(u) * res1 % mod * ifac[siz[u]] % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = 1;\n\t\t\tfor (auto &e: g[root]) {\n\t\t\t\tif(on_cyc[e.to]) {\n\t\t\t\t\tban = e.id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u = root; ; ) {\n\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\tif(on_cyc[v] && i != ban) {\n\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tban = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u == root) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(!on_cyc[u]) {\n\t\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\t\tif(v == par[u]) {\n\t\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res2 = 1;\n\t\t\tfor (int &u: ccur) {\n\t\t\t\tif(isr[u][flag]) {\n\t\t\t\t\tres2 = (long long) DP(u) * res2 % mod * ifac[siz[u]] % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = (long long) (res1 + res2) * ans % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <algorithm>\n\nint read()\n{\n  int x=0,f=1;\n  char ch=getchar();\n  while((ch<'0')||(ch>'9'))\n    {\n      if(ch=='-')\n        {\n          f=-f;\n        }\n      ch=getchar();\n    }\n  while((ch>='0')&&(ch<='9'))\n    {\n      x=x*10+ch-'0';\n      ch=getchar();\n    }\n  return x*f;\n}\n\nconst int maxn=100000;\nconst int maxv=maxn*2;\nconst int maxe=maxv*2;\nconst int mod=1000000007;\n\nstd::queue<int> q;\nstd::vector<int> cur;\nint n,pre[maxe+10],now[maxv+10],son[maxe+10],tot,_pre[maxe+10],_now[maxv+10],_son[maxe+10],_tot,vis[maxv+10],ecnt,cir[maxv+10],deg[maxv+10],choose[maxv+10],fac[maxv+10],ifac[maxv+10],f[maxv+10],size[maxv+10];\n\nint C(int a,int b)\n{\n  return 1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint _ins(int a,int b)\n{\n  _pre[++_tot]=_now[a];\n  _now[a]=_tot;\n  _son[_tot]=b;\n  return 0;\n}\n\nint calc()\n{\n  for(auto i:cur)\n    {\n      deg[i]=_now[i]=0;\n    }\n  for(auto i:cur)\n    {\n      for(int j=now[i]; j; j=pre[j])\n        {\n          int v=son[j];\n          if(v<choose[i])\n            {\n              _ins(v,i);\n              ++deg[i];\n            }\n        }\n    }\n  for(auto i:cur)\n    {\n      if(!deg[i])\n        {\n          q.push(i);\n        }\n      f[i]=1;\n      size[i]=1;\n    }\n  int sz=0,ans=1;\n  while(!q.empty())\n    {\n      int u=q.front(),flag=0;\n      q.pop();\n      for(int i=_now[u]; i; i=_pre[i])\n        {\n          flag=1;\n          int v=_son[i];\n          --deg[v];\n          size[v]+=size[u];\n          f[v]=1ll*f[v]*f[u]%mod*C(size[v]-1,size[u])%mod;\n          if(!deg[v])\n            {\n              q.push(v);\n            }\n        }\n      if(!flag)\n        {\n          sz+=size[u];\n          ans=1ll*ans*f[u]%mod*C(sz,size[u])%mod;\n        }\n    }\n  return ans;\n}\n\nint ins(int a,int b)\n{\n  pre[++tot]=now[a];\n  now[a]=tot;\n  son[tot]=b;\n  return 0;\n}\n\nint dfs(int u)\n{\n  vis[u]=1;\n  cur.push_back(u);\n  for(int i=now[u]; i; i=pre[i])\n    {\n      ++ecnt;\n      int v=son[i];\n      if(!vis[v])\n        {\n          dfs(v);\n        }\n    }\n  return 0;\n}\n\nint search(int u)\n{\n  cir[++cir[0]]=u;\n  vis[u]=1;\n  for(int i=now[u]; i; i=pre[i])\n    {\n      int v=son[i];\n      if(!vis[v])\n        {\n          search(v);\n        }\n    }\n  return 0;\n}\n\nint solve()\n{\n  if((int)cur.size()!=ecnt)\n    {\n      return 0;\n    }\n  for(auto i:cur)\n    {\n      if(deg[i]==1)\n        {\n          q.push(i);\n        }\n    }\n  while(!q.empty())\n    {\n      int u=q.front();\n      q.pop();\n      for(int i=now[u]; i; i=pre[i])\n        {\n          int v=son[i];\n          if(deg[v]!=1)\n            {\n              --deg[v];\n              choose[u]=v;\n              if(deg[v]==1)\n                {\n                  q.push(v);\n                }\n            }\n        }\n    }\n  int st=0;\n  for(auto i:cur)\n    {\n      if(deg[i]>1)\n        {\n          st=i;\n          vis[i]=0;\n        }\n    }\n  cir[0]=0;\n  search(st);\n  cir[cir[0]+1]=cir[1];\n  for(int i=1; i<=cir[0]; ++i)\n    {\n      choose[cir[i]]=cir[i+1];\n    }\n  int res=calc();\n  for(int i=2; i<=cir[0]+1; ++i)\n    {\n      choose[cir[i]]=cir[i-1];\n    }\n  res+=calc();\n  if(res>=mod)\n    {\n      res-=mod;\n    }\n  for(auto i:cur)\n    {\n      vis[i]=1;\n    }\n  return res;\n}\n\nint main()\n{\n  n=read();\n  fac[0]=1;\n  for(int i=1; i<=n<<1; ++i)\n    {\n      fac[i]=1ll*fac[i-1]*i%mod;\n    }\n  ifac[0]=ifac[1]=1;\n  for(int i=2; i<=n<<1; ++i)\n    {\n      ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;\n    }\n  for(int i=2; i<=n<<1; ++i)\n    {\n      ifac[i]=1ll*ifac[i-1]*ifac[i]%mod;\n    }\n  for(int i=1; i<=n<<1; ++i)\n    {\n      int x=read(),y=read();\n      ins(x,y+n);\n      ins(y+n,x);\n      ++deg[x];\n      ++deg[y+n];\n    }\n  int tsize=0,ans=1;\n  for(int i=1; i<=n<<1; ++i)\n    {\n      if(!vis[i])\n        {\n          cur.clear();\n          ecnt=0;\n          dfs(i);\n          ecnt/=2;\n          int res=solve();\n          tsize+=ecnt;\n          ans=1ll*ans*res%mod*C(tsize,ecnt)%mod;\n        }\n    }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long LL;\nconst LL mo=1e9+7;\nint n,kx,size;\nstruct point {\n\tint x,y;\n}a[200001];\nvector <int> vx[200001],vy[200001],vx2[200001],vy2[200001],lines,son[200001];\nint dx[200001],dy[200001],matched[200001],col[200001],w[200001],fa[200001];\nLL fac[200001],inv[200001];\nbool vis[200001];\nqueue <int> q;\nLL mul(LL x,LL y) {\n\tif (y==0) return 1;\n\tLL now=mul(x,y/2);\n\tnow=now*now%mo;\n\tif (y%2) now=now*x%mo;\n\treturn now;\n}\nvoid pre_choose() {\n\tfac[0]=1;\n\tfor (LL i=1;i<=200000;i++) fac[i]=fac[i-1]*i%mo;\n\tinv[200000]=mul(fac[200000],mo-2);\n\tfor (LL i=199999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mo;\n}\nLL C(LL x,LL y) {\n\tif (y<0||y>x) return 0;\n\treturn fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nvoid make_matches() {\n\tfor (int i=1;i<=n;i++) if (dx[i]==1) q.push(i);\n\tfor (int i=1;i<=n;i++) if (dy[i]==1) q.push(n+i);\n\twhile (!q.empty()) {\n\t\tint k=q.front();\n\t\tvis[k]=1;\n\t\tq.pop();\n\t\tif (k<=n) {\n\t\t\tint nx=vx[k].size();\n\t\t\tfor (int i=0;i<nx;i++) {\n\t\t\t\tif (matched[vx[k][i]]) continue;\n\t\t\t\tmatched[vx[k][i]]=k;\n\t\t\t\tdy[a[vx[k][i]].y]--;\n\t\t\t\tif (dy[a[vx[k][i]].y]==1) q.push(a[vx[k][i]].y+n);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint nx=vy[k-n].size();\n\t\t\tfor (int i=0;i<nx;i++) {\n\t\t\t\tif (matched[vy[k-n][i]]) continue;\n\t\t\t\tmatched[vy[k-n][i]]=k;\n\t\t\t\tdx[a[vy[k-n][i]].x]--;\n\t\t\t\tif (dx[a[vy[k-n][i]].x]==1) q.push(a[vy[k-n][i]].x);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int x) {\n\tif (col[x]) return;\n\tcol[x]=1;\n\tlines.push_back(x);\n\tif (x<=n) {\n\t\tint nx=vx[x].size();\n\t\tsize+=nx;\n\t\tfor (int i=0;i<nx;i++) {\n\t\t\tint kp=vx[x][i];\n\t\t\tdfs(a[kp].y+n);\n\t\t}\n\t}\n\telse {\n\t\tint nx=vy[x-n].size();\n\t\tfor (int i=0;i<nx;i++) {\n\t\t\tint kp=vy[x-n][i];\n\t\t\tdfs(a[kp].x);\n\t\t}\n\t}\n}\nvoid work(int x,int nowl) {\n\tmatched[x]=nowl;\n\twhile (1) {\n\t\tif (nowl<=n) {\n\t\t\tif (matched[vx2[nowl][0]]&&matched[vx2[nowl][1]]) break;\n\t\t\tif (matched[vx2[nowl][0]]) \n\t\t\t\tnowl=matched[vx2[nowl][1]]=a[vx2[nowl][1]].y+n;\n\t\t\telse nowl=matched[vx2[nowl][0]]=a[vx2[nowl][0]].y+n;\n\t\t}\n\t\telse {\n\t\t\tif (matched[vy2[nowl-n][0]]&&matched[vy2[nowl-n][1]]) break;\n\t\t\tif (matched[vy2[nowl-n][0]])\n\t\t\t\tnowl=matched[vy2[nowl-n][1]]=a[vy2[nowl-n][1]].x;\n\t\t\telse nowl=matched[vy2[nowl-n][0]]=a[vy2[nowl-n][0]].x;\n\t\t}\n\t}\n}\nLL get(int x) {\n\tw[x]=1;\n\tLL ans=1;\n\tint nx=son[x].size();\n\tfor (int i=0;i<nx;i++) {\n\t\tint kx=son[x][i];\n\t\tans=ans*get(kx)%mo;\n\t\tw[x]+=w[kx];\n\t}\n\tint noww=w[x]-1;\n\tfor (int i=0;i<nx;i++) {\n\t\tans=ans*C(noww,w[son[x][i]])%mo;\n\t\tnoww-=w[son[x][i]];\n\t}\n\treturn ans;\n}\nLL getans() {\n\tint nx=lines.size();\n\tfor (int i=0;i<nx;i++) {\n\t\tif (lines[i]>n) continue;\n\t\tint ny=vx[lines[i]].size();\n\t\tfor (int j=0;j<ny;j++) {\n\t\t\tfa[vx[lines[i]][j]]=0;\n\t\t\tson[vx[lines[i]][j]].clear();\n\t\t}\n\t}\n\tfor (int i=0;i<nx;i++) {\n\t\tint kp=lines[i];\n\t\tif (kp<=n) {\n\t\t\tint ny=vx[kp].size();\n\t\t\tint nowk;\n\t\t\tfor (int j=0;j<ny;j++)\n\t\t\t\tif (matched[vx[kp][j]]==kp) {\n\t\t\t\t\tnowk=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tfor (int j=0;j<ny;j++)\n\t\t\t\tif (a[vx[kp][j]].y<a[vx[kp][nowk]].y) {\n\t\t\t\t\tfa[vx[kp][j]]=vx[kp][nowk];\n\t\t\t\t\tson[vx[kp][nowk]].push_back(vx[kp][j]);\n\t\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tkp-=n;\n\t\t\tint ny=vy[kp].size();\n\t\t\tint nowk;\n\t\t\tfor (int j=0;j<ny;j++)\n\t\t\t\tif (matched[vy[kp][j]]==kp+n) {\n\t\t\t\t\tnowk=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tfor (int j=0;j<ny;j++)\n\t\t\t\tif (a[vy[kp][j]].x<a[vy[kp][nowk]].x) {\n\t\t\t\t\tson[vy[kp][nowk]].push_back(vy[kp][j]);\n\t\t\t\t\tfa[vy[kp][j]]=vy[kp][nowk];\n\t\t\t\t}\n\t\t}\n\t}\n\tint nsize=size;\n\tLL nowans=1;\n\tfor (int i=0;i<nx;i++) {\n\t\tif (lines[i]>n) continue;\n\t\tint ny=vx[lines[i]].size();\n\t\tfor (int j=0;j<ny;j++)\n\t\t\tif (fa[vx[lines[i]][j]]==0) {\n\t\t\t\tLL now=get(vx[lines[i]][j]);\n\t\t\t\tnow=now*C(nsize,w[vx[lines[i]][j]])%mo;\n\t\t\t\tnowans=nowans*now%mo;\n\t\t\t\tnsize-=w[vx[lines[i]][j]];\n\t\t\t}\n\t}\n\treturn nowans;\n}\nLL match1(int x) {\n\tlines.clear();\n\tsize=0;\n\tdfs(a[x].x);\n\twork(x,a[x].x);\n\treturn getans();\n}\nLL match2(int x) {\n\tint nx=lines.size();\n\tfor (int i=0;i<nx;i++) {\n\t\tif (lines[i]>n) continue;\n\t\tif (vx2[lines[i]].size()>0)\n\t\t\tmatched[vx2[lines[i]][0]]=matched[vx2[lines[i]][1]]=0;\n\t}\n\twork(x,a[x].y+n);\n\treturn getans();\n}\nint main() {\n\tpre_choose();\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n*2;i++) {\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tdx[a[i].x]++;\n\t\tdy[a[i].y]++;\n\t\tvx[a[i].x].push_back(i);\n\t\tvy[a[i].y].push_back(i);\n\t}\n\tmake_matches();\n\tfor (int i=1;i<=n;i++) if (!vis[i]&&dx[i]==0) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++) if (!vis[i+n]&&dy[i]==0) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tLL ans=1;\n\tfor (int i=1;i<=2*n;i++) if (!matched[i]) {\n\t\tvx2[a[i].x].push_back(i);\n\t\tvy2[a[i].y].push_back(i);\n\t}\n\tint nowsize=n*2;\n\tfor (int i=1;i<=n*2;i++)\n\t\tif (!matched[i]) {\n\t\t\tLL now1=match1(i);\n\t\t\tLL now2=match2(i);\n\t\t\tnow1=(now1+now2)%mo;\n\t\t\tnow1=now1*C(nowsize,size)%mo;\n\t\t\tnowsize-=size;\n\t\t\tans=ans*now1%mo;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\nint n,fac[200100],inv[200100],ans,cntv,cnte,a[200100],deg[200100],link[200100],s[200100];\nbool flag[200100];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[600100],*tp=pool,*fst[200100],*fst2[200100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nint c(int n,int m)\n{\n    return LL(fac[n])*inv[m]%p*inv[n-m]%p;\n}\n\nvoid addedge(int u,int v,edge **fst)\n{\n    *tp=(edge){v,fst[u]},fst[u]=tp++;\n}\n\nvoid dfs1(int x)\n{\n    flag[x]=1,a[++cntv]=x;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (flag[i->v])\n            ++cnte,++deg[x],++deg[i->v];\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (!flag[i->v])\n            dfs1(i->v);\n}\n\nint dfs2(int x)\n{\n    int ret=s[x]=1;\n    for (edge *i=fst2[x]; i; i=i->nxt)\n    {\n        ret=LL(ret)*dfs2(i->v)%p;\n        s[x]+=s[i->v],ret=LL(ret)*c(s[x]-1,s[i->v])%p;\n    }\n    return ret;\n}\n\nint calc()\n{\n    static bool flag[200100];\n    edge *t=tp;\n    repu(i,1,cntv)\n        flag[a[i]]=0;\n    repu(i,1,cntv)\n        for (edge *j=fst[a[i]]; j; j=j->nxt)\n            if (j->v<link[a[i]])\n                addedge(a[i],j->v,fst2),flag[j->v]=1;\n    int sum=0,ret=1;\n    repu(i,1,cntv)\n        if (!flag[a[i]])\n        {\n            ret=LL(ret)*dfs2(a[i])%p;\n            ret=LL(ret)*c(sum+=s[a[i]],s[a[i]])%p;\n        }\n    tp=t;\n    repu(i,1,cntv)\n        fst2[a[i]]=0;\n    return ret;\n}\n\nint solve(int x)\n{\n    cntv=cnte=0,dfs1(x);\n    if (cntv!=cnte)\n    {\n        puts(\"0\");\n        exit(0);\n    }\n    repu(i,1,cntv)\n        if (deg[a[i]]==1)\n            for (int j=a[i],nxt=0; j; deg[j]=0,j=nxt,nxt=0)\n                for (edge *k=fst[j]; k; k=k->nxt)\n                    if (deg[k->v]>1)\n                    {\n                        link[j]=k->v;\n                        if (--deg[k->v]==1)\n                            nxt=k->v;\n                    }\n    static int cyc[200100],tot;\n    repu(i,1,cntv)\n        if (deg[a[i]]>1)\n        {\n            cyc[tot=1]=a[i];\n            while (tot==1 || cyc[tot]!=a[i])\n                for (edge *j=fst[cyc[tot]]; j; j=j->nxt)\n                    if (deg[j->v]>1 && cyc[tot-1]!=j->v)\n                    {\n                        cyc[++tot]=j->v;\n                        break;\n                    }\n            --tot;\n            break;\n        }\n    repu(i,1,tot)\n        link[cyc[i]]=cyc[i+1];\n    int sum=calc();\n    repu(i,1,tot)\n        link[cyc[i+1]]=cyc[i];\n    (sum+=calc())%=p,ans=LL(ans)*sum%p;\n    return cntv;\n}\n\nint main()\n{\n    n=getint(),ans=1;\n    repu(i,1,n*2)\n    {\n        int u=getint(),v=getint()+n;\n        addedge(u,v,fst),addedge(v,u,fst);\n    }\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    repu(i,2,n*2)\n        inv[i]=LL(p-p/i)*inv[p%i]%p;\n    repu(i,2,n*2)\n        fac[i]=LL(fac[i-1])*i%p,inv[i]=LL(inv[i-1])*inv[i]%p;\n    int sum=0;\n    repu(i,1,n*2)\n        if (!flag[i])\n        {\n            int cnt=solve(i);\n            ans=LL(ans)*c(sum+=cnt,cnt)%p;\n        }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,k,min=99890287,sum=0,l,x,h;cin>>n;cin>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>x;\n\t\tl=abs(k-x);\n\t\th=x;\n\t\tif(l<min)min=l;\n\t\tif(h<min) min=h;\n\t\tsum=sum+min;\n\t\tmin=99899999;\n\t}\n\t\tcout<<2*sum;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nconst int mod=1e9+7;\nint n,ans;\nint x[maxn],y[maxn],par[maxn],dep[maxn],deg[maxn];\nbool vis[maxn],incyc[maxn];\nvector<int>edge[maxn],cyc,nedge[maxn],path,qryx[maxn],qryy[maxn];\nint fac[maxn],ifac[maxn],dp[maxn],sz[maxn];\nbool ok;\nvector<pii>xs[maxn],ys[maxn];\n\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nvoid dfs1(int x,int p,int d){\n\tvis[x]=true;\n\tpar[x]=p;\n\tdep[x]=d;\n\tpath.pb(x);\n\trep(i,edge[x].size()){\n\t\tint y=edge[x][i];\n\t\tif(y==p||incyc[y])continue;\n\t\tif(!vis[y])dfs1(y,x,d+1);\n\t\telse if(dep[y]<dep[x]){\n\t\t\tif(!cyc.empty())ok=false;\n\t\t\tint z=x;\n\t\t\twhile(z!=y)cyc.pb(z),z=par[z];\n\t\t\tcyc.pb(z);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x){\n\tdp[x]=1;\n\tsz[x]=0;\n\trep(i,nedge[x].size()){\n\t\tint y=nedge[x][i];\n\t\tdfs2(y);\n\t\tdp[x]=1LL*dp[x]*C(sz[x]+sz[y],sz[y])%mod*dp[y]%mod; \n\t\tsz[x]+=sz[y];\n\t}\n\tsz[x]++;\n}\n\nvoid add(int cur,int nxt){\n\tif(cur<=n){\n\t\tint pos=lower_bound(xs[cur].begin(),xs[cur].end(),mp(nxt-n,0))-xs[cur].begin();\n\t\tqryx[cur].pb(pos);\n\t}\n\telse{\n\t\tint pos=lower_bound(ys[cur-n].begin(),ys[cur-n].end(),mp(nxt,0))-ys[cur-n].begin();\n\t\tqryy[cur-n].pb(pos);\n\t}\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2*n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,2*n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tREP(i,2*n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\txs[x[i]].pb(mp(y[i],i));\n\t\tys[y[i]].pb(mp(x[i],i));\n\t\tedge[x[i]].pb(y[i]+n);\n\t\tedge[y[i]+n].pb(x[i]);\n\t}\n\tREP(i,n){\n\t\tsort(xs[i].begin(),xs[i].end());\n\t\tsort(ys[i].begin(),ys[i].end());\n\t}\n\tans=1;\n\tint tsz=0;\n\tREP(i,2*n)if(!vis[i]){\n\t\tok=true;\n\t\tcyc.clear();\n\t\tpath.clear();\n\t\tdfs1(i,0,0);\n\t\tif(cyc.empty())ok=false;\n\t\tif(!ok){\n\t\t\tans=0;\n\t\t\tbreak;\n\t\t}\n\t\trep(j,cyc.size())incyc[cyc[j]]=true;\n\t\trep(j,path.size())vis[path[j]]=false;\n\t\tpath.clear();\n\t\trep(j,cyc.size())dfs1(cyc[j],0,0);\n\t\tint sum=0;\n\t\tfor(int t=-1;t<=1;t+=2){\n\t\t\trep(j,path.size())if(!incyc[path[j]])add(path[j],par[path[j]]);\n\t\t\trep(j,cyc.size())add(cyc[j],cyc[(j+t+int(cyc.size()))%int(cyc.size())]);\n\t\t\tvector<int>tmp;\n\t\t\trep(j,path.size()){\n\t\t\t\tint x=path[j];\n\t\t\t\tif(x<=n){\n\t\t\t\t\tsort(qryx[x].begin(),qryx[x].end());\n\t\t\t\t\tint last=0;\n\t\t\t\t\trep(k,qryx[x].size()){\n\t\t\t\t\t\ttmp.pb(xs[x][qryx[x][k]].snd);\n\t\t\t\t\t\tfor(int p=last;p<qryx[x][k];p++){\n\t\t\t\t\t\t\tnedge[xs[x][qryx[x][k]].snd].pb(xs[x][p].snd);\n\t\t\t\t\t\t\tdeg[xs[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryx[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryx[x].clear();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx-=n;\n\t\t\t\t\tsort(qryy[x].begin(),qryy[x].end());\n\t\t\t\t\tint last=0;\n\t\t\t\t\trep(k,qryy[x].size()){\n\t\t\t\t\t\ttmp.pb(ys[x][qryy[x][k]].snd);\n\t\t\t\t\t\tfor(int p=last;p<qryy[x][k];p++){\n\t\t\t\t\t\t\tnedge[ys[x][qryy[x][k]].snd].pb(ys[x][p].snd);\n\t\t\t\t\t\t\tdeg[ys[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryy[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryy[x].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cur=1,csz=0;\n\t\t\trep(j,path.size())if(!deg[path[j]]){\n\t\t\t\tdfs2(path[j]);\n\t\t\t\tcur=1LL*cur*dp[path[j]]%mod*C(csz+sz[path[j]],sz[path[j]])%mod;\n\t\t\t\tcsz+=sz[path[j]];\n\t\t\t}\n\t\t\trep(j,tmp.size())nedge[tmp[j]].clear(),deg[tmp[j]]=0;\n\t\t\tsum=(sum+cur)%mod;\n\t\t}\n\t\tans=1LL*ans*sum%mod*C(tsz+path.size(),path.size())%mod;\n\t\ttsz+=path.size();\n\t}\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"2,Ofast,inline\")\n#pragma GCC diagnostic error \"-std=c++11\"\n#include<bits/stdc++.h>\n#define LL long long\n#define int LL\n#define P pair<int,int>\n#define fi first\n#define se second\nconst LL N=2e5+10;\nconst LL mod=1e9+7;\nconst LL inf=0x3f3f3f;\nconst double eps=1e-9;\nusing namespace std;\ntemplate<typename tp> inline void read(tp &x)\n{\n    x=0;char c=getchar();\n    bool f=0; for(; c<'0'||c>'9'; f|=(c=='-'),c = getchar());\n    for(; c>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0',c = getchar());\n    if(f) x=-x;\n}\nP wei[N<<1];\nmap<P,int> Map;\nvector<P> idd;\nvector<int> line[N],row[N],vec,node;\n \nint n,found;\nint head[N<<1],cnt;\nint fa[N<<1],side[N<<1],vis[N<<1];\nint tou[N<<1],num;\nLL siz[N<<1];\n \nstruct Node { int next,to,id;} edge[N<<3];\nstruct E {int next,to;} e[N<<3];\n \nvoid add(int from,int to,int id) { edge[++cnt]= {head[from],to,id}; head[from]=cnt;}\nvoid insert(int from,int to,int id) { add(from,to,id); add(to,from,id);}\nvoid jia(int from,int to) {e[++num]= {tou[from],to}; tou[from]=num;}\nP calc(int x,int y) { if(x>y) swap(x,y); y-=n; return P(x,y);}\nLL KSM(LL a,LL b,LL ret=1) { while(b) { if(b&1) ret=ret*a%mod; a=a*a%mod; b>>=1; } return ret;}\nint ask(P x) { return lower_bound(idd.begin(),idd.end(),x)-idd.begin()+1;}\n\nvoid dfs(int now,int fath)\n{\n    vis[now]=1;\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        if(found==1) return ;\n        int to=edge[i].to;\n        if(to==fath) continue;\n        if(vis[to])\n        {\n            int flag=now;\n            while(flag!=to)\n            {\n                vec.push_back(flag);\n                flag=fa[flag];\n            }\n            vec.push_back(to);\n            found = 1;\n            return ;\n        }\n        fa[to]=now;\n        dfs(to,now);\n    }\n}\nvoid dfs_side_other(int now,int fa)\n{\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        int to=edge[i].to;\n        if(vis[to]==2||to==fa)\n            continue;\n        vis[to]=1;\n        if(to>n) side[edge[i].id]=2;\n        else side[edge[i].id]=1;\n        node.push_back(edge[i].id);\n        dfs_side_other(to,now);\n    }\n}\nLL dfs_size(int now)\n{\n    if(siz[now]) return siz[now];\n    siz[now]=1;\n    for(int i=tou[now]; i; i=e[i].next)\n    {\n        int to=e[i].to;\n        siz[now]+=dfs_size(to);\n    }\n    return siz[now];\n}\nvoid built()\n{\n    for(int i=0; i<node.size(); i++)\n    {\n        int x=wei[node[i]].fi,y=wei[node[i]].se;\n        if(side[node[i]]==1)\n        {\n            int pos=lower_bound(line[x].begin(),line[x].end(),y)-line[x].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(x,line[x][j])));\n        }\n        else\n        {\n            int pos=lower_bound(row[y].begin(),row[y].end(),x)-row[y].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(row[y][j],y)));\n        }\n    }\n}\nLL solve(int now)\n{\n    found = 0;\n    LL ret1=1,ret2=1;\n    vec.clear(), node.clear();\n    dfs(now,now);\n    // for(int i=0;i<vec.size();i++) cout<<vec[i]<<\" \";puts(\"\");\n    for(int i=0; i<vec.size(); i++) vis[vec[i]]=2;\n    for(int i=0; i<vec.size(); i++) dfs_side_other(vec[i],vec[i]);\n    for(int i=0; i<vec.size()-1; i++)\n    {\n        side[ask(calc(vec[i],vec[i+1]))]=(vec[i+1]>n?1:2);\n        node.push_back(ask(calc(vec[i],vec[i+1])));\n    }\n    side[ask(calc(vec[vec.size()-1],vec[0]))]=(vec[0]>n?1:2);\n    node.push_back(ask(calc(vec[vec.size()-1],vec[0])));\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    // for(int i=0; i<node.size();i++) cout<<node[i]<<\" \";puts(\"\");\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret1=ret1*KSM(dfs_size(node[i]),mod-2)%mod;\n    // puts(\"\");\n    // for(int i=0;i<node.size();i++) cout<<node[i]<<\" \"<<dfs_size(node[i])<<endl;\n    // puts(\"\");\n    num=0;\n    for(int i=0; i<node.size(); i++) tou[node[i]]=0;\n    for(int i=vec.size()-1; i>0; i--)\n        side[ask(calc(vec[i],vec[i-1]))]=(vec[i-1]>n?1:2);\n    side[ask(calc(vec[0],vec[vec.size()-1]))]=(vec[vec.size()-1]>n?1:2);\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret2=ret2*KSM(dfs_size(node[i]),mod-2)%mod;\n    return ret1+ret2;\n}\nsigned main()\n{\n\t// freopen(\"data,in\",\"r\",stdin);\n    read(n);\n    for(int i=1,x,y; i<=n*2; i++)\n    {\n        read(x),read(y),insert(x,y+n,i);\n        // wei[i]=P(x,y);\n        // Map[P(x,y)]=i;\n\t\tidd.push_back(P(x,y));\n        line[x].push_back(y);\n        row[y].push_back(x);\n    }\n\tsort(idd.begin(),idd.end());\n\tfor(int i=0;i<n*2;i++)\n\t\twei[i+1]=idd[i];\n    for(int i=1; i<=n; i++)\n    {\n        sort(line[i].begin(),line[i].end()),\n        sort(row[i].begin(),row[i].end());\n        if(!line[i].size()||!row[i].size())\n            return 0*puts(\"0\");\n    }\n    LL ans=1;\n    for(int i=1; i<=n*2; i++)\n        if(!vis[i])\n            ans=ans*solve(i)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n/*\n3\n2 1\n1 2\n2 2\n3 3\n3 2\n2 3\n \noxo\nxxx\noxx\n \n850000006\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#define Rep(i, x, y) for (int i = x; i <= y; i ++)\n#define Dwn(i, x, y) for (int i = x; i >= y; i --)\n#define RepE(i, x) for (int i = pos[x]; i; i = g[i].nex)\n#define ev g[i].y\n#define eps 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N = 200005, mod = 1000000007;\nint n, pos[N], sz, fl, X, Y, Z, s[N], st[N], top, w[N], vis[N];\nll ans = 1, res;\nstruct edge { int y, nex, z; } g[N * 2];\nvoid init(int x, int y, int z) { g[++ sz] = (edge) { y, pos[x], z }, pos[x] = sz; }\nll power(ll x, int y) {\n\tll z = 1;\n\twhile (y) {\n\t\tif (y & 1) (z *= x) %= mod;\n\t\ty >>= 1; (x *= x) %= mod;\n\t}\n\treturn z;\n}\nvoid dfs1(int x, int fa) {\n\tvis[x] = 2; st[++ top] = x;\n\tRepE(i, x) if (ev != fa) {\n\t\tif (vis[ev] == 2) {\n\t\t\tX = x, Y = ev, Z = g[i].z;\n\t\t\tint k = top;\n\t\t\tdo {\n\t\t\t\tk --;\n\t\t\t\tif (w[k] > Z) X = st[k], Y = st[k + 1], Z = w[k];\n\t\t\t} while (st[k] != ev);\n\t\t\t// cout << top - k<<endl;\n\t\t\tfl ++;\n\t\t}\n\t\tif (!vis[ev]) w[top] = g[i].z, dfs1(ev, x);\n\t}\n\tvis[x] = 1; top --;\n}\nvoid dfs2(int x, int fa, int z) {\n//\tcout << x <<\" - \"<<s[x]<<endl;\n\ts[x] = 1;\n\tRepE(i, x) if (ev != fa && ev != X && (x != X || ev != Y)) {\n\t\tdfs2(ev, x, g[i].z);\n\t\tif (g[i].z < z) s[x] += s[ev];\n\t}\n\t(res *= power(s[x], mod - 2)) %= mod;\n}\nint main()\n{\n\tscanf (\"%d\", &n);\n\tRep(i, 1, n * 2) {\n\t\tint x, y;\n\t\tscanf (\"%d%d\", &x, &y);\n\t\tinit(x, y + n, x + y);\n\t\tinit(y + n, x, x + y);\n\t}\n\tn = n * 2;\n\tRep(i, 1, n) ans = ans * i % mod;\n\tRep(i, 1, n) if (!vis[i]) {\n\t\tfl = 0;\n\t\tdfs1(i, 0);\n\t\tif (fl != 1) { ans = 0; break ; }\n\t\tres = 1; dfs2(X, 0, Z);\n\t\tll k = res;\n\t\tswap(X, Y);\n\t\tres = 1; dfs2(X, 0, Z);\n\t\t// cout << i<<\" \"<<k<<\" \" <<res<< endl;\n\t\tans = ans * (k + res) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=200010;\nconst int ha=1e9+7;\nstruct Edge{int to,next;} e[N<<1],et[N<<1];\nint h[N],ht[N],esum=0,tsum=0,n,cmt=0;\nint gay[N],out[N],sz[N];\nbool done[N],inc[N],flag;\nvector<int> crl,vertix;\nstack<int> s;\nint fac[N];\n\nint Pow(int a,int b)\n{\n    int ans=1;\n    for(;b;b>>=1,a=1ll*a*a%ha)\n        if(b&1) ans=1ll*ans*a%ha;\n    return ans;\n}\n\nvoid add_edge(int u,int v)\n{\n    e[++esum]={v,h[u]};h[u]=esum;\n    e[++esum]={u,h[v]};h[v]=esum;\n}\n\nvoid add_topo_edge(int u,int v)\n{\n    out[v]++;\n    et[++tsum].to=v;\n    et[tsum].next=ht[u];\n    ht[u]=tsum;\n}\n\nvoid findcrl(int u,int fa)\n{\n    vertix.push_back(u);\n    done[u]=1;s.push(u);\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa) continue;\n        if(!flag&&done[v])\n        {\n            while(s.top()!=v) crl.push_back(s.top()),inc[s.top()]=1,s.pop();\n            crl.push_back(v);inc[v]=1;s.pop();\n            flag=1;cmt++;return;\n        }\n        else if(!done[v]) cmt++,findcrl(v,u);\n    }\n    if(!s.empty()&&s.top()==u) s.pop();\n}\n\nvoid findgay(int u,int fa)\n{\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa||inc[v]) continue;\n        gay[v]=u;findgay(v,u);\n    }\n}\n\nvoid build_topo()\n{\n    for(int u : vertix)\n        for(int t=h[u];t;t=e[t].next)\n        {\n            int v=e[t].to;\n            if(v>=gay[u]) continue;\n            add_topo_edge(u,v);\n        }\n    for(int u : vertix)\n        if(!out[u]) add_topo_edge(0,u);\n    for(int u : vertix) out[u]=0;\n}\n\nvoid getsize(int u)\n{\n    sz[u]=1;\n    for(int t=ht[u];~t;t=et[t].next)\n    {\n        int v=et[t].to;\n        getsize(v);\n        sz[u]+=sz[v];\n    }\n    ht[u]=-1;\n}\n\nint getans()\n{\n    int prodsz=1;getsize(0);\n    for(int u : vertix)\n        prodsz=1ll*prodsz*sz[u]%ha;\n    return Pow(prodsz,ha-2);\n}\n\nint xi_jin_ping_is_good(int u)\n{\n    flag=0;cmt=0;findcrl(u,0);\n    if(vertix.size()!=cmt) return 0;\n    for(int u : crl) if(inc[u]) findgay(u,0);\n    for(int i=0;i<crl.size()-1;i++) gay[crl[i]]=crl[i+1];\n    gay[crl.back()]=crl[0];\n    build_topo();\n    int res=getans();\n    for(int i=1;i<crl.size();i++) gay[crl[i]]=crl[i-1];\n    gay[crl[0]]=crl.back();\n    tsum=0;build_topo();\n    res=(res+getans())%ha;\n    for(int u : vertix) inc[u]=0;\n    vertix.clear();crl.clear();\n    return res;\n}\n\nint main()\n{\n    memset(ht,-1,sizeof(ht));\n    int x,y,ans=1;\n    n=read()<<1;fac[0]=1;\n    for(int i=1;i<=n;i++)\n        fac[i]=1ll*fac[i-1]*i%ha;\n    for(int i=1;i<=n;i++)\n    {\n        x=read();y=read();\n        add_edge(x,y+n/2);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(done[i]) continue;\n        x=xi_jin_ping_is_good(i);\n        if(x==0) return puts(\"0\"),0;\n        ans=1ll*ans*x%ha;\n    }\n    ans=1ll*fac[n]*ans%ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 200010;\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint remod(LL x) { x %= mod; return x + (x >> 63 & mod); }\nint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot;\nvoid addedge(int b, int e) {\n\tnxt[++tot] = head[b]; to[head[b] = tot] = e;\n\tnxt[++tot] = head[e]; to[head[e] = tot] = b;\n}\nint xs[MAXN], ys[MAXN], bak, fa[MAXN], hav[MAXN];\nint n;\nint find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\nint li[MAXN], cnt, cir[MAXN];\nint ex[MAXN], ey[MAXN], et[MAXN], idx;\nstd::map<int, int> M[MAXN];\nbool dfs(int u, int S, int fa = 0) {\n\tli[++cnt] = u;\n\tif (u == S) return true;\n\tfor (int i = head[u]; i; i = nxt[i])\n\t\tif (to[i] != fa)\n\t\t\tif (dfs(to[i], S, u)) return true;\n\t--cnt;\n\treturn false;\n}\nvoid append(int x, int y) {\n\tex[++idx] = std::min(x, y);\n\tey[idx] = std::max(x, y) - n;\n\tet[idx] = y > x;\n}\nvoid dfs2(int u, int fa = 0) {\n\tfor (int i = head[u]; i; i = nxt[i])\n\t\tif (!cir[to[i]] && to[i] != fa)\n\t\t\tappend(u, to[i]), dfs2(to[i], u);\n}\nint fac[MAXN], inv[MAXN];\ntypedef std::vector<int> VI;\nVI out[MAXN], lx[MAXN];\nint ind[MAXN], sz[MAXN], rk[MAXN];\nint dfs3(int u) {\n\tsz[u] = 1; int res = 1;\n\tfor (auto t : out[u])\n\t\tres = mul(res, dfs3(t)), sz[u] += sz[t];\n\treturn mul(res, inv[sz[u]]);\n}\nvoid adde(int b, int e) { ++ind[e]; out[b].push_back(e); }\nint solve() {\n\tfor (int i = 1; i <= idx; ++i) out[i].clear(), ind[rk[i] = i] = 0;\n\tstd::sort(rk + 1, rk + 1 + idx, [] (int a, int b) { return ey[a] < ey[b]; });\n\tfor (int i = 1; i <= idx; ++i) lx[ex[i]].clear();\n\tfor (int i = 1; i <= idx; ++i) {\n\t\tint u = rk[i];\n\t\tif (et[u] == 0) {\n\t\t\tfor (auto t : lx[ex[u]]) adde(u, t);\n\t\t\tlx[ex[u]].clear();\n\t\t}\n\t\tlx[ex[u]].push_back(u);\n\t}\n\tstd::sort(rk + 1, rk + 1 + idx, [] (int a, int b) { return ex[a] < ex[b]; });\n\tfor (int i = 1; i <= idx; ++i) lx[ey[i]].clear();\n\tfor (int i = 1; i <= idx; ++i) {\n\t\tint u = rk[i];\n\t\tif (et[u] == 1) {\n\t\t\tfor (auto t : lx[ey[u]]) adde(u, t);\n\t\t\tlx[ey[u]].clear();\n\t\t}\n\t\tlx[ey[u]].push_back(u);\n\t}\n\tint res = 1, tz = 0;\n\tfor (int i = 1; i <= idx; ++i) if (ind[i] == 0) {\n\t\tres = mul(res, dfs3(i)); tz += sz[i];\n\t}\n\treturn res;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tfac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2; i != MAXN; ++i) {\n\t\tfac[i] = mul(fac[i - 1], i);\n\t\tinv[i] = mul(inv[mod % i], mod - mod / i);\n\t}\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n * 2; ++i) fa[i] = i, hav[i] = 1;\n\tfor (int i = 1, a, b; i <= n * 2; ++i) {\n\t\tstd::cin >> a >> b;\n\t\tint _a = a, _b = b + n;\n\t\ta = find(a), b = find(b + n);\n\t\tif (a == b) xs[++bak] = _a, ys[bak] = _b;\n\t\telse addedge(_a, _b);\n\t\tif (b != a) hav[a] += hav[b]; fa[b] = a; --hav[a];\n\t}\n\tfor (int i = 1; i <= n; ++i) if (i == fa[i])\n\t\tif (hav[i]) return std::cout << 0 << std::endl, 0;\n\tint ans = 1;\n\tfor (int i = 1; i <= bak; ++i) {\n\t\tcnt = idx = 0;\n\t\tdfs(xs[i], ys[i]);\n\t\tfor (int j = 1; j <= cnt; ++j) cir[li[j]] = true;\n\t\tli[0] = li[cnt];\n\t\tfor (int j = 0; j < cnt; ++j) append(li[j], li[j + 1]);\n\t\tfor (int j = 1; j <= cnt; ++j) dfs2(li[j]);\n\t\tint t = solve();\n\t\tfor (int j = 1; j <= cnt; ++j) et[j] ^= 1;\n\t\treduce(t += solve() - mod);\n\t\tans = mul(ans, t);\n\t}\n\tstd::cout << mul(ans, fac[n * 2]) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\n\nnamespace io {\n#define File(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n  const int SIZE = (1 << 21) + 1;\n  char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1;\n  inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);}\n  inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;}\n  inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();}\n  template<class T>\n  inline void read(T &x) {\n    char ch; int f = 1;\n    x = 0;\n    while(isspace(ch = getc()));\n    if(ch == '-') ch = getc(), f = -1;\n    do x = x * 10 + ch - '0'; while(isdigit(ch = getc()));\n    x *= f;\n  }\n  template<class T, class ...Args>\n  inline void read(T &x, Args&... args) {read(x); read(args...);}\n  template<class T>\n  inline void write(T x) {\n    static char stk[128];\n    int top = 0;\n    if(x == 0) {putc('0'); return;}\n    if(x < 0) putc('-'), x = -x;\n    while(x) stk[top++] = x % 10, x /= 10;\n    while(top) putc(stk[--top] + '0');\n  }\n  template<class T, class ...Args>\n  inline void write(T x, Args... args) {write(x); putc(' '); write(args...);}\n  inline void space() {putc(' ');}\n  inline void endl() {putc('\\n');}\n  struct _flush {~_flush() {flush();}} __flush;\n};\nusing io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc;\n\nconst int M = 1000000007;\ninline int add(int x, int y) {return x+y>=M ? x+y-M : x+y;}\ntemplate<class ...Args> inline int add(int x, int y, Args... args) {return add(add(x, y), args...);}\ninline int sub(int x, int y) {return x-y<0 ? x-y+M : x-y;}\ninline int mul(int x, int y) {return 1LL * x * y % M;}\ntemplate<class ...Args> inline int mul(int x, int y, Args... args) {return mul(mul(x, y), args...);}\ninline void inc(int &x, int y=1) {x += y; if(x >= M) x -= M;}\ninline void dec(int &x, int y=1) {x -= y; if(x < 0) x += M;}\ninline int power(int x, int y){\n  int res = 1;\n  for(; y; y>>=1, x = mul(x, x)) if(y & 1) res = mul(res, x);\n  return res;\n}\ninline int inv(int x){return power(x, M - 2);}\n\nconst int N = 400005;\nvector<int> G[N];\nint tfa[N];\nint indeg[N], siz[N];\nvector<int> circ, node;\n\nnamespace DSU {\nint fa[N], rk[N];\nbool circuit[N];\nint find(int x) {\n  if (!fa[x]) return x;\n  return fa[x] = find(fa[x]);\n}\nbool merge(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) {\n    if (circuit[x]) return false;\n    circuit[x] = true;\n    return true;\n  }\n  if (rk[x] < rk[y]) swap(x, y);\n  fa[y] = x, rk[x] += rk[x] == rk[y];\n  circuit[x] = circuit[x] || circuit[y];\n  return true;\n}\n}; // namespace DSU\n\nint fac[N];//, ifac[N];\nvoid pre(int n) {\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n//  ifac[n] = inv(fac[n]);\n//  for (int i = n - 1; i >= 0; --i) ifac[i] = mul(ifac[i + 1], i + 1);\n}\n\nbool vis[N];\nint from[N];\n\nvoid dfs(int x) {\n  vis[x] = true;\n  node.push_back(x);\n  for (int v : G[x]) {\n    if (v == from[x]) continue;\n    if (vis[v]) {\n      if (!circ.empty()) break;\n      circ.push_back(v);\n      circ.push_back(x);\n      int t = from[x];\n      while (t != v) {\n        circ.push_back(t);\n        t = from[t];\n      }\n      break;\n    }\n    from[v] = x;\n    dfs(v);\n  }\n}\nint fa[N];\nvoid dfs2(int x) {\n  for (int v : G[x]) {\n    if (fa[v]) continue;\n    fa[v] = x;\n    dfs2(v);\n  }\n}\nint topo_cnt() {\n  int res = 1;\n  queue<int> q;\n  for (int x : node) {\n    siz[x] = 1;\n    if (!indeg[x])\n      q.push(x);\n  }\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    res = mul(res, inv(siz[x]));\n    if (!tfa[x]) continue;\n    indeg[tfa[x]]--;\n    siz[tfa[x]] += siz[x];\n    if (indeg[tfa[x]] == 0)\n      q.push(tfa[x]);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  read(n);\n  pre(n * 2);\n  for (int i = 1; i <= n * 2; ++i) {\n    int x, y;\n    read(x, y);\n    G[x].push_back(n + y); G[n + y].push_back(x);\n    if (!DSU::merge(x, n + y)) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  for (int i = 1; i <= 2 * n; ++i)\n    sort(G[i].begin(), G[i].end());\n  int res = 1;\n  for (int i = 1; i <= n * 2; ++i) {\n    int now = 0;\n    if (!vis[i]) {\n      node.clear();\n      circ.clear();\n      dfs(i);\n      int L = circ.size();\n      fa[circ[0]] = circ[L - 1];\n      for (int i = 1; i < L; ++i)\n        fa[circ[i]] = circ[i - 1];\n      for (int x : circ)\n        dfs2(x);\n      for (int x : node) {\n        for (int v : G[x]) {\n          if (v < fa[x])\n            tfa[v] = x, ++indeg[x];\n          else break;\n        }\n      }\n      now += topo_cnt();\n      for (int x : node)\n        tfa[x] = 0, indeg[x] = 0;\n      fa[circ[L - 1]] = circ[0];\n      for (int i = 0; i < L - 1; ++i)\n        fa[circ[i]] = circ[i + 1];\n      for (int x : node) {\n        for (int v : G[x])\n          if (v < fa[x]) tfa[v] = x, ++indeg[x];\n          else break;\n      }\n      now += topo_cnt();\n      now %= M;\n//      printf(\"now = %d ways %d\\n\", now, mul(now, fac[node.size()]));\n      res = mul(res, mul(now, fac[node.size()]));\n    }\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nconst int p = 1000000007;\nint n;\nint head[N],ver[N],nxt[N],tot;\nvoid add(int a,int b)\n{\n    tot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;return ;\n}\nint jie[N],ni[N];\nint c(int x,int y)\n{\n    return 1LL*jie[x]*ni[y]%p*ni[x-y]%p;\n}\nint v[N],dian,bian,st[N],top;\nint pi[N],cir[N],sz,q[N];\nvoid dfs(int x,int fa)\n{\n    st[++top]=x;\n    v[x]=1;q[++dian]=x;\n    for(int i=head[x];i;i=nxt[i])\n    {\n        bian++;\n        if(!v[ver[i]])dfs(ver[i],x);\n        else if(ver[i]!=fa&&!sz)\n        {\n            for(int j=top;j>=1;j--)\n            {\n                cir[++sz]=st[j];\n                if(st[j]==ver[i])break;\n            }\n        }\n    }\n    top--;\n    return ;\n}\nint now;\nvoid sao(int x,int f)\n{\n    for(int i=head[x];i;i=nxt[i])\n    {\n        if(ver[i]==f)continue;\n        pi[ver[i]]=x;\n        if(ver[i]==now)continue;\n        sao(ver[i],x);\n    }\n}\nvector<int>vv[N];\nint size[N],fa[N],f[N];\nvoid dp(int x)\n{\n    f[x]=1;size[x]=1;\n    for(int i=0;i<vv[x].size();i++)\n    {\n        dp(vv[x][i]);\n        size[x]+=size[vv[x][i]];\n        f[x]=1LL*f[x]*f[vv[x][i]]%p*c(size[x]-1,size[vv[x][i]])%p;\n    }\n}\nint solve()\n{\n    for(int j=1;j<=dian;j++)fa[q[j]]=0;\n    for(int j=1;j<=dian;j++)\n    {\n        int u=q[j];vv[u].clear();\n        for(int k=head[u];k;k=nxt[k])\n        {\n            if(ver[k]<pi[u])\n            {\n                //if(u==9&&ver[k]==5)cout<<pi[9]<<'s'<<endl;\n                vv[u].push_back(ver[k]),fa[ver[k]]=u;\n            }\n        }\n    }\n    int ans=1;int szzz=0;\n    for(int j=1;j<=dian;j++)\n    {\n        if(!fa[q[j]])\n        {\n            dp(q[j]);szzz+=size[q[j]];\n            ans=1LL*ans*f[q[j]]%p*c(szzz,size[q[j]])%p;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    jie[0]=ni[0]=ni[1]=1;\n    for(int i=1;i<=2*n;i++)jie[i]=1LL*jie[i-1]*i%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*(p-p/i)*ni[p%i]%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*ni[i-1]*ni[i]%p;\n    for(int i=1;i<=2*n;i++)\n    {\n        int t1,t2;scanf(\"%d%d\",&t1,&t2);\n        add(t1,t2+n);add(t2+n,t1);\n    }\n    int ans=1;int nw=2*n;\n    for(int i=1;i<=2*n;i++)\n    {\n        if(v[i])continue;\n        dian=sz=bian=0;\n        dfs(i,-1);bian/=2;\n        if(dian!=bian)return puts(\"0\"),0;\n        now=cir[sz];\n        sao(cir[sz],-1);\n        cir[sz+1]=cir[1];\n        int as=solve();\n\n        for(int j=1;j<=sz;j++)pi[cir[j]]=cir[j+1];\n        //cout<<pi[9]<<' '<<pi[5]<<' '<<pi[15]<<endl;\n        as+=solve();\n        ans=1LL*ans*c(nw,dian)%p*as%p;\n        nw-=dian;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nconst int N = 100010;\n\nint n;\n\nvector<pp> edge[N*2];\n\npp d[2*N];\n\nbool vis[2*N];\nint comp[2*N], compn;\nint ec;\nvoid dfs_compo(int x){\n\tvis[x]=1;\n\tcomp[compn++]=x;\n\tec += edge[x].size();\n\tfor(auto tmp:edge[x]){\n\t\tint y=tmp.x;\n\t\tif(!vis[y]) dfs_compo(y);\n\t}\n}\n\nmap<int,vector<pp>> lx, ly;\n\nint cyc[2*N];\nint cycn;\nint stk[2*N], top;\nchar onstk[2*N];\nvoid dfs_cyc(int x, int p){\n\tvis[x]=1;\n\tonstk[x]=1; stk[top++]=x;\n\tfor(auto tmp:edge[x]){\n\t\tint y=tmp.x;\n\t\tif(y == p) continue;\n\t\tif(!vis[y]) dfs_cyc(y, x);\n\t\telse if(onstk[y]){\n\t\t\tfor(int i=top-1;;--i){\n\t\t\t\tif((cyc[cycn++] = stk[i]) == y){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonstk[x]=0; --top;\n}\n\nint deg[2*N];\nint asgn[2*N];\nconst ll mod = int(1e9) + 7;\nint par[2*N];\nvector<int> child[2*N];\n\nchar ins[2*N];\n\nll fact[2*N]={1};\nll finv[2*N]={1};\nll Pow(ll b, ll e){\n\tif(e<0) e=(-e)*(mod-2)%mod;\n\tll ret=1;\n\twhile(e){\n\t\tif(e&1) (ret*=b)%=mod;\n\t\t(b*=b)%=mod; e>>=1;\n\t}\n\treturn ret;\n}\nll Comb(ll n, ll r){ return fact[n]*finv[r]%mod*finv[n-r]%mod; }\n\npair<ll,ll> dp(int x){\n\tll cnt = 0, way = 1;\n\tfor(int y:child[x]){\n\t\tll nc, nw;\n\t\ttie(nc, nw) = dp(y);\n\t\t(way *= nw) %= mod;\n\t\t(way *= Comb(cnt+nc, cnt)) %= mod;\n\t\tcnt += nc;\n\t}\n\tcnt += 1;\n\treturn {cnt, way};\n}\n\nvoid dfs_asgn(int x){\n\tint cnt=0, ys=0, is=0;\n\tfor(auto tmp:edge[x]){\n\t\tint y, i; tie(y, i) = tmp;\n\t\tif(asgn[i]) continue;\n\t\t++cnt; ys+=y; is+=i;\n\t}\n\tif(cnt == 1){\n\t\tasgn[is] = 1 + (x>n);\n\t\tdfs_asgn(ys);\n\t}\n}\n\nint main()\n{\t\n\tread(n);\n\tfor(int i=1; i<=2*n; ++i) fact[i]=fact[i-1]*i%mod;\n\tfinv[2*n]=Pow(fact[2*n], -1);\n\tfor(int i=2*n-1; 0<=i; --i) finv[i]=finv[i+1]*(i+1)%mod;\n\t\n\tfor(int i=1, x, y; i<=2*n; ++i){\n\t\tread(x, y); d[i]={x, y};\n\t\tedge[x].eb(y+n, i);\n\t\tedge[y+n].eb(x, i);\n\t\tlx[x].eb(y, i);\n\t\tly[y].eb(x, i);\n\t}\n\t\n\tfor(auto& tmp:lx) sort(all(tmp.y));\n\tfor(auto& tmp:ly) sort(all(tmp.y));\n\t\n\tll ans = 1, ac = 0;\n\t\n\tfor(int i=1; i<=2*n; ++i) if(!vis[i]){\n\t\tcompn = ec = 0;\n\t\tdfs_compo(i);\n\t\tif(compn != ec/2){\n\t\t\tputs(\"0\"); return 0;\n\t\t}\n\t\tcycn = 0;\n\t\tfor(int j=0; j<compn; ++j) vis[comp[j]]=0;\n\t\tdfs_cyc(i, -1);\n\t\t\n\t\tfor(int j=0; j<compn; ++j){\n\t\t\tdfs_asgn(comp[j]);\n\t\t}\n\t\t\n\t\tvector<int> ce(cycn), coe(compn);\n\t\tfor(int i=0; i<cycn; ++i){\n\t\t\tfor(auto tmp:edge[cyc[i]]){\n\t\t\t\tint y, e; tie(y, e) = tmp;\n\t\t\t\tif(y == cyc[(i+1)%cycn]){\n\t\t\t\t\tce[i] = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0, p=0; i<compn; ++i){\n\t\t\tint x = comp[i];\n\t\t\tfor(auto tmp:edge[x]){\n\t\t\t\tif(!ins[tmp.y]) coe[p++]=tmp.y, ins[tmp.y]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tll cc = 0, cw = 0;\n\t\t\n\t\tfor(int T=0; T<2; ++T){\n\t\t\tfor(int i=0; i<cycn; ++i) asgn[ce[i]]=1+((T+i)&1);\n\t\t\tfor(int i=0; i<compn; ++i){\n\t\t\t\tint x = coe[i];\n\t\t\t\tchild[x].clear(); par[x] = -1;\n\t\t\t}\n\t\t\tfor(int i=0; i<compn; ++i){\n\t\t\t\tint x = coe[i];\n\t\t\t\tvector<pp> *v;\n\t\t\t\tif(asgn[x] == 1){\n\t\t\t\t\tv = &lx[d[x].x];\n\t\t\t\t} else {\n\t\t\t\t\tv = &ly[d[x].y];\n\t\t\t\t}\n\t\t\t\tfor(auto& tmp:*v){\n\t\t\t\t\tif(tmp.y == x) break;\n\t\t\t\t\tpar[tmp.y] = x;\n\t\t\t\t\tchild[x].pb(tmp.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt = 0, way = 1;\n\t\t\tfor(int i=0; i<compn; ++i){\n\t\t\t\tint x = coe[i];\n\t\t\t\tif(par[x] == -1){\n\t\t\t\t\tll dc, dw; tie(dc, dw) = dp(x);\n\t\t\t\t\t(way *= dw * Comb(cnt + dc, dc) % mod) %= mod;\n\t\t\t\t\tcnt += dc;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcc = cnt;\n\t\t\tcw += way;\n\t\t}\n\t\t\n\t\t(ans *= cw * Comb(ac + cc, cc) % mod) %= mod;\n\t\tac += cc;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=200005;\nconst int mod=1000000007;\n\nstruct E{\n\tint to,next;\n}mem[N<<1];\nint n,num,x,y,ssr,siz,res,ns,sum,ans,h,t,m;\nint head[N],fac[N],inv[N],dp[N],sz[N],q[N],tp[N],d[N];\nbool vis[N];\n\nvoid addedge(int x,int y){\n\tnum++;\n\tmem[num].to=y; mem[num].next=head[x];\n\thead[x]=num; d[x]++;\n}\n\nint quickpow(int x,int y){\n\tint s=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mod)\n\t\tif (y&1) s=1ll*s*x%mod;\n\treturn s;\n}\n\nvoid init(int n){\n\tint i; fac[0]=inv[0]=1;\n\tfor (i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=quickpow(fac[n],mod-2);\n\tfor (i=n-1;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int x,int y){\n\tif (x<y) return 0;\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nvoid bfs(int st){\n\tint k,u,j;\n\th=t=0; q[++t]=st;\n\twhile (h<t){\n\t\tk=q[++h]; vis[k]=1;\n\t\tfor (j=head[k];j;j=mem[j].next){\n\t\t\tu=mem[j].to;\n\t\t\tif (!vis[u]){\n\t\t\t\tvis[u]=1; q[++t]=u;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid topsort(){\n\tint k,u,j;\n\twhile (h<t){\n\t\tk=tp[++h];\n\t\tfor (j=head[k];j;j=mem[j].next){\n\t\t\tu=mem[j].to; d[u]--;\n\t\t\tif (d[u]==1) tp[++t]=u;\n\t\t}\n\t}\n}\n\nvoid dfs(int k,int pre,int rt){\n\tint j,u;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre||u==rt) continue;\n\t\tdfs(u,k,rt);\n\t}\n\tdp[k]=1; sz[k]=0;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre||u==rt) continue;\n\t\tif (u<pre){\n\t\t\tdp[k]=1ll*dp[k]*dp[u]%mod*C(sz[k]+sz[u],sz[u])%mod;\n\t\t\tsz[k]+=sz[u];\n\t\t}\n\t\telse{\n\t\t\tssr=1ll*ssr*dp[u]%mod*C(siz+sz[u],sz[u])%mod;\n\t\t\tsiz+=sz[u];\n\t\t}\n\t}\n\tsz[k]++;\n}\n\nvoid solve(int x,int &res,int &ns){\n\tint i,k,st=0,j; res=0;\n\tbfs(x);\n\tns=t; h=t=0; m=0;\n\tfor (i=1;i<=ns;i++){\n\t\tk=q[i];\n\t\tfor (j=head[k];j;j=mem[j].next) m++;\n\t\tif (d[k]==1) tp[++t]=k;\n\t}\n\tif (m/2!=ns) return;\n\ttopsort(); t=0;\n\tfor (i=1;i<=ns;i++)\n\t\tif (d[q[i]]>1&&q[i]>st) st=q[i];\n\tfor (i=head[st];i;i=mem[i].next)\n\t\tif (d[mem[i].to]>1) tp[++t]=mem[i].to;\n\tfor (i=1;i<=t;i++){\n\t\tssr=1; siz=0;\n\t\tdfs(st,tp[i],st);\n\t\tssr=1ll*ssr*dp[st]%mod*C(siz+sz[st],sz[st])%mod;\n\t\tres=(res+ssr)%mod;\n\t}\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n+n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y+n); addedge(y+n,x);\n\t}\n\tinit(2*n);\n\tans=1;\n\tfor (i=1;i<=n;i++)\n\t\tif (!vis[i]){\n\t\t\tsolve(i,res,ns);\n\t\t\tans=1ll*ans*res%mod*C(sum+ns,ns)%mod;\n\t\t\tsum+=ns;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#undef LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename V>\nstring to_string(V v) {\n    bool f = true; string res = \"[\";\n    for (const auto& x: v) {\n        if (!f) res += \", \";\n        f = false;\n        res += to_string(x); } res += \"]\";\n    return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) { cerr << \" \" << to_string(h); debug(t...); }\n#ifdef LOCAL\n#define dbg(args...) cerr<<\"(\"<<#args<<\") =\", debug(args)\n#else\n#define dbg(args...) 2019\n#endif\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n    // sum x = s, x > 0\n    mint p(int s, int k) {\n        return c(s-1, k-1);\n    }\n    // sum x = s, x >= 0\n    mint z(int s, int k) {\n        return p(s+k, k);\n    }\n    // \\E Y-X >= m\n    mint hit(int n, int k, int m=1) {\n        if (m <= k-n) return c(n+k, n);\n        return c(n+k, k-m);\n    }\n    // catalan trapezoids C_m(n, k)\n    // \\A Y-X < m,  =c(n+k,n) - hit\n    mint cat(int n, int k, int m=1) {\n        if (m > k) return c(n+k, n);\n        if (m <= k-n) return 0;\n        return c(n+k,n) - c(n+k, k-m);\n    }\n}c(300000);\n\nstruct Graph {\n    int n, m;\n    vector<vector<int>> g;\n    bool is_digraph;\n    Graph(int _n) : n(_n), m(0) {\n        assert(n >= 1);\n        g.resize(n);\n        set_di(true); // TRUE!\n    }\n    Graph(int _n, int _m, bool _di=false) : n(_n), m(0) {\n        assert(n >= 1);\n        assert(1ll*n*(n-1)/2 >= m);\n        g.resize(n);\n        set_di(_di);\n        input(_m);\n    }\n    inline void add(int u, int v) {\n        assert(0 <= u && u < n);\n        assert(0 <= v && v < n);\n        assert(u != v);\n        g[u].emplace_back(v);\n        pa[v] = u;\n        if (!is_digraph)\n            g[v].emplace_back(u);\n        m++;\n    }\n    void input(int _m) {\n        int u, v;\n        for (int i = 0; i < _m; i++) {\n            cin >> u >> v;\n            u--;v--; // to 0-based\n            add(u, v);\n        }\n    }\n    void set_di(bool _di) {\n        is_digraph = _di;\n        trk = vector<bool>(n, false);\n        pa = vector<int>(n, -1);\n        sz = vector<int>(n, 0);\n        ans = vector<mint>(n, 0);\n    }\n    vector<bool> trk;\n    vector<int> pa;\n    vector<int> sz;\n    vector<mint> ans;\n    void dfs(int u) {\n        trk[u] = true;\n        ans[u] = 1;\n        for (int v: g[u]) {\n            if (trk[v]) continue;\n            dfs(v);\n            ans[u] *= c.ifac[sz[v]];\n            ans[u] *= ans[v];\n            sz[u] += sz[v];\n        }\n        ans[u] *= c.fac[sz[u]];\n        sz[u] += 1;\n    }\n\n    void clear_comp(vector<int>& comp) {\n        for (int u: comp) {\n            trk[u] = false;\n            pa[u] = -1;\n            sz[u] = 0;\n            g[u].clear();\n        }\n    }\n\n    mint full_dfs(vector<int>& comp){\n        mint res = c.fac[comp.size()];\n        for (int u: comp) if(pa[u]==-1) {\n            dfs(u);\n            dbg(sz[u],(int)ans[u]);\n            res *= c.ifac[sz[u]];\n            res *= ans[u];\n        }\n        return res;\n    }\n};\n\nvoid solve() {\n    int n; cin >> n; int N = n<<1;\n    vector<vector<int>> g(N);\n    for (int _ = 0; _ < N; _++) {\n        int x,y;\n        cin >> x >> y;\n        x--;y--;y+=n;\n        g[x].emplace_back(y);\n        g[y].emplace_back(x);\n    }\n    for (int i = 0; i < N; i++) {\n        sort(g[i].begin(), g[i].end());\n    }\n\n    int cycnt = 0, high = -1, low = -1;\n    vector<bool> trk(N, false);\n    vector<int> pa(N, -1);\n    vector<bool> in_c(N, false);\n    vector<int> comp;\n    vector<int> cycle;\n    // find cycle\n    function<bool(int,int)> dfs = [&](int u, int p){\n        trk[u] = true;\n        comp.emplace_back(u);\n        for (int v: g[u])if(v!=p){\n            if (trk[v]) {\n                cycnt++;  high = u;  low = v;\n                if (cycnt > 2) return false;\n            } else {\n                pa[v] = u;\n                dfs(v, u);\n            }\n        }\n        return true;\n    };\n    vector<bool> trk_asn(N, false);\n    vector<int> assign(N,-1);\n    function<void(int)> asn = [&](int u){\n        trk_asn[u] = true;\n        for (int v: g[u])if(!in_c[v] && !trk_asn[v]){\n            assign[v] = u;\n            asn(v);\n        }\n    };\n\n    Graph digraph(N);\n\n    auto make_before = [&](int u){\n        for (int v: g[u]) {\n            if (v >= assign[u]) break;\n            digraph.add(u, v);\n        }\n    };\n    mint res = c.fac[N];\n\n    dbg(g);\n    for (int i = 0; i < N; i++) {\n        if (trk[i]) continue;\n        comp.clear(); cycle.clear();\n        cycnt = 0, high = -1, low = -1;\n        if (!dfs(i, -1) || cycnt < 2) {\n            dbg(pa); dbg(cycnt);\n            cout << 0; return;\n        }\n        assert(cycnt == 2 && high != -1 && low != -1);\n        {// mark cycle\n            int x = low;\n            while (x != high) {\n                cycle.emplace_back(x);\n                in_c[x] = true;\n                x = pa[x];\n            }cycle.emplace_back(x); in_c[x] = true;\n        }\n        dbg(high, low);\n        dbg(comp, cycle);\n        {// assgin out\n            for (int u: cycle) asn(u);\n        }\n        mint sub = 0;\n        {// +1\n            int csz = cycle.size();\n            for (int i = 0; i < csz; i++) {\n                assign[cycle[i]] = cycle[(i+1)%csz];\n            }\n            dbg(assign);\n            for (int u: comp){\n                make_before(u);\n            }\n            dbg(digraph.g);\n            sub += digraph.full_dfs(comp);\n            dbg((int)sub);\n            digraph.clear_comp(comp);\n        }\n        {// -1\n            int csz = cycle.size();\n            for (int i = 0; i < csz; i++) {\n                assign[cycle[i]] = cycle[(i+csz-1)%csz];\n            }\n            dbg(assign);\n            for (int u: comp){\n                make_before(u);\n            }\n            dbg(digraph.g);\n            sub += digraph.full_dfs(comp);\n            dbg((int)sub);\n        }\n        res *= c.ifac[comp.size()];\n        res *= sub;\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=200010;\nconst int mod=1000000007;\nint n,first[maxn],nxt[maxn<<1],to[maxn<<1],dis[maxn<<1],e;\nvoid Add(int u,int v,int w) {\n//\tprintf(\"%d -> %d %d\\n\",u,v,w);\n\tto[++e]=v;dis[e]=w;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;dis[e]=w;nxt[e]=first[v];first[v]=e;\n}\nint pa[maxn],siz[maxn],es[maxn],vis[maxn];\nint findset(int x) {return x==pa[x]?x:pa[x]=findset(pa[x]);}\nvoid GG() {puts(\"0\");exit(0);}\nint sta[maxn],cir[maxn],left[maxn],right[maxn],col[maxn],clo,top;\nvector<int> s,all;\nint dfs(int x,int la) {\n\tif(vis[x]) {\n\t\twhile(top) {\n\t\t\tint y=sta[top--];\n\t\t\tcir[y]=1;s.pb(y);\n\t\t\tif(x==y) break;\n\t\t}\n\t\treturn 1;\n\t}\n\tvis[x]=++clo;sta[++top]=x;\n\tfor(int i=first[x];i;i=nxt[i]) if((i-1)!=(la-1^1)){\n\t\tif(dfs(to[i],i)) return 1;\n\t}\n\ttop--;\n\treturn 0;\n}\nvoid dfsout(int x,int fa) {\n\tall.pb(x);\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa&&!cir[to[i]]) {\n\t\tcol[to[i]]=dis[i];\n\t\tdfsout(to[i],x);\n\t}\n}\nint fac[maxn],ifac[maxn],size[maxn];\nint C(int a,int b) {return (ll)fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nvector<int> G[maxn];\nint deg[maxn],f[maxn];\nvoid dp(int x) {\n\tf[x]=1;size[x]=0;\n\trep(i,0,G[x].size()-1) {\n\t\tdp(G[x][i]);\n\t\tf[x]=(ll)f[x]*f[G[x][i]]%mod;\n\t\tf[x]=(ll)f[x]*ifac[size[G[x][i]]]%mod;\n\t\tsize[x]+=size[G[x][i]];\n\t}\n\tf[x]=(ll)f[x]*fac[size[x]]%mod;\n\tsize[x]++;\n}\nint work() {\n\trep(j,0,all.size()-1) G[all[j]].clear(),deg[all[j]]=0;\n\trep(j,0,all.size()-1) {\n\t\tint x=all[j];\n\t\tfor(int i=first[x];i;i=nxt[i]) if(dis[i]<col[x]) G[x].pb(to[i]),deg[to[i]]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,0,all.size()-1) if(!deg[all[i]]) {\n\t\tdp(all[i]);\n\t\tans=(ll)ans*C(cur+size[all[i]],cur)%mod;\n\t\tans=(ll)ans*f[all[i]]%mod;\n\t\tcur+=size[all[i]];\n\t}\n\treturn ans;\n}\nint main() {\n\tn=read();\n\tifac[0]=ifac[1]=fac[0]=1;\n\trep(i,2,n*2) ifac[i]=(ll)(mod-mod/i)*ifac[mod%i]%mod;\n\trep(i,1,n*2) fac[i]=(ll)fac[i-1]*i%mod,ifac[i]=(ll)ifac[i-1]*ifac[i]%mod;\n\trep(i,1,n*2) pa[i]=i,siz[i]=1;\n\trep(i,1,n*2) {\n\t\tint x=read(),y=read(),w=x+y;\n\t\tAdd(x,y+n,w);\n\t\tx=findset(x);y=findset(y+n);\n\t\tif(x!=y) {pa[x]=y;siz[y]+=siz[x];es[y]+=es[x];}\n\t\tes[y]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,1,n*2) if(i==findset(i)) {\n\t\tif(siz[i]!=es[i]) GG();\n\t\ts.clear();all.clear();dfs(i,0);top=0;\n\t\trep(j,0,s.size()-1) {\n\t\t\tdfsout(s[j],0);\n\t\t\tint prev=((!j)?s[s.size()-1]:s[j-1]);\n\t\t\tint nxtv=(j==s.size()-1?s[0]:s[j+1]);\n\t\t\tfor(int k=first[s[j]];k;k=nxt[k]) {\n\t\t\t\tif(to[k]==prev) left[s[j]]=dis[k];\n\t\t\t\tif(to[k]==nxtv) right[s[j]]=dis[k];\n\t\t\t}\n\t\t}\n\t\tans=(ll)ans*C(cur+all.size(),cur)%mod;\n\t\tcur+=all.size();\n\t\tint tmp=0;\n\t\trep(j,0,s.size()-1) col[s[j]]=left[s[j]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\trep(j,0,s.size()-1) col[s[j]]=right[s[j]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\tans=tmp;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n/*\n4\n2 2\n2 3\n3 2\n3 3\n1 2\n1 1\n1 4\n4 1\n*/"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n有点恶心。\n\n每个机器人看做一个点，平面上的每个点看做连接机器人的边。\n形成的图一定是基环树森林，否则说明有一行或一列为空，直接输出 0 。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) // fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 400005, mod = 1000000007;\nint head[maxn], nxt[maxn << 2], to[maxn << 2], hp = 1;\n\ninline ll power(ll x, int k) {\n\tif(k < 0) k += mod - 1;\n\tll res = 1;\n\twhile(k) {\n\t\tif(k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline void add(int u, int v, int *h) {\n\tnxt[++ hp] = h[u];\n\th[u] = hp;\n\tto[hp] = v;\n}\n\nint tmp[maxn], tp;\nbool vis[maxn];\nint cx, cy;\nint dfs(int u, int f) {\n\t/* debug(\"%d -> %d\\n\", f, u); */\n\ttmp[++ tp] = u;\n\tvis[u] = 1;\n\tint res = 0;\n\n\tfor(int i = head[u]; i; i = nxt[i], ++ res)\n\t\tif(to[i] != f) {\n\t\t\tif(vis[to[i]]) {\n\t\t\t\tcx = u;\n\t\t\t\tcy = to[i];\n\t\t\t} else\n\t\t\t\tres += dfs(to[i], u);\n\t\t}\n\n\t/* debug(\"dfs %d %d\\n\", u, res); */\n\n\treturn res;\n}\n\nint match[maxn];\nvoid mdfs(int u, int f) {\n\t/* debug(\"%d -> %d\\n\", f, u); */\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f and to[i] != cx) {\n\t\t\tmatch[to[i]] = u;\n\t\t\tmdfs(to[i], u);\n\t\t}\n}\n\nint Head[maxn];\nint deg[maxn];\nint stack[maxn], sp;\nll f[maxn];\nint size[maxn];\nll fac[maxn], ifac[maxn];\n\ninline ll C(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint force_count;\nvoid dp(int u) {\n\t++ force_count;\n\tif(force_count >= maxn) {\n\t\tputs(\"0\");\n\t\texit(0);\n\t}\n\n\tsize[u] = 0;\n\tf[u] = 1;\n\tfor(int i = Head[u]; i; i = nxt[i]) {\n\t\tdp(to[i]);\n\t\tsize[u] += size[to[i]];\n\t\t(f[u] *= f[to[i]]) %= mod;\n\t\t(f[u] *= C(size[u], size[to[i]])) %= mod;\n\t}\n\t++ size[u];\n\tdebug(\"%d : %lld %d\\n\", u, f[u], size[u]);\n}\n\nint HP;\nll solve() {\n\tdebug(\"solve %d %d\\n\", cx, cy);\n\tmdfs(cx, cy);\n\tmatch[cx] = cy;\n\n\thp = HP;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tdeg[tmp[i]] = Head[tmp[i]] = 0;\n\n\tfor(int id = 1; id <= tp; id ++) {\n\t\tint u = tmp[id];\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] < match[u]) {\n\t\t\t\tdebug(\"%d -> %d\\n\", u, to[i]);\n\t\t\t\tadd(u, to[i], Head);\n\t\t\t\t++ deg[to[i]];\n\t\t\t}\n\t}\n\n\tHead[0] = 0;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tif(!deg[tmp[i]])\n\t\t\tadd(0, tmp[i], Head);\n\n\tdp(0);\n\tdebug(\"get %lld\\n\", f[0]);\n\n\treturn f[0];\n}\n\nint main() {\n\tint n = read;\n\n\tint N = n << 1 | 1;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[N] = power(fac[N], -1);\n\tfor(int i = N; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n\n\tfor(int i = 1; i < N; i ++) {\n\t\tint x = read, y = read;\n\t\tadd(x, n + y, head);\n\t\tadd(n + y, x, head);\n\t}\n\n\tHP = hp;\n\tll ans = 1;\n\tint SIZE = 0;\n\n\tfor(int r = 1; r < N; r ++)\n\t\tif(!vis[r]) {\n\t\t\ttp = 0;\n\t\t\tif(dfs(r, 0) != (tp << 1)) return puts(\"0\"), 0;\n\t\t\tll now = solve();\n\t\t\tstd::swap(cx, cy);\n\t\t\tnow += solve();\n\t\t\tSIZE += size[0] - 1;\n\t\t\t(ans *= now) %= mod;\n\t\t\t(ans *= C(SIZE, size[0] - 1)) %= mod;\n\t\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 2e5 + 10 , P = 1e9 + 7;\nint n , vis[N] , fac[N] = {1} , ifac[N] , du[N] , root[N];\nvi g[N] , G[N];\nvoid output(vi v){\n    rep(i,0,sz(v)) printf(\"%d%c\",v[i],\" \\n\"[i+1==sz(v)]);\n}\n\nint inverse(int x){return x == 1 ? 1 : P - ll(P/x)*inverse(P%x)%P;}\n\nvoid dfs(int c,int fa){\n    for(auto e : g[c]) if(e < fa) G[c].pb(e) , root[e] = false;\n    for(auto e : g[c]) if(du[e] == 1 && e != fa) dfs(e , c);\n}\n\npii solve(int c,int fa){\n    pii res=mp(1,0);\n    for(auto e : G[c]) if(e != fa){\n        pii get=solve(e,c);\n        res.se+=get.se;\n        res.fi=1ll*res.fi*get.fi%P*ifac[get.se]%P;\n    }\n    res.fi=1ll*res.fi*fac[res.se]%P;\n    res.se+=1;\n    return res;\n}\n\nint solve(vi cir,vi all){\n    for(auto e : all) G[e].clear() , root[e] = true;\n    int rt = N - 1;G[rt].clear();\n    cir.pb(cir[0]);\n    rep(i,1,sz(cir)) dfs(cir[i] , cir[i-1]);\n    for(auto e : all) if(root[e]) G[rt].pb(e);\n    return solve(rt , -1).fi;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,(n<<1)+1) fac[i] = 1ll * fac[i - 1] * i % P;\n    ifac[n<<1] = inverse(fac[n<<1]);\n    per(i,0,(n<<1)) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;\n    rep(i,0,n<<1){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        --x;--y;\n        g[x << 1].pb(y << 1 | 1);\n        g[y << 1 | 1].pb(x << 1);\n    }\n    int ans = fac[n<<1];\n    rep(i,0,n<<1) if(!vis[i]){\n        vi q;q.pb(i);vis[i]=1;\n        rep(i,0,sz(q)) for(auto e : g[q[i]]) if(!vis[e])\n            q.pb(e) , vis[e]=1;\n        vi noncir,cir;int edgecnt(0);\n        rep(i,0,sz(q)) {\n            int c=q[i];\n            edgecnt+=sz(g[c]);\n            du[c] = sz(g[c]);\n            if(sz(g[c]) == 1) noncir.pb(c);\n        }\n        if(edgecnt / 2 != sz(q)) {\n            ans = 0;\n            break;\n        }\n        rep(i,0,sz(noncir)){\n            int c=noncir[i];\n            for(auto e : g[c]) if(du[e] != 1 && (--du[e]) == 1)\n                noncir.pb(e);\n        }\n        rep(i,0,sz(q)) if(du[q[i]] == 2){\n            for(int c=q[i],t=-1;c!=-1;c=t){\n                cir.pb(c);du[c]=0;t=-1;\n                for(auto e : g[c]) if(du[e] == 2) t=e;\n            }\n        }\n        int way = solve(cir , q);\n        reverse(all(cir));\n        (way += solve(cir , q)) %= P;\n        ans = 1ll * ans * way % P * ifac[sz(q)] % P;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e5 + 5;\nconst LL mod = 1e9 + 7;\n\ntemplate <typename T> inline void Read(T &x) {\n  char ch; x = 0;\n  while (!isdigit(ch = getchar()));\n  do {x = (x << 1) + (x << 3) + ch - '0';} while (isdigit(ch = getchar()));\n}\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], point[N], top, tp;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found || !vis[e[i].to]) point[++ tp] = e[i].id;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= tp; i ++)\n    Fir[point[i]] = deg[point[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = tp, i; u; u --) {\n    i = point[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = tp, i = point[u]; u; u --, i = point[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  return res;\n}\n\nint main() {\n  pre();\n  Read(n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    Read(x[i]); Read(y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      tp = rt = top = 0;\n      dfs(k);\n      if (!rt) return !puts(\"0\");\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      ans = ans * tmp % mod * C(p, top) % mod;\n      p -= top;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef long double ld; \ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\n\nstruct Combi\n{\n\tvector<ll> fact;\n\tvector<ll> ifact;\n\tvector<ll> inv;\n\tvector<ll> pow2;\n\tconst int MOD = 1e9 + 7;\n\tll add(ll a, ll b)\n\t{\n\t\ta+=b;\n\t\twhile(a>=MOD) a-=MOD;\n\t\treturn a;\n\t}\n\tll mult(ll a, ll b)\n\t{\n\t\treturn (a*b)%MOD;\n\t}\n\tll modpow(ll a, ll b)\n\t{\n\t\tll r=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r=mult(r,a);\n\t\t\ta=mult(a,a);\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tll choose(ll a, ll b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tll inverse(ll a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tinv[i] = inverse(i);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t\tifact[i]=mult(ifact[i-1],inv[i]);\n\t\t}\n\t}\n};\n\n\nCombi combi;\nvi adj[211111];\nset<ii> S;\nset<ii> ad[211111];\nvector<vi> cyc;\nbool vis[211111];\n\nvoid dfscyc(int u)\n{\n\tvis[u]=1;\n\tcyc.back().pb(u);\n\tfor(auto it=ad[u].begin();it!=ad[u].end();it++)\n\t{\n\t\tint v=(*it).fi;\n\t\tif(!vis[v])\n\t\t{\n\t\t\tdfscyc(v);\n\t\t}\n\t}\n}\n\nmap<ii,int> ma;\nint n; \nint match[200011];\nint imatch[200011];\nvi comp[200011];\n\nvoid dfs(int u, int idx)\n{\n\tvis[u]=1;\n\tcomp[idx].pb(u);\n\t////////cerr<<u<<'\\n';\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(vis[v]) continue;\n\t\tii cur = mp(u,v%n);\n\t\tif(u>=n) cur = mp(v,u%n);\n\t\tmatch[ma[cur]] = v;\n\t\timatch[v] = ma[cur];\n\t\tdfs(v,idx);\n\t}\n}\nconst int MOD=1e9+7;\n\nll add(ll &a, ll b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nvector<ii> pt;\nvi T[200001];\nint indeg[200001];\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nii calctree(int u ,int p = -1)\n{\n\tll ans = 1;\n\tll siz=1;\n\tfor(int i=0;i<T[u].size();i++)\n\t{\n\t\tint v=T[u][i];\n\t\tii res = calctree(v,u);\n\t\tans = mult(ans,res.fi);\n\t\tans = mult(ans,combi.ifact[res.se]);\n\t\tsiz+=res.se;\n\t}\n\tans = mult(ans,combi.fact[siz-1]);\n\t////cerr<<u<<' '<<p<<' '<<ans<<' '<<siz<<'\\n';\n\treturn mp(ans,siz);\n}\n\nint timer;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tint x, y; cin>>x>>y;\n\t\tx--; y--;\n\t\tadj[x].pb(y+n);\n\t\tadj[y+n].pb(x);\n\t\tad[x].insert(mp(y+n,++timer));\n\t\tad[y+n].insert(mp(x,timer));\n\t\tma[mp(x,y)] = i;\n\t\tpt.pb(mp(x,y));\n\t}\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tS.insert(mp(int(ad[i].size()),i));\n\t}\n\twhile(!S.empty())\n\t{\n\t\tii tmp = (*S.begin());\n\t\t////cerr<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\tif(tmp.fi==0)\n\t\t{\n\t\t\tcout<<0<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t\telse if(tmp.fi==1)\n\t\t{\n\t\t\tint u = tmp.se;\n\t\t\tint v = (*ad[u].begin()).fi;\n\t\t\tS.erase(mp(ad[u].size(),u));\n\t\t\tS.erase(mp(ad[v].size(),v));\n\t\t\t////cerr<<\"ERASE : \"<<v<<' '<<ad[v].size()<<'\\n';\n\t\t\tad[u].erase(ad[u].lower_bound(mp(v,-1)));\n\t\t\tad[v].erase(ad[v].lower_bound(mp(u,-1)));\n\t\t\t////cerr<<\"ERASE : \"<<v<<' '<<ad[v].size()<<'\\n';\n\t\t\tS.insert(mp(ad[v].size(),v));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tvi vertices;\n\tfor(auto it = S.begin(); it != S.end(); it++)\n\t{\n\t\tif(!vis[it->se]) \n\t\t{\n\t\t\tcyc.pb(vi());\n\t\t\tdfscyc(it->se);\n\t\t}\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=0;i<cyc.size();i++) \n\t{\n\t\tfor(int j=0;j<cyc[i].size();j++)\n\t\t{\n\t\t\t//cerr<<cyc[i][j]<<' ';\n\t\t\tvis[cyc[i][j]]=1;\n\t\t}\n\t\t//cerr<<'\\n';\n\t}\n\tfor(int i=0;i<cyc.size();i++)\n\t{\n\t\tfor(int j=0;j<cyc[i].size();j++)\n\t\t{\n\t\t\tdfs(cyc[i][j],i);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tsort(adj[i].begin(),adj[i].end());\n\t}\n\tcombi.init(212121);\n\tvector<ll> results;\n\tll res = combi.fact[2*n];\n\tfor(int z=0;z<cyc.size();z++)\n\t{\n\t\tsort(comp[z].begin(),comp[z].end());\n\t\tres=mult(res,combi.ifact[comp[z].size()]);\n\t\tll ans=1;\n\t\tfor(int i=0;i<cyc[z].size();i++)\n\t\t{\n\t\t\tint u=cyc[z][i];\n\t\t\tint v=cyc[z][(i+1)%int(cyc[z].size())];\n\t\t\t////////cerr<<u<<' '<<v<<'\\n';\n\t\t\tii cur = mp(u,v%n);\n\t\t\tif(u>=n) cur = mp(v,u%n);\n\t\t\tmatch[ma[cur]] = u;\n\t\t\timatch[u] = ma[cur];\n\t\t\t////////cerr<<u<<' '<<ma[cur]<<'\\n';\n\t\t}\n\t\t\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tint x = imatch[i];\n\t\t\t//cerr<<\"MATCH : \"<<i<<' '<<pt[x].fi<<' '<<pt[x].se<<'\\n';\n\t\t\tii V = pt[x];\n\t\t\tint cr = V.se + n;\n\t\t\tif(i>=n)\n\t\t\t{\n\t\t\t\tcr = V.fi;\n\t\t\t}\n\t\t\tfor(int j=0;j<adj[i].size();j++)\n\t\t\t{\n\t\t\t\tint v=adj[i][j];\n\t\t\t\tif(v<cr)\n\t\t\t\t{\n\t\t\t\t\t////////cerr<<v<<' '<<cr<<'\\n';\n\t\t\t\t\tif(i<n)\n\t\t\t\t\t{\n\t\t\t\t\t\t//cerr<<i<<' '<<v-n<<' '<<i<<' '<<cr-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(i,cr-n)]].pb(ma[mp(i,v-n)]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//cerr<<v<<' '<<i-n<<' '<<cr<<' '<<i-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(cr,i-n)]].pb(ma[mp(v,i-n)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tfor(int j=0;j<T[i].size();j++)\n\t\t\t{\n\t\t\t\t////cerr<<\"T1 : \"<<i<<' '<<T[i][j]<<'\\n';\n\t\t\t\tindeg[T[i][j]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi vec;\n\t\t\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tif(indeg[i]==0)\n\t\t\t{\n\t\t\t\tii tmp = calctree(i);\n\t\t\t\t//////cerr<<\"DEG : \"<<i<<' '<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\t\t\tans = mult(ans,tmp.fi);\n\t\t\t\t////cerr<<i<<' '<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\t\t\tvec.pb(tmp.se);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll r=0;\n\t\tfor(int i=0;i<vec.size();i++)\n\t\t{\n\t\t\tr+=vec[i];\n\t\t\tans=mult(ans,combi.ifact[vec[i]]);\n\t\t}\n\t\tans=mult(ans,combi.fact[r]);\n\t\t////////cerr<<ans<<'\\n';\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tT[i].clear();\n\t\t\tindeg[i]=0;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<cyc[z].size();i++)\n\t\t{\n\t\t\tint u=cyc[z][i];\n\t\t\tint v=cyc[z][(i+1)%int(cyc[z].size())];\n\t\t\tii cur = mp(u,v%n);\n\t\t\tif(u>=n) cur = mp(v,u%n);\n\t\t\tmatch[ma[cur]] = v;\n\t\t\timatch[v] = ma[cur];\n\t\t}\n\t\t\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tint x = imatch[i];\n\t\t\tii V = pt[x];\n\t\t\tint cr = V.se + n;\n\t\t\tif(i>=n)\n\t\t\t{\n\t\t\t\tcr = V.fi;\n\t\t\t}\n\t\t\tfor(int j=0;j<adj[i].size();j++)\n\t\t\t{\n\t\t\t\tint v=adj[i][j];\n\t\t\t\tif(v<cr)\n\t\t\t\t{\n\t\t\t\t\tif(i<n)\n\t\t\t\t\t{\n\t\t\t\t\t\t////////cerr<<i<<' '<<v-n<<' '<<i<<' '<<cr-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(i,cr-n)]].pb(ma[mp(i,v-n)]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t////////cerr<<v<<' '<<i-n<<' '<<cr<<' '<<i-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(cr,i-n)]].pb(ma[mp(v,i-n)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tfor(int j=0;j<T[i].size();j++)\n\t\t\t{\n\t\t\t\t////cerr<<\"T2 : \"<<i<<' '<<T[i][j]<<'\\n';\n\t\t\t\tindeg[T[i][j]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans2 = 1;\n\t\tvec.clear();\n\t\t\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tif(indeg[i]==0)\n\t\t\t{\n\t\t\t\tii tmp = calctree(i);\n\t\t\t\tans2 = mult(ans2,tmp.fi);\n\t\t\t\t////cerr<<i<<' '<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\t\t\tvec.pb(tmp.se);\n\t\t\t}\n\t\t}\n\t\t\n\t\tr=0;\n\t\tfor(int i=0;i<vec.size();i++)\n\t\t{\n\t\t\tr+=vec[i];\n\t\t\tans2=mult(ans2,combi.ifact[vec[i]]);\n\t\t}\n\t\t\n\t\tans2=mult(ans2,combi.fact[r]);\n\t\n\t\tadd(ans,ans2);\n\t\tres = mult(res,ans);\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tT[i].clear();\n\t\t\tindeg[i]=0;\n\t\t}\n\t\t////cerr<<comp[z].size()<<' '<<ans<<'\\n';\n\t}\n\tcout<<res<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int P = 1000000007;\n\nint norm(int x) { return x >= P ? (x - P) : x; }\n\nvoid add(int& x, int y) { if ((x += y) >= P) x -= P; }\n\nvoid sub(int& x, int y) { if ((x -= y) < 0) x += P; }\n\nvoid exGcd(int a, int b, int& x, int& y) {\n  if (!b) {\n    x = 1;\n    y = 0;\n    return;\n  }\n  exGcd(b, a % b, y, x);\n  y -= a / b * x;\n}\n\nint inv(int a) {\n  int x, y;\n  exGcd(a, P, x, y);\n  return norm(x + P);\n}\n\nconst int N = 200010;\n\nint n;\nvector<int> g[N];\nint fac[N], ifac[N], nv[N], f[N], bal[N], sz[N], mn[N];\nint got[N], prt[N], deg[N];\n\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }\n\nvoid prep(int m) {\n  fac[0] = 1;\n  for (int i = 1; i <= m; ++i) fac[i] = fac[i - 1] * (ll)i % P;\n  ifac[m] = inv(fac[m]);\n  for (int i = m; i; --i) ifac[i - 1] = ifac[i] * (ll)i % P;\n  for (int i = 1; i <= m; ++i) nv[i] = ifac[i] * (ll)fac[i - 1] % P;\n}\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  iota(f + 1, f + n * 2 + 1, 1);\n  fill(bal + 1, bal + n * 2 + 1, 1);\n  vector<pair<int, int>> crit;\n  fill(mn + 1, mn + n * 2 + 1, numeric_limits<int>::max());\n  for (int rep = 0; rep < n * 2; ++rep) {\n    int x, y;\n    cin >> x >> y;\n    y += n;\n    int u = x, v = y;\n    mn[u] = min(mn[u], v);\n    mn[v] = min(mn[v], u);\n    x = find(x); y = find(y);\n    if (x != y) {\n      bal[x] += bal[y];\n      f[y] = x;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    } else\n      crit.emplace_back(u, v);\n    --bal[x];\n  }\n  for (int i = 1; i <= n * 2; ++i)\n    if (f[i] == i && bal[i]) {\n      cout << \"0\\n\";\n      return 0;\n    }\n  prep(n * 2);\n  int ans = 1;\n\n  auto gans = [&](int x, int y) {\n    int ret = 1;\n    vector<int> tot;\n    function<void(int)> dfs = [&](int u) {\n      for (int v : g[u])\n        if (!prt[v]) {\n          prt[v] = u;\n          dfs(v);\n        }\n      tot.push_back(u);\n    };\n    prt[x] = -1;\n    dfs(x);\n    prt[x] = y;\n    for (int u : tot) sz[u] = 1;\n\n    queue<int> topo;\n    for (int u : tot) {\n      if (u < prt[prt[u]]) {\n        ++deg[got[u] = prt[u]];\n      } else\n        got[u] = 0;\n    }\n    for (int u : tot)\n      if (!deg[u])\n        topo.push(u);\n\n    while (!topo.empty()) {\n      int u = topo.front(); topo.pop();\n      ret = ret * (ll)nv[sz[u]] % P;\n      if (got[u]) {\n        sz[got[u]] += sz[u];\n        if (--deg[got[u]] == 0)\n          topo.push(got[u]);\n      }\n    }\n\n    for (int u : tot) prt[u] = 0;\n    return ret % P;\n  };\n\n  for (const auto& [x, y] : crit) {\n    int good = norm(gans(x, y) + gans(y, x));\n    ans = ans * (ll)good % P;\n  }\n\n  ans = ans * (ll)fac[n * 2] % P;\n  cout << ans << '\\n';\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 1e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = 0);\n\t\tif (!findcr) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\t// assert(SZ(cir) > 1);\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) { ideg[u] = 0; T[u].clear(); }\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tauto lim = UB(DT[u], in[u]); \n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v]) {\t// find it!\n\t\t\twhile (top > 0 && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); if (top > 0) --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tSCir(v, u);\n\t\tif (findcr) return;\n\t} if (top > 0 && S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define SIZE(c) (int) (c).size()\n#define FORE(i,c) FOR(i,0,SIZE(c)-1)\n#define FORDE(i,c) FORD(i,SIZE(c)-1,0)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> pii;\ntypedef pair <ll,ll> pll;\n\ntypedef vector <int> VI;\ntypedef vector <bool> VB;\ntypedef vector <pii> VP;\ntypedef vector <ll> VL;\ntypedef vector <pll> VPL;\n\ntypedef vector <VI> VVI;\ntypedef vector <VL> VVL;\ntypedef vector <VB> VVB;\ntypedef vector <VP> VVP;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000001;\nconst ll LINF = 1000000000000000001LL;\n\n/*************************************************************************/\n\nconst int N = 200004;\nll fact[N], revFact[N];\n\nll expo(ll a, ll n, ll mod) {\n    ll ans = 1;\n\n    while (n) {\n        if (n & 1LL) ans = (ans * a) % mod;\n\n        n >>= 1;\n        a = (a * a) % mod;\n    }\n\n    return ans;\n}\n\nll revMod(ll a, ll mod) {\n    return expo(a, mod - 2, mod);\n}\n\nvoid pre() {\n    fact[0] = revFact[0] = 1;\n    FOR(i,1,N-1) {\n        fact[i] = (i * fact[i-1]) % MOD;\n        revFact[i] = revMod(fact[i], MOD);\n    }\n}\n\nll binom(int n, int m) {\n    if (m > n) return 0;\n\n    ll res = (fact[n] * revFact[n-m]) % MOD;\n    res = (res * revFact[m]) % MOD;\n    \n    return res;\n}\n\nll interleave(int n, int m) {\n    return binom(n + m, n);\n}\n\n/*************************************************************************/\n\npii dfs(int v, int par, VVI &g) {\n    ll ans = 1, sub = 0;\n    \n    for (int u : g[v]) if (u != par) {\n        auto p = dfs(u, v, g);\n        \n        int uAns = p.st;\n        int uSub = p.nd;\n        \n        ans = (ans * uAns) % MOD;\n        ans = (ans * interleave(sub, uSub)) % MOD;\n        \n        sub += uSub;\n    }\n    \n    sub++;\n    \n    return {(int) ans, sub};\n}\n\nint solveEdgeGraph(int n, VVI &edgeGraph) {\n    return dfs(n-1, -1, edgeGraph).st;\n}\n\nint solveWithDir(int n, VI &dir, VVI &g) {\n    map <pii,int> edgeId;\n    int curr = 0;\n    \n    FOR(i,0,n-1) for (int j : g[i]) if (i < j) {\n        edgeId[{i, j}] = curr++;\n    }\n    \n    VVI edgeGraph(n+1);\n    \n    auto getEdgeId = [&](int i, int j) {\n        auto p = minmax(i, j);\n        return edgeId[p];\n    };\n    \n    VB root(n, true);\n    FOR(i,0,n-1) for (int j : g[i]) if (j < dir[i]) {\n        int a = getEdgeId(i, j);\n        int b = getEdgeId(i, dir[i]);\n        \n        edgeGraph[b].pb(a);\n        root[a] = false;\n    }\n    \n    FOR(i,0,n-1) if (root[i]) {\n        edgeGraph[n].pb(i);\n    }\n    \n    return solveEdgeGraph(n+1, edgeGraph);\n}\n\nint solve(int n, VVI &g) {\n    VI deg(n);\n    FOR(i,0,n-1) deg[i] = SIZE(g[i]);\n    \n    int edges = 0;\n    FOR(i,0,n-1) edges += deg[i];\n    \n    if (edges / 2 != n) {\n        return 0;\n    }\n    \n    queue <int> q;\n    FOR(i,0,n-1) if (deg[i] == 1) {\n        q.push(i);\n    }\n    \n    VB removed(n, false);\n    VI dir(n,-1);\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        removed[v] = true;\n        \n        for (int u : g[v]) if (!removed[u]) {\n            dir[v] = u;\n            deg[u]--;\n            \n            if (deg[u] == 1) {\n                q.push(u);\n            }\n            \n            break;\n        }\n    }\n    \n    int v;\n    FOR(i,0,n-1) if (!removed[i]) {\n        v = i;\n        break;\n    }\n    \n    auto getNeigh = [&](int v, int otherThan) {\n        for (int u : g[v]) if (!removed[u] && u != otherThan) {\n            return u;\n        }\n        \n        return -1;\n    };\n    \n    VI cycle = {v};\n    int prev = -1;\n    \n    while (true) {\n        int next = getNeigh(v, prev);\n        if (next == -1) break;\n        \n        cycle.pb(next);\n        \n        removed[v] = true;\n        prev = v;\n        v = next;\n    }\n    \n    ll ans = 0;\n    \n    FOR(_,0,1) {\n        FORE(i,cycle) {\n            dir[cycle[i]] = cycle[(i + 1) % SIZE(cycle)];\n        }\n        \n        ans = (ans + solveWithDir(n, dir, g)) % MOD;\n        reverse(cycle.begin(), cycle.end());\n    }\n    \n    return ans;\n}\n\n/*************************************************************************/\n\nstruct FAU {\n    VI p, r;\n\n    FAU(int n): p(n,-1), r(n,0) {}\n\n    int find(int x) {\n        if (p[x] == -1) return x;\n        return p[x] = find(p[x]);\n    }\n\n    void join(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return ;\n\n        if (r[x] > r[y]) p[y] = x;\n        else p[x] = y;\n\n        if (r[x] == r[y]) ++r[y];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    pre();\n    \n    int n;\n    cin >> n;\n    \n    int v = 2 * n;\n    \n    VVI g(v);\n    FAU fau(v);\n    \n    FOR(_,1,v) {\n        int x, y;\n        cin >> x >> y; x--; y--;\n        \n        g[x].pb(n + y);\n        g[n + y].pb(x);\n        \n        fau.join(x, n + y);\n    }\n    \n    VVI comp(v);\n    FOR(i,0,v-1) {\n        comp[fau.find(i)].pb(i);\n    }\n    \n    ll ans = 1;\n    int currSize = 0;\n    \n    for (auto &c : comp) if (!c.empty()) {\n        int m = SIZE(c);\n        VVI shrG(m);\n        \n        for (int v : c) {\n            int vId = lower_bound(c.begin(), c.end(), v) - c.begin();\n            \n            for (int u : g[v]) {\n                int uId = lower_bound(c.begin(), c.end(), u) - c.begin();\n                shrG[vId].pb(uId);\n            }\n        }\n        \n        ll here = solve(m, shrG);\n        \n        ans = (ans * here) % MOD;\n        ans = (ans * interleave(currSize, m)) % MOD;\n        \n        currSize += m;\n    }\n    \n    cout << ans;\n\n    return 0;\n}\n\n/*************************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <fstream>\n\ntypedef long long LL;\ntypedef unsigned long long uLL;\n\n#define PII pair<int, int>\n#define SZ(x) ((int)x.size())\n#define ALL(x) (x).begin(), (x).end()\n#define MP(x, y) std::make_pair(x, y)\n#define DE(x) cerr << x << endl;\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define GO cerr << \"GO\" << endl;\n#define rep(i, a, b) for (register int (i) = (a); (i) <= (b); ++(i))\n\nusing namespace std;\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\ninline int read() \n{\n\tregister int x = 0; register int f = 1; register char c;\n\twhile (!isdigit(c = getchar())) if (c == '-') f = -1;\n\twhile (x = (x << 1) + (x << 3) + (c xor 48), isdigit(c = getchar()));\n\treturn x * f;\n}\ntemplate<class T> inline void write(T x) \n{\n\tstatic char stk[30]; static int top = 0;\n\tif (x < 0) { x = -x, putchar('-'); }\n\twhile (stk[++top] = x % 10 xor 48, x /= 10, x);\n\twhile (putchar(stk[top--]), top);\n}\ntemplate<typename T> inline bool chkmin(T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\n\nconst int maxN = (int) 2e5;\nconst int mod = (int) 1e9 + 7;\n\nstruct Edge\n{\n\tint v, w;\n\tEdge() { }\n\tEdge(int v, int w) : v(v), w(w) { }\n} ;\n\nint n;\nbool vis[maxN + 2], instk[maxN + 2], found, in_cir[maxN + 2], choose[maxN + 2];\nint top, val[maxN + 2], par[maxN + 2], size[maxN + 2];\nPII stk[maxN + 2];\nvector<pair<int, int> > circle;\nvector<int> node;\nvector<Edge> g[maxN + 2];\n\nnamespace math\n{\n\tint fac[2 * maxN + 2], ifac[2 * maxN + 2];\n\tLL qpow(LL a, LL b)\n\t{\n\t\tLL ans = 1;\n\t\twhile (b)\n\t\t{\n\t\t\tif (b & 1) \n\t\t\t\tans = ans * a % mod;\n\t\t\ta = a * a % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= 2 * n; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tifac[2 * n] = qpow(fac[2 * n], mod - 2);\n\t\tfor (int i = 2 * n - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;\n\t}\n\tint C(int n, int m) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\tint merge(int a, int b) { return C(a + b, a); }\n}\nusing namespace math;\n\nvoid input()\n{\n\tn = read() << 1;\n\tfor (int i = 1; i <= n; ++i) \n\t{\n\t\tint x = read(), y = read();\n\t\tg[x].emplace_back(y + n / 2, x + y);\n\t\tg[y + n / 2].emplace_back(x, x + y);\n\t\tchoose[x] = choose[y + n / 2] = 1;\n\t}\n}\n\nvoid dfs_circle(int x, int fa, int edge)\n{\n\tif (found) return;\n\tstk[++top] = MP(x, edge);\n\tinstk[x] = 1;\n\tfor (Edge E : g[x])\n\t{\n\t\tint v = E.v, w = E.w;\n\t\tif (v == fa) continue;\n\t\tif (!instk[v])\n\t\t{\n\t\t\tdfs_circle(v, x, w);\n\t\t}\n\t   \telse\n\t\t{\n\t\t\tint To = v;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tv = stk[top].first;\n\t\t\t\tin_cir[v] = 1;\n\t\t\t\tcircle.push_back(stk[top--]);\n\t\t\t} while (v != To);\n\t\t\tcircle.back().second = w;\n\t\t\tfound = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (found) return;\n\t}\n\tinstk[x] = 0;\n\ttop--;\n}\n\nvoid dfs1(int u, int fa)\n{\n\tvis[u] = 1;\n\tnode.push_back(u);\n\tfor (Edge E : g[u])\n\t{\n\t\tint v = E.v, w = E.w;\n\t\tif (v != fa and !in_cir[v])\n\t\t{\n\t\t\tval[v] = w;\n\t\t\tdfs1(v, u);\n\t\t}\n\t}\n}\n\nint dfs2(int u)\n{\n\tint ans = 1;\n\tsize[u] = 0;\n\tfor (Edge E : g[u])\n\t{\n\t\tint v = E.v;\n\t\tif (par[v] != u) continue;\n\t\tint cur = dfs2(v);\n\t\tans = 1ll * ans * cur % mod * merge(size[u], size[v]) % mod;\n\t\tsize[u] += size[v];\n\t}\n\tsize[u]++;\n\treturn ans;\n}\n\nint calc()\n{\n\tfor (int u : node)\n\t{\n\t\tsize[u] = 0;\n\t\tpar[u] = 0;\n\t}\n\tfor (int u : node)\n\t{\n\t\tfor (Edge E : g[u])\n\t\t{\n\t\t\tint v = E.v, w = E.w;\n\t\t\tif (w < val[u]) par[v] = u;\n\t\t}\n\t}\n\tint SIZE = 0, ans = 1;\n\tfor (int u : node)\n\t{\n\t\tif (!par[u])\n\t\t{\n\t\t\tint cur = dfs2(u);\n\t\t\tans = 1ll * ans * cur % mod * merge(SIZE, size[u]) % mod;\n\t\t\tSIZE += size[u];\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve()\n{\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcnt += choose[i];\n\tif (cnt != n)\n\t{\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tint SIZE = 0, ans = 1;\n\tfor (int i = 1; i <= n && ans; ++i)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tint cur = 0;\n\t\t\ttop = 0;\n\t\t\tfound = 0;\n\t\t\tcircle.clear();\n\t\t\tdfs_circle(i, 0, 0);\n\n\t\t\tnode.clear();\n\t\t\tfor (int j = 0; j < SZ(circle); ++j) dfs1(circle[j].first, 0);\n\n\t\t\tfor (int j = 0; j < SZ(circle); ++j) \n\t\t\t\tval[circle[j].first] = circle[j].second;\n\t\t\t(cur += calc()) %= mod;\n\n\t\t\tcircle.push_back(circle[0]);\n\t\t\tfor (int j = 1; j < SZ(circle); ++j)\n\t\t\t\tval[circle[j].first] = circle[j - 1].second;\n\t\t\t(cur += calc()) %= mod;\n\n\t\t\tans = 1ll * ans * cur % mod * merge(SIZE, node.size()) % mod;\n\t\t\tSIZE += node.size();\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() \n{ \n\tinput();\n\tmath::init();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lowbit(o) o&(-o)\n#define P 1000000007\n#define N 200005\n#define M 400005\n#define pb push_back\nusing namespace std;\nint i,j,k,l,s,r,n,m,jc[N],ny[N],fa[N],A[2][N],B[2][N],tot,T,vis[2][N],id[N],Si[2][N];\nint ans,Ans,si,G[N];\nvector<int>GT[2][N],V[2][N];\nvector<int>::iterator GTW;\nstruct orz {\n\tint x,y;\n}a[N],q[N],Q[N];\nstruct node {\n\tint tot,last[N],to[M],next[M];\n\tinline void add(int x,int y) {\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A1;\nstruct Node {\n\tint tot,chu[N],ru[N],l,r,last[N],next[M],to[M],f[N],si[N];\n\torz q[N];\n\tinline void add(int x,int y) {\n\t\tchu[x]++; ru[y]++;\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A2;\ninline bool cmp(int x,int y) {\n\treturn G[x]<G[y];\n}\ninline int findl(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=0;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]<x) s=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn s+1;\n}\ninline int findr(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=2*n+1;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]>x) s=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn s-1;\n}\ninline int quick(int x,int y) {\n\tint s=1;\n\twhile (y) {\n\t\tif (y&1) s=1ll*s*x%P;\n\t\tx=1ll*x*x%P;\n\t\ty>>=1;\n\t}\n\treturn s;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\ninline int C(int x,int y) {\n\treturn 1ll*jc[x]*ny[y]%P*ny[x-y]%P;\n}\ninline int getans(int r) {\n\tT=s=0;\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].pb(q[i].y);\n\tint L=findl(get(q[1].x*n+q[1].y)),R=findr(get(q[1].x*n+q[1].y));\n\tfor (int i=L;i<=R;i++) {\n\t\ts++;\n\t\tQ[++T].x=(id[i]-1)/n,Q[T].y=(id[i]-1)%n+1;\n\t\tif (A[Q[T].x][Q[T].y]) {\n \t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>A[Q[T].x][Q[T].y]) continue;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>B[Q[T].x][Q[T].y]) continue;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t}\n\tA2.l=A2.r=0;\n\tA2.f[A2.si[0]=0]=1;\n\tfor (int i=1;i<=T;i++) A2.f[Q[i].x*n+Q[i].y]=1;\n\tfor (int i=1;i<=T;i++) if (!A2.chu[Q[i].x*n+Q[i].y]) A2.add(Q[i].x*n+Q[i].y,0);\n\tfor (int i=1;i<=T;i++) if (!A2.ru[Q[i].x*n+Q[i].y]) A2.q[++A2.r].x=Q[i].x,A2.q[A2.r].y=Q[i].y;\n\twhile (A2.l<A2.r) {\n\t\tA2.l++;\n\t\tA2.si[A2.q[A2.l].x*n+A2.q[A2.l].y]++;\n\t\tfor (int i=A2.last[A2.q[A2.l].x*n+A2.q[A2.l].y];i;i=A2.next[i]) {\n\t\t\tA2.ru[A2.to[i]]--;\n\t\t\tA2.si[A2.to[i]]+=A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y];\n\t\t\t(A2.f[A2.to[i]]=1ll*A2.f[A2.to[i]]*A2.f[A2.q[A2.l].x*n+A2.q[A2.l].y]%P*C(A2.si[A2.to[i]],A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y])%P);\n\t\t\tif (!A2.ru[A2.to[i]]) A2.q[++A2.r].x=(A2.to[i]-1)/n,A2.q[A2.r].y=(A2.to[i]-1)%n+1;\n\t\t}\n\t}\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].pop_back();\n\tA2.tot=0;\n\tfor (int i=1;i<=A2.r;i++) A2.last[A2.q[i].x*n+A2.q[i].y]=0,A2.chu[A2.q[i].x*n+A2.q[i].y]=A2.ru[A2.q[i].x*n+A2.q[i].y]=0;\n\tfor (int i=1;i<=T;i++) A2.f[A2.q[i].x*n+A2.q[i].y]=A2.si[A2.q[i].x*n+A2.q[i].y]=0;\n\treturn A2.f[0];\n}\ninline void work(int x,int y) {\n\tvis[x][y]=1;\n\tint l=0,r=1; q[1].x=x,q[1].y=y;\n\twhile (l<r) {\n\t\t++l;\n\t\tfor (GTW=GT[q[l].x][q[l].y].begin();GTW!=GT[q[l].x][q[l].y].end();GTW++) if (!vis[q[l].x^1][(*GTW)]) q[++r].x=q[l].x^1,q[r].y=(*GTW),vis[q[r].x][q[r].y]=1;\n\t}\n\tfor (int i=1;i<=r;i++) \n\tfor (GTW=GT[q[i].x][q[i].y].begin();GTW!=GT[q[i].x][q[i].y].end();GTW++) A1.add(q[i].x*n+q[i].y,(*GTW));\n\tint xx=x,yy=y;\n\tB[xx][yy]=A1.to[A1.last[xx*n+yy]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) \n\t\tif (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tAns=getans(r);\n\t\n\tfor (int i=1;i<=r;i++) B[q[i].x][q[i].y]=0;\n\tB[xx][yy]=A1.to[A1.next[A1.last[xx*n+yy]]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) if (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tA1.tot=0;\n\tfor (int i=1;i<=r;i++) A1.last[q[i].x*n+q[i].y]=0;\n\t(Ans+=getans(r))%=P;\n\tsi+=s;\n\t(ans=1ll*ans*Ans%P*C(si,s)%P);\n}\ninline void doit() {\n\tjc[0]=1;\n\tfor (int i=1;i<=200000;i++) jc[i]=1ll*jc[i-1]*i%P;\n\tny[200000]=quick(jc[200000],P-2);\n\tfor (int i=199999;i;i--) ny[i]=1ll*ny[i+1]*(i+1)%P;\n\tny[0]=1;\n}\nvoid R(int &x) {\n\tx=0;char ch=getchar();\n\twhile (ch<'0' || '9'<ch) ch=getchar();\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n}\nint main() {\n\tdoit();\n\tans=1; si=0;\n\tR(n);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) fa[i*n+j]=i*n+j;\n\tfor (i=1;i<=2*n;i++) {\n\t\tR(a[i].x),R(a[i].y);\n\t\tif (get(a[i].x)!=get(n+a[i].y)) fa[get(a[i].x)]=get(n+a[i].y);\n\t\tGT[0][a[i].x].pb(a[i].y);\n\t\tSi[0][a[i].x]++;\n\t\tSi[1][a[i].y]++;\n\t\tGT[1][a[i].y].pb(a[i].x);\n\t}\n\tfor (i=1;i<=2*n;i++) if (get(id[i]=i)==i) G[i]=++tot;\n\tfor (i=1;i<=2*n;i++) G[i]=G[get(i)];\n\ttot=0;\n\tsort(id+1,id+1+2*n,cmp);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!Si[i][j]) return puts(\"0\"),0;\n\telse if (Si[i][j]==1) q[++r].x=i,q[r].y=j;\n\twhile (l<r) {\n\t\t++l;\n\t\tif (!Si[q[l].x][q[l].y]) return puts(\"0\"),0;\n\t\tfor (GTW=GT[q[l].x][q[l].y].begin();GTW!=GT[q[l].x][q[l].y].end();GTW++) if (A[q[l].x^1][*GTW]!=q[l].y)\n\t\tA[q[l].x][q[l].y]=(*GTW);\n\t\tSi[q[l].x^1][A[q[l].x][q[l].y]]--;\n\t\tif (Si[q[l].x^1][A[q[l].x][q[l].y]]==1) q[++r].x=q[l].x^1,q[r].y=A[q[l].x][q[l].y];\n\t}\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) GT[i][j].clear();\n\tfor (i=1;i<=2*n;i++) if (A[0][a[i].x]!=a[i].y&&A[1][a[i].y]!=a[i].x) {\n\t\tGT[0][a[i].x].pb(a[i].y);\n\t\tGT[1][a[i].y].pb(a[i].x);\n\t}\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (A[i][j]) V[i^1][A[i][j]].pb(j);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!vis[i][j]&&GT[i][j].size()==2) \n\twork(i,j);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N];\n\nint cnt,head[N];\nstruct Xint{int to,next;}V[N*8];\nvoid add(int x,int y){\n\tV[++cnt]=(Xint){y,head[x]};head[x]=cnt;\n\tV[++cnt]=(Xint){x,head[y]};head[y]=cnt;\n}\n\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;\n\tstk[++top]=x;instk[x]=1;\n\tfor(int i=head[x];i;i=V[i].next){\n\t\tint y=V[i].to;if(y!=f)dfs(x,y);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)add(vx[i][j],vx[i][j+1]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)add(vy[i][j],vy[i][j+1]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            chain_t c = use_generic(i, true);\n            return c * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            chain_t c = use_generic(i, false);\n            return c * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        try {\n            REP (y, n) acc = acc * go_row(y);\n            REP (x, n) acc = acc * go_col(x);\n        } catch (bool e) {\n            assert (not e);\n            acc.size = -1;\n        }\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n有点恶心。\n\n每个机器人看做一个点，平面上的每个点看做连接机器人的边。\n形成的图一定是基环树森林。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) // fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 400005, mod = 1000000007;\nint head[maxn], nxt[maxn << 2], to[maxn << 2], hp = 1;\n\ninline ll power(ll x, int k) {\n\tif(k < 0) k += mod - 1;\n\tll res = 1;\n\twhile(k) {\n\t\tif(k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline void add(int u, int v, int *h) {\n\tnxt[++ hp] = h[u];\n\th[u] = hp;\n\tto[hp] = v;\n}\n\nint tmp[maxn], tp;\nbool vis[maxn];\nint cx, cy;\nint dfs(int u, int f) {\n\t/* debug(\"%d -> %d\\n\", f, u); */\n\ttmp[++ tp] = u;\n\tvis[u] = 1;\n\tint res = 0;\n\n\tfor(int i = head[u]; i; i = nxt[i]) {\n\t\t++ res;\n\t\tif(to[i] != f) {\n\t\t\tif(vis[to[i]]) {\n\t\t\t\tcx = u;\n\t\t\t\tcy = to[i];\n\t\t\t} else\n\t\t\t\tres += dfs(to[i], u);\n\t\t}\n\t}\n\n\t/* debug(\"dfs %d %d\\n\", u, res); */\n\n\treturn res;\n}\n\nint match[maxn];\nvoid mdfs(int u, int f) {\n\t/* debug(\"%d -> %d\\n\", f, u); */\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f and to[i] != cx) {\n\t\t\tmatch[to[i]] = u;\n\t\t\tmdfs(to[i], u);\n\t\t}\n}\n\nint Head[maxn];\nint deg[maxn];\nint stack[maxn], sp;\nll f[maxn];\nint size[maxn];\nll fac[maxn], ifac[maxn];\n\ninline ll C(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint force_count;\nvoid dp(int u) {\n\t++ force_count;\n\tif(force_count >= 100) {\n\t\tputs(\"0\");\n\t\texit(0);\n\t}\n\n\tsize[u] = 0;\n\tf[u] = 1;\n\tfor(int i = Head[u]; i; i = nxt[i]) {\n\t\tdp(to[i]);\n\t\tsize[u] += size[to[i]];\n\t\t(f[u] *= f[to[i]]) %= mod;\n\t\t(f[u] *= C(size[u], size[to[i]])) %= mod;\n\t}\n\t++ size[u];\n\tdebug(\"%d : %lld %d\\n\", u, f[u], size[u]);\n}\n\nint HP;\nll solve() {\n\tdebug(\"solve %d %d\\n\", cx, cy);\n\tmdfs(cx, cy);\n\tmatch[cx] = cy;\n\n\thp = HP;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tdeg[tmp[i]] = Head[tmp[i]] = 0;\n\n\tfor(int id = 1; id <= tp; id ++) {\n\t\tint u = tmp[id];\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] < match[u]) {\n\t\t\t\tdebug(\"%d -> %d\\n\", u, to[i]);\n\t\t\t\tadd(u, to[i], Head);\n\t\t\t\t++ deg[to[i]];\n\t\t\t}\n\t}\n\n\tHead[0] = 0;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tif(!deg[tmp[i]])\n\t\t\tadd(0, tmp[i], Head);\n\n\tdp(0);\n\tdebug(\"get %lld\\n\", f[0]);\n\n\treturn f[0];\n}\n\nint main() {\n\tint n = read;\n\n\tint N = n << 1 | 1;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[N] = power(fac[N], -1);\n\tfor(int i = N; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n\n\tfor(int i = 1; i < N; i ++) {\n\t\tint x = read, y = read;\n\t\tadd(x, n + y, head);\n\t\tadd(n + y, x, head);\n\t}\n\n\tHP = hp;\n\tll ans = 1;\n\tint SIZE = 0;\n\n\tfor(int r = 1; r < N; r ++)\n\t\tif(!vis[r]) {\n\t\t\ttp = 0;\n\t\t\tif(dfs(r, 0) != (tp << 1)) return puts(\"0\"), 0;\n\t\t\tll now = solve();\n\t\t\tstd::swap(cx, cy);\n\t\t\tnow += solve();\n\t\t\tSIZE += size[0] - 1;\n\t\t\t(ans *= now) %= mod;\n\t\t\t(ans *= C(SIZE, size[0] - 1)) %= mod;\n\t\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nconst int mod = 1e9 + 7;\nconst int nax = 2e5 + 44;\nint u[nax];\nvi graf[nax];\nint deg[nax];\nbool cyc[nax];\nll fac[nax], fin[nax];\nvoid reset() {\n\tiota(u, u + nax, 0);\n}\nint find(int x) {\n\tif (u[x] == x) return x;\n\treturn u[x] = find(u[x]);\n}\nvoid err() {\n\tdone(\"0\\n\");\n}\nvoid onion(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b) {\n\t\tif (cyc[a]) err();\n\t\tcyc[a] = true;\n\t}\n\telse {\n\t\tif (cyc[a] && cyc[b]) err();\n\t\tcyc[b] = cyc[a] && cyc[b];\n\t\tu[a] = b;\n\t}\n}\nbool on_cycle[nax];\nbool seen[nax];\nvi centers;\nint dfs(int x, int y = -1) {\n\tif (seen[x]) {\n\t\tdebug(\"on cycle\", imie(x));\n\t\ton_cycle[x] = true;\n\t\tcenters.push_back(x);\n\t\treturn x;\n\t}\n\tseen[x] = true;\n\tfor (int v : graf[x]) if (v != y) {\n\t\tint r = dfs(v, x);\n\t\tif (r != -1) {\n\t\t\tif (r == x) return -1;\n\t\t\tdebug(\"on cycle\", imie(x));\n\t\t\ton_cycle[x] = true;\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn -1;\n}\nvi coms[nax];\nvoid find_cycle(int x, int p, vi &cycle) {\n\tif (!cycle.empty() && cycle[0] == x) return;\n\tcycle.push_back(x);\n\tfor (int v : graf[x]) if (v != p && on_cycle[v]) {\n\t\tfind_cycle(v, x, cycle);\n\t\treturn;\n\t}\n}\nvoid dfs2(int x, map <int, int> &dir, int p = -1) {\n\tfor (int v : graf[x]) if (v != p && !on_cycle[v]) {\n\t\tdir[v] = x;\n\t\tdfs2(v, dir, x);\n\t}\n}\nll inv(ll x) {\n\tint e = mod - 2;\n\tll r = 1;\n\twhile (e) {\n\t\tif (e & 1) r = r * x % mod;\n\t\tx = x * x % mod;\n\t\te >>= 1;\n\t}\n\treturn r;\n}\nll run(int x) {\n\tvi &vers = coms[find(x)];\n\tvi cycle;\n\tfind_cycle(x, -1, cycle);\n\tdebug(imie(cycle));\n\tdebug(imie(x));\n\tmap <int, int> dir0;\n\tfor (int y : cycle) dfs2(y, dir0);\n\tconst int l = cycle.size();\n\tll ans = 0;\n\tREP(_, 2) {\n\t\tll a = fac[vers.size()];\n\t\tmap <int, int> dir = dir0;\n\t\tREP(i, l) dir[cycle[i]] = cycle[(i + 1) % l];\n\t\tmap <int, int> siz;\n\t\tfor (int y : vers) siz[y] = 1;\n\t\treverse(ALL(cycle));\n\t\tvector <pair <pii, int> > ord;\n\t\tfor (int y : vers) {\n\t\t\tint t = dir[y];\n\t\t\tord.emplace_back(make_pair(min(t, y), max(t, y)), y);\n\t\t}\n\t\tsort(ALL(ord));\n\t\tfor (auto c : ord) {\n\t\t\tint now = c.second;\n\t\t\t(a *= inv(siz[now])) %= mod;\n\t\t\tint oth = dir[now];\n\t\t\tif (dir[oth] > now) siz[oth] += siz[now];\n\t\t}\n\t\tans += a;\n\t}\n\trans;\n}\nll choose(int a, int b) {\n\treturn fac[a] * fin[b] % mod * fin[a - b] % mod;\n}\nvoid solve() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < nax; ++i) fac[i] = fac[i - 1] * i % mod;\n\tfin[nax - 1] = inv(fac[nax - 1]);\n\tfor (int i = nax - 2; i >= 0; --i) fin[i] = fin[i + 1] * (i + 1) % mod;\n\treset();\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(_, 2 * n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ty += n;\n\t\tonion(x, y);\n\t\tgraf[x].push_back(y);\n\t\tgraf[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= 2 * n; ++i) if (find(i) == i) dfs(i);\n\tll ans = 1;\n\tfor (int i = 1; i <= 2 * n; ++i) coms[find(i)].push_back(i);\n\tint rest = 2 * n;\n\tfor (int i = 1; i <= 2 * n; ++i) {\n\t\t(ans *= choose(rest, coms[i].size())) %= mod;\n\t\trest -= coms[i].size();\n\t}\n\tfor (int x : centers)\n\t\t(ans *= run(x)) %= mod;\n\tprintf(\"%lld\\n\", ans);\n}\nint main() {\n\t// unt seed = TIME; debug(imie(seed));srand(seed);\n\tint t = 1;\n\t// scanf(\"%d\", &t);\n\tREP(_, t) solve();\n\texit(0);\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long LL;\nconst int N=200005,mo=1000000007;\nint fst[N],v[N],pre[N],sz[N],tot=1,cntv,cnte,ed,t,n;\nLL fac[N],inv[N];\nbool vis[N];\nstruct Edge{\n\tint to,nxt;\n}e[N*2];\nvoid addedge(int x,int y){\n\te[++tot].to=y;e[tot].nxt=fst[x];fst[x]=tot;\n}\nvoid dfs(int x,int fa){\n\tvis[x]=1;cntv++;\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;cnte++;\n\t\tif (y!=fa){\n\t\t\tif (vis[y]) ed=i;\n\t\t\t\telse dfs(y,x);\n\t\t}\n\t}\n}\nvoid dfs2(int x,int fa){\n\tpre[x]=fa;\n\tfor (int i=fst[x];i;i=e[i].nxt)\n\t\tif (i/2!=ed/2 && e[i].to!=fa) dfs2(e[i].to,x);\n\tif (pre[pre[x]]<x) v[++t]=x;\n}\nLL C(int n,int m){\n\treturn fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nint dfs3(int x){\n\tLL cnt=1;sz[x]=0;\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (y<pre[x]){\n\t\t\tint z=dfs3(y);\n\t\t\tsz[x]+=sz[y];\n\t\t\tcnt=cnt*z%mo*C(sz[x],sz[y])%mo;\n\t\t}\n\t}\n\tsz[x]++;\n\treturn cnt;\n}\nint solve(){\n\tt=0;dfs2(e[ed^1].to,e[ed].to);\n\tint cnt=1;\n\tfor (int i=1,x=0;i<=t;i++){\n\t\tint y=dfs3(v[i]);\n\t\tx+=sz[v[i]];\n\t\tcnt=cnt*y%mo*C(x,sz[v[i]])%mo;\n\t}\n\treturn cnt;\n}\nLL ksm(LL x,int y){\n\tLL i=1;\n\tfor (;y;y>>=1,x=x*x%mo)\n\t\tif (y&1) i=i*x%mo;\n\treturn i;\n}\nvoid Pre(){\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mo;\n\tinv[n]=ksm(fac[n],mo-2);\n\tfor (int i=n;i>=1;i--) inv[i-1]=inv[i]*i%mo;\n}\nint main(){\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=0;i<n*2;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\\n\",&x,&y);\n\t\taddedge(x,y+n);\n\t\taddedge(y+n,x);\n\t}\n\tn*=2;Pre();\n\tLL ans=1;\n\tfor (int i=1,x=0;i<=n;i++)\n\tif (!vis[i]){\n\t\tcntv=cnte=0;\n\t\tdfs(i,0);\n\t\tif (cntv*2!=cnte){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint cnt=solve();\n\t\ted^=1;\n\t\tcnt+=solve();\n\t\tx+=cntv;\n\t\tans=ans*cnt%mo*C(x,cntv)%mo;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define FOR(i,b,e) for(int i=(b); i <= (e); ++i)\n#define FORD(i,b,e) for(int i=(b); i >= (e); --i)\n#define SIZE(c) (int) (c).size()\n#define FORE(i,c) FOR(i,0,SIZE(c)-1)\n#define FORDE(i,c) FORD(i,SIZE(c)-1,0)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> pii;\ntypedef pair <ll,ll> pll;\n\ntypedef vector <int> VI;\ntypedef vector <bool> VB;\ntypedef vector <pii> VP;\ntypedef vector <ll> VL;\ntypedef vector <pll> VPL;\n\ntypedef vector <VI> VVI;\ntypedef vector <VL> VVL;\ntypedef vector <VB> VVB;\ntypedef vector <VP> VVP;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000001;\nconst ll LINF = 1000000000000000001LL;\n\n/*************************************************************************/\n\nconst int N = 100004;\nll fact[N], revFact[N];\n\nll expo(ll a, ll n, ll mod) {\n    ll ans = 1;\n\n    while (n) {\n        if (n & 1LL) ans = (ans * a) % mod;\n\n        n >>= 1;\n        a = (a * a) % mod;\n    }\n\n    return ans;\n}\n\nll revMod(ll a, ll mod) {\n    return expo(a, mod - 2, mod);\n}\n\nvoid pre() {\n    fact[0] = revFact[0] = 1;\n    FOR(i,1,N-1) {\n        fact[i] = (i * fact[i-1]) % MOD;\n        revFact[i] = revMod(fact[i], MOD);\n    }\n}\n\nll binom(int n, int m) {\n    if (m > n) return 0;\n\n    ll res = (fact[n] * revFact[n-m]) % MOD;\n    res = (res * revFact[m]) % MOD;\n    \n    return res;\n}\n\nll interleave(int n, int m) {\n    return binom(n + m, n);\n}\n\n/*************************************************************************/\n\npii dfs(int v, int par, VVI &g) {\n    ll ans = 1, sub = 0;\n    \n    for (int u : g[v]) if (u != par) {\n        auto p = dfs(u, v, g);\n        \n        int uAns = p.st;\n        int uSub = p.nd;\n        \n        ans = (ans * uAns) % MOD;\n        ans = (ans * interleave(sub, uSub)) % MOD;\n        \n        sub += uSub;\n    }\n    \n    sub++;\n    \n    return {(int) ans, sub};\n}\n\nint solveEdgeGraph(int n, VVI &edgeGraph) {\n    return dfs(n-1, -1, edgeGraph).st;\n}\n\nint solveWithDir(int n, VI &dir, VVI &g) {\n    map <pii,int> edgeId;\n    int curr = 0;\n    \n    FOR(i,0,n-1) for (int j : g[i]) if (i < j) {\n        edgeId[{i, j}] = curr++;\n    }\n    \n    VVI edgeGraph(n+1);\n    \n    auto getEdgeId = [&](int i, int j) {\n        auto p = minmax(i, j);\n        return edgeId[p];\n    };\n    \n    VB root(n, true);\n    FOR(i,0,n-1) for (int j : g[i]) if (j < dir[i]) {\n        int a = getEdgeId(i, j);\n        int b = getEdgeId(i, dir[i]);\n        \n        edgeGraph[b].pb(a);\n        root[a] = false;\n    }\n    \n    FOR(i,0,n-1) if (root[i]) {\n        edgeGraph[n].pb(i);\n    }\n    \n    return solveEdgeGraph(n+1, edgeGraph);\n}\n\nint solve(int n, VVI &g) {\n    VI deg(n);\n    FOR(i,0,n-1) deg[i] = SIZE(g[i]);\n    \n    int edges = 0;\n    FOR(i,0,n-1) edges += deg[i];\n    \n    if (edges / 2 != n) {\n        return 0;\n    }\n    \n    queue <int> q;\n    FOR(i,0,n-1) if (deg[i] == 1) {\n        q.push(i);\n    }\n    \n    VB removed(n, false);\n    VI dir(n,-1);\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        removed[v] = true;\n        \n        for (int u : g[v]) if (!removed[u]) {\n            dir[v] = u;\n            deg[u]--;\n            \n            if (deg[u] == 1) {\n                q.push(u);\n            }\n            \n            break;\n        }\n    }\n    \n    int v;\n    FOR(i,0,n-1) if (!removed[i]) {\n        v = i;\n        break;\n    }\n    \n    auto getNeigh = [&](int v, int otherThan) {\n        for (int u : g[v]) if (!removed[u] && u != otherThan) {\n            return u;\n        }\n        \n        return -1;\n    };\n    \n    VI cycle = {v};\n    int prev = -1;\n    \n    while (true) {\n        int next = getNeigh(v, prev);\n        if (next == -1) break;\n        \n        cycle.pb(next);\n        \n        removed[v] = true;\n        prev = v;\n        v = next;\n    }\n    \n    ll ans = 0;\n    \n    FOR(_,0,1) {\n        FORE(i,cycle) {\n            dir[cycle[i]] = cycle[(i + 1) % SIZE(cycle)];\n        }\n        \n        ans = (ans + solveWithDir(n, dir, g)) % MOD;\n        reverse(cycle.begin(), cycle.end());\n    }\n    \n    return ans;\n}\n\n/*************************************************************************/\n\nstruct FAU {\n    VI p, r;\n\n    FAU(int n): p(n,-1), r(n,0) {}\n\n    int find(int x) {\n        if (p[x] == -1) return x;\n        return p[x] = find(p[x]);\n    }\n\n    void join(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return ;\n\n        if (r[x] > r[y]) p[y] = x;\n        else p[x] = y;\n\n        if (r[x] == r[y]) ++r[y];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    pre();\n    \n    int n;\n    cin >> n;\n    \n    int v = 2 * n;\n    \n    VVI g(v);\n    FAU fau(v);\n    \n    FOR(_,1,v) {\n        int x, y;\n        cin >> x >> y; x--; y--;\n        \n        g[x].pb(n + y);\n        g[n + y].pb(x);\n        \n        fau.join(x, n + y);\n    }\n    \n    VVI comp(v);\n    FOR(i,0,v-1) {\n        comp[fau.find(i)].pb(i);\n    }\n    \n    ll ans = 1;\n    int currSize = 0;\n    \n    for (auto &c : comp) if (!c.empty()) {\n        int m = SIZE(c);\n        VVI shrG(m);\n        \n        for (int v : c) {\n            int vId = lower_bound(c.begin(), c.end(), v) - c.begin();\n            \n            for (int u : g[v]) {\n                int uId = lower_bound(c.begin(), c.end(), u) - c.begin();\n                shrG[vId].pb(uId);\n            }\n        }\n        \n        ll here = solve(m, shrG);\n        \n        ans = (ans * here) % MOD;\n        ans = (ans * interleave(currSize, m)) % MOD;\n        \n        currSize += m;\n    }\n    \n    cout << ans;\n\n    return 0;\n}\n\n/*************************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define mod 1000000007\n#define next nxt\n\nint n,x[N],y[N],z[N],next[N],p[N],h[N],q[N],s[N],cnt,cmt,cir;\nlong long fac[N],inv[N],ans;\nvector<int> v[N];\n\nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nvoid travel(int x,int pre){\n\th[x]=true;q[++cnt]=x;\n\tfor (int t=p[x];t;cmt++,t=next[t])\n\t\tif (!h[y[t]]) travel(y[t],t);\n\t\telse if (t/2!=pre/2) cir=t;\n}\n\nvoid build(int x,int pre){\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (t/2!=pre/2){\n\t\t\tif (t/2!=cir/2) build(y[t],t);\n\t\t\tif (y[t]<y[pre^1]) v[x].push_back(y[t]),h[y[t]]=1;\n\t\t}\n}\n\nlong long solve(int x){\n\ts[x]=0;long long ans=1;\n\tfor (int i=0;i<(int)v[x].size();i++){\n\t\tans=ans*solve(v[x][i])%mod;\n\t\ts[x]+=s[v[x][i]];\n\t\tans=ans*C(s[x],s[v[x][i]])%mod;\n\t}\n\ts[x]++;return ans;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=2*n;i++){\n\t\tx[2*i]=y[2*i+1]=read();\n\t\ty[2*i]=x[2*i+1]=n+read();\n\t\tz[2*i]=z[2*i+1]=x[2*i]+y[2*i];\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t\tnext[2*i+1]=p[x[2*i+1]];p[x[2*i+1]]=2*i+1;\n\t}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tans=fac[2*n];\n\tfor (int i=1;i<=2*n;i++)\n\t\tif (!h[i]){\n\t\t\tcnt=cmt=0;travel(i,0);\n\t\t\tif (cmt!=cnt*2) {printf(\"0\\n\");return 0;}\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),h[q[i]]=false;\n\t\t\tbuild(x[cir],cir);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!h[q[i]]) v[0].push_back(q[i]),h[q[i]]=1;\n\t\t\tlong long tmp=solve(0);\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),h[q[i]]=false;\n\t\t\tbuild(y[cir],cir);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!h[q[i]]) v[0].push_back(q[i]),h[q[i]]=1;\n\t\t\ttmp+=solve(0);\n\t\t\t\n\t\t\tans=ans*tmp%mod*inv[cnt]%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N];\n\nint cnt,head[N];\nstruct Xint{int to,next;}V[N*8];\nvoid add(int x,int y){\n\tV[++cnt]=(Xint){y,head[x]};head[x]=cnt;\n\tV[++cnt]=(Xint){x,head[y]};head[y]=cnt;\n}\n\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;i>0;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;\n\tstk[++top]=x;instk[x]=1;\n\tfor(int i=head[x];i;i=V[i].next){\n\t\tint y=V[i].to;if(y!=f)dfs(x,y);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)add(vx[i][j],vx[i][j+1]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)add(vy[i][j],vy[i][j+1]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define M 200020\n#define mod 1000000007\nusing namespace std;\nnamespace IO{\n    const int BS=(1<<22)+5; int Top=0;\n    char Buffer[BS],OT[BS],*OS=OT,*HD,*TL,SS[20]; const char *fin=OT+BS-1;\n    inline char Getchar(){if(HD==TL){TL=(HD=Buffer)+fread(Buffer,1,BS,stdin);} return (HD==TL)?EOF:*HD++;}\n    inline void write(int x){\n        if(!x){putchar('0');return;} if(x<0) x=-x,putchar('-');\n        while(x) SS[++Top]=x%10,x/=10;\n        while(Top) putchar(SS[Top]+'0'),--Top;\n    }\n    inline int read(){\n        int nm=0; char cw=Getchar(); for(;!isdigit(cw);cw=Getchar());\n        for(;isdigit(cw);cw=Getchar()) nm=nm*10+(cw-'0'); return nm;\n    }\n}\nusing namespace IO;\n#define mul(x,y) (LL)(x)*(y)%mod\n#define upd(x,y) x=((x)+(y)>=mod)?(x)+(y)-mod:(x)+(y)\nint n,m,fs[M],nt[M<<1],to[M<<1],tmp,ans=1,EG,top,ind[M],node[M];\nint S[M],c[M],fa[M],nxt[M],fst[M],tar[M],cur,cnt,sz[M],inv[M],vis[M];\ninline void link(int x,int y){\n    nt[tmp]=fs[x],fs[x]=tmp,to[tmp++]=y;\n    nt[tmp]=fs[y],fs[y]=tmp,to[tmp++]=x;\n}\ninline void edge(int x,int y){nxt[cur]=fst[x],fst[x]=cur,tar[cur++]=y;}\nvoid init(int x,int last){\n    node[++cnt]=x,S[++top]=x,ind[x]=1,S[top+1]=0;\n    for(register int i=fs[x];~i;i=nt[i],EG++){\n        if(to[i]==last) continue;\n        if(!ind[to[i]]){init(to[i],x);continue;}\n        if(m) continue;\n        while(S[top+1]!=to[i]) vis[c[++m]=S[top--]]=true; c[0]=to[i];\n    } top--,ind[x]=2;\n}\nvoid build(int x,int last){\n    for(register int i=fs[x];~i;i=nt[i]){\n        if(vis[to[i]]||to[i]==last) continue;\n        fa[to[i]]=x,build(to[i],x);\n    }\n}\nint dfs(int x){\n    if(sz[x]) return 1; int res=sz[x]=1;\n    for(register int i=fst[x];i!=-1;i=nxt[i]){\n        res=mul(res,dfs(tar[i])),sz[x]+=sz[tar[i]];\n    } return mul(res,inv[sz[x]]);\n}\ninline int calc(){\n    for(int i=1;i<=cnt;i++) fst[node[i]]=-1,sz[node[i]]=0; cur=0; int res=1;\n    for(int x=1;x<=cnt;x++) for(register int i=fs[node[x]];i!=-1;i=nt[i]) if(to[i]<fa[node[x]]) edge(node[x],to[i]);\n    for(int x=1;x<=cnt;x++) if(!sz[node[x]]) res=mul(res,dfs(node[x])); return res;\n}\ninline int solve(int x){\n    top=0,init(x,0); if(EG!=(cnt<<1)) puts(\"0\"),exit(0);\n    for(int i=1;i<=m;i++) build(c[i],0); int res=0;\n    for(int i=1;i<=m;i++) fa[c[i-1]]=c[i]; upd(res,calc());\n    for(int i=1;i<=m;i++) fa[c[i]]=c[i-1]; upd(res,calc());\n    return res;\n}\nint main(){\n    n=read(),ans=inv[1]=1,memset(fs,-1,sizeof(fs));\n    for(int i=2;i<=(n<<1);i++) ans=mul(ans,i),inv[i]=mul(inv[mod%i],mod-(mod/i));\n    for(int i=1;i<=(n<<1);i++) link(read()+n,read());\n    for(int i=1;i<=(n<<1);i++) if(!ind[i]) cnt=m=EG=0,ans=mul(ans,solve(i));\n    printf(\"%d\\n\",ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int N=200005;\nconst int mod=1000000007;\n\nstruct E{\n\tint to,next;\n}mem[N<<1];\nint h,t,num,n,x,y,m,ans,res,sum,ns,siz,ssr;\nint dp[N],sz[N],head[N],tp[N],q[N],fac[N],inv[N],d[N];\nbool vis[N];\n\nvoid addedge(int x,int y){\n\tnum++;\n\tmem[num].to=y; mem[num].next=head[x];\n\thead[x]=num; d[x]++;\n}\n\nint quickpow(int x,int y){\n\tint s=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mod)\n\t\tif (y&1) s=1ll*s*x%mod;\n\treturn s;\n}\n\nvoid init(int n){\n\tint i; fac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=quickpow(fac[n],mod-2);\n\tfor (i=n-1;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int x,int y){\n\tif (x<y) return 0;\n\treturn 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nvoid add(int &x,int y){\n\tx+=y;\n\t(x>=mod)?x-=mod:0;\n}\n\nvoid bfs(int st){\n\tint k,u,j;\n\th=t=0; q[++t]=st;\n\twhile (h<t){\n\t\tk=q[++h]; vis[k]=1;\n\t\tfor (j=head[k];j;j=mem[j].next){\n\t\t\tu=mem[j].to;\n\t\t\tif (!vis[u]){\n\t\t\t\tq[++t]=u; vis[u]=1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid topsort(){\n\tint k,u,j;\n\twhile (h<t){\n\t\tk=tp[++h];\n\t\tfor (j=head[k];j;j=mem[j].next){\n\t\t\tu=mem[j].to; d[u]--;\n\t\t\tif (d[u]==1) tp[++t]=u;\n\t\t}\n\t}\n}\n\nvoid dfs(int k,int pre,int rt){\n\tint u,j;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre||u==rt) continue;\n\t\tdfs(u,k,rt);\n\t}\n\tdp[k]=1; sz[k]=0;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre||u==rt) continue;\n\t\tif (u<pre){\n\t\t\tdp[k]=1ll*dp[k]*dp[u]%mod*C(sz[k]+sz[u],sz[u])%mod;\n\t\t\tsz[k]+=sz[u];\n\t\t}\n\t\telse{\n\t\t\tssr=1ll*ssr*dp[u]%mod*C(siz+sz[u],sz[u])%mod;\n\t\t\tsiz+=sz[u];\n\t\t}\n\t}\n\tsz[k]++;\n}\n\nvoid solve(int x,int &res,int &ns){\n\tint i,j,k,st=0;\n\tns=0; res=0;\n\tbfs(x);\n\tns=t; m=0; h=t=0;\n\tfor (i=1;i<=ns;i++){\n\t\tk=q[i];\n\t\tfor (j=head[k];j;j=mem[j].next) m++;\n\t\tif (d[k]==1) tp[++t]=k;\n\t}\n\tif (m/2!=ns) return;\n\ttopsort(); t=0;\n\tfor (i=1;i<=ns;i++)\n\t\tif (d[q[i]]>1&&q[i]>st) st=q[i];\n\tfor (j=head[st];j;j=mem[j].next)\n\t\tif (d[mem[j].to]>1) tp[++t]=mem[j].to;\n\tfor (i=1;i<=t;i++){\n\t\tk=tp[i]; ssr=1; siz=0;\n\t\tdfs(st,k,st);\n\t\tssr=1ll*ssr*C(siz+sz[st],sz[st])%mod*dp[st]%mod;\n\t\tadd(res,ssr);\n\t}\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=2*n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y+n); addedge(y+n,x);\n\t}\n\tinit(n*2);\n\tans=1;\n\tfor (i=1;i<=n;i++)\n\t\tif (!vis[i]){\n\t\t\tsolve(i,res,ns);\n\t\t\tans=1ll*ans*C(sum+ns,ns)%mod*res%mod;\n\t\t\tsum+=ns;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 2e5 + 100;\nconst int Mod = 1e9 + 7;\n\n\nnamespace MATH\n{\n\tint fac[Maxn], ifac[Maxn];\n\n\tinline void Add (int &a, int b) { if ((a += b) >= Mod) a -= Mod; }\n\n\tinline int Pow (int a, int b)\n\t{\n\t\tint ans = 1;\n\t\tfor (int i = b; i; i >>= 1, a = (LL) a * a % Mod) if (i & 1) ans = (LL) ans * a % Mod;\n\t\treturn ans;\n\t}\n\n\tinline void init (int n = 2e5)\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % Mod;\n\t\tifac[n] = Pow (fac[n], Mod - 2);\n\t\tfor (int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % Mod;\n\t}\n\n\tinline int C (int n, int m) { if (n < m) return 0; return (LL) fac[n] * ifac[m] % Mod * ifac[n - m] % Mod; }\n}\n\nusing namespace MATH;\n\nint N;\nint e, Begin[Maxn], Next[Maxn << 1], To[Maxn << 1], W[Maxn << 1];\n\ninline void add_edge (int x, int y, int z) { To[++e] = y; Next[e] = Begin[x]; Begin[x] = e; W[e] = z; }\n\ninline int merge (int a, int b) { return C (a + b, b); }\n\nint Vis[Maxn], top, in_stk[Maxn];\npii stk[Maxn];\n\nint found;\nint circle[Maxn], in_circle[Maxn];\nint val_cir[Maxn];\n\ninline void dfs_circle (int x, int f, int w)\n{\n\tif (found) return ;\n\tstk[++top] = mp (x, w), in_stk[x] = 1;\n\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f) continue;\n\t\tif (!in_stk[y]) dfs_circle (y, x, W[i]);\n\t\telse\n\t\t{\n\t\t\tval_cir[++circle[0]] = W[i];\n\t\t\twhile (top)\n\t\t\t{\n\t\t\t\tint a = stk[top].x, b = stk[top].y; --top;\n\t\t\t\tcircle[circle[0]] = a;\n\t\t\t\tin_circle[a] = 1;\n\t\t\t\tval_cir[++circle[0]] = b;\n\t\t\t\tif (a == y) break;\n\t\t\t}\n\t\t\t--circle[0];\n\t\t\tfound = 1;\n\t\t\treturn ;\n\t\t}\n\t\tif (found) return ;\n\t}\n\n\t--top, in_stk[x] = 0;\n}\n\nint val[Maxn], tree[Maxn];\n\ninline void dfs_tree (int x, int f)\n{\n\ttree[++tree[0]] = x;\n\tVis[x] = 1;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (y == f || in_circle[y]) continue;\n\t\tval[y] = W[i];\n\t\tdfs_tree (y, x);\n\t}\n}\n\nint fa[Maxn], size[Maxn];\n\ninline int dfs_calc (int x)\n{\n\tint ans = 1;\n\tsize[x] = 0;\n\tfor (int i = Begin[x]; i; i = Next[i])\n\t{\n\t\tint y = To[i];\n\t\tif (x != fa[y]) continue;\n\t\tint now = dfs_calc (y);\n\t\tans = (LL) ans * now % Mod * merge (size[x], size[y]) % Mod;\n\t\tsize[x] += size[y];\n\t}\n\t++size[x];\n\treturn ans;\n}\n\ninline int Calc ()\n{\n//\tfor (int i = 1; i <= tree[0]; ++i) cout << tree[i] << ' ' << val[tree[i]] << endl;\n//\tputs(\"-------------\");\n\tfor (int t = 1; t <= tree[0]; ++t)\n\t{\n\t\tint x = tree[t];\n\t\tfa[x] = size[x] = 0;\n\t}\n\n\tfor (int t = 1; t <= tree[0]; ++t) \n\t{\n\t\tint x = tree[t];\n\t\tfor (int i = Begin[x]; i; i = Next[i])\n\t\t{\n\t\t\tint y = To[i];\n\t\t\tif (W[i] < val[x]) fa[y] = x;\n\t\t}\n\t}\n\n\tint ans = 1, sum_point = 0;\n\tfor (int t = 1; t <= tree[0]; ++t)\n\t{\n\t\tint x = tree[t];\n\t\tif (!fa[x])\n\t\t{\n//\t\t\tcout << \"*\" << x << endl;\n\t\t\tint now = dfs_calc (x);\n\t\t\tans = (LL) ans * now % Mod * merge (sum_point, size[x]) % Mod;\n\t\t\tsum_point += size[x];\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline int Process (int x)\n{\n\tfound = circle[0] = top = 0;\n\tdfs_circle (x, 0, 0);\n//\tprintf(\"Circle : \");\n//\tfor (int i = 1; i <= circle[0]; ++i) cout << circle[i] << ' ' ; puts(\"\");\n\ttree[0] = 0;\n\tfor (int i = 1; i <= circle[0]; ++i) dfs_tree (circle[i], 0);\n\n\tint ans = 0;\n\tfor (int i = 1; i <= circle[0]; ++i) val[circle[i]] = val_cir[i];\n\tAdd (ans, Calc ());\n\n\tval_cir[circle[0] + 1] = val_cir[1];\n\tfor (int i = 1; i <= circle[0]; ++i) val[circle[i]] = val_cir[i + 1];\n\tAdd (ans, Calc ());\n\n\treturn ans;\n}\n\nint Choose[Maxn];\n\ninline void Solve ()\n{\n\tint chosen = 0;\n\tfor (int i = 1; i <= 2 * N; ++i) if (Choose[i]) ++chosen;\n\tif (chosen != 2 * N) return void (puts(\"0\"));\n\n\tint ans = 1, sum_point = 0;\n\tfor (int i = 1; i <= 2 * N; ++i)\n\t\tif (!Vis[i])\n\t\t{\n\t\t\tint now = Process (i);\n//\t\t\tcout << tree[0] << ' ' << now << endl;\n\t\t\tans = (LL) ans * now % Mod * merge (sum_point, tree[0]) % Mod;\n\t\t\tsum_point += tree[0];\n\t\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>();\n\tfor (int i = 1; i <= 2 * N; ++i) \n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tChoose[x] = Choose[y + N] = 1;\n\t\tadd_edge (x, y + N, x + y);\n\t\tadd_edge (y + N, x, x + y);\n\t}\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH :: init ();\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\nint read() {\n\tint x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) flag *= (ch == '-' ? -1 : 1);\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';\n\treturn flag * x;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 3e5 + 9, Mod = 1e9 + 7;\nnamespace Math {\n\tint fpm(int base, int tims) {\n\t\tint r = 1;\n\t\tfor (; tims; base = 1ll * base * base % Mod, tims >>= 1) \n\t\t\tif (tims & 1) r = 1ll * r * base % Mod;\n\t\treturn r;\n\t}\n\tint fac[Maxn], invFac[Maxn];\n\tvoid Init() {\n\t\tfac[0] = 1;\n\t\trep (i, 1, Maxn - 1) \n\t\t\tfac[i] = fac[i - 1] * 1ll * i % Mod;\n\t\tinvFac[Maxn - 1] = fpm(fac[Maxn - 1], Mod - 2);\n\t\tdrep (i, Maxn - 2, 0) invFac[i] = invFac[i + 1] * (i + 1ll) % Mod;\n\t}\n\tint C(int _n, int _m) {\n\t\tif (_n < _m) return 0;\n\t\treturn fac[_n] * 1ll * invFac[_n - _m] % Mod * invFac[_m] % Mod;\n\t}\n}\nusing namespace Math;\n\nstruct node { int u, v, w; };\nstruct edge { int to, nxt, w; }g[Maxn << 2], g1[Maxn << 2];\nint head[Maxn], e;\nint head1[Maxn], e1;\nvoid add(int u, int v, int w) { g[++e] = (edge){v, head[u], w}, head[u] = e; }\nvoid add1(int u, int v, int w = 0) { g1[++e1] = (edge){v, head1[u], w}, head1[u] = e1; }\n\nint vis[Maxn], inCir[Maxn], found, _top, delta, n;\nnode stk[Maxn];\nvector <node> cir;\nvector <int> cus, cun;\n\nvoid dfsCir(int u, int pa) {\n\tif (found) return ;\n\tvis[u] = 1; \n\t\t\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tif (!vis[v]) {\n\t\t\t\tstk[++_top] = (node){u, v, g[i].w};\n\t\t\t\tdfsCir(v, u);\n\t\t\t\t--_top;\n\t\t\t} else if (!found) {\n\t\t\t\tnode tmp; int bak = _top;\n\t\t\t\tdo {\n\t\t\t\t\ttmp = stk[bak--];\n\t\t\t\t\tcir.push_back(tmp);\n\t\t\t\t\tif (!inCir[tmp.u]) cus.push_back(tmp.u);\n\t\t\t\t\tif (!inCir[tmp.v]) cus.push_back(tmp.v);\n\t\t\t\t\tinCir[tmp.u] = inCir[tmp.v] = 1;\n\t\t\t\t} while (tmp.u != v);\n\t\t\t\tcir.push_back((node){u, v, g[i].w});\n\t\t\t\tfound = 1;\n\t\t\t\treturn;\n\t\t\t} \n\t\t}\n\t\tif (found) return;\n\t}\n}\n\nint val[Maxn], fa[Maxn];\nint find(int x) {\n\treturn fa[x] ^ x ? fa[x] = find(fa[x]) : x;\n}\nvoid dfs1(int u, int pa) {\n\tcun.push_back(u); ++delta;\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (!inCir[v] && v != pa) val[v] = g[i].w, dfs1(v, u);\n\t}\n}\n\nint size[Maxn], dp[Maxn];\nvoid dfsDp(int u, int pa) {\n\tdp[u] = 1;\n\tint sum = 0;\n\tfor (int i = head1[u]; ~i; i = g1[i].nxt) {\n\t\tint v = g1[i].to;\n\t\tif (v != pa) {\n\t\t\tdfsDp(v, u);\n\t\t\tsize[u] += size[v];\n\t\t\tdp[u] = 1ll * dp[u] * dp[v] % Mod * C(size[u], sum) % Mod;\n\t\t\tsum += size[v];\n\t\t}\n\t}\n\t++size[u];\n}\nint deg[Maxn];\nint calc() {\n\te1 = 0;\n\trep (i, 0, cun.size() - 1) {\n\t\tint u = cun[i];\n\t\tsize[u] = dp[u] = deg[u] = 0;\n\t\thead1[u] = -1;\n\t}\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (g[i].w < val[u]) {\n\t\t\t\tadd1(u, v), ++deg[v];\n\t\t\t\t//cout << u << \" \" << v << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 1, sum = 0;\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tif (!deg[u]) {\n\t\t\tdfsDp(u, 0);\n\t\t\tres = 1ll * res * dp[u] * C(sum + size[u], sum) % Mod;\n\t\t\tsum += size[u];\n\t\t}\n\t}\n\t//cout << res << endl;\n//\tputs(\"\");\n\treturn res;\n}\n\nint main() {\n\n\n\tstatic int x[Maxn], y[Maxn], xjig[Maxn], amt = 0;\n\n\tclar (head, -1), e = 0;\n\tMath :: Init();\n\n\tn = read() << 1;\n\trep (i, 1, n) fa[i] = i;\n\trep (i, 1, n) {\n\t\tx[i] = read(), y[i] = read();\n\t\tadd(x[i], y[i] + n / 2, x[i] + y[i]);\n\t\tadd(y[i] + n / 2, x[i], x[i] + y[i]);\n\t\tif (!xjig[x[i]]) ++amt, xjig[x[i]] = 1;\n\t\tif (!xjig[y[i] + n / 2]) ++amt, xjig[y[i] + n / 2] = 1;\n\t\tif (find(x[i]) != find(y[i] + n / 2)) fa[find(x[i])] = fa[find(y[i] + n / 2)];\n\t}\n\tif (amt != n) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tLL ans = 1, sum = 0;\n\trep (i, 1, n) \n\t\tif (fa[i] == i) {\n\t\t\tint res = 0; _top = 0, cir.clear(), found = 0, delta = 0, cus.clear(), cun.clear();\n\t\t\tdfsCir(i, 0);\n\t\t\tif (!found) {\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep (j, 0, cus.size() - 1) dfs1(cus[j], 0);\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].u] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].v] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\n\t\t\tans = 1ll * ans * res % Mod * C(sum += delta, delta) % Mod;\n\t\t}\n\tprintf(\"%d\\n\", 1ll * ans * fpm(fac[n], Mod - 1) % Mod);\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\n#define dputs(...) fputs(__VA_ARGS__,stderr)\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,fac[N],ifac[N];\nstruct node{int x,y;}ori[N<<1];\ninline int C(int x,int y){\n\tif(x<y) return 0;\n\treturn (ll)fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\ninline bool cmp(node a,node b){return mp(a.x,a.y)<mp(b.x,b.y);}\n\nint tcnt,cnt,root,w,dep[N],fa[N],val[N];\nbool vis[N];\nvector<pii> g[N],seq;\nvoid add(int x,int y,int z){\n//\tdprintf(\"%d %d %d\\n\",x,y,z);\n\tg[x].pb(mp(y,z));g[y].pb(mp(x,z));\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tcnt++;tcnt-=2;\n\tfor(auto i:g[x]){\n\t\ttcnt++;\n\t\tint y=i.FF;\n\t\tif(vis[y]){\n\t\t\tif(dep[y]>dep[x]){\n\t\t\t\tw=i.SS;\n\t\t\t\twhile(y!=x)\n\t\t\t\t\tgmax(w,val[y]),y=fa[y];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tdep[y]=dep[x]+1;fa[y]=x;val[y]=i.SS;\n\t\tdfs(y);\n\t}\n}\ninline pii dfs(int x,int f,int w){\n//\tdprintf(\"%d %d %d\\n\",x,f,w);\n\tint res=1,now=0;\n\tfor(auto i:g[x]){\n\t\tint y=i.FF;\n\t\tif(y==root||y==f) continue;\n\t\tpii t=dfs(y,x,i.SS);\n\t\tif(i.SS>w) seq.pb(t);\n\t\telse{\n\t\t\tnow+=t.SS;\n\t\t\tres=(ll)res*t.FF%mod*C(now,t.SS)%mod;\n\t\t}\n\t}\n\treturn mp(res,now+1);\n}\nint solve(int w,int flag){\n\tint u=ori[w].x,v=ori[w].y+n;\n\tif(flag) swap(u,v);\n\tseq.clear();root=u;\n\tseq.pb(dfs(u,v,w));\n\tint now=0,res=1;\n\tfor(auto i:seq) res=(ll)res*i.FF%mod*C(now+i.SS,i.SS)%mod,now+=i.SS;\n//\tfor(auto i:seq) dprintf(\"%d %d\\n\",i.FF,i.SS);\n//\tdputs(\"\\n\");\n\treturn res;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tn=200000;fac[0]=ifac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=exp(fac[n],mod-2);\n\tfor(int i=n-1;i;i--) ifac[i]=(ll)ifac[i+1]*(i+1)%mod;\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n*2;i++)\n\t\tscanf(\"%d%d\",&ori[i].x,&ori[i].y);\n\tsort(ori+1,ori+n*2+1,cmp);\n\tfor(int i=1;i<=n*2;i++)\n\t\tadd(ori[i].x,ori[i].y+n,i);\n\tint ans=1,now=0;\n\tfor(int i=1;i<=n*2;i++)\n\t\tif(!vis[i]){\n\t\t\ttcnt=cnt=0;dfs(i);\n\t\t\tif(tcnt){puts(\"0\");return 0;}\n\t\t\tnow+=cnt;\n//\t\t\tdebug(w);\n\t\t\tans=(ll)ans*(solve(w,0)+solve(w,1))%mod*C(now,cnt)%mod;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define N 100009\n#define mod 1000000007\nusing namespace std;\nint n,a[N<<1],b[N<<1],first[N<<1],number=1,vis[N<<1],size[N<<1];\nint jc[N<<1],inv[N<<1],Ans[N<<1],cnt,len[N<<1],fa[N<<1];\nint sta[N<<1],top,First[N<<1],Number,to[N<<1],Fa[N<<1];\nint Sta[N<<1],num,Size[N<<1],dp[N<<1],flag,pd[N<<1];\nmap<pair<int,int>,int> mp;\nstruct edge\n{\n\tint to,next;\n\tvoid add(int x,int y)\n\t{\n\t\tto=y,next=first[x],first[x]=number;\n\t}\n}e[N<<2];\nstruct Edge\n{\n\tint to,next;\n\tvoid add(int x,int y)\n\t{\n\t\tto=y,next=First[x],First[x]=Number;\n\t}\n}E[N<<2];\nint read()\n{\n\tint x=1;\n\tchar ch;\n\twhile (ch=gc,ch<'0'||ch>'9') if (ch=='-') x=-1;\n\tint s=ch-'0';\n\twhile (ch=gc,ch>='0'&&ch<='9') s=s*10+ch-'0';\n\treturn x*s;\n}\nint c(int n,int m)\n{\n\treturn (ll)jc[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid dfs(int x)\n{\n\tvis[x]=size[x]=1;\n\tSta[++num]=x;\n\tfor (int i=first[x];i;i=e[i].next)\n\t\tif (e[i].to!=fa[x])\n\t\t{\n\t\t\tif (!vis[e[i].to])\n\t\t\t{\n\t\t\t\tfa[e[i].to]=x;\n\t\t\t\tdfs(e[i].to);\n\t\t\t\tsize[x]+=size[e[i].to];\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tint now=x;\n\t\t\t\t\twhile (now!=e[i].to)\n\t\t\t\t\t{\n\t\t\t\t\t\tsta[++top]=now;\n\t\t\t\t\t\tnow=fa[now];\n\t\t\t\t\t}\n\t\t\t\t\tsta[++top]=e[i].to;\n\t\t\t\t\tflag=0;\n\t\t\t\t}\n\t\t}\n}\nvoid tree_dp(int x)\n{\n\tSize[x]=0;\n\tdp[x]=1;\n\tfor (int i=First[x];i;i=E[i].next)\n\t{\n\t\ttree_dp(E[i].to);\n\t\tSize[x]+=Size[E[i].to];\n\t\tdp[x]=(ll)dp[x]*dp[E[i].to]%mod*c(Size[x],Size[E[i].to])%mod;\n\t}\n\tSize[x]++;\n}\nvoid Dfs(int x)\n{\n\tfor (int i=first[x];i;i=e[i].next)\n\t\tif (!to[e[i].to])\n\t\t{\n\t\t\tto[e[i].to]=i,Dfs(e[i].to);\n\t\t\tif (e[i].to<e[to[x]^1].to)\n\t\t\t{\n\t\t\t\tE[++Number].add(x,e[i].to);\n\t\t\t\tFa[e[i].to]=x;\n\t\t\t}\n\t\t}\n}\nint solve(int sz)\n{\n\tfor (int i=1;i<=num;i++)\n\t\tFa[Sta[i]]=to[Sta[i]]=Size[Sta[i]]=dp[Sta[i]]=First[Sta[i]]=0;\n\tNumber=0;\n\tfor (int i=1;i<=top;i++)\n\t{\n\t\tto[sta[i]]=mp[make_pair(sta[i==top?1:(i+1)],sta[i])];\n\t\tif (sta[i==1?top:(i-1)]<sta[i==top?1:(i+1)])\n\t\t{\n\t\t\tE[++Number].add(sta[i],sta[i==1?top:(i-1)]);\n\t\t\tFa[sta[i==1?top:(i-1)]]=sta[i];\n\t\t}\n\t}\n\tfor (int i=1;i<=top;i++) Dfs(sta[i]);\n\tint ret=1,l=0;\n\tfor (int i=1;i<=num;i++)\n\t\tif (!Fa[Sta[i]]&&First[Sta[i]])\n\t\t{\n\t\t\ttree_dp(Sta[i]);\n\t\t\tint ans=dp[Sta[i]],L=Size[Sta[i]];\n\t\t\tret=(ll)ret*ans%mod*c(L+l,l)%mod,l+=L;\n\t\t}\n\tret=(ll)ret*jc[sz-l]%mod*c(sz,l)%mod;\n\tfor (int i=1;i*2<=top;i++) swap(sta[i],sta[top-i+1]);\n\tfor (int i=1;i<=num;i++)\n\t\tFa[Sta[i]]=to[Sta[i]]=Size[Sta[i]]=dp[Sta[i]]=First[Sta[i]]=0;\n\tNumber=0;\n\tfor (int i=1;i<=top;i++)\n\t{\n\t\tto[sta[i]]=mp[make_pair(sta[i==top?1:(i+1)],sta[i])];\n\t\tif (sta[i==1?top:(i-1)]<sta[i==top?1:(i+1)])\n\t\t{\n\t\t\tE[++Number].add(sta[i],sta[i==1?top:(i-1)]);\n\t\t\tFa[sta[i==1?top:(i-1)]]=sta[i];\n\t\t}\n\t}\n\tfor (int i=1;i<=top;i++) Dfs(sta[i]);\n\tint Ret=1;\n\tl=0;\n\tfor (int i=1;i<=num;i++)\n\t\tif (!Fa[Sta[i]]&&First[Sta[i]])\n\t\t{\n\t\t\ttree_dp(Sta[i]);\n\t\t\tint ans=dp[Sta[i]],L=Size[Sta[i]];\n\t\t\tRet=(ll)Ret*ans%mod*c(L+l,l)%mod,l+=L;\n\t\t}\n\tRet=(ll)Ret*jc[sz-l]%mod*c(sz,l)%mod;\n\treturn ret+Ret;\n}\nint main()\n{\n\tjc[0]=1;\n\tinv[0]=inv[1]=1;\n\tfor (int i=1;i<(N<<1);i++)\n\t\tjc[i]=(ll)jc[i-1]*i%mod;\n\tfor (int i=2;i<(N<<1);i++)\n\t\tinv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<(N<<1);i++)\n\t\tinv[i]=(ll)inv[i]*inv[i-1]%mod;\n\tn=read();\n\tfor (int i=1;i<=n*2;i++)\n\t{\n\t\ta[i]=read(),b[i]=read();\n\t\te[++number].add(a[i],b[i]+n);\n\t\tmp[make_pair(a[i],b[i]+n)]=number;\n\t\te[++number].add(b[i]+n,a[i]);\n\t\tmp[make_pair(b[i]+n,a[i])]=number;\n\t\tpd[a[i]]=1,pd[b[i]+n]=1;\n\t}\n\tfor (int i=1;i<=n*2;i++)\n\t\tif (!pd[i])\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i=1;i<=n*2;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tflag=1;\n\t\t\tnum=top=0,dfs(i);\n\t\t\tAns[++cnt]=solve(len[cnt]=size[i]);\n\t\t}\n\tint ret=1,l=0;\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tret=(ll)ret*Ans[i]%mod*c(len[i]+l,l)%mod;\n\t\tl+=len[i];\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <fstream>\n\ntypedef long long LL;\ntypedef unsigned long long uLL;\n\n#define PII pair<int, int>\n#define SZ(x) ((int)x.size())\n#define ALL(x) (x).begin(), (x).end()\n#define MP(x, y) std::make_pair(x, y)\n#define DE(x) cerr << x << endl;\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define GO cerr << \"GO\" << endl;\n#define rep(i, a, b) for (register int (i) = (a); (i) <= (b); ++(i))\n\nusing namespace std;\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\ninline int read() \n{\n\tregister int x = 0; register int f = 1; register char c;\n\twhile (!isdigit(c = getchar())) if (c == '-') f = -1;\n\twhile (x = (x << 1) + (x << 3) + (c xor 48), isdigit(c = getchar()));\n\treturn x * f;\n}\ntemplate<class T> inline void write(T x) \n{\n\tstatic char stk[30]; static int top = 0;\n\tif (x < 0) { x = -x, putchar('-'); }\n\twhile (stk[++top] = x % 10 xor 48, x /= 10, x);\n\twhile (putchar(stk[top--]), top);\n}\ntemplate<typename T> inline bool chkmin(T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\n\nconst int maxN = (int) 2e5;\nconst int mod = (int) 1e9 + 7;\n\nstruct Edge\n{\n\tint v, w;\n\tEdge() { }\n\tEdge(int v, int w) : v(v), w(w) { }\n} ;\n\nint n;\nbool vis[maxN + 2], instk[maxN + 2], found, in_cir[maxN + 2], choose[maxN + 2];\nint top, val[maxN + 2], par[maxN + 2], size[maxN + 2];\nPII stk[maxN + 2];\nvector<pair<int, int> > circle;\nvector<int> node;\nvector<Edge> g[maxN + 2];\n\nnamespace math\n{\n\tint fac[maxN + 2], ifac[maxN + 2], inv[maxN + 2];\n\tLL qpow(LL a, LL b)\n\t{\n\t\tLL ans = 1;\n\t\twhile (b)\n\t\t{\n\t\t\tif (b & 1) \n\t\t\t\tans = ans * a % mod;\n\t\t\ta = a * a % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tinv[0] = 0, inv[1] = 1;\n\t\tfor (int i = 2; i <= n; ++i) inv[i] = (1ll * mod - 1ll * mod / i * inv[mod % i] % mod) % mod;\n\t\tifac[n] = qpow(fac[n], mod - 2);\n\t\tfor (int i = n - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;\n\t}\n\tint C(int n, int m) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\tint merge(int a, int b) { return C(a + b, a); }\n}\nusing namespace math;\n\nvoid input()\n{\n\tn = read() << 1;\n\tfor (int i = 1; i <= n; ++i) \n\t{\n\t\tint x = read(), y = read();\n\t\tg[x].emplace_back(y + n / 2, x + y);\n\t\tg[y + n / 2].emplace_back(x, x + y);\n\t\tchoose[x] = choose[y + n / 2] = 1;\n\t}\n}\n\nvoid dfs_circle(int x, int fa, int edge)\n{\n\tif (found) return;\n\tstk[++top] = MP(x, edge);\n\tinstk[x] = 1;\n\tfor (Edge E : g[x])\n\t{\n\t\tint v = E.v, w = E.w;\n\t\tif (v == fa) continue;\n\t\tif (!instk[v])\n\t\t{\n\t\t\tdfs_circle(v, x, w);\n\t\t}\n\t   \telse\n\t\t{\n\t\t\tint To = v;\n\t\t\tdo\n\t\t\t{\n\t\t\t\t//cerr << v << endl;\n\t\t\t\tv = stk[top].first;\n\t\t\t\tin_cir[v] = 1;\n\t\t\t\tcircle.push_back(stk[top--]);\n\t\t\t} while (v != To);\n\t\t\tcircle.back().second = w;\n\t\t\tfound = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (found) return;\n\t}\n\tinstk[x] = 0;\n\ttop--;\n}\n\nvoid dfs1(int u, int fa)\n{\n\tvis[u] = 1;\n\tnode.push_back(u);\n\tfor (Edge E : g[u])\n\t{\n\t\tint v = E.v, w = E.w;\n\t\tif (v != fa and !in_cir[v])\n\t\t{\n\t\t\tval[v] = w;\n\t\t\tdfs1(v, u);\n\t\t}\n\t}\n}\n\nint dfs2(int u)\n{\n\tint ans = 1;\n\tsize[u] = 0;\n\tfor (Edge E : g[u])\n\t{\n\t\tint v = E.v;\n\t\tif (par[v] != u) continue;\n\t\tint cur = dfs2(v);\n\t\tans = 1ll * ans * cur % mod * merge(size[u], size[v]) % mod;\n\t\tsize[u] += size[v];\n\t}\n\tsize[u]++;\n\treturn ans;\n}\n\nint calc()\n{\n\tfor (int u : node)\n\t{\n\t\tsize[u] = 0;\n\t\tpar[u] = 0;\n\t}\n\tfor (int u : node)\n\t{\n\t\tfor (Edge E : g[u])\n\t\t{\n\t\t\tint v = E.v, w = E.w;\n\t\t\tif (w < val[u]) par[v] = u;\n\t\t}\n\t}\n\tint SIZE = 0, ans = 1;\n\tfor (int u : node)\n\t{\n\t\tif (!par[u])\n\t\t{\n\t\t\tint cur = dfs2(u);\n\t\t\tans = 1ll * ans * cur % mod * merge(SIZE, size[u]) % mod;\n\t\t\tSIZE += size[u];\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve()\n{\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcnt += choose[i];\n\tif (cnt != n)\n\t{\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tint SIZE = 0, ans = 1;\n\tfor (int i = 1; i <= n && ans; ++i)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tint cur = 0;\n\t\t\ttop = 0;\n\t\t\tfound = 0;\n\t\t\tcircle.clear();\n\t\t\tdfs_circle(i, 0, 0);\n\n\t\t\tnode.clear();\n\t\t\tfor (int j = 0; j < SZ(circle); ++j) dfs1(circle[j].first, 0);\n\n\t\t\tfor (int j = 0; j < SZ(circle); ++j) \n\t\t\t\tval[circle[j].first] = circle[j].second;\n\t\t\t(cur += calc()) %= mod;\n\t\t\t//DE(cur);\n\n\t\t\tcircle.push_back(circle[0]);\n\t\t\tfor (int j = 1; j < SZ(circle); ++j)\n\t\t\t\tval[circle[j].first] = circle[j - 1].second;\n\t\t\t(cur += calc()) %= mod;\n\n\t\t\tans = 1ll * ans * cur % mod * merge(SIZE, node.size());\n\t\t\tSIZE += node.size();\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() \n{ \n\tinput();\n\tmath::init();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=400010;\nconst int mod=1000000007;\nint n,first[maxn],nxt[maxn<<1],to[maxn<<1],dis[maxn<<1],e;\nvoid Add(int u,int v,int w) {\n//\tprintf(\"%d -> %d %d\\n\",u,v,w);\n\tto[++e]=v;dis[e]=w;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;dis[e]=w;nxt[e]=first[v];first[v]=e;\n}\nint pa[maxn],siz[maxn],es[maxn],vis[maxn];\nint findset(int x) {return x==pa[x]?x:pa[x]=findset(pa[x]);}\nvoid GG() {puts(\"0\");exit(0);}\nint sta[maxn],cir[maxn],left[maxn],right[maxn],col[maxn],clo,top;\nvector<int> s,all;\nvoid dfs(int x,int la) {\n\tvis[x]=++clo;sta[++top]=x;\n\tfor(int i=first[x];i;i=nxt[i]) if((i-1)!=(la-1^1)){\n\t\tif(!vis[to[i]]) dfs(to[i],i);\n\t\telse if(vis[to[i]]<vis[x]) {\n\t\t\twhile(top) {\n\t\t\t\tint y=sta[top--];\n\t\t\t\tcir[y]=1;s.pb(y);\n\t\t\t\tif(to[i]==y) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(top) top--;\n}\nvoid dfsout(int x,int fa) {\n\tall.pb(x);\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa&&!cir[to[i]]) {\n\t\tcol[to[i]]=dis[i];\n\t\tdfsout(to[i],x);\n\t}\n}\nint fac[maxn],ifac[maxn],size[maxn];\nint C(int a,int b) {return (ll)fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nvector<int> G[maxn];\nint deg[maxn],f[maxn];\nvoid dp(int x) {\n\tf[x]=1;size[x]=0;\n\trep(i,0,G[x].size()-1) {\n\t\tdp(G[x][i]);\n\t\tf[x]=(ll)f[x]*f[G[x][i]]%mod;\n\t\tf[x]=(ll)f[x]*ifac[size[G[x][i]]]%mod;\n\t\tsize[x]+=size[G[x][i]];\n\t}\n\tf[x]=(ll)f[x]*fac[size[x]]%mod;\n\tsize[x]++;\n}\nint work() {\n\trep(j,0,all.size()-1) G[all[j]].clear(),deg[all[j]]=0;\n\trep(j,0,all.size()-1) {\n\t\tint x=all[j];\n\t\tfor(int i=first[x];i;i=nxt[i]) if(dis[i]<col[x]) G[x].pb(to[i]),deg[to[i]]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,0,all.size()-1) if(!deg[all[i]]) {\n\t\tdp(all[i]);\n\t\tans=(ll)ans*C(cur+size[all[i]],cur)%mod;\n\t\tans=(ll)ans*f[all[i]]%mod;\n\t\tcur+=size[all[i]];\n\t}\n\treturn ans;\n}\nint main() {\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tn=read();\n\tifac[0]=ifac[1]=fac[0]=1;\n\trep(i,2,n*2) ifac[i]=(ll)(mod-mod/i)*ifac[mod%i]%mod;\n\trep(i,1,n*2) fac[i]=(ll)fac[i-1]*i%mod,ifac[i]=(ll)ifac[i-1]*ifac[i]%mod;\n\trep(i,1,n*2) pa[i]=i,siz[i]=1;\n\trep(i,1,n*2) {\n\t\tint x=read(),y=read(),w=x+y;\n\t\tAdd(x,y+n,w);\n\t\tx=findset(x);y=findset(y+n);\n\t\tif(x!=y) {pa[x]=y;siz[y]+=siz[x];es[y]+=es[x];}\n\t\tes[y]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,1,n*2) if(i==findset(i)) {\n\t//\tif(siz[i]!=es[i]) GG();\n\t\ts.clear();all.clear();dfs(i,0);top=0;\n\t\trep(i,0,s.size()-1) {\n\t\t\tdfsout(s[i],0);\n\t\t\tint prev=(!i?s[s.size()-1]:s[i-1]);\n\t\t\tint nxtv=(i==s.size()-1?s[0]:s[i+1]);\n\t\t\tfor(int j=first[s[i]];j;j=nxt[j]) {\n\t\t\t\tif(to[j]==prev) left[s[i]]=dis[j];\n\t\t\t\tif(to[j]==nxtv) right[s[i]]=dis[j];\n\t\t\t}\n\t\t}\n\t\tans=(ll)ans*C(cur+all.size(),cur)%mod;\n\t\tcur+=all.size();\n\t\tint tmp=0;\n\t\trep(i,0,s.size()-1) col[s[i]]=left[s[i]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\trep(i,0,s.size()-1) col[s[i]]=right[s[i]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\tans=tmp;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\nconst int MAX = 300000;\nMint inv[MAX+1], fact[MAX+1], fact_inv[MAX+1];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i=2; i<=MAX; i++) inv[i] = inv[MOD%i] * (MOD-MOD/i);\n\n    fact[0] = fact_inv[0] = 1;\n    for (int i=1; i<=MAX; i++) {\n\tfact[i] = fact[i-1] * i;\n\tfact_inv[i] = fact_inv[i-1] * inv[i];\n    }\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\n\nint N;\nVI G[200011];\nint par[200011];\nbool use[200011];\nint target[200011];\nVI H[200011];\nint indeg[200011];\n\nint sz[200011];\nMint dp[200011];\n\nvoid MAIN() {\n    init();\n    scanf(\"%d\", &N);\n    REP (i, N*2) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y+N);\n\tG[y+N].push_back(x);\n    }\n    N += N;\n\n    memset(par, -1, sizeof par);\n    Mint ans = 1;\n    int size = 0;\n    REP (s, N) if (!use[s]) {\n\tpar[s] = s;\n\tVI ord;\n\tord.push_back(s);\n\tuse[s] = true;\n\tvector<pair<int, int> > cut;\n\tfor (int i=0; i<(int)ord.size(); i++) {\n\t    int v = ord[i];\n\t    EACH (e, G[v]) if (*e != par[v]) {\n\t\tif (!use[*e]) {\n\t\t    par[*e] = v;\n\t\t    ord.push_back(*e);\n\t\t    use[*e] = true;\n\t\t} else {\n\t\t    cut.emplace_back(min(v, *e), max(v, *e));\n\t\t}\n\t    }\n\t}\n\n\tif (cut.size() != 2 || cut[0] != cut[1]) {\n\t    ans = 0;\n\t    goto END;\n\t}\n\n\n\tEACH (e, ord) {\n\t    par[*e] = -1;\n\t    use[*e] = false;\n\t}\n\tint root = cut[0].first;\n\tcut.clear();\n\tord.clear();\n\tord.push_back(root);\n\n\tuse[root] = true;\n\n\tfor (int i=0; i<(int)ord.size(); i++) {\n\t    int v = ord[i];\n\t    EACH (e, G[v]) if (*e != par[v]) {\n\t\tif (!use[*e]) {\n\t\t    par[*e] = v;\n\t\t    ord.push_back(*e);\n\t\t    use[*e] = true;\n\t\t} else {\n\t\t    cut.emplace_back(min(v, *e), max(v, *e));\n\t\t}\n\t    }\n\t}\n\n\tMint ans_1 = 0;\n\tEACH (e, ord) target[*e] = par[*e];\n\tint a = cut[0].first, b = cut[0].second;\n\tREP (t, 2) {\n\t    target[a] = b;\n\t    {\n\t\tint v = a;\n\t\twhile (v != root) {\n\t\t    target[par[v]] = v;\n\t\t    v = par[v];\n\t\t}\n\t\tv = b;\n\t\twhile (v != root) {\n\t\t    target[v] = par[v];\n\t\t    v = par[v];\n\t\t}\n\t    }\n\n\t    EACH (e, ord) {\n\t\tH[*e].clear();\n\t\tindeg[*e] = 0;\n\t    }\n\t    EACH (e, ord) EACH (f, G[*e]) if (*f < target[*e]) {\n\t\tH[*e].push_back(*f);\n\t\tindeg[*f]++;\n\t    }\n\n\t    Mint ans_inner = 1;\n\t    int size_inner = 0;\n\t    EACH (e, ord) if (indeg[*e] == 0) {\n\t\tVI ord2;\n\t\tord2.push_back(*e);\n\t\tfor (int i=0; i<(int)ord2.size(); i++) {\n\t\t    int v = ord2[i];\n\t\t    EACH (f, H[v]) {\n\t\t\tord2.push_back(*f);\n\t\t    }\n\t\t}\n\t\tfor (int i=ord2.size(); i--;) {\n\t\t    int v = ord2[i];\n\t\t    sz[v] = 0;\n\t\t    dp[v] = 1;\n\t\t    EACH (f, H[v]) {\n\t\t\tdp[v] = dp[v] * dp[*f] * nCk(sz[v] + sz[*f], sz[v]);\n\t\t\tsz[v] += sz[*f];\n\t\t    }\n\t\t    sz[v]++;\n\t\t}\n\n\t\tans_inner = ans_inner * dp[*e] * nCk(size_inner + sz[*e], size_inner);\n\t\tsize_inner += sz[*e];\n\t    }\n\n\t    ans_1 += ans_inner;\n\t    swap(a, b);\n\t}\n\n\tans = ans * ans_1 * nCk(size + (int)ord.size(), size);\n\tsize += ord.size();\n    }\n\nEND:\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\nint read() {\n\tint x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) flag *= (ch == '-' ? -1 : 1);\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';\n\treturn flag * x;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 2e5 + 9, Mod = 1e9 + 7;\nnamespace Math {\n\tint fpm(int base, int tims) {\n\t\tint r = 1;\n\t\tfor (; tims; base = 1ll * base * base % Mod, tims >>= 1) \n\t\t\tif (tims & 1) r = 1ll * r * base % Mod;\n\t\treturn r;\n\t}\n\tint fac[Maxn], invFac[Maxn];\n\tvoid Init() {\n\t\tfac[0] = 1;\n\t\trep (i, 1, Maxn - 1) \n\t\t\tfac[i] = fac[i - 1] * 1ll * i % Mod;\n\t\tinvFac[Maxn - 1] = fpm(fac[Maxn - 1], Mod - 2);\n\t\tdrep (i, Maxn - 2, 0) invFac[i] = invFac[i + 1] * (i + 1ll) % Mod;\n\t}\n\tint C(int _n, int _m) {\n\t\tif (_n < _m) return 0;\n\t\treturn fac[_n] * 1ll * invFac[_n - _m] % Mod * invFac[_m] % Mod;\n\t}\n}\nusing namespace Math;\n\nstruct node { int u, v, w; };\nstruct edge { int to, nxt, w; }g[Maxn << 2], g1[Maxn << 2];\nint head[Maxn], e;\nint head1[Maxn], e1;\nvoid add(int u, int v, int w) { g[++e] = (edge){v, head[u], w}, head[u] = e; }\nvoid add1(int u, int v, int w = 0) { g1[++e1] = (edge){v, head1[u], w}, head1[u] = e1; }\n\nint vis[Maxn], inCir[Maxn], found, _top, delta, n;\nnode stk[Maxn];\nvector <node> cir;\nvector <int> cus, cun;\n\nvoid dfsCir(int u, int pa) {\n\tif (!vis[u]) ++delta, cun.push_back(u);\n\tvis[u] = 1; \n\t\t\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tif (!vis[v]) {\n\t\t\t\tstk[++_top] = (node){u, v, g[i].w};\n\t\t\t\tdfsCir(v, u);\n\t\t\t\t--_top;\n\t\t\t} else if (!found) {\n\t\t\t\tnode tmp; int bak = _top;\n\t\t\t\tdo {\n\t\t\t\t\ttmp = stk[bak--];\n\t\t\t\t\tcir.push_back(tmp);\n\t\t\t\t\tif (!inCir[tmp.u]) cus.push_back(tmp.u);\n\t\t\t\t\tif (!inCir[tmp.v]) cus.push_back(tmp.v);\n\t\t\t\t\tinCir[tmp.u] = inCir[tmp.v] = 1;\n\t\t\t\t} while (tmp.u != v);\n\t\t\t\tcir.push_back((node){u, v, g[i].w});\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint val[Maxn];\nvoid dfs1(int u, int pa) {\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (!inCir[v] && v != pa) val[v] = g[i].w, dfs1(v, u);\n\t}\n}\n\nint size[Maxn], dp[Maxn];\nvoid dfsDp(int u, int pa) {\n\tdp[u] = 1;\n\tint sum = 0;\n\tfor (int i = head1[u]; ~i; i = g1[i].nxt) {\n\t\tint v = g1[i].to;\n\t\tif (v != pa) {\n\t\t\tdfsDp(v, u);\n\t\t\tsize[u] += size[v];\n\t\t\tdp[u] = 1ll * dp[u] * dp[v] % Mod * C(size[u], sum) % Mod;\n\t\t\tsum += size[v];\n\t\t}\n\t}\n\t++size[u];\n}\nint deg[Maxn], toward[Maxn];\nint calc() {\n\te1 = 0;\n\trep (i, 0, cun.size() - 1) {\n\t\tint u = cun[i];\n\t\tsize[u] = dp[u] = deg[u] = 0;\n\t\thead1[u] = -1;\n\t}\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (g[i].w < val[u]) add1(u, v), ++deg[v];\n\t\t}\n\t}\n\tint res = 1, sum = 0;\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tif (!deg[u]) {\n\t\t\tdfsDp(u, 0);\n\t\t\tres = 1ll * res * dp[u] * C(sum + size[u], sum) % Mod;\n\t\t\tsum += size[u];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n//\tfreopen(\"robot.in\", \"r\", stdin);\n//\tfreopen(\"robot.out\", \"w\", stdout);\n\n\tstatic int x[Maxn], y[Maxn], xjig[Maxn], amt = 0;\n\n\tclar (head, -1), e = 0;\n\tMath :: Init();\n\n\tn = read() << 1;\n\trep (i, 1, n) {\n\t\tx[i] = read(), y[i] = read();\n\t\tadd(x[i], y[i] + n / 2, x[i] + y[i]);\n\t\tadd(y[i] + n / 2, x[i], x[i] + y[i]);\n\t\tif (!xjig[x[i]]) ++amt, xjig[x[i]] = 1;\n\t\tif (!xjig[y[i] + n / 2]) ++amt, xjig[y[i] + n / 2] = 1;\n\t}\n\tif (amt != n) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tLL ans = 1, sum = 0;\n\trep (i, 1, n) \n\t\tif (!vis[i]) {\n\t\t\tint res = 0; _top = 0, cir.clear(), found = 0, delta = 0, cus.clear(), cun.clear();\n\t\t\tdfsCir(i, 0);\n\t\t\trep (j, 0, cus.size() - 1) dfs1(cus[j], 0);\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].u] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].v] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\n\t\t\tans = 1ll * ans * res % Mod * C(sum += delta, delta) % Mod;\n\t\t}\n\tprintf(\"%d\\n\", 1ll * ans * fpm(fac[n], Mod - 1) % Mod);\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e5 + 5;\nconst LL mod = 1e9 + 7;\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], top;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  //cerr << x << \" -> \" << y << endl;\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n      break;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= top; i ++)\n    Fir[vertex[i]] = deg[vertex[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = top, i; u; u --) {\n    i = vertex[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = top, i = vertex[u]; u; u --, i = vertex[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  return res;\n}\n\nint main() {\n  pre();\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      top = 0;\n      dfs(k);\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      if (ans >= mod) ans -= mod;\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      tmp = tmp * C(p, top) % mod;\n      ans = ans * tmp % mod;\n      p -= top;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nclass unionfind {\n\tvector<int> par, rank;\n\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return ;\n\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y]) ++rank[x];\n\t\t}\n\t}\n\n\tbool same(int x, int y) { return (find(x) == find(y)); }\n} uf;\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = 200010;\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < MX; ++i) {\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t}\n\tfact[0] = ifact[0] = 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tifact[i] = ifact[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(int n, int r) {\n\tif (n < 0 || r < 0 || r > n) return 0;\n\treturn fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\n// allow multiple components\nconst int maxn = 200010;\n\nint V;\nint deg[maxn], par[maxn];\nvi g[maxn], g2[maxn];\nbool vis[maxn];\nvector<vi> cycles;\n\nvoid add_edge(int a, int b) {\n\tg[a].pb(b); g[b].pb(a);\n\t++deg[a]; ++deg[b];\n}\n\nvoid dfs(int v, vi& cycle) {\n\tvis[v] = true;\n\tcycle.pb(v);\n\n\tfor (int to : g[v]) if (deg[to] == 2 && !vis[to]) {\n\t\tdfs(to, cycle);\n\t}\n}\n\nvoid build() {\n\tmemset(par, -1, sizeof(par));\n\n\tqueue<int> que;\n\trep(i, V) {\n\t\tif (deg[i] == 1) {\n\t\t\tque.push(i);\n\t\t}\n\t}\n\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tvis[v] = true;\n\t\tfor (int to : g[v]) if (deg[to] > 1) {\n\t\t\tg2[to].pb(v);\n\t\t\tpar[v] = to;\n\n\t\t\tif (--deg[to] == 1) {\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, V) if (deg[i] == 2 && !vis[i]) {\n\t\tvi cyc;\n\t\tcycles.eb(cyc);\n\t\tdfs(i, cycles.back());\n\t}\n}\n\nint dp[maxn];\n\nbool us[maxn];\nint ord[maxn];\n\nvoid topo(int v, int &k, const vector<vi>& gp) {\n\tus[v] = true;\n\tfor (int to : gp[v]) {\n\t\tif (!us[to]) {\n\t\t\ttopo(to, k, gp);\n\t\t}\n\t}\n\tord[v] = k++;\n}\n\nint reach(int v, const vector<vi>& gp) {\n\tif (dp[v] != -1) {\n\t\treturn dp[v];\n\t}\n\tint s = 0;\n\tfor (int to : gp[v]) {\n\t\ts += reach(to, gp) + 1;\n\t}\n\treturn dp[v] = s;\n}\n\nvi cmp[maxn];\nint id[maxn];\n\nint main() {\n\tint N; cin >> N; V = N * 2;\n\tinit();\n\tuf.init(V);\n\n\trep(i, N*2) {\n\t\tint x, y; cin >> x >> y;\n\t\t--x; --y;\n\t\tadd_edge(x, y + N);\n\t\tuf.unite(x, y + N);\n\t}\n\n\tbuild();\n\tbool ok = true;\n\trep(i, V) if (!vis[i]) {\n\t\tok = false;\n\t}\n\n\tif (!ok) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\n\tll ans = 1;\n\n\trep(i, V) cmp[uf.find(i)].pb(i);\n\tint s = 0;\n\n\trep(i, cycles.size()) {\n\t\tint c = uf.find(cycles[i][0]);\n\t\tvi& vec = cmp[c];\n\t\tvi match(vec.size(), -1);\n\t\trep(j, vec.size()) id[vec[j]] = j;\n\n\t\tll way = 0;\n\t\trep(t, 2) { //try 2 directions\n\t\t\tvector<vi> gp(vec.size());\n\n\t\t\trep(j, vec.size()) {\n\t\t\t\tdp[j] = -1;\n\t\t\t\tus[j] = 0;\n\t\t\t}\n\n\t\t\tfor (int v : vec) if (par[v] != -1) {\n\t\t\t\tmatch[id[v]] = id[par[v]];\n\t\t\t}\n\t\t\trep(j, cycles[i].size()) {\n\t\t\t\tint nx = (j + 1) % cycles[i].size();\n\t\t\t\tmatch[id[cycles[i][j]]] = id[cycles[i][nx]];\n\t\t\t}\n/*\n\t\t\trep(j, vec.size()) {\n\t\t\t\tcout << vec[j] << \", id = \" << j << \" \" << match[j] << endl;\n\t\t\t}\n*/\n\t\t\tfor (int v : vec) {\n\t\t\t\tint to = match[id[v]];\n\t\t\t\tfor (int u : g[v]) {\n\t\t\t\t\tif (u < vec[to]) {\n\t\t\t\t\t\tgp[id[v]].pb(id[u]);\n\t\t\t\t\t\t//cerr << id[v] << \"---\" << id[u] << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint now = 0;\n\n\t\t\trep(j, vec.size()) {\n\t\t\t\tif (!us[j]) {\n\t\t\t\t\ttopo(j, now, gp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool ok = true;\n\t\t\trep(j, vec.size()) {\n\t\t\t\tfor (int to : gp[j]) {\n\t\t\t\t\tif (ord[j] < ord[to]) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tll f = 1;\n\t\t\tif (ok) {\n\t\t\t\trep(j, vec.size()) {\n\t\t\t\t\tf = f * inv[reach(j, gp) + 1] % MOD;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tf = 0;\n\t\t\t}\n\n\t\t\tway = (way + f) % MOD;\n\n\t\t\treverse(ALL(cycles[i]));\n\t\t}\n\n\t\tway = way * fact[cmp[c].size()] % MOD;\n\n\t\tans = ans * way % MOD * comb(s + cmp[c].size(), s) % MOD;\n\t\ts += cmp[c].size();\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=200010;\nconst int mod=1000000007;\nint n,first[maxn],nxt[maxn<<1],to[maxn<<1],dis[maxn<<1],e;\nvoid Add(int u,int v,int w) {\n//\tprintf(\"%d -> %d %d\\n\",u,v,w);\n\tto[++e]=v;dis[e]=w;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;dis[e]=w;nxt[e]=first[v];first[v]=e;\n}\nint pa[maxn],siz[maxn],es[maxn],vis[maxn];\nint findset(int x) {return x==pa[x]?x:pa[x]=findset(pa[x]);}\nvoid GG() {puts(\"0\");exit(0);}\nint sta[maxn],cir[maxn],left[maxn],right[maxn],col[maxn],clo,top;\nvector<int> s,all;\nint dfs(int x,int la) {\n\tif(vis[x]) {\n\t\twhile(top) {\n\t\t\tint y=sta[top--];\n\t\t\tcir[y]=1;s.pb(y);\n\t\t\tif(x==y) break;\n\t\t}\n\t\treturn 1;\n\t}\n\tvis[x]=++clo;sta[++top]=x;\n\tfor(int i=first[x];i;i=nxt[i]) if((i-1)!=(la-1^1)){\n\t\tif(dfs(to[i],i)) return 1;\n\t}\n\ttop--;\n\treturn 0;\n}\nvoid dfsout(int x,int fa) {\n\tall.pb(x);\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa&&!cir[to[i]]) {\n\t\tcol[to[i]]=dis[i];\n\t\tdfsout(to[i],x);\n\t}\n}\nint fac[maxn],ifac[maxn],size[maxn];\nint C(int a,int b) {return (ll)fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nvector<int> G[maxn];\nint deg[maxn],f[maxn];\nvoid dp(int x) {\n\tf[x]=1;size[x]=0;\n\trep(i,0,G[x].size()-1) {\n\t\tdp(G[x][i]);\n\t\tf[x]=(ll)f[x]*f[G[x][i]]%mod;\n\t\tf[x]=(ll)f[x]*ifac[size[G[x][i]]]%mod;\n\t\tsize[x]+=size[G[x][i]];\n\t}\n\tf[x]=(ll)f[x]*fac[size[x]]%mod;\n\tsize[x]++;\n}\nint work() {\n\trep(j,0,all.size()-1) G[all[j]].clear(),deg[all[j]]=0;\n\trep(j,0,all.size()-1) {\n\t\tint x=all[j];\n\t\tfor(int i=first[x];i;i=nxt[i]) if(dis[i]<col[x]) G[x].pb(to[i]),deg[to[i]]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,0,all.size()-1) if(!deg[all[i]]) {\n\t\tdp(all[i]);\n\t\tans=(ll)ans*C(cur+size[all[i]],cur)%mod;\n\t\tans=(ll)ans*f[all[i]]%mod;\n\t\tcur+=size[all[i]];\n\t}\n\treturn ans;\n}\nint main() {\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tn=read();\n\tifac[0]=ifac[1]=fac[0]=1;\n\trep(i,2,n*2) ifac[i]=(ll)(mod-mod/i)*ifac[mod%i]%mod;\n\trep(i,1,n*2) fac[i]=(ll)fac[i-1]*i%mod,ifac[i]=(ll)ifac[i-1]*ifac[i]%mod;\n\trep(i,1,n*2) pa[i]=i,siz[i]=1;\n\trep(i,1,n*2) {\n\t\tint x=read(),y=read(),w=x+y;\n\t\tAdd(x,y+n,w);\n\t\tx=findset(x);y=findset(y+n);\n\t\tif(x!=y) {pa[x]=y;siz[y]+=siz[x];es[y]+=es[x];}\n\t\tes[y]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,1,n*2) if(i==findset(i)) {\n\t\tif(siz[i]!=es[i]) GG();\n\t\ts.clear();all.clear();dfs(i,0);top=0;\n\t\trep(i,0,s.size()-1) {\n\t\t\tdfsout(s[i],0);\n\t\t\tint prev=((!i)?s[s.size()-1]:s[i-1]);\n\t\t\tint nxtv=(i==s.size()-1?s[0]:s[i+1]);\n\t\t\tfor(int j=first[s[i]];j;j=nxt[j]) {\n\t\t\t\tif(to[j]==prev) left[s[i]]=dis[j];\n\t\t\t\tif(to[j]==nxtv) right[s[i]]=dis[j];\n\t\t\t}\n\t\t}\n\t\tans=(ll)ans*C(cur+all.size(),cur)%mod;\n\t\tcur+=all.size();\n\t\tint tmp=0;\n\t\trep(i,0,s.size()-1) col[s[i]]=left[s[i]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\trep(i,0,s.size()-1) col[s[i]]=right[s[i]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\tans=tmp;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 2e5 + 5;\nconst int MOD = 1e9 + 7;\n\nint qpow(int base, int e) {\n    int ret = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret = (LL) ret * base % MOD;\n        }\n        base = (LL) base * base % MOD;\n    }\n    return ret;\n}\n\nint n, fac[N], inv[N], finv[N];\n\nvoid prep() {\n    fac[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fac[i] = (LL) fac[i - 1] * i % MOD;\n    }\n    inv[n] = qpow(fac[n], MOD - 2);\n    for (int i = n; i >= 1; --i) {\n        inv[i - 1] = (LL) inv[i] * i % MOD;\n    }\n    for (int i = 1; i <= n; ++i) {\n        finv[i] = (LL) inv[i] * fac[i - 1] % MOD;\n    }\n}\n\nnamespace CalcTop {\n\nbool vis[N];\nint sz[N];\nvector<int> vc, g[N];\n\nvoid add_edge(int x, int y) {\n    vc.emplace_back(x);\n    vc.emplace_back(y);\n    g[x].emplace_back(y);\n}\n\nint dfs(int x) {\n    if (vis[x]) return 1;\n    vis[x] = true;\n    int ret = sz[x] = 1;\n    for (int y : g[x]) {\n        ret = (LL) ret * dfs(y) % MOD;\n        sz[x] += sz[y];\n    }\n    ret = (LL) ret * finv[sz[x]] % MOD;\n    return ret;\n}\n\nint calc() {\n    int ret = 1;\n    for (int x : vc) {\n        ret = (LL) ret * dfs(x) % MOD;\n    }\n    for (int x : vc) {\n        vis[x] = false;\n        g[x].clear();\n    }\n    vc.clear();\n    return ret;\n}\n\n}\n\nint dom[N];\nvector<int> vc, g[N];\nbool vis[N];\nint v1, v2, v3;\n\nvoid get_tp(int x, int p = 0) {\n    if (vis[x]) {\n        if (v1) {\n            puts(\"0\");\n            exit(0);\n        }\n        v1 = x; v2 = p;\n        return;\n    }\n    vc.emplace_back(x);\n    vis[x] = true;\n    bool flag = true;\n    for (int y : g[x]) {\n        if (y == p) continue;\n        if (x == v1 && y == v2) continue;\n        get_tp(y, x);\n        if (flag && v1 == x) {\n            v3 = y;\n            flag = false;\n        }\n    }\n}\n\nvoid dfs(int rt, int x, int p = 0) {\n    dom[x] = p;\n    if (rt == x && p) return;\n    for (int y : g[x]) {\n        if (y != p) {\n            dfs(rt, y, x);\n        }\n    }\n}\n\nint calc(int rt) {\n    dfs(rt, rt);\n    for (int x : vc) {\n        if (x < dom[dom[x]]) {\n            CalcTop::add_edge(dom[x], x);\n        }\n    }\n    return CalcTop::calc();\n}\n\nint main() {\n    n = read();\n    for (int i = 0, _ = n << 1; i < _; ++i) {\n        int x = read(), y = read() + n;\n        g[x].emplace_back(y);\n        g[y].emplace_back(x);\n    }\n\n    n <<= 1;\n    prep();\n    int ans = fac[n];\n    for (int i = 1; i <= n; ++i) {\n        if (vis[i]) continue;\n        v1 = 0;\n        get_tp(i);\n        int x = v1;\n        if (!x) return puts(\"0\"), 0;\n        assert(v2 != v3);\n        iter_swap(find(g[x].begin(), g[x].end(), v2), g[x].begin());\n        iter_swap(find(g[x].begin(), g[x].end(), v3), g[x].rbegin());\n\n        int val1 = calc(x);\n        swap(g[x].front(), g[x].back());\n        int val2 = calc(x);\n        ans = (LL) ans * (val1 + val2) % MOD;\n\n        vc.clear();\n    }\n\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=2e5+5,P=1e9+7;\ninline int fpow(int a,int t){static int r;for(r=1;t;t>>=1,a=(ll)a*a%P)if(t&1)r=(ll)r*a%P;return r;}\nint n,fac[N],ifac[N],ans=1,m,now;\ninline int C(int n,int m){return (ll)fac[n]*ifac[m]%P*ifac[n-m]%P;}\n\nbool vi[N];\nvector<int>e[N];\nint id[N],idc,s1,s2,fa[N],pa[N];\n\nvoid dfs(int x){\n\tvi[x]=true;id[++idc]=x;\n\tif(x<=n)s1++;else s2++;\n\tsort(e[x].begin(),e[x].end());\n\tfor(int v:e[x])if(fa[x]!=v){\n\t\tfa[v]=x;if(!vi[v])dfs(v);\n\t}\n}\nint find(int x){\n\tif(vi[x])return x; \n\tvi[x]=true;\n\tint t=0;\n\tfor(int v:e[x])if(pa[x]!=v){pa[v]=x,t=find(v);if(t)break;}\n\tvi[x]=false;\n\treturn t;\n}\n\nint sz[N],in[N];\nvector<int>E[N];\n\nint solve(int x){\n\tint r=1;\n\tfor(int v:E[x]){\n\t\tr=(ll)r*solve(v)%P;\n\t\tr=(ll)r*C(sz[x]+sz[v],sz[v])%P;\n\t\tsz[x]+=sz[v];\n\t}\n\tsz[x]++;\n\treturn r;\n}\n\nint calc(){\n\tfor(int i=1,u;i<=idc;i++)\n\t\tfor(int x:e[u=id[i]]){\n\t\t\tif(x==fa[u])break;\n\t\t\tE[u].pb(x),in[x]++;\n\t\t}\n\tfor(int i=1,u;i<=idc;i++)if(!in[u=id[i]])E[0].pb(u),in[u]++;\n\tint ans=solve(0);\n\tfor(int i=0,u;i<=idc;i++)E[u=id[i]].clear(),in[u]=sz[u]=0;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor(int i=1;i<=2*n;i++)fac[i]=(ll)fac[i-1]*i%P;\n\tifac[2*n]=fpow(fac[2*n],P-2);\n\tfor(int i=2*n;i>=1;i--)ifac[i-1]=(ll)ifac[i]*i%P;\n\tfor(int i=1,x,y;i<=2*n;i++)scanf(\"%d%d\",&x,&y),e[x].pb(y+n),e[y+n].pb(x);\n\tfor(int i=1;i<=2*n;i++)if(!vi[i]){\n\t\tint R=find(i);\n\t\tif(!R){ans=0;break;}\n\t\tdfs(R);\n\t\tint se=0;\n\t\tfor(int k=1;k<=idc;k++)se+=e[id[k]].size();se>>=1;\n\t\tif(se!=s1+s2){ans=0;break;}\n\t\tnow=calc();\n\t\tfor(int x=pa[R]=fa[R];x!=R;x=pa[x]=fa[x]);\n\t\tfa[pa[R]]=R;\n\t\tfor(int x=pa[R];x!=R;x=pa[x])fa[pa[x]]=x;\n\t\tnow=(now+calc())%P;\n\t\tans=(ll)ans*now%P*C(m+idc,m)%P;\n\t\tm+=idc;\n\t\twhile(idc)id[idc--]=0;s1=s2=0;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\nnamespace IO {\n    template <typename _T>\n    inline bool read (_T& x) {\n        x = 0;\n        _T y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return false;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return true;\n    }\n\n    template <typename _T>\n    inline _T input () {\n        _T x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return x;\n    }\n};\nusing namespace IO;\n\nnamespace modular {\n    const int MOD = 1000000007;\n\n    inline int add (int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n\n    inline void inc (int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n\n    inline int mul (int x, int y) { return 1LL * x * y % MOD; }\n\n    inline int qpow (int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x)) if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};\nusing namespace modular;\n\n#define reg register\n#define MAX_N 200007\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define lep(i, l, r) for(int i = l; i < r; ++i)\n#define irep(i, r, l) for(int i = r; i >= l; --i)\n#define ilep(i, r, l) for(int i = r; i > l; --i)\ntypedef long long ll;\n\nstruct edge {\n    int head[MAX_N], to[MAX_N << 1], nxt[MAX_N << 1], val[MAX_N << 1], cap;\n    edge () : cap(0) {}\n    inline void addE (int u, int v, int w = 0) {\n        nxt[++cap] = head[u];\n        head[u] = cap;\n        to[cap] = v;\n        val[cap] = w;\n    }\n}E, en;\n\nint N, M, res = 1, ans = 0, totv, tote, now;\nint dep[MAX_N], st[MAX_N], top, fa[MAX_N], val[MAX_N];\nint vert[MAX_N], tp;\nint deg[MAX_N], fac[MAX_N], ifac[MAX_N];\nbool vis[MAX_N], vise[MAX_N], onc[MAX_N];\n\nbool findcir (int x, int las = 0) {\n    if (vis[x]) return false;\n    totv++;\n    vis[x] = true;\n    vert[++tp] = x;\n    bool flag = false;\n    for (int i = E.head[x]; i; i = E.nxt[i]) {\n        // printf(\"%d %d\\n\", x, E.to[i]);\n        tote++;\n        if (!vis[E.to[i]]) {\n            if (findcir(E.to[i], x)) flag = true;\n        } else if (E.to[i] != las && x != now) {\n            // printf(\"%d %d\\n\", x, E.to[i]);\n            flag = true;\n            now = E.to[i];\n        }\n    }\n    // printf(\"%d %d\\n\", x, flag);\n    if (flag) onc[x] = true, st[++top] = x;\n    // printf(\"%d %d\\n\", x, flag);\n    return flag && (now != x);\n}\n\nvoid getd (int x, int las) {\n    for (int i = E.head[x]; i; i = E.nxt[i])\n        if (E.to[i] != las && !onc[E.to[i]]) {\n            dep[E.to[i]] = dep[x] + 1;\n            fa[E.to[i]] = x, val[E.to[i]] = E.val[i];\n            getd(E.to[i], x);\n        }\n}\n\nvoid getc (int x, int las, int t) {\n    for (int i = E.head[x], v = E.to[i]; i; i = E.nxt[i], v = E.to[i])\n        if (onc[v] && v != las) {\n            fa[x] = v, val[x] = E.val[i];\n            if (v != t) getc(v, x, t);\n        }\n}\n\nint f[MAX_N], sz[MAX_N];\n\ninline int C (int x, int y) {\n    if (x < y || y < 0) return 0;\n    return mul(fac[x], mul(ifac[y], ifac[x - y]));\n}\n\nvoid dp (int x) {\n    // printf(\"%d\\n\", x);\n    sz[x] = f[x] = 1;\n    for (int i = en.head[x], v = en.to[i]; i; i = en.nxt[i], v = en.to[i]) {\n        dp(v);\n        f[x] = mul(f[x], mul(f[v], ifac[sz[v]]));\n        // f[x] = mul(mul(f[x], f[v]), C(sz[x] + sz[v] - 1, sz[v]));\n        sz[x] += sz[v];\n    }\n    f[x] = mul(f[x], fac[sz[x] - 1]);\n}\n\ninline void solve () {\n    en.cap = 0;\n    rep (i, 1, tp) en.head[vert[i]] = 0;\n    en.head[M + 1] = 0;\n    rep (t, 1, tp) {\n        int x = vert[t];\n        // printf(\"%d %d %d\\n\", x, fa[x], val[x]);\n        for (int i = E.head[x], v = E.to[i]; i; i = E.nxt[i], v = E.to[i])\n            if (v != fa[x] && E.val[i] < val[x]) {\n                // printf(\"%d %d\\n\", x, E.to[i]);\n                en.addE(x, E.to[i]);\n                deg[E.to[i]]++;\n            }\n    }\n    rep (i, 1, tp) if (!deg[vert[i]]) {\n        en.addE(M + 1, vert[i]);\n    }\n    rep (i, 1, tp) deg[vert[i]] = 0;\n    dp(M + 1);\n    inc(ans, f[M + 1]);\n}\n\ninline void init () {\n    fac[0] = ifac[0] = 1;\n    rep (i, 1, M) fac[i] = mul(fac[i - 1], i);\n    ifac[M] = qpow(fac[M], MOD - 2);\n    irep (i, M, 2) ifac[i - 1] = mul(ifac[i], i);\n}\n\nint main () {\n    FIN(\"in\");\n    read(N);\n    M = 2 * N;\n    init();\n    int x, y;\n    rep (i, 1, M) {\n        read(x), read(y);\n        // printf(\"%d %d %d\\n\", x, y + N, x + y);\n        E.addE(x, y + N, x + y);\n        E.addE(y + N, x, x + y);\n    }\n    int tot = 0;\n    rep (i, 1, N * 2) if (!vis[i]) {\n        totv = tote = top = tp = 0;\n        findcir(i);\n        // printf(\"%d %d\\n\", tote, totv);\n        // rep (i, 1, top) printf(\"%d \", st[i]); puts(\"\");\n        // break;\n        if (tote != totv * 2) { res = 0; break; }\n        tot += totv;\n        rep (i, 1, top) {\n            dep[st[i]] = 0;\n            getd(st[i], 0);\n        }\n        ans = 0;\n        int u = st[1];\n        for (int j = E.head[u]; j; j = E.nxt[j])\n            if (onc[E.to[j]]) {\n                // printf(\"%d %d\\n\", u, E.to[j]);\n                fa[u] = E.to[j];\n                val[u] = E.val[j];\n                getc(E.to[j], u, u);\n                solve();\n                // printf(\"%d\\n\", ans);\n                // return 0;\n            }\n        // printf(\"%d\\n\", ans);\n        res = mul(mul(res, ans), C(tot, totv));\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[201000];\nint n, ss, v[201000], Q[201000], head, tail, Deg[201000], Nxt[201000], Mod = 1000000007, C[201000];\nint F[201000], InvF[201000];\nlong long D[201000];\nvector<int>T, G[201000];\nvoid DFS(int a){\n    T.push_back(a);\n    ss += E[a].size();\n    v[a] = 1;\n    for(int i=0;i<E[a].size();i++)if(!v[E[a][i]])DFS(E[a][i]);\n}\nvoid DP(int a){\n    int i;\n    int r = 1;\n    C[a] = 0;\n    for(i=0;i<G[a].size();i++){\n        DP(G[a][i]);\n        r = 1ll * r * D[G[a][i]] % Mod * InvF[C[G[a][i]]] % Mod;\n        C[a] += C[G[a][i]];\n    }\n    D[a] = 1ll * r * F[C[a]]%Mod;\n    C[a]++;\n}\nlong long Get(int st, int a){\n    Nxt[st] = a;\n    int pp = st, i;\n    while(a != st){\n        for(i=0;i<E[a].size();i++){\n            if(Deg[E[a][i]] > 1 && pp != E[a][i])break;\n        }\n        pp = a;\n        Nxt[a] = E[a][i];\n        a = E[a][i];\n    }\n    for(i=0;i<T.size();i++)G[T[i]].clear();\n    G[0].clear();\n    for(i=0;i<T.size();i++){\n        if(T[i] < Nxt[Nxt[T[i]]]) G[Nxt[T[i]]].push_back(T[i]);\n        else G[0].push_back(T[i]);\n    }\n    DP(0);\n    return D[0];\n}\nint Res = 1;\nvoid Calc(){\n    int i;\n    head = tail = 0;\n    for(i=0;i<T.size();i++){\n        if(Deg[T[i]] == 1)Q[++tail] = T[i];\n    }\n    int x;\n    while(head < tail){\n        x = Q[++head];\n        for(i=0;i<E[x].size();i++){\n            if(Deg[E[x][i]] > 1){\n                Nxt[x] = E[x][i];\n                Deg[E[x][i]]--;\n                if(Deg[E[x][i]] == 1)Q[++tail] = E[x][i];\n            }\n        }\n    }\n    for(i=0;i<T.size();i++){\n        if(Deg[T[i]] > 1)break;\n    }\n    x = T[i];\n    int t1 = -1, t2 = -1;\n    for(i=0;i<E[x].size();i++){\n        if(Deg[E[x][i]] > 1){\n            if(t1 == -1)t1 = E[x][i];\n            else t2 = E[x][i];\n        }\n    }\n    int s = 0;\n    s += Get(x, t1);\n    s += Get(x, t2);\n    Res = 1ll * Res * s % Mod * InvF[T.size()] % Mod;\n}\nint Pow(int a, int b){\n    int r = 1;\n    while(b){\n        if(b&1)r=1ll*r*a%Mod;\n        a=1ll*a*a%Mod;b>>=1;\n    }\n    return r;\n}\nint main(){\n    int i, x, y;\n    scanf(\"%d\",&n);\n    F[0] = 1;\n    for(i=1;i<=n+n;i++)F[i] = 1ll*F[i-1]*i%Mod;\n    InvF[n+n] = Pow(F[n+n], Mod-2);\n    for(i=n+n-1;i>=0;i--)InvF[i] = 1ll*InvF[i+1]*(i+1)%Mod;\n    for(i=1;i<=n+n;i++){\n        scanf(\"%d%d\",&x,&y);\n        E[x].push_back(n+y);\n        E[n+y].push_back(x);\n        Deg[x]++,Deg[n+y]++;\n    }\n    for(i=1;i<=n+n;i++){\n        if(!v[i]){\n            ss = 0;\n            T.clear();\n            DFS(i);\n            if(ss != T.size()*2){\n                printf(\"0\\n\");\n                return 0;\n            }\n            Calc();\n        }\n    }\n    Res = 1ll * Res * F[n+n]%Mod;\n    printf(\"%d\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n#define int ll\n\ttypedef long long ll;\n\tconst int p = 1000000007;\n\tconst int N = 2e5 + 5;\n\n\tint n, vis[N], fac[N], inv[N], invfac[N], size[N], fa[N], onloop[N];\n\tvector<int> E[N], tr[N], node, loop;\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tvoid init()\n\t{\n\t\tfac[0] = invfac[0] = inv[1] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfac[i] = (ll)fac[i - 1] * i % p;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tinv[i] = (ll)inv[p % i] * (p - p / i) % p;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tinvfac[i] = (ll)invfac[i - 1] * inv[i] % p;\n\t}\n\n\tvoid dfs1(const int u, const int f)\n\t{\n\t\tvis[u] = 1;\n\t\tnode.push_back(u);\n\t\tfor (auto v : E[u])\n\t\t\tif (v != f && !vis[v])\n\t\t\t\tdfs1(v, u);\n\t}\n\n\tbool findloop(const int u, const int f)\n\t{\n\t\tstatic int top, sta[N], in[N];\n\t\tsta[++top] = u, in[u] = 1;\n\t\tfor (auto v : E[u])\n\t\t\tif (v != f)\n\t\t\t{\n\t\t\t\tif (in[v])\n\t\t\t\t{\n\t\t\t\t\tdo \t\t\n\t\t\t\t\t{\n\t\t\t\t\t\tloop.push_back(sta[top]);\n\t\t\t\t\t\tonloop[sta[top--]] = 1;\n\t\t\t\t\t}\n\t\t\t\t\twhile (sta[top + 1] != v);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (findloop(v, u))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t--top, in[u] = 0;\n\t\treturn false;\n\t}\n\n\tvoid dfs2(const int u)\n\t{\n\t\tfor (auto v : E[u])\n\t\t\tif (v != fa[u] && !onloop[v])\n\t\t\t\tfa[v] = u, dfs2(v);\n\t}\n\n\tvoid dfs3(const int u)\n\t{\n\t\tsize[u] = 1;\n\t\tfor (auto v : tr[u])\n\t\t\tdfs3(v), size[u] += size[v];\n\t}\t\n\n\tint calc()\n\t{\n\t\tstatic int in[N];\n\t\tint nc = node.size();\n\t\tmemset(in, 0, sizeof(int[nc + 1]));\n\t\tfor (int i = 1; i <= nc; i++)\n\t\t\tfor (auto j : E[node[i - 1]])\n\t\t\t\tif (j < fa[node[i - 1]])\n\t\t\t\t\ttr[node[i - 1]].push_back(j), ++in[j];\n\t\tfor (int i = 1; i <= nc; i++)\n\t\t\tif (!in[node[i - 1]])\n\t\t\t\ttr[0].push_back(node[i - 1]);\n\t\tdfs3(0);\n\t\ttr[0].clear();\n\t\tfor (int i = 1; i <= nc; i++)\n\t\t\ttr[node[i - 1]].clear();\n\t\tint ans = fac[size[0] - 1];\n\t\tfor (int i = 1; i <= nc; i++)\n\t\t\tans = (ll)ans * inv[size[node[i - 1]]] % p;\n\t\treturn ans;\n\t}\n\n\tint solve(const int x)\n\t{\n\t\tnode.clear();\n\t\tdfs1(x, 0);\n\t\tint nc = node.size(), ec = 0;\n\t\tfor (auto i : node)\n\t\t\tec += E[i].size();\n\t\tif ((ec >> 1) != nc)\n\t\t\treturn 0;\n\n\t\tloop.clear();\n\t\tfindloop(x, 0);\n\t\tfor (auto i : loop)\n\t\t\tdfs2(i);\n\n\t\tint tot = loop.size(), u = 0, v = 0;\n\t\tfor (int i = 1; i < tot; i++)\n\t\t\tif (loop[i - 1] + loop[i] > u + v)\n\t\t\t\tu = loop[i - 1], v = loop[i];\n\t\tE[u].erase(find(E[u].begin(), E[u].end(), v));\n\t\tE[v].erase(find(E[v].begin(), E[v].end(), u));\n\n\t\tfa[loop[0]] = loop[tot - 1];\n\t\tfor (int i = 1; i < tot; i++)\n\t\t\tfa[loop[i]] = loop[i - 1];\n\t\tint sum = calc();\n\n\t\tfa[loop[tot - 1]] = loop[0];\n\t\tfor (int i = 1; i < tot; i++)\n\t\t\tfa[loop[i - 1]] = loop[i];\n\t\treturn int((ll)(sum + calc()) % p * invfac[nc] % p);\n\t}\n\n\tvoid work()\n\t{\n\t\tn = read() << 1;\n\t\tinit();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint x = read(), y = read() + (n >> 1);\n\t\t\tE[x].push_back(y);\n\t\t\tE[y].push_back(x);\n\t\t}\n\t\tint ans = fac[n];\n\t\tfor (int i = 1; i <= n && ans; i++)\n\t\t\tif (!vis[i])\n\t\t\t\tans = (ll)ans * solve(i) % p;\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n#undef int\n}\n\nint main()\n{\n#ifdef DINO\n\tfreopen(\"3537.in\", \"r\", stdin);\n\tfreopen(\"3537.out\", \"w\", stdout);\n#endif\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n;\n\nint H(int x,int y){return x*n+y;}\n\nstruct side{\n  int y,next;\n}e[N*8+9];\nint lin[2][N*2+9],cs;\n\nvoid Ins(int id,int x,int y){e[++cs].y=y;e[cs].next=lin[id][x];lin[id][x]=cs;}\nvoid Ins2(int id,int x,int y){Ins(id,x,y);Ins(id,y,x);}\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n<<1;++i){\n\tint x,y;\n\tscanf(\"%d%d\",&x,&y);\n\tIns2(0,H(0,x),H(1,y));\n  }\n}\n\nint inv[N*2+9],fac[N*2+9],ifac[N*2+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n<<1;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint a[N*2+9],vis[N*2+9],ca;\nint st,td,ce;\n\nvoid Dfs_a(int k,int fa){\n  vis[a[++ca]=k]=1;\n  for (int i=lin[0][k];i;i=e[i].next){\n\t++ce;\n\tif (!vis[e[i].y]) Dfs_a(e[i].y,k);\n    else if (e[i].y^fa) st=k,td=e[i].y;\n  }\n}\n\nint pre[N*2+9];\n\nvoid Dfs_pre(int k,int fa){\n  for (int i=lin[0][k];i;i=e[i].next)\n\tif (e[i].y^fa&&e[i].y^st){\n\t  pre[e[i].y]=k;\n\t  Dfs_pre(e[i].y,k);\n\t}\n}\n\nint siz[N*2+9];\n\nvoid Dfs_siz(int k,int fa){\n  siz[k]=1;\n  for (int i=lin[1][k];i;i=e[i].next)\n\tif (e[i].y^fa){\n\t  Dfs_siz(e[i].y,k);\n\t  siz[k]+=siz[e[i].y];\n\t}\n}\n\nint deg[N*2+9];\n\nint Get_ans0(){\n  int res=fac[ca];\n  Dfs_pre(st,td);\n  pre[st]=td;\n  for (int i=1;i<=ca;++i) lin[1][a[i]]=0,deg[a[i]]=0;\n  for (int i=1;i<=ca;++i){\n\tint t=a[i];\n\tfor (int j=lin[0][t];j;j=e[j].next)\n\t  if (e[j].y<pre[t]) Ins(1,t,e[j].y),++deg[e[j].y];\n  }\n  for (int i=1;i<=ca;++i)\n\tif (!deg[a[i]]) Dfs_siz(a[i],0);\n  for (int i=1;i<=ca;++i) smul(res,inv[siz[a[i]]]);\n  return res;\n}\n\nint ans;\n\nvoid Get_ans(){\n  ans=fac[n<<1];\n  for (int i=1;i<=n<<1;++i)\n\tif (!vis[i]){\n\t  ca=ce=0;\n\t  Dfs_a(i,0);\n\t  if (ca<<1^ce) {ans=0;return;}\n\t  smul(ans,ifac[ca]);\n\t  int now=Get_ans0();\n\t  swap(st,td);\n\t  smul(ans,add(now,Get_ans0()));\n\t}\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 9, P = 1e9 + 7;\n\nint n, x[N], y[N];\n/*using pii = pair<int, int>;\nusing ull = unsigned long long;\nstruct Hash {\n\tull operator () (const pii &pi) const {\n\t\treturn (ull)pi.first << 31 | pi.second;\n\t}\n};\nunordered_map<pii, int, Hash>T;*/\nvector<int>V[N];\nint dep[N], ss[N], h[N], t, es, ns, ans, f[N], fac[N], fac_rev[N], s[N], sum, tmp, A, B;\nbool vis[N], o;\n\nvoid Dfs (int x, int d, int y) {\n\tvis[x] ^= 1;\n\tss[dep[x] = d] = x;\n\t++ns;\n\tfor (auto v : V[x]) if (v != y) {\n\t\t++es;\n\t\tif (!vis[v]) Dfs(v, d + 1, x); else if (o) { o = 0; for (int i = dep[v]; i <= d; ++i) h[++t] = ss[i]; }\n\t}\n}\n\nvoid Dfs2 (int x, int y) {\n\tf[x] = 1; s[x] = 0;\n\tfor (auto v : V[x]) if (v != y && (v != A || x != B) && (v != B || x != A)) {\n\t\tDfs2(v, x);\n\t\tif (v < y) {\n\t\t\tf[x] = 1ll * f[x] * fac_rev[s[v]] % P * f[v] % P;\n\t\t\ts[x] += s[v];\n\t\t} else {\n\t\t\tsum = 1ll * sum * f[v] % P * fac_rev[s[v]] % P;\n\t\t}\n\t}\n\tf[x] = 1ll * f[x] * fac[s[x]] % P; ++s[x];\n\tif ((x == A && y == B) || (x == B && y == A)) sum = 1ll * sum * f[x] % P * fac_rev[s[x]] % P;\n}\n\nint qp (int a, int b) { int c = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b & 1) c = 1ll * c * a % P; return c; }\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= (n << 1); ++i) scanf(\"%d%d\", &x[i], &y[i]), y[i] += n, V[x[i]].emplace_back(y[i]), V[y[i]].emplace_back(x[i]);\n\tfac[0] = 1; for (int i = 1; i <= (n << 1); ++i) fac[i] = 1ll * fac[i - 1] * i % P;\n\tfac_rev[n << 1] = qp(fac[n << 1], P - 2);\n\tfor (int i = (n << 1) - 1; ~i; --i) fac_rev[i] = 1ll * fac_rev[i + 1] * (i + 1) % P;\n\tans = fac[n << 1];\n\tfor (int i = 1; i <= n; ++i) if (!vis[i]) {\n\t\to = 1; t = es = ns = tmp = 0;\n\t\tDfs(i, 0, 0);\n\t\tif (es != ns + 1) puts(\"0\"), exit(0);\n\t\tA = h[1]; B = h[t];\n\t\tfor (int i = 1; i < t; ++i) if (h[i] + h[i + 1] > A + B) A = h[i], B = h[i + 1];\n\t\tsum = 1; Dfs2(A, B); tmp = (tmp + sum) % P;\n\t\tsum = 1; Dfs2(B, A); tmp = (tmp + sum) % P;\n\t\tans = 1ll * ans * tmp % P;\n//\t\tfor (int i = 1; i <= t; ++i) printf(\"%d%c\", h[i], i == t ? '\\n' : ' ');\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (!isdigit(ch)) f=ch=='-'?-1:f,ch=getchar();\n\twhile (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\n\nconst int P=1000000007;\nconst int N=100005;\nconst int V=N<<1;\nconst int E=V<<1;\n\nint last[V],last_[V],nxt_[V],tov_[V],vis[V],fact[V],invf[V],X[V],Y[V],cir[V],eid[V],f[V],size[V],deg[V];\nint nxt[E],tov[E],bel[E];\nbool mark[E];\nvector<int> con;\nqueue<int> q;\nint n,v,tot,tot_,tim,ans,ecnt,sizcnt;\n\ninline void insert(int x,int y){++deg[tov[++tot]=y],nxt[tot]=last[x],last[x]=tot;}\ninline void insert_(int x,int y){++deg[tov_[++tot_]=y],nxt_[tot_]=last_[x],last_[x]=tot_;}\n\nint quick_power(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1,x=1ll*x*x%P) if (y&1) ret=1ll*ret*x%P;\n\treturn ret;\n}\n\nvoid pre()\n{\n\tfact[0]=1;\n\tfor (int i=1;i<=v;++i) fact[i]=1ll*fact[i-1]*i%P;\n\tinvf[v]=quick_power(fact[v],P-2);\n\tfor (int i=v;i>=1;--i) invf[i-1]=1ll*invf[i]*i%P;\n}\n\nvoid dfs(int x)\n{\n\tvis[x]=++tim,con.push_back(x);\n\tfor (int i=last[x],y;i;i=nxt[i])\n\t\tif (!mark[i+1>>1]) if (++ecnt,mark[i+1>>1]=1,!vis[y=tov[i]]) dfs(y);\n}\n\ninline int C(int n,int m){return 1ll*fact[n]*invf[m]%P*invf[n-m]%P;}\n\ninline int calc()\n{\n\tfor (;tot_;tov_[tot_]=nxt_[tot_]=0,--tot_);\n\tfor (int x:con) last_[x]=0;\n\tfor (int x:con)\n\t{\n\t\tint u=size[x]=0;f[x]=1;\n\t\tfor (int i=last[x];!u&&i;i=nxt[i]) if (bel[i+1>>1]==x) u=tov[i];\n\t\tfor (int i=last[x];i;i=nxt[i]) if (tov[i]<u) insert_(tov[i],x);\n\t}\n\tfor (int x:con) if (!deg[x]) q.push(x);\n\tint ret=1,siz=0;\n\tfor (int x;!q.empty();q.pop())\n\t{\n\t\t++size[x=q.front()];\n\t\tbool found=0;\n\t\tfor (int i=last_[x],y;i;i=nxt_[i])\n\t\t{\n\t\t\tif (!--deg[y=tov_[i]]) q.push(y);\n\t\t\tf[y]=1ll*f[y]*f[x]%P*C(size[y]+=size[x],size[x])%P,found=1;\n\t\t}\n\t\tif (!found) ret=1ll*ret*f[x]%P*C(siz+=size[x],size[x])%P;\n\t}\n\treturn ret;\n}\n\ninline void solve()\n{\n\tif (ecnt!=(int)con.size())\n\t{\n\t\tans=0;\n\t\treturn;\n\t}\n\tfor (int x:con) if (deg[x]==1) q.push(x);\n\tfor (;!q.empty();q.pop())\n\t{\n\t\tint x=q.front();\n\t\tfor (int i=last[x],y;i;i=nxt[i])\n\t\t\tif (deg[y=tov[i]]-1)\n\t\t\t{\n\t\t\t\tbel[i+1>>1]=x;\n\t\t\t\tif (--deg[y]==1) q.push(y);\n\t\t\t}\n\t}\n\tint src=0;\n\tfor (int x:con)\n\t\tif (deg[x]-1)\n\t\t{\n\t\t\tif (!src) src=x;\n\t\t\tvis[x]=0;\n\t\t}\n\tcir[0]=0;\n\tfor (int x=src,y,tar,i,lste=0,i_;!vis[x];vis[cir[++cir[0]]=x]=tim,eid[cir[0]]=lste=i_+1>>1,x=tar)\n\t\tfor (i=last[x],tar=0;!tar&&i;i=nxt[i])\n\t\t\tif (lste!=i+1>>1&&deg[y=tov[i]]-1) tar=y,i_=i;\n\tfor (int x:con) deg[x]=0;\n\tcir[cir[0]+1]=cir[1];\n\tfor (int i=1;i<=cir[0];++i) bel[eid[i]]=cir[i];\n\tint ret=calc();\n\tfor (int i=1;i<=cir[0];++i) bel[eid[i]]=cir[i+1];\n\t(ret+=calc())%=P;\n\tans=1ll*ans*ret%P*C(sizcnt+=ecnt,ecnt)%P;\n\tcon.clear(),ecnt=0;\n}\n\nint main()\n{\n\t//freopen(\"balls.in\",\"r\",stdin),freopen(\"balls.out\",\"w\",stdout);\n\tn=read(),v=n<<1;\n\tfor (int i=1;i<=v;++i) X[i]=read(),Y[i]=read(),insert(X[i],Y[i]+n),insert(Y[i]+n,X[i]);\n\tpre(),ans=1;\n\tfor (int x=1;ans&&x<=v;++x)\n\t\tif (!vis[x]) ++tim,dfs(x),solve();\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n\n#define fir first\n#define sec second\n\nusing namespace std;\nusing LL = long long;\nusing pii = pair<int, int>;\n\nconst int maxN = 2e5 + 2;\nconst int mod = 1e9 + 7;\n\nint n, ans = 1, curs, tmps;\nint fac[maxN], inv[maxN];\nint pre[maxN], deg[maxN], val[maxN], size[maxN], fa[maxN], prod[maxN];\nbitset<maxN> vis;\nvector<int> wib;\nvector<pii> G[maxN];\nvector<int> newG[maxN];\n\ninline void Mod(int& x)\n{ x >= mod ? x -= mod : x < 0 ? x += mod : 0; }\n\nint QPow(int bas, int ind)\n{\n    int res = 1;\n    while (ind)\n    {\n        if (ind & 1)\n            res = (LL)res * bas % mod;\n        bas = (LL)bas * bas % mod;\n        ind >>= 1;\n    }\n    return res;\n}\n\ninline int C(int n, int m)\n{ return (LL)fac[n] * inv[m] % mod * inv[n - m] % mod; }\n\nvoid Init(int lim)\n{\n    fac[0] = inv[0] = 1;\n    for (int i = 1; i <= lim; ++i)\n        fac[i] = (LL)fac[i - 1] * i % mod;\n    inv[lim] = QPow(fac[lim], mod - 2);\n    for (int i = lim - 1; i; --i)\n        inv[i] = (LL)inv[i + 1] * (i + 1) % mod;\n}\n\nvoid Topsort()\n{\n    static queue<int> q;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (deg[i] == 1)\n            q.push(i);\n        if (deg[i] == 0)\n        {\n            cout << 0 << endl;\n            exit(0);\n        }\n    }\n    while (!q.empty())\n    {\n        int u = q.front();\n        deg[u] = -1, q.pop();\n        for (auto i : G[u]) if (~deg[i.fir])\n        {\n            val[u] = i.sec;\n            if (--deg[i.fir] == 1)\n                q.push(i.fir);\n            if (deg[i.fir] == 0)\n            {\n                cout << 0 << endl;\n                exit(0);\n            }\n        }\n    }\n}\n\nvoid DFS(int u)\n{\n    for (auto i : G[u]) if (deg[i.fir] == 2 and i.sec != val[u])\n    {\n        if (!pre[i.fir])\n        {\n            pre[i.fir] = u, val[i.fir] = i.sec;\n            DFS(i.fir);\n        }\n        else\n            pre[i.fir] = u, val[i.fir] = i.sec;\n    }\n}\n\nvoid Getlink(int u)\n{\n    vis.set(u), wib.push_back(u);\n    for (auto i : G[u]) if (!vis[i.fir])\n        Getlink(i.fir);\n}\n\nvoid Getsize(int u)\n{\n    if (size[u])\n        return;\n    size[u] = prod[u] = 1;\n    for (auto i : G[u])\n        if (i.sec != val[u] and val[i.fir] < val[u])\n        {\n            fa[i.fir] = u;\n            Getsize(i.fir);\n            prod[u] = (LL)prod[u] * prod[i.fir] % mod;\n            size[u] += size[i.fir];\n        }\n    prod[u] = (LL)prod[u] * size[u] % mod;\n}\n\nint Getans()\n{\n    int siz = 1, pd = 1;\n    for (int i : wib)\n        size[i] = fa[i] = 0;\n    for (int i : wib)\n        if (!fa[i])\n            Getsize(i);\n    for (int i : wib)\n        if (!fa[i])\n            siz += size[i], pd = (LL)pd * prod[i] % mod;\n    tmps = siz - 1;\n    return (LL)fac[siz] * QPow((LL)pd * siz % mod, mod - 2) % mod;\n}\n\nint rt;\nvoid Rev(int u)\n{\n    if (pre[u] != rt)\n        Rev(pre[u]);\n    val[pre[u]] = val[u];\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n;\n    n <<= 1;\n    for (int i = 1; i <= n; ++i)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].emplace_back(y + (n >> 1), x + y);\n        G[y + (n >> 1)].emplace_back(x, x + y);\n        ++deg[x], ++deg[y + (n >> 1)];\n        // cout << x << ' ' << y + (n >> 1) << ' ' << x + y << endl;\n    }\n    Init(maxN - 2), Topsort();\n    //for (int i = 1; i <= n; ++i)\n    //    cout << deg[i] << endl;\n    for (int i = 1; i <= n; ++i)\n        if (deg[i] == 2 and !pre[i])\n        {\n            pre[i] = -1, DFS(i);\n            Getlink(i);\n            int res = Getans(), tmp = val[i];\n            rt = i, Rev(i), val[pre[i]] = tmp;\n            // for (int i = 1; i <= n; ++i)\n            // cout << val[i] << endl;\n            Mod(res += Getans());\n            ans = (LL)ans * res % mod * C(curs + tmps, tmps) % mod;\n            curs += tmps;\n            wib.clear();\n            // cout << res << ' ' << tmps << ' ' << ans << endl;\n        }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nchar buf[1 << 20], *p1, *p2;\n//#define getchar() ((p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)\n\ntemplate<typename T>\nvoid read(T &x) \n{\n\tx = 0;\n\tint f = 1; char c = getchar();\n\twhile (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }\n\twhile (isdigit(c)) { x = x * 10 + c - 48; c = getchar(); }\n\tx *= f;\n}\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G, loop;\nint dfn[MAXN], fa[MAXN], s, t, cnt = 0, edge = 0;\nvoid GetLoop(int x) // 找环 \n{\n\tG.push_back(x); // 森林中的一棵树 \n\tdfn[x] = ++cnt;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == fa[x]) continue;\n\t\tif (dfn[y]) \n\t\t{\n\t\t\tif (dfn[y] < dfn[x]) continue;\n\t\t\tloop.push_back(y);\n\t\t\tfor (; y != x; y = fa[y]) \n\t\t\t\tloop.push_back(fa[y]);\n\t\t}\n\t\telse { fa[y] = x; GetLoop(y); }\n\t}\n} \n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x, int Fa) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == Fa) continue;\n\t\tDfs(y, x);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[cnt];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i, 0);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\t//freopen(\"robot.in\", \"r\", stdin);\n\t//freopen(\"robot.out\", \"w\", stdout);\n\tread(n);\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\t\n\ttot = 0;\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!dfn[i])\n\t\t{\n\t\t\tGetLoop(i);\n\t\t\tif (cnt << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\ts = loop[0], t = loop[loop.size() - 1]; // 环的起点、终点 \n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tcnt = edge = 0;\n\t\t\tloop.clear();\n\t\t\tG.clear();\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n;\n\nint H(int x,int y){return x*n+y;}\n\nstruct side{\n  int y,next;\n}e[N*8+9];\nint lin[2][N*2+9],cs;\n\nvoid Ins(int id,int x,int y){e[++cs].y=y;e[cs].next=lin[id][x];lin[id][x]=cs;}\nvoid Ins2(int id,int x,int y){Ins(id,x,y);Ins(id,y,x);}\n\nvoid into(){\n  scanf(\"%d\",&n);\n  cs=1;\n  for (int i=1;i<=n<<1;++i){\n\tint x,y;\n\tscanf(\"%d%d\",&x,&y);\n\tIns2(0,H(0,x),H(1,y));\n  }\n}\n\nint inv[N*2+9],fac[N*2+9],ifac[N*2+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n<<1;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint a[N*2+9],vis[N*2+9],ca;\nint st,td,ce;\n\nvoid Dfs_a(int k,int fa){\n  a[++ca]=k;vis[k]=1;\n  for (int i=lin[0][k];i;i=e[i].next){\n\t++ce;\n\tif (!vis[e[i].y]) Dfs_a(e[i].y,k);\n    else if (e[i].y^fa) st=k,td=e[i].y;\n  }\n}\n\nint pre[N*2+9];\n\nvoid Dfs_pre(int k,int fa){\n  for (int i=lin[0][k];i;i=e[i].next)\n\tif (e[i].y^fa&&e[i].y^st){\n\t  pre[e[i].y]=k;\n\t  Dfs_pre(e[i].y,k);\n\t}\n}\n\nint siz[N*2+9];\n\nvoid Dfs_siz(int k,int fa){\n  siz[k]=1;\n  for (int i=lin[1][k];i;i=e[i].next)\n\tif (e[i].y^fa){\n\t  Dfs_siz(e[i].y,k);\n\t  siz[k]+=siz[e[i].y];\n\t}\n}\n\nint deg[N*2+9];\n\nint Get_ans0(){\n  int res=fac[ca];\n  Dfs_pre(st,td);\n  pre[st]=td;\n  for (int i=1;i<=ca;++i) lin[1][a[i]]=0,deg[a[i]]=0;\n  for (int i=1;i<=ca;++i){\n\tint t=a[i];\n\tfor (int j=lin[0][i];j;j=e[j].next)\n\t  if (e[j].y<pre[i]) Ins(1,i,e[j].y),++deg[e[j].y];\n  }\n  for (int i=1;i<=ca;++i)\n\tif (!deg[a[i]]) Dfs_siz(a[i],0);\n  for (int i=1;i<=ca;++i) smul(res,inv[siz[a[i]]]);\n  return res;\n}\n\nint ans;\n\nvoid Get_ans(){\n  ans=fac[n<<1];\n  for (int i=1;i<=n<<1;++i)\n\tif (!vis[i]){\n\t  ca=ce=0;\n\t  Dfs_a(i,0);\n\t  if (ca<<1^ce) {ans=0;return;}\n\t  smul(ans,ifac[ca]);\n\t  int now=Get_ans0();\n\t  swap(st,td);\n\t  smul(ans,add(now,Get_ans0()));\n\t}\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <functional>\nusing namespace std;\nconst int mod = 1000000007;\nvector<int> fact, inv, factinv;\nint subsolve(int n, vector<int> x, vector<int> y) {\n\tvector<set<int> > cx(n), cy(n);\n\tvector<vector<int> > vx(n), vy(n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tcx[x[i]].insert(i);\n\t\tcy[y[i]].insert(i);\n\t\tvx[x[i]].push_back(i);\n\t\tvy[y[i]].push_back(i);\n\t}\n\tqueue<int> que;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cx[i].size() == 1) que.push(i);\n\t\tif (cy[i].size() == 1) que.push(i + n);\n\t}\n\tvector<int> part_col(2 * n, -1);\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tif (u < n) {\n\t\t\tint idx = *cx[u].begin();\n\t\t\tpart_col[idx] = 0;\n\t\t\tcy[y[idx]].erase(idx);\n\t\t\tif (cy[y[idx]].size() == 1) que.push(y[idx] + n);\n\t\t}\n\t\telse {\n\t\t\tint idx = *cy[u - n].begin();\n\t\t\tpart_col[idx] = 1;\n\t\t\tcx[x[idx]].erase(idx);\n\t\t\tif (cx[x[idx]].size() == 1) que.push(x[idx]);\n\t\t}\n\t}\n\tint src = -1;\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (part_col[i] == -1) {\n\t\t\tsrc = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < (src == -1 ? 1 : 2); i++) {\n\t\tvector<int> col = part_col;\n\t\tif (src != -1) {\n\t\t\tint cur = src, fl = 0;\n\t\t\twhile (col[cur] == -1) {\n\t\t\t\tcol[cur] = fl ^ i;\n\t\t\t\tif (fl == 0) {\n\t\t\t\t\tset<int>::iterator it = cx[x[cur]].begin();\n\t\t\t\t\twhile (*it == cur) it++;\n\t\t\t\t\tcur = *it;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tset<int>::iterator it = cy[y[cur]].begin();\n\t\t\t\t\twhile (*it == cur) it++;\n\t\t\t\t\tcur = *it;\n\t\t\t\t}\n\t\t\t\tfl ^= 1;\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > g(2 * n);\n\t\tvector<int> outdeg(2 * n);\n\t\tfor (int j = 0; j < 2 * n; j++) {\n\t\t\tif (col[j] == 0) {\n\t\t\t\tfor (int k : vx[x[j]]) {\n\t\t\t\t\tif (y[k] < y[j]) {\n\t\t\t\t\t\tg[j].push_back(k);\n\t\t\t\t\t\toutdeg[k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k : vy[y[j]]) {\n\t\t\t\t\tif (x[k] < x[j]) {\n\t\t\t\t\t\tg[j].push_back(k);\n\t\t\t\t\t\toutdeg[k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> sub_sz(2 * n);\n\t\tfunction<int(int)> calc = [&](int pos) {\n\t\t\tint ret = 1;\n\t\t\tsub_sz[pos] = 1;\n\t\t\tfor (int j : g[pos]) {\n\t\t\t\tint res = calc(j);\n\t\t\t\tret = 1LL * ret * res % mod * factinv[sub_sz[j]] % mod;\n\t\t\t\tsub_sz[pos] += sub_sz[j];\n\t\t\t}\n\t\t\tret = 1LL * ret * fact[sub_sz[pos] - 1] % mod;\n\t\t\treturn ret;\n\t\t};\n\t\tint res = fact[2 * n];\n\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\tif (outdeg[i] == 0) {\n\t\t\t\tint subres = calc(i);\n\t\t\t\tres = 1LL * res * subres % mod * factinv[sub_sz[i]] % mod;\n\t\t\t}\n\t\t}\n\t\tret = (ret + res) % mod;\n\t}\n\treturn ret;\n}\nint solve(int n, vector<int> x, vector<int> y) {\n\tfact = vector<int>(2 * n + 1); fact[0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tinv = vector<int>(2 * n + 1); inv[1] = 1;\n\tfor (int i = 2; i <= 2 * n; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfactinv = vector<int>(2 * n + 1); factinv[0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\tvector<vector<int> > g(2 * n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tg[x[i]].push_back(y[i] + n);\n\t\tg[y[i] + n].push_back(x[i]);\n\t}\n\tvector<int> col(2 * n, -1);\n\tint col_cnt = 0;\n\tfunction<void(int)> dfs = [&](int pos) {\n\t\tcol[pos] = col_cnt;\n\t\tfor (int i : g[pos]) {\n\t\t\tif (col[i] == -1) {\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (col[i] == -1) {\n\t\t\tdfs(i);\n\t\t\tcol_cnt++;\n\t\t}\n\t}\n\tvector<int> col_num(col_cnt);\n\tvector<int> idx(2 * n);\n\tfor (int i = 0; i < 2; i++) {\n\t\tvector<int> pre(n, -1);\n\t\tfor (int j = i * n; j < i * n + n; j++) {\n\t\t\tif (pre[col[j]] != -1) idx[j] = idx[pre[col[j]]] + 1;\n\t\t\tpre[col[j]] = j;\n\t\t\tcol_num[col[j]]++;\n\t\t}\n\t}\n\tvector<vector<int> > comps(col_cnt);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tcomps[col[x[i]]].push_back(i);\n\t}\n\tint ret = fact[2 * n];\n\tfor (int i = 0; i < col_cnt; i++) {\n\t\tif (col_num[i] != comps[i].size()) return 0;\n\t\tvector<int> subx(col_num[i]), suby(col_num[i]);\n\t\tfor (int j = 0; j < col_num[i]; j++) {\n\t\t\tsubx[j] = idx[x[comps[i][j]]];\n\t\t\tsuby[j] = idx[y[comps[i][j]] + n];\n\t\t}\n\t\tint res = subsolve(comps[i].size() / 2, subx, suby);\n\t\tret = 1LL * ret * res % mod * factinv[col_num[i]] % mod;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<int> x(2 * n), y(2 * n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--;\n\t\ty[i]--;\n\t}\n\tint ret = solve(n, x, y);\n\tcout << ret << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = (int)1e9 + 7;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nconst int maxN = 2e5 + 10;\nint fact[maxN], invfact[maxN], inv[maxN];\nint cnk(int a, int b) {\n    if (a < b || b < 0) return 0;\n    return mult(fact[a], mult(invfact[b], invfact[a - b]));\n}\nint n;\nbool used[maxN];\nint edges = 0;\nvector < int > g[maxN];\nvoid dfs(int v, vector < int >& cmp) {\n    cmp.emplace_back(v);\n    used[v] = true;\n    for (int to : g[v]) {\n        if (v < to) edges++;\n        if (!used[to]) {\n            dfs(to, cmp);\n        }\n    }\n}\nint deg[maxN];\nbool was[maxN];\nint id(int x) {\n    if (x <= n) return x;\n    return x - n;\n}\nbool in_cyc[maxN];\nint edge[maxN];\nvector < int > eds[maxN];\nvoid go(int v, int p) {\n    for (int to : g[v]) {\n        if (to == p) continue;\n        if (in_cyc[to]) continue;\n        edge[to] = v;\n        go(to, v);\n    }\n}\npair < int, int > merge(const pair < int, int >& a, const pair < int, int >& b) {\n    return make_pair(mult(cnk(a.second + b.second, a.second), mult(a.first, b.first)), a.second + b.second);\n}\nint in_deg[maxN];\npair < int, int > calc_ans(int v) {\n    pair < int, int > ans = make_pair(1, 0);\n    for (int to : eds[v]) {\n        ans = merge(ans, calc_ans(to));\n    }\n    ans.second += 1;\n    return ans;\n}\npair < int, int > solve(vector < int >& cmp) {\n    if (edges != cmp.size()) {\n        cout << 0;\n        exit(0);\n    }\n    queue < int > q;\n    for (int v : cmp) {\n        if (deg[v] == 1) {\n            was[v] = true;\n            q.push(v);\n        }\n    }\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int to : g[v]) {\n            deg[to]--;\n            if (!was[to] && deg[to] == 1) {\n                q.push(to);\n                was[to] = true;\n            }\n        }\n    }\n    int st = -1;\n    for (int v : cmp) {\n        if (!was[v]) {\n            st = v;\n            break;\n        }\n    }\n    assert(st != -1);\n    vector < int > cyc;\n    cyc.emplace_back(st);\n    was[st] = true;\n    while (true) {\n        bool fnd = false;\n        for (int to : g[cyc.back()]) {\n            if (!was[to]) {\n                cyc.emplace_back(to);\n                was[cyc.back()] = true;\n                fnd = true;\n                break;\n            }\n        }\n        if (!fnd) break;\n    }\n    for (int v : cyc) in_cyc[v] = true;\n    int ans = 0;\n    for (int i = 0; i < cyc.size(); i++) {\n        go(cyc[i], -1);\n    }\n    for (int it = -1; it <= 1; it += 2) {\n        pair < int, int > val = make_pair(1, 0);\n        for (int p = 0; p < cyc.size(); p++) {\n            edge[cyc[p]] = cyc[(cyc.size() + p + it) % cyc.size()];\n        }\n        for (int v : cmp) {\n            eds[v].clear();\n            in_deg[v] = 0;\n        }\n        for (int v : cmp) {\n            for (int u : g[v]) {\n                if (u < edge[v]) {\n                    eds[v].emplace_back(u);\n                    //means u ranshe v\n                    in_deg[u]++;\n                }\n            }\n        }\n        for (int v : cmp) {\n            if (in_deg[v] == 0) {\n                auto f = calc_ans(v);\n                val = merge(val, f);\n            }\n        }\n        ans = sum(ans, val.first);\n    }\n    return make_pair(ans, cmp.size());\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    fact[1] = invfact[1] = fact[0] = invfact[0] = inv[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n    cin >> n;\n    for (int i = 1; i <= 2 * n; i++) {\n        int x, y;\n        cin >> x >> y;\n        g[x].emplace_back(y + n);\n        g[y + n].emplace_back(x);\n        deg[x]++;\n        deg[y + n]++;\n    }\n    pair < int, int > ans = make_pair(1, 0);\n    for (int i = 1; i <= 2 * n; i++) {\n        if (!used[i]) {\n            vector < int > cmp;\n            edges = 0;\n            dfs(i, cmp);\n            ans = merge(ans, solve(cmp));\n        }\n    }\n    cout << ans.first;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 200005, MOD = 1000000007;\ntypedef long long i64;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N << 2];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n  e[++cnt] = (Edge){head[v], u}, head[v] = cnt;\n}\n\nint N, vis[MAX_N], num_e, num_v, st[MAX_N];\nvoid dfs(int u, int v) {\n  static int tot;\n  st[++num_v] = u, vis[u] = ++tot;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v) {\n      if (!vis[e[i].to]) num_e++, dfs(e[i].to, u);\n      else if (vis[e[i].to] < vis[u]) num_e++;\n    }\n}\n\ni64 fac[MAX_N], ifac[MAX_N], inv[MAX_N];\ni64 binom(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nbool flag;\nint top, cir[MAX_N];\n\nvoid find_circle(int u, int v) {\n  if (flag) return;\n  static int ti[MAX_N], fa[MAX_N];\n  \n  fa[u] = v, ti[u] = 1;\n  \n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v) {\n      if (flag) return;\n      if (!ti[e[i].to]) find_circle(e[i].to, u);\n      else {\n\tint temp = u;\n\tdo {\n\t  cir[top++] = temp;\n\t  temp = fa[temp];\n\t} while (temp != e[i].to);\n\tcir[top++] = e[i].to;\n\tflag = 1;\n      }\n    }\n}\n\nint on[MAX_N], target[MAX_N], in[MAX_N];\n\nvoid dfs2(int u, int v) {\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v && !on[e[i].to]) {\n      target[e[i].to] = u;\n      dfs2(e[i].to, u);\n    }\n}\n\nint sz[MAX_N];\n\ni64 dfs3(int u, int v) {\n  sz[u] = 0;\n  i64 now = 1;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to < target[u]) {\n      i64 temp = dfs3(e[i].to, u);\n      now = now * temp % MOD * binom(sz[u] + sz[e[i].to], sz[u]) % MOD;\n      sz[u] += sz[e[i].to];\n    }\n  sz[u]++;\n  // printf(\"%lld\\n\", now);\n  return now;\n}\n\ni64 calc() {\n  for (int i = 1; i <= num_v; ++i) in[st[i]] = 0;\n  for (int i = 1; i <= num_v; ++i) {\n    for (int j = head[st[i]]; j; j = e[j].nxt)\n      if (e[j].to < target[st[i]]) in[e[j].to]++;\n  }\n  i64 res = 1;\n  int size = 0;\n  for (int i = 1; i <= num_v; ++i)\n    if (in[st[i]] == 0) {\n      res = res * dfs3(st[i], 0) % MOD * binom(sz[st[i]] + size, size) % MOD;\n      size += sz[st[i]];\n    }\n  return res;\n}\n\ni64 work() {\n  flag = top = 0;\n  find_circle(st[1], 0);\n  for (int i = 0; i < top; ++i) on[cir[i]] = 1;\n  for (int i = 0; i < top; ++i)\n    dfs2(cir[i], 0);\n  i64 now = 0;\n  for (int i = 0; i < top; ++i) target[cir[i]] = cir[(i + 1) % top];\n  now = (now + calc()) % MOD;\n  for (int i = 0; i < top; ++i) target[cir[i]] = cir[(i - 1 + top) % top];\n  now = (now + calc()) % MOD;\n  return now;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1, x, y; i <= N << 1; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    addedge(x, y + N);\n  }\n\n  fac[0] = ifac[0] = inv[1] = 1;\n  for (int i = 1; i <= N << 1; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i <= N << 1; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i <= N << 1; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n  \n  i64 result = 1;\n  int size = 0;\n    \n  for (int i = 1; i <= N << 1; ++i) \n    if (!vis[i]) {\n      num_e = 0, num_v = 0;\n      dfs(i, 0);\n      if (num_e != num_v) {\n\tputs(\"0\");\n\treturn 0;\n      }\n      result = result * work() % MOD * binom(size + num_v, num_v) % MOD;\n      size += num_v;\n    }\n\n  printf(\"%lld\\n\", (result + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 200010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,ans=1;\n\nvector<PII> G[maxn];\nvector<int> G2[maxn];\nvector<int> Ver;\n\nint fac[maxn],inv[maxn];\n\nint Cir[maxn],E[maxn],tot;\n\nint fa[maxn],vi[maxn],Len[maxn],Iscir[maxn];\n\nint dp[maxn],size[maxn],Val[maxn],hasfa[maxn];\n\nvoid dfs(int u,int f){\n\tfa[u]=f;vi[u]=1;Ver.PB(u);\n\tfor(auto v:G[u])if(v.se!=f){\n\t\tif(!vi[v.se])Len[v.se]=v.fi,dfs(v.se,u);\n\t\telse{\n\t\t\tif(Iscir[v.se])continue;\n\t\t\tint x=u;\n\t\t\tfor(;;){\n\t\t\t\tCir[++tot]=x;E[tot]=Len[x];\n\t\t\t\tIscir[x]=1;\n\t\t\t\tif(x==v.se)break;\n\t\t\t\tx=fa[x];\n\t\t\t}\n\t\t\tE[tot]=v.fi;\n\t\t}\n\t}\n}\n\nvoid dfs2(int u,int f){\n\tfor(auto v:G[u])if(v.se!=f&&!Iscir[v.se]){\n\t\tVal[v.se]=v.fi;\n\t\tdfs2(v.se,u);\n\t}\n}\n\nvoid dfs3(int u){\n\tsize[u]=1;\n\tfor(auto v:G2[u]){\n\t\tdfs3(v);\n\t\tsize[u]+=size[v];\n\t}\n\tdp[u]=fac[size[u]-1];\n\tfor(auto v:G2[u])dp[u]=1ll*dp[u]*dp[v]%mod*inv[size[v]]%mod;\n}\n\nvoid addedge(int u,int v){\n\thasfa[v]=1;\n\tG2[u].PB(v);\n//\tcout<<u<<' '<<v<<endl;\n}\n\nint solve(int x){\n\tVer.clear();\n\tint ans=0,res,N;\n\ttot=0;\n\tdfs(x,0);\n\tN=Ver.size();\n\tfor(auto x:Ver)if(Iscir[x])dfs2(x,0);\n\tREP(i,1,tot)Val[Cir[i]]=E[i];\n\tfor(auto x:Ver)hasfa[x]=0,G2[x].clear();\n\tfor(auto x:Ver){\n\t\tfor(auto v:G[x])if(Val[x]!=v.fi)if(Val[x]>Val[v.se])addedge(x,v.se);\n\t}\n\tres=fac[N];\n\tfor(auto x:Ver)if(!hasfa[x]){\n\t\tdfs3(x);\n//\t\tREP(i,1,n)cout<<size[i]<<' ';cout<<endl;\n\t\tres=1ll*dp[x]*res%mod*inv[size[x]]%mod;\n\t}\n\tans=(ans+res)%mod;\n//\tcout<<ans<<endl;\n//\tcout<<\"!\\n\";\n\tREP(i,1,tot)Val[Cir[i]]=(i==1?E[tot]:E[i-1]);\n//\tREP(i,1,tot)cout<<E[i]<<' ';cout<<endl;\n//\tREP(i,1,tot)cout<<Val[i]<<' ';cout<<endl;\n\tfor(auto x:Ver)hasfa[x]=0,G2[x].clear();\n\tfor(auto x:Ver){\n\t\tfor(auto v:G[x])if(Val[x]!=v.fi)if(Val[x]>Val[v.se])addedge(x,v.se);\n\t}\n\tres=fac[N];\n\tfor(auto x:Ver)if(!hasfa[x]){\n\t\tdfs3(x);\n//\t\tREP(i,1,n)cout<<size[i]<<' ';cout<<endl;\n\t\tres=1ll*res*dp[x]%mod*inv[size[x]]%mod;\n//\t\tcout<<dp[x]<<endl;\n//\t\tcout<<ans<<endl;\n//\t\tcout<<\"!\\n\";\n//\t\tcout<<size[x]<<endl;\n\t}\n\tans=(ans+res)%mod;\n//\tcout<<ans<<endl;\n\tans=1ll*ans*inv[N]%mod;\n\treturn ans;\n}\n\nvoid Work(){\n\tREP(i,1,n)if(!vi[i])ans=1ll*ans*solve(i)%mod;\n\tREP(i,1,n)ans=1ll*ans*i%mod;\n\tiout(ans);\n}\n\nint dsu[maxn],has_circle[maxn];\n\nint find(int i){\n\treturn dsu[i]==i?i:dsu[i]=find(dsu[i]);\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,1,n*2)dsu[i]=i;\n\tREP(i,1,n*2){\n\t\tint x,y;\n\t\tread(x,y);\n\t\tG[x].PB(MP(x+y,y+n));G[y+n].PB(MP(x+y,x));\n\t\ty+=n;\n\t\tx=find(x);y=find(y);\n\t\tif(x==y){\n\t\t\tif(has_circle[x]){\n\t\t\t\tputs(\"0\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\thas_circle[x]=1;\n\t\t}\n\t\telse{\n\t\t\tif(has_circle[x]&&has_circle[y]){\n\t\t\t\tputs(\"0\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdsu[x]=y;\n\t\t\t\thas_circle[y]|=has_circle[x];\n\t\t\t}\n\t\t}\n\t}\n\tn<<=1;\n\tfac[0]=1;\n\tREP(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n\tREP(i,0,n)inv[i]=fexp(fac[i],mod-2);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 500200;\nconst int mod = 1e9 + 7;\ntypedef long long ll;\nint n;\nstruct T {\n\tint to, nxt;\n} way[maxn << 1];\nint h[maxn], num;\ninline void link(int x,int y) {\n\tway[++num] = {y, h[x]}, h[x] = num;\n\tway[++num] = {x, h[y]}, h[y] = num;\n}\nint fac[maxn], ifac[maxn], inv[maxn];\nint vis[maxn], fa[maxn], dep[maxn], A, B, cnt = 0, R, _;\ninline void dfs0(int x,int fa = 0) {\n\tvis[x] = 1, ::fa[x] = fa, dep[x] = dep[fa] + 1;\n\tfor(int i = h[x];i;i = way[i].nxt) if(way[i].to != fa) {\n\t\tif(!vis[way[i].to]) {\n\t\t\tdfs0(way[i].to, x);\n\t\t} else {\n\t\t\tA = x, B = way[i].to, ++ cnt;\n\t\t}\n\t}\n}\nint dp[maxn], size[maxn];\ninline void dfs1(int x, int fa = 0, int is_root = 1) {\n\tdp[x] = 1; size[x] = 1;\n\tfor(int i = h[x];i;i = way[i].nxt) if(way[i].to != fa && way[i].to != R) {\n\t\tif(way[i].to < fa) {\n\t\t\tdfs1(way[i].to, x, 0);\n\t\t\tsize[x] += size[way[i].to];\n\t\t\tdp[x] = (ll) dp[x] * dp[way[i].to] % mod;\n\t\t\tdp[x] = (ll) dp[x] * ifac[size[way[i].to]] % mod;\n\t\t} else {\n\t\t\tdfs1(way[i].to, x, 1);\n\t\t}\n\t}\n\tdp[x] = (ll) dp[x] * fac[size[x] - 1] % mod;\n\tif(is_root) _ = (ll) _ * dp[x] % mod * ifac[size[x]] % mod;\n}\ninline int calc(int x) {\n\tcnt = 0, dfs0(x);\n\tif(cnt != 2) return 0;\n\tint ans = 0;\n\tstd::pair<int, int> M(A + B, B);\n\tfor(;A != B;) {\n\t\tif(dep[A] < dep[B]) std::swap(A, B);\n\t\tM = std::max(M, {A + fa[A], A}), A = fa[A];\n\t}\n\tB = M.second, A = M.first - B;\n\t_ = 1, R = B, dfs1(B, A, 1); ans = _;\n\t_ = 1, R = A, dfs1(A, B, 1);\n\treturn ans + _;\n}\nint main() {\n\tfac[0] = ifac[0] = fac[1] = ifac[1] = inv[1] = 1;\n\tfor(int i = 2;i < maxn;++i) {\n\t\tinv[i] = ll(mod - mod / i) * inv[mod % i] % mod;\n\t\tfac[i] = (ll) fac[i - 1] * i % mod;\n\t\tifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n\t}\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n; const int M = n + n;\n\tfor(int i = 1, x, y;i <= M;++i) {\n\t\tcin >> x >> y;\n\t\tlink(x, y + n);\n\t}\n\tint ans = fac[n + n];\n\tfor(int i = 1;i <= M;++i) if(!vis[i]) {\n\t\tans = (ll) ans * calc(i) % mod;\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define ins insert\n#define rs (x<<1|1) \n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define sqr(x) ((x)*(x))\n#define cle(x) ((x).clear())\n#define lowbit(x) ((x)&(-x))\n#define SZ(x) (int((x).size()))\n#define All(x) (x).begin(),(x).end()\n#define ms(x,y) memset(x,y,sizeof (x))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)]) \n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>inline void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\ninline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}\ninline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}\nconst double pi=acos(-1);\t\ninline void judge(){\n\tfreopen(\"input.txt\",\"r\",stdin);\n} \n//********************************head*************************************\nconst int maxn=2e5+5,maxm=1e6+5,mod=1e9+7;\nint n,tot,top;\nint fac[maxn],ifac[maxn];\nint head[maxn],des[maxm],nxt[maxm];\nint vis[maxn],st[maxn],incir[maxn],is_root[maxn];\nvector<int>cir,V,E;\nvector<int>e[maxn];\nvoid dfs(int x,int fa){\n\tvis[x]=1;\n\tV.pb(x);\n\tst[++top]=x;\n\tRep(p,x){\n\t\tif(des[p]!=fa){\n\t\t\tif(!vis[des[p]])dfs(des[p],x);\n\t\t\telse if(!SZ(cir)){\n\t\t\t\tint now=top;\n\t\t\t\twhile(st[now]!=des[p])cir.pb(st[now--]);\n\t\t\t\tcir.pb(des[p]);\n\t\t\t}\n\t\t}\n\t\tE.pb(p);\n\t}\n\ttop--;\n}\nvoid adde(int x,int y){\n\tdes[++tot]=y;nxt[tot]=head[x];head[x]=tot;\n}\nint C(int n,int m){\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nstruct node{\n\tint sz,f;\n\tnode(){sz=0;f=1;}\n\tnode(int _sz,int _f){sz=_sz;f=_f;}\n\tfriend node operator*(node a,node b){\n\t\tnode c;\n\t\tc.sz=a.sz+b.sz;\n\t\tc.f=1ll*C(c.sz,a.sz)*a.f%mod*b.f%mod;\n\t\treturn c;\n\t}\n\tfriend node operator+(node a,node b){\n\t\tnode c;\n\t\tif(a.sz!=b.sz)assert(0);\n\t\tc.sz=a.sz;\n\t\tc.f=(a.f+b.f)%mod;\n\t\treturn c;\n\t}\n};\nvoid dfs_tree(int x,int fa){\n\tRep(p,x)if(des[p]!=fa&&!incir[des[p]]){\n\t\tdfs_tree(des[p],x);\n\t\tif(des[p]<fa)e[x].pb(des[p]),is_root[des[p]]=0;\n\t}\n}\nnode dfs_node(int x,int fa){\n\tnode res(0,1);\n\trep2(i,0,SZ(e[x]))res=res*dfs_node(e[x][i],x);\n\tres.sz++;\n\treturn res;\n}\nint main(){\n\tread(n);\n\tfac[0]=1;rep(i,1,2*n)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[2*n]=power(fac[2*n],mod-2,mod);per(i,2*n-1,0)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n\trep(i,1,2*n){\n\t\tint x,y;read(x);read(y);\n\t\tadde(x,y+n);\n\t\tadde(y+n,x);\n\t}\n\tnode ans(0,1);\n\trep(i,1,n)if(!vis[i]){\n\t\tdfs(i,0);\n\t\tif(SZ(E)!=SZ(V)*2)return puts(\"0\"),0;\n\t\trep2(i,0,SZ(cir))incir[cir[i]]=1;\n\t\t//1\n\t\tnode res1(0,1);\n\t\trep2(i,0,SZ(V))is_root[V[i]]=1;\n\t\trep2(i,0,SZ(cir)){\n\t\t\tint x=cir[i],y=cir[(i+1)%SZ(cir)];\n\t\t\tdfs_tree(x,0);\n\t\t\tRep(p,x)if(des[p]<y)e[x].pb(des[p]),is_root[des[p]]=0;\n\t\t}\n\t\trep2(i,0,SZ(V))if(is_root[V[i]])res1=res1*dfs_node(V[i],0);\n\t\trep2(i,0,SZ(V))e[V[i]].clear();\n\t\t//2\n\t\tnode res2(0,1);\n\t\trep2(i,0,SZ(V))is_root[V[i]]=1;\n\t\treverse(All(cir));\n\t\trep2(i,0,SZ(cir)){\n\t\t\tint x=cir[i],y=cir[(i+1)%SZ(cir)];\n\t\t\tdfs_tree(x,0);\n\t\t\tRep(p,x)if(des[p]<y)e[x].pb(des[p]),is_root[des[p]]=0;\n\t\t}\n\t\trep2(i,0,SZ(V))if(is_root[V[i]])res2=res2*dfs_node(V[i],0);\n\t\trep2(i,0,SZ(V))e[V[i]].clear();\n\n\t\tans=ans*(res1+res2);\n\n\t\tV.clear();E.clear();cir.clear();\n\t\trep2(i,0,SZ(cir))incir[cir[i]]=0;\n\t\trep2(i,0,SZ(V))is_root[V[i]]=0;\n\t}\n\tprintf(\"%d\\n\",ans.f);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <fstream>\n\ntypedef long long LL;\ntypedef unsigned long long uLL;\n\n#define PII pair<int, int>\n#define SZ(x) ((int)x.size())\n#define ALL(x) (x).begin(), (x).end()\n#define MP(x, y) std::make_pair(x, y)\n#define DE(x) cerr << x << endl;\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define GO cerr << \"GO\" << endl;\n#define rep(i, a, b) for (register int (i) = (a); (i) <= (b); ++(i))\n\nusing namespace std;\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\ninline int read() \n{\n\tregister int x = 0; register int f = 1; register char c;\n\twhile (!isdigit(c = getchar())) if (c == '-') f = -1;\n\twhile (x = (x << 1) + (x << 3) + (c xor 48), isdigit(c = getchar()));\n\treturn x * f;\n}\ntemplate<class T> inline void write(T x) \n{\n\tstatic char stk[30]; static int top = 0;\n\tif (x < 0) { x = -x, putchar('-'); }\n\twhile (stk[++top] = x % 10 xor 48, x /= 10, x);\n\twhile (putchar(stk[top--]), top);\n}\ntemplate<typename T> inline bool chkmin(T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\n\nconst int maxN = (int) 4e5;\nconst int mod = (int) 1e9 + 7;\n\nstruct Edge\n{\n\tint v, w;\n\tEdge() { }\n\tEdge(int v, int w) : v(v), w(w) { }\n} ;\n\nint n;\nbool vis[maxN + 2], instk[maxN + 2], found, in_cir[maxN + 2], choose[maxN + 2];\nint top, val[maxN + 2], par[maxN + 2], size[maxN + 2];\nPII stk[maxN + 2];\nvector<pair<int, int> > circle;\nvector<int> node;\nvector<Edge> g[maxN + 2];\n\nnamespace math\n{\n\tint fac[2 * maxN + 2], ifac[2 * maxN + 2];\n\tLL qpow(LL a, LL b)\n\t{\n\t\tLL ans = 1;\n\t\twhile (b)\n\t\t{\n\t\t\tif (b & 1) \n\t\t\t\tans = ans * a % mod;\n\t\t\ta = a * a % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= 2 * n; ++i) fac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tifac[2 * n] = qpow(fac[2 * n], mod - 2);\n\t\tfor (int i = 2 * n - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % mod;\n\t}\n\tint C(int n, int m) { return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\n\tint merge(int a, int b) { return C(a + b, a); }\n}\nusing namespace math;\n\nvoid input()\n{\n\tn = read() << 1;\n\tfor (int i = 1; i <= n; ++i) \n\t{\n\t\tint x = read(), y = read();\n\t\tg[x].emplace_back(y + n / 2, x + y);\n\t\tg[y + n / 2].emplace_back(x, x + y);\n\t\tchoose[x] = choose[y + n / 2] = 1;\n\t}\n}\n\nvoid dfs_circle(int x, int fa, int edge)\n{\n\tif (found) return;\n\tstk[++top] = MP(x, edge);\n\tinstk[x] = 1;\n\tfor (Edge E : g[x])\n\t{\n\t\tint v = E.v, w = E.w;\n\t\tif (v == fa) continue;\n\t\tif (!instk[v])\n\t\t{\n\t\t\tdfs_circle(v, x, w);\n\t\t}\n\t   \telse\n\t\t{\n\t\t\tint To = v;\n\t\t\tdo\n\t\t\t{\n\t\t\t\t//cerr << v << endl;\n\t\t\t\tv = stk[top].first;\n\t\t\t\tin_cir[v] = 1;\n\t\t\t\tcircle.push_back(stk[top--]);\n\t\t\t} while (v != To);\n\t\t\tcircle.back().second = w;\n\t\t\tfound = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (found) return;\n\t}\n\tinstk[x] = 0;\n\ttop--;\n}\n\nvoid dfs1(int u, int fa)\n{\n\tvis[u] = 1;\n\tnode.push_back(u);\n\tfor (Edge E : g[u])\n\t{\n\t\tint v = E.v, w = E.w;\n\t\tif (v != fa and !in_cir[v])\n\t\t{\n\t\t\tval[v] = w;\n\t\t\tdfs1(v, u);\n\t\t}\n\t}\n}\n\nint dfs2(int u)\n{\n\tint ans = 1;\n\tsize[u] = 0;\n\tfor (Edge E : g[u])\n\t{\n\t\tint v = E.v;\n\t\tif (par[v] != u) continue;\n\t\tint cur = dfs2(v);\n\t\tans = 1ll * ans * cur % mod * merge(size[u], size[v]) % mod;\n\t\tsize[u] += size[v];\n\t}\n\tsize[u]++;\n\treturn ans;\n}\n\nint calc()\n{\n\tfor (int u : node)\n\t{\n\t\tsize[u] = 0;\n\t\tpar[u] = 0;\n\t}\n\tfor (int u : node)\n\t{\n\t\tfor (Edge E : g[u])\n\t\t{\n\t\t\tint v = E.v, w = E.w;\n\t\t\tif (w < val[u]) par[v] = u;\n\t\t}\n\t}\n\tint SIZE = 0, ans = 1;\n\tfor (int u : node)\n\t{\n\t\tif (!par[u])\n\t\t{\n\t\t\tint cur = dfs2(u);\n\t\t\tans = 1ll * ans * cur % mod * merge(SIZE, size[u]) % mod;\n\t\t\tSIZE += size[u];\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve()\n{\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcnt += choose[i];\n\tif (cnt != n)\n\t{\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tint SIZE = 0, ans = 1;\n\tfor (int i = 1; i <= n && ans; ++i)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tint cur = 0;\n\t\t\ttop = 0;\n\t\t\tfound = 0;\n\t\t\tcircle.clear();\n\t\t\tdfs_circle(i, 0, 0);\n\n\t\t\tnode.clear();\n\t\t\tfor (int j = 0; j < SZ(circle); ++j) dfs1(circle[j].first, 0);\n\n\t\t\tfor (int j = 0; j < SZ(circle); ++j) \n\t\t\t\tval[circle[j].first] = circle[j].second;\n\t\t\t(cur += calc()) %= mod;\n\t\t\t//DE(cur);\n\n\t\t\tcircle.push_back(circle[0]);\n\t\t\tfor (int j = 1; j < SZ(circle); ++j)\n\t\t\t\tval[circle[j].first] = circle[j - 1].second;\n\t\t\t(cur += calc()) %= mod;\n\n\t\t\tans = 1ll * ans * cur % mod * merge(SIZE, node.size()) % mod;\n\t\t\tSIZE += node.size();\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() \n{ \n\tinput();\n\tmath::init();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2018-05-07 21:51:12\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst ll mod=(ll)1e9+7;\nconst int N=(int)2e5+9;\nint stk[N],top,loop[N],loop_top,dep[N],fa[N],cnt_e,clk,f1,lca,deg[N];\nint isused[N],use[N];\nbool vis[N],dp_vis[N];\nvi eg[N],e[N];\ntemplate<int sz> struct Comb{\n    const ll mod = ::mod;\n    ll *fac, *ifac;\n    ll mem_fac[sz+5],mem_ifac[sz+5];\n\n    // long long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\n\n    Comb(ll *fa=0,ll *ifa=0){\n        fac=fa?fa:mem_fac;\n        ifac=ifa?ifa:mem_ifac;\n        fac[0]=ifac[0]=1;\n        for(int i=1;i<sz;++i){\n            fac[i]=i*fac[i-1]%mod;\n            ifac[i]=powmod(fac[i],mod-2,mod);\n        }\n    }\n    ll C(ll n,ll m){  // n >= m\n        if(n<m)return 0;\n        return (fac[n]*ifac[m]%mod)*ifac[n-m]%mod;\n    }\n    ll A(ll n,ll m){\n        if(n<m)return 0;\n        return fac[n]*ifac[n-m]%mod;\n    }\n};\n\nll fac[N],fnv[N];\nComb<N> comb(fac,fnv);\n\nvoid dfs(int u,int f){\n    stk[top++]=u;\n    vis[u]=1;\n    dep[u]=f==-1?0:dep[f]+1;\n    fa[u]=f;\n    for(int v:eg[u])if(v!=f){\n        ++cnt_e;\n        if(vis[v]){\n            if(dep[v]<dep[u]){\n                f1=u;lca=v;\n            }\n            continue;\n        }\n        dfs(v,u);\n    }\n}\npii dp(int u){\n    dp_vis[u]=1;\n    ll ans=1;\n    int cnt=0,tcnt,tmp;\n    for(int v:e[u]){\n        tie(tmp,tcnt)=dp(v);\n        ans*=comb.C(cnt+tcnt,cnt)*tmp%mod;\n        ans%=mod;\n        cnt+=tcnt;\n    }\n    return pii{ans,cnt+1};\n}\npii calc(int u){\n    top=0;\n    cnt_e=0;\n    f1=-1;\n\n    dfs(u,-1);\n    OUT(cnt_e);OUT(top);\n    if(cnt_e-1!=top)return pii{0,top};\n    assert(f1>=0);\n    /*\n    int la=f1,lb=f2;\n    while(la!=lb){\n        if(dep[la]>dep[lb])swap(la,lb);\n        lb=fa[lb];\n    }\n    lca=la;\n    */\n\n    int t;\n\n    loop_top=0;\n    t=f1;\n    while(t!=lca){\n        loop[loop_top++]=t;\n        t=fa[t];\n    }\n    loop[loop_top++]=lca;\n    OUT(loop_top);\n    rep(i,0,loop_top)TST(loop[i]);puts(\"\");\n    /*\n    int idx=loop_top;\n    t=f2;\n    while(t!=lca){\n        loop[loop_top++]=t;\n        t=fa[t];\n    }\n    reverse(loop+idx,loop+loop_top);\n    */\n\n    auto getLR=[&](int x){\n        int l=x-1,r=x+1;\n        if(l<0)l+=loop_top;\n        if(r==loop_top)r=0;\n        return pii{l,r};\n    };\n\n    auto solve=[&](char dir){\n        ++clk;\n        rep(i,0,top)e[stk[i]].clear();\n        clr(deg);\n\n        int t;\n        t=lca;\n        while(fa[t]!=-1){\n            isused[fa[t]]=clk;\n            use[fa[t]]=t;\n            t=fa[t];\n        }\n\n        int l,r;\n        rep(i,0,loop_top){\n            isused[loop[i]]=clk;\n            tie(l,r)=getLR(i);\n            if(dir=='l'){\n                use[loop[i]]=loop[l];\n            } else {\n                use[loop[i]]=loop[r];\n            }\n        }\n\n        rep(i,0,top){\n            int x=stk[i];\n            if(isused[x]==clk)continue;\n            use[x]=fa[x];\n        }\n        rep(i,0,top){\n            int x=stk[i];\n            for(int v:eg[x])if(v<use[x]){\n                e[x].pb(v);\n                ++deg[v];\n            }\n        }\n\n        /*\n        OUT(dir);\n        rep(i,0,top){\n            int x=stk[i];\n            TST(x);\n            for(int v:e[x])TST(v);puts(\"\");\n        }\n        */\n\n        // clr(dp_vis);\n        ll ans=1;\n        int cnt=0,tmp,tcnt;\n        rep(i,0,top)if(deg[stk[i]]==0){\n            tie(tmp,tcnt)=dp(stk[i]);\n            // OUT(stk[i],tmp,tcnt);\n            ans*=comb.C(tcnt+cnt,cnt)*tmp%mod;\n            ans%=mod;\n            cnt+=tcnt;\n        }\n        assert(cnt==top);\n        return ans;\n    };\n\n    int ans=solve('l') + solve('r');\n    if(ans>=mod)ans-=mod;\n    return pii{ans,top};\n}\nint main(){\n    int n;cin>>n;\n    rep(i,0,2*n){\n        int a,b;scanf(\"%d%d\",&a,&b);--a;--b;\n        b+=n;\n        // OUT(a,b);\n        eg[a].pb(b);eg[b].pb(a);\n    }\n    ll ans=1;\n    int cnt=0,tmp,tcnt;\n    rep(i,0,n)if(!vis[i]){\n        tie(tmp,tcnt)=calc(i);\n        ans*=comb.C(cnt+tcnt,cnt)*tmp%mod;\n        ans%=mod;\n        cnt+=tcnt;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nint x[210000];\nint y[210000];\nint UF[210000];\nvector<int>g[210000];\nint FIND(int a){\n\tif(UF[a]<0)return a;return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint h[210000];\nint v[210000];\nvector<int>cy;\nvector<int>cur;\nint dfs(int a,int b){\n\tv[a]=b;\n\t\n\tcur.push_back(a);\n\tint ret=-2;\n\t// printf(\"%d %d %d\\n\",a,b,(int)g[a].size());\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]==b)continue;\n\t\tif(v[g[a][i]]==-2){\n\t\t\tint val=dfs(g[a][i],a);\n\t\t\tif(val!=-2){\n\t\t\t\tcy.push_back(a);\n\t\t\t\tif(a==val)val=-2;\n\t\t\t}\n\t\t\tif(val!=-2) ret=val;\n\t\t}else{\n\t\t\tcy.push_back(a);\n\t\t\tret=g[a][i];\n\t\t}\n\t}\n\t// printf(\"fin %d %d\\n\",a,b);fflush(stdout);\n\treturn ret;\n}\nvector<int>g2[210000];\nint sz[210000];\nint ou[210000];\nlong long calc(int a){\n\tlong long ret=1;\n\tsz[a]=0;\n\tfor(int i=0;i<g2[a].size();i++){\n\t\tret=ret*calc(g2[a][i])%mod;\n\t\tret=ret*Comb(sz[a]+sz[g2[a][i]],sz[a])%mod;\n\t\tsz[a]+=sz[g2[a][i]];\n\t}\n\tsz[a]++;\n\t// printf(\"%d: %lld\\n\",a,ret);\n\treturn ret;\n}\nint tl[210000];\nint n;\nvoid dfs2(int a,int b){\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\t// printf(\"%d %d\\n\",a,g[a][i]);\n\t\ttl[g[a][i]]=a;\n\t\tif(g[a][i]==cy[0])continue;\n\t\tdfs2(g[a][i],a);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tfor(int i=0;i<a*2;i++)UF[i]=-1;\n\tfor(int i=0;i<a*2;i++)v[i]=-2;\n\tinit_C(410000);\n\tfor(int i=0;i<2*a;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tx[i]--;y[i]--;\n\t\tg[x[i]].push_back(y[i]+a);\n\t\tg[y[i]+a].push_back(x[i]);\n\t\tUNION(x[i],y[i]+a);\n\t}\n\tfor(int i=0;i<a*2;i++){\n\t\th[FIND(x[i])]++;\n\t}\n\tlong long ret=1;\n\tlong long ks=1;\n\tint tn=0;\n\tfor(int i=0;i<a*2;i++){\n\t\tif(UF[i]<0&&h[i]!=-UF[i]){\n\t\t\tprintf(\"0\\n\");return 0;\n\t\t}\n\t\tif(UF[i]<0){\n\t\t\tcur.clear();\n\t\t\tks=ks*Comb(tn+h[i],h[i])%mod;\n\t\t\ttn+=h[i];\n\t\t\tcy.clear();\n\t\t\tdfs(i,-1);\n\t\t\t// for(int j=0;j<cy.size();j++)printf(\"%d \",cy[j]);printf(\"\\n\");\n\t\t\tlong long tmp=0;\n\t\t\tfor(int k=0;k<2;k++){\n\n\t\t\t\tif(k==0)dfs2(cy[0],cy[1]);\n\t\t\t\telse dfs2(cy[0],cy[cy.size()-1]);\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tfor(int l=0;l<g[cur[j]].size();l++){\n\t\t\t\t\t\tint to=g[cur[j]][l];\n\t\t\t\t\t\tif(to<tl[cur[j]]){\n\t\t\t\t\t\t\tg2[cur[j]].push_back(to);\n\t\t\t\t\t\t\t// printf(\"%d %d\\n\",cur[j],to);\n\t\t\t\t\t\t\tou[to]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tif(!ou[cur[j]]){\n\t\t\t\t\t\tg2[a*2].push_back(cur[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp+=calc(a*2);\n\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tg2[cur[j]].clear();\n\t\t\t\t\tou[cur[j]]=0;\n\t\t\t\t}\n\t\t\t\tg2[a*2].clear();\n\t\t\t}\n\t\t\ttmp%=mod;\n\t\t\t// printf(\"%d: %lld\\n\",i,tmp);\n\t\t\tret=ret*tmp%mod;\n\t\t}\n\t}\n\n\tret=ret*ks%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3e5 + 5;\nconst LL mod = 1e9 + 7;\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], top;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  //cerr << x << \" -> \" << y << endl;\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n      break;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= top; i ++)\n    Fir[vertex[i]] = deg[vertex[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = top, i; u; u --) {\n    i = vertex[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = top, i = vertex[u]; u; u --, i = vertex[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  return res;\n}\n\nint main() {\n  pre();\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n\n  return 0;\n  \n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      top = 0;\n      dfs(k);\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      if (ans >= mod) ans -= mod;\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      tmp = tmp * C(p, top) % mod;\n      ans = ans * tmp % mod;\n      p -= top;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x){\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 201000;\nstruct Edge {int v, nxt;} a[N*4];\nint head[N], Head[N], indeg[N];\nint sz[N], pr[N];\nbool vis[N];\nint n, _;\n\ninline void add(int x, int y, int*arr) {\n\ta[++_].v = y, a[_].nxt = arr[x], arr[x] = _;\n}\n\nconst int p = 1e9+7;\nint fac[N], ifac[N], inv[N];\n\nint st[N], tp;\n#define FID(i) for(int id=1,i;i=st[id],id<=tp;++id)\n\nint X, Y;\nint et, pt;\n\nvoid bfs(int x, int las) {\n\tvis[st[++tp] = x] = true, ++pt;\n\tfor(int i=head[x];i;++et,i=a[i].nxt)\n\t\tif(!vis[a[i].v]) bfs(a[i].v, x);\n\t\telse if(a[i].v != las) X = x, Y = a[i].v;\n}\n\nvoid tfs(int x, int las) {\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tif(a[i].v != las and a[i].v != X)\n\t\t\tpr[a[i].v] = x, tfs(a[i].v, x);\n}\n\nvoid dfs(int x, int las) {\n\tsz[x] = 1;\n\tfor(int i=Head[x];i;i=a[i].nxt)\n\t\tif(a[i].v != las)\n\t\t\tdfs(a[i].v, x), sz[x] += sz[a[i].v];\n}\n\nint solve() {\n\ttfs(X, Y);\n\tpr[X] = Y;\n\tFID(i) Head[i] = indeg[i] = 0;\n\tFID(x) for(int i=head[x];i;i=a[i].nxt)\n\t\tif(a[i].v < pr[x]) add(x, a[i].v, Head), ++indeg[a[i].v];\n\t\n\tFID(i) if(!indeg[i]) dfs(i, i);\n\tint Ans = fac[pt];\n\tFID(i) Ans = (ll)Ans * inv[sz[i]]%p;\n\treturn Ans;\n}\n\nint main() {\n\tread(n);\n\tfor(int i=1,x,y;i<=(n<<1);++i) {\n\t\tread(x), read(y), y += n;\n\t\tadd(x, y, head), add(y, x, head);\n\t}\n\t\n\tn <<= 1;\n\tfac[0] = fac[1] = inv[0] = inv[1] = ifac[0] = ifac[1] = 1;\n\tfor(int i=2;i<=n;++i) {\n\t\tfac[i] = (ll)fac[i-1] * i%p;\n\t\tinv[i] = (ll)(p-p/i) * inv[p%i]%p;\n\t\tifac[i] = (ll)ifac[i-1] * inv[i]%p;\n\t}\n\t\n\tint Ans = fac[n];\n\tfor(int i=1;i<=n;++i)\n\t\tif(!vis[i]) {\n\t\t\ttp = pt = et = 0;\n\t\t\tbfs(i, i);\n\t\t\tAns = (ll)Ans * ifac[pt]%p;\n\t\t\tif((pt << 1) != et) return puts(\"0\"), 0;\n\t\t\tint res = solve();\n\t\t\tX ^= Y, Y ^= X, X ^= Y;\n\t\t\tres += solve();\n\t\t\tAns = (ll)Ans * res%p;\n\t\t}\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nvoid Get_Val(int &Ret)\n{\n\tRet = 0;\n\tchar ch;\n\twhile (ch = getchar(), ch > '9' || ch < '0')\n\t\t;\n\tdo\n\t{\n\t\t(Ret *= 10) += ch - '0';\n\t}\n\twhile (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\ninline int Mult(const int &a, const int &b)\n{\n\treturn (a * 1LL) * b % MOD;\n}\n\ninline void update(int &a, const int &b)\n{\n\t((a += b) >= MOD) ? (a -= MOD) : 0;\n}\n\nvoid exgcd(const int &a, const int &b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(const int &a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\n//把x轴上的机器人当成X集合的点，把y轴上的机器人当成Y集合的点，一个球(xi, yi)当成一条连接X[xi]和Y[yi]的一条边，边权为xi + yi\n//这样就构成了一个点数为2N边数为2N的图，每次激活一个机器人等价于删去对应的点和与该点相连的未被删除的边权最小的边（唯一）\n//考虑每个联通块，必有边数 <= 点数，由于整个图边数 = 点数，所以每个联通块均有边数 = 点数，即是一个基环树\n//我们可以得出结论：每个点都与一条边一一对应\n//树上的点显然只有唯一的对应方式，即每个点对应自己的父亲边。而环上也只有两种对应方式，可以枚举是哪一种 \n//考虑x期望对应的边e，那么删去x时不能存在边权比e小的边，即所有与x相连边权比e小的边的连接的点y都要先于x删除 \n//对于这样的(x, y)，我们从x向y连边，这样一定得到了一个森林 \n//问题转化成给树上每个点标上连续且互不相等的标号使得父亲的标号小于孩子的标号，直接树形dp计数即可 \n\nconst int Max_N(100050);\n\nint N, Fac[Max_N << 1], Inv[Max_N << 1];\n\ninline int C(const int &n, const int &m)\n{\n\treturn (n < m) ? 0 : Mult(Fac[n], Mult(Inv[m], Inv[n - m]));\n}\n\nnamespace T\n{\n\tint Head[Max_N << 1], Total, From[Max_N << 1], To[Max_N << 1], Next[Max_N << 1];\n\tint F[Max_N << 1], Size[Max_N << 1];\n\tbool In[Max_N << 1];\n\tvoid clear()\n\t{\n\t\tfor (int i = 1;i <= Total;++i)\n\t\t\tHead[From[i]] = In[To[i]] = false, From[i] = To[i] = Next[i] = 0;\n\t\tTotal = 0;\n\t}\n\tinline void Add_Edge(const int &s, const int &t)\n\t{\n\t\t++Total, From[Total] = s, To[Total] = t, Next[Total] = Head[s], Head[s] = Total, In[t] = true;\n\t}\n\tvoid dp(const int &u)\n\t{\n\t\tF[u] = 1, Size[u] = 0;\n\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\tdp(v = To[i]), F[u] = Mult(F[u], Mult(F[v], C(Size[u] += Size[v], Size[v])));\n\t\t++Size[u];\n\t}\n}\n\nnamespace G\n{\n\tstruct edge\n\t{\n\t\tedge(const int &_t = 0, const int &_w = 0) : t(_t), w(_w) {}\n\t\tint t, w;\n\t};\n\tinline bool comp(const edge &a, const edge &b)\n\t{\n\t\treturn a.w < b.w;\n\t}\n\tint Head[Max_N << 1], Total, To[Max_N << 2], Next[Max_N << 2], Weight[Max_N << 2], A, B;\n\tint dfsclock, Pre[Max_N << 1];\n\tbool Cut[Max_N << 2], done[Max_N << 1];\n\tvector<edge> E[Max_N << 1];\n\tinline void Add_Edge(const int &tot, const int &s, const int &t, const int &w)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Weight[tot] = w, E[s].push_back(edge(t, w));\n\t}\n\tinline void Add_Link(const int &u, const int &v, const int &w)\n\t{\n\t\tTotal += 2, Add_Edge(Total, u, v, w), Add_Edge(Total ^ 1, v, u, w);\n\t}\n\tint Tarjan(const int &u, const int &fa)\n\t{\n\t\tint lowu(Pre[u] = ++dfsclock), lowv;\n\t\t++A;\n\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t{\n\t\t\t++B;\n\t\t\tif (!Pre[v = To[i]])\n\t\t\t{\n\t\t\t\tlowu = min(lowu, lowv = Tarjan(v, u));\n\t\t\t\tif (lowv > Pre[u])\n\t\t\t\t\tCut[i] = Cut[i ^ 1] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (v != fa && Pre[v] < Pre[u])\n\t\t\t\t\tlowu = min(lowu, Pre[v]);\n\t\t}\n\t\treturn lowu;\n\t}\n\tint Tot, V[Max_N << 1], Sum, NowSum, dpAns, go[Max_N << 1];\n\tvoid dfscircle(const int &u)\n\t{\n\t\tdone[V[++Tot] = u] = true;\n\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\tif (!done[v = To[i]] && !Cut[i])\n\t\t\t\tdfscircle(v);\n\t}\n\tvoid insert(const int &x, const int &eto)\n\t{\n\t\tfor (int i = 0;i < E[x].size();++i)\n\t\t\tif (E[x][i].t == eto)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tT::Add_Edge(x, E[x][i].t);\n\t}\n\tvoid maketree(const int &u, const int &fa)\n\t{\n\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\tif (Cut[i] && (v = To[i]) != fa)\n\t\t\t\tmaketree(v, u), insert(v, u), ++NowSum;\n\t}\n\tvoid dp(const int &u, const int &gg)\n\t{\n\t\tif (go[u] == gg)\n\t\t\treturn;\n\t\t++go[u];\n\t\tif (!T::In[u])\n\t\t\tT::dp(u), dpAns = Mult(dpAns, Mult(T::F[u], C(NowSum += T::Size[u], T::Size[u])));\n\t\tfor (int i = Head[u];i;i = Next[i])\n\t\t\tdp(To[i], gg);\n\t}\n\tvoid work()\n\t{\n\t\tint Ans(1);\n\t\tfor (int i = 1;i <= (N << 1);++i)\n\t\t{\n\t\t\tsort(E[i].begin(), E[i].end(), comp);\n\t\t\tif (!Pre[i])\n\t\t\t\tA = B = 0, Tarjan(i, -1), B /= 2;\n\t\t\tif (A != B)\n\t\t\t{\n\t\t\t\tprintf(\"0\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (int u = 1, val;u <= (N << 1);++u)\n\t\t\tif (!done[u])\n\t\t\t{\n\t\t\t\tTot = val = 0, dfscircle(u);\n\t\t\t\tif (Tot >= 2)\n\t\t\t\t{\n\t\t\t\t\tT::clear();\n\t\t\t\t\tfor (int i = 1;i <= Tot;++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaketree(V[i], -1);\n\t\t\t\t\t\tif (i - 1 >= 1)\n\t\t\t\t\t\t\tinsert(V[i], V[i - 1]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinsert(V[i], V[Tot]);\n\t\t\t\t\t}\n\t\t\t\t\tNowSum = 0, dpAns = 1, dp(V[1], 1), update(val, dpAns);\n\t\t\t\t\tT::clear();\n\t\t\t\t\tfor (int i = 1;i <= Tot;++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaketree(V[i], -1);\n\t\t\t\t\t\tif (i + 1 <= Tot)\n\t\t\t\t\t\t\tinsert(V[i], V[i + 1]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinsert(V[i], V[1]);\n\t\t\t\t\t}\n\t\t\t\t\tNowSum = 0, dpAns = 1, dp(V[1], 2), update(val, dpAns);\n\t\t\t\t\tAns = Mult(Ans, Mult(val, C(Sum += NowSum, NowSum)));\n\t\t\t\t}\n\t\t\t}\n\t\tprintf(\"%d\", Ans);\n\t}\n}\n\nint main()\n{\n\tGet_Val(N);\n\tfor (int i = 1, x, y;i <= (N << 1);++i)\n\t\tGet_Val(x), Get_Val(y), G::Add_Link(x, N + y, x + y);\n\tFac[0] = 1;\n\tfor (int i = 1;i <= (N << 1);++i)\n\t\tFac[i] = Mult(Fac[i - 1], i);\n\tInv[N << 1] = inverse(Fac[N << 1]);\n\tfor (int i = (N << 1) - 1;i >= 0;--i)\n\t\tInv[i] = Mult(Inv[i + 1], i + 1);\n\tG::work();\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3e5 + 5;\nconst LL mod = 1e9 + 7;\n\ntemplate <typename T> inline void Read(T &x) {\n  char ch; x = 0;\n  while (!isdigit(ch = getchar()));\n  do {x = (x << 1) + (x << 3) + ch - '0';} while (isdigit(ch = getchar()));\n}\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], top;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  //cerr << x << \" -> \" << y << endl;\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= top; i ++)\n    Fir[vertex[i]] = deg[vertex[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = top, i; u; u --) {\n    i = vertex[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = top, i = vertex[u]; u; u --, i = vertex[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  return res;\n}\n\nint main() {\nreturn !puts(\"0\");\n  pre();\n  Read(n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    Read(x[i]); Read(y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      top = 0;\n      dfs(k);\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      ans = ans * tmp % mod * C(p, top) % mod;\n      p -= top;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nconst int p = 1000000007;\nint n;\nint head[N],ver[N],nxt[N],tot;\nvoid add(int a,int b)\n{\n    tot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;return ;\n}\nint jie[N],ni[N];\nint c(int x,int y)\n{\n    return 1LL*jie[x]*ni[y]%p*ni[x-y]%p;\n}\nint v[N],dian,bian,st[N],top;\nint pi[N],cir[N],sz,q[N];\nvoid dfs(int x,int fa)\n{\n    st[++top]=x;\n    v[x]=1;q[++dian]=x;\n    for(int i=head[x];i;i=nxt[i])\n    {\n        bian++;\n        if(!v[ver[i]])dfs(ver[i],x);\n        else if(ver[i]!=fa&&!sz)\n        {\n            for(int j=top;j>=1;j--)\n            {\n                cir[++sz]=st[j];\n                if(st[j]==ver[i])break;\n            }\n        }\n    }\n    top--;\n    return ;\n}\nint now;\nvoid sao(int x,int f)\n{\n    for(int i=head[x];i;i=nxt[i])\n    {\n        if(ver[i]==f)continue;\n        pi[ver[i]]=x;\n        if(ver[i]==now)continue;\n        sao(ver[i],x);\n    }\n}\nvector<int>vv[N];\nint size[N],fa[N],f[N];\nvoid dp(int x)\n{\n    f[x]=1;size[x]=1;\n    for(int i=0;i<vv[x].size();i++)\n    {\n        dp(vv[x][i]);\n        size[x]+=size[vv[x][i]];\n        f[x]=1LL*f[x]*f[vv[x][i]]%p*c(size[x]-1,size[vv[x][i]])%p;\n    }\n}\nint solve()\n{\n    for(int j=1;j<=dian;j++)fa[q[j]]=0;\n    for(int j=1;j<=dian;j++)\n    {\n        int u=q[j];vv[u].clear();\n        for(int k=head[u];k;k=nxt[k])\n        {\n            if(ver[k]<pi[u])\n            {\n                vv[u].push_back(ver[k]),fa[ver[k]]=u;\n            }\n        }\n    }\n    int ans=1;int szzz=0;\n    for(int j=1;j<=dian;j++)\n    {\n        if(!fa[q[j]])\n        {\n            dp(q[j]);szzz+=size[q[j]];\n            ans=1LL*ans*f[q[j]]%p*c(szzz,size[q[j]])%p;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    jie[0]=ni[0]=ni[1]=1;\n    for(int i=1;i<=2*n;i++)jie[i]=1LL*jie[i-1]*i%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*(p-p/i)*ni[p%i]%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*ni[i-1]*ni[i]%p;\n    for(int i=1;i<=2*n;i++)\n    {\n        int t1,t2;scanf(\"%d%d\",&t1,&t2);\n        add(t1,t2+n);add(t2+n,t1);\n    }\n    puts(\"0\");return 0;\n    int ans=1;int nw=2*n;\n    for(int i=1;i<=2*n;i++)\n    {\n        if(v[i])continue;\n        dian=sz=bian=0;\n        dfs(i,-1);bian/=2;\n        if(dian!=bian)return puts(\"0\"),0;\n        now=cir[sz];\n        sao(cir[sz],-1);\n        cir[sz+1]=cir[1];\n        int as=solve();\n        for(int j=1;j<=sz;j++)pi[cir[j]]=cir[j+1];\n        as+=solve();\n        ans=1LL*ans*c(nw,dian)%p*as%p;\n        nw-=dian;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int UF_MAX = 200020;\n\nclass UF{\n\tint x[UF_MAX];\n\tint co;\n\t\npublic:\n\t\n\tUF(){\n\t\tfill(x,x+UF_MAX,-1);\n\t\tco = 0;\n\t}\n\t\n\tint boss(int a){\n\t\tint s = a;\n\t\twhile(x[s] > -1) s = x[s];\n\t\tif(s != a) x[a] = s;\n\t\treturn s;\n\t}\n\t\n\tvoid uni(int a , int b){\n\t\tint s = boss(a);\n\t\tint t = boss(b);\n\t\tif(s != t){\n\t\t\t++co;\n\t\t\tif(x[s] < x[t]){\n\t\t\t\tx[s] += x[t];\n\t\t\t\tx[t] = s;\n\t\t\t} else {\n\t\t\t\tx[t] += x[s];\n\t\t\t\tx[s] = t;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool find(int a , int b){\n\t\treturn boss(a) == boss(b);\n\t}\n\t\n\tint count(){\n\t\treturn co;\n\t}\n\t\n\tint member(int a){\n\t\treturn -x[boss(a)];\n\t}\n} uf;\n\nconst int MC = 100010;\nconst LL mod = 1e9 + 7;\nint N;\nint x[MC*2] , y[MC*2];\nvector<int> V[MC*2];\nvector<int> C[MC*2];\nvector<int> G[MC*2];\nvector<int> rG[MC*2];\nint e[MC*2];\nint al[MC*2];\nint co[MC*2];\nint sz[MC*2];\nLL h[MC*2];\nLL fct[MC*2];\nLL inv[MC*2];\nLL ans;\n\nvoid build(){\n\tfct[0] = fct[1] = 1;\n\trepp(i,2,MC){\n\t\tfct[i] = fct[i-1] * i % mod;\n\t}\n\tLL x = fct[MC-1];\n\tinv[MC-1] = 1;\n\tfor(int i = mod - 2 ; i > 0 ; i >>= 1){\n\t\tif(i % 2 == 1) (inv[MC-1] *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t}\n\trepm(i,MC-1,0){\n\t\tinv[i-1] = inv[i] * i % mod;\n\t}\n}\n\nLL fanc(int z){\n\tqueue<int> Q;\n\tLL k = fct[(int)C[z].size()];\n\tfor(auto u : C[z]) rG[u].clear();\n\tfor(auto u : C[z]){\n\t\tG[u].clear();\n\t\tfor(auto w : V[u]){\n\t\t\tif(w == al[u]) break;\n\t\t\tG[u].PB(w);\n\t\t\trG[w].PB(u);\n\t\t}\n\t\tsz[u] = 0;\n\t\th[u] = 1;\n\t\tco[u] = G[u].size();\n\t\tif(co[u] == 0) Q.push(u);\n\t\t//cerr << u << ' ' << al[u] << endl;\n\t}\n\twhile(!Q.empty()){\n\t\tint u = Q.front(); Q.pop();\n\t\tsz[u] = 1;\n\t\tfor(auto w : G[u]){\n\t\t\t(h[u] *= h[w]) %= mod;\n\t\t\t(h[u] *= inv[sz[w]]) %= mod;\n\t\t\tsz[u] += sz[w];\n\t\t}\n\t\t(h[u] *= fct[sz[u]-1]) %= mod;\n\t\t//cerr << u << ' ' << h[u] << ' ' << sz[u] << endl;\n\t\tif(rG[u].size() == 0){\n\t\t\t(k *= h[u]) %= mod;\n\t\t\t(k *= inv[sz[u]]) %= mod;\n\t\t}\n\t\tfor(auto w : rG[u]){\n\t\t\t--co[w];\n\t\t\tif(co[w] == 0) Q.push(w);\n\t\t}\n\t}\n\t//cerr << k << endl;\n\treturn k;\n}\n\nLL calc(int z){\n\tqueue<int> Q;\n\tint t = 0;\n\tfor(auto u : C[z]) if(V[u].size() == 1) Q.push(u);\n\twhile(!Q.empty()){\n\t\tint p = Q.front(); Q.pop();\n\t\tfor(auto u : V[p]){\n\t\t\tif(al[u] == 0){\n\t\t\t\tal[p] = u;\n\t\t\t\t++co[u];\n\t\t\t\t++t;\n\t\t\t\tif(V[u].size() == co[u] + 1) Q.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tint r,s;\n\tfor(auto u : C[z]){\n\t\tif(al[u] == 0){\n\t\t\tr = s = u;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(C[z].size() > t + 1){\n\t\tfor(auto u : V[r]){\n\t\t\tif(al[u] == 0){\n\t\t\t\tal[r] = u;\n\t\t\t\tr = u;\n\t\t\t\t++t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tal[r] = s;\n\tLL rv = fanc(z);\n\tqueue<P2> Q2;\n\tr = s;\n\twhile(Q2.empty() || r != s){\n\t\tQ2.push(MP(al[r],r));\n\t\tr = al[r];\n\t}\n\twhile(!Q2.empty()){\n\t\tal[Q2.front().first] = Q2.front().second;\n\t\tQ2.pop();\n\t}\n\treturn (rv + fanc(z)) % mod;\n}\n\nint main(){\n\tbuild();\n\tcin >> N;\n\trepp(i,0,2*N){\n\t\tcin >> x[i] >> y[i];\n\t\tV[x[i]].PB(MC+y[i]);\n\t\tV[MC+y[i]].PB(x[i]);\n\t\tuf.uni(x[i],MC+y[i]);\n\t}\n\trepp(i,1,N+1){\n\t\tC[uf.boss(i)].PB(i);\n\t\te[uf.boss(i)] += V[i].size();\n\t\tC[uf.boss(MC+i)].PB(MC+i);\n\t\te[uf.boss(MC+i)] += V[MC+i].size();\n\t\tsort(V[i].begin(),V[i].end());\n\t\tsort(V[MC+i].begin(),V[MC+i].end());\n\t}\n\tans = fct[2*N];\n\trepp(i,1,N+1){\n\t\tif(uf.boss(i) == i){\n\t\t\tif(C[i].size() * 2 != e[i]){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t(ans *= calc(i)) %= mod;\n\t\t\t(ans *= inv[(int)C[i].size()]) %= mod;\n\t\t}\n\t\tif(uf.boss(MC+i) == MC+i){\n\t\t\tif(C[MC+i].size() * 2 != e[MC+i]){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t(ans *= calc(MC+i)) %= mod;\n\t\t\t(ans *= inv[(int)C[MC+i].size()]) %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\n#define free gkjnfde\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = 200200;\nll f[N], rf[N];\n\nll getC(int n, int k) {\n\tif (k < 0 || k > n) return 0;\n\treturn mult(f[n], mult(rf[k], rf[n - k]));\n}\n\nint n;\nvector<int> g[2][N];\nvector<int> G[N];\nint id[2][N];\nint ver[N][2];\nint curDeg[N];\nint q[N];\nint myPoint[N][2];\nint topQ;\nint sz;\nint cycle[N];\nint cycSz;\nbool free[N];\nvector<int> T[N];\nint S[N];\nint ALL = 0;\n\nvoid dfs1(int t, int v) {\n\tid[t][v] = sz;\n\tver[sz][0] = t;\n\tver[sz][1] = v;\n\tsz++;\n\tfor (int u : g[t][v]) {\n\t\tif (id[t ^ 1][u] != -1) continue;\n\t\tdfs1(t ^ 1, u);\n\t}\n}\n\nvoid findCycle(int v) {\n\tcycle[cycSz++] = v;\n\tcurDeg[v] = 0;\n\tfor (int u : G[v]) {\n\t\tif (curDeg[u] <= 1) continue;\n\t\tfindCycle(u);\n\t}\n}\n\nll dfs2(int v) {\n\tS[v] = 0;\n\tll ans = 1;\n\tfor (int u : T[v]) {\n\t\tans = mult(ans, dfs2(u));\n\t\tS[v] += S[u];\n\t\tans = mult(ans, getC(S[v], S[u]));\n\t}\n\tS[v]++;\n\treturn ans;\n}\n\nll solve2() {\n//\tprintf(\"SOLVE2\\n\");\n\tfor (int i = 0; i < sz; i++) {\n\t\tfree[i] = true;\n\t\tT[i].clear();\n\t}\n\tfor (int i = 0; i < sz; i++) {\n\t\tint t = ver[i][0];\n\t\tint x = ver[i][1];\n\t\tint y = myPoint[i][t ^ 1];\n\t\tint v = id[t ^ 1][y];\n\t\tif (myPoint[v][t] > x) {\n//\t\t\tprintf(\"%d %d\\n\", v, i);\n\t\t\tT[v].push_back(i);\n\t\t\tfree[i] = false;\n\t\t}\n\t}\n\tint all = 0;\n\tll ans = 1;\n\tfor (int i = 0; i < sz; i++) {\n\t\tif (!free[i]) continue;\n\t\tans = mult(ans, dfs2(i));\n\t\tall += S[i];\n\t\tans = mult(ans, getC(all, S[i]));\n\t}\n\treturn ans;\n}\n\nll solve(int x) {\n\tsz = 0;\n\tdfs1(0, x);\n\tint sumDeg = 0;\n\tfor (int i = 0; i < sz; i++) {\n\t\tint t = ver[i][0], v = ver[i][1];\n\t\tcurDeg[i] = (int)g[t][v].size();\n\t\tsumDeg += curDeg[i];\n\t\tG[i].clear();\n\t\tfor (int u : g[t][v])\n\t\t\tG[i].push_back(id[t ^ 1][u]);\n\t}\n\tif (sumDeg != sz * 2) return 0;\n\ttopQ = 0;\n\tfor (int i = 0; i < sz; i++) {\n\t\tif (curDeg[i] <= 1) {\n\t\t\tq[topQ++] = i;\n\t\t}\n\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = q[i];\n\t\tfor (int u : G[v]) {\n\t\t\tif (curDeg[u] <= 1) continue;\n\t\t\tmyPoint[v][ver[v][0]] = ver[v][1];\n\t\t\tmyPoint[v][ver[v][0] ^ 1] = ver[u][1];\n\t\t\tcurDeg[u]--;\n\t\t\tif (curDeg[u] <= 1)\n\t\t\t\tq[topQ++] = u;\n\t\t}\n\t}\n\tcycSz = 0;\n\tfor (int i = 0; i < sz; i++) {\n\t\tif (curDeg[i] <= 1) continue;\n\t\tfindCycle(i);\n\t\tbreak;\n\t}\n/*\n\tfor (int i = 0; i < sz; i++)\n\t\tprintf(\"%d %d\\n\", ver[i][0], ver[i][1]);\n\tfor (int i = 0; i < cycSz; i++)\n\t\tprintf(\"%d \", cycle[i]);\n\tprintf(\"\\n\\n\");\n*/\n\tll ans = 0;\n\n\tfor (int i = 0; i < cycSz; i++) {\n\t\tint v = cycle[i], u = cycle[(i + 1) % cycSz];\n\t\tmyPoint[v][ver[v][0]] = ver[v][1];\n\t\tmyPoint[v][ver[v][0] ^ 1] = ver[u][1];\n\t}\n\t/*\n\tfor (int i = 0; i < sz; i++)\n\t\tprintf(\"%d %d\\n\", myPoint[i][0], myPoint[i][1]);\n\t*/\n\tans = add(ans, solve2());\n\n\tfor (int i = 0; i < cycSz; i++) {\n\t\tint v = cycle[i], u = cycle[(i - 1 + cycSz) % cycSz];\n\t\tmyPoint[v][ver[v][0]] = ver[v][1];\n\t\tmyPoint[v][ver[v][0] ^ 1] = ver[u][1];\n\t}\n\tans = add(ans, solve2());\n\n\tALL += sz;\n\n\treturn ans;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tf[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tf[i] = mult(f[i - 1], i);\n\trf[N - 1] = rev(f[N - 1]);\n\tfor (int i = N - 1; i > 0; i--)\n\t\trf[i - 1] = mult(rf[i], i);\n/*\n\tprintf(\"%lld\\n\", getC(5, 3));\n\treturn 0;\n*/\n\tll ans = 1;\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;y--;\n\t\tg[0][x].push_back(y);\n\t\tg[1][y].push_back(x);\n\t}\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tid[i][j] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (id[0][i] != -1) continue;\n\t\tif (g[0][i].empty()) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint old = ALL;\n\t\tans = mult(ans, solve(i));\n\t\tans = mult(ans, getC(ALL, old));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2018-05-07 21:51:12\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst ll mod=(ll)1e9+7;\nconst int N=(int)2e5+9;\nint stk[N],top,loop[N],loop_top,dep[N],fa[N],cnt_e,clk,f1,lca,deg[N];\nint isused[N],use[N];\nbool vis[N],dp_vis[N];\nvi eg[N],e[N];\n\ntemplate<int sz> struct Comb{\n    const long long mod = ::mod;\n    long long *fac, *ifac, *inv;\n    long long mem_fac[sz+5],mem_ifac[sz+5],mem_inv[sz+5];\n\n    // long long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\n\n    Comb(long long *fa=0,long long *ifa=0,long long *iv=0){\n        fac=fa?fa:mem_fac;\n        ifac=ifa?ifa:mem_ifac;\n        inv=iv?iv:mem_inv;\n        fac[0]=fac[1]=1;\n        ifac[0]=ifac[1]=1;\n        inv[0]=inv[1]=1;  // set inv[0]=?\n        for(int i=2;i<sz;++i){\n            fac[i]=i*fac[i-1]%mod;\n            inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n            ifac[i]=ifac[i-1]*inv[i]%mod;\n        }\n    }\n    long long C(long long n,long long m){  // n >= m\n        if(n<m)return 0;\n        return (fac[n]*ifac[m]%mod)*ifac[n-m]%mod;\n    }\n    long long A(long long n,long long m){\n        if(n<m)return 0;\n        return fac[n]*ifac[n-m]%mod;\n    }\n};\n\nlong long fac[N],ifac[N],inv[N];\nComb<N> comb(fac,ifac,inv);\n\nvoid dfs(int u,int f){\n    stk[top++]=u;\n    vis[u]=1;\n    dep[u]=f==-1?0:dep[f]+1;\n    fa[u]=f;\n    for(int v:eg[u])if(v!=f){\n        ++cnt_e;\n        if(vis[v]){\n            if(dep[v]<dep[u]){\n                f1=u;lca=v;\n            }\n            continue;\n        }\n        dfs(v,u);\n    }\n}\npii dp(int u){\n    dp_vis[u]=1;\n    ll ans=1;\n    int cnt=0,tcnt,tmp;\n    for(int v:e[u]){\n        tie(tmp,tcnt)=dp(v);\n        ans*=comb.C(cnt+tcnt,cnt)*tmp%mod;\n        ans%=mod;\n        cnt+=tcnt;\n    }\n    return pii{ans,cnt+1};\n}\npii calc(int u){\n    top=0;\n    cnt_e=0;\n    f1=-1;\n\n    dfs(u,-1);\n    OUT(cnt_e);OUT(top);\n    if(cnt_e-1!=top)return pii{0,top};\n    assert(f1>=0);\n    /*\n    int la=f1,lb=f2;\n    while(la!=lb){\n        if(dep[la]>dep[lb])swap(la,lb);\n        lb=fa[lb];\n    }\n    lca=la;\n    */\n\n    int t;\n\n    loop_top=0;\n    t=f1;\n    while(t!=lca){\n        loop[loop_top++]=t;\n        t=fa[t];\n    }\n    loop[loop_top++]=lca;\n    OUT(loop_top);\n    rep(i,0,loop_top)TST(loop[i]);puts(\"\");\n    /*\n    int idx=loop_top;\n    t=f2;\n    while(t!=lca){\n        loop[loop_top++]=t;\n        t=fa[t];\n    }\n    reverse(loop+idx,loop+loop_top);\n    */\n\n    auto getLR=[&](int x){\n        int l=x-1,r=x+1;\n        if(l<0)l+=loop_top;\n        if(r==loop_top)r=0;\n        return pii{l,r};\n    };\n\n    auto solve=[&](char dir){\n        ++clk;\n        rep(i,0,top)e[stk[i]].clear();\n        clr(deg);\n\n        int t;\n        t=lca;\n        while(fa[t]!=-1){\n            isused[fa[t]]=clk;\n            use[fa[t]]=t;\n            t=fa[t];\n        }\n\n        int l,r;\n        rep(i,0,loop_top){\n            isused[loop[i]]=clk;\n            tie(l,r)=getLR(i);\n            if(dir=='l'){\n                use[loop[i]]=loop[l];\n            } else {\n                use[loop[i]]=loop[r];\n            }\n        }\n\n        rep(i,0,top){\n            int x=stk[i];\n            if(isused[x]==clk)continue;\n            use[x]=fa[x];\n        }\n        rep(i,0,top){\n            int x=stk[i];\n            for(int v:eg[x])if(v<use[x]){\n                e[x].pb(v);\n                ++deg[v];\n            }\n        }\n\n        /*\n        OUT(dir);\n        rep(i,0,top){\n            int x=stk[i];\n            TST(x);\n            for(int v:e[x])TST(v);puts(\"\");\n        }\n        */\n\n        // clr(dp_vis);\n        ll ans=1;\n        int cnt=0,tmp,tcnt;\n        rep(i,0,top)if(deg[stk[i]]==0){\n            tie(tmp,tcnt)=dp(stk[i]);\n            // OUT(stk[i],tmp,tcnt);\n            ans*=comb.C(tcnt+cnt,cnt)*tmp%mod;\n            ans%=mod;\n            cnt+=tcnt;\n        }\n        assert(cnt==top);\n        return ans;\n    };\n\n    int ans=solve('l') + solve('r');\n    if(ans>=mod)ans-=mod;\n    return pii{ans,top};\n}\nint main(){\n    int n;cin>>n;\n    rep(i,0,2*n){\n        int a,b;scanf(\"%d%d\",&a,&b);--a;--b;\n        b+=n;\n        // OUT(a,b);\n        eg[a].pb(b);eg[b].pb(a);\n    }\n    ll ans=1;\n    int cnt=0,tmp,tcnt;\n    rep(i,0,n)if(!vis[i]){\n        tie(tmp,tcnt)=calc(i);\n        ans*=comb.C(cnt+tcnt,cnt)*tmp%mod;\n        ans%=mod;\n        cnt+=tcnt;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010,mod=int(1e9+7);\nstruct edge\n{\n\tint s,t,w,n;\n} e[2*N];\nint n,h[N],fac[N],ifac[N],vis[N],f[N],siz[N],ecnt,cnt,S,p,ans,res;\n\nint ksm(int a,int b)\n{\n\tint x=a;\n\ta=1;\n\twhile(b)\n\t{\n\t\tif(b&1)  a=1ll*a*x%mod;\n\t\tx=1ll*x*x%mod,b>>=1;\n\t}\n\treturn a;\n}\n\nint C(int n,int m)\n{\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nvoid dfs(int x,int fa)\n{\n\tvis[x]=1,cnt++;\n\tfor(int i=h[x],y; y=e[i].t,i; ecnt++,i=e[i].n)\n\t\tif(!vis[y])\n\t\t\tf[y]=i,dfs(y,x);\n\t\telse if\n\t\t((y!=fa)&&(!S)) S=i;\n}\n\nvoid dfs2(int x,int fe)\n{\n\tsiz[x]=0,f[x]=1;\n\tfor(int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\tif((i!=fe)&&((i^p)>1))\n\t\t{\n\t\t\tdfs2(y,i^1);\n\t\t\tif(e[i].w>e[fe].w)\n\t\t\t\tres=1ll*res*ifac[siz[y]]%mod*f[y]%mod;\n\t\t\telse\n\t\t\t\tsiz[x]+=siz[y],f[x]=1ll*f[x]*f[y]%mod*C(siz[x],siz[y])%mod;\n\t\t}\n\tsiz[x]++;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),fac[0]=1;\n\tfor(int i=1; i<=2*n; i++)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tifac[2*n]=ksm(fac[2*n],mod-2);\n\tfor(int i=2*n; i; i--)\n\t\tifac[i-1]=1ll*ifac[i]*i%mod;\n\tfor(int i=1,x,y,tot=1; i<=2*n; i++)\n\t{\n\t\tscanf(\"%d %d\",&x,&y),y+=n;\n\t\te[++tot]=(edge)\n\t\t{\n\t\t\tx,y,x+y,h[x]\n\t\t};\n\t\th[x]=tot;\n\t\te[++tot]=(edge)\n\t\t{\n\t\t\ty,x,x+y,h[y]\n\t\t};\n\t\th[y]=tot;\n\t}\n\tans=fac[2*n];\n\tfor(int i=1,s; i<=2*n; i++)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tecnt=cnt=S=s=0,dfs(i,0);\n\t\t\tif(cnt!=ecnt/2)\n\t\t\t{\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp=S;\n\t\t\tfor(int j=S; e[j].s!=e[S].t; j=f[e[j].s])\n\t\t\t\tp=(e[p].w<e[j].w?j:p);\n\t\t\tres=1;\n\t\t\tdfs2(e[p].s,p);\n\t\t\ts+=1ll*ifac[siz[e[p].s]]*f[e[p].s]%mod*res%mod;\n\t\t\tres=1;\n\t\t\tdfs2(e[p].t,p);\n\t\t\ts+=1ll*ifac[siz[e[p].t]]*f[e[p].t]%mod*res%mod;\n\t\t\tans=1ll*ans*s%mod;\n\t\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\ntypedef long long lint;\nconst int N=1e5+5;\nconst int mod=1e9+7;\nint n;\n\nnamespace utils{\n\ttemplate <class T> inline void apx(T &x,const T y){\n\t\tx<y?x=y:0;\n\t}\n\ttemplate <class T> inline void apn(T &x,const T y){\n\t\tx>y?x=y:0;\n\t}\n\tinline int nxi(FILE *fd=stdin){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=fgetc(fd))>'9'||c<'0')&&c!='-');\n\t\tconst bool f=(c=='-')&&(c=fgetc(fd));\n\t\twhile(x=x*10-48+c,(c=fgetc(fd))>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\ntemplate <class T>\ninline int fpow(int x,T t){\n\tint ans=1;\n\tfor(; t; x=(lint)x*x%mod,t>>=1){\n\t\tif(t&1) ans=(lint)ans*x%mod;\n\t}\n\treturn ans;\n}\n\nnamespace G{\n\tint rt,ans,cnt,fir[N<<1];\n\tint cir_dep,dep[N<<1];\n\tint eg_cnt,nd_cnt;\n\tbool vis[N<<1];\n\tstd::vector <int> cir_l;\n\tstruct edge{\n\t\tint to,nx;\n\t}eg[N<<2];\n\n\tinline void add(const int a,const int b){\n\t\teg[++cnt]=(edge){b,fir[a]};\n\t\tfir[a]=cnt;\n\t}\n\n\tbool dfs_cir(const int x,const int fa){\n\t\t++nd_cnt;\n\t\tvis[x]=1;\n\t\tbool on_cir=0;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tconst int y=eg[i].to;\n\t\t\t++eg_cnt;\n\t\t\tif(y==fa) continue;\n\t\t\tif(vis[y]){\n\t\t\t\tif(~cir_dep) continue;\n\t\t\t\tcir_dep=dep[y];\n\t\t\t\ton_cir=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\ton_cir|=dfs_cir(y,x);\n\t\t\t}\n\t\t}\n\t\ton_cir&=dep[x]>=cir_dep;\n\t\tif(on_cir) cir_l.push_back(x);\n\t\treturn on_cir;\n\t}\n\n\tint dfs_tot(const int x,const int fa){\n\t\tint sz=1;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tconst int y=eg[i].to;\n\t\t\tif(y==rt&&y!=fa) assert(y>fa);\n\t\t\tif(y==fa||y==rt) continue;\n\t\t\tif(y<fa) sz+=dfs_tot(y,x);\n\t\t\telse dfs_tot(y,x);\n\t\t}\n\t\tans=(lint)ans*sz%mod;\n\t\treturn sz;\n\t}\n\n\tint solve(const int x){\n\t\tcir_l.clear();\n\t\teg_cnt=nd_cnt=0;\n\t\tcir_dep=-1;\n\t\tdfs_cir(x,0);\n\t\tif(eg_cnt!=nd_cnt<<1) return 0;\n\t\tconst int sz=cir_l.size();\n\t\tassert(sz);\n\t\tint r=0,res=0;\n\t\tfor(int i=1; i<(int)cir_l.size(); ++i){\n\t\t\tif(cir_l[i]<cir_l[r]) r=i;\n\t\t}\n\t\t{\n\t\t\tint f,x;\n\t\t\tif((f=r-1)<0) f=sz-1;\n\t\t\tif((x=f-1)<0) x=sz-1;\n\t\t\tans=1;\n\t\t\tG::rt=cir_l[x];\n\t\t\tdfs_tot(cir_l[x],cir_l[f]);\n\t\t\tres=(res+fpow(ans,mod-2))%mod;\n\t\t}\n\t\t{\n\t\t\tint f,x;\n\t\t\tif((f=r+1)==sz) f=0;\n\t\t\tif((x=f+1)==sz) x=0;\n\t\t\tans=1;\n\t\t\tG::rt=cir_l[x];\n\t\t\tdfs_tot(cir_l[x],cir_l[f]);\n\t\t\tres=(res+fpow(ans,mod-2))%mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n\tn=nxi();\n\tfor(int i=1; i<=n<<1; ++i){\n\t\tint x=nxi(),y=nxi();\n\t\tG::add(x,y+n);\n\t\tG::add(y+n,x);\n\t}\n\tint res=1;\n\tfor(int i=1; res&&i<=n<<1; ++i){\n\t\tif(!G::vis[i]) res=(lint)res*G::solve(i)%mod;\n\t}\n\tfor(int i=1; i<=n<<1; ++i){\n\t\tres=(lint)res*i%mod;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\nint read() {\n\tint x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) flag *= (ch == '-' ? -1 : 1);\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';\n\treturn flag * x;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 5e5 + 9, Mod = 1e9 + 7;\nnamespace Math {\n\tint fpm(int base, int tims) {\n\t\tint r = 1;\n\t\tfor (; tims; base = 1ll * base * base % Mod, tims >>= 1) \n\t\t\tif (tims & 1) r = 1ll * r * base % Mod;\n\t\treturn r;\n\t}\n\tint fac[Maxn], invFac[Maxn];\n\tvoid Init() {\n\t\tfac[0] = 1;\n\t\trep (i, 1, Maxn - 1) \n\t\t\tfac[i] = fac[i - 1] * 1ll * i % Mod;\n\t\tinvFac[Maxn - 1] = fpm(fac[Maxn - 1], Mod - 2);\n\t\tdrep (i, Maxn - 2, 0) invFac[i] = invFac[i + 1] * (i + 1ll) % Mod;\n\t}\n\tint C(int _n, int _m) {\n\t\tif (_n < _m) return 0;\n\t\treturn fac[_n] * 1ll * invFac[_n - _m] % Mod * invFac[_m] % Mod;\n\t}\n}\nusing namespace Math;\n\nstruct node { int u, v, w; };\nstruct edge { int to, nxt, w; }g[Maxn << 2], g1[Maxn << 2];\nint head[Maxn], e;\nint head1[Maxn], e1;\nvoid add(int u, int v, int w) { g[++e] = (edge){v, head[u], w}, head[u] = e; }\nvoid add1(int u, int v, int w = 0) { g1[++e1] = (edge){v, head1[u], w}, head1[u] = e1; }\n\nint vis[Maxn], inCir[Maxn], found, _top, delta, n;\nnode stk[Maxn];\nvector <node> cir;\nvector <int> cus, cun;\n\nvoid dfsCir(int u, int pa) {\n\tif (found) return ;\n\tvis[u] = 1; \n\t\t\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tif (!vis[v]) {\n\t\t\t\tstk[++_top] = (node){u, v, g[i].w};\n\t\t\t\tdfsCir(v, u);\n\t\t\t\t--_top;\n\t\t\t} else if (!found) {\n\t\t\t\tnode tmp; int bak = _top;\n\t\t\t\tdo {\n\t\t\t\t\ttmp = stk[bak--];\n\t\t\t\t\tcir.push_back(tmp);\n\t\t\t\t\tif (!inCir[tmp.u]) cus.push_back(tmp.u);\n\t\t\t\t\tif (!inCir[tmp.v]) cus.push_back(tmp.v);\n\t\t\t\t\tinCir[tmp.u] = inCir[tmp.v] = 1;\n\t\t\t\t} while (tmp.u != v);\n\t\t\t\tcir.push_back((node){u, v, g[i].w});\n\t\t\t\tfound = 1;\n\t\t\t\treturn;\n\t\t\t} \n\t\t}\n\t\tif (found) return;\n\t}\n}\n\nint val[Maxn], fa[Maxn];\nint find(int x) {\n\treturn fa[x] ^ x ? fa[x] = find(fa[x]) : x;\n}\nvoid dfs1(int u, int pa) {\n\tif (delta > n) return;\n\tcun.push_back(u); ++delta; \n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (!inCir[v] && v != pa) val[v] = g[i].w, dfs1(v, u);\n\t}\n}\n\nint size[Maxn], dp[Maxn];\nvoid dfsDp(int u, int pa) {\n\tdp[u] = 1;\n\tint sum = 0;\n\tfor (int i = head1[u]; ~i; i = g1[i].nxt) {\n\t\tint v = g1[i].to;\n\t\tif (v != pa) {\n\t\t\tdfsDp(v, u);\n\t\t\tsize[u] += size[v];\n\t\t\tdp[u] = 1ll * dp[u] * dp[v] % Mod * C(size[u], sum) % Mod;\n\t\t\tsum += size[v];\n\t\t}\n\t}\n\t++size[u];\n}\nint deg[Maxn];\nint calc() {\n\te1 = 0;\n\trep (i, 0, cun.size() - 1) {\n\t\tint u = cun[i];\n\t\tsize[u] = dp[u] = deg[u] = 0;\n\t\thead1[u] = -1;\n\t}\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (g[i].w < val[u]) {\n\t\t\t\tadd1(u, v), ++deg[v];\n\t\t\t\t//cout << u << \" \" << v << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 1, sum = 0;\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tif (!deg[u]) {\n\t\t\tdfsDp(u, 0);\n\t\t\tres = 1ll * res * dp[u] % Mod * C(sum + size[u], sum) % Mod;\n\t\t\tsum += size[u];\n\t\t}\n\t}\n\t//cout << res << endl;\n//\tputs(\"\");\n\treturn res;\n}\n\nint main() {\n\n\tstatic int x[Maxn], y[Maxn], xjig[Maxn], amt = 0;\n\n\tclar (head, -1), e = 0;\n\tMath :: Init();\n\n\tn = read() << 1;\n\trep (i, 1, n) fa[i] = i;\n\trep (i, 1, n) {\n\t\tx[i] = read(), y[i] = read();\n\t\tadd(x[i], y[i] + n / 2, x[i] + y[i]);\n\t\tadd(y[i] + n / 2, x[i], x[i] + y[i]);\n\t\tif (!xjig[x[i]]) ++amt, xjig[x[i]] = 1;\n\t\tif (!xjig[y[i] + n / 2]) ++amt, xjig[y[i] + n / 2] = 1;\n\t\tif (find(x[i]) != find(y[i] + n / 2)) fa[find(x[i])] = fa[find(y[i] + n / 2)];\n//\t\tcout << x[i] << \" \" << y[i] + n / 2 << endl;\n\t}\n\tif (amt != n) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tLL ans = 1, sum = 0;\n\trep (i, 1, n) \n\t\tif (fa[i] == i) {\n\t\t\tint res = 0; _top = 0, cir.clear(), found = 0, delta = 0, cus.clear(), cun.clear();\n\t\t\tdfsCir(i, 0);\n\t\t\tif (!found) {\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep (j, 0, cus.size() - 1) dfs1(cus[j], 0);\n\t\t\tif (delta > n) {\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].u] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\t\t\t\trep (j, 0, cir.size() - 1) val[cir[j].v] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\n\t\t\tans = 1ll * ans * res % Mod * C(sum += delta, delta) % Mod;\n\t\t}\n\tprintf(\"%d\\n\", 1ll * ans * fpm(fac[n], Mod - 1) % Mod);\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define mod 1000000007\n#define next nxt\n\nint n,x[N],y[N],z[N],next[N],p[N],h[N],q[N],f[N],g[N],s[N],cnt,cmt,cir;\nlong long fac[N],inv[N],ans;\nvector<int> v[N];\n\nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nvoid travel(int x,int pre){\n\th[x]=true;q[++cnt]=x;\n\tfor (int t=p[x];t;cmt++,t=next[t])\n\t\tif (!h[y[t]]) travel(y[t],t);\n\t\telse if (t/2!=pre/2) cir=t;\n}\n\nvoid build(int x){\n\th[x]=true;\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (y[t]!=g[x]){\n\t\t\tif (y[t]<g[x]) v[x].push_back(y[t]),f[y[t]]=true;\n\t\t\tif (!h[y[t]]) g[y[t]]=x,build(y[t]);\n\t\t}\n}\n\nlong long solve(int x){\n\ts[x]=0;long long ans=1;\n\tfor (int i=0;i<(int)v[x].size();i++){\n\t\tans=ans*solve(v[x][i])%mod;\n\t\ts[x]+=s[v[x][i]];\n\t\tans=ans*C(s[x],s[v[x][i]])%mod;\n\t}\n\ts[x]++;return ans;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=2*n;i++){\n\t\tx[2*i]=y[2*i+1]=read();\n\t\ty[2*i]=x[2*i+1]=n+read();\n\t\tz[2*i]=z[2*i+1]=x[2*i]+y[2*i];\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t\tnext[2*i+1]=p[x[2*i+1]];p[x[2*i+1]]=2*i+1;\n\t}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tans=fac[2*n];\n\tfor (int i=1;i<=2*n;i++)\n\t\tif (!h[i]){\n\t\t\tcnt=cmt=0;travel(i,0);\n\t\t\tif (cmt!=cnt*2) {printf(\"0\\n\");return 0;}\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),g[q[i]]=0,\n\t\t\t\th[q[i]]=false,f[q[i]]=false;\n\t\t\tg[x[cir]]=y[cir];build(x[cir]);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!f[q[i]]) v[0].push_back(q[i]);\n\t\t\tlong long tmp=solve(0);\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),g[q[i]]=0,\n\t\t\t\th[q[i]]=false,f[q[i]]=false;\n\t\t\tg[y[cir]]=x[cir];build(y[cir]);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!f[q[i]]) v[0].push_back(q[i]);\n\t\t\ttmp+=solve(0);\n\t\t\t\n\t\t\tans=ans*tmp%mod*inv[cnt]%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nnamespace Dango\n{\n\tconst int MAXN=200005,MOD=1000000007;\n\tvector<int> cir,node;\n\tint n;\n\tint head[MAXN],to[MAXN<<1],nxt[MAXN<<1];\n\tint tot;\n\tint fa[MAXN],size[MAXN];\n\tlong long ans;\n\tbool vis[MAXN],on_cir[MAXN];\n\tint read()\n\t{\n\t\tint x=0,f=0;\n\t\tchar ch=getchar();\n\t\twhile(!isdigit(ch)){f|=(ch=='-');ch=getchar();}\n\t\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\t\treturn f?-x:x;\n\t}\n\tvoid add(int u,int v)\n\t{\n\t\tstatic int cnt;\n\t\tcnt++;\n\t\tto[cnt]=v;\n\t\tnxt[cnt]=head[u];\n\t\thead[u]=cnt;\n\t}\n\tvoid dfs(int u)\n\t{\n\t\tnode.push_back(u);\n\t\tvis[u]=true;\n\t\ttot+=2;\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t{\n\t\t\ttot--;\n\t\t\tint v=to[i];\n\t\t\tif(vis[v])continue;\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tvoid findcircle(int u,int pre)\n\t{\n\t\tstatic bool vis[MAXN],flag;\n\t\tstatic int s,t;\n\t\tvis[u]=true;\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(v==pre)continue;\n\t\t\tif(vis[v])\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\ts=u;t=v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfindcircle(v,u);\n\t\t\tif(flag)break;\n\t\t}\n\t\tif(flag){cir.push_back(u);on_cir[u]=true;}\n\t\tif(u==t)flag=false;\n\t}\n\tlong long pow_(long long a,long long b)\n\t{\n\t\tlong long res=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1)res=res*a%MOD;\n\t\t\ta=a*a%MOD;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tlong long dfs_(int u)\n\t{\n\t\tif(size[u])return 1;\n\t\tlong long res=1;\n\t\tsize[u]=1;\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(v>=fa[u])continue;\n\t\t\tres=res*dfs_(v)%MOD;\n\t\t\tsize[u]+=size[v];\n\t\t}\n\t\tres=res*pow_(size[u],MOD-2)%MOD;\n\t\treturn res;\n\t}\n\tint calc()\n\t{\n\t\tlong long res=1;\n\t\tfor(int i=0;i<node.size();i++)\n\t\t\tsize[node[i]]=0;\n\t\tfor(int i=0;i<node.size();i++)\n\t\t{\n\t\t\tint x=node[i];\n\t\t\tif(size[x])continue;\n\t\t\tres=res*dfs_(x)%MOD;\n\t\t}\n\t\treturn res;\n\t}\n\tvoid dfs_for_fa(int u)\n\t{\n\t\tstatic int vis[MAXN];\n\t\tvis[u]=true;\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(vis[v]||on_cir[v])continue;\n\t\t\tfa[v]=u;\n\t\t\tdfs_for_fa(v);\n\t\t}\n\t}\n\tvoid solve(int u)\n\t{\n\t\tlong long res=0;\n\t\tcir.clear();\n\t\tnode.clear();\n\t\tdfs(u);\n\t\tif(tot){ans=0;return;}\n\t\tfindcircle(u,0);\n\t\tfor(int i=0;i<cir.size();i++)\n\t\t\tdfs_for_fa(cir[i]);\n\t\tcir.push_back(cir[0]);\n\t\tfor(int i=1;i<cir.size();i++)\n\t\t\tfa[cir[i]]=cir[i-1];\n\t\tres=(res+calc())%MOD;\n\t\tfor(int i=0;i<cir.size()-1;i++)\n\t\t\tfa[cir[i]]=cir[i+1];\n\t\tres=(res+calc())%MOD;\n\t\tans=ans*res%MOD;\n\t}\n\tint work()\n\t{\n\t\tn=read();\n\t\tn<<=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint u=read(),v=read()+n/2;\n\t\t\tadd(u,v);add(v,u);\n\t\t}\n\t\tans=1;\n\t\tfor(int i=1;i<=n&&ans;i++)\n\t\t{\n\t\t\tans=ans*i%MOD;\n\t\t\tif(!vis[i])solve(i);\n\t\t}\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn Dango::work();\n}"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 1e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = 0);\n\t\tif (!findcr) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\tassert(SZ(cir) > 1);\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) ideg[u] = 0;\n\t\tfor (auto u : gt) {\n\t\t\tT[u].clear();\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tauto lim = UB(DT[u], in[u]); \n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v]) {\t// find it!\n\t\t\twhile (top && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tSCir(v, u);\n\t\tif (findcr) return;\n\t} if (S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long LL;\nconst int N=200005,mo=1000000007;\nint fst[N],v[N],pre[N],sz[N],tot=1,cntv,cnte,ed,t,n;\nLL fac[N],inv[N];\nbool vis[N];\nstruct Edge{\n\tint to,nxt;\n}e[N*2];\nvoid addedge(int x,int y){\n\te[++tot].to=y;e[tot].nxt=fst[x];fst[x]=tot;\n}\nvoid dfs(int x,int fa){\n\tvis[x]=1;cntv++;\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;cnte++;\n\t\tif (y!=fa){\n\t\t\tif (vis[y]) ed=i;\n\t\t\t\telse dfs(y,x);\n\t\t}\n\t}\n}\nvoid dfs2(int x,int fa){\n\tpre[x]=fa;\n\tfor (int i=fst[x];i;i=e[i].nxt)\n\t\tif (i/2!=ed/2 && e[i].to!=fa) dfs2(e[i].to,x);\n\tif (pre[pre[x]]<x) v[++t]=x;\n}\nLL C(int n,int m){\n\treturn fac[n]*inv[m]%mo*inv[n-m]%mo;\n}\nint dfs3(int x){\n\tLL cnt=1;sz[x]=0;\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (y<pre[x]){\n\t\t\tint z=dfs3(y);\n\t\t\tsz[x]+=sz[y];\n\t\t\tcnt=cnt*z%mo*C(sz[x],sz[y])%mo;\n\t\t}\n\t}\n\tsz[x]++;\n\treturn cnt;\n}\nint solve(){\n\tt=0;dfs2(e[ed^1].to,e[ed].to);\n\tLL cnt=1;\n\tfor (int i=1,x=0;i<=t;i++){\n\t\tint y=dfs3(v[i]);\n\t\tx+=sz[v[i]];\n\t\tcnt=cnt*y%mo*C(x,sz[v[i]])%mo;\n\t}\n\treturn cnt;\n}\nLL ksm(LL x,int y){\n\tLL i=1;\n\tfor (;y;y>>=1,x=x*x%mo)\n\t\tif (y&1) i=i*x%mo;\n\treturn i;\n}\nvoid Pre(){\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mo;\n\tinv[n]=ksm(fac[n],mo-2);\n\tfor (int i=n;i>=1;i--) inv[i-1]=inv[i]*i%mo;\n}\nint main(){\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=0;i<n*2;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\\n\",&x,&y);\n\t\taddedge(x,y+n);\n\t\taddedge(y+n,x);\n\t}\n\tn*=2;Pre();\n\tLL ans=1;\n\tfor (int i=1,x=0;i<=n;i++)\n\tif (!vis[i]){\n\t\tcntv=cnte=0;\n\t\tdfs(i,0);\n\t\tif (cntv*2!=cnte){\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint cnt=solve();\n\t\ted^=1;\n\t\tcnt+=solve();\n\t\tx+=cntv;\n\t\tans=ans*cnt%mo*C(x,cntv)%mo;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define no_solution {cout << \"0\\n\"; return 0;}\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 2e5 + 5;\ntypedef long long ll;\n\nint n, i, cnt, x, y, edge[Nmax], X, Y, w[Nmax], forbx, forby;\nbool used[Nmax], root[Nmax];\nvector<int> v[Nmax], comp, before[Nmax];\nll dp[Nmax], fact[Nmax], ifact[Nmax], ans = 1;\n\nll power(ll a, int b)\n{\n    if(!b) return 1;\n    if(b&1) return a * power(a*a%Mod, b/2) % Mod;\n    return power(a*a%Mod, b/2);\n}\n\nvoid dfs(int node, int dad = 0)\n{\n    cnt += 2;\n    cnt -= v[node].size();\n    used[node] = 1;\n    comp.push_back(node);\n\n    for(auto it : v[node])\n        if(!used[it]) dfs(it, node);\n            else if(it != dad) X = node, Y = it;\n}\n\nvoid Clear()\n{\n    before[0].clear(); edge[0] = -1;\n    for(auto it : comp) before[it].clear(), root[it] = 1, edge[it] = 0;\n}\n\nvoid select(int node)\n{\n    for(auto it : v[node])\n        if(it == edge[node]) break;\n            else before[node].push_back(it), root[it] = 0;\n\n    for(auto it : v[node])\n        if(!edge[it] && !(node == forbx && it == forby))\n        {\n            edge[it] = node;\n            select(it);\n        }\n}\n\nint comb(int n, int k)\n{\n    return fact[n] * ifact[k] % Mod * ifact[n-k] % Mod;\n}\n\nvoid answer(int node)\n{\n    dp[node] = 1;\n    if(before[node].empty())\n    {\n        w[node] = 1;\n        return;\n    }\n\n    w[node] = 0;\n    for(auto it : before[node]) answer(it);\n\n    for(auto it : before[node])\n    {\n        dp[node] = dp[node] * dp[it] % Mod * comb(w[node] + w[it], w[it]) % Mod;\n        w[node] += w[it];\n    }\n\n    ++w[node];\n}\n\nll solve(int x, int y)\n{\n    forbx = x, forby = y;\n    Clear();\n    edge[x] = y;\n    select(x);\n\n    for(auto it : comp)\n        if(root[it]) before[0].push_back(it);\n    answer(0);\n    return dp[0];\n}\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    cin >> n;\n    for(i=1; i<=2*n; ++i)\n    {\n        cin >> x >> y; y += n;\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n\n    for(i=1; i<=2*n; ++i) sort(v[i].begin(), v[i].end());\n\n    fact[0] = ifact[0] = 1;\n    for(i=1; i<=2*n; ++i) fact[i] = fact[i-1] * i % Mod;\n    ifact[2*n] = power(fact[2*n], Mod-2);\n    for(i=2*n-1; i; --i) ifact[i] = ifact[i+1] * (i+1) % Mod;\n\n    int what = 0;\n    for(i=1; i<=2*n; ++i)\n        if(!used[i])\n        {\n            comp.clear();\n            dfs(i);\n            if(cnt) no_solution;\n\n            ans *= (solve(X, Y) + solve(Y, X));\n            ans %= Mod;\n            ans *= comb(what + comp.size(), comp.size());\n            ans %= Mod;\n            what += comp.size();\n        }\n\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint fac[200111],invf[200111];\nint cal(int x,int y){return 1ll*fac[x+y]*invf[x]%mod*invf[y]%mod;}\npii comb(pii x,pii y){return mp(1ll*x.ff*y.ff%mod*cal(x.ss,y.ss)%mod,x.ss+y.ss);}\n\nvector<int> g[200111],g2[200111];\nint n,vs[200111],tot,cyc[200111],len,to[200111],dgr[200111];\n\nbool incyc[200111];\nint stk[200111],top,cnt,dep[200111];\n\npii dfs2(int x)\n{\n\tpii ret=mp(1,0);\n\tfor(int i=0;i<(int)g2[x].size();i++)\n\t\tret=comb(ret,dfs2(g2[x][i]));\n\tret.ss++;return ret;\n}\nvoid dfs(int x,int f=0)\n{\n\tstk[++top]=x;dep[x]=top;cnt++;\n\tvs[++tot]=x;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t{\n\t\tif(g[x][i]==f)continue;\n\t\tcnt--;\n\t\tif(!dep[g[x][i]])\n\t\t\tdfs(g[x][i],x);\n\t\telse if(dep[g[x][i]]<dep[x])\n\t\t{\n\t\t\tlen=0;\n\t\t\tfor(int j=dep[g[x][i]];j<=top;j++){cyc[++len]=stk[j];incyc[stk[j]]=1;}\n\t\t}\n\t\telse cnt++;\n\t}\n\ttop--;\n}\nvoid rdfs(int x,int f=0)\n{\n\tto[x]=f;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f&&!incyc[g[x][i]])\n\t\t\trdfs(g[x][i],x);\n}\n\nint calc()\n{\n\tfor(int i=1;i<=tot;i++){g2[vs[i]].clear();dgr[vs[i]]=0;}\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tfor(int j=0;j<(int)g[vs[i]].size();j++)\n\t\t{\n\t\t\tif(to[vs[i]]>g[vs[i]][j])\n\t\t\t{\n\t\t\t\tg2[vs[i]].pb(g[vs[i]][j]);\n\t\t\t\tdgr[g[vs[i]][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tpii ret=mp(1,0);\n\tfor(int i=1;i<=tot;i++)if(dgr[vs[i]]==0)ret=comb(ret,dfs2(vs[i]));\n\treturn ret.ff;\n}\nint main()\n{\n\tfac[0]=invf[0]=1;for(int i=1;i<200111;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinvf[200111-1]=power(fac[200111-1],mod-2);\n\tfor(int i=200111-2;i>=0;i--)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\t\n\tget1(n);\n\tfor(int i=1,x,y;i<=n+n;i++)\n\t{\n\t\tget2(x,y);\n\t\tg[x].pb(y+n);\n\t\tg[y+n].pb(x);\n\t}\n\tn<<=1;\n\t\n\tpii now=mp(1,0);\n\tfor(int _=1;_<=n;_++)\n\t{\n\t\tif(dep[_])continue;\n\t\ttot=0;dfs(_);\n\t\tif(cnt)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=len;i++)rdfs(cyc[i]);\n\t\tint sum=0;\n\t\tfor(int i=1;i<=len;i++)to[cyc[i]]=cyc[i%len+1];\n\t\tsum+=calc();\n\t\tfor(int i=1;i<=len;i++)to[cyc[i%len+1]]=cyc[i];\n\t\tsum+=calc();if(sum>=mod)sum-=mod;\n\t\tnow=comb(now,mp(sum,tot));\n\t}\n\t\n\tprintendl(now.ff);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G, loop;\nint dfn[MAXN], fa[MAXN], s, t, cnt = 0, edge = 0;\nvoid GetLoop(int x) // 找环 \n{\n\tG.push_back(x); // 森林中的一棵树 \n\tdfn[x] = ++cnt;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == fa[x])\n\t\t\tcontinue;\n\t\tif (dfn[y]) \n\t\t{\n\t\t\tif (dfn[y] < dfn[x]) continue;\n\t\t\tloop.push_back(y);\n\t\t\tfor (; y != x; y = fa[y])\n\t\t\t\tloop.push_back(fa[y]);\n\t\t}\n\t\telse { fa[y] = x; GetLoop(y); }\n\t}\n} \n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[cnt];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tscanf(\"%d\", &n);;\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!dfn[i])\n\t\t{\n\t\t\tcnt = edge = 0;\n\t\t\tGetLoop(i);\n\t\t\tif (cnt << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\ts = loop[0], t = loop[loop.size() - 1]; // 环的起点、终点 \n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tloop.clear();\n\t\t\tG.clear();\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll N = 200005, mod = 1e9+7;\n\nll n, ans = 1, fac[N] = {1}, fi[N] = {1};\nll vis[N], wh[N], sz[N], cv, ms;\nvector<ll> adj[N], tree[N], cur, cyc;\nbool done[N], onc[N];\n\nll calc (ll A, ll B) {\n\tif(!B) return 1;\n\tll R = calc(A, B/2);\n\tR = (R * R) % mod;\n\tif(B%2) R = (R * A) % mod;\n\treturn R;\n}\n\nll comb (ll A, ll B) {\n\treturn fac[A] * fi[B] % mod * fi[A-B] % mod;\n}\n\nll multicomb (vector<ll> &V) {\n\tll R = 1, C = 0;\n\tfor(auto &T : V) {\n\t\tC += T;\n\t}\n\tfor(auto &T : V) {\n\t\tR = (R * comb(C, T));\n\t\tC -= T;\n\t}\n\treturn R;\n}\n\nll dfs1 (ll I) {\n\tms += adj[I].size();\n\tcur.push_back(I);\n\tdone[I] = true;\n\tvis[I] = cv;\n\tfor(auto &T : adj[I]) {\n\t\tif(vis[T] != cv) dfs1(T);\n\t}\n}\n\nll dfs2 (ll I, ll P) {\n\tvis[I] = cv;\n\tfor(auto &T : adj[I]) {\n\t\tll X;\n\t\tif(vis[T] != cv) {\n\t\t\tX = dfs2(T, I);\n\t\t\tif(X == -1) return -1;\n\t\t\telse if(X) {\n\t\t\t\tcyc.push_back(I);\n\t\t\t\tonc[I] = true;\n\t\t\t\treturn (X == I ? -1 : X);\n\t\t\t}\n\t\t}\n\t\telse if(T != P) {\n\t\t\tcyc.push_back(I);\n\t\t\tonc[I] = true;\n\t\t\treturn T;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid dfs3 (ll I) {\n\tvis[I] = cv;\n\tfor(auto &T : adj[I]) {\n\t\tif(onc[T] || vis[T] == cv) continue;\n\t\twh[T] = I;\n\t\tdfs3(T);\n\t}\n}\n\nll dfs4 (ll I) {\n\tsz[I] = 1;\n\tvector<ll> S;\n\tll R = 1;\n\tfor(auto &T : tree[I]) {\n\t\tR = (R * dfs4(T)) % mod;\n\t\tS.push_back(sz[T]);\n\t\tsz[I] += sz[T];\n\t}\n\treturn (R * multicomb(S)) % mod;\n}\n\nll subsol () {\n\tcv++;\n\tfor(auto &C : cur) {\n\t\ttree[C].clear();\n\t\tfor(auto &T : adj[C]) {\n\t\t\tif(T < wh[C]) {\n\t\t\t\tvis[T] = cv;\n\t\t\t\ttree[C].push_back(T);\n\t\t\t}\n\t\t}\n\t}\n\ttree[0].clear();\n\tfor(auto &C : cur) {\n\t\tif(vis[C] == cv) continue;\n\t\ttree[0].push_back(C);\n\t}\n\treturn dfs4(0);\n}\n\nll solve (ll I) {\n\tcv++;\n\tcur.clear();\n\tms = 0;\n\tdfs1(I);\n\tif(ms != 2*cur.size()) {\n\t\tputs(\"0\");\n\t\texit(0);\n\t}\n\tcv++;\n\tcyc.clear();\n\tdfs2(I, 0);\n\tcv++;\n\tfor(auto &C : cyc) {\n\t\tdfs3(C);\n\t}\n\tll R = 0, S = (ll)cyc.size();\n\tfor(ll i=0;i<S;i++) {\n\t\twh[cyc[i]] = cyc[(i+1)%S];\n\t}\n\tR += subsol();\n\tfor(ll i=0;i<S;i++) {\n\t\twh[cyc[(i+1)%S]] = cyc[i];\n\t}\n\tR += subsol();\n\treturn R;\n}\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tn *= 2;\n\tfor(ll i=1;i<=n;i++) {\n\t\tfac[i] = (fac[i-1] * i) % mod;\n\t\tfi[i] = calc(fac[i], mod-2);\n\t}\n\tfor(ll i=1;i<=n;i++) {\n\t\tll A, B;\n\t\tscanf(\"%lld%lld\",&A,&B);\n\t\tB += n/2;\n\t\tadj[A].push_back(B);\n\t\tadj[B].push_back(A);\n\t}\n\tvector<ll> S;\n\tfor(ll i=1;i<=n;i++) {\n\t\tif(done[i]) continue;\n\t\tans = (ans * solve(i)) % mod;\n\t\tS.push_back((ll)cur.size());\n\t}\n\tprintf(\"%lld\\n\", (ans * multicomb(S)) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 200005;\nconst int MM = 1000000007;\n\nint N;\nvector<int> G[MX], T[MX];\nvector<int> Vu;\nint vst[MX], F[MX], I[MX], FI[MX];\nint deg[MX], nxt[MX], prv[MX];\n\nvoid dfs(int x){\n\tif( vst[x] ) return;\n\tvst[x] = 1; Vu.push_back(x);\n\tfor(int c : G[x]) dfs(c);\n}\n\nvector<int> G2[MX];\nll dp[MX], cnt[MX], deg2[MX];\nll solve(vector<int> &Vu)\n{\n\tfor(int c : Vu) cnt[c] = 0, dp[c] = 1, deg2[c] = 0;\n\tdp[0] = 1; cnt[0] = 0; deg2[0] = 0;\n\tfor(int c : Vu) G2[c].clear();\n\tG[0].clear();\n\n\tfor(int c : Vu){\n\t\tfor(int d : G[c]){\n\t\t\tif( d < nxt[c] ) G2[d].push_back(c), deg2[c]++;\n\t\t}\n\t}\n\tfor(int c : Vu) if( G2[c].empty() ) G2[c].push_back(0), deg2[0]++;\n\tvector<int> Q;\n\tfor(int c : Vu) if( deg2[c] == 0 ) Q.push_back(c);\n\tfor(int i = 0; i < Q.size(); i++){\n\t\tint p = Q[i];\n\t\tcnt[p]++;\n\t\tfor(int c : G2[p]){\n\t\t\tcnt[c] += cnt[p];\n\t\t\tdp[c] = dp[c] * dp[p] % MM * F[cnt[c]] % MM * FI[cnt[p]] % MM * FI[cnt[c] - cnt[p]] % MM;\n\t\t\tif( --deg2[c] == 0) Q.push_back(c);\n\t\t}\n\t}\n\treturn dp[0];\n}\n\nint main()\n{\n\tF[0] = FI[0] = I[1] = 1;\n\tfor(int i = 2; i < MX; i++) I[i] = (ll)I[MM%i] * (MM - MM/i) % MM;\n\tfor(int i = 1; i < MX; i++) F[i] = (ll)F[i-1] * i % MM;\n\tfor(int i = 1; i < MX; i++) FI[i] = (ll)FI[i-1] * I[i] % MM;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= 2*N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b); b += N;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tll ans = F[2*N];\n\tfor(int i = 1; i <= 2*N; i++){\n\t\tif( vst[i] ) continue;\n\t\tdfs(i);\n\t\tans = ans * FI[Vu.size()] % MM;\n\t\t\n\t\tvector<int> Q;\n\t\tfor(int c : Vu){\n\t\t\tdeg[c] = G[c].size();\n\t\t\tif( deg[c] == 1 ) Q.push_back(c);\n\t\t}\n\t\tfor(int i = 0; i < Q.size(); i++){\n\t\t\tint p = Q[i];\n\t\t\tdeg[p]--;\n\t\t\tfor(int c : G[p]){\n\t\t\t\tif( deg[c] ){\n\t\t\t\t\tnxt[p] = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( --deg[nxt[p]] == 1 ) Q.push_back(nxt[p]);\n\t\t}\n\t\tint st = 0;\n\t\tfor(int c : Vu){\n\t\t\tif( deg[c] == 2 ) st = c;\n\t\t\telse if( deg[c] >= 3 ) return !printf(\"0\\n\");\n\t\t}\n\t\tif( !st ) return !printf(\"0\\n\");\n\t\t\n\t\tint cur = st;\n\t\tdo{\n\t\t\tfor(int c : G[cur]){\n\t\t\t\tif( c != prv[cur] && deg[c] == 2){\n\t\t\t\t\tnxt[cur] = c;\n\t\t\t\t\tprv[c] = cur;\n\t\t\t\t\tcur = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(st != cur);\n\n\t\tll total = solve(Vu);\n\t\tfor(int c : Vu) if( deg[c] == 2 ) swap(prv[c], nxt[c]);\n\t\ttotal = (total + solve(Vu)) % MM;\n\n\t\tans = ans * total % MM;\n\t\t\n\t\tVu.clear();\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define N 400005\nusing namespace std;\nconst int mo=1e9+7;\nvector <int> H,M,D;\nint S,cnt,a[N],b[N],g[N],nex[N],E[N],d[N],l,r,n,x,y,w[N],R[N],v[N],s[N],e[N]; LL ans,tmp,P[N],Q[N],f[N];\nvoid fly(int x){\n\tH.push_back(x); v[x]=1;\n\tfor (int i=g[x];i;i=nex[i])\n\tif (!v[b[i]]) fly(b[i]);\n}\nvoid dfs(int x){\n\tfor (int i=g[x];i;i=nex[i])\n\tif (!E[i]) E[i]=1,E[i>n?i-n:i+n]=-1,dfs(b[i]);\n}\nLL po(LL x,int y){\n\tLL z=1;\n\tfor (;y;y>>=1,x=x*x%mo)\n\tif (y&1) z=z*x%mo;\n\treturn z;\n}\nLL C(int n,int m){\n\treturn P[n]*Q[m]%mo*Q[n-m]%mo;\n}\nint go(){\n\tfor (int i=0;i<H.size();++i) f[H[i]]=1,s[H[i]]=R[H[i]]=0;\n\tl=r=f[0]=1; s[0]=0;\n\tfor (int i=0;i<M.size();++i)\n\t\tif (E[M[i]]==1) e[a[M[i]]]=b[M[i]];\n\tfor (int i=0;i<H.size();++i)\n\t\tif (H[i]<e[e[H[i]]]) ++R[e[H[i]]];\n\tfor (int i=0;i<H.size();++i)\n\t\tif (!R[H[i]]) d[r++]=H[i];\n\twhile (l<r){\n\t\tint x=d[l]; ++s[x];\n\t\tif (x<e[e[x]]){\n\t\t\t--R[e[x]]; if (!R[e[x]]) d[r++]=e[x];\n\t\t\t(f[e[x]]*=f[x]*C(s[e[x]]+=s[x],s[x])%mo)%=mo;\n\t\t}else (f[0]*=f[x]*C(s[0]+=s[x],s[x])%mo)%=mo;\n\t\t++l;\n\t}\n\treturn f[0];\n}\nint main(){\n\tscanf(\"%d\",&n); ans=1;\n\tfor (int i=1;i<=n+n;++i){\n\t\tscanf(\"%d%d\",&x,&y); y+=n;\n\t\t++w[x]; ++w[y];\n\t\ta[i]=x; b[i]=y; nex[i]=g[x]; g[x]=i;\n\t\ta[i+n+n]=y; b[i+n+n]=x;\n\t\tnex[i+n+n]=g[y]; g[y]=i+n+n;\n\t}\n\tn+=n;\n\tP[0]=1; for (int i=1;i<=n;++i) P[i]=P[i-1]*i%mo;\n\tQ[n]=po(P[n],mo-2); for (int i=n-1;~i;--i) Q[i]=Q[i+1]*(i+1)%mo;\n\tfor (int i=1;i<=n;++i)\n\t\tif (!w[x]) return puts(\"0\"),0;\n\tfor (int I=1;I<=n;++I)\n\tif (!v[I]){\n\t\tH.clear(); M.clear(); fly(I); l=r=1;\n\t\tfor (int i=0;i<H.size();++i)\n\t\tfor (int j=g[H[i]];j;j=nex[j])\n\t\t\tM.push_back(j);\n\t\tfor (int i=0;i<H.size();++i)\n\t\t\tif (w[H[i]]==1) d[r++]=H[i];\n\t\twhile (l<r){\n\t\t\tfor (int i=g[d[l]];i;i=nex[i])\n\t\t\tif (!E[i]){\n\t\t\t\tE[i]=1; E[i>n?i-n:i+n]=-1;\n\t\t\t\t--w[a[i]]; --w[b[i]];\n\t\t\t\tif (w[b[i]]==1) d[r++]=b[i];\n\t\t\t}\n\t\t\t++l;\n\t\t}\n\t\tD.clear();\n\t\tfor (int i=0;i<H.size();++i)\n\t\t\tif (w[H[i]]&&w[H[i]]!=2) return puts(\"0\"),0;\n\t\tfor (int i=0;i<M.size();++i)\n\t\t\tif (!E[M[i]]) D.push_back(M[i]);\n\t\tdfs(a[D[0]]);\n\t\ttmp=go();\n\t\tfor (int i=0;i<D.size();++i) E[D[i]]*=-1;\n\t\t(tmp+=go())%=mo;\n\t\tans=ans*tmp%mo*C(S+=H.size(),H.size())%mo;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2, \"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair <int, int> pii;\n \nconst int N = 4e5 + 5, mod = 1e9 + 7;\nint n, m, ans, ways;\nint fac[N], inv[N];\nint pre[N], rp[N][2], cp[N][2];\nint deg[N], color[N], os[N];\nint dir[N], id[N];\npii nowp, rep[N], a[N];\nmap <pii, int> exi;\nvector <int> dlt, e[N], g[N], r[N], ance[N];\nqueue <int> sing;\ninline int read () {\n\tint x = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn x;\n}\ninline int power (int a, int b) {\n    int ret = 1;\n    for ( ; b; b >>= 1, a = 1ll * a * a % mod) {\n        if (b & 1) {\n            ret = 1ll * ret * a % mod;\n        }\n    }\n    return ret;\n}\nvoid predo () {\n    fac[0] = 1;\n    for (int i = 1; i <= n + n; ++i) {\n        fac[i] = 1ll * fac[i - 1] * i % mod;\n    }\n    inv[n + n] = power(fac[n + n], mod - 2);\n    for (int i = n + n - 1; ~i; --i) {\n        inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n    }\n}\nvoid adds (int x, int y) {\n    g[x].push_back(y), g[y].push_back(x);\n}\nvoid cover (int x) {\n    color[x] = m;\n    r[m].push_back(x);\n    if (!dir[x]) {\n        ++os[m];\n    }\n    for (auto y : g[x]) {\n        if (!color[y]) {\n            cover(y);\n        }\n    }\n}\nvoid bring (int x, int c) {\n    r[color[x]].clear();\n    color[x] = c;\n    r[c].push_back(x);\n    for (auto y : ance[x]) {\n        bring(y, c);\n    }\n}\nstruct Tr {\n    int n, dg[N], subs[N], fa[N];\n    vector <int> c[N];\n    void init (int _n) {\n        n = _n;\n        for (int i = 0; i <= n; ++i) {\n            dg[i] = subs[i] = 0;\n            fa[i] = -1;\n            c[i].clear();\n        }\n    }\n    void add (int x, int y) {\n        if (fa[y] == -1) {\n            fa[y] = x;\n            c[x].push_back(y), ++dg[y];\n        }\n    }\n    int dp (int x, int p) {\n        int ret = 1;\n        subs[x] = 1;\n        for (auto y : c[x]) {\n            if (y != p) {\n                ret = 1ll * ret * dp(y, x) % mod;\n                subs[x] += subs[y];\n                ret = 1ll * ret * inv[subs[y]] % mod;\n            }\n        }\n        ret = 1ll * ret * fac[subs[x] - 1] % mod;\n        return ret;\n    }\n} T;\nint deter (int x, int f) {\n    T.init(r[x].size());\n    for (int i = 0; i < os[x]; ++i) {\n        dir[r[x][i]] = ((i + f) & 1) + 1;\n    }\n    for (int i = 0; i < r[x].size(); ++i) {\n        id[r[x][i]] = i;\n    }\n    for (int i = os[x], u, v; i < r[x].size(); ++i) {\n        u = r[x][i], nowp = a[u];\n        for (auto v : ance[u]) {\n            T.add(i + 1, id[v] + 1);\n        }\n        if (os[x]) {\n            if (dir[u] == 1) {\n                v = rp[a[u].fi][0];\n                if (a[u].se < a[v].se && dir[v] == 2) {\n                    T.add(id[v] + 1, i + 1);\n                } else {\n                    v = rp[a[u].fi][1];\n                    if (a[u].se < a[v].se && dir[v] == 2) {\n                        T.add(id[v] + 1, i + 1);\n                    }\n                }\n            } else {\n                v = cp[a[u].se][0];\n                if (a[u].fi < a[v].fi && dir[v] == 1) {\n                    T.add(id[v] + 1, i + 1);\n                } else {\n                    v = cp[a[u].se][1];\n                    if (a[u].fi < a[v].fi && dir[v] == 1) {\n                        T.add(id[v] + 1, i + 1);\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 0, u, v; i < os[x]; ++i) {\n        u = r[x][i], v = r[x][(i + 1) % os[x]];\n        if (dir[u] == 1 && dir[v] == 2) {\n            if (a[u].fi == a[v].fi && a[u].se < a[v].se) {\n                T.add((i + 1) % os[x] + 1, i + 1);\n            }\n            if (a[u].se == a[v].se && a[u].fi > a[v].fi) {\n                T.add(i + 1, (i + 1) % os[x] + 1);\n            }\n        } else {\n            if (a[u].fi == a[v].fi && a[u].se > a[v].se) {\n                T.add(i + 1, (i + 1) % os[x] + 1);\n            }\n            if (a[u].se == a[v].se && a[u].fi < a[v].fi) {\n                T.add((i + 1) % os[x] + 1, i + 1);\n            }\n        }\n    }\n    for (int i = 1; i <= T.n; ++i) {\n        if (T.dg[i] == 0) {\n            T.add(0, i);\n        }\n    }\n    return T.dp(0, -1);\n}\nint main () {\n\tn = read(), predo();\n    for (int i = 1, x, y; i <= n + n; ++i) {\n    \tx = read(), y = read();\n        a[i] = make_pair(x, y);\n        exi[a[i]] = i;\n        y += n;\n        e[x].push_back(y), e[y].push_back(x);\n        ++deg[x], ++deg[y];\n    }\n    return 0;\n    for (int i = 1; i <= n + n; ++i) {\n        if (deg[i] == 0) {\n            return puts(\"0\"), 0;\n        }\n    }\n    for (int i = 1; i <= n + n; ++i) {\n        if (deg[i] == 1) {\n            if (i <= n) {\n                rep[i] = make_pair(i, e[i][0] - n);\n                dir[exi[rep[i]]] = 2;\n            } else {\n                rep[i] = make_pair(e[i][0], i - n);\n                dir[exi[rep[i]]] = 1;\n            }\n            sing.push(i), dlt.push_back(i);\n        }\n    }\n    for ( ; !sing.empty(); ) {\n        int x = sing.front(), z;\n        sing.pop();\n        for (auto y : e[x]) {\n            if ((--deg[y]) == 1) {\n                for (auto u : e[y]) {\n                    if (deg[u] > 1) {\n                        z = u;\n                        break;\n                    }\n                }\n                if (y <= n) {\n                    rep[y] = make_pair(y, z - n);\n                    dir[exi[rep[y]]] = 2;\n                } else {\n                    rep[y] = make_pair(z, y - n);\n                    dir[exi[rep[y]]] = 1;\n                }\n                sing.push(y), dlt.push_back(y);\n            }\n        }\n    }\n    memset(deg, 0, sizeof deg);\n    for (int i = 1, p, q, u, v; i <= n + n; ++i) {\n        u = exi[rep[i]], p = dir[u];\n        if (p) {\n            for (auto j : e[i]) {\n                v = exi[rep[j]], q = dir[v];\n                if (!v) {\n                    continue;\n                }\n                if (p == 1 && q == 2) {\n                    if (rep[i].fi > rep[j].fi) {\n                        ance[u].push_back(v), ++deg[v];\n                    }\n                } else {\n                    if (rep[i].se > rep[j].se) {\n                        ance[u].push_back(v), ++deg[v];\n                    }\n                }\n            }\n        }\n    }\n    for (auto x : dlt) {\n        exi[rep[x]] = 0;\n    }\n    for (auto p : exi) {\n        if (p.se) {\n            if (rp[p.fi.fi][0]) {\n                rp[p.fi.fi][1] = p.se;\n                if (a[rp[p.fi.fi][0]].se > a[rp[p.fi.fi][1]].se) {\n                    swap(rp[p.fi.fi][0], rp[p.fi.fi][1]);\n                }\n            } else {\n                rp[p.fi.fi][0] = p.se;\n            }\n            if (cp[p.fi.se][0]) {\n                cp[p.fi.se][1] = p.se;\n                if (a[cp[p.fi.se][0]].fi > a[cp[p.fi.se][1]].fi) {\n                    swap(cp[p.fi.se][0], cp[p.fi.se][1]);\n                }\n            } else {\n                cp[p.fi.se][0] = p.se;\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (rp[i][0] && rp[i][1]) {\n            adds(rp[i][0], rp[i][1]);\n        }\n        if (cp[i][0] && cp[i][1]) {\n            adds(cp[i][0], cp[i][1]);\n        }\n    }\n    for (int i = 1; i <= n + n; ++i) {\n        if (!color[i]) {\n            ++m, cover(i);\n        }\n    }\n    for (int i = 1, ci; i <= n + n; ++i) {\n        if ((int)r[color[i]].size() == 1) {\n            nowp = a[i], ci = -1;\n            if (dir[i] == 2) {\n                if (cp[nowp.se][0]) {\n                    ci = color[cp[nowp.se][0]];\n                }\n            } else {\n                if (rp[nowp.fi][0]) {\n                    ci = color[rp[nowp.fi][0]];\n                }\n            }\n            if (~ci) {\n                bring(i, ci);\n            } else {\n                if (!deg[i]) {\n                    for (auto j : ance[i]) {\n                        bring(j, color[i]);\n                    }\n                }\n            }\n        }\n    }\n    ans = 1, ways = 1;\n    for (int i = 1, tmp; i <= m; ++i) {\n        if ((int)r[i].size() > 0) {\n            if (os[i]) {\n                tmp = (deter(i, 0) + deter(i, 1)) % mod;\n            } else {\n                tmp = deter(i, 0);\n            }\n            ways = 1ll * ways * tmp % mod;\n            ans = 1ll * ans * inv[r[i].size()] % mod;\n        }\n    }\n    ans = 1ll * ans * ways % mod;\n    ans = 1ll * ans * fac[n + n] % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,O=1000000007;\ninline int fpow(int x,int n){\n\tint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\nint nlst[N],ns;\nint fac[N],invfac[N];\ninline void gmath(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=(lint)fac[i-1]*i%O;\n\t}\n\tinvfac[n]=inv(fac[n]);\n\tfor(int i=n;i>=1;i--){\n\t\tinvfac[i-1]=(lint)invfac[i]*i%O;\n\t}\n}\nint vis[N],tim=0;\nnamespace G{\n\tconst int E=N;\n\tint to[E],bro[E],head[N],e=0;\n\tint size[N],ringe;\n\tint edg[N];\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tvoid getring(int x){\n\t\tnlst[++ns]=x;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])!=edg[x]){\n\t\t\t\tif(edg[v]){\n\t\t\t\t\tif(ringe==-1){\n\t\t\t\t\t\tringe=i;\n\t\t\t\t\t}else if(to[ringe]!=x){\n\t\t\t\t\t\tringe=-2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tedg[v]=x;\n\t\t\t\t\tgetring(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x){\n\t\tsize[x]=1;\n\t\tlint ans=1;\n\t\tvis[x]=tim;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tassert(vis[v]!=tim);\n\t\t\t\tif(vis[v]==tim)throw 0;\n\t\t\t\tans=ans*dfs(v)%O;\n\t\t\t\tans=ans*invfac[size[v]]%O;\n\t\t\t\tsize[x]+=size[v];\n\t\t\t}\n\t\t}\n\t\treturn ans*fac[size[x]-1]%O;\n\t}\n}\nint deg[N];\ninline int work2(){\n\tusing namespace G;\n\tfor(int i=1;i<=ns;i++){\n\t\tint x=nlst[i];\n\t\tdeg[x]=0;\n\t}\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tdeg[v]++;\n\t\t\t}\n\t\t}\n\t}\n\ttim++;\n\tlint ans=fac[ns];\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tif(deg[x]==0){\n\t\t\tans=ans*dfs(x)%O;\n\t\t\tans=ans*invfac[size[x]]%O;\n\t\t}\n\t}\n\treturn ans;\n}\ninline int work(int x){//kind*invfac[n]\n\tusing namespace G;\n\tns=0;\n\tringe=-1;\n\tedg[x]=-1;\n\tgetring(x);\n\tif(ringe<0)return 0;\n\tfor(int p=to[ringe],q=to[ringe^1];~p;swap(edg[p],q),swap(p,q));\n\ttry{\n\t\tint ans=work2();\n\t\tfor(int p=to[ringe^1],q=to[ringe],tp=p;swap(edg[p],q),swap(p,q),p!=tp;);\n\t\treturn (lint)invfac[ns]*(ans+work2())%O;\n\t}catch(int x){\n\t\treturn x;\n\t}\n}\ninline int Main(){\n\tint n=ni,n2=n<<1;\n\tG::init();\n\tfor(int i=1;i<=n2;i++){\n\t\tG::add(ni,n+ni);\n\t}\n\tgmath(n<<1);\n\tlint ans=fac[n<<1];\n\tmemset(G::edg,0,sizeof(G::edg));\n\tmemset(G::size,0,sizeof(G::size));\n\tfor(int i=1;i<=n2;i++){\n\t\tif(G::edg[i]==0){\n\t\t\t(ans*=work(i))%=O;\n\t\t\tif(ans==0)return 0;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tprintf(\"%d\\n\",Main());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\nconst int MAXN = (int) 2e5;\n\nint n;\n\nint x[MAXN + 5], y[MAXN + 5];\n\nvector<pii> adj[MAXN * 2 + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= 2 * n; ++i)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\t\tadj[u].emplace_back(n + v, u + v);\n\t\tadj[n + v].emplace_back(u, u + v);\n\t}\n}\n\nint dfn[MAXN * 2 + 5], dfn_cur = 0;\nvector<int> stk;\n\nint cir[MAXN * 2 + 5], len = 0;\n\ninline void dfs_cir(int u, int fa)\n{\n\tdfn[u] = ++dfn_cur;\n\n\tstk.push_back(u);\n\tfor(auto it : adj[u])\n\t{\n\t\tint v = it.fst;\n\t\tif(v != fa)\n\t\t{\n\t\t\tif(!dfn[v]) dfs_cir(v, u);\n\t\t\telse if(dfn[u] > dfn[v])\n\t\t\t{\n\t\t\t\tfor(int i = SZ(stk) - 1; stk[i] != v; --i) cir[++len] = stk[i];\n\t\t\t\tcir[++len] = v;\n\t\t\t}\n\t\t}\n\t}\n\tstk.pop_back();\n}\n\nint is_cir[MAXN * 2 + 5];\nint w[MAXN * 2 + 5];\n\ninline void dfs_w(int u, int fa)\n{\n\tfor(auto it : adj[u])\n\t{\n\t\tint v = it.fst;\n\t\tif(!is_cir[v] && v != fa) w[v] = it.snd, dfs_w(v, u);\n\t}\n}\n\nnamespace MATH\n{\n\tinline int fpm(int x, int y)\n\t{\n\t\tint res = 1;\n\t\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\t\treturn res;\n\t}\n\n\tint fac[MAXN * 2 + 5], ifac[MAXN * 2 + 5];\n\n\tinline int C(int N, int M) { return N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n\n\tinline void init(int N)\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= N; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[N] = fpm(fac[N], MOD - 2);\n\t\tfor(int i = N - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n}\nusing MATH::C;\n\nvector<int> sub[MAXN * 2 + 5];\nint fa[MAXN + 5];\n\nint f[MAXN + 5], size[MAXN + 5];\n\ninline void dfs_ans(int u)\n{\n\tf[u] = 1, size[u] = 1;\n\tfor(auto v : sub[u]) if(v != fa[u])\n\t{\n\t\tdfs_ans(v);\n\t\tf[u] = (LL) f[u] * C(size[u] - 1 + size[v], size[v]) % MOD * f[v] % MOD;\n\t\tsize[u] += size[v];\n\t}\n}\n\ninline int calc()\n{\n\tfor(int i = 0; i <= 2 * n; ++i) fa[i] = 0, sub[i].clear();\n\n\tfor(int u = 1; u <= 2 * n; ++u)\n\t\tfor(auto it : adj[u])\n\t\t{\n\t\t\tint v = it.fst, w0 = it.snd;\n\t\t\tif(w0 < w[u]) fa[v] = u, sub[u].push_back(v);\n\t\t}\n\tfor(int i = 1; i <= 2 * n; ++i) if(fa[i] == 0) sub[0].push_back(i);\n\n\tdfs_ans(0);\n\treturn f[0];\n}\n\ninline void solve()\n{\n\tdfs_cir(1, 0);\n\tif(dfn_cur != 2 * n) { puts(\"0\"); return; }\n\n\tint ans = 0;\n\n\tfor(int i = 1; i <= len; ++i) is_cir[cir[i]] = 1;\n\tfor(int i = 1; i <= len; ++i) dfs_w(cir[i], 0);\n\n\tMATH::init(2 * n);\n\n\tfor(int i = 1; i <= len; ++i)\n\t{\n\t\tint u = cir[i];\n\t\tfor(auto it : adj[u]) if(it.fst == cir[i % len + 1]) w[u] = it.snd;\n\t}\n\n\t(ans += calc()) %= MOD;\n\n\tfor(int i = len + 1; i >= 1; --i) w[cir[i]] = w[cir[i - 1]];\n\tw[cir[1]] = w[cir[len + 1]];\n\n\t(ans += calc()) %= MOD;\n\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nconst int N = 5 * 100000 + 100;\nconst int MOD = 1000000007;\nconst int oo = 1e9;\n\nint n , x , y, take[N], in[N], sz[N];\nbool inStack[N], vis[N];\nll fact[N], inv[N];\n\nvector<int> g[N], tree[N], cycle, my;\nstack<int> st;\n\nvoid findCycle(int u , int p) {\n\tif (inStack[u]) {\n\t\twhile (1) {\n\t\t\tcycle.pb(st.top());\n\t\t\tst.pop();\n\t\t\tif (cycle.back() == u)break;\n\t\t}\n\t\tfor (int i = 0; i < cycle.size(); ++i) st.push(cycle[i]);\n\t\treturn;\n\t}\n\tif (vis[u])return;\n\tmy.pb(u);\n\ttake[u] = p;\n\tvis[u] = 1;\n\tinStack[u] = 1;\n\tst.push(u);\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tfindCycle(v, u);\n\t}\n\tinStack[u] = 0;\n\tst.pop();\n}\nbool getType(int idx) {\n\treturn idx > n;\n}\nll fast(ll a , ll b) {\n\tif (!b)return 1ll;\n\tll res = fast(a, b / 2);\n\tres = (res * res) % MOD;\n\tif (b & 1)\n\t\treturn (res * a) % MOD;\n\treturn res;\n}\nll nCk(ll n , ll k) {\n\treturn ((fact[n] * inv[n - k]) % MOD * inv[k]) % MOD;\n}\nll calc(int u) {\n\tsz[u] = 0;\n\tll ans = 1;\n\tfor (int i = 0; i < tree[u].size(); ++i) {\n\t\tint v = tree[u][i];\n\t\tll ff = calc(v);\n\t\tans = (((ans * ff ) % MOD * nCk(sz[u] + sz[v], sz[v])))%MOD;\n\t\tsz[u] += sz[v];\n\t}\n\tsz[u]++;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tg[x + n].pb(y);\n\t\tg[y].pb(x + n);\n\t}\n\tfact[0] = 1;\n\tinv[0] = fast(fact[0], MOD - 2);\n\tfor (int i = 1 ; i <= 2 * n ; ++i) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv[i] = fast(fact[i], MOD - 2);\n\t}\n\tll ans = 1;\n\tint len = 0;\n\tfor (int node = 1 ; node <= 2 * n ; ++node) {\n\t\tif (vis[node])continue;\n\t\tcycle.clear();\n\t\tmy.clear();\n\t\tfindCycle(node, -1);\n\t\tfor (int i = 0; i < my.size(); ++i){\n\t\t\tinStack[my[i]]=vis[my[i]]=0;\n\t\t}\n\t\tif(cycle.size()){\n\t\t\tint root = cycle[0];\n\t\t\tcycle.clear();\n\t\t\tmy.clear();\n\t\t\tfindCycle(root,-1);\n\t\t}\n\t\tint E = 0;\n\t\tfor (int i = 0; i < my.size(); ++i){\n\t\t\tE += g[my[i]].size();\n\t\t}\n\t\tif(E != 2*my.size()){\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tll res = 0;\n\t\tfor (int it = 0; it < 2 ; ++it) {\n\t\t\tfor (int i = 0 ; i < my.size(); ++i){\n\t\t\t\tin[my[i]] = 0;\n\t\t\t\ttree[my[i]].clear();\n\t\t\t}\n\t\t\ttree[0].clear();\n\t\t\tfor (int j = 0 ; j < cycle.size(); ++j) {\n\t\t\t\ttake[cycle[j]] = (it == 0 ? cycle[(j + 1) % cycle.size()] :  cycle[(j - 1 + cycle.size()) % cycle.size()]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size() ; ++i) {\n\t\t\t\tint f = my[i];\n\t\t\t\tfor (int j = 0 ; j < g[f].size(); ++j) {\n\t\t\t\t\tint v = g[f][j];\n\t\t\t\t\tif (getType(take[f]) == getType(v) && v < take[f]) {\n\t\t\t\t\t\ttree[f].pb(v);\n\t\t\t\t\t\tin[v]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size(); ++i) {\n\t\t\t\tif (!in[my[i]]) {\n\t\t\t\t\ttree[0].push_back(my[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = (res + calc(0)) % MOD;\n\t\t}\n\n\t\tans = (ans * res ) % MOD;\n\t\tans = (ans * nCk(len+my.size(),my.size()))%MOD;\n\t\tlen += my.size();\n\t}\n\tprintf(\"%lld\\n\", ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m;\nvector<int>E[N];\n#define pb push_back\nvoid input()\n{\n\tint x,y;\n\tn=read<int>();\n\tFor(i,1,n<<1)\n\t{\n\t\tx=read<int>(),y=read<int>()+n;\n\t\tE[x].pb(y),E[y].pb(x);\n\t}\n}\nconst int mo=1e9+7;\nint ans,inv[N];\nint vis[N],edge;\nint node[N],cnt;\nint c[N],top;\nint fa[N];\nint stk[N],tp;\nvoid dfs1(int u,int pre)\n{\n\tnode[++cnt]=u;stk[++tp]=u,vis[u]=1,stk[tp+1]=0;\n\tedge+=(int)E[u].size();\n\tfor(int v:E[u])if(v^pre)\n\t{\n\t\tif(!vis[v])dfs1(v,u);\n\t\telse if(!top)\n\t\t{\n\t\t\twhile(stk[tp+1]!=v)vis[c[++top]=stk[tp--]]=2;\n\t\t\tc[0]=v;\n\t\t}\n\t}\n\t--tp;\n}\nvoid dfs2(int u,int pre)\n{\n\tfor(int v:E[u])if(v^pre&&vis[v]<2)\n\t{\n\t\tfa[v]=u;\n\t\tdfs2(v,u);\n\t}\n}\nvector<int>G[N];\nint d[N],sz[N];\nvoid dfs3(int u,int &res)\n{\n\tsz[u]=1;\n\tfor(int v:G[u])\n\t{\n\t\tdfs3(v,res);\n\t\tsz[u]+=sz[v];\n\t}\n\tres=1ll*res*inv[sz[u]]%mo;\n}\nint cal()\n{\n\tint res=1;\n\tFor(i,1,cnt)\n\t{\n\t\tres=1ll*res*i%mo;\n\t\td[node[i]]=0;\n\t\tG[node[i]].clear();\n\t}\n\tFor(i,1,cnt)\n\t{\n\t\tfor(int v:E[node[i]])if(v<fa[node[i]])\n\t\t{\n\t\t\tG[node[i]].pb(v);d[v]++;\n\t\t}\n\t}\n\tFor(i,1,cnt)if(!d[node[i]])dfs3(node[i],res);\n\treturn res;\n}\nvoid init(int st)\n{\n\tint res=0;\n\tcnt=top=tp=edge=0;\t\n\tdfs1(st,0);\t\n\tif(edge!=(cnt<<1)){puts(\"0\");exit(0);}\n\tFor(i,1,top)dfs2(c[i],0);\t\n\tFor(i,1,top)fa[c[i-1]]=c[i];\n\tres=cal();\n\tFor(i,1,top)fa[c[i]]=c[i-1];\n\tres=(res+cal())%mo;\n\tans=1ll*ans*res%mo;\n\tFor(i,1,cnt)ans=1ll*ans*inv[i]%mo;\n\t//cerr<<cnt<<endl;\n}\nvoid work()\n{\n\tans=1;\n\tinv[0]=inv[1]=1;\n\tFor(i,2,n<<1)ans=1ll*ans*i%mo,inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,n<<1)if(!vis[i])init(i);\n\twrite(ans,'\\n');\n}\nint main()\n{\n\n\tinput();\n\twork();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        // assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        // assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        // assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            chain_t c = use_generic(i, true);\n            return c * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            chain_t c = use_generic(i, false);\n            return c * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        REP (y, n) acc = acc * go_row(y);\n        REP (x, n) acc = acc * go_col(x);\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define isNum(a) (a >= '0' && a <= '9')\n#define SP putchar(' ')\n#define EL putchar('\\n')\n#define File(a) freopen(a \".in\", \"r\", stdin), freopen(a \".out\", \"w\", stdout)\n\ntemplate <class T> void read(T &);\ntemplate <class T> void write(const T &);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef const long long &cll;\ntypedef const int &ci;\ntypedef std::pair<int, int> pii;\nconst int iinf = 2147483647;\nconst ll llinf = 9223372036854775807ll;\nusing std::abs;\nusing std::max;\nusing std::min;\n\nconst int N = 400005;\nconst int M = 800005;\nconst int Mod = 1000000007;\n\nint pow(int a, int b, int m);\nvoid add(int u, int v);\nvoid add2(int u, int v);\nvoid dfs1(int u, int fa);\nvoid dfs2(int u, int fa);\nvoid dfs3(int u, int fa);\nint solve();\n\nint hed[N], nxt[M], to[M], id;\nint hed2[N], nxt2[M], to2[M], id2;\nint fac[N], ifac[N], inv[N];\nint sta[N];\nbool vis[N];\nint deg[N];\nint sv, se;\nint nto[N];\nint siz[N];\nint X, Y;\nint n;\n\nint main() {\n  read(n);\n  for (int i = 1; i <= 2 * n; ++i) {\n    int x, y;\n    read(x), read(y);\n    y += n;\n    add(x, y), add(y, x);\n  }\n  n <<= 1;\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = fac[i - 1] * 1ll * i % Mod;\n  }\n  ifac[n] = pow(fac[n], Mod - 2, Mod);\n  for (int i = n - 1; i >= 1; --i) {\n    ifac[i] = ifac[i + 1] * 1ll * (i + 1) % Mod;\n  }\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    inv[i] = (Mod - Mod / i) * 1ll * inv[Mod % i] % Mod;\n  }\n  int ans = fac[n];\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      sv = se = 0;\n      dfs1(i, 0);\n      if ((sv << 1) != se) {\n        puts(\"0\");\n        return 0;\n      }\n      ans = ans * 1ll * ifac[sv] % Mod;\n      int now = solve();\n      std::swap(X, Y);\n      now = (now + solve()) % Mod;\n      ans = ans * 1ll * now % Mod;\n    }\n  }\n  write(ans), EL;\n  return 0;\n}\n\ntemplate <class T> inline void read(T &Re) {\n  T k = 0;\n  char ch = getchar();\n  int flag = 1;\n  while (!isNum(ch)) {\n    if (ch == '-') {\n      flag = -1;\n    }\n    ch = getchar();\n  }\n  while (isNum(ch)) {\n    k = (k << 1) + (k << 3) + ch - '0';\n    ch = getchar();\n  }\n  Re = flag * k;\n}\ntemplate <class T> inline void write(const T &Wr) {\n  if (Wr < 0) {\n    putchar('-');\n    write(-Wr);\n  } else {\n    if (Wr < 10) {\n      putchar(Wr + '0');\n    } else {\n      write(Wr / 10);\n      putchar((Wr % 10) + '0');\n    }\n  }\n}\n\nint pow(int a, int b, int m) {\n  int ans = 1, now = a;\n  while (b) {\n    if (b & 1) {\n      ans = ans * 1ll * now % m;\n    }\n    now = now * 1ll * now % m;\n    b >>= 1;\n  }\n  return ans;\n}\nvoid add(int u, int v) {\n  nxt[++id] = hed[u];\n  hed[u] = id;\n  to[id] = v;\n}\nvoid add2(int u, int v) {\n  nxt2[++id2] = hed2[u];\n  hed2[u] = id2;\n  to2[id2] = v;\n}\nvoid dfs1(int u, int fa) {\n  vis[u] = true;\n  sta[++sv] = u;\n  for (int i = hed[u]; i; i = nxt[i], ++se) {\n    int v = to[i];\n    if (!vis[v]) {\n      dfs1(v, u);\n    } else {\n      if (v != fa) {\n        X = u, Y = v;\n      }\n    }\n  }\n}\nvoid dfs2(int u, int fa) {\n  for (int i = hed[u]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v != fa && v != X) {\n      nto[v] = u;\n      dfs2(v, u);\n    }\n  }\n}\nvoid dfs3(int u, int fa) {\n  siz[u] = 1;\n  for (int i = hed2[u]; i; i = nxt2[i]) {\n    int v = to2[i];\n    if (v != fa) {\n      dfs3(v, u);\n      siz[u] += siz[v];\n    }\n  }\n}\nint solve() {\n  dfs2(X, Y);\n  nto[X] = Y;\n  for (int i = 1; i <= sv; ++i) {\n    hed2[sta[i]] = deg[sta[i]] = 0;\n  }\n  for (int i = 1; i <= sv; ++i) {\n    for (int j = hed[sta[i]]; j; j = nxt[j]) {\n      int v = to[j];\n      if (v < nto[sta[i]]) {\n        add2(sta[i], v);\n        ++deg[v];\n      }\n    }\n  }\n  for (int i = 1; i <= sv; ++i) {\n    if (deg[sta[i]] == 0) {\n      dfs3(sta[i], 0);\n    }\n  }\n  int ans = fac[sv];\n  for (int i = 1; i <= sv; ++i) {\n    ans = ans * 1ll * inv[siz[sta[i]]] % Mod;\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nconst int MAXN=100000;\nconst int MAXNODE=2*MAXN;\nconst LL mods=1000000007LL;\nstruct M{\n\tLL x;\n\tM(LL angka){\n\t\tif(angka>=mods||angka<=-mods)\n\t\t\tangka%=mods;\n\t\tif(angka<0)\n\t\t\tangka+=mods;\n\t\tx=angka;\n\t}\n\tM(){\n\t\tx=0;\n\t}\n\tM operator + (const M &other) const{\n\t\treturn M(x+other.x);\n\t}\n\tM operator - (const M &other) const{\n\t\treturn M(x-other.x);\n\t}\n\tM operator * (const M &other) const{\n\t\treturn M(x*other.x);\n\t}\n\tM operator - () const{\n\t\treturn M(-x);\n\t}\n};\nint n,rootcc,par[MAXNODE+5],subtree[MAXNODE+5];\nM fakt[MAXNODE+5],inv[MAXNODE+5],ans;\nvector <int> node[MAXNODE+5],cc,dag[MAXNODE+5];\nbool partofcycle[MAXNODE+5],partofcc[MAXNODE+5],rootdag[MAXNODE+5];\nvoid inis(){\n\tmemset(partofcycle,false,sizeof(partofcycle));\t\t\t//part of cycle gak\n\tmemset(partofcc,false,sizeof(partofcc));\t\t\t\t//sudah pernah gak jadi cc\n}\nvoid exteuclid(LL a,LL b,M &x,M &y){\n\tif(b==0)\n\t{\n\t\tx=1;\n\t\ty=0;\n\t}\n\telse\n\t{\n\t\texteuclid(b,a%b,x,y);\n\t\tM tempx,tempy;\n\t\ttempx=x,tempy=y;\n\t\t\n\t\tx=tempy;\n\t\ty=tempx-tempy*(a/b);\n\t}\n}\nM invers(LL angka){\n\tM x,y;\n\texteuclid(angka,mods,x,y);\n\treturn x;\n}\nM invers(M angka){\n\treturn invers(angka.x);\n}\nvoid precomp(){\n\tfakt[0]=1;\n\tinv[0]=1;\n\tfor(int i=1;i<=MAXNODE;i++)\n\t\tfakt[i]=fakt[i-1]*i;\n\tfor(int i=1;i<=MAXNODE;i++)\n\t\tinv[i]=invers(fakt[i]);\n}\nvoid dfs(int now,int tadi){\n\tpartofcc[now]=true;\n\tcc.pb(now);\n\tfor(auto v:node[now])\n\t{\n\t\tif(v==tadi)\n\t\t\tcontinue;\n\t\tif(partofcc[v])\n\t\t{\n\t\t\tif(rootcc==-1)\n\t\t\t\trootcc=v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdfs(v,now);\n\t\t}\n\t}\n}\nbool isicc(int s){\t\t\t//return valid tidak, dan cari root, dan isi cc\n\tcc.clear();\n\trootcc=-1;\n\tdfs(s,-1);\t\t\t\t//isi cc\n\tassert(rootcc!=-1);\n\tint total=0;\n\tfor(auto isi:cc)\n\t\ttotal+=(node[isi].size())-1;\n\treturn (total==cc.size());\n}\nvoid tentukancycle(int now,int _par){\t\t\t\t//sekalian isi parnya, par root itu teman cyclenya\n\tpar[now]=_par;\n\tfor(auto v:node[now])\n\t{\n\t\tif(v==_par)\n\t\t\tcontinue;\n\t\tif(v==rootcc)\n\t\t{\n\t\t\tpartofcycle[now]=true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(now==rootcc&&partofcycle[v])\t\t\t\t//berarti sudah visited\n\t\t{\n\t\t\t//cout<<\"ketemu par\"<<endl;\n\t\t\tassert(partofcycle[now]);\n\t\t\tpar[now]=v;\n\t\t\tcontinue;\n\t\t}\n\t\ttentukancycle(v,now);\n\t\tif(partofcycle[v])\n\t\t{\n\t\t\tassert(!partofcycle[now]);\n\t\t\tpartofcycle[now]=true;\n\t\t}\n\t}\n}\nvoid bagidag(int jenis){\t\t\t//bagi menjadi dag, tergantung loop ke berapa, loop1 based on par, loop2 yang cycle di reverse\n\tfor(auto isi:cc)\n\t{\n\t\tdag[isi].clear();\n\t\tint patokan;\n\t\tif(jenis==0)\n\t\t\tpatokan=par[isi];\n\t\telse\n\t\t{\n\t\t\tif(partofcycle[isi])\n\t\t\t{\n\t\t\t\tfor(auto v:node[isi])\n\t\t\t\t{\n\t\t\t\t\tif(v==par[isi])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(partofcycle[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tpatokan=v;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tpatokan=par[isi];\n\t\t}\n\t\t\n\t\tfor(auto v:node[isi])\n\t\t{\n\t\t\tif(v>patokan)\n\t\t\t\tdag[isi].pb(v);\n\t\t}\n\t}\n}\nvoid tentukanrootdag(){\t\t\t\t//cari root dari dag\n\tfor(auto isi:cc)\n\t\trootdag[isi]=true;\n\tfor(auto isi:cc)\n\t{\n\t\tfor(auto v:dag[isi])\n\t\t\trootdag[v]=false;\n\t}\n}\nvoid hitungsubtree(int now){\n\tsubtree[now]=1;\n\tfor(auto v:dag[now])\n\t{\n\t\thitungsubtree(v);\n\t\tsubtree[now]+=subtree[v];\n\t}\n\t//cout<<\"subtree dari \"<<now<<\" \"<<subtree[now]<<endl;\n}\nvoid hitungsubtree(){\t\t\t\t//subtree dari dag\n\tfor(auto isi:cc)\n\t{\n\t\tif(rootdag[isi])\n\t\t\thitungsubtree(isi);\n\t}\n}\nM costdag(int now){\t\t\t\t//ini sudah jadi dag\n\tM ret=fakt[subtree[now]-1];\n\tfor(auto v:dag[now])\n\t\tret=ret*costdag(v)*inv[subtree[v]];\n\t//cout<<\"cost dag dari \"<<now<<\" \"<<ret.x<<endl;\n\treturn ret;\n}\nM costdag(){\n\tM ret=fakt[cc.size()];\n\t//cout<<\"ret awal \"<<ret.x<<endl;\n\tfor(auto isi:cc)\n\t{\n\t\tif(!rootdag[isi])\n\t\t\tcontinue;\n\t\t//cout<<\"rootdag \"<<subtree[isi]<<\" \"<<costdag(isi).x<<endl;\n\t\tret=ret*inv[subtree[isi]]*costdag(isi);\n\t}\n\t//cout<<\"cost akhir \"<<ret.x<<endl;\n\treturn ret;\n}\nvoid printtree(int now){\n\tcout<<\"anak dari \"<<now<<endl;\n\tfor(auto v:dag[now])\n\t\tcout<<v<<\" \";\n\tcout<<endl;\n\tfor(auto v:dag[now])\n\t\tprinttree(v);\n}\nvoid solve(){\t\t\t//bagi jadi beberapa cc\n\tans=fakt[2*n];\n\tfor(int i=1;i<=2*n;i++)\n\t{\n\t\tif(partofcc[i])\n\t\t\tcontinue;\n\t\tif(!isicc(i))\n\t\t{\n\t\t\tans=0;\n\t\t\tbreak;\n\t\t}\n\t\t//cout<<\"rootnya \"<<rootcc<<endl;\n\t\ttentukancycle(rootcc,-1);\n\t\t/*cout<<\"ini part of cyclenya \"<<endl;\n\t\tfor(auto isi:cc)\n\t\t\tif(partofcycle[isi])\n\t\t\t\tcout<<isi<<\" \";\n\t\tcout<<endl;*/\n\t\tM costhere;\n\t\tfor(int ulang=0;ulang<2;ulang++)\n\t\t{\n\t\t\t//cout<<\"pengulangan \"<<ulang<<endl;\n\t\t\tbagidag(ulang);\n\t\t\ttentukanrootdag();\n\t\t\t/*for(auto isi:cc)\n\t\t\t\tif(rootdag[isi])\n\t\t\t\t\tprinttree(isi);*/\n\t\t\thitungsubtree();\n\t\t\tcosthere=costhere+costdag();\n\t\t}\n\t\t\n\t\t//updateans\n\t\tcosthere=costhere*inv[(int) cc.size()];\n\t\tans=ans*costhere;\n\t}\n}\nint main()\n{\n\tinis();\n\tprecomp();\n\tscan(n);\n\tfor(int ulang=0;ulang<2;ulang++)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscan(x,y);\n\t\t\tnode[x].pb(y+n);\n\t\t\tnode[y+n].pb(x);\n\t\t}\n\t}\n\tsolve();\n\tprintf(\"%lld\\n\",ans.x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n \nconst int N=200010;\nconst int ha=1e9+7;\nstruct Edge{int to,next;} e[N<<1],et[N<<1];\nint h[N],ht[N],esum=0,tsum=0,n,cmt=0;\nint gay[N],out[N],sz[N];\nbool done[N],inc[N],flag;\nvector<int> crl,vertix;\nstack<int> s;\nint fac[N];\n \nint Pow(int a,int b)\n{\n    int ans=1;\n    for(;b;b>>=1,a=1ll*a*a%ha)\n        if(b&1) ans=1ll*ans*a%ha;\n    return ans;\n}\n \nvoid add_edge(int u,int v)\n{\n    e[++esum]={v,h[u]};h[u]=esum;\n    e[++esum]={u,h[v]};h[v]=esum;\n}\n \nvoid add_topo_edge(int u,int v)\n{\n    out[v]++;\n    et[++tsum].to=v;\n    et[tsum].next=ht[u];\n    ht[u]=tsum;\n}\n \nvoid findcrl(int u,int fa)\n{\n    vertix.push_back(u);\n    done[u]=1;s.push(u);\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa||inc[v]) continue;\n        cmt++;\n        if(!flag&&done[v])\n        {\n            while(s.top()!=v) crl.push_back(s.top()),inc[s.top()]=1,s.pop();\n            crl.push_back(v);inc[v]=1;s.pop();\n            flag=1;\n        }\n        else if(!done[v]) findcrl(v,u);\n    }\n    if(!s.empty()&&s.top()==u) s.pop();\n}\n \nvoid findgay(int u,int fa)\n{\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa||inc[v]) continue;\n        gay[v]=u;findgay(v,u);\n    }\n}\n \nvoid build_topo()\n{\n    for(int u : vertix)\n        for(int t=h[u];t;t=e[t].next)\n        {\n            int v=e[t].to;\n            if(v>=gay[u]) continue;\n            add_topo_edge(u,v);\n        }\n    for(int u : vertix)\n        if(!out[u]) add_topo_edge(0,u);\n    for(int u : vertix) out[u]=0;\n}\n \nvoid getsize(int u)\n{\n    sz[u]=1;\n    for(int t=ht[u];~t;t=et[t].next)\n    {\n        int v=et[t].to;\n        getsize(v);\n        sz[u]+=sz[v];\n    }\n    ht[u]=-1;\n}\n \nint getans()\n{\n    int prodsz=1;getsize(0);\n    for(int u : vertix)\n        prodsz=1ll*prodsz*sz[u]%ha;\n    return Pow(prodsz,ha-2);\n}\n \nint xi_jin_ping_is_good(int u)\n{\n    flag=0;cmt=0;findcrl(u,0);\n    if(vertix.size()!=cmt) return 0;\n    for(int u : crl) if(inc[u]) findgay(u,0);\n    for(int i=0;i<crl.size()-1;i++) gay[crl[i]]=crl[i+1];\n    gay[crl.back()]=crl[0];\n    tsum=-1;build_topo();\n    int res=getans();\n    for(int i=1;i<crl.size();i++) gay[crl[i]]=crl[i-1];\n    gay[crl[0]]=crl.back();\n    tsum=-1;build_topo();\n    res=(res+getans())%ha;\n    vertix.clear();crl.clear();\n    return res;\n}\n \nint main()\n{\n    memset(ht,-1,sizeof(ht));\n    int x,y,ans=1;\n    n=read()<<1;fac[0]=1;\n    for(int i=1;i<=n;i++)\n        fac[i]=1ll*fac[i-1]*i%ha;\n    for(int i=1;i<=n;i++)\n    {\n        x=read();y=read();\n        add_edge(x,y+n/2);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(done[i]) continue;\n        x=xi_jin_ping_is_good(i);\n        if(x==0) return puts(\"0\"),0;\n        ans=1ll*ans*x%ha;\n    }\n    ans=1ll*fac[n]*ans%ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nll len[200], cnt[200][26];\nint sum0[26][100001], sum1[26][200001];\n\nll rec(int n, ll l, ll r, int c){\n\tif(l >= len[n] || r <= 0) return 0;\n\tif(l <= 0 && len[n] <= r) return cnt[n][c];\n\t\n\tl = max(l, 0ll); r = min(r, len[n]);\n\t\n\tif(n <= 1){\n\t\tif(n == 1) return sum1[c][r] - sum1[c][l];\n\t\treturn sum0[c][r] - sum0[c][l];\n\t}\n\treturn rec(n - 1, l, r, c) + rec(n - 2, l - len[n - 1], r - len[n - 1], c);\n}\n\nint* buildFail(const string &s){\n\tint n = s.size();\n\tint *p = new int[n];\n\tp[0] = 0;\n\tfor (int i = 1; i < n; ++i){\n\t\tp[i] = p[i - 1];\n\t\twhile (p[i] > 0 && s[p[i]] != s[i]) p[i] = p[p[i] - 1];\n\t\tif (s[p[i]] == s[i]) p[i]++;\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tstring s;\n\tll l, r; cin >> s >> l >> r; l--;\n\tint n = s.size() / 2;\n\tint *f = buildFail(s.substr(0, n));\n\tint p = n - f[n - 1];\n\t\n\tif(n % p == 0){\n\t\trep(i, 26){\n\t\t\trep(j, p) sum1[i][j + 1] = sum1[i][j] + (s[j] == 'a' + i);\n\t\t\tll k = r / p, m = l / p, cnt = 0;\n\t\t\tcnt += sum1[i][p] * k + sum1[i][r % p];\n\t\t\tcnt -= sum1[i][p] * m + sum1[i][l % p];\n\t\t\tcout << cnt << (i == 25 ? \"\\n\" : \" \");\n\t\t}\n\t}\n\telse{\n\t\tstring t = s.substr(0, n) + s.substr(0, p);\n\t\tlen[0] = n;\n\t\tlen[1] = t.size();\n\t\trep(i, 26){\n\t\t\trep(j, n)        sum0[i][j + 1] = sum0[i][j] + (s[j] == 'a' + i);\n\t\t\trep(j, t.size()) sum1[i][j + 1] = sum1[i][j] + (t[j] == 'a' + i);\n\t\t\tcnt[0][i] = sum0[i][n];\n\t\t\tcnt[1][i] = sum1[i][t.size()];\n\t\t}\n\t\tint m = 1;\n\t\tfor(; len[m] < r; m++){\n\t\t\tlen[m + 1] = len[m] + len[m - 1];\n\t\t\trep(i, 26) cnt[m + 1][i] = cnt[m][i] + cnt[m - 1][i];\n\t\t}\n\t\trep(i, 26) cout << rec(m, l, r, i) << (i == 25 ? \"\\n\": \" \");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\ninline void down(int &x,const int &y){if(x>y)x=y;}\nconst ll Mod = 1e9+7;\nconst int maxn = 810000;\n\nll pw(ll x,int k)\n{\n\tll re=1ll;\n\tfor(;k;k>>=1,x=x*x%Mod) if(k&1)\n\t\tre=re*x%Mod;\n\treturn re;\n}\nint n;\nll s[maxn],sN[maxn];\nvoid pre()\n{\n\ts[0]=1ll;\n\tfor(int i=1;i<=2*n;i++) s[i]=s[i-1]*(ll)i%Mod;\n\tsN[n<<1]=pw(s[n<<1],Mod-2);\n\tfor(int i=2*n-1;i>=0;i--) sN[i]=sN[i+1]*(ll)(i+1)%Mod;\n}\nll C(const int i,const int j){return s[i]*sN[j]%Mod*sN[i-j]%Mod;}\n\nstruct edge{int y,nex;}a[maxn<<1]; int len,fir[maxn];\ninline void ins(const int x,const int y){a[++len]=(edge){y,fir[x]};fir[x]=len;}\nstruct E{int y,c;};\ninline bool operator <(const E x,const E y){return x.c<y.c;}\nvector<E>V[maxn];\n\nint nt[maxn],t[maxn],tp,tn,en;\nint dfn[maxn],low[maxn],id;\nint cir[maxn],cnt; bool inc[maxn];\nvoid tarjan(const int x,const int fa)\n{\n\tdfn[x]=low[x]=++id; t[++tp]=x;\n\tnt[++tn]=x; en+=V[x].size();\n\tfor(int i=0;i<V[x].size();i++)\n\t{\n\t\tint y=V[x][i].y; if(y==fa) continue;\n\t\tif(!dfn[y]) \n\t\t{\n\t\t\ttarjan(y,x);\n\t\t\tif(low[y]==dfn[x])\n\t\t\t{\n\t\t\t\tcnt=0;\n\t\t\t\tint la=0;\n\t\t\t\twhile(la!=x)\n\t\t\t\t\tinc[cir[++cnt]=la=t[tp--]]=true;\n\t\t\t}\n\t\t\telse if(low[y]>dfn[x]) tp--;\n\t\t\tdown(low[x],low[y]);\n\t\t}\n\t\telse down(low[x],dfn[y]);\n\t}\n}\nint match[maxn];\nvoid divide(const int x,const int fa)\n{\n\tfor(int i=0;i<V[x].size();i++)\n\t{\n\t\tint y=V[x][i].y; if(inc[y]||y==fa)continue;\n\t\tmatch[y]=x;\n\t\tdivide(y,x);\n\t}\n}\nll f[maxn]; int siz[maxn];\nvoid dp(const int x)\n{\n\tsiz[x]=0;\n\tf[x]=1ll;\n\tfor(int k=fir[x],y=a[k].y;k;k=a[k].nex,y=a[k].y)\n\t{\n\t\tdp(y);\n\t\tf[x]=f[x]*f[y]%Mod*C((siz[x]+=siz[y]),siz[y])%Mod;\n\t}\n\tsiz[x]++;\n}\nint In[maxn];\nll count()\n{\n\tlen=0; for(int i=1,x=nt[i];i<=tn;i++,x=nt[i]) fir[x]=In[x]=siz[x]=0;\n\tfor(int i=1,x=nt[i];i<=tn;i++,x=nt[i])\n\t{\n\t\tfor(int j=0;j<V[x].size()&&V[x][j].y!=match[x];j++)\n\t\t\tins(x,V[x][j].y),In[V[x][j].y]++;\n\t}\n\tll ret=1; int sn=0;\n\tfor(int i=1,x=nt[i];i<=tn;i++,x=nt[i]) if(!In[x])\n\t{\n\t\tdp(x);\n\t\tret=ret*f[x]%Mod*C((sn+=siz[x]),siz[x])%Mod;\n\t}\n\treturn ret;\n}\nll re;\nvoid solve(const int i)\n{\n\tre=0;\n\ttn=en=0; tarjan(i,0); en>>=1;\n\tif(tn!=en) {re=0; return;}\n\tfor(int i=1;i<=cnt;i++) divide(cir[i],0);\n\tfor(int i=1;i<=cnt;i++) match[cir[i]]=i-1>0?cir[i-1]:cir[cnt];\n\tre+=count();\n\tfor(int i=1;i<=cnt;i++) match[cir[i]]=i+1<=cnt?cir[i+1]:cir[1];\n\tre+=count();\n\tre%=Mod;\n}\n\nll ans; int nown;\nint main()\n{\n\tscanf(\"%d\",&n); pre();\n\tfor(int i=1;i<=2*n;i++)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tV[x].push_back((E){n+y,x+y});\n\t\tV[n+y].push_back((E){x,x+y});\n\t}\n\tfor(int i=1;i<=2*n;i++)\n\t\tsort(V[i].begin(),V[i].end());\n\t\n\tnown=0; ans=1ll;\n\tfor(int i=1;i<=n;i++) if(!dfn[i])\n\t{\n\t\tsolve(i);\n\t\tif(!re) {ans=0; break;}\n\t\tans=ans*re%Mod*C(nown+tn,tn)%Mod;\n\t\tnown+=tn;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            chain_t c = use_generic(i, true);\n            return c * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            chain_t c = use_generic(i, false);\n            return c * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        REP (y, n) acc = acc * go_row(y);\n        REP (x, n) acc = acc * go_col(x);\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                // assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                // assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                // assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nnamespace zyt\n{\n\ttemplate<typename T>\n\tinline bool read(T &x)\n\t{\n\t\tchar c;\n\t\tbool f = false;\n\t\tx = 0;\n\t\tdo\n\t\t\tc = getchar();\n\t\twhile (c != EOF && c != '-' && !isdigit(c));\n\t\tif (c == EOF)\n\t\t\treturn false;\n\t\tif (c == '-')\n\t\t\tf = true, c = getchar();\n\t\tdo\n\t\t\tx = x * 10 + c - '0', c = getchar();\n\t\twhile (isdigit(c));\n\t\tif (f)\n\t\t\tx = -x;\n\t\treturn true;\n\t}\n\ttemplate<typename T>\n\tinline void write(T x)\n\t{\n\t\tstatic char buf[20];\n\t\tchar *pos = buf;\n\t\tif (x < 0)\n\t\t\tputchar('-'), x = -x;\n\t\tdo\n\t\t\t*pos++ = x % 10 + '0';\n\t\twhile (x /= 10);\n\t\twhile (pos > buf)\n\t\t\tputchar(*--pos);\n\t}\n\ttypedef pair<int, int> pii;\n\ttypedef long long ll;\n\tconst int N = 2e5 + 10, p = 1e9 + 7;\n\tint head[N], fac[N], inv[N], finv[N], ecnt, n;\n\tbool mark[N], vis[N];\n\tstruct edge\n\t{\n\t\tint to, w;\n\t\tbool tag;\n\t\tint next;\n\t}e[N << 1];\n\tvoid add(const int a, const int b, const int c)\n\t{\n\t\te[ecnt] = (edge){b, c, false, head[a]}, head[a] = ecnt++;\n\t}\n\tint fa[N], ptnum[N], ednum[N];\n\tint f(const int x)\n\t{\n\t\treturn x == fa[x] ? x : fa[x] = f(fa[x]);\n\t}\n\tbool findrot(const int u, const int f, vector<int> &ve)\n\t{\n\t\tif (vis[u])\n\t\t\treturn true;\n\t\tvis[u] = true;\n\t\tfor (int i = head[u]; ~i; i = e[i].next)\n\t\t{\n\t\t\tint v = e[i].to;\n\t\t\tif (v == f)\n\t\t\t\tcontinue;\n\t\t\tif (findrot(v, u, ve))\n\t\t\t{\n\t\t\t\tve.push_back(i);\n\t\t\t\treturn u != e[*ve.begin()].to;\n\t\t\t}\n\t\t}\n\t\tvis[u] = false;\n\t\treturn false;\n\t}\n\tint size[N];\n\tint dfs(const int u, const int f, const int from, bool rot, vector<pii> &ans)\n\t{\n\t\tint mul = 1;\n\t\tsize[u] = 1;\n\t\tfor (int i = head[u]; ~i; i = e[i].next)\n\t\t{\n\t\t\tint v = e[i].to;\n\t\t\tif ((i ^ 1) == from || e[i].tag)\n\t\t\t\tcontinue;\n\t\t\tmul = ll(mul) * dfs(v, u, i, f && f < v, ans) % p;\n\t\t\tif (!(f && f < v))\n\t\t\t\tsize[u] += size[v];\n\t\t}\n\t\tmul = (ll)mul * size[u] % p;\n\t\tif (rot)\n\t\t{\n\t\t\tans.push_back(pii((ll)fac[size[u]] * inv[mul] % p, size[u]));\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\treturn mul;\n\t}\n\tint cal(const vector<pii> &buf)\n\t{\n\t\tint ans = 1, mul = 1, sum = 0;\n\t\tfor (auto it = buf.begin(); it != buf.end(); it++)\n\t\t\tans = (ll)ans * it->first % p, mul = (ll)mul * finv[it->second] % p, sum = (sum + it->second) % p;\n\t\tans = (ll)ans * mul % p * fac[sum] % p;\n\t\treturn ans;\n\t}\n\tint solve(const int u)\n\t{\n\t\tstatic vector<int> ve;\n\t\tstatic vector<pii> ans1, ans2;\n\t\tve.clear();\n\t\tans1.clear();\n\t\tans2.clear();\n\t\tfindrot(u, 0, ve);\n\t\tpii mx = pii(-1, -1);\n\t\tfor (int i = 0; i < ve.size(); i++)\n\t\t\tmx = max(mx, pii(e[ve[i]].w, ve[i]));\n\t\tint a = e[mx.second].to, b = e[mx.second ^ 1].to;\n\t\te[mx.second].tag = e[mx.second ^ 1].tag = true;\n\t\tdfs(a, b, -1, true, ans1);\n\t\tdfs(b, a, -1, true, ans2);\n\t\treturn (cal(ans1) + cal(ans2)) % p;\n\t}\n\tinline void init()\n\t{\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < N; i++)\n\t\t\tinv[i] = ll(p - p / i) * inv[p % i] % p;\n\t\tfac[0] = finv[0] = 1;\n\t\tfor (int i = 1; i < N; i++)\n\t\t{\n\t\t\tfac[i] = (ll)fac[i - 1] * i % p;\n\t\t\tfinv[i] = (ll)finv[i - 1] * inv[i] % p;\n\t\t}\n\t}\n\tint work()\n\t{\n\t\tinit();\n\t\tread(n);\n\t\tmemset(head, -1, sizeof(int[n * 2 + 1]));\n\t\tfor (int i = 1; i <= (n << 1); i++)\n\t\t\tfa[i] = i, ptnum[i] = 1, ednum[i] = 0;\n\t\tfor (int i = 1; i <= (n << 1); i++)\n\t\t{\n\t\t\tint u, v, x, y;\n\t\t\tread(u), read(v);\n\t\t\tadd(u, v + n, u + v), add(v + n, u, u + v);\n\t\t\tx = f(u), y = f(v + n);\n\t\t\tif (x != y)\n\t\t\t\tfa[x] = y, ptnum[y] += ptnum[x], ednum[y] += ednum[x];\n\t\t\t++ednum[y];\n\t\t}\n\t\tn *= 2;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (i == fa[i] && ptnum[i] != ednum[i])\n\t\t\t{\n\t\t\t\twrite(0);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tstatic vector<pii> tmp;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (i == fa[i])\n\t\t\t\ttmp.push_back(pii(solve(i), ptnum[i]));\n\t\twrite(cal(tmp));\n\t\treturn 0;\n\t}\n}\nint main()\n{\n#ifdef BlueSpirit\n\tfreopen(\"3537.in\", \"r\", stdin);\n#endif\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#define MOD 1000000007\ntypedef long long ll; \ninline int quick_pow(int a, int n)\n{\n\tint res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (ll)res * a % MOD; \n\t\ta = (ll)a * a % MOD; \n\t\tn >>= 1; \n\t}\n\treturn res; \n}\nstd::map<int, int> idx_e[200005]; \nint lst[200005], to[400005], pre[400005], w[400005], tot; \nint st[200005], vis[200005], sz[200005], e, tp; \nint fact[200005], inv[200005], dp[200005], res; \nbool cyc, del[400005]; \ninline void add_edge(int u, int v, int _w)\n{\n\tto[tot] = v; \n\tpre[tot] = lst[u]; \n\tw[tot] = _w; \n\tidx_e[u][v] = tot; \n\tlst[u] = tot++; \n}\nvoid dfs(int u, int fa = -1)\n{\n\tvis[u] = 1; \n\tst[tp++] = u; \n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tint v = to[i]; \n\t\tif (v == fa)\n\t\t\tcontinue; \n\t\tif (vis[v] == 1)\n\t\t{\n\t\t\te = i; \n\t\t\tfor (int j = tp - 2; j >= 0; j--)\n\t\t\t{\n\t\t\t\tint cur = idx_e[st[j]][st[j + 1]]; \n\t\t\t\tif (w[cur] > w[e])\n\t\t\t\t\te = cur;\n\t\t\t\tif (st[j] == v)\n\t\t\t\t\tbreak; \n\t\t\t}\n\t\t\tif (cyc)\n\t\t\t{\n\t\t\t\tputs(\"0\");\n\t\t\t\texit(0); \n\t\t\t}\n\t\t\tcyc = true; \n\t\t}\n\t\telse if (!vis[v])\n\t\t\tdfs(v, u); \n\t}\n\tvis[u] = 2; \n\ttp--; \n}\nvoid work(int u, int fae)\n{\n\tsz[u] = 0; \n\tdp[u] = 1; \n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tint v = to[i]; \n\t\tif (i == fae || del[i])\n\t\t\tcontinue; \n\t\twork(v, i ^ 1); \n\t\tif (w[i] > w[fae])\n\t\t\tres = (ll)res * inv[sz[v]] % MOD * dp[v] % MOD; \n\t\telse\n\t\t{\n\t\t\tsz[u] += sz[v]; \n\t\t\tdp[u] = (ll)dp[u] * dp[v] % MOD * fact[sz[u]] % MOD * inv[sz[v]] % MOD * inv[sz[u] - sz[v]] % MOD; \n\t\t}\n\t}\n\tsz[u]++; \n}\nint main()\n{\n\t// freopen(\"ARC083-F.in\", \"r\", stdin); \n\tmemset(lst, -1, sizeof(lst)); \n\tint n; \n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n << 1; i++)\n\t{\n\t\tint x, y; \n\t\tscanf(\"%d%d\", &x, &y); \n\t\tx--; \n\t\ty--; \n\t\tadd_edge(x, y + n, x + y); \n\t\tadd_edge(y + n, x, x + y); \n\t}\n\tn <<= 1; \n\tfact[0] = inv[0] = 1; \n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD; \n\t\tinv[i] = quick_pow(fact[i], MOD - 2); \n\t}\n\tint ans = fact[n]; \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (vis[i])\n\t\t\tcontinue; \n\t\tcyc = false; \n\t\tdfs(i, 0); \n\t\tdel[e] = del[e ^ 1] = true; \n\t\tint sum = 0; \n\t\tres = 1; \n\t\twork(to[e], e ^ 1); \n\t\tsum += (ll)inv[sz[to[e]]] * dp[to[e]] % MOD * res % MOD; \n\t\tres = 1; \n\t\twork(to[e ^ 1], e); \n\t\tsum += (ll)inv[sz[to[e ^ 1]]] * dp[to[e ^ 1]] % MOD * res % MOD; \n\t\tans = (ll)ans * sum % MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nint n,cnt=0,num=0;\nvi x,y,ax,ay,vis,b,c,d,used;\nvl dp;\nvvi g,G;\nvvp X,Y;\n\nint dfs(int v,int w){\n\tb.push_back(v);\n\tvis[v]++;cnt++;\n\tif(!ax[x[v]]) num++,ax[x[v]]=1;\n\tif(!ay[y[v]]) num++,ay[y[v]]=1;\n\tint t=-1;\n\tfor(auto u:g[v]) if(u!=-1&&u!=w){\n\t\tif(vis[u]&&w!=-1){\n\t\t\tint I=d.size()-1;\n\t\t\tpip p={{x[u],y[u]},u};\n\t\t\twhile(I>=0&&d[I]!=u){\n\t\t\t\tint u_=d[I--];\n\t\t\t\tp=min(p,{{x[u_],y[u_]},u_});\n\t\t\t}\n\t\t\tt=p.second;\n\t\t}\n\t\telse if(!vis[u]){\n\t\t\td.push_back(u);\n\t\t\tint t_=dfs(u,v);\n\t\t\tif(t_!=-1) t=t_;\n\t\t\td.pop_back();\n\t\t}\n\t}\n\treturn t;\n}\n\nvoid DFS(int v,int I){\n\tint u=g[v][I];\n\tif(u==-1||c[u]!=-1) return;\n\tc[u]=1-I%2;\n\tfor(int i=0;i<4;i++){\n\t\tint w=g[u][i];\n\t\tif(w!=-1&&c[w]==-1) DFS(u,i);\n\t}\n}\n\npll Rec(int v){\n\tll res=1,S=0;\n\tfor(auto u:G[v]){\n\t\tpll p=Rec(u);\n\t\tll T=p.second;\n\t\tres=Div(res*p.first%mod,F[T]);\n\t\tS+=T;\n\t}\n\t(res*=F[S])%=mod;\n\treturn {res,S+1};\n}\n\nll f(int v,int t){\n\tc[v]=t;\n\tfor(int i=0;i<4;i++) DFS(v,i%2*2+abs(i/2-t));\n\tfor(auto i:b){\n\t\tint u=g[i][c[i]];\n\t\twhile(u!=-1){\n\t\t\tG[i].push_back(u);\n\t\t\tused[u]=1;\n\t\t\tu=g[u][c[i]];\n\t\t}\n\t}\n\tfor(auto i:b) if(!used[i]) G[n].push_back(i);\n\tll res=Rec(n).first;\n\tfor(auto i:b){\n\t\tc[i]=-1;\n\t\tused[i]=0;\n\t\tG[i].clear();\n\t}\n\tG[n].clear();\n\treturn res;\n}\n\nint main(){\n\tInit();\n\tcin>>n;\n\tn*=2;\n\tx=y=ax=ay=vis=used=vi(n);\n\tc=vi(n,-1);\n\tX=Y=vvp(n);\n\tg=vvi(n,vi(4,-1));\n\tG=vvi(n+1);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tx[i]--;y[i]--;\n\t\tX[x[i]].push_back({y[i],i});\n\t\tY[y[i]].push_back({x[i],i});\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tsort(X[i].begin(),X[i].end());\n\t\tsort(Y[i].begin(),Y[i].end());\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<X[i].size();j++){\n\t\t\tint u=X[i][j-1].second,v=X[i][j].second;\n\t\t\tg[u][3]=v;g[v][1]=u;\n\t\t}\n\t\tfor(int j=1;j<Y[i].size();j++){\n\t\t\tint u=Y[i][j-1].second,v=Y[i][j].second;\n\t\t\tg[u][2]=v;g[v][0]=u;\n\t\t}\n\t}\n\tll res=F[n];\n\tfor(int i=0;i<n;i++) if(!vis[i]){\n\t\tcnt=0;num=0;\n\t\tb.clear();d.clear();\n\t\td.push_back(i);\n\t\tint v=dfs(i,-1);\n\t\td.pop_back();\n//\t\tres=(cnt==num?Div(res*(f(v,0)+f(v,1))%mod,F[cnt]):0);\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\nconst int p=1e9+7;\n\nint Pow(int a,int b){\n\tint res=1;\n\tfor (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;\n\treturn res;\n}\n\nstruct Edge{\n\tint y,nxt;\n} E[N*2];\n\nVi V[N],P;\nint fac[N],inv[N],las[N],vis[N],chk[N],nxt[N],sz[N],deg[N];\nint n,num,tmp,ans,cnt,v,e,a,b,v2,num2,tmp2,alb,x,y;\n\nint C(int n,int m){\n\treturn 1ll*fac[n]*inv[m]%p*inv[n-m]%p;\n}\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tv++;\n\tfor (int i=las[x],y;~i;i=E[i].nxt){\n\t\te++;\n\t\tif (!vis[y=E[i].y]) dfs(y);\n\t}\n}\nvoid dfs(int x,int fa){\n\tP.pb(x);\n\tchk[x]=1;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (i!=fa){\n\t\t\tif (!chk[y=E[i].y]){\n\t\t\t\tdfs(y,i^1);\n\t\t\t} else{\n\t\t\t\ta=x,b=y;\n\t\t\t}\n\t\t}\n}\nvoid gao(int x,int fa){\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif ((y=E[i].y)!=fa){\n\t\t\tif (x==a&&y==b) continue;\n\t\t\tif (x==b&&y==a) continue;\n\t\t\tnxt[y]=x;\n\t\t\tgao(y,x);\n\t\t}\n}\nint bao(int x){\n\tchk[x]=2;\n\tint ans=1;\n\tsz[x]=0;\n\tfor (int y:V[x]){\n\t\tans=1ll*ans*bao(y)%p*C(sz[x]+sz[y],sz[y])%p;\n\t\tsz[x]+=sz[y];\n\t}\n\tsz[x]++;\n\treturn ans;\n}\nvoid Work(int x){\n\tP.clear();\n\ttmp=0;\n\tdfs(x,-1);\n\t\n\talb=1;\n\tgao(a,-1);\n\tnxt[a]=b;\n\tfor (int i:P) if (i<nxt[nxt[i]]){\n\t\tV[nxt[i]].pb(i);\n\t\tdeg[i]++;\n\t}\n\tnum2=0;\n\tfor (int i:P) if (deg[i]==0&&chk[i]!=2){\n\t\talb=1ll*alb*bao(i)%p*C(num2+sz[i],sz[i])%p;\n\t\tnum2+=sz[i];\n\t}\n\tfor (int i:P){\n\t\tV[i].clear();\n\t\tdeg[i]=0;\n\t\tchk[i]=0;\n\t}\n\t//printf(\"%d\\n\",alb);\n\ttmp=(tmp+alb)%p;\n\t\n\talb=1;\n\tgao(b,-1);\n\tnxt[b]=a;\n\tfor (int i:P) if (i<nxt[nxt[i]]){\n\t\tV[nxt[i]].pb(i);\n\t\tdeg[i]++;\n\t}\n\tnum2=0;\n\tfor (int i:P) if (deg[i]==0&&chk[i]!=2){\n\t\talb=1ll*alb*bao(i)%p*C(num2+sz[i],sz[i])%p;\n\t\tnum2+=sz[i];\n\t}\n\t//printf(\"%d\\n\",alb);\n\ttmp=(tmp+alb)%p;\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tfac[0]=1;\n\tFor(i,1,N) fac[i]=1ll*fac[i-1]*i%p;\n\tinv[N-1]=Pow(fac[N-1],p-2);\n\tfor (int i=N-1;i;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tn=IN()*2;\n\tFor(i,1,n+1){\n\t\tx=IN(),y=IN();\n\t\tLink(x,y+n/2);\n\t}\n\tans=1;\n\tFor(i,1,n+1) if (!vis[i]){\n\t\tv=0,e=0;\n\t\tdfs(i);\n\t\tif (v!=e/2){\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tWork(i);\n\t\tans=1ll*ans*tmp%p*C(num+v,v)%p;\n\t\tnum+=v;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m;\nvector<int>E[N];\n#define pb push_back\nvoid input()\n{\n\tint x,y;\n\tn=read<int>();\n\tFor(i,1,n<<1)\n\t{\n\t\tx=read<int>(),y=read<int>()+n;\n\t\tE[x].pb(y),E[y].pb(x);\n\t}\n}\nconst int mo=1e9+7;\nint ans,inv[N];\nint vis[N],edge;\nint node[N],cnt;\nint c[N],top;\nint fa[N];\nint stk[N],tp;\nvoid dfs1(int u,int pre)\n{\n\t//cerr<<u<<endl;\n\tnode[++cnt]=u;stk[++tp]=u,vis[u]=1,stk[tp+1]=0;\n\t//cerr<<cnt<<endl;\n\tedge+=(int)E[u].size();\n\tfor(int v:E[u])if(v^pre)\n\t{\n\t\tif(!vis[v])dfs1(v,u);\n\t\telse if(!top)\n\t\t{\n\t\t\twhile(stk[tp+1]!=v)vis[c[++top]=stk[tp--]]=2;\n\t\t\tc[0]=v;\n\t\t}\n\t}\n\tif(!top)--tp;\n}\nvoid dfs2(int u,int pre)\n{\n\tfor(int v:E[u])if(v^pre&&vis[v]<2)\n\t{\n\t\tfa[v]=u;\n\t\tdfs2(v,u);\n\t}\n}\nvector<int>G[N];\nint d[N],sz[N];\nvoid dfs3(int u,int &res)\n{\n\tsz[u]=1;\n\tfor(int v:G[u])\n\t{\n\t\tdfs3(v,res);\n\t\tsz[u]+=sz[v];\n\t}\n\tres=1ll*res*inv[sz[u]]%mo;\n}\nint cal()\n{\n\tint res=1;\n\tFor(i,1,cnt)\n\t{\n\t\tres=1ll*res*i%mo;\n\t\td[node[i]]=0;\n\t\tG[node[i]].clear();\n\t}\n\tFor(i,1,cnt)\n\t{\n\t\tfor(int v:E[node[i]])if(v<fa[node[i]])\n\t\t{\n\t\t\tG[node[i]].pb(v);d[v]++;\n\t\t}\n\t}\n\tFor(i,1,cnt)if(!d[node[i]])dfs3(node[i],res);\n\treturn res;\n}\nvoid init(int st)\n{\n\tint res=0;\n\tcnt=top=tp=edge=0;\t\n\tdfs1(st,0);\t\n\tif(edge!=(cnt<<1)){puts(\"0\");exit(0);}\n\tFor(i,1,top)dfs2(c[i],0);\t\n\tFor(i,1,top)fa[c[i-1]]=c[i];\n\tres=cal();\n\tFor(i,1,top)fa[c[i]]=c[i-1];\n\tres=(res+cal())%mo;\n\tans=1ll*ans*res%mo;\n\tFor(i,1,cnt)ans=1ll*ans*inv[i]%mo;\n\t//cerr<<cnt<<endl;\n}\nvoid work()\n{\n\tans=1;\n\tinv[0]=inv[1]=1;\n\tFor(i,2,n<<1)ans=1ll*ans*i%mo,inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,n<<1)if(!vis[i])init(i);\n\twrite(ans,'\\n');\n}\nint main()\n{\n\n\tinput();\n\twork();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\ntypedef long long ll;\n\nconst int N=200005,P=1000000007;\nint n,Ans=1,Res;\nint Head[N],Next[N<<1],To[N<<1],Val[N<<1],En;\nint Vis[N],Sta[N],Top,w[N],f,a,b,c,s[N];\n\nll Inv(ll a,ll s=1){for(int b=P-2;b;b>>=1,a=a*a%P)if(b&1)s=s*a%P;return s%P;}\ninline void Add(int x,int y,int z){Next[++En]=Head[x],To[Head[x]=En]=y,Val[En]=z;}\n\nvoid DFS1(int x,int Fa)\n{\n    Vis[x]=2,Sta[++Top]=x;\n    for(int i=Head[x],y;i;i=Next[i])\n        if((y=To[i])!=Fa)\n        {\n            if(Vis[y]==2)\n            {\n                a=x,b=y,c=Val[i],++f;\n                int Ts=Top;\n                do if(w[--Ts]>c)a=Sta[Ts],b=Sta[Ts+1],c=w[Ts];\n                while(Sta[Ts]!=y);\n            }\n            else if(!Vis[y])w[Top]=Val[i],DFS1(y,x);\n        }\n    Vis[x]=1,--Top;\n}\n\nvoid DFS2(int x,int Fa,int w)\n{\n    s[x]=1;\n    for(int i=Head[x],y;i;i=Next[i])\n        if((y=To[i])!=Fa&&y!=a&&(x!=a||y!=b))\n            if(DFS2(y,x,Val[i]),Val[i]<w)\n                s[x]+=s[y];\n    Res=Res*Inv(s[x])%P;\n}\n\nint main()\n{\n    scanf(\"%d\",&n),n<<=1;\n    for(int i=1,x,y;i<=n;++i)scanf(\"%d%d\",&x,&y),Add(x,y+n/2,x+y),Add(y+n/2,x,x+y);\n    for(int i=1;i<=n;++i)Ans=(ll)Ans*i%P;\n    for(int i=1,Tmp;i<=n;++i)\n        if(!Vis[i])\n        {\n            f=0,DFS1(i,0);\n            if(f!=1)return puts(\"0\"),0;\n            Res=1,DFS2(a,0,c);\n            Tmp=Res,std::swap(a,b);\n            Res=1,DFS2(a,0,c);\n            Ans=Ans*ll(Tmp+Res)%P;\n        }\n    printf(\"%d\\n\",Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nconst int mod=1e9+7;\nint n,ans;\nint x[maxn],y[maxn],par[maxn],dep[maxn],deg[maxn];\nbool vis[maxn],incyc[maxn];\nvector<int>edge[maxn],cyc,nedge[maxn],path,qryx[maxn],qryy[maxn];\nint fac[maxn],ifac[maxn],dp[maxn],sz[maxn];\nbool ok;\nvector<pii>xs[maxn],ys[maxn];\n\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nvoid dfs1(int x,int p,int d){\n\tvis[x]=true;\n\tpar[x]=p;\n\tdep[x]=d;\n\tpath.pb(x);\n\trep(i,edge[x].size()){\n\t\tint y=edge[x][i];\n\t\tif(y==p||incyc[y])continue;\n\t\tif(!vis[y])dfs1(y,x,d+1);\n\t\telse if(dep[y]<dep[x]){\n\t\t\tif(!cyc.empty())ok=false;\n\t\t\tint z=x;\n\t\t\twhile(z!=y)cyc.pb(z),z=par[z];\n\t\t\tcyc.pb(z);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x){\n\tdp[x]=1;\n\tsz[x]=0;\n\trep(i,nedge[x].size()){\n\t\tint y=nedge[x][i];\n\t\tdfs2(y);\n\t\tdp[x]=1LL*dp[x]*C(sz[x]+sz[y],sz[y])%mod*dp[y]%mod; \n\t\tsz[x]+=sz[y];\n\t}\n\tsz[x]++;\n}\n\nvoid add(int cur,int nxt){\n\tif(cur<=n){\n\t\tint pos=lower_bound(xs[cur].begin(),xs[cur].end(),mp(nxt-n,0))-xs[cur].begin();\n\t\tqryx[cur].pb(pos);\n\t}\n\telse{\n\t\tint pos=lower_bound(ys[cur-n].begin(),ys[cur-n].end(),mp(nxt,0))-ys[cur-n].begin();\n\t\tqryy[cur-n].pb(pos);\n\t}\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2*n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,2*n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tREP(i,2*n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\txs[x[i]].pb(mp(y[i],i));\n\t\tys[y[i]].pb(mp(x[i],i));\n\t\tedge[x[i]].pb(y[i]+n);\n\t\tedge[y[i]+n].pb(x[i]);\n\t}\n\tREP(i,n){\n\t\tsort(xs[i].begin(),xs[i].end());\n\t\tsort(ys[i].begin(),ys[i].end());\n\t}\n\tans=1;\n\tint tsz=0;\n\tREP(i,2*n)if(!vis[i]){\n\t\tok=true;\n\t\tcyc.clear();\n\t\tpath.clear();\n\t\tdfs1(i,0,0);\n\t\tif(cyc.empty())ok=false;\n\t\tif(!ok){\n\t\t\tans=0;\n\t\t\tbreak;\n\t\t}\n\t\trep(j,cyc.size())incyc[cyc[j]]=true;\n\t\trep(j,path.size())vis[path[j]]=false;\n\t\tpath.clear();\n\t\trep(j,cyc.size())dfs1(cyc[j],0,0);\n\t\tint sum=0;\n\t\tvector<int>v;\n\t\trep(j,path.size()){\n\t\t\tint x=path[j];\n\t\t\tif(x<=n)rep(k,xs[x].size())v.pb(xs[x][k].snd);\n\t\t\telse rep(k,ys[x-n].size())v.pb(ys[x-n][k].snd);\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tv.resize(unique(v.begin(),v.end())-v.begin());\n\t\tfor(int t=-1;t<=1;t+=2){\n\t\t\trep(j,path.size())if(!incyc[path[j]])add(path[j],par[path[j]]);\n\t\t\trep(j,cyc.size())add(cyc[j],cyc[(j+t+int(cyc.size()))%int(cyc.size())]);\n\t\t\trep(j,path.size()){\n\t\t\t\tint x=path[j];\n\t\t\t\tif(x<=n){\n\t\t\t\t\tsort(qryx[x].begin(),qryx[x].end());\n\t\t\t\t\tint last=0;\n\t\t\t\t\trep(k,qryx[x].size()){\n\t\t\t\t\t\tfor(int p=last;p<qryx[x][k];p++){\n\t\t\t\t\t\t\tnedge[xs[x][qryx[x][k]].snd].pb(xs[x][p].snd);\n\t\t\t\t\t\t\tdeg[xs[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryx[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryx[x].clear();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx-=n;\n\t\t\t\t\tsort(qryy[x].begin(),qryy[x].end());\n\t\t\t\t\tint last=0;\n\t\t\t\t\trep(k,qryy[x].size()){\n\t\t\t\t\t\tfor(int p=last;p<qryy[x][k];p++){\n\t\t\t\t\t\t\tnedge[ys[x][qryy[x][k]].snd].pb(ys[x][p].snd);\n\t\t\t\t\t\t\tdeg[ys[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryy[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryy[x].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cur=1,csz=0;\n\t\t\trep(j,v.size())if(!deg[v[j]]){\n\t\t\t\tdfs2(v[j]);\n\t\t\t\tcur=1LL*cur*dp[v[j]]%mod*C(csz+sz[v[j]],sz[v[j]])%mod;\n\t\t\t\tcsz+=sz[v[j]];\n\t\t\t}\n\t\t\trep(j,v.size())nedge[v[j]].clear(),deg[v[j]]=0;\n\t\t\tsum=(sum+cur)%mod;\n\t\t}\n\t\tans=1LL*ans*sum%mod*C(tsz+v.size(),v.size())%mod;\n\t\ttsz+=v.size();\n\t}\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\nnamespace IO {\n    template <typename _T>\n    inline bool read (_T& x) {\n        x = 0;\n        _T y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return false;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return true;\n    }\n\n    template <typename _T>\n    inline _T input () {\n        _T x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return x;\n    }\n};\nusing namespace IO;\n\nnamespace modular {\n    const int MOD = 1000000007;\n\n    inline int add (int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n\n    inline void inc (int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n\n    inline int mul (int x, int y) { return 1LL * x * y % MOD; }\n\n    inline int qpow (int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x)) if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};\nusing namespace modular;\n\n#define reg register\n#define MAX_N 200007\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define lep(i, l, r) for(int i = l; i < r; ++i)\n#define irep(i, r, l) for(int i = r; i >= l; --i)\n#define ilep(i, r, l) for(int i = r; i > l; --i)\ntypedef long long ll;\n\nstruct edge {\n    int head[MAX_N], to[MAX_N << 1], nxt[MAX_N << 1], val[MAX_N << 1], cap;\n    edge () : cap(0) {}\n    inline void addE (int u, int v, int w = 0) {\n        nxt[++cap] = head[u];\n        head[u] = cap;\n        to[cap] = v;\n        val[cap] = w;\n    }\n}E, en;\n\nint N, M, res = 1, ans = 0, totv, tote, now;\nint dep[MAX_N], st[MAX_N], top, fa[MAX_N], val[MAX_N];\nint vert[MAX_N], tp;\nint deg[MAX_N], fac[MAX_N], ifac[MAX_N];\nbool vis[MAX_N], vise[MAX_N], onc[MAX_N];\n\nbool findcir (int x, int las = 0) {\n    if (vis[x]) return false;\n    totv++;\n    vis[x] = true;\n    vert[++tp] = x;\n    bool flag = false;\n    for (int i = E.head[x]; i; i = E.nxt[i]) {\n        // printf(\"%d %d\\n\", x, E.to[i]);\n        tote++;\n        if (!vis[E.to[i]]) {\n            if (findcir(E.to[i], x)) flag = true;\n        } else if (E.to[i] != las && x != now) {\n            // printf(\"%d %d\\n\", x, E.to[i]);\n            flag = true;\n            now = E.to[i];\n        }\n    }\n    // printf(\"%d %d\\n\", x, flag);\n    if (flag) onc[x] = true, st[++top] = x;\n    // printf(\"%d %d\\n\", x, flag);\n    return flag && (now != x);\n}\n\nvoid getd (int x, int las) {\n    for (int i = E.head[x]; i; i = E.nxt[i])\n        if (E.to[i] != las && !onc[E.to[i]]) {\n            dep[E.to[i]] = dep[x] + 1;\n            fa[E.to[i]] = x, val[E.to[i]] = E.val[i];\n            getd(E.to[i], x);\n        }\n}\n\nvoid getc (int x, int las, int t) {\n    for (int i = E.head[x], v = E.to[i]; i; i = E.nxt[i], v = E.to[i])\n        if (onc[v] && v != las) {\n            fa[x] = v, val[x] = E.val[i];\n            if (v != t) getc(v, x, t);\n        }\n}\n\nint f[MAX_N], sz[MAX_N];\n\ninline int C (int x, int y) {\n    if (x < y || y < 0) return 0;\n    return mul(fac[x], mul(ifac[y], ifac[x - y]));\n}\n\nvoid dp (int x) {\n    // printf(\"%d\\n\", x);\n    sz[x] = f[x] = 1;\n    for (int i = en.head[x], v = en.to[i]; i; i = en.nxt[i], v = en.to[i]) {\n        dp(v);\n        f[x] = mul(f[x], mul(f[v], ifac[sz[v]]));\n        // f[x] = mul(mul(f[x], f[v]), C(sz[x] + sz[v] - 1, sz[v]));\n        sz[x] += sz[v];\n    }\n    f[x] = mul(f[x], fac[sz[x] - 1]);\n}\n\ninline void solve () {\n    en.cap = 0;\n    rep (i, 1, tp) en.head[vert[i]] = 0;\n    en.head[M + 1] = 0;\n    rep (t, 1, tp) {\n        int x = vert[t];\n        // printf(\"%d %d %d\\n\", x, fa[x], val[x]);\n        for (int i = E.head[x], v = E.to[i]; i; i = E.nxt[i], v = E.to[i])\n            if (v != fa[x] && E.val[i] < val[x]) {\n                // printf(\"%d %d\\n\", x, E.to[i]);\n                en.addE(x, E.to[i]);\n                deg[E.to[i]]++;\n            }\n    }\n    rep (i, 1, tp) if (!deg[vert[i]]) {\n        en.addE(M + 1, vert[i]);\n    }\n    rep (i, 1, tp) deg[vert[i]] = 0;\n    dp(M + 1);\n    inc(ans, f[M + 1]);\n}\n\ninline void init () {\n    fac[0] = ifac[0] = 1;\n    rep (i, 1, M) fac[i] = mul(fac[i - 1], i);\n    ifac[M] = qpow(fac[M], MOD - 2);\n    irep (i, M, 2) ifac[i - 1] = mul(ifac[i], i);\n}\n\nint main () {\n    read(N);\n    M = 2 * N;\n    init();\n    int x, y;\n    rep (i, 1, M) {\n        read(x), read(y);\n        // printf(\"%d %d %d\\n\", x, y + N, x + y);\n        E.addE(x, y + N, x + y);\n        E.addE(y + N, x, x + y);\n    }\n    int tot = 0;\n    rep (i, 1, N * 2) if (!vis[i]) {\n        totv = tote = top = tp = 0;\n        findcir(i);\n        // printf(\"%d %d\\n\", tote, totv);\n        // rep (i, 1, top) printf(\"%d \", st[i]); puts(\"\");\n        // break;\n        if (tote != totv * 2) { res = 0; break; }\n        tot += totv;\n        rep (i, 1, top) {\n            dep[st[i]] = 0;\n            getd(st[i], 0);\n        }\n        ans = 0;\n        int u = st[1];\n        for (int j = E.head[u]; j; j = E.nxt[j])\n            if (onc[E.to[j]]) {\n                // printf(\"%d %d\\n\", u, E.to[j]);\n                fa[u] = E.to[j];\n                val[u] = E.val[j];\n                getc(E.to[j], u, u);\n                solve();\n                // printf(\"%d\\n\", ans);\n                // return 0;\n            }\n        // printf(\"%d\\n\", ans);\n        res = mul(mul(res, ans), C(tot, totv));\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 200000 + 1000;\nconst int MOD = 1000000000 + 7;\n\nint fpow(int x, int p)\n{\n\tint ret = 1;\n\tfor(; p; p >>= 1, x = (long long)x * x % MOD)\n\t\tif(p & 1)\n\t\t\tret = (long long)ret * x % MOD;\n\treturn ret;\n}\nint inv(int x)\n{\n\treturn fpow(x, MOD - 2);\n}\n\nint fac[MAXN], fac_inv[MAXN];\nvoid init()\n{\n\tfac[0] = 1;\n\tfor(int i = 1; i < MAXN; i++)\n\t\tfac[i] = (long long)fac[i - 1] * i % MOD;\n\tfac_inv[MAXN - 1] = inv(fac[MAXN - 1]);\n\tfor(int i = MAXN - 2; i >= 0; i--)\n\t\tfac_inv[i] = (long long)fac_inv[i + 1] * (i + 1) % MOD;\n\t// cerr << fac_inv[0] << endl;\n}\n\nint n, ans = 1;\nvector<int> edg[MAXN], topo[MAXN];\nbool vis[MAXN], onc[MAXN];\nint deg[MAXN], from[MAXN], f[MAXN], sz[MAXN];\nvector<int> vp, vc;\n\nvoid find_all(int x)\n{\n\tvis[x] = true, vp.push_back(x);\n\tfor(int i = 0; i < edg[x].size(); i++)\n\t\tif(!vis[edg[x][i]])\n\t\t\tfind_all(edg[x][i]);\n}\n\nint find_cir(int x, int fa)\n{\n\t// cerr << x << endl;\n\tstatic int vis[MAXN];\n\tvis[x] = true;\n\tfor(int i = 0; i < edg[x].size(); i++)\n\t\tif(edg[x][i] != fa)\n\t\t{\n\t\t\tint y = edg[x][i], t = vis[y] ? y : find_cir(y, x);\n\t\t\tif(t)\n\t\t\t{\n\t\t\t\tonc[x] = true, vc.push_back(x);\n\t\t\t\treturn t == x ? 0 : t;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nvoid get_from(int x, int fa)\n{\n\tfor(int i = 0; i < edg[x].size(); i++)\n\t\tif(edg[x][i] != fa && !onc[edg[x][i]])\n\t\t{\n\t\t\tint y = edg[x][i];\n\t\t\tfrom[y] = x;\n\t\t\tget_from(y, x);\n\t\t}\n}\n\nint dp(int x)\n{\n\tf[x] = 1, sz[x] = 1;\n\tfor(int i = 0; i < topo[x].size(); i++)\n\t{\n\t\tint y = topo[x][i];\n\t\tdp(y);\n\t\tf[x] = (long long)f[x] * f[y] % MOD * fac_inv[sz[y]] % MOD;\n\t\tsz[x] += sz[y];\n\t}\n\tf[x] = (long long)f[x] * fac[sz[x] - 1] % MOD;\n\treturn f[x];\n}\n\nint calc()\n{\n\t// cerr << \"calc : \" << endl;\n\tint ret = 1;\n\tfor(int i = 0; i < vp.size(); i++)\n\t\ttopo[vp[i]].clear(), deg[vp[i]] = 0;\n\tfor(int i = 0; i < vp.size(); i++)\n\t{\n\t\tint x = vp[i];\n\t\tfor(int j = 0; j < edg[x].size(); j++)\n\t\t\tif(edg[x][j] < from[x])\n\t\t\t{\n\t\t\t\tint y = edg[x][j];\n\t\t\t\ttopo[x].push_back(y), deg[y]++;\n\t\t\t\t// cerr << x << ' ' << y << endl;\n\t\t\t}\n\t}\n\tfor(int i = 0; i < vp.size(); i++)\n\t\tif(deg[vp[i]] == 0)\n\t\t{\n\t\t\tint tmp = (long long)dp(vp[i]) * fac_inv[sz[vp[i]]] % MOD;\n\t\t\t// cout << vp[i] << ' ' << sz[vp[i]] << ' ' << tmp << endl;\n\t\t\tret = (long long)ret * tmp % MOD;\n\t\t}\n\treturn ret;\n}\n\nvoid solve()\n{\n\t// cerr << vp.size() << endl;\n\tint edg_cnt = 0;\n\tfor(int i = 0; i < vp.size(); i++)\n\t\tedg_cnt += edg[vp[i]].size();\n\tif(edg_cnt != vp.size() * 2)\n\t{\n\t\tans = 0;\n\t\treturn ;\n\t}\n\tvc.clear();\n\tfind_cir(vp[0], 0);\n\t// cerr << vp[0] << ' ' << vc.size() << endl;\n\tint ret = 0;\n\tfor(int i = 0; i < vc.size(); i++)\n\t\tget_from(vc[i], 0);\n\tfor(int i = 0; i < vc.size(); i++)\n\t\tfrom[vc[i]] = vc[(i + 1) % vc.size()];\n\tret = (ret + calc()) % MOD;\n\tfor(int i = 0; i < vc.size(); i++)\n\t\tfrom[vc[i]] = vc[(i + vc.size() - 1) % vc.size()];\n\tret = (ret + calc()) % MOD;\n\tans = (long long)ans * ret % MOD;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tinit();\n\tcin >> n;\n\tfor(int i = 1; i <= 2 * n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tedg[x].push_back(n + y), edg[n + y].push_back(x);\n\t}\n\tfor(int i = 1; i <= 2 * n; i++)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tvp.clear();\n\t\t\tfind_all(i);\n\t\t\tsolve();\n\t\t}\n\tans = (long long)ans * fac[2 * n] % MOD;\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n\nconst int kN = 200000 + 5;\nconst int MOD = (int)1e9 + 7;\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a < 0) a += MOD;\n    else if (a >= MOD) a -= MOD;\n}\n\ninline int mul(int x)\n{\n    return x;\n}\n\ntemplate<typename... Args>\ninline int mul(int x, Args... args)\n{\n    return x * 1ll * mul(args...) % MOD;\n}\n\n\nint n;\nstd::vector<int> edges[kN], tree[kN];\nbool vis[kN], in[kN];\nstd::vector<int> vec;\nint F[kN], Finv[kN], Inv[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return mul(F[a], Finv[b], Finv[a - b]);\n}\n\nint dfs(int u)\n{\n    int ret = 1;\n    vis[u] = true;\n    vec.emplace_back(u);\n    for (int v : edges[u]) if (!vis[v])\n        ret -= dfs(v);\n    return ret;\n}\n\nbool find_cycle(int u, int fa, int &s, int &t)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != fa) {\n        if (vis[v]) {\n            s = u;\n            t = v;\n            return true;\n        } else if (find_cycle(v, u, s, t)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int u, int target)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != target) {\n        if (!vis[v])\n            dfs2(v, u);\n        // printf(\"(u, target): (%d, %d)\\n\", u, target);\n        if (v < target) {\n            tree[u].emplace_back(v);\n            // printf(\"%d->%d\\n\", u, v);\n            in[v] = true;\n        }\n    }\n}\n\nusing Val = std::pair<int, int>;\n\nVal combine(Val a, Val b)\n{\n    return Val(a.first + b.first, mul(a.second, b.second, binom(a.first + b.first, a.first)));\n}\n\nVal calc(int u)\n{\n    Val ret(0, 1);\n    for (int v : tree[u]) {\n        ret = combine(ret, calc(v));\n    }\n    ret.first ++;\n    // printf(\"u = %d, ret = (%d, %d)\\n\", u, ret.first, ret.second);\n    return ret;\n}\n\nVal solve(int u)\n{\n    vec.clear();\n    dfs(u);\n    int e = 0;\n    for (int v : vec)\n        e += edges[v].size();\n    if (e / 2 != vec.size()) {\n        return std::make_pair(0, 0);\n    }\n\n    for (int v : vec) vis[v] = false;\n    int s, t;\n    assert(find_cycle(u, -1, s, t));\n    int ways = 0;\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(s, t);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve0::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(t, s);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve1::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    return std::make_pair(vec.size(), ways);\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = mul(MOD - MOD / i, Inv[MOD % i]);\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = mul(F[i - 1], i);\n        Finv[i] = mul(Finv[i - 1], Inv[i]);\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n * 2; ++ i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b); a --; b --;\n        edges[a].emplace_back(n + b);\n        edges[n + b].emplace_back(a);\n    }\n    Val val(0, 1);\n    for (int i = 0; i < n; ++ i) if (!vis[i]) {\n        val = combine(val, solve(i));\n    }\n    printf(\"%d\\n\", val.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\n#define ll long long\n#define maxn 200005\n#define mo 1000000007\ninline ll read()\n{\n\tll x=0,w=0;char ch=getchar();\n\twhile(!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn w?-x:x;\n}\nvector<int>A[maxn];\nvector<int>G[maxn];\nint n,tot;\nint jc[maxn],ans[maxn],inst[maxn];\nint vis[maxn],vis1[maxn],fa[maxn],huan[maxn],size[maxn];\nint headd[maxn],nextt[maxn<<1],to[maxn<<1],cntt;\ninline int ksm(int x,int y)\n{\n    int a=1;\n    while(y)\n    {\n        if(y&1)a=1ll*a*x%mo;\n        x=1ll*x*x%mo;y>>=1;\n    }return a;\n}\ninline void add(int u,int v)\n{nextt[++cntt]=headd[u];headd[u]=cntt;to[cntt]=v;}\ninline void dfs(int u,int f)\n{\n    vis[u]=tot;A[tot].push_back(u);fa[u]=f;inst[u]=1;\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(vis[to[i]]){if(inst[to[i]])huan[fa[to[i]]]=-1,huan[u]++;}\n        else dfs(to[i],u),huan[u]+=huan[to[i]];\n    }inst[u]=0;\n}\ninline void dfs1(int u,int f)\n{\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(huan[to[i]]==1)continue;\n        fa[to[i]]=u;dfs1(to[i],u);\n    }\n}\ninline void dfs2(int u)\n{\n    reg int i,sz=G[u].size();\n    size[u]=1;vis1[u]=1;\n    for(i=0;i<sz;++i)\n    {\n        if(!vis1[G[u][i]])dfs2(G[u][i]);\n        size[u]+=size[G[u][i]];\n    }\n}\ninline void solve1()\n{\n    reg int i,j,u,sz=A[tot].size();\n    for(j=0;j<sz;++j)\n    {\n        u=A[tot][j];G[u].clear();\n        for(i=headd[u];i;i=nextt[i])\n        {\n            if(fa[to[i]]!=u)continue;\n            if(to[i]<fa[u])G[u].push_back(to[i]);\n        }\n    }\n    for(i=0;i<sz;++i)\n        if(!vis1[A[tot][i]])\n            dfs2(A[tot][i]);\n    for(i=0;i<sz;++i)vis1[A[tot][i]]=0;\n    reg int tmp=1;\n    for(i=0;i<sz;++i)tmp=1ll*tmp*size[A[tot][i]]%mo;\n    ans[tot]+=1ll*jc[sz]*ksm(tmp,mo-2)%mo;if(ans[tot]>=mo)ans[tot]-=mo;\n}\ninline void solve()\n{\n    reg int i,sz=A[tot].size(),fi,k;\n    if(sz==1)exit(0);\n    for(i=0;i<sz;++i)\n        if(huan[A[tot][i]]==1){fi=A[tot][i];break;}\n    k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[to[i]]!=k){fa[k]=to[i];k=to[i];break;}\n    }while(fi!=k);solve1();k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[k]!=to[i]){fa[to[i]]=k;k=to[i];break;}\n    }while(fi!=k);solve1();\n}\nint main()\n{\n    n=read();reg int i,x,y;jc[0]=1;\n    for(i=1;i<=2*n;++i)jc[i]=1ll*jc[i-1]*i%mo;\n    for(i=1;i<=2*n;++i)\n    {\n        x=read(),y=read();\n        add(x,n+y),add(n+y,x);\n    }\n    for(i=1;i<=n*2;++i)if(!vis[i])\n        ++tot,dfs(i,0),solve();\n    reg int sum=1,su=1;\n    for(i=1;i<=tot;++i)sum=1ll*sum*ans[i]%mo;\n    for(i=1;i<=tot;++i)su=1ll*su*jc[A[i].size()]%mo;\n    sum=1ll*sum*jc[2*n]%mo*ksm(su,mo-2)%mo;\n    printf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v; };\n\nint f[300000], fi[300000];\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n>>=1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint inv_mod(int x, int p) {\n\treturn pow_mod(x, p - 2, p);\n}\n\nint C(int x, int y) {\n\treturn (ll)f[x] * fi[y] % MOD * fi[x - y] % MOD;\n}\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint prod;\n\nint dfs(int u, vector<vector<int> >& G) {\n\tint tot = 0;\n\tfor (int v: G[u]) {\n\t\tint sz = dfs(v, G);\n\t\ttot += sz;\n\t\tprod = (ll)prod * C(tot, sz) % MOD;\n\t}\n\treturn tot + 1;\n}\n\nint calc(int N, int M, vector<int> a, vector<int> b, vector<int> dir) {\n\treturn 0;\n\trep(i, N + M) if (dir[i] == -1) return 0;\n\tvector<int> unko(N + M);\n\trep(i, N + M) {\n\t\tif (dir[i] == 0) unko[a[i]]++;\n\t\tif (dir[i] == 1) unko[N + b[i]]++;\n\t}\n\trep(u, N + M) if (unko[u] != 1) return 0;\n\tvector<vector<i_i> > xs(N), ys(M);\n\trep(i, N + M) xs[a[i]].pb(i_i(b[i], i));\n\trep(i, N + M) ys[b[i]].pb(i_i(a[i], i));\n\tvector<vector<int> > G(N + M);\n\tvector<bool> root(N + M, true);\n\trep(k, N) {\n\t\tsort(xs[k].begin(), xs[k].end());\n\t\trep(l, xs[k].size()) {\n\t\t\tint i = xs[k][l].second;\n\t\t\tif (dir[i] == 0)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(xs[k][_l].second);\n\t\t}\n\t}\n\trep(k, N) {\n\t\tsort(ys[k].begin(), ys[k].end());\n\t\trep(l, ys[k].size()) {\n\t\t\tint i = ys[k][l].second;\n\t\t\tif (dir[i] == 1)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(ys[k][_l].second);\n\t\t}\n\t}\n\trep(u, N + M) for (int v: G[u]) root[v] = false;\n\tvector<int> to;\n\trep(u, N + M) if (root[u]) to.pb(u);\n\tG.pb(to);\n\tprod = 1;\n\tdfs(N + M, G);\n\treturn prod;\n}\n\nint solve(int N, int M, vector<int> a, vector<int> b) {\n\tif (N + M != a.size()) return 0;\n\tvector<vector<edge> > G(N + M);\n\trep(i, N + M) G[a[i]].pb(edge{i, N + b[i]}), G[N + b[i]].pb(edge{i, a[i]});\n\tvector<int> d(N + M);\n\trep(u, N + M) d[u] = G[u].size();\n\tqueue<int> q;\n\trep(u, N + M) if (d[u] == 1) q.push(u);\n\tvector<bool> exist(N + M, true);\n\tvector<int> dir(N + M, -1);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\texist[u] = false;\n\t\tint i;\n\t\tfor (edge e: G[u]) if (exist[e.v]) {\n\t\t\ti = e.i;\n\t\t\td[e.v]--;\n\t\t\tif (d[e.v] == 1) q.push(e.v);\n\t\t}\n\t\tdir[i] = (u >= N);\n\t}\n\tint i0 = -1;\n\trep(i, N + M) if (dir[i] == -1) i0 = i;\n\tif (i0 == -1) return calc(N, M, a, b, dir);\n\tvector<int> dir0 = dir;\n\tint ans = 0;\n\trep(t, 2) {\n\t\tdir = dir0;\n\t\tint s;\n\t\tif (t == 0) s = a[i0], dir[i0] = 0;\n\t\tif (t == 1) s = N + b[i0], dir[i0] = 1;\n\t\tvector<bool> vis(N + M); vis[s] = true;\n\t\tqueue<int> q; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (edge e: G[u]) if (dir[e.i] == -1) {\n\t\t\t\tdir[e.i] = (e.v >= N);\n\t\t\t\tif (!vis[e.v]) {\n\t\t\t\t\tvis[e.v] = true;\n\t\t\t\t\tq.push(e.v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (ans + calc(N, M, a, b, dir)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\treturn -1;\n\tf[0] = fi[0] = 1;\n\tfor (int x = 1; x < 300000; x++) {\n\t\tf[x] = (ll)f[x - 1] * x % MOD;\n\t\tfi[x] = (ll)fi[x - 1] * inv_mod(x, MOD) % MOD;\n\t}\n\tint N; cin >> N;\n\tvector<int> a(N * 2), b(N * 2);\n\trep(i, N * 2) scanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\tunion_find uf(N * 2);\n\trep(i, N * 2) uf.unite(a[i], b[i] + N);\n\tvector<vector<int> > vv(N * 2);\n\trep(i, N * 2) vv[uf.find(a[i])].pb(i);\n\tint ans = 1;\n\tfor (vector<int> v: vv) if (!v.empty()) {\n\t\tvector<int> _a, _b;\n\t\tfor (int i: v) _a.pb(a[i]), _b.pb(b[i]);\n\t\tvector<int> A = _a, B = _b;\n\t\tsort(A.begin(), A.end());\n\t\tsort(B.begin(), B.end());\n\t\tA.erase(unique(A.begin(), A.end()), A.end());\n\t\tB.erase(unique(B.begin(), B.end()), B.end());\n\t\tfor (int& u: _a) u = lower_bound(A.begin(), A.end(), u) - A.begin();\n\t\tfor (int& u: _b) u = lower_bound(B.begin(), B.end(), u) - B.begin();\n\t\tans = (ll)ans * solve(A.size(), B.size(), _a, _b) % MOD;\n\t}\n\tint tot = 0;\n\trep(u, N * 2) if (uf.root(u)) {\n\t\ttot += uf.size(u);\n\t\tans = (ll)ans * C(tot, uf.size(u)) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <math.h>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 400005;\nconst int mod = 1e9+7;\n\nint n,p[maxn],sum[maxn],ans;\n\nint findp(int t) {\n\treturn p[t]?p[t]=findp(p[t]):t;\n}\nvoid merge(int u,int v) {\n\tu=findp(u);v=findp(v);\n\tu!=v?(p[u]=v,sum[v]+=sum[u]):0;\n}\n\nstruct edge {\n\tint u,v,next;\n}edg[maxn];\nint ehead[maxn],ecnt;\nvoid add(int u,int v) {\n\tedg[++ecnt]=(edge){u,v,ehead[u]};\n\tehead[u]=ecnt;sum[findp(u)]--;\n\tedg[++ecnt]=(edge){v,u,ehead[v]};\n\tehead[v]=ecnt;sum[findp(v)]--;\n}\n\nLL fpm(LL p,LL k) {\n\tLL res=1ll;\n\twhile (k) {\n\t\tif (k&1) (res*=p)%=mod;\n\t\t(p*=p)%=mod;k>>=1;\n\t}\n\treturn res;\n}\n\nint stk[maxn],top,fa[maxn],cal[maxn],res,val;bool ins[maxn],tag,onr[maxn];\nvoid FindRing(int u)\n{\n\tins[u]=true;\n\tfor (int v,j=ehead[u];j&&!tag;j=edg[j].next)\n\tif ((v=edg[j].v)!=fa[u]) {\n\t\tif (ins[v]) {\n\t\t\ttag=onr[u]=true;stk[++top]=u;\n\t\t\tfor (int i=u;i!=v;i=fa[i])\n\t\t\t\tstk[++top]=fa[i],onr[fa[i]]=true;\n\t\t}\n\t\telse fa[v]=u,FindRing(v);\n\t}\n\tins[u]=false;\n}\nvoid calc(int u,int fa)\n{\n\tcal[u]=1;ins[u]=true;\n\tfor (int v,j=ehead[u];j;j=edg[j].next)\n\tif ((v=edg[j].v)!=fa&&!onr[v]) {\n\t\tcalc(v,u);v<fa?cal[u]+=cal[v]:0;\n\t}\n\tif (fa) res=(LL)res*cal[u]%mod;\n}\nvoid calcR(int u,int fa)\n{\n\tif (ins[u]) return ;\n\tcal[u]=1;ins[u]=true;\n\tfor (int v,j=ehead[u];j;j=edg[j].next)\n\tif ((v=edg[j].v)!=fa&&v<fa) {\n\t\tcalcR(v,u);cal[u]+=cal[v];\n\t}\n\tval=(LL)val*cal[u]%mod;\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc083f.in\",\"r\",stdin);\n\t\tfreopen(\"arc083f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);ans=1;\n\tfor (int i=1;i<=n<<1;i++) ans=(LL)ans*i%mod;\n\tfor (int i=2;i<=(n<<1|1);i++) sum[i]=2;\n\tfor (int u,v,i=1;i<=n<<1;i++)\n\t\tscanf(\"%d %d\",&u,&v),add(u<<1,v<<1|1),merge(u<<1,v<<1|1);\n\tfor (int i=2;i<=(n<<1|1);i++)\n\t\tif (sum[i]&&!p[i]) {puts(\"0\");return 0;}\n\t\n\tfor (int i=2;i<=(n<<1|1);i++)\n\tif (!p[i]) {\n\t\tres=1;tag=false;top=0;FindRing(i);\n\t\tfor (int j=1;j<=top;j++) calc(stk[j],0);\n\t\tstk[0]=stk[top];stk[top+1]=stk[1];\n\t\tint oans=0;val=1;\n\t\tfor (int j=1;j<=top;j++) ins[stk[j]]=false;\n\t\tfor (int j=1;j<=top;j++) calcR(stk[j],stk[j-1]);\n\t\toans=fpm((LL)res*val,mod-2);val=1;\n\t\tfor (int j=1;j<=top;j++) ins[stk[j]]=false;\n\t\tfor (int j=1;j<=top;j++) calcR(stk[j],stk[j+1]);\n\t\toans=(oans+fpm((LL)res*val,mod-2))%mod;\n\t\tans=(LL)ans*oans%mod;\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int P = 1000000007;\n\nint norm(int x) { return x >= P ? (x - P) : x; }\n\nvoid add(int& x, int y) { if ((x += y) >= P) x -= P; }\n\nvoid sub(int& x, int y) { if ((x -= y) < 0) x += P; }\n\nvoid exGcd(int a, int b, int& x, int& y) {\n  if (!b) {\n    x = 1;\n    y = 0;\n    return;\n  }\n  exGcd(b, a % b, y, x);\n  y -= a / b * x;\n}\n\nint inv(int a) {\n  int x, y;\n  exGcd(a, P, x, y);\n  return norm(x + P);\n}\n\nconst int N = 200010;\n\nint n;\nvector<int> g[N];\nint fac[N], ifac[N], nv[N], f[N], bal[N], sz[N], mn[N];\nint got[N], prt[N], deg[N];\n\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }\n\nvoid prep(int m) {\n  fac[0] = 1;\n  for (int i = 1; i <= m; ++i) fac[i] = fac[i - 1] * (ll)i % P;\n  ifac[m] = inv(fac[m]);\n  for (int i = m; i; --i) ifac[i - 1] = ifac[i] * (ll)i % P;\n  for (int i = 1; i <= m; ++i) nv[i] = ifac[i] * (ll)fac[i - 1] % P;\n}\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  iota(f + 1, f + n * 2 + 1, 1);\n  fill(bal + 1, bal + n * 2 + 1, 1);\n  vector<pair<int, int>> crit;\n  fill(mn + 1, mn + n * 2 + 1, numeric_limits<int>::max());\n  for (int rep = 0; rep < n * 2; ++rep) {\n    int x, y;\n    cin >> x >> y;\n    y += n;\n    int u = x, v = y;\n    mn[u] = min(mn[u], v);\n    mn[v] = min(mn[v], u);\n    x = find(x); y = find(y);\n    if (x != y) {\n      bal[x] += bal[y];\n      f[y] = x;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    } else\n      crit.emplace_back(u, v);\n    --bal[x];\n  }\n  for (int i = 1; i <= n * 2; ++i)\n    if (f[i] == i && bal[i]) {\n      cout << \"0\\n\";\n      return 0;\n    }\n  prep(n * 2);\n  int ans = 1;\n\n  auto gans = [&](int x, int y) {\n    int ret = 1;\n    vector<int> tot;\n    function<void(int)> dfs = [&](int u) {\n      for (int v : g[u])\n        if (!prt[v]) {\n          prt[v] = u;\n          dfs(v);\n        }\n      tot.push_back(u);\n    };\n    prt[x] = -1;\n    dfs(x);\n    prt[x] = y;\n    for (int u : tot) sz[u] = 1;\n\n    queue<int> topo;\n    for (int u : tot) {\n      if (u < prt[prt[u]]) {\n        ++deg[got[u] = prt[u]];\n      } else\n        got[u] = 0;\n    }\n    for (int u : tot)\n      if (!deg[u])\n        topo.push(u);\n\n    while (!topo.empty()) {\n      int u = topo.front(); topo.pop();\n      ret = ret * (ll)nv[sz[u]] % P;\n      if (got[u]) {\n        sz[got[u]] += sz[u];\n        if (--deg[got[u]] == 0)\n          topo.push(got[u]);\n      }\n    }\n\n    for (int u : tot) prt[u] = 0;\n    return ret % P;\n  };\n\n  for (const auto& pr : crit) { int x, y;tie(x,y)=pr;\n    int good = norm(gans(x, y) + gans(y, x));\n    ans = ans * (ll)good % P;\n  }\n\n  ans = ans * (ll)fac[n * 2] % P;\n  cout << ans << '\\n';\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nstruct edge{\n\tint k,next;\n}e[N<<2];\nint n,home[N],cnt=-1,a[N],tot,sum=0,s[N],top,to[N],H[N];\nll fac[N],inv[N];\nll quick_pow(ll a,ll b){\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) ans=ans*a%mod;\n\treturn ans;\n}\nll C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nbool vis[N];\nll ans=1;\nvoid add(int *home,int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid dfs(int k){\n\tvis[k]=1;a[++tot]=k;\n\tfor(int i=home[k];~i;i=e[i].next,sum++) if(!vis[e[i].k])\n\t\tdfs(e[i].k);\n}\nint used[N],cir[N],cc;\nint fa[N];\nvoid dfs(int k,int F){\n\tused[k]=++cc;fa[k]=F;\n\tfor(int i=home[k];~i;i=e[i].next) if(i!=F){\n\t\tif(used[e[i].k]){\n\t\t\tif(used[e[i].k]>used[k]) continue;\n\t\t\tint x=k;\n\t\t\tcir[e[i].k]=1;\n\t\t\twhile(x!=e[i].k){\n\t\t\t\ts[++top]=x;\n\t\t\t\tcir[x]=1;\n\t\t\t\tx=e[fa[x]].k;\n\t\t\t}\n\t\t\ts[++top]=e[i].k;\n\t\t\tcontinue;\n\t\t}\n\t\telse dfs(e[i].k,i^1);\n\t}\n}\nvoid dfs1(int k,int F){\n\tused[k]=1;\n\tif(!cir[k]) to[k]=e[F].k;\n\tfor(int i=home[k];~i;i=e[i].next) if(i!=F&&!used[e[i].k]){\n\t\tdfs1(e[i].k,i^1);\n\t}\n}\nint vec,now,siz[N],IN[N];\nll f[N];\nvoid dp(int k){\n\tf[k]=1;now++;siz[k]=0;\n\tfor(int i=H[k];~i;i=e[i].next){\n\t\tdp(e[i].k);\n\t\tsiz[k]+=siz[e[i].k];\n\t\tf[k]=f[k]*C(siz[k],siz[e[i].k])%mod*f[e[i].k]%mod;\n\t}\n\tsiz[k]++;\n}\nvoid solve(){\n\ttop=cc=0;\n\tdfs(a[1],-1);\n\tfor(int i=1;i<=tot;i++) used[a[i]]=0;\n\tdfs1(s[1],-1);\n\tfor(int i=1;i<=tot;i++) used[a[i]]=0;\n\tll ret=0;\n\tint vv=vec,CNT=cnt;\n\tfor(int w=-1;w<=1;w+=2){\n\t\tcnt=CNT;\n\t\tfor(int i=1;i<=tot;i++) H[a[i]]=-1,IN[a[i]]=0;\n\t\tfor(int i=1;i<=top;i++){\n\t\t\tint x=i+w;\n\t\t\tif(x==top+1) x=1;\n\t\t\tif(x==0) x=top;\n\t\t\tto[s[i]]=s[x];\n\t\t}\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tfor(int p=home[a[i]];~p;p=e[p].next)if(e[p].k<to[a[i]]){\n\t\t\t\tadd(H,a[i],e[p].k);\n\t\t\t\tIN[e[p].k]++;\n\t\t\t}\n\t\t}\n\t\tll o=1;vec=vv;\n\t\tfor(int i=1;i<=tot;i++) if(!IN[a[i]]){\n\t\t\tnow=0;\n\t\t\tdp(a[i]);\n\t\t\to=o*C(vec,now)%mod*f[a[i]]%mod;\n\t\t\tvec-=now;\n\t\t}\n\t\tret=(ret+o)%mod;\n\t}\n\tans=ans*ret%mod;\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tmemset(H,-1,sizeof(H));\n\tscanf(\"%d\",&n);\n\tvec=n+n;\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=200002;i++) fac[i]=fac[i-1]*i%mod,inv[i]=quick_pow(fac[i],mod-2);\n\tfor(int i=1,x,y;i<=n+n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(home,x,y+n);add(home,y+n,x);\n\t}\n\tfor(int i=1;i<=n;i++)if(!vis[i]){\n\t\ttot=sum=0;\n\t\tdfs(i);\n\t\tif(sum!=tot+tot) return puts(\"0\"),0;\n\t\tsolve();\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\nconst int N=2e5+10,Mod=1e9+7;\n\nstruct Edge{ int to,next,cost; }way[N<<1],E[N];\n\nint n,num[N],tot,hed[N],cnt,inv_fact[N],d[N],fact[N];\n\nvoid Build(int a,int b,int c) { way[++tot]=(Edge){b,num[a],c}; num[a]=tot; } \n\nvoid Add(int a,int b) { E[++cnt]=(Edge){b,hed[a]}; hed[a]=cnt; d[b]++; }\n\nvoid Init() {\n\tscanf(\"%d\",&n);\n\tint x,y;\n\tfor (int i=1;i<=2*n;++i) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tBuild(x,y+n,x+y);Build(y+n,x,x+y);\n\t}\n}\n\nint que[N],cntedge,cntnode,cirx,ciry,cirw;\nbool vis[N];\nvoid Dfs(int x,int fa) {\n\tvis[x]=1; que[cntnode++]=x;\n\tfor (int i=num[x];i;i=way[i].next) {\n\t\tint v=way[i].to;\n\t\tif (v==fa) continue;\n\t\tcntedge++;\n\t\tif (vis[v]==1) { \n\t\t\tif (!cirx) cirx=x,ciry=v,cirw=way[i].cost; \n\t\t\telse if (cirx==v && ciry==x) cntedge--;\n\t\t\tcontinue; \n\t\t}\n\t\tDfs(v,x);\n\t}\n}\n\nbool vis2[N];\nvoid ReBuild(int x,int fa,int cost) {\n\tvis2[x]=1;\n\tfor (int i=num[x];i;i=way[i].next) {\n\t\tint v=way[i].to,c=way[i].cost;\n\t\tif (v==fa) continue;\n\t\tif (c<cost) \n\t\t\tAdd(x,v);\n\t}\n\tfor (int i=num[x];i;i=way[i].next) {\n\t\tint v=way[i].to;\n\t\tif (v==fa || vis2[v]) continue;\n\t\tReBuild(v,x,way[i].cost);\n\t}\n}\n\nint son[N];\nLL GetAns(int x,int fa) {\n\tLL ans=1; son[x]=0;\n\tfor (int i=hed[x];i;i=E[i].next) {\n\t\tint v=E[i].to;\n\t\tif (v==fa) continue;\n\t\tans=ans*GetAns(v,x)%Mod*inv_fact[son[v]]%Mod;\n\t\tson[x]+=son[v];\n\t}\n\tans=ans*fact[son[x]]%Mod;\n\tson[x]++;\n\treturn ans;\n}\n\nLL Work() {\n\tLL ans,sum=0;\n\tcnt=0; for (int i=0;i<cntnode;++i) hed[que[i]]=0,d[que[i]]=0,vis2[que[i]]=0;\n\tReBuild(cirx,ciry,cirw);\n\tans=fact[cntnode];\n\tfor (int i=0;i<cntnode;++i) if (!d[que[i]]) \n\t\tans=ans*GetAns(que[i],0)%Mod*inv_fact[son[que[i]]]%Mod;\n\tsum+=ans;\n\tcnt=0; for (int i=0;i<cntnode;++i) hed[que[i]]=0,d[que[i]]=0,vis2[que[i]]=0;\n\tReBuild(ciry,cirx,cirw);\n\tans=fact[cntnode];\n\tfor (int i=0;i<cntnode;++i) if (!d[que[i]])\n\t\tans=ans*GetAns(que[i],0)%Mod*inv_fact[son[que[i]]]%Mod;\n\tsum+=ans;\n\treturn sum%Mod;\n}\n\nvoid Prepare() {\n\tfact[0]=1; for (int i=1;i<=n*2;++i) fact[i]=1ll*fact[i-1]*i%Mod;\n\tinv_fact[1]=1; for (int i=2;i<=n*2;++i) inv_fact[i]=1ll*(Mod-Mod/i)*inv_fact[Mod%i]%Mod;\n\tinv_fact[0]=1; for (int i=2;i<=n*2;++i) inv_fact[i]=1ll*inv_fact[i-1]*inv_fact[i]%Mod;\n}\n\nvoid Solve() {\n\tPrepare();\n\tLL ans=1ll;\n\tfor (int i=1;i<=n*2;++i) if (!vis[i]) {\n\t\tcntedge=0; cntnode=0; cirx=0; ciry=0;\n\t\tDfs(i,0); \n\t\tif (cntedge!=cntnode) { printf(\"0\\n\"); return ; }\n\t\tans=ans*Work()%Mod*inv_fact[cntnode]%Mod;\n\t}\n\tprintf(\"%lld\\n\",ans*fact[n<<1]%Mod);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\n#define ll long long\n#define maxn 200005\n#define mo 1000000007\ninline ll read()\n{\n\tll x=0,w=0;char ch=getchar();\n\twhile(!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn w?-x:x;\n}\nvector<int>A[maxn];\nvector<int>G[maxn];\nint n,tot;\nint jc[maxn],ans[maxn],inst[maxn];\nint vis[maxn],vis1[maxn],fa[maxn],huan[maxn],size[maxn];\nint headd[maxn],nextt[maxn<<1],to[maxn<<1],cntt;\ninline int ksm(int x,int y)\n{\n    int a=1;\n    while(y)\n    {\n        if(y&1)a=1ll*a*x%mo;\n        x=1ll*x*x%mo;y>>=1;\n    }return a;\n}\ninline void add(int u,int v)\n{nextt[++cntt]=headd[u];headd[u]=cntt;to[cntt]=v;}\ninline void dfs(int u,int f)\n{\n    vis[u]=tot;A[tot].push_back(u);fa[u]=f;inst[u]=1;\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(vis[to[i]]){if(inst[to[i]])huan[fa[to[i]]]=-1,huan[u]++;}\n        else dfs(to[i],u),huan[u]+=huan[to[i]];\n    }inst[u]=0;\n}\ninline void dfs1(int u,int f)\n{\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(huan[to[i]]==1)continue;\n        fa[to[i]]=u;dfs1(to[i],u);\n    }\n}\ninline void dfs2(int u)\n{\n    reg int i,sz=G[u].size();\n    size[u]=1;vis1[u]=1;\n    for(i=0;i<sz;++i)\n    {\n        if(!vis1[G[u][i]])dfs2(G[u][i]);\n        size[u]+=size[G[u][i]];\n    }\n}\ninline void solve1()\n{\n    reg int i,j,u,sz=A[tot].size();\n    for(j=0;j<sz;++j)\n    {\n        u=A[tot][j];G[u].clear();\n        for(i=headd[u];i;i=nextt[i])\n        {\n            if(fa[to[i]]!=u)continue;\n            if(to[i]<fa[u])G[u].push_back(to[i]);\n        }\n    }\n    for(i=0;i<sz;++i)\n        if(!vis1[A[tot][i]])\n            dfs2(A[tot][i]);\n    for(i=0;i<sz;++i)vis1[A[tot][i]]=0;\n    reg int tmp=1;\n    for(i=0;i<sz;++i)tmp=1ll*tmp*size[A[tot][i]]%mo;\n    ans[tot]+=1ll*jc[sz]*ksm(tmp,mo-2)%mo;if(ans[tot]>=mo)ans[tot]-=mo;\n}\ninline void solve()\n{\n    reg int i,sz=A[tot].size(),fi,k;\n    for(i=0;i<sz;++i)\n        if(huan[A[tot][i]]==1){fi=A[tot][i];break;}\n    k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[to[i]]!=k){fa[k]=to[i];k=to[i];break;}\n    }while(fi!=k);solve1();k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[k]!=to[i]){fa[to[i]]=k;k=to[i];break;}\n    }while(fi!=k);solve1();\n}\nint ha[maxn],ha1[maxn];\nint main()\n{\n    n=read();reg int i,x,y;jc[0]=1;\n    for(i=1;i<=2*n;++i)jc[i]=1ll*jc[i-1]*i%mo;\n    for(i=1;i<=2*n;++i)\n    {\n        x=read(),y=read();ha[x]=1;ha1[y]=1;\n        add(x,n+y),add(n+y,x);\n    }\n    for(i=1;i<=n;++i)if(!ha[i])return 0;\n    for(i=1;i<=n;++i)if(!ha1[i])return 0;\n    for(i=1;i<=n*2;++i)if(!vis[i])\n        ++tot,dfs(i,0),solve();\n    reg int sum=1,su=1;\n    for(i=1;i<=tot;++i)sum=1ll*sum*ans[i]%mo;\n    for(i=1;i<=tot;++i)su=1ll*su*jc[A[i].size()]%mo;\n    sum=1ll*sum*jc[2*n]%mo*ksm(su,mo-2)%mo;\n    printf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define mod 1000000007\n#define ll long long\nnamespace mymyth{\n\tll f[nn],rf[nn];\n\tll qpow(ll x,ll y)\n\t{\n\t\tll res=1;\n\t\twhile(y)\n\t\t{\n\t\t\tif(y&1) res=res*x%mod;\n\t\t\ty=y/2;x=x*x%mod;\n\t\t}return res;\n\t}\n\tvoid ini()\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod,rf[i]=qpow(f[i],mod-2);\n\t}\n};\nusing namespace mymyth;\n#define pii pair<int,int> \n#define mp make_pair\nvector<int> v[nn];\nint n;pii dot[nn];\n#define err {puts(\"0\");exit(0);}\nvoid adde(int x,int y)\n{\n\tv[x].push_back(y);\n\tv[y].push_back(x);\n}\nint vis[nn];\nint siz[nn],esiz[nn];\nint pa[nn];vector<int> cir;\nvector<int> all;int dep[nn];\nvoid dfs(int x,int p)\n{\n\tsiz[x]=1;esiz[x]=0;vis[x]=1;\n\tall.push_back(x);\n\tpa[x]=p,dep[x]=dep[p]+1;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif(y==p) continue;//there cant be a multi-edge\n\t\tif(!vis[y])\n\t\t{\n\t\t\tdfs(y,x);\n\t\t\tsiz[x]+=siz[y];\n\t\t\tesiz[x]+=1+esiz[y];\n\t\t}\n\t\telse if(dep[y]<dep[x] and cir.size()==0)\n\t\t{\n\t\t\tesiz[x]++;\n\t\t\tint t=x;\n\t\t\twhile(x!=pa[y]) \n\t\t\t\tcir.push_back(x),x=pa[x];\n\t\t\tx=t;\n\t\t}\n\t}\n}\n\nunordered_map<int,vector<int> >trans ;\nvector<int> g[nn];int gs[nn];ll dp[nn];\nvoid give(int x,int y)\n{\n//\tcout<<x<<\"-\"<<y<<\"\\n\";\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\nvoid gfs(int x,int p)\n{\n\tgs[x]=1;dp[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t{\n\t\tint y=g[x][i];if(y==p) continue;\n\t\tgfs(y,x);\n\t\tdp[x]=dp[x]*dp[y]%mod*rf[gs[y]]%mod;gs[x]+=gs[y];\n\t}\n\tdp[x]=dp[x]*f[gs[x]-1]%mod;\n}\nint cf[nn];\nll solve()\n{\n\ttrans.clear();\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];g[all[i]].clear();cf[all[i]]=0;\n//\t\tcout<<x<<\"->\"<<y<<\"\\n\";\n\t\t\ttrans[y].push_back(x);\n\t}\n\tg[0].clear();//system(\"pause\");\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];vector<int> tmp=trans[x];\n\t\tfor(int j=0;j<tmp.size();j++)\n\t\t\tif(tmp[j]<y) give(all[i],tmp[j]),cf[tmp[j]]=1; \n\t}\n\tfor(int i=0;i<all.size();i++) if(!cf[all[i]]) give(all[i],0);\n\tgfs(0,-1);\n\treturn dp[0];\n}\n\nint vp[nn];\nvoid vps(int x,int p)\n{\n\tpa[x]=p;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==p or vp[v[x][i]]) continue;\n\t\tvps(v[x][i],x); \n\t}\n}\nint main()\n{\n\tini();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tscanf(\"%d%d\",&dot[i].first,&dot[i].second);\n\t\tadde(dot[i].first,dot[i].second+n);\n\t}\n\tll ans=1;\n\tfor(int i=1;i<=n*2;i++) \n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tcir.clear();all.clear();\n\t\t\tdfs(i,0);int cn=cir.size();\n\t\t\tif(siz[i]!=esiz[i]) err;\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tvp[cir[j]]=1,pa[cir[j]]=cir[(j+1)%cn];\n\t\t//\tfor(int j=0;j<cn;j++)\n\t\t//\t\tvps(cir[j],pa[cir[j]]);\n\t\t\tll res=solve();\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tpa[cir[j]]=cir[(j-1+cn)%cn];\n\t\t\tres+=solve();\n\t\t\tans=res%mod*ans%mod*rf[all.size()]%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans*f[n+n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define mod 1000000007\n#define ll long long\nnamespace mymyth{\n\tll f[nn],rf[nn];\n\tll qpow(ll x,ll y)\n\t{\n\t\tll res=1;\n\t\twhile(y)\n\t\t{\n\t\t\tif(y&1) res=res*x%mod;\n\t\t\ty=y/2;x=x*x%mod;\n\t\t}return res;\n\t}\n\tvoid ini()\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod,rf[i]=qpow(f[i],mod-2);\n\t}\n};\nusing namespace mymyth;\n#define pii pair<int,int> \n#define mp make_pair\nvector<int> v[nn];\nint n;pii dot[nn];\n#define err {puts(\"0\");exit(0);}\nvoid adde(int x,int y)\n{\n\tv[x].push_back(y);\n\tv[y].push_back(x);\n}\nint vis[nn];\nint siz[nn],esiz[nn];\nint pa[nn];vector<int> cir;\nvector<int> all;int dep[nn];\nvoid dfs(int x,int p)\n{\n\tsiz[x]=1;esiz[x]=0;vis[x]=1;\n\tall.push_back(x);\n\tpa[x]=p,dep[x]=dep[p]+1;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif(y==p) continue;//there cant be a multi-edge\n\t\tif(!vis[y])\n\t\t{\n\t\t\tdfs(y,x);\n\t\t\tsiz[x]+=siz[y];\n\t\t\tesiz[x]+=1+esiz[y];\n\t\t}\n\t\telse if(dep[y]<dep[x] and cir.size()==0)\n\t\t{\n\t\t\tesiz[x]++;\n\t\t\tint t=x;\n\t\t\twhile(x!=pa[y]) \n\t\t\t\tcir.push_back(x),x=pa[x];\n\t\t\tx=t;\n\t\t}\n\t}\n}\n\nunordered_map<int,vector<int> >trans ;\nvector<int> g[nn];int gs[nn];ll dp[nn];\nvoid give(int x,int y)\n{\n//\tcout<<x<<\"-\"<<y<<\"\\n\";\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\nvoid gfs(int x,int p)\n{\n\tgs[x]=1;dp[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t{\n\t\tint y=g[x][i];if(y==p) continue;\n\t\tgfs(y,x);\n\t\tdp[x]=dp[x]*dp[y]%mod*rf[gs[y]]%mod;gs[x]+=gs[y];\n\t}\n\tdp[x]=dp[x]*f[gs[x]-1]%mod;\n}\nint cf[nn];\nll solve()\n{\n\ttrans.clear();\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];g[all[i]].clear();cf[all[i]]=0;\n//\t\tcout<<x<<\"->\"<<y<<\"\\n\";\n\t\t\ttrans[y].push_back(x);\n\t}\n\tg[0].clear();//system(\"pause\");\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];vector<int> tmp=trans[x];\n\t\tfor(int j=0;j<tmp.size();j++)\n\t\t\tif(tmp[j]<y) give(all[i],tmp[j]),cf[tmp[j]]=1; \n\t}\n\tfor(int i=0;i<all.size();i++) if(!cf[all[i]]) give(all[i],0);\n\tgfs(0,-1);\n\treturn dp[0];\n}\n\nint vp[nn];\nvoid vps(int x,int p)\n{\n\tpa[x]=p;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==p or vp[v[x][i]]) continue;\n\t\tvps(v[x][i],x); \n\t}\n}\nint main()\n{\n\tini();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tscanf(\"%d%d\",&dot[i].first,&dot[i].second);\n\t\tadde(dot[i].first,dot[i].second+n);\n\t}\n\tll ans=1;\n\tfor(int i=1;i<=n*2;i++) \n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tcir.clear();all.clear();\n\t\t\tdfs(i,0);int cn=cir.size();\n\t\t\tif(siz[i]!=esiz[i]) err;\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tvp[cir[i]]=1,pa[cir[j]]=cir[(j+1)%cn];\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tvps(cir[j],pa[cir[j]]);\n\t\t\tll res=solve();\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tpa[cir[j]]=cir[(j-1+cn)%cn];\n\t\t\tres+=solve();\n\t\t\tans=res%mod*ans%mod*rf[all.size()]%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans*f[n+n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x){\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 201000;\nstruct Edge {int v, nxt;} a[N*4];\nint head[N], Head[N], indeg[N];\nint sz[N], pr[N];\nbool vis[N];\nint n, _;\n\ninline void add(int x, int y, int*arr) {\n\ta[++_].v = y, a[_].nxt = arr[x], arr[x] = _;\n}\n\nconst int p = 1e9+7;\nint fac[N], ifac[N], inv[N];\n\nint st[N], tp;\n#define FID(i) for(int id=1,i;i=st[id],id<=tp;++id)\n\nint X, Y;\nint et, pt;\n\nvoid bfs(int x, int las) {\n\tvis[st[++tp] = x] = true, ++pt;\n\tfor(int i=head[x];i;++et,i=a[i].nxt)\n\t\tif(!vis[a[i].v]) bfs(a[i].v, x);\n\t\telse if(a[i].v != las) X = x, Y = a[i].v;\n}\n\nvoid tfs(int x, int las) {\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tif(a[i].v != las and a[i].v != X)\n\t\t\tpr[a[i].v] = x, tfs(a[i].v, x);\n}\n\nvoid dfs(int x, int las) {\n\tsz[x] = 1;\n\tfor(int i=Head[x];i;i=a[i].nxt)\n\t\tif(a[i].v != las)\n\t\t\tdfs(a[i].v, x), sz[x] += sz[a[i].v];\n}\n\nint solve() {\n\ttfs(X, Y);\n\tpr[X] = Y;\n\tFID(i) Head[i] = indeg[i] = 0;\n\tFID(x) for(int i=head[x];i;i=a[i].nxt)\n\t\tif(a[i].v < pr[x]) add(x, a[i].v, Head), ++indeg[a[i].v];\n\t\n\tFID(i) if(!indeg[i]) dfs(i, i);\n\tint Ans = fac[pt];\n\tFID(i) Ans = (ll)Ans * inv[sz[i]]%p;\n\treturn Ans;\n}\n\nint main() {\n\tread(n);\n\tfor(int i=1,x,y;i<=(n<<1);++i) {\n\t\tread(x), read(y), y += n;\n\t\tadd(x, y, head);\n\t\tadd(y, x, head);\n\t}\n\t\n\tn <<= 1;\n\tfac[0] = fac[1] = inv[0] = inv[1] = ifac[0] = ifac[1] = 1;\n\tfor(int i=2;i<=n;++i) {\n\t\tfac[i] = (ll)fac[i-1] * i%p;\n\t\tinv[i] = (ll)(p-p/i) * inv[p%i]%p;\n\t\tifac[i] = (ll)ifac[i-1] * inv[i]%p;\n\t}\n\t\n\tint Ans = fac[n];\n\tfor(int i=1;i<=n;++i)\n\t\tif(!vis[i]) {\n\t\t\ttp = pt = et = 0;\n\t\t\tbfs(i, i);\n\t\t\tAns = (ll)Ans * ifac[pt]%p;\n\t\t\tif((pt << 1) != et) return puts(\"0\"), 0;\n\t\t\tint res = solve();\n\t\t\tswap(X, Y);\n\t\t\tres += solve();\n\t\t\tAns = (ll)Ans * res%p;\n\t\t}\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nnamespace Dango\n{\n\tconst int MAXN=200005,MOD=1000000007;\n\tvector<int> cir,node;\n\tint n;\n\tint head[MAXN],to[MAXN<<1],nxt[MAXN<<1];\n\tint tot;\n\tint fa[MAXN],size[MAXN];\n\tlong long ans;\n\tbool vis[MAXN],on_cir[MAXN];\n\tint read()\n\t{\n\t\tint x=0,f=0;\n\t\tchar ch=getchar();\n\t\twhile(!isdigit(ch)){f|=(ch=='-');ch=getchar();}\n\t\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\t\treturn f?-x:x;\n\t}\n\tvoid add(int u,int v)\n\t{\n\t\tstatic int cnt;\n\t\tcnt++;\n\t\tto[cnt]=v;\n\t\tnxt[cnt]=head[u];\n\t\thead[u]=cnt;\n\t}\n\tvoid dfs(int u)\n\t{\n\t\tnode.push_back(u);\n\t\tvis[u]=true;\n\t\ttot+=2;\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t{\n\t\t\ttot--;\n\t\t\tint v=to[i];\n\t\t\tif(vis[v])continue;\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tvoid findcircle(int u,int pre)\n\t{\n\t\tstatic bool vis[MAXN],flag;\n\t\tstatic int s,t;\n\t\tvis[u]=true;\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(v==pre)continue;\n\t\t\tif(vis[v])\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\ts=u;t=v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfindcircle(v,u);\n\t\t\tif(flag)break;\n\t\t}\n\t\tif(flag){cir.push_back(u);on_cir[u]=true;}\n\t\tif(u==t)flag=false;\n\t}\n\tlong long pow_(long long a,long long b)\n\t{\n\t\tlong long res=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1)res=res*a%MOD;\n\t\t\ta=a*a%MOD;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tlong long dfs_(int u)\n\t{\n\t\tif(size[u])return 1;\n\t\tlong long res=1;\n\t\tsize[u]=1;\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(v>=fa[u])continue;\n\t\t\tres=res*dfs_(v)%MOD;\n\t\t\tsize[u]+=size[v];\n\t\t}\n\t\tres=res*pow_(size[u],MOD-2)%MOD;\n\t\treturn res;\n\t}\n\tint calc()\n\t{\n\t\tlong long res=1;\n\t\tfor(int i=0;i<node.size();i++)\n\t\t\tsize[node[i]]=0;\n\t\tfor(int i=0;i<node.size();i++)\n\t\t{\n\t\t\tint x=node[i];\n\t\t\tif(size[x])continue;\n\t\t\tres=res*dfs_(x)%MOD;\n\t\t}\n\t\treturn res;\n\t}\n\tvoid dfs_for_fa(int u)\n\t{\n\t\tstatic int vis[MAXN];\n\t\tvis[u]=true;\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(vis[v])continue;\n\t\t\tfa[v]=u;\n\t\t\tdfs_for_fa(v);\n\t\t}\n\t}\n\tvoid solve(int u)\n\t{\n\t\tlong long res=0;\n\t\tcir.clear();\n\t\tnode.clear();\n\t\tdfs(u);\n\t\tif(tot){ans=0;return;}\n\t\tfindcircle(u,0);\n\t\tcir.push_back(cir[0]);\n\t\tfor(int i=1;i<cir.size();i++)\n\t\t\tfa[cir[i]]=cir[i-1];\n\t\tdfs_for_fa(cir[0]);\n\t\tres=(res+calc())%MOD;\n\t\tfor(int i=0;i<cir.size()-1;i++)\n\t\t\tfa[cir[i]]=cir[i+1];\n\t\tres=(res+calc())%MOD;\n\t\tans=ans*res%MOD;\n\t}\n\tint work()\n\t{\n\t\tn=read();\n\t\tn<<=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint u=read(),v=read()+n/2;\n\t\t\tadd(u,v);add(v,u);\n\t\t}\n\t\tans=1;\n\t\tfor(int i=1;i<=n&&ans;i++)\n\t\t{\n\t\t\tans=(ans*i)%MOD;\n\t\t\tif(!vis[i])solve(i);\n\t\t}\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn Dango::work();\n}\n/*\n8\n6 2\n5 1\n6 8\n7 8\n6 5\n5 7\n4 3\n1 4\n7 6\n8 3\n2 8\n3 6\n3 2\n8 5\n1 5\n5 8\n*/"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n有点恶心。\n\n每个机器人看做一个点，平面上的每个点看做连接机器人的边。\n形成的图一定是基环树森林，否则说明有一行或一列为空，直接输出 0 。\n\n单独考虑森林的每一颗基环树。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) // fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 400005, mod = 1000000007;\nint head[maxn], nxt[maxn << 2], to[maxn << 2], hp = 1;\n\ninline ll power(ll x, int k) {\n\tif(k < 0) k += mod - 1;\n\tll res = 1;\n\twhile(k) {\n\t\tif(k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline void add(int u, int v, int *h) {\n\tnxt[++ hp] = h[u];\n\th[u] = hp;\n\tto[hp] = v;\n}\n\nint tmp[maxn], tp;\nbool vis[maxn];\nint cx, cy;\nint dfs(int u, int f) {\n\t/* debug(\"%d -> %d\\n\", f, u); */\n\ttmp[++ tp] = u;\n\tvis[u] = 1;\n\tint res = 0;\n\n\tfor(int i = head[u]; i; i = nxt[i], ++ res)\n\t\tif(to[i] != f) {\n\t\t\tif(vis[to[i]]) {\n\t\t\t\tcx = u;\n\t\t\t\tcy = to[i];\n\t\t\t} else\n\t\t\t\tres += dfs(to[i], u);\n\t\t}\n\n\t/* debug(\"dfs %d %d\\n\", u, res); */\n\n\treturn res;\n}\n\nint match[maxn];\nvoid mdfs(int u, int f) {\n\t/* debug(\"%d -> %d\\n\", f, u); */\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f and to[i] != cx) {\n\t\t\tmatch[to[i]] = u;\n\t\t\tmdfs(to[i], u);\n\t\t}\n}\n\nint Head[maxn];\nint deg[maxn];\nint stack[maxn], sp;\nll f[maxn];\nint size[maxn];\nll fac[maxn], ifac[maxn];\n\ninline ll C(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint force_count;\nvoid dp(int u) {\n\t++ force_count;\n\tif(force_count >= maxn * 2) {\n\t\tputs(\"0\");\n\t\texit(0);\n\t}\n\n\tsize[u] = 0;\n\tf[u] = 1;\n\tfor(int i = Head[u]; i; i = nxt[i]) {\n\t\tdp(to[i]);\n\t\tsize[u] += size[to[i]];\n\t\t(f[u] *= f[to[i]]) %= mod;\n\t\t(f[u] *= C(size[u], size[to[i]])) %= mod;\n\t}\n\t++ size[u];\n\tdebug(\"%d : %lld %d\\n\", u, f[u], size[u]);\n}\n\nint HP;\nll solve() {\n\tdebug(\"solve %d %d\\n\", cx, cy);\n\tmdfs(cx, cy);\n\tmatch[cx] = cy;\n\n\thp = HP;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tdeg[tmp[i]] = Head[tmp[i]] = 0;\n\n\tfor(int id = 1; id <= tp; id ++) {\n\t\tint u = tmp[id];\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] < match[u]) {\n\t\t\t\tdebug(\"%d -> %d\\n\", u, to[i]);\n\t\t\t\tadd(u, to[i], Head);\n\t\t\t\t++ deg[to[i]];\n\t\t\t}\n\t}\n\n\tHead[0] = 0;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tif(!deg[tmp[i]])\n\t\t\tadd(0, tmp[i], Head);\n\n\tdp(0);\n\tdebug(\"get %lld\\n\", f[0]);\n\n\treturn f[0];\n}\n\nint main() {\n\tint n = read;\n\n\tint N = n << 1 | 1;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[N] = power(fac[N], -1);\n\tfor(int i = N; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n\n\tfor(int i = 1; i < N; i ++) {\n\t\tint x = read, y = read;\n\t\tadd(x, n + y, head);\n\t\tadd(n + y, x, head);\n\t}\n\n\tHP = hp;\n\tll ans = 1;\n\tint SIZE = 0;\n\n\tfor(int r = 1; r < N; r ++)\n\t\tif(!vis[r]) {\n\t\t\ttp = 0;\n\t\t\tif(dfs(r, 0) != (tp << 1)) return puts(\"0\"), 0;\n\t\t\tll now = solve();\n\t\t\tstd::swap(cx, cy);\n\t\t\tnow += solve();\n\t\t\tSIZE += size[0] - 1;\n\t\t\t(ans *= now) %= mod;\n\t\t\t(ans *= C(SIZE, size[0] - 1)) %= mod;\n\t\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,k,min=0x7f7f7f7f,sum=0,l,x,h;cin>>n;cin>>k;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>x;\n\t\tl=abs(k-x);\n\t\th=x;\n\t\tif(l<min)min=l;\n\t\tif(h<min) min=h;\n\t\tsum=sum+min;\n\t\tmin=0x7f7f7f7f;\n\t}\n\tcout<<2*sum;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define int LL\n#define P pair<int,int>\n#define fi first\n#define se second\nconst LL N=2e5+10;\nconst LL mod=1e9+7;\nconst LL inf=0x3f3f3f;\nconst double eps=1e-9;\nusing namespace std;\ntemplate<typename tp> inline void read(tp &x)\n{\n    x=0;char c=getchar();\n    bool f=0; for(; c<'0'||c>'9'; f|=(c=='-'),c = getchar());\n    for(; c>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0',c = getchar());\n    if(f) x=-x;\n}\nP wei[N<<1];\nmap<P,int> Map;\nvector<P> idd;\nvector<int> line[N],row[N],vec,node;\n \nint n,found;\nint head[N<<1],cnt;\nint fa[N<<1],side[N<<1],vis[N<<1];\nint tou[N<<1],num;\nLL siz[N<<1];\n \nstruct Node { int next,to,id;} edge[N<<3];\nstruct E {int next,to;} e[N<<3];\n \nvoid add(int from,int to,int id) { edge[++cnt]= {head[from],to,id}; head[from]=cnt;}\nvoid insert(int from,int to,int id) { add(from,to,id); add(to,from,id);}\nvoid jia(int from,int to) {e[++num]= {tou[from],to}; tou[from]=num;}\nP calc(int x,int y) { if(x>y) swap(x,y); y-=n; return P(x,y);}\nLL KSM(LL a,LL b,LL ret=1) { while(b) { if(b&1) ret=ret*a%mod; a=a*a%mod; b>>=1; } return ret;}\nint ask(P x) { return lower_bound(idd.begin(),idd.end(),x)-idd.begin()+1;}\n\nvoid dfs(int now,int fath)\n{\n    vis[now]=1;\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        if(found==1) return ;\n        int to=edge[i].to;\n        if(to==fath) continue;\n        if(vis[to])\n        {\n            int flag=now;\n            while(flag!=to)\n            {\n                vec.push_back(flag);\n                flag=fa[flag];\n            }\n            vec.push_back(to);\n            found = 1;\n            return ;\n        }\n        fa[to]=now;\n        dfs(to,now);\n    }\n}\nvoid dfs_side_other(int now,int fa)\n{\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        int to=edge[i].to;\n        if(vis[to]==2||to==fa)\n            continue;\n        vis[to]=1;\n        if(to>n) side[edge[i].id]=2;\n        else side[edge[i].id]=1;\n        node.push_back(edge[i].id);\n        dfs_side_other(to,now);\n    }\n}\nLL dfs_size(int now)\n{\n    if(siz[now]) return siz[now];\n    siz[now]=1;\n    for(int i=tou[now]; i; i=e[i].next)\n    {\n        int to=e[i].to;\n        siz[now]+=dfs_size(to);\n    }\n    return siz[now];\n}\nvoid built()\n{\n    for(int i=0; i<node.size(); i++)\n    {\n        int x=wei[node[i]].fi,y=wei[node[i]].se;\n        if(side[node[i]]==1)\n        {\n            int pos=lower_bound(line[x].begin(),line[x].end(),y)-line[x].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(x,line[x][j])));\n        }\n        else\n        {\n            int pos=lower_bound(row[y].begin(),row[y].end(),x)-row[y].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(row[y][j],y)));\n        }\n    }\n}\nLL solve(int now)\n{\n    found = 0;\n    LL ret1=1,ret2=1;\n    vec.clear(), node.clear();\n    dfs(now,now);\n    // for(int i=0;i<vec.size();i++) cout<<vec[i]<<\" \";puts(\"\");\n    for(int i=0; i<vec.size(); i++) vis[vec[i]]=2;\n    for(int i=0; i<vec.size(); i++) dfs_side_other(vec[i],vec[i]);\n    for(int i=0; i<vec.size()-1; i++)\n    {\n        side[ask(calc(vec[i],vec[i+1]))]=(vec[i+1]>n?1:2);\n        node.push_back(ask(calc(vec[i],vec[i+1])));\n    }\n    side[ask(calc(vec[vec.size()-1],vec[0]))]=(vec[0]>n?1:2);\n    node.push_back(ask(calc(vec[vec.size()-1],vec[0])));\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    // for(int i=0; i<node.size();i++) cout<<node[i]<<\" \";puts(\"\");\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret1=ret1*KSM(dfs_size(node[i]),mod-2)%mod;\n    // puts(\"\");\n    // for(int i=0;i<node.size();i++) cout<<node[i]<<\" \"<<dfs_size(node[i])<<endl;\n    // puts(\"\");\n    num=0;\n    for(int i=0; i<node.size(); i++) tou[node[i]]=0;\n    for(int i=vec.size()-1; i>0; i--)\n        side[ask(calc(vec[i],vec[i-1]))]=(vec[i-1]>n?1:2);\n    side[ask(calc(vec[0],vec[vec.size()-1]))]=(vec[vec.size()-1]>n?1:2);\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret2=ret2*KSM(dfs_size(node[i]),mod-2)%mod;\n    return ret1+ret2;\n}\nsigned main()\n{\n\t// freopen(\"data,in\",\"r\",stdin);\n    read(n);\n    for(int i=1,x,y; i<=n*2; i++)\n    {\n        read(x),read(y),insert(x,y+n,i);\n        // wei[i]=P(x,y);\n        // Map[P(x,y)]=i;\n\t\tidd.push_back(P(x,y));\n        line[x].push_back(y);\n        row[y].push_back(x);\n    }\n\tsort(idd.begin(),idd.end());\n\tfor(int i=0;i<n*2;i++)\n\t\twei[i+1]=idd[i];\n    for(int i=1; i<=n; i++)\n    {\n        sort(line[i].begin(),line[i].end()),\n        sort(row[i].begin(),row[i].end());\n        if(!line[i].size()||!row[i].size())\n            return 0*puts(\"0\");\n    }\n    LL ans=1;\n    for(int i=1; i<=n*2; i++)\n        if(!vis[i])\n            ans=ans*solve(i)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n/*\n3\n2 1\n1 2\n2 2\n3 3\n3 2\n2 3\n \noxo\nxxx\noxx\n \n850000006\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tint sz=V[x].size();\n\t\tref(i,0,sz-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);/*Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;*/res=1;\n\ttp=3;w[o]=2;s=dfs(o);/*Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;*/\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 200005, MOD = 1000000007;\ntypedef long long i64;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N << 2];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n  e[++cnt] = (Edge){head[v], u}, head[v] = cnt;\n}\n\nint N, vis[MAX_N], num_e, num_v, st[MAX_N];\nvoid dfs(int u, int v) {\n  static int tot;\n  st[++num_v] = u, vis[u] = ++tot;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v) {\n      if (!vis[e[i].to]) num_e++, dfs(e[i].to, u);\n      else if (vis[e[i].to] < vis[u]) num_e++;\n    }\n}\n\ni64 fac[MAX_N], ifac[MAX_N], inv[MAX_N];\ni64 binom(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nbool flag;\nint top, cir[MAX_N];\n\nvoid find_circle(int u, int v) {\n  if (flag) return;\n  static int ti[MAX_N], fa[MAX_N];\n  \n  fa[u] = v, ti[u] = 1;\n  \n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v) {\n      if (flag) return;\n      if (!ti[e[i].to]) find_circle(e[i].to, u);\n      else {\n\tint temp = u;\n\tdo {\n\t  cir[top++] = temp;\n\t  temp = fa[temp];\n\t} while (temp != e[i].to);\n\tcir[top++] = e[i].to;\n\tflag = 1;\n      }\n    }\n}\n\nint on[MAX_N], target[MAX_N], in[MAX_N];\n\nvoid dfs2(int u, int v) {\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v && !on[e[i].to]) {\n      target[e[i].to] = u;\n      dfs2(e[i].to, u);\n    }\n}\n\nint sz[MAX_N];\n\ni64 dfs3(int u, int v) {\n  sz[u] = 0;\n  i64 now = 1;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to < target[u]) {\n      i64 temp = dfs3(e[i].to, u);\n      now = now * temp % MOD * binom(sz[u] + sz[e[i].to], sz[u]) % MOD;\n      sz[u] += sz[e[i].to];\n    }\n  sz[u]++;\n  // printf(\"%lld\\n\", now);\n  return now;\n}\n\ni64 calc() {\n  for (int i = 1; i <= num_v; ++i) in[st[i]] = 0;\n  for (int i = 1; i <= num_v; ++i) {\n    for (int j = head[st[i]]; j; j = e[j].nxt)\n      if (e[j].to < target[st[i]]) in[e[j].to]++;\n  }\n  i64 res = 1;\n  int size = 0;\n  for (int i = 1; i <= num_v; ++i)\n    if (in[st[i]] == 0) {\n      res = res * dfs3(st[i], 0) % MOD * binom(sz[st[i]] + size, size) % MOD;\n      size += sz[st[i]];\n    }\n  return res;\n}\n\ni64 work() {\n  flag = 0;\n  find_circle(st[1], 0);\n  for (int i = 0; i < top; ++i) on[cir[i]] = 1;\n  for (int i = 0; i < top; ++i)\n    dfs2(cir[i], 0);\n  i64 now = 0;\n  for (int i = 0; i < top; ++i) target[cir[i]] = cir[(i + 1) % top];\n  now = (now + calc()) % MOD;\n  for (int i = 0; i < top; ++i) target[cir[i]] = cir[(i - 1 + top) % top];\n  now = (now + calc()) % MOD;\n  return now;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1, x, y; i <= N << 1; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    addedge(x, y + N);\n  }\n\n  fac[0] = ifac[0] = inv[1] = 1;\n  for (int i = 1; i <= N << 1; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i <= N << 1; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i <= N << 1; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n  \n  i64 result = 1;\n  int size = 0;\n    \n  for (int i = 1; i <= N << 1; ++i) \n    if (!vis[i]) {\n      num_e = 0, num_v = 0;\n      dfs(i, 0);\n      if (num_e != num_v) {\n\tputs(\"0\");\n\treturn 0;\n      }\n      result = result * work() % MOD * binom(size + num_v, num_v) % MOD;\n      size += num_v;\n    }\n\n  printf(\"%lld\\n\", (result + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=500005,mod=1e9+7;\nint n,cc,tt,tp,ans,a[N],b[N],c[N],fa[N],f[N],dep[N],stk[N],val[N],hd[N],rt[N],cir[N],sz[N],fac[N],ifac[N];\nvector<int>G[N];\nstruct E{int v,nxt,w;}e[N];\ninline void add(int u,int v,int w){e[++cc]=(E){v,hd[u],w};hd[u]=cc;}\ninline int pw(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)r=1ll*r*a%mod;return r;} \nvoid dfs(int x,int p)\n{\n\tc[++c[0]]=stk[++tp]=x;fa[x]=p;dep[x]=dep[p]+1;\n\tfor(int i=hd[x];i;i=e[i].nxt)if(e[i].v!=p)\n\t{\n\t\tval[tp]=e[i].w;\n\t\tif(!dep[e[i].v])dep[e[i].v]=dep[x]+1,dfs(e[i].v,x);\n\t\telse for(int j=tp-dep[x]+dep[e[i].v];j<=tp;j++)cir[stk[j]]=1,a[++tt]=stk[j],b[tt]=val[j];\n\t}\n\ttp--;\n} \nvoid dfs1(int x,int p){for(int i=hd[x];i;i=e[i].nxt)if(e[i].v!=p)val[e[i].v]=e[i].w,dfs1(e[i].v,x);}\nvoid dfs2(int x)\n{\n\tf[x]=sz[x]=1;\n\tfor(int i=0,y;i<G[x].size();i++)dfs2(y=G[x][i]),sz[x]+=sz[y],f[x]=1ll*f[x]*f[y]%mod*ifac[sz[y]]%mod;\n\tf[x]=1ll*f[x]*fac[sz[x]-1]%mod;\n}\nint sol()\n{\n\tint res=1;\n\tfor(int i=1;i<=c[0];i++)G[c[i]].clear(),rt[c[i]]=0;\n\tfor(int i=1;i<=c[0];i++)for(int j=hd[c[i]];j;j=e[j].nxt)if(e[j].w<val[c[i]])G[c[i]].push_back(e[j].v),rt[e[j].v]=1;\n\tfor(int i=1;i<=c[0];i++)if(!rt[c[i]])dfs2(c[i]),res=1ll*res*f[c[i]]%mod*ifac[sz[c[i]]]%mod;\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=fac[0]=1;i<=2*n;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[2*n]=pw(fac[2*n],mod-2);\n\tfor(int i=2*n;i;i--)ifac[i-1]=1ll*ifac[i]*i%mod;\n\tfor(int i=1,u,v;i<=2*n;i++)scanf(\"%d%d\",&u,&v),add(u,v+n,u+v),add(v+n,u,u+v);\n\tans=fac[2*n];\n\tfor(int i=1;i<=2*n;i++)if(!dep[i])\n\t{\n\t\ttt=c[0]=0;dep[i]=1;dfs(i,i);\n\t\tfor(int j=1;j<=tt;j++)for(int k=hd[a[j]];k;k=e[k].nxt)if(!cir[e[k].v])val[e[k].v]=e[k].w,dfs1(e[k].v,a[j]);\n\t\tfor(int j=1;j<=tt;j++)val[a[j]]=b[j];\n\t\tint res=sol();\n\t\tfor(int j=1;j<tt;j++)val[a[j+1]]=b[j];val[a[1]]=b[tt];\n\t\tans=1ll*ans*(res+sol())%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define next nxt\nusing namespace std;\nint fac[400010],nifac[400010],e[400010];\nint first[400010],next[400010],des[400010],w[400010];\nint size[400010],ans,f[400010],vn,en,ed;\nbool vis[400010];\nint tt,n;\nint C(int n,int m){return (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;}\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nvoid dfs(int s,int pre)\n{\n\tvis[s]=true;vn++;\n\tfor (int k=first[s];k;k=next[k])\n\t{\n\t\ten++;\n\t\tif (!vis[des[k]]) {e[des[k]]=k^1;dfs(des[k],s);}\n\t\telse if (des[k]!=pre) ed=k;\n\t}\n}\nvoid dp(int s,int e)\n{\n\tf[s]=1;size[s]=0;\n\tfor (int k=first[s];k;k=next[k]) if (k/2!=ed/2&&((k^1)!=e))\n\t{\n\t\tdp(des[k],k);\n\t\tif (w[k]>w[e]) ans=(long long)ans*nifac[size[des[k]]]%mo*f[des[k]]%mo;\n\t\telse\n\t\t{\n\t\t\tsize[s]+=size[des[k]];\n\t\t\tf[s]=(long long)f[s]*f[des[k]]%mo*C(size[s],size[des[k]])%mo;\n\t\t}\n\t}\n\tsize[s]++;\n}\nint main()\n{\n\ttt=1;scanf(\"%d\",&n);n<<=1;\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);v+=n/2;\n\t\tdes[++tt]=v;next[tt]=first[u];first[u]=tt;\n\t\tdes[++tt]=u;next[tt]=first[v];first[v]=tt;\n\t\tw[tt]=w[tt^1]=u+v;\n\t}\n \n\tint all=fac[n];\n\tfor (int s=1;s<=n;s++) if (!vis[s])\n\t{\n\t\tvn=en=ed=0;dfs(s,0);en>>=1;\n\t\tif (vn!=en) {puts(\"0\");return 0;}\n\t\tint u=des[ed],v=des[ed^1];\n\t\tfor (;u!=v;u=des[e[u]]) if (w[e[u]]>w[ed]) ed=e[u];\n\t\tans=1;dp(des[ed],ed);\n\t\tint p1=(long long)ans*nifac[size[des[ed]]]%mo*f[des[ed]]%mo;\n\t\tans=1;dp(des[ed^1],ed);\n\t\tint p2=(long long)ans*nifac[size[des[ed^1]]]%mo*f[des[ed^1]]%mo;\n\t\tall=(long long)all*(p1+p2)%mo;\n\t}\n\tprintf(\"%d\\n\",all);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define mod 1000000007\n#define next nxt\n \nint n,x[N],y[N],z[N],next[N],p[N],h[N],q[N],s[N],cnt,cmt,cir;\nlong long fac[N],inv[N],ans;\nvector<int> v[N];\n \nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n \nvoid travel(int x,int pre){\n\th[x]=true;q[++cnt]=x;\n\tfor (int t=p[x];t;cmt++,t=next[t])\n\t\tif (!h[y[t]]) travel(y[t],t);\n\t\telse if (t/2!=pre/2) cir=t;\n}\n \nvoid build(int x,int pre){\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (t/2!=pre/2){\n\t\t\tif (y[t]<y[pre^1]) v[x].push_back(y[t]),h[y[t]]=true;\n\t\t\tif (t/2!=cir/2) build(y[t],t);\n\t\t}\n}\n \nlong long solve(int x){\n\ts[x]=0;long long ans=1;\n\tfor (int i=0;i<(int)v[x].size();i++){\n\t\tans=ans*solve(v[x][i])%mod;\n\t\ts[x]+=s[v[x][i]];\n\t\tans=ans*C(s[x],s[v[x][i]])%mod;\n\t}\n\ts[x]++;return ans;\n}\n \nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();\n\tfor (int i=1;i<=2*n;i++){\n\t\tx[2*i]=y[2*i+1]=read();\n\t\ty[2*i]=x[2*i+1]=n+read();\n\t\tz[2*i]=z[2*i+1]=x[2*i]+y[2*i];\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t\tnext[2*i+1]=p[x[2*i+1]];p[x[2*i+1]]=2*i+1;\n\t}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tans=fac[2*n];\n\tfor (int i=1;i<=2*n;i++)\n\t\tif (!h[i]){\n\t\t\tcnt=cmt=0;travel(i,0);\n\t\t\tif (cmt!=cnt*2) {printf(\"0\\n\");return 0;}\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),h[q[i]]=false;\n\t\t\tbuild(y[cir],cir);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!h[q[i]]) v[0].push_back(q[i]),h[q[i]]=1;\n\t\t\tlong long tmp=solve(0);\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),h[q[i]]=false;\n\t\t\tbuild(y[cir^1],cir^1);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!h[q[i]]) v[0].push_back(q[i]),h[q[i]]=1;\n\t\t\ttmp+=solve(0);\n\t\t\t\n\t\t\tans=ans*tmp%mod*inv[cnt]%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint sz, N, fac[200009], inv[200009], fath[200009], ap[200009], q[200009], val[200009], cnt[200009];\nvector < int > v[200009], sons[200009];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=1; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\npair < int, int > combine (pair < int, int > a, pair < int, int > b)\n{\n    return {a.first + b.first, mul (mul (a.second, b.second), comb (a.first + b.first, a.first))};\n}\n\npair < int, int > ways (int node)\n{\n    if (sons[node].empty ()) return {1, 1};\n    pair < int, int > ans = {0, 1};///length, ways\n    for (auto v : sons[node])\n        ans = combine (ans, ways (v));\n    ans.first ++;\n    return ans;\n}\n\nvector < int > curr;\nvoid ever (int i) {curr.push_back (i);}\nvoid Clear () {for (auto i : curr) fath[i] = 0, sons[i].clear (); curr.clear ();}\n\nvoid dfs (int nod, int tata)\n{\n    ever (nod);\n    for (auto fiu : v[nod])\n        if (fiu != tata && ap[fiu] == 1)\n        {\n            val[fiu] = nod, dfs (fiu, nod);\n            if (fiu < val[nod])\n                fath[fiu] = nod;\n        }\n}\n\npair < int, int > solve ()\n{\n    q[sz + 1] = q[1];\n    for (int i=1; i<=sz; i++)\n        if (q[i - 1] < q[i + 1])\n            fath[q[i - 1]] = q[i];\n    for (int i=1; i<=sz; i++)\n        val[q[i]] = q[i + 1], dfs (q[i], -1);\n    sort (curr.begin (), curr.end ());\n    curr.erase (unique (curr.begin (), curr.end ()), curr.end ());\n    for (auto it : curr)\n    {\n  //      printf (\"(%d, %d) \", it, fath[it]);\n        if (fath[it] != 0)\n            sons[fath[it]].push_back (it);\n    }\n//    printf (\"\\n\");\n    pair < int, int > ans = {0, 1};\n    for (auto it : curr)\n        if (fath[it] == 0)\n            ans = combine (ans, ways (it));\n    Clear ();\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=2 * N; i++)\n{\n    int x, y;\n    scanf (\"%d %d\", &x, &y), y += N;\n    v[x].push_back (y), v[y].push_back (x);\n}\nN += N, Prec (N + 1);\nfor (int i=1; i<=N; i++)\n    if (v[i].size () == 0)\n    {\n        printf (\"0\\n\");\n        return 0;\n    }\nfor (int i=1; i<=N; i++)\n{\n    cnt[i] = v[i].size ();\n    if (cnt[i] == 1)\n        q[++sz] = i, ap[i] = 1;\n}\nfor (int i=1; i<=sz; i++)\n    for (auto j : v[q[i]])\n    {\n        cnt[j] --;\n        if (cnt[j] == 1)\n            q[++sz] = j, ap[j] = 1;\n    }\nfor (int i=1; i<=N; i++)\n    if (ap[i] == 0 && cnt[i] != 2)\n    {\n        printf (\"0\\n\");\n        return 0;\n    }\npair < int, int > ans = {0, 1};\nfor (int I=1; I<=N; I++)\n    if (ap[I] == 0)\n    {\n        int sum = 0, L = 0;\n        for (auto rd : v[I])\n        if (ap[rd] == 0)\n        {\n            sz = 1, q[1] = I, q[0] = rd;\n            for (int i=1;; i++)\n            {\n                q[i + 1] = 0;\n                for (auto nxt : v[q[i]])\n                    if (nxt != q[i - 1] && ap[nxt] == 0)\n                    {\n                        q[i + 1] = nxt;\n                        break;\n                    }\n                if (q[i + 1] == 0)\n                {\n                    printf (\"0\\n\");\n                    return 0;\n                }\n                if (q[i + 1] == q[0])\n                {\n                    sz = i + 1;\n                    break;\n                }\n            }\n            pair < int, int > curr = solve ();\n            adto (sum, curr.second), L = curr.first;\n        }\n        for (int i=1; i<=sz; i++)\n            ap[q[i]] = 1;\n        ans = combine (ans, {L, sum});\n    }\nprintf (\"%d\\n\", ans.second);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nint n,cnt=0,num=0;\nvi x,y,ax,ay,vis,b,c,d,used;\nvl dp;\nvvi g,G;\nvvp X,Y;\n\nint dfs(int v,int w){\n\tb.push_back(v);\n\tvis[v]++;cnt++;\n\tif(!ax[x[v]]) num++,ax[x[v]]=1;\n\tif(!ay[y[v]]) num++,ay[y[v]]=1;\n\tint t=-1;\n\tfor(auto u:g[v]) if(u!=-1&&u!=w){\n\t\tif(vis[u]&&w!=-1){\n\t\t\tint I=d.size()-1;\n\t\t\tpip p={{x[u],y[u]},u};\n\t\t\twhile(I>=0&&d[I]!=u){\n\t\t\t\tint u_=d[I--];\n\t\t\t\tp=min(p,{{x[u_],y[u_]},u_});\n\t\t\t}\n\t\t\tt=p.second;\n\t\t}\n\t\telse if(!vis[u]){\n\t\t\td.push_back(u);\n\t\t\tint t_=dfs(u,v);\n\t\t\tif(t_!=-1) t=t_;\n\t\t\td.pop_back();\n\t\t}\n\t}\n\treturn t;\n}\n\nvoid DFS(int v,int I){\n\tint u=g[v][I];\n\tif(u==-1||c[u]!=-1) return;\n\tc[u]=1-I%2;\n\tfor(int i=0;i<4;i++){\n\t\tint w=g[u][i];\n\t\tif(w!=-1&&c[w]==-1) DFS(u,i);\n\t}\n}\n\npll Rec(int v){\n\tll res=1,S=0;\n\tfor(auto u:G[v]){\n\t\tpll p=Rec(u);\n\t\tll T=p.second;\n\t\tres=Div(res*p.first%mod,F[T]);\n\t\tS+=T;\n\t}\n\t(res*=F[S])%=mod;\n\treturn {res,S+1};\n}\n\nll f(int v,int t){\n\tc[v]=t;\n\tfor(int i=0;i<4;i++) DFS(v,i%2*2+abs(i/2-t));\n\tfor(auto i:b){\n\t\tint u=g[i][c[i]];\n\t\twhile(u!=-1){\n\t\t\tG[i].push_back(u);\n\t\t\tused[u]=1;\n\t\t\tu=g[u][c[i]];\n\t\t}\n\t}\n\tfor(auto i:b) if(!used[i]) G[n].push_back(i);\n\tll res=Rec(n).first;\n\tfor(auto i:b){\n\t\tc[i]=-1;\n\t\tused[i]=0;\n\t\tG[i].clear();\n\t}\n\tG[n].clear();\n\treturn res;\n}\n\nint main(){\n\tInit();\n\tcin>>n;\n\tn*=2;\n\tx=y=ax=ay=vis=used=vi(n);\n\tc=vi(n,-1);\n\tX=Y=vvp(n);\n\tg=vvi(n,vi(4,-1));\n\tG=vvi(n+1);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tx[i]--;y[i]--;\n\t\tX[x[i]].push_back({y[i],i});\n\t\tY[y[i]].push_back({x[i],i});\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tsort(X[i].begin(),X[i].end());\n\t\tsort(Y[i].begin(),Y[i].end());\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<X[i].size();j++){\n\t\t\tint u=X[i][j-1].second,v=X[i][j].second;\n\t\t\tg[u][3]=v;g[v][1]=u;\n\t\t}\n\t\tfor(int j=1;j<Y[i].size();j++){\n\t\t\tint u=Y[i][j-1].second,v=Y[i][j].second;\n\t\t\tg[u][2]=v;g[v][0]=u;\n\t\t}\n\t}\n\tll res=F[n];\n\tfor(int i=0;i<n;i++) if(!vis[i]){\n\t\tcnt=0;num=0;\n\t\tb.clear();d.clear();\n\t\td.push_back(i);\n//\t\tint v=dfs(i,-1);\n\t\td.pop_back();\n//\t\tres=(cnt==num?Div(res*(f(v,0)+f(v,1))%mod,F[cnt]):0);\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "    #include<cstdio>\n    const int MaxN=200010,mod=1000000007;\n    int N;\n    long long fac[MaxN],ifac[MaxN];\n    long long inv(int a,int p=mod){return a==1?1:(1+p*(a-inv(p%a,a)))/a%p;}\n    struct edge{int to;edge*next;}E[MaxN*2],*ne=E,*fir[MaxN];\n    void link(int u,int v){*ne=(edge){v,fir[u]};fir[u]=ne++;}\n    int Q[MaxN],deg[MaxN],S[MaxN],fa[MaxN],siz[MaxN],C[MaxN];\n    bool vis[MaxN];\n    int dfs(int i){\n    \tsiz[i]=1;\n    \tint s=1;\n    \tfor(edge*e=fir[i];e;e=e->next)\n    \t\tif(fa[e->to]==i&&e->to<fa[i])s=1ll*s*dfs(e->to)%mod,siz[i]+=siz[e->to];\n    \treturn 1ll*s*ifac[siz[i]]%mod*fac[siz[i]-1]%mod;\n    }\n    int solve(int v){\n    \tint*h=Q,*t=Q+1,es=0;\n    \tvis[*Q=v]=1;\n    \tfor(;h<t;es+=deg[*h++])\n    \t\tfor(edge*e=fir[*h];e;e=e->next,deg[*h]++)\n    \t\t\tif(!vis[e->to])vis[*t++=e->to]=1;\n    \tif(es!=(t-Q)*2)return 0;\n    \tint*tp=S;\n    \tfor(int*i=Q;i<t;i++)if(deg[*i]==1)*tp++=*i;\n    \twhile(tp>S){\n    \t\tint x=*--tp;\n    \t\tfor(edge*e=fir[x];e;e=e->next)\n    \t\t\tif(--deg[e->to])deg[fa[x]=e->to]==1?*tp++=e->to:1;\n    \t}\n    \tint len=0;\n    \tfor(int*i=Q;i<t;i++)if(deg[*i]>1){\n    \t\tfor(int j=*i;deg[j];){\n    \t\t\tdeg[C[len++]=j]=0;\n    \t\t\tfor(edge*e=fir[j];e;e=e->next)\n    \t\t\t\tif(deg[e->to]>1){j=e->to;break;}\n    \t\t}\n    \t\tbreak;\n    \t}\n    \tint sum=0;\n    \tfor(int dir=0;dir<2;dir++){\n    \t\tint s=1;\n    \t\tfor(int i=0;i<len;i++)fa[C[i]]=C[(dir?i+len-1:i+1)%len];\n    \t\tfor(int*i=Q;i<t;i++)if(*i>fa[fa[*i]])s=1ll*s*dfs(*i)%mod;\n    \t\t(sum+=s)%=mod;\n    \t}\n    \treturn sum;\n    }\n    int main(){\n    \tscanf(\"%d\",&N);\n    \tfor(int i=*fac=1;i<=N*2;i++)fac[i]=fac[i-1]*i%mod;\n    \tifac[N*2]=inv(fac[N*2]);\n    \tfor(int i=N*2;i;i--)ifac[i-1]=ifac[i]*i%mod;\n    \tfor(int i=0,x,y;i<N*2;i++)scanf(\"%d%d\",&x,&y),link(x,y+=N),link(y,x);\n    \tint s=fac[N*2];\n    \tfor(int i=1;i<=N*2;i++)if(!vis[i])s=1ll*s*solve(i)%mod;\n    \tprintf(\"%d\\n\",s);\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 200005;\nconst ll M = ll(1e9) + 7;\n\nstruct E{ int x, i; };\n\nint n, ln, vis[MN], cyc[MN], as[MN], nas[MN], vc, ec, sz[MN], oth[MN], hp[MN], fnd;\nvector<E> e[MN];\nvector<int> vl, cv, tv, ch[MN];\nll fc[MN], ifc[MN], ans = 1;\n\nvoid T_T(){\n\tputs(\"0\");\n\texit(0);\n}\n\nll pw(ll x, ll k){\n\tif(k == 1) return x;\n\treturn pw(x * x % M, k / 2) * (k % 2 ? x : 1) % M;\n}\n\nll cm(int n, int r){\n\treturn fc[n] * ifc[r] % M * ifc[n - r] % M;\n}\n\nvoid g(int x){\n\tvis[x] = 1;\n\tvc++;\n\tec += e[x].size();\n\ttv.push_back(x);\n\tfor(auto &i : e[x]) if(!vis[i.x]) g(i.x);\n}\n\nvoid h(int x, int p){\n\t//printf(\"%d\\n\", x);\n\tif(vis[x] == 2){\n\t\t//puts(\"CYCLE\");\n\t\tcyc[x] = 1;\n\t\tcv.push_back(x);\n\t\tfor(int i = int(vl.size()) - 1; vl[i] != x; i--){\n\t\t\t//printf(\"%d\\n\", vl[i]);\n\t\t\tcyc[vl[i]] = 1;\n\t\t\tcv.push_back(vl[i]);\n\t\t}\n\t\t//puts(\"--\");\n\t\tfnd = 1;\n\t\treturn;\n\t}\n\tvis[x] = 2;\n\tvl.push_back(x);\n\tfor(auto &i : e[x]){\n\t\tif(i.x != p){\n\t\t\t//printf(\"%d -> %d\\n\", x, i.x);\n\t\t\th(i.x, x);\n\t\t}\n\t\tif(fnd) return;\n\t}\n\tvl.pop_back();\n}\n\nvoid af(int x, int p){\n\tfor(auto &i : e[x]){\n\t\tif(i.x != p && !cyc[i.x]){\n\t\t\tas[i.x] = nas[i.x] = i.i;\n\t\t\taf(i.x, x);\n\t\t}\n\t}\n}\n\nvoid cf(){\n\tint cs = int(cv.size());\n\tfor(int i = 0; i < cs; i++){\n\t\tfor(auto &j : e[cv[i]]){\n\t\t\tif(j.x == cv[(i + 1) % cs]){\n\t\t\t\t//printf(\"%d : %d - %d (%d)\\n\", i, cv[i], j.x, j.i);\n\t\t\t\tas[cv[i]] = nas[j.x] = j.i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint sf(int x){\n\tsz[x] = 1;\n\tvc++;\n\tfor(auto &i : ch[x]) sz[x] += sf(i);\n\treturn sz[x];\n}\n\nll tf(int x){\n\tll ret = 1;\n\tint cs = sz[x] - 1;\n\tfor(auto &i : ch[x]){\n\t\tret = ret * cm(cs, sz[i]) % M;\n\t\tret = ret * tf(i) % M;\n\t\tcs -= sz[i];\n\t}\n\t//printf(\"tf %d : %lld\\n\", x, ret);\n\treturn ret;\n}\n\nll get(){\n\t//puts(\"GET\");\n\tfor(auto &i : tv){\n\t\tint to = oth[as[i]] - i;\n\t\tfor(auto &j : e[i]){\n\t\t\tif(j.x < to){\n\t\t\t\t//printf(\"%d - %d\\n\", j.x, i);\n\t\t\t\tch[i].push_back(j.x);\n\t\t\t\thp[j.x]++;\n\t\t\t}\n\t\t}\n\t}\n\tll ret = 1;\n\tint tln = int(tv.size());\n\tfor(auto &i : tv){\n\t\tif(!hp[i]){\n\t\t\tvc = 0;\n\t\t\tsf(i);\n\t\t\tret = ret * cm(tln, vc) % M;\n\t\t\tret = ret * tf(i) % M;\n\t\t\ttln -= vc;\n\t\t}\n\t}\n\tfor(auto &i : tv){\n\t\tfor(auto &j : ch[i]){\n\t\t\thp[j]--;\n\t\t}\n\t\tch[i].clear();\n\t}\n\treturn ret;\n}\n\nll f(int x){\n\tvl.clear();\n\tcv.clear();\n\tfnd = 0;\n\th(x, x);\n\tfor(auto &i : cv) af(i, i);\n\tcf();\n\t//for(auto &i : cv) printf(\"%d : %d %d\\n\", i, as[i], nas[i]);\n\tll t = get();\n\tfor(auto &i : cv) as[i] = nas[i];\n\tt += get();\n\treturn t % M;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, x, y; i <= 2 * n; i++){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ty += n;\n\t\te[x].push_back({y, i});\n\t\te[y].push_back({x, i});\n\t\toth[i] = x + y;\n\t}\n\tfc[0] = ifc[0] = 1;\n\tfor(int i = 1; i <= 2 * n; i++){\n\t\tfc[i] = fc[i - 1] * i % M;\n\t\tifc[i] = pw(fc[i], M - 2);\n\t}\n\tln = 2 * n;\n\tfor(int i = 1; i <= 2 * n; i++){\n\t\tif(!vis[i]){\n\t\t\tvc = ec = 0;\n\t\t\ttv.clear();\n\t\t\tg(i);\n\t\t\tif(ec != 2 * vc) T_T();\n\t\t\t//printf(\"%d %d\\n\", ln, vc);\n\t\t\tans = ans * cm(ln, vc) % M;\n\t\t\tln -= vc;\n\t\t\t//printf(\"%lld\\n\", ans);\n\t\t\tans = ans * f(i) % M;\n\t\t\t//printf(\"////// %lld\\n\", ans);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define MAXN 200005\n#define mod 1000000007\nusing namespace std;\n\nint n, mark[MAXN], deg[MAXN], dp[MAXN], sz[MAXN];\nint fact[MAXN], ifact[MAXN];\nvector<int> G[MAXN], Gmark[MAXN];\nvector<pair<int, int>> partialSol;\nbool uz[MAXN], uz2[MAXN], inCycle[MAXN];\n\nint pwmod(int x, int n) {\n    if (n == 0)\n        return 1;\n    return 1LL * pwmod(1LL * x * x % mod, n >> 1) * ((n & 1) ? x : 1) % mod;\n}\n\nvoid precalcFact() {\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n        ifact[i] = pwmod(fact[i], mod - 2);\n    }\n}\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * ifact[k] % mod * ifact[n - k] % mod;\n}\n\nvoid DFS(int u, int &numNodes, int &numEdges) {\n    uz[u] = 1;\n    ++numNodes;\n\n    for (auto x: G[u]) {\n        ++numEdges;\n        if (!uz[x])\n            DFS(x, numNodes, numEdges);\n    }\n}\n\nvoid findCycle(int u, int p, vector<int> &cycle, vector<int> &st, vector<int> &nodes) {\n    st.push_back(u);\n    nodes.push_back(u);\n    uz2[u] = 1;\n\n    for (auto x: G[u]) {\n        if (x == p)\n            continue;\n        if (uz2[x]) {\n            if (cycle.empty()) {\n                for (int j = (int) st.size() - 1; j >= 0 && st[j] != x; j--)\n                    cycle.push_back(st[j]);\n                cycle.push_back(x);\n            }\n        }\n        else\n            findCycle(x, u, cycle, st, nodes);\n    }\n\n    st.pop_back();\n}\n\nvoid DFSmark(int u, int p) {\n    for (auto x: G[u]) {\n        if (x != p && !inCycle[x]) {\n            mark[x] = u;\n            DFSmark(x, u);\n        }\n    }\n}\n\nbool getTopSort(vector<int> &nodes, vector<int> &topSort) {\n    queue<int> q;\n\n    q.push(0);\n    while (!q.empty()) {\n        int x = q.front();\n        q.pop();\n\n        topSort.push_back(x);\n        for (auto y: Gmark[x]) {\n            if (--deg[y] == 0)\n                q.push(y);\n        }\n    }\n\n    return topSort.size() == nodes.size();\n}\n\nint solveMark(vector<int> &nodes) {\n    nodes.push_back(0);\n    for (auto x: nodes) {\n        Gmark[x].clear();\n        deg[x] = dp[x] = sz[x] = 0;\n    }\n\n    for (auto x: nodes) {\n        for (auto y: G[x]) {\n            if (y == mark[x])\n                break;\n            Gmark[x].push_back(y);\n            ++deg[y];\n        }\n    }\n    for (auto x: nodes) {\n        if (x != 0 && deg[x] == 0) {\n            Gmark[0].push_back(x);\n            ++deg[x];\n        }\n    }\n\n    vector<int> topSort;\n    if (!getTopSort(nodes, topSort)) {\n        nodes.pop_back();\n        return -1;\n    }\n\n    reverse(topSort.begin(), topSort.end());\n    for (auto x: topSort) {\n        long long dpx = 1;\n        int crtSz = 0;\n\n        for (auto y: Gmark[x]) {\n            crtSz += sz[y];\n            dpx = dpx * dp[y] % mod * comb(crtSz, sz[y]) % mod;\n        }\n        sz[x] = crtSz + 1;\n        dp[x] = (int) dpx;\n    }\n\n    nodes.pop_back();\n    return dp[0];\n}\n\npair<int, int> solve(int u) {\n    vector<int> cycle, st, nodes;\n\n    findCycle(u, 0, cycle, st, nodes);\n\n    for (auto x: cycle)\n        inCycle[x] = 1;\n\n    for (auto x: cycle)\n        DFSmark(x, 0);\n\n    cycle.push_back(cycle[0]);\n    int cycleSize = (int) cycle.size();\n    for (int i = 0; i < cycleSize - 1; ++i)\n        mark[cycle[i]] = cycle[i + 1];\n\n    int sol1 = solveMark(nodes);\n\n    for (int i = 1; i < cycleSize; ++i)\n        mark[cycle[i]] = cycle[i - 1];\n\n    int sol2 = solveMark(nodes);\n\n    if (sol1 < 0 && sol2 < 0)\n        return make_pair(-1, -1);\n    sol1 = max(sol1, 0);\n    sol2 = max(sol2, 0);\n\n    return make_pair((sol1 + sol2) % mod, (int) nodes.size());\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n\n    precalcFact();\n    cin >> n;\n    for (int i = 1; i <= 2 * n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y + n);\n        G[y + n].push_back(x);\n    }\n\n    for (int i = 1; i <= 2 * n; ++i)\n        sort(G[i].begin(), G[i].end());\n\n    for (int i = 1; i <= 2 * n; ++i) {\n        if (!uz[i]) {\n            int numNodes = 0;\n            int numEdges = 0;\n            \n            DFS(i, numNodes, numEdges);\n            numEdges >>= 1;\n\n            if (numEdges != numNodes) {\n                cout << \"0\\n\";\n                return 0;\n            }\n            pair<int, int> crtSol = solve(i);\n            if (crtSol.first < 0) {\n                cout << \"0\\n\";\n                return 0;\n            }\n\n            partialSol.push_back(crtSol);\n        }\n    }\n\n    long long ans = 1;\n    int crtSz = 0;\n\n    for (auto x: partialSol) {\n        crtSz += x.second;\n        ans = ans * x.first % mod * comb(crtSz, x.second) % mod;\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    UnionFind(int);\n    int find(int);\n    void unite(int, int);\nprivate:\n    vector<int> table;\n};\n\nUnionFind::UnionFind(int size) {\n    table.resize(size);\n    fill(table.begin(), table.end(), -1);\n}\n\nint UnionFind::find(int x) {\n    while (0 <= table[x])\n        x = table[x];\n    return x;\n}\n\nvoid UnionFind::unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry) {\n        int dx = -table[rx];\n        int dy = -table[ry];\n        if (dx != dy) {\n            if (dx < dy) {\n                table[rx] = ry;\n            } else {\n                table[ry] = rx;\n            }\n        } else {\n            table[rx] -= 1;\n            table[ry] = rx;\n        }\n    }\n}\n\n\nconst long M = 1e9 + 7;\nint N;\nlong F[202020];\nint groups[202020];\nint pair_table[202020];\nint counts[202020];\nlong perms[202020];\nvector< vector<int> > edges;\nvector<bool> is_root;\n\n\nlong powmod(long a, long x, long m) {\n    long r = 1;\n    while (0 < x) {\n        if (x & 1) {\n            r *= a;\n            r %= m;\n        }\n        x >>= 1;\n        a *= a;\n        a %= m;\n    }\n    return r;\n}\n\n\nvoid calc_node(int node, const vector< vector<int> > &tree) {\n    if (tree[node].size() == 0) {\n        counts[node] = 1;\n        perms[node] = 1;\n    } else {\n        int c;\n        \n        c = 0;\n        for (int child : tree[node]) {\n            calc_node(child, tree);\n            c += counts[child];\n        }\n        counts[node] = c + 1;\n\n        long p;\n\n        p = F[c];\n        for (int child : tree[node]) {\n            p *= powmod(F[counts[child]], M - 2, M);\n            p %= M;\n            p *= perms[child];\n            p %= M;\n        }\n        perms[node] = p;\n    }\n}\n\nlong calc(const vector<int> &nodes) {\n    vector< vector<int> > tree;\n    int nv, nnv;\n    int c;\n    long p;\n\n    fill(is_root.begin(), is_root.end(), true);\n    tree.resize(2 * N);\n\n    for (int v : nodes) {\n        nv = pair_table[v];\n        nnv = pair_table[nv];\n        if (v < nnv) {\n            is_root[v] = false;\n            tree[nv].push_back(v);\n        }\n    }\n\n    c = 0;\n    for (int v : nodes) {\n        if (is_root[v]) {\n            calc_node(v, tree);\n            c += counts[v];\n        }\n    }\n\n    p = F[c];\n    for (int v : nodes) {\n        if (is_root[v]) {\n            p *= powmod(F[counts[v]], M - 2, M);\n            p %= M;\n            p *= perms[v];\n            p %= M;\n        }\n    }\n\n    return p;\n}\n\n\n\nlong solve(const vector<int> &nodes) {\n    int pv, nv;\n\n    for (int v : nodes) {\n        if (edges[v].size() == 1) {\n            nv = edges[v].back();\n            edges[v].pop_back();\n            pair_table[v] = nv;\n            edges[nv].erase(find(edges[nv].begin(), edges[nv].end(), v));\n            pv = v; v = nv;\n            while (edges[v].size() == 1) {\n                nv = edges[v].back();\n                edges[v].pop_back();\n                pair_table[v] = nv;\n                edges[nv].erase(find(edges[nv].begin(), edges[nv].end(), v));\n                pv = v; v = nv;\n            }\n        }\n    }\n\n    int v0 = 0;\n    int v1, v2;\n    for (int v : nodes) {\n        if (edges[v].size() != 0) {\n            v0 = v;\n            break;\n        }\n    }\n    v1 = edges[v0][0];\n    v2 = edges[v0][1];\n\n    long r = 0;\n    int v;\n    int nv0, nv1, nv2;\n    rep(d, 0, 2) {\n        nv0 = (d == 0) ? v1 : v2;\n        nv = nv0; v = v0;\n        pair_table[v] = nv;\n        pv = v; v = nv;\n        while (v != v0) {\n            nv1 = edges[v][0];\n            nv2 = edges[v][1];\n            nv = (nv1 != pv) ? nv1 : nv2;\n            pair_table[v] = nv;\n            pv = v; v = nv;\n        }\n        r += calc(nodes);\n        r %= M;\n    }\n\n    return r;\n}\n\n\nint main(int argc, const char * argv[]) {\n    vector< tuple<int, int> > balls;\n    int x, y;\n\n    cin >> N;\n    rep(i, 0, 2 * N) {\n        cin >> x >> y;\n        balls.push_back(make_tuple(x - 1, N + y - 1));\n    }\n\n    {\n        long p = 1;\n        rep(i, 1, 2 * N + 1) {\n            p *= i;\n            p %= M;\n            F[i] = p;\n        }\n    }\n\n    UnionFind uf(2 * N);\n    edges.resize(2 * N);\n    is_root.resize(2 * N);\n\n    for (tuple<int, int> t : balls) {\n        int x = get<0>(t);\n        int y = get<1>(t);\n        uf.unite(x, y);\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n\n    long ans = F[2 * N];\n    vector<int> nodes;\n    unsigned long num_nodes, num_edges;\n\n    \n    rep(i, 0, 2 * N) {\n        if (edges[i].empty()) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n\n    rep(i, 0, 2 * N) groups[i] = uf.find(i);\n    \n    rep(i, 0, 2 * N) {\n        if (groups[i] == i) {\n            nodes.clear();\n            rep(v, 0, 2 * N) {\n                if (groups[v] == i) {\n                    nodes.push_back(v);\n                }\n            }\n            num_nodes = nodes.size();\n            num_edges = 0;\n            for (int v : nodes) {\n                num_edges += edges[v].size();\n            }\n            num_edges /= 2;\n            if (num_nodes != num_edges) {\n                cout << 0 << endl;\n                return 0;\n            }\n            ans *= powmod(F[num_nodes], M - 2, M);\n            ans %= M;\n            ans *= solve(nodes);\n            ans %= M;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nint x[210000];\nint y[210000];\nint UF[210000];\nvector<int>g[210000];\nint FIND(int a){\n\tif(UF[a]<0)return a;return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint h[210000];\nint v[210000];\nvector<int>cy;\nvector<int>cur;\nint dfs(int a,int b){\n\tv[a]=b;\n\t\n\tcur.push_back(a);\n\tint ret=-2;\n\t// printf(\"%d %d %d\\n\",a,b,(int)g[a].size());\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]==b)continue;\n\t\tif(v[g[a][i]]==-2){\n\t\t\tint val=dfs(g[a][i],a);\n\t\t\tif(val!=-2){\n\t\t\t\tcy.push_back(a);\n\t\t\t\tif(a==val)val=-2;\n\t\t\t}\n\t\t\tif(val!=-2) ret=val;\n\t\t}else{\n\t\t\tcy.push_back(a);\n\t\t\treturn g[a][i];\n\t\t}\n\t}\n\t// printf(\"fin %d %d\\n\",a,b);fflush(stdout);\n\treturn ret;\n}\nvector<int>g2[210000];\nint sz[210000];\nint ou[210000];\nlong long calc(int a){\n\tlong long ret=1;\n\tsz[a]=0;\n\tfor(int i=0;i<g2[a].size();i++){\n\t\tret=ret*calc(g2[a][i])%mod;\n\t\tret=ret*Comb(sz[a]+sz[g2[a][i]],sz[a])%mod;\n\t\tsz[a]+=sz[g2[a][i]];\n\t}\n\tsz[a]++;\n\t// printf(\"%d: %lld\\n\",a,ret);\n\treturn ret;\n}\nint tl[210000];\nint n;\nvoid dfs2(int a,int b){\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\t// printf(\"%d %d\\n\",a,g[a][i]);\n\t\ttl[g[a][i]]=a;\n\t\tif(g[a][i]==cy[0])continue;\n\t\tdfs2(g[a][i],a);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tfor(int i=0;i<a*2;i++)UF[i]=-1;\n\tfor(int i=0;i<a*2;i++)v[i]=-2;\n\tinit_C(410000);\n\tfor(int i=0;i<2*a;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tx[i]--;y[i]--;\n\t\tg[x[i]].push_back(y[i]+a);\n\t\tg[y[i]+a].push_back(x[i]);\n\t\tUNION(x[i],y[i]+a);\n\t}\n\tfor(int i=0;i<a*2;i++){\n\t\th[FIND(x[i])]++;\n\t}\n\tlong long ret=1;\n\tlong long ks=1;\n\tint tn=0;\n\tfor(int i=0;i<a*2;i++){\n\t\tif(UF[i]<0&&h[i]!=-UF[i]){\n\t\t\tprintf(\"0\\n\");return 0;\n\t\t}\n\t\tif(UF[i]<0){\n\t\t\tcur.clear();\n\t\t\tks=ks*Comb(tn+h[i],h[i])%mod;\n\t\t\ttn+=h[i];\n\t\t\tcy.clear();\n\t\t\tdfs(i,-1);\n\t\t\t// for(int j=0;j<cy.size();j++)printf(\"%d \",cy[j]);printf(\"\\n\");\n\t\t\tlong long tmp=0;\n\t\t\tfor(int k=0;k<2;k++){\n\n\t\t\t\tif(k==0)dfs2(cy[0],cy[1]);\n\t\t\t\telse dfs2(cy[0],cy[cy.size()-1]);\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tfor(int k=0;k<g[cur[j]].size();k++){\n\t\t\t\t\t\tint to=g[cur[j]][k];\n\t\t\t\t\t\tif(to<tl[cur[j]]){\n\t\t\t\t\t\t\tg2[cur[j]].push_back(to);\n\t\t\t\t\t\t\t// printf(\"%d %d\\n\",cur[j],to);\n\t\t\t\t\t\t\tou[to]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tif(!ou[cur[j]]){\n\t\t\t\t\t\tg2[a*2].push_back(cur[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp+=calc(a*2);\n\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tg2[cur[j]].clear();\n\t\t\t\t\tou[cur[j]]=0;\n\t\t\t\t}\n\t\t\t\tg2[a*2].clear();\n\t\t\t}\n\t\t\ttmp%=mod;\n\t\t\t// printf(\"%d: %lld\\n\",i,tmp);\n\t\t\tret=ret*tmp%mod;\n\t\t}\n\t}\n\n\tret=ret*ks%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\n#define int long long\nusing namespace std;\nconst int p = 1000000007;\nint n;\nint head[N],ver[N],nxt[N],tot;\nvoid add(int a,int b)\n{\n    tot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;return ;\n}\nint jie[N],ni[N];\nint c(int x,int y)\n{\n    return 1LL*jie[x]*ni[y]%p*ni[x-y]%p;\n}\nint v[N],dian,bian,st[N],top;\nint pi[N],cir[N],sz,q[N];\nvoid dfs(int x,int fa)\n{\n    st[++top]=x;\n    v[x]=1;q[++dian]=x;\n    for(int i=head[x];i;i=nxt[i])\n    {\n        bian++;\n        if(!v[ver[i]])dfs(ver[i],x);\n        else if(ver[i]!=fa&&!sz)\n        {\n            for(int j=top;j>=1;j--)\n            {\n                cir[++sz]=st[j];\n                if(st[j]==ver[i])break;\n            }\n        }\n    }\n    top--;\n    return ;\n}\nint now;\nvoid sao(int x,int f)\n{\n    for(int i=head[x];i;i=nxt[i])\n    {\n        if(ver[i]==f)continue;\n        pi[ver[i]]=x;\n        if(ver[i]==now)continue;\n        sao(ver[i],x);\n    }\n}\nvector<int>vv[N];\nint size[N],fa[N],f[N];\nvoid dp(int x)\n{\n    f[x]=1;size[x]=1;\n    for(int i=0;i<vv[x].size();i++)\n    {\n        dp(vv[x][i]);\n        size[x]+=size[vv[x][i]];\n        f[x]=1LL*f[x]*f[vv[x][i]]%p*c(size[x]-1,size[vv[x][i]])%p;\n    }\n}\nint solve()\n{\n    for(int j=1;j<=dian;j++)fa[q[j]]=0;\n    for(int j=1;j<=dian;j++)\n    {\n        int u=q[j];vv[u].clear();\n        for(int k=head[u];k;k=nxt[k])\n        {\n            if(ver[k]<pi[u])\n            {\n                vv[u].push_back(ver[k]),fa[ver[k]]=u;\n            }\n        }\n    }\n    int ans=1;int szzz=0;\n    for(int j=1;j<=dian;j++)\n    {\n        if(!fa[q[j]])\n        {\n            dp(q[j]);szzz+=size[q[j]];\n            ans=1LL*ans*f[q[j]]%p*c(szzz,size[q[j]])%p;\n        }\n    }\n    return ans;\n}\nsigned main()\n{\n    scanf(\"%lld\",&n);\n    jie[0]=ni[0]=ni[1]=1;\n    for(int i=1;i<=2*n;i++)jie[i]=1LL*jie[i-1]*i%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*(p-p/i)*ni[p%i]%p;\n    for(int i=2;i<=2*n;i++)ni[i]=1LL*ni[i-1]*ni[i]%p;\n    for(int i=1;i<=2*n;i++)\n    {\n        int t1,t2;scanf(\"%lld%lld\",&t1,&t2);\n        add(t1,t2+n);add(t2+n,t1);\n    }\n    puts(\"0\");return 0;\n    int ans=1;int nw=2*n;\n    for(int i=1;i<=2*n;i++)\n    {\n        if(v[i])continue;\n        dian=sz=bian=0;\n        dfs(i,-1);bian/=2;\n        if(dian!=bian)return puts(\"0\"),0;\n        now=cir[sz];\n        sao(cir[sz],-1);\n        cir[sz+1]=cir[1];\n        int as=solve();\n        for(int j=1;j<=sz;j++)pi[cir[j]]=cir[j+1];\n        as+=solve();\n        ans=1LL*ans*c(nw,dian)%p*as%p;\n        nw-=dian;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n\nconst int kN = 500000 + 5;\nconst int MOD = (int)1e9 + 7;\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a < 0) a += MOD;\n    else if (a >= MOD) a -= MOD;\n}\n\ninline int mul(int x)\n{\n    return x;\n}\n\ntemplate<typename... Args>\ninline int mul(int x, Args... args)\n{\n    return x * 1ll * mul(args...) % MOD;\n}\n\n\nint n;\nstd::vector<int> edges[kN], tree[kN];\nbool vis[kN], in[kN];\nstd::vector<int> vec;\nint F[kN], Finv[kN], Inv[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return mul(F[a], Finv[b], Finv[a - b]);\n}\n\nint dfs(int u)\n{\n    int ret = 1;\n    vis[u] = true;\n    vec.emplace_back(u);\n    for (int v : edges[u]) if (!vis[v])\n        ret -= dfs(v);\n    return ret;\n}\n\nbool find_cycle(int u, int fa, int &s, int &t)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != fa) {\n        if (vis[v]) {\n            s = u;\n            t = v;\n            return true;\n        } else if (find_cycle(v, u, s, t)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int u, int target)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != target) {\n        if (!vis[v])\n            dfs2(v, u);\n        // printf(\"(u, target): (%d, %d)\\n\", u, target);\n        if (v < target) {\n            tree[u].emplace_back(v);\n            // printf(\"%d->%d\\n\", u, v);\n            in[v] = true;\n        }\n    }\n}\n\nusing Val = std::pair<int, int>;\n\nVal combine(Val a, Val b)\n{\n    return Val(a.first + b.first, mul(a.second, b.second, binom(a.first + b.first, a.first)));\n}\n\nVal calc(int u)\n{\n    Val ret(0, 1);\n    for (int v : tree[u]) {\n        ret = combine(ret, calc(v));\n    }\n    ret.first ++;\n    // printf(\"u = %d, ret = (%d, %d)\\n\", u, ret.first, ret.second);\n    return ret;\n}\n\nVal solve(int u)\n{\n    vec.clear();\n    if (dfs(u))\n        return std::make_pair(0, 0);\n    int e = 0;\n    for (int v : vec)\n        e += edges[v].size();\n    if (e / 2 != vec.size()) {\n        return std::make_pair(0, 0);\n    }\n\n    for (int v : vec) vis[v] = false;\n    int s, t;\n    assert(find_cycle(u, -1, s, t));\n    int ways = 0;\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(s, t);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve0::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(t, s);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve1::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    return std::make_pair(vec.size(), ways);\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = mul(MOD - MOD / i, Inv[MOD % i]);\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = mul(F[i - 1], i);\n        Finv[i] = mul(Finv[i - 1], Inv[i]);\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n * 2; ++ i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b); a --; b --;\n        edges[a].emplace_back(n + b);\n        edges[n + b].emplace_back(a);\n    }\n    Val val(0, 1);\n    for (int i = 0; i < n; ++ i) if (!vis[i]) {\n        val = combine(val, solve(i));\n    }\n    printf(\"%d\\n\", val.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nconst int q=1000000007;\nint n,x[200010],y[200010],u[200010],p=1,r,A,B,D,t[200010],s[200010];\nvector<int> a[200010],v,w,b,c,d,e[200010],f[200010],g[200010];\ninline int C(int n,int m)\n{\n\treturn (L)x[n]*y[m]%q*y[n-m]%q;\n}\ninline void dfs(int i)\n{\n\tu[i]=1;\n\tw.pb(i);\n\tfor(auto j:a[i])\n\t  if(!u[j])\n\t    dfs(j);\n}\ninline void dfs(int i,int j)\n{\n\tu[i]=2;\n\tfor(auto k:a[i])\n\t  if(k!=j)\n\t    if(u[k]==2)\n\t      {\n\t\t   A=i;\n\t\t   B=j;\n\t\t   D=k;\n\t\t   v.pb(k);\n\t\t   return;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t   dfs(k,i);\n\t\t   if(A)\n\t\t     {\n\t\t\t  if(v.size()==1 || v[0]!=v[v.size()-1])\n\t\t\t    {\n\t\t\t\t u[i]=3;\n\t\t\t     v.pb(i);\n\t\t\t    }\n\t\t      return;\n\t\t\t }\n\t\t  }\n}\ninline void add(int i,int j)\n{\n\tif(i>n)\n\t  {\n\t   b.pb(j);\n\t   c.pb(i-n);\n\t   d.pb(2);\n\t  }\n\telse\n\t  {\n\t   b.pb(i);\n\t   c.pb(j-n);\n\t   d.pb(1);\n\t  }\n}\ninline void dfs2(int i,int j)\n{\n\tu[i]=4;\n\tfor(auto k:a[i])\n\t  if(k!=j)\n\t    {\n\t     add(k,i);\n\t     if(u[k]!=4)\n\t\t   dfs2(k,i);\n\t\t}\n\tu[i]=1;\n}\ninline void line(int i,int j)\n{\n\t//cout<<i<<\" \"<<j<<\"---\\n\";\n\te[i].pb(j);\n\tt[j]++;\n}\ninline int dp2(int i)\n{\n\tint j,k=1;\n\ts[i]=0;\n\tfor(auto l:e[i])\n\t  {\n\t   j=dp2(l);\n\t   k=(L)k*j%q*C(s[i]+s[l],s[l])%q;\n\t   s[i]+=s[l];\n\t  }\n\ts[i]++;\n\t  //cout<<i<<\" \"<<s[i]<<\" \"<<k<<\"!!\\n\";\n\treturn k;\n}\ninline int calc(int A,int B)\n{\n\tdfs2(A,B);\n\tint i,k=b.size();\n\tfor(i=0;i<k;i++)\n\t  {\n\t   f[b[i]].pb(i);\n\t   g[c[i]].pb(i);\n\t   //cout<<i<<\" \"<<b[i]<<\" \"<<c[i]<<\" \"<<d[i]<<\"!!!!!!!!!!!!\\n\";\n\t  }\n\tfor(i=0;i<k;i++)\n\t  if(d[i]==1)\n\t    {\n\t     for(auto j:f[b[i]])\n\t       if(c[j]<c[i])\n\t         line(i,j);\n\t\t}\n\t  else\n\t    {\n\t     for(auto j:g[c[i]])\n\t       if(b[j]<b[i])\n\t         line(i,j);\n\t\t}\n\tfor(i=0;i<k;i++)\n\t  if(!t[i])\n\t    line(k,i);\n\tint j=dp2(k);\n\t//cout<<j<<\"\\n\";\n\tfor(i=0;i<k;i++)\n\t  {\n\t   f[b[i]].clear();\n\t   g[c[i]].clear();\n\t   e[i].clear();\n\t   t[i]=0;\n\t  }\n\te[k].clear();\n\tb.clear();\n\tc.clear();\n\td.clear();\n\treturn j;\n}\ninline int calc()\n{\n\tA=0;\n\tdfs(w[0],0);\n\tv.clear();\n\t//cout<<A<<\" \"<<B<<\" \"<<D<<\"\\n\";\n\treturn (calc(A,B)+calc(A,D))%q;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tx[0]=1;\n\tfor(i=1;i<=2*n+5;i++)\n\t  x[i]=(L)x[i-1]*i%q;\n\ty[0]=y[1]=1;\n\tfor(i=2;i<=2*n+5;i++)\n\t  y[i]=q-(L)q/i*y[q%i]%q;\n\tfor(i=2;i<=2*n+5;i++)\n\t  y[i]=(L)y[i]*y[i-1]%q;\n\tfor(i=1;i<=2*n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   a[j].pb(k+n);\n\t   a[k+n].pb(j);\n\t  }\n\tfor(i=1;i<=2*n;i++)\n\t  if(!u[i])\n\t    {\n\t     dfs(i);\n\t     k=0;\n\t     for(auto j:w)\n\t       k+=a[j].size();\n\t     k/=2;\n\t     //cout<<k<<\" \"<<w.size()<<\" \"<<r<<\"----------------------------------\\n\";\n\t     if(k!=w.size())\n\t       {\n\t        p=0;\n\t        break;\n\t\t   }\n\t\t p=(L)p*C(2*n-r,k)%q*calc()%q;\n\t\t r+=k;\n\t\t w.clear();\n\t\t}\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pct puts(\"------ visit ------\");\n#define rep(a, b, c) for(int a = (b); a <= (c); ++ a)\n#define per(a, b, c) for(int a = (b); a >= (c); -- a)\nusing namespace std;\ntemplate <class T> void rd(T &x){\n  x = 0; int f = 1; char ch = getchar();\n  while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }\n  while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();\n  x *= f;\n}\n\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nint n, sdu, tim = 2;\nint mrk[maxn], to[maxn], siz[maxn];\nint p[maxn], cntp;\nint r[maxn], cntr;\nvector <int> h, g[maxn];\nbool ok[maxn], isr[maxn];\n\nnamespace mathematics{\n  ll fac[maxn], fin[maxn];\n\n  ll qpow(ll x, ll n){\n\tll y = 1;\n\tfor(; n; n >>= 1, x = x * x % mod)\n\t  if(n & 1) y = y * x % mod;\n\treturn y;\n  }\n\n#define inv(x) qpow(x, mod - 2)\n\n  ll C(ll n, ll m){ return fac[n] * fin[m] % mod * fin[n - m] % mod; }\n\n  void init(int n){\n\tfac[0] = 1; rep(i, 1, n) fac[i] = fac[i - 1] * i % mod;\n\tfin[n] = inv(fac[n]);\n\tper(i, n, 1) fin[i - 1] = fin[i] * i % mod;\n  }\n\n  void add(ll &a, ll b){ a = (a + b) % mod; }\n\n  void mul(ll &a, ll b){ a = (a * b) % mod; }\n}\nusing namespace mathematics;\n\nstruct edge{ int v, nxt; }; vector <edge> e; int head[maxn];\n\nvoid adde(int u, int v){\n  e.push_back((edge){v, head[u]});\n  head[u] = e.size() - 1;\n}\n\nvoid rebuild(int u, int f){\n  mrk[u] = tim;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v; if(v == f) continue;\n\tif(mrk[v] == tim && v < u) continue;\n\tif(to[u] == v){\n\t  if(to[v] > u) g[v].push_back(u), ok[u] = true;\n\t}\n\telse{\n\t  if(to[u] > v) g[u].push_back(v), ok[v] = true;\n\t}\n\tif(mrk[v] != tim) rebuild(v, u);\n  }\n}\n\nvoid getsize(int u, int f){\n  siz[u] = 1;\n  for(int i = 0; i < g[u].size(); ++ i){\n\tint v = g[u][i];\n\tgetsize(v, u);\n\tsiz[u] += siz[v];\n  }\n}\n\nll getdp(int u, int f){\n  int tot = siz[u] - 1;\n  ll res = 1;\n  for(int i = 0; i < g[u].size(); ++ i){\n\tint v = g[u][i];\n\tmul(res, C(tot, siz[v]) * getdp(v, u) % mod);\n\ttot -= siz[v];\n  }\n  return res;\n}\n\nll query(){\n  ++ tim; \n  rebuild(p[1], 0);\n  int tot = cntp;\n  ll res = 1;\n  rep(i, 1, cntp) if(!ok[p[i]]){\n\tgetsize(p[i], 0);\n\tmul(res, C(tot, siz[p[i]]) * getdp(p[i], 0) % mod);\n\ttot -= siz[p[i]];\n  }\n  rep(i, 1, cntp) g[p[i]].clear();\n  return res;\n}\n\nbool getroll(int u, int f){\n  h.push_back(u);\n  mrk[u] = 2;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v;\n\tif(v == f) continue;\n\tif(mrk[v] != 2){\n\t  if(getroll(v, u)) return true;\n\t}\n\telse if(mrk[v] == 2){\n\t  int t = -1;\n\t  while(t != v){\n\t\tt = h.back();\n\t\th.pop_back();\n\t\tr[cntr ++] = t;\n\t\tisr[t] = 1;\n\t  }\n\t  return true;\n\t}\n  }\n  h.pop_back();\n  return false;\n}\n\nvoid match(int u, int f){\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v; if(v == f || isr[v]) continue;\n\tto[v] = u; match(v, u);\n  }\n}\n\nll cal(){\n  if(cntp != sdu){\n\tputs(\"0\");\n\texit(0);\n  }\n  cntr = 0;\n  h.clear();\n  getroll(p[1], 0);\n  rep(i, 0, cntr - 1) match(r[i], 0);\n  rep(i, 0, cntr - 1) to[r[i]] = r[(i + 1) % cntr];\n  ll res = query();\n  rep(i, 0, cntr - 1) to[r[i]] = r[(i + cntr - 1) % cntr];\n  add(res, query());\n  return res;\n}\n\nvoid dfs(int u){\n  p[++ cntp] = u;\n  mrk[u] = 1;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v;\n\tsdu ++;\n\tif(mrk[v]) continue;\n\tdfs(v);\n  }\n}\n\nvoid sol(){\n  int tot = 2 * n;\n  ll res = 1;\n  rep(i, 1, 2 * n) if(!mrk[i]){\n\tcntp = sdu = 0;\n\tdfs(i);\n\tsdu /= 2;\n\tmul(res, C(tot, cntp) * cal() % mod);\n\ttot -= cntp;\n  }\n  printf(\"%lld\\n\", res);\n}\n\nint main(){\n  memset(head, -1, sizeof(head));\n  rd(n);\n  init(2 * n);\n  rep(i, 1, 2 * n){\n\tint u, v; rd(u), rd(v);\n\tadde(u, v + n);\n\tadde(v + n, u);\n  }\n  sol();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nvoid debug(vec &v) {\n\tint n = v.size();\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << \"\\n\";\n}\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nvector<P> vx[1 << 17], vy[1 << 17];\nint memo[1 << 18];\nint chk[1 << 18];\nint cop[1 << 18];\n\nbool used[1 << 18];\n\nstruct edge {\n\tint to, id;\n};\nvector<edge> G[1 << 18];\n\nvector<int> fG[1 << 18];\nint n;\nbool visited[1 << 18];\nll calc(vector<int> &v) {\n\tll ret = 1;\n\tvector<pair<P, int>> ids;\n\trep(i, v.size()) {\n\t\tint val = v[i];\n\t\tif (val < n) {\n\t\t\tint x = val;\n\t\t\trep(j, vx[x].size()) {\n\t\t\t\tP z = vx[x][j];\n\t\t\t\tif (chk[z.second] == 0) {\n\t\t\t\t\tfG[z.second].clear();\n\t\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\tP zz = vx[x][k];\n\t\t\t\t\t\tfG[z.second].push_back(zz.second);\n\t\t\t\t\t}\n\t\t\t\t\tids.push_back({ {x,z.first},z.second });\n\t\t\t\t\tvisited[z.second] = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint y = val - n;\n\t\t\trep(j, vy[y].size()) {\n\t\t\t\tP z = vy[y][j];\n\t\t\t\tif (chk[z.second] == 1) {\n\t\t\t\t\tfG[z.second].clear();\n\t\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\tP zz = vy[y][k];\n\t\t\t\t\t\tfG[z.second].push_back(zz.second);\n\t\t\t\t\t}\n\t\t\t\t\tids.push_back({ {z.first,y }, z.second });\n\t\t\t\t\tvisited[z.second] = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(ids.begin(), ids.end(), greater<pair<P, int>>());\n\tfunction<int(int, int)> dfs = [&](int id, int fr)->int {\n\t\tint res = 1;\n\t\tvisited[id] = true;\n\t\trep(j, fG[id].size()) {\n\t\t\tint to = fG[id][j];\n\t\t\tif (to == fr)continue;\n\t\t\tres += dfs(to, id);\n\t\t}\n\t    ret = ret * res%mod;\n\t\treturn res;\n\t};\n\trep(i, ids.size()) {\n\t\tint id = ids[i].second;\n\t\tif (!visited[id])dfs(id, -1);\n\t}\n\treturn mod_pow(ret,mod-2);\n}\nvoid solve() {\n\tcin >> n;\n\tuf u(2 * n);\n\trep(i, 2 * n) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tvx[x].push_back({ y,i });\n\t\tvy[y].push_back({ x,i });\n\t\tchk[i] = -1;\n\t\tu.unite(x, y + n);\n\t}\n\tvector<vector<int>> vs;\n\t{\n\t\tvector<vector<int>> loc(2 * n);\n\t\trep(i, 2 * n) {\n\t\t\tloc[u.find(i)].push_back(i);\n\t\t}\n\t\trep(i, 2 * n)if (loc[i].size() > 0)vs.push_back(loc[i]);\n\t}\n\t\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\trep(i, n) {\n\t\tsort(vx[i].begin(), vx[i].end());\n\t\tsort(vy[i].begin(), vy[i].end());\n\t\tq.push({ vx[i].size(),i });\n\t\tq.push({ vy[i].size(), i + n });\n\t\tused[i] = used[i + n] = false;\n\t\tmemo[i] = vx[i].size();\n\t\tmemo[i + n] = vy[i].size();\n\t}\n\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\t//cout << p.first << endl;\n\t\tif (p.first >= 2)break;\n\t\tint id = p.second;\n\t\tif (used[id])continue;\n\t\tused[id] = true;\n\t\tif (p.first == 0) {\n\t\t\tcout << 0 << endl; return;\n\t\t}\n\t\tif (id < n) {\n\t\t\trep(j, vx[id].size()) {\n\t\t\t\tP z = vx[id][j];\n\t\t\t\tif (chk[z.second] >= 0)continue;\n\t\t\t\tchk[z.second] = 0;\n\t\t\t\tint y = z.first; y += n;\n\t\t\t\tmemo[y]--;\n\t\t\t\tq.push({ memo[y],y });\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trep(j, vy[id-n].size()) {\n\t\t\t\tP z = vy[id - n][j];\n\t\t\t\tif (chk[z.second] >= 0)continue;\n\t\t\t\tchk[z.second] = 1;\n\t\t\t\tint x = z.first;\n\t\t\t\tmemo[x]--;\n\t\t\t\tq.push({ memo[x],x });\n\t\t\t}\n\t\t}\n\t}\n\tll pro = 1;\n\trep(i, 2 * n)cop[i] = chk[i];\n\trep(aa, vs.size()) {\n\t\t//cout << vs[aa].size() << endl;\n\t\tvector<int> xs, ys;\n\t\trep(j, vs[aa].size()) {\n\t\t\tint val = vs[aa][j];\n\t\t\tif (val < n && !used[val])xs.push_back(val);\n\t\t\tif (val >= n && !used[val])ys.push_back(val - n);\n\t\t}\n\t\tassert(xs.size() == ys.size());\n\t\t//cout << \"hello\" << endl;\n\t\t//rep(i, xs.size())cout << xs[i] << endl;\n\t\t//rep(i, ys.size())cout << ys[i] << endl;\n\t\tif (xs.size() == 0) {\n\t\t\tpro = pro * calc(vs[aa]) % mod;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i, xs.size()) {\n\t\t\tint x = xs[i];\n\t\t\trep(j, vx[x].size()) {\n\t\t\t\tP z = vx[x][j];\n\t\t\t\tif (cop[z.second] < 0) {\n\t\t\t\t\tG[z.first + n].push_back({ x,z.second });\n\t\t\t\t\tG[x].push_back({ z.first + n,z.second });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> roopid;\n\t\tint cur = xs[0];\n\t\tint to = G[cur][0].to;\n\t\troopid.push_back(G[cur][0].id);\n\t\trep(i, 2 * xs.size() - 1) {\n\t\t\tif (G[to][0].to == cur) {\n\t\t\t\troopid.push_back(G[to][1].id);\n\t\t\t\tcur = to; to = G[to][1].to;\n\t\t\t}\n\t\t\telse {\n\t\t\t\troopid.push_back(G[to][0].id);\n\t\t\t\tcur = to; to = G[to][0].to;\n\t\t\t}\n\t\t}\n\t\tll sum = 0;\n\t\trep(j, 2) {\n\t\t\trep(i, roopid.size()) {\n\t\t\t\tint id = roopid[i];\n\t\t\t\tif ((i + j) % 2)chk[id] = 0;\n\t\t\t\telse chk[id] = 1;\n\t\t\t}\n\t\t\tsum += calc(vs[aa]);\n\t\t}\n\t\tsum %= mod;\n\t\tpro = pro * sum%mod;\n\t}\n\tfor (int i = 1; i <= 2 * n;i++)pro = pro * i%mod;\n\tcout << pro << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(17);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mk make_pair\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int mod = 1e9 + 7;\nint n, root, root1, tag[N], deg[N], size[N];\nll ans = 1, fac[N], inv[N];\nvector<int> s, ss, G[N], E[N];\nunordered_map<int, int> id[N];\nint row[N], col[N];\nvector<int> r[N], c[N];\nbool vis[N];\ninline ll Pow(ll a, int x) {\n\tll res = 1;\n\twhile (x) {\n\t\tif (x & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\nvoid dfs(int x, int f) {\n\tvis[x] = 1;\n\ts.push_back(x);\n\ttag[x] = tag[0];\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (u == f) continue;\n\t\tif (vis[u] && tag[u] != tag[x]) continue;\n\t\tif (!vis[u]) {\n\t\t\tdfs(u, x);\n\t\t\tss.push_back(id[x][u]);\n\t\t} else {\n\t\t\tif (x < u)\n\t\t\t\tss.push_back(id[x][u]);\n\t\t\troot = u;\n\t\t\troot1 = x;\n\t\t}\n\t}\n}\nvoid dfs1(int x, int f, int r) {\n\tif (x <= n) \n\t\tcol[x] = f;\n\telse \n\t\trow[x] = f;\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (u == f || u == r) continue;\n\t\tdfs1(u, x, r);\n\t}\n}\nll cal(int x) {\n\tsize[x] = 0;\n\tll res = 1;\n\tfor (int i = 0; i < E[x].size(); i++) {\n\t\tint u = E[x][i];\n\t\tres = res * cal(u) % mod;\n\t\tres = res * inv[size[u]] % mod;\n\t\tsize[x] += size[u];\n\t}\n\tres = res * fac[size[x]] % mod;\n\tsize[x]++;\n\treturn res;\n}\nll cal() { //cout << ss.size() << \"/\" << s.size() << endl;\n\tif (ss.size() != s.size()) return 0;\n\tll res = 0;\n\tdfs1(root, root1, root);\n\tE[0].clear();\n\tfor (int i = 0; i < ss.size(); i++) {\n\t\tE[ss[i]].clear();\n\t\tdeg[ss[i]] = 0;\n\t}\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tint x = s[i];\n\t\tif (x <= n) {\n\t\t\tfor (int j = 0; j < c[x].size(); j++) {\n\t\t\t\tint u = c[x][j];\n\t\t\t\tif (u < col[x]) {\n\t\t\t\t\tE[id[x][col[x]]].push_back(id[x][u]);\n\t\t\t\t\tdeg[id[x][u]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int j = 0; j < r[x].size(); j++) {\n\t\t\t\tint u = r[x][j];\n\t\t\t\tif (u < row[x]) {\n\t\t\t\t\tE[id[x][row[x]]].push_back(id[x][u]);\n\t\t\t\t\tdeg[id[x][u]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ss.size(); i++) \n\t\tif (deg[ss[i]] == 0) E[0].push_back(ss[i]);\n\tres += cal(0);\n\tdfs1(root1, root, root1);\n\tE[0].clear();\n\tfor (int i = 0; i < ss.size(); i++) {\n\t\tE[ss[i]].clear();\n\t\tdeg[ss[i]] = 0;\n\t}\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tint x = s[i];\n\t\tif (x <= n) {\n\t\t\tfor (int j = 0; j < c[x].size(); j++) {\n\t\t\t\tint u = c[x][j];\n\t\t\t\tif (u < col[x]) {\n\t\t\t\t\tE[id[x][col[x]]].push_back(id[x][u]);\n\t\t\t\t\tdeg[id[x][u]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int j = 0; j < r[x].size(); j++) {\n\t\t\t\tint u = r[x][j];\n\t\t\t\tif (u < row[x]) {\n\t\t\t\t\tE[id[x][row[x]]].push_back(id[x][u]);\n\t\t\t\t\tdeg[id[x][u]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ss.size(); i++) \n\t\tif (deg[ss[i]] == 0) E[0].push_back(ss[i]);\n\tres += cal(0);\n\treturn res % mod;\n}\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i % mod;\n\tinv[N - 1] = Pow(fac[N - 1], mod - 2);\n\tfor (int i = N - 2; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % mod;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tG[x].push_back(y + n);\n\t\tG[y + n].push_back(x);\n\t\tid[x][y + n] = i;\n\t\tid[y + n][x] = i;\n\t\tr[y + n].push_back(x);\n\t\tc[x].push_back(y + n);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(c[i].begin(), c[i].end());\n\t\tsort(r[i + n].begin(), r[i + n].end());\n\t}\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tif (vis[i]) continue;\n\t\ts.clear();\n\t\tss.clear();\n\t\t++tag[0];\n\t\tdfs(i, 0);\n\t\tans = ans * cal() % mod * inv[s.size()] % mod;\n\t}\n\tans = ans * fac[2 * n] % mod;\n\tcout << ans << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t200005\n#define P\t1000000007\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvector <int> a[MAXN], b[MAXN];\nint n, cnt, p[MAXN], cnte, x, y, size[MAXN], pr[MAXN];\nbool visited[MAXN], father[MAXN];\nlong long fac[MAXN], inv[MAXN], met[MAXN];\nlong long power(long long x, long long y) {\n\tif (y == 0) return 1;\n\tlong long tmp = power(x, y / 2);\n\tif (y % 2 == 0) return tmp * tmp % P;\n\telse return tmp * tmp % P * x % P;\n}\nlong long getc(long long x, long long y) {\n\treturn fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid init(int N) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tfac[i] = fac[i - 1] * i % P;\n\tinv[N] = power(fac[N], P - 2);\n\tfor (int i = N - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1) % P;\n}\nvoid dfs(int pos, int fa) {\n\tvisited[pos] = true;\n\tp[++cnt] = pos; cnte += a[pos].size();\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (!visited[a[pos][i]]) dfs(a[pos][i], pos);\n\t\telse if (a[pos][i] != fa) x = pos, y = a[pos][i]; \n}\nvoid work(int pos) {\n\tvisited[pos] = true;\n\tfor (unsigned i = 0; i < a[pos].size(); i++) {\n\t\tif (a[pos][i] == pr[pos]) continue;\n\t\tif (a[pos][i] < pr[pos]) {\n\t\t\tb[pos].push_back(a[pos][i]);\n\t\t\tfather[a[pos][i]] = true;\n\t\t}\n\t\tif (!visited[a[pos][i]]) {\n\t\t\tpr[a[pos][i]] = pos;\n\t\t\twork(a[pos][i]);\n\t\t}\n\t}\n}\nlong long dp(int pos) {\n\tsize[pos] = 0;\n\tlong long ans = 1;\n\tfor (unsigned i = 0; i < b[pos].size(); i++) {\n\t\tans = ans * dp(b[pos][i]) % P;\n\t\tsize[pos] += size[b[pos][i]];\n\t\tans = ans * getc(size[pos], size[b[pos][i]]) % P;\n\t}\n\tsize[pos]++;\n\treturn ans;\n}\nint main() {\n\tread(n); init(n * 2);\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\ta[x].push_back(y + n);\n\t\ta[y + n].push_back(x); \n\t}\n\tlong long ans = 1, all = 0;\n\tfor (int i = 1; i <= 2 * n; i++)\n\t\tif (!visited[i]) {\n\t\t\tcnt = cnte = 0; dfs(i, 0);\n\t\t\tif (cnt * 2 != cnte) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlong long tans = 0;\n\t\t\tb[0].clear();\n\t\t\tfor (int i = 1; i <= cnt; i++) {\n\t\t\t\tb[p[i]].clear(); pr[p[i]] = 0;\n\t\t\t\tfather[p[i]] = false;\n\t\t\t\tvisited[p[i]] = false;\n\t\t\t}\n\t\t\tpr[x] = y;\n\t\t\twork(x);\n\t\t\tfor (int i = 1; i <= cnt; i++)\n\t\t\t\tif (!father[p[i]]) b[0].push_back(p[i]);\n\t\t\ttans += dp(0);\n\t\t\tb[0].clear();\n\t\t\tfor (int i = 1; i <= cnt; i++) {\n\t\t\t\tb[p[i]].clear(); pr[p[i]] = 0;\n\t\t\t\tfather[p[i]] = false;\n\t\t\t\tvisited[p[i]] = false;\n\t\t\t}\n\t\t\tpr[y] = x;\n\t\t\twork(y);\n\t\t\tfor (int i = 1; i <= cnt; i++)\n\t\t\t\tif (!father[p[i]]) b[0].push_back(p[i]);\n\t\t\ttans += dp(0);\n\t\t\tall += cnt;\n\t\t\tans = ans * tans % P * getc(all, cnt) % P;\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll MAX=400053;\nconst ll MOD=1000000007;\nvector<ll> conn[MAX],rec[MAX],dir[MAX],undir[MAX],now;\npll edge[MAX];\nll N,cnt[MAX],par[MAX],fact[MAX],chk[MAX],fin=1,npar[MAX],inv_dir[MAX];\nvoid build(ll x, ll px){\n    if(npar[x]!=0) return;\n    npar[x]=px; now.push_back(x);\n    for(ll i=0;i<undir[x].size();i++) if(px!=undir[x][i]) build(undir[x][i],x);\n}\nll power(ll x,ll y){\n    if(y==0) return 1;\n    ll t=power(x,y/2);\n    if(y%2) return t*t%MOD*x%MOD;\n    return t*t%MOD;\n}\npll counter(ll x){\n    ll t1=1,t2=1;\n    for(ll i=0;i<dir[x].size();i++){\n        pll tmp=counter(dir[x][i]);\n        t1+=tmp.first,t2*=tmp.second*power(fact[tmp.first],MOD-2)%MOD; t2%=MOD;\n    }\n    t2*=fact[t1-1]; t2%=MOD;\n    return make_pair(t1,t2);\n}\nll calc(ll x){\n    ll val[2]={1,1},uu;\n    for(ll i=0;i<2;i++){\n        build(x,undir[x][i]);\n        for(ll j=0;j<now.size();j++) {\n            ll t=now[j];\n            for(ll k=0;k<conn[t].size();k++) {\n                if(conn[t][k]!=npar[t]) dir[t].push_back(conn[t][k]),inv_dir[conn[t][k]]++;\n                else break;\n            }\n        }\n        ll slen=0;\n        for(ll j=0;j<now.size();j++) {\n            ll t=now[j];\n            if(chk[t]==0&&inv_dir[t]==0) {\n                pll tmp=counter(t);\n                val[i]*=tmp.second*power(fact[tmp.first],MOD-2)%MOD; val[i]%=MOD; slen+=tmp.first;\n            }\n        }\n        val[i]%=MOD;\n        while(!now.empty()){ll t=now.back(); dir[t].clear(); inv_dir[t]=0; npar[t]=0; chk[t]=i; now.pop_back();}\n    }\n    return (val[0]+val[1])%MOD;\n}\nint main(){\n    scanf(\"%lld\",&N);\n    for(ll i=1;i<=2*N;i++){\n        ll t1,t2;\n        scanf(\" %lld %lld\",&t1,&t2); t2+=N;\n        edge[i]=make_pair(t1,t2);\n        cnt[t1]++, cnt[t2]++;\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    for(ll i=1;i<=2*N;i++) sort(conn[i].begin(),conn[i].end());\n    for(ll i=1;i<=2*N;i++) {\n        if(cnt[i]<=1) now.push_back(i);\n    }\n    while(!now.empty()){\n        ll u=now.back(),up=0;\n        now.pop_back();\n        if(cnt[u]==1){\n            cnt[u]=0;\n            for(ll i=0;i<conn[u].size();i++) if(par[conn[u][i]]==0){\n                cnt[conn[u][i]]--; up=conn[u][i];\n                if(cnt[conn[u][i]]<=1) now.push_back(conn[u][i]);\n            }\n            par[u]=up;\n        }\n        else{\n            printf(\"0\\n\");\n            return 0;\n        }\n    }\n    for(ll i=1;i<=2*N;i++) if(par[i]==0&&conn[i].size()<2){\n        printf(\"0\\n\");\n        return 0;\n    }\n    fact[0]=1;\n    for(ll i=1;i<=2*N;i++) fact[i]=fact[i-1]*i%MOD;\n    for(ll i=1;i<=2*N;i++){\n        if(par[i]==0) {for(ll j=0;j<conn[i].size();j++) if(par[conn[i][j]]==0) undir[conn[i][j]].push_back(i);}\n        else {\n            undir[par[i]].push_back(i);\n            undir[i].push_back(par[i]);\n        }\n    }\n    for(ll i=1;i<=2*N;i++) sort(undir[i].begin(),undir[i].end());\n    for(ll i=1;i<=2*N;i++){\n        if(par[i]==0&&chk[i]==0) {\n            fin*=calc(i),fin%=MOD;\n        }\n    }\n    fin*=fact[2*N],fin%=MOD;\n    printf(\"%lld\\n\",fin);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\nconst int MOD=1e9+7;\nstruct mint{int x;mint(int x=0):x(x){}};\ninline mint operator+  (mint a,mint b){return a.x+b.x<MOD?a.x+b.x:a.x+b.x-MOD;}\ninline mint operator-  (mint a){return MOD-a.x;}\ninline mint operator-  (mint a,mint b){return a+-b;}\ninline mint operator*  (mint a,mint b){return 1LL*a.x*b.x%MOD;}\ninline mint operator<< (mint x,int y){mint r=1;for(;y;y>>=1,x=x*x)if(y&1)r=r*x;return r;}\ninline mint operator~  (mint x){return x<<MOD-2;}\ninline mint operator/  (mint a,mint b){return a*~b;}\ninline mint&operator+= (mint&a,mint b){return a=a+b;}\ninline mint&operator-= (mint&a,mint b){return a=a-b;}\ninline mint&operator*= (mint&a,mint b){return a=a*b;}\ninline mint&operator<<=(mint&x,int y){return x=x<<y;}\ninline mint&operator/= (mint&a,mint b){return a=a/b;}\n#define MN 200000\nstruct edge{int nx,t,w;}e[MN*2+5];\nint h[MN+5],en,d[MN+5],z[MN+5],q[MN+5],qn,sv,se,vq[MN+5],f[MN+5],fa[MN+5];\nmint ans=1,s1,s2,ff[MN+5],F[MN+5],RF[MN+5];\nvector<int> v[MN+5];\ninline void ins(int x,int y,int w)\n{\n\te[++en]=(edge){h[x],y,w};h[x]=en;\n\te[++en]=(edge){h[y],x,w};h[y]=en;\n}\nvoid dfs(int x,int fa)\n{\n\tz[d[x]=d[fa]+1]=x;vq[++sv]=x;\n\tfor(int i=h[x];i;i=e[i].nx,++se)if(e[i].t!=fa)\n\t\tif(d[e[i].t]){if(!qn)for(int j=d[e[i].t];j<=d[x];++j)q[++qn]=z[j];}\n\t\telse dfs(e[i].t,x);\n}\nvoid build(int x,int fr)\n{\n\tv[x].clear();\n\tfor(int i=h[x];i;i=e[i].nx)if(e[i].t!=fr)\n\t{\n\t\tif(e[i].w<f[x])v[fa[e[i].t]=x].push_back(e[i].t);\n\t\tif(d[e[i].t]>=0)f[e[i].t]=e[i].w,build(e[i].t,x);\n\t}\n}\nvoid dp(int x,int fa)\n{\n\tff[x]=1;\n\tfor(int i=0;i<v[x].size();++i)\n\t\tdp(v[x][i],x),\n\t\tff[x]*=ff[v[x][i]]*RF[d[v[x][i]]],\n\t\td[x]+=d[v[x][i]];\n\tff[x]*=F[d[x]++];\n}\nint main()\n{\n\tint n=read(),i,j,x,y;\n\tfor(i=1;i<=n<<1;++i)x=read(),y=read(),ins(x,y+n,x+y);\n\tfor(n<<=1,F[0]=i=1;i<=n;++i)F[i]=F[i-1]*i;\n\tfor(RF[i=n]=~F[n];i--;)RF[i]=RF[i+1]*(i+1);\n\tfor(i=1;i<=n;++i)if(!d[i])\n\t{\n\t\tdfs(i,qn=sv=se=0);\n\t\tif(sv<<1!=se)return 0*puts(\"0\");\n\t\tfor(j=1;j<=qn;++j)for(d[q[j]]=-1,x=h[q[j]];x;x=e[x].nx)if(e[x].t==q[j%qn+1])f[q[j]]=e[x].w;\n\t\tfor(j=1;j<=qn;++j)build(q[j],0);\n\t\tfor(j=1;j<=sv;++j)d[vq[j]]=0;\n\t\tfor(s1=F[sv],j=1;j<=sv;++j)if(!d[vq[j]])\n\t\t{\n\t\t\tfor(x=vq[j];fa[x];)x=fa[x];\n\t\t\tdp(x,0);s1*=ff[x]*RF[d[x]];\n\t\t}\n\t\tfor(j=1;j<=sv;++j)v[vq[j]].clear(),fa[vq[j]]=0;\n\t\tfor(j=1;j<=qn;++j)for(d[q[j]]=-1,x=h[q[j]];x;x=e[x].nx)if(e[x].t==q[j%qn+1])f[e[x].t]=e[x].w;\n\t\tfor(j=1;j<=qn;++j)build(q[j],0);\n\t\tfor(j=1;j<=sv;++j)d[vq[j]]=0;\n\t\tfor(s2=F[sv],j=1;j<=sv;++j)if(!d[vq[j]])\n\t\t{\n\t\t\tfor(x=vq[j];fa[x];)x=fa[x];\n\t\t\tdp(x,0);s2*=ff[x]*RF[d[x]];\n\t\t}\n\t\tfor(j=1;j<=sv;++j)v[vq[j]].clear(),fa[vq[j]]=0;\n\t\tans*=(s1+s2)*RF[sv];\n\t}\n\tprintf(\"%d\",ans*F[n]); \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nvoid failure () {\n  cout << 0 << endl;\n  exit(0);\n}\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 2e5 + 10;\nconst int Y = 1e5 + 5;\n\nModint fact [MAX_N];\nModint invfact [MAX_N];\n\nModint choose (int n, int k) {\n  return fact[n] * invfact[n - k] * invfact[k];\n}\n\nint x_idx (int x) {\n  return x;\n}\n\nint y_idx (int y) {\n  return Y + y;\n}\n\nvector<int> adj [MAX_N];\n\nvoid add_edge (int u, int v) {\n  adj[u].push_back(v);\n  adj[v].push_back(u);\n}\n\nint vis [MAX_N];\n\nvoid visit_comp (int u, vector<int> &comp) {\n  comp.push_back(u);\n  vis[u] = 1;\n  for (int nxt : adj[u]) {\n    if (!vis[nxt]) {\n      visit_comp(nxt, comp);\n    }\n  }\n}\n\nint find_cycle_vis [MAX_N];\nbool find_cycle (int u, int p, deque<int> &cycle) {\n  find_cycle_vis[u] = 1;\n  cycle.push_back(u);\n  \n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      if (find_cycle_vis[nxt]) {\n        while (cycle.front() != nxt) {\n          cycle.pop_front();\n        }\n        return true;\n      } else {\n        if (find_cycle(nxt, u, cycle)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  cycle.pop_back();\n  return false;\n}\n\nbool on_cycle [MAX_N];\nint parent [MAX_N];\n\nvoid build_parent (int u, int p) {\n  parent[u] = p;\n  for (int nxt : adj[u]) {\n    if (nxt != p && !on_cycle[nxt]) {\n      build_parent(nxt, u);\n    }\n  }\n}\n\nvector<int> temp_adj [MAX_N];\nbool is_root [MAX_N];\nint sub_sz [MAX_N];\nModint sub_ways [MAX_N];\n\nvoid count_sub (int u) {\n  sub_ways[u] = Modint(1);\n  sub_sz[u] = 0;\n  for (int nxt : temp_adj[u]) {\n    count_sub(nxt);\n    \n    sub_ways[u] *= sub_ways[nxt] * choose(sub_sz[u] + sub_sz[nxt], sub_sz[nxt]);\n    sub_sz[u] += sub_sz[nxt];\n  }\n  sub_sz[u]++;\n}\n\nModint count_forest (const vector<int> &comp) {\n  // for each vertex, only include the children who have an index < than the parent\n  for (int u : comp) {\n    temp_adj[u].clear();\n    is_root[u] = true;\n  }\n\n  for (int u : comp) {\n    for (int nxt : adj[u]) {\n      if (nxt < parent[u]) {\n        temp_adj[u].push_back(nxt);\n        is_root[nxt] = false;\n      }\n    }\n  }\n\n  Modint ans (1);\n  int cur_k = 0;\n  for (int u : comp) {\n    if (is_root[u]) {\n      count_sub(u);\n\n      ans *= sub_ways[u] * choose(cur_k + sub_sz[u], sub_sz[u]);\n      cur_k += sub_sz[u];\n    }\n  }\n\n  return ans;\n}\n\nint n_seen;\nModint tot_ans;\n\nvoid process_component (int u) {\n  vector<int> comp;\n  visit_comp(u, comp);\n\n  int k = (int) comp.size();\n  int ec = 0;\n  for (int v : comp) {\n    ec += (int) adj[v].size();\n  }\n  ec /= 2;\n\n  if (ec != k) {\n    failure();\n  }\n\n  // now, find the cycle\n  deque<int> cycle;\n  find_cycle(u, u, cycle);\n\n  for (int v : cycle) {\n    on_cycle[v] = true;\n  }\n\n  for (int v : cycle) {\n    build_parent(v, v);\n  }\n\n  for (int i = 0; i < (int) cycle.size(); i++) {\n    parent[cycle[i]] = cycle[(i + 1) % (int) cycle.size()];\n  }\n  Modint cur_ans = count_forest(comp);\n\n  reverse(cycle.begin(), cycle.end());\n\n  for (int i = 0; i < (int) cycle.size(); i++) {\n    parent[cycle[i]] = cycle[(i + 1) % (int) cycle.size()];\n  }\n  cur_ans += count_forest(comp);\n\n  int cur_n = (int) comp.size();\n  tot_ans *= cur_ans * choose(n_seen + cur_n, cur_n);\n  n_seen += cur_n;\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  fact[0] = Modint(1);\n  invfact[0] = Modint(1);\n  for (int i = 1; i < MAX_N; i++) {\n    fact[i] = fact[i - 1] * Modint(i);\n    invfact[i] = invfact[i - 1] * inv(Modint(i));\n  }\n  \n  int n;\n  cin >> n;\n\n  for (int i = 0; i < 2 * n; i++) {\n    int x, y;\n    cin >> x >> y;\n\n    add_edge(x_idx(x), y_idx(y));\n  }\n  \n  tot_ans = Modint(1);\n  for (int i = 1; i <= n; i++) {\n    if (!vis[x_idx(i)]) {\n      process_component(x_idx(i));\n    }\n  }\n\n  for (int i = 1; i <= n; i++) {\n    if (!vis[y_idx(i)]) {\n      process_component(y_idx(i));\n    }\n  }\n\n  cout << tot_ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=2e5+5,P=1e9+7;\ninline int fpow(int a,int t){static int r;for(r=1;t;t>>=1,a=(ll)a*a%P)if(t&1)r=(ll)r*a%P;return r;}\nint n,fac[N],ifac[N],ans=1,m,now;\ninline int C(int n,int m){return (ll)fac[n]*ifac[m]%P*ifac[n-m]%P;}\n\nbool vi[N];\nvector<int>e[N];\nint id[N],idc,s1,s2,fa[N],pa[N];\n\nvoid dfs(int x){\n\tvi[x]=true;id[++idc]=x;\n\tif(x<=n)s1++;else s2++;\n\tsort(e[x].begin(),e[x].end());\n\tfor(int v:e[x])if(fa[x]!=v){\n\t\tfa[v]=x;if(!vi[v])dfs(v);\n\t}\n}\nint find(int x){\n\tif(vi[x])return x; \n\tvi[x]=true;\n\tint t=0;\n\tfor(int v:e[x])if(pa[x]!=v){pa[v]=x,t=find(v);if(t)break;}\n\tvi[x]=false;\n\treturn t;\n}\n\nint sz[N],in[N];\nvector<int>E[N];\n\nint solve(int x){\n\tint r=1;\n\tfor(int v:E[x]){\n\t\tr=(ll)r*solve(v)%P;\n\t\tr=(ll)r*C(sz[x]+sz[v],sz[v])%P;\n\t\tsz[x]+=sz[v];\n\t}\n\tsz[x]++;\n\treturn r;\n}\n\nint calc(){\n\tfor(int i=1,u;i<=idc;i++)for(int x:e[u=id[i]]){if(x==fa[u])break;E[u].pb(x),in[x]++;}\n\tfor(int i=1,u;i<=idc;i++)if(!in[u=id[i]])E[0].pb(u),in[u]++;\n\tint ans=solve(0);\n\tfor(int i=0,u;i<=idc;i++)E[u=id[i]].clear(),in[u]=sz[u]=0;\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor(int i=1;i<=2*n;i++)fac[i]=(ll)fac[i-1]*i%P;\n\tifac[2*n]=fpow(fac[2*n],P-2);\n\tfor(int i=2*n;i>=1;i--)ifac[i-1]=(ll)ifac[i]*i%P;\n\tfor(int i=1,x,y;i<=2*n;i++)scanf(\"%d%d\",&x,&y),e[x].pb(y+n),e[y+n].pb(x);\n\tfor(int i=1;i<=2*n;i++)if(!vi[i]){\n\t\tint R=find(i);\n\t\tdfs(R);\n\t\tif(s1!=s2){ans=0;break;}\n\t\tnow=calc();\n\t\tfor(int x=pa[R]=fa[R];x!=R;x=pa[x]=fa[x]);\n\t\tfa[pa[R]]=R;\n\t\tfor(int x=pa[R];x!=R;x=pa[x])fa[pa[x]]=x;\n\t\tnow=(now+calc())%P;\n\t\tans=(ll)ans*now%P*C(m+idc,m)%P;\n\t\tm+=idc;\n\t\twhile(idc)id[idc--]=0;s1=s2=0;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n\nconst int kN = 200000 + 5;\nconst int MOD = (int)1e9 + 7;\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a < 0) a += MOD;\n    else if (a >= MOD) a -= MOD;\n}\n\ninline int mul(int x)\n{\n    return x;\n}\n\ntemplate<typename... Args>\ninline int mul(int x, Args... args)\n{\n    return x * 1ll * mul(args...) % MOD;\n}\n\n\nint n;\nstd::vector<int> edges[kN], tree[kN];\nbool vis[kN], in[kN];\nstd::vector<int> vec;\nint F[kN], Finv[kN], Inv[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return mul(F[a], Finv[b], Finv[a - b]);\n}\n\nint dfs(int u)\n{\n    int ret = 1;\n    vis[u] = true;\n    vec.emplace_back(u);\n    for (int v : edges[u]) if (!vis[v])\n        ret -= dfs(v);\n    return ret;\n}\n\nbool find_cycle(int u, int fa, int &s, int &t)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != fa) {\n        if (vis[v]) {\n            s = u;\n            t = v;\n            return true;\n        } else if (find_cycle(v, u, s, t)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int u, int target)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != target) {\n        if (!vis[v])\n            dfs2(v, u);\n        // printf(\"(u, target): (%d, %d)\\n\", u, target);\n        if (v < target) {\n            tree[u].emplace_back(v);\n            // printf(\"%d->%d\\n\", u, v);\n            in[v] = true;\n        }\n    }\n}\n\nusing Val = std::pair<int, int>;\n\nVal combine(Val a, Val b)\n{\n    return Val(a.first + b.first, mul(a.second, b.second, binom(a.first + b.first, a.first)));\n}\n\nVal calc(int u)\n{\n    Val ret(0, 1);\n    for (int v : tree[u]) {\n        ret = combine(ret, calc(v));\n    }\n    ret.first ++;\n    // printf(\"u = %d, ret = (%d, %d)\\n\", u, ret.first, ret.second);\n    return ret;\n}\n\nVal solve(int u)\n{\n    vec.clear();\n    if (dfs(u) % 2)\n        return std::make_pair(0, 0);\n    int e = 0;\n    for (int v : vec)\n        e += edges[v].size();\n    if (e / 2 != vec.size()) {\n        return std::make_pair(0, 0);\n    }\n\n    for (int v : vec) vis[v] = false;\n    int s, t;\n    assert(find_cycle(u, -1, s, t));\n    int ways = 0;\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(s, t);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve0::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(t, s);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve1::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    return std::make_pair(vec.size(), ways);\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = mul(MOD - MOD / i, Inv[MOD % i]);\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = mul(F[i - 1], i);\n        Finv[i] = mul(Finv[i - 1], Inv[i]);\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n * 2; ++ i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b); a --; b --;\n        edges[a].emplace_back(n + b);\n        edges[n + b].emplace_back(a);\n    }\n    Val val(0, 1);\n    for (int i = 0; i < n; ++ i) if (!vis[i]) {\n        val = combine(val, solve(i));\n    }\n    printf(\"%d\\n\", val.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x){\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 201000;\nstruct Edge {int v, nxt;} a[N*4];\nint head[N], Head[N], indeg[N];\nint sz[N], pr[N];\nbool vis[N];\nint n, _;\n\ninline void add(int x, int y, int*arr) {\n\ta[++_].v = y, a[_].nxt = arr[x], arr[x] = _;\n}\n\nconst int p = 1e9+7;\nint fac[N], ifac[N], inv[N];\n\nint st[N], tp;\n#define FID(i) for(int id=1,i;i=st[id],id<=tp;++id)\n\nint X, Y;\nint et, pt;\n\nvoid bfs(int x, int las) {\n\tvis[st[++tp] = x] = true, ++pt;\n\tfor(int i=head[x];i;++et,i=a[i].nxt)\n\t\tif(!vis[a[i].v]) bfs(a[i].v, x);\n\t\telse if(a[i].v != las) X = x, Y = a[i].v;\n}\n\nvoid tfs(int x, int las) {\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tif(a[i].v != las and a[i].v != X)\n\t\t\tpr[a[i].v] = x, tfs(a[i].v, x);\n}\n\nvoid dfs(int x, int las) {\n\tsz[x] = 1;\n\tfor(int i=Head[x];i;i=a[i].nxt)\n\t\tif(a[i].v != las)\n\t\t\tdfs(a[i].v, x), sz[x] += sz[a[i].v];\n}\n\nint solve() {\n\ttfs(X, Y);\n\tpr[X] = Y;\n\tFID(i) Head[i] = indeg[i] = 0;\n\tFID(x) for(int i=head[x];i;i=a[i].nxt)\n\t\tif(a[i].v < pr[x]) add(x, a[i].v, Head), ++indeg[a[i].v];\n\t\n\tFID(i) if(!indeg[i]) dfs(i, i);\n\tint Ans = fac[pt];\n\tFID(i) Ans = (ll)Ans * inv[sz[i]]%p;\n\treturn Ans;\n}\n\nint main() {\n\tread(n);\n\tfor(int i=1,x,y;i<=(n<<1);++i) {\n\t\tread(x), read(y), y += n;\n\t\tadd(x, y, head), add(y, x, head);\n\t}\n\t\n\tn <<= 1;\n\tfac[0] = fac[1] = inv[0] = inv[1] = ifac[0] = ifac[1] = 1;\n\tfor(int i=2;i<=n;++i) {\n\t\tfac[i] = (ll)fac[i-1] * i%p;\n\t\tinv[i] = (ll)(p-p/i) * inv[p%i]%p;\n\t\tifac[i] = (ll)ifac[i-1] * inv[i]%p;\n\t}\n\t\n\tint Ans = fac[n];\n\tfor(int i=1;i<=n;++i)\n\t\tif(!vis[i]) {\n\t\t\ttp = pt = et = 0;\n\t\t\tbfs(i, i);\n\t\t\tAns = (ll)Ans * ifac[pt]%p;\n\t\t\tif((pt << 1) != et) return puts(\"0\"), 0;\n\t\t\tint res = solve();\n\t\t\tX ^= Y, Y ^= X, X ^= Y;\n\t\t\tres += solve();\n\t\t\tAns = (ll)Ans * res%p;\n\t\t}\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=2e5+7;\nvi G[maxn];\nvi lp;\nint ce=0,cc;\nconst int mod=1e9+7;\nbool vis[maxn],ins[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nint st[maxn];\nint p;\nint sz[maxn];\nvi cG;\nint fd=0;\nvoid dfs(int u,int fa=-1)\n{\n    vis[u]=1;\n    ins[u]=1;\n    st[p++]=u;\n    cc++;\n    for(auto v:G[u])\n    {\n        if(v!=fa)\n        {\n            if(ins[v])\n            {\n                ce++;\n                fd++;\n                if(fd>=2) return ;\n                for(int i=p-1;st[i]!=v;i--)\n                    lp.push_back(st[i]);\n                lp.push_back(v);\n            }\n            if(!vis[v]) ce++,dfs(v,u);\n        }\n    }\n    ins[u]=0;\n    p--;\n}\nint n;\nbool vv[maxn];\nvi used;\nll cursz;\nvi nG[maxn];\nvoid dfs2(int u,int fa)\n{\n    vv[u]=1;\n    used.push_back(u);\n    for(auto v:G[u])\n    {\n        if(v==fa) continue;\n        if(!vv[v])\n            dfs2(v,u);\n        if(v<fa) {\n            nG[u].push_back(v);\n        }\n    }\n}\nbool v3[maxn];\nvoid dfs3(int u)\n{\n    if(v3[u]) return;\n    v3[u]=1;\n    sz[u]=1;\n    for(auto v:nG[u])\n    {\n        dfs3(v);\n        sz[u]+=sz[v];\n    }\n    cursz=cursz*sz[u]%mod;\n    //dbg(u,sz[u]);\n}\nint main()\n{\n    cin>>n;\n    for(int i=0,x,y;i<2*n;i++)\n    {\n        cin>>x>>y;\n        G[x].push_back(y+n);\n        G[y+n].push_back(x);\n    }\n    for(int i=1;i<=2*n;i++) sort(G[i].begin(),G[i].end());\n    ll ans=1;\n    for(int i=1;i<=2*n;i++)\n    {\n        if(!vis[i])\n        {\n            ce=cc=0;\n            p=0;\n            lp.clear();\n            dfs(i);\n            //dbg(lp);\n            if(ce!=cc||fd>=2)\n            {\n                ans=0;\n                break;\n            }\n            cursz=1;\n            dfs2(lp[1],lp[0]);\n            for(auto v:used) \n            {\n                dfs3(v);\n                vv[v]=0;\n            }\n            //dbg(cursz);\n            ll tmp=inv(cursz);\n            for(auto v:used) nG[v].clear(),v3[v]=0;\n            used.clear();\n            dfs2(lp[0],lp[1]);\n            cursz=1;\n            for(auto v:used)\n            {\n                dfs3(v);\n                vv[v]=0;\n            }\n            used.clear();\n            cursz=(inv(cursz)+tmp)%mod;\n            ans=(ans*cursz)%mod;\n        }\n    }\n    for(int i=1;i<=2*n;i++) ans=ans*i%mod;\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=200010;\nconst int ha=1e9+7;\nstruct Edge{int to,next;} e[N<<1],et[N<<1];\nint h[N],ht[N],esum=0,tsum=0,n,cmt=0;\nint gay[N],out[N],sz[N];\nbool done[N],inc[N],flag;\nvector<int> crl,vertix;\nstack<int> s;\nint fac[N];\n\nint Pow(int a,int b)\n{\n    int ans=1;\n    for(;b;b>>=1,a=1ll*a*a%ha)\n        if(b&1) ans=1ll*ans*a%ha;\n    return ans;\n}\n\nvoid add_edge(int u,int v)\n{\n    e[++esum]={v,h[u]};h[u]=esum;\n    e[++esum]={u,h[v]};h[v]=esum;\n}\n\nvoid add_topo_edge(int u,int v)\n{\n    out[v]++;\n    et[++tsum].to=v;\n    et[tsum].next=ht[u];\n    ht[u]=tsum;\n}\n\nvoid findcrl(int u,int fa)\n{\n    vertix.push_back(u);\n    done[u]=1;s.push(u);\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa) continue;\n        if(!flag&&done[v])\n        {\n            while(s.top()!=v) crl.push_back(s.top()),inc[s.top()]=1,s.pop();\n            crl.push_back(v);inc[v]=1;s.pop();\n            flag=1;cmt++;return;\n        }\n        else if(!done[v]) cmt++,findcrl(v,u);\n    }\n    if(!s.empty()&&s.top()==u) s.pop();\n}\n\nvoid findgay(int u,int fa)\n{\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa||inc[v]) continue;\n        gay[v]=u;findgay(v,u);\n    }\n}\n\nvoid build_topo()\n{\n    for(int u : vertix)\n        for(int t=h[u];t;t=e[t].next)\n        {\n            int v=e[t].to;\n            if(v>=gay[u]) continue;\n            add_topo_edge(u,v);\n        }\n    for(int u : vertix)\n        if(!out[u]) add_topo_edge(0,u);\n    for(int u : vertix) out[u]=0;\n}\n\nvoid getsize(int u)\n{\n    sz[u]=1;\n    for(int t=ht[u];~t;t=et[t].next)\n    {\n        int v=et[t].to;\n        getsize(v);\n        sz[u]+=sz[v];\n    }\n    ht[u]=-1;\n}\n\nint getans()\n{\n    int prodsz=1;getsize(0);\n    for(int u : vertix)\n        prodsz=1ll*prodsz*sz[u]%ha;\n    return Pow(prodsz,ha-2);\n}\n\nint xi_jin_ping_is_good(int u)\n{\n    flag=0;cmt=0;findcrl(u,0);\n    if(vertix.size()!=cmt) return 0;\n    for(int u : crl) if(inc[u]) findgay(u,0);\n    for(int i=0;i<crl.size()-1;i++) gay[crl[i]]=crl[i+1];\n    gay[crl.back()]=crl[0];\n    tsum=-1;build_topo();\n    int res=getans();\n    for(int i=1;i<crl.size();i++) gay[crl[i]]=crl[i-1];\n    gay[crl[0]]=crl.back();\n    tsum=-1;build_topo();\n    res=(res+getans())%ha;\n    for(int u : vertix) inc[u]=0;\n    vertix.clear();crl.clear();\n    return res;\n}\n\nint main()\n{\n    memset(ht,-1,sizeof(ht));\n    int x,y,ans=1;\n    n=read()<<1;fac[0]=1;\n    for(int i=1;i<=n;i++)\n        fac[i]=1ll*fac[i-1]*i%ha;\n    for(int i=1;i<=n;i++)\n    {\n        x=read();y=read();\n        add_edge(x,y+n/2);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(done[i]) continue;\n        x=xi_jin_ping_is_good(i);\n        if(x==0) return puts(\"0\"),0;\n        ans=1ll*ans*x%ha;\n    }\n    ans=1ll*fac[n]*ans%ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <algorithm>\n\nint read()\n{\n  int x=0,f=1;\n  char ch=getchar();\n  while((ch<'0')||(ch>'9'))\n    {\n      if(ch=='-')\n        {\n          f=-f;\n        }\n      ch=getchar();\n    }\n  while((ch>='0')&&(ch<='9'))\n    {\n      x=x*10+ch-'0';\n      ch=getchar();\n    }\n  return x*f;\n}\n\nconst int maxn=100000;\nconst int maxv=maxn*2;\nconst int maxe=maxv*2;\nconst int mod=1000000007;\n\nstd::queue<int> q;\nstd::vector<int> cur;\nint n,pre[maxe+10],now[maxv+10],son[maxe+10],tot,_pre[maxe+10],_now[maxv+10],_son[maxe+10],_tot,vis[maxv+10],ecnt,cir[maxv+10],deg[maxv+10],choose[maxv+10],fac[maxv+10],ifac[maxv+10],f[maxv+10],size[maxv+10];\n\nint C(int a,int b)\n{\n  return 1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint _ins(int a,int b)\n{\n  _pre[++_tot]=_now[a];\n  _now[a]=_tot;\n  _son[_tot]=b;\n  return 0;\n}\n\nint calc()\n{\n  for(auto i:cur)\n    {\n      deg[i]=_now[i]=0;\n    }\n  for(auto i:cur)\n    {\n      for(int j=now[i]; j; j=pre[j])\n        {\n          int v=son[j];\n          if(v<choose[i])\n            {\n              _ins(v,i);\n              ++deg[i];\n            }\n        }\n    }\n  for(auto i:cur)\n    {\n      if(!deg[i])\n        {\n          q.push(i);\n        }\n      f[i]=1;\n      size[i]=1;\n    }\n  int sz=0,ans=1;\n  while(!q.empty())\n    {\n      int u=q.front(),flag=0;\n      q.pop();\n      for(int i=_now[u]; i; i=_pre[i])\n        {\n          flag=1;\n          int v=_son[i];\n          --deg[v];\n          size[v]+=size[u];\n          f[v]=1ll*f[v]*f[u]%mod*C(size[v]-1,size[u])%mod;\n          if(!deg[v])\n            {\n              q.push(v);\n            }\n        }\n      if(!flag)\n        {\n          sz+=size[u];\n          ans=1ll*ans*f[u]%mod*C(sz,size[u])%mod;\n        }\n    }\n  return ans;\n}\n\nint ins(int a,int b)\n{\n  pre[++tot]=now[a];\n  now[a]=tot;\n  son[tot]=b;\n  return 0;\n}\n\nint dfs(int u)\n{\n  vis[u]=1;\n  cur.push_back(u);\n  for(int i=now[u]; i; i=pre[i])\n    {\n      ++ecnt;\n      int v=son[i];\n      if(!vis[v])\n        {\n          dfs(v);\n        }\n    }\n  return 0;\n}\n\nint search(int u)\n{\n  cir[++cir[0]]=u;\n  vis[u]=1;\n  for(int i=now[u]; i; i=pre[i])\n    {\n      int v=son[i];\n      if(!vis[v])\n        {\n          search(v);\n        }\n    }\n  return 0;\n}\n\nint solve()\n{\n  if((int)cur.size()!=ecnt)\n    {\n      return 0;\n    }\n  for(auto i:cur)\n    {\n      if(deg[i]==1)\n        {\n          q.push(i);\n        }\n    }\n  while(!q.empty())\n    {\n      int u=q.front();\n      q.pop();\n      for(int i=now[u]; i; i=pre[i])\n        {\n          int v=son[i];\n          if(deg[v]!=1)\n            {\n              --deg[v];\n              choose[u]=v;\n              if(deg[v]==1)\n                {\n                  q.push(v);\n                }\n            }\n        }\n    }\n  int st=0;\n  for(auto i:cur)\n    {\n      if(deg[i]>1)\n        {\n          st=i;\n          vis[i]=0;\n        }\n    }\n  cir[0]=0;\n  search(st);\n  cir[cir[0]+1]=cir[1];\n  for(int i=1; i<=cir[0]; ++i)\n    {\n      choose[cir[i]]=cir[i+1];\n    }\n  int res=calc();\n  for(int i=2; i<=cir[0]+1; ++i)\n    {\n      choose[cir[i]]=cir[i-1];\n    }\n  res+=calc();\n  if(res>=mod)\n    {\n      res-=mod;\n    }\n  for(auto i:cur)\n    {\n      vis[i]=1;\n    }\n  return res;\n}\n\nint main()\n{\n  n=read();\n  fac[0]=1;\n  for(int i=1; i<=n<<1; ++i)\n    {\n      fac[i]=1ll*fac[i-1]*i%mod;\n    }\n  ifac[0]=ifac[1]=1;\n  for(int i=2; i<=n<<1; ++i)\n    {\n      ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;\n    }\n  for(int i=2; i<=n<<1; ++i)\n    {\n      ifac[i]=1ll*ifac[i-1]*ifac[i]%mod;\n    }\n  for(int i=1; i<=n<<1; ++i)\n    {\n      int x=read(),y=read();\n      ins(x,y+n);\n      ins(y+n,x);\n      ++deg[x];\n      ++deg[y+n];\n    }\n  int tsize=0,ans=1;\n  for(int i=1; i<=n<<1; ++i)\n    {\n      if(!vis[i])\n        {\n          cur.clear();\n          ecnt=0;\n          dfs(i);\n          ecnt/=2;\n          int res=solve();\n          tsize+=ecnt;\n          ans=1ll*ans*res%mod*C(tsize,ecnt)%mod;\n        }\n    }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nint x[210000];\nint y[210000];\nint UF[210000];\nvector<int>g[210000];\nint FIND(int a){\n\tif(UF[a]<0)return a;return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint h[210000];\nint v[210000];\nvector<int>cy;\nvector<int>cur;\nint dfs(int a,int b){\n\tv[a]=b;\n\t\n\tcur.push_back(a);\n\tint ret=-2;\n\t// printf(\"%d %d %d\\n\",a,b,(int)g[a].size());\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]==b)continue;\n\t\tif(v[g[a][i]]==-2){\n\t\t\tint val=dfs(g[a][i],a);\n\t\t\tif(val!=-2){\n\t\t\t\tcy.push_back(a);\n\t\t\t\tif(a==val)val=-2;\n\t\t\t}\n\t\t\tif(val!=-2) ret=val;\n\t\t}else{\n\t\t\tcy.push_back(a);\n\t\t\treturn g[a][i];\n\t\t}\n\t}\n\t// printf(\"fin %d %d\\n\",a,b);fflush(stdout);\n\treturn ret;\n}\nvector<int>g2[210000];\nint sz[210000];\nint ou[210000];\nlong long calc(int a){\n\tlong long ret=1;\n\tsz[a]=0;\n\tfor(int i=0;i<g2[a].size();i++){\n\t\tret=ret*calc(g2[a][i])%mod;\n\t\tret=ret*Comb(sz[a]+sz[g2[a][i]],sz[a])%mod;\n\t\tsz[a]+=sz[g2[a][i]];\n\t}\n\tsz[a]++;\n\t// printf(\"%d: %lld\\n\",a,ret);\n\treturn ret;\n}\nint tl[210000];\nint n;\nvoid dfs2(int a,int b){\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\t// printf(\"%d %d\\n\",a,g[a][i]);\n\t\ttl[g[a][i]]=a;\n\t\tif(g[a][i]==cy[0])continue;\n\t\tdfs2(g[a][i],a);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tfor(int i=0;i<a*2;i++)UF[i]=-1;\n\tfor(int i=0;i<a*2;i++)v[i]=-2;\n\tinit_C(410000);\n\tfor(int i=0;i<2*a;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tx[i]--;y[i]--;\n\t\tg[x[i]].push_back(y[i]+a);\n\t\tg[y[i]+a].push_back(x[i]);\n\t\tUNION(x[i],y[i]+a);\n\t}\n\tfor(int i=0;i<a*2;i++){\n\t\th[FIND(x[i])]++;\n\t}\n\tlong long ret=1;\n\tlong long ks=1;\n\tint tn=0;\n\tfor(int i=0;i<a*2;i++){\n\t\tif(UF[i]<0&&h[i]!=-UF[i]){\n\t\t\tprintf(\"0\\n\");return 0;\n\t\t}\n\t\tif(UF[i]<0){\n\t\t\tcur.clear();\n\t\t\tks=ks*Comb(tn+h[i],h[i])%mod;\n\t\t\ttn+=h[i];\n\t\t\tcy.clear();\n\t\t\tdfs(i,-1);\n\t\t\t// for(int j=0;j<cy.size();j++)printf(\"%d \",cy[j]);printf(\"\\n\");\n\t\t\tlong long tmp=0;\n\t\t\tfor(int k=0;k<2;k++){\n\n\t\t\t\tif(k==0)dfs2(cy[0],cy[1]);\n\t\t\t\telse dfs2(cy[0],cy[cy.size()-1]);\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tfor(int l=0;l<g[cur[j]].size();l++){\n\t\t\t\t\t\tint to=g[cur[j]][l];\n\t\t\t\t\t\tif(to<tl[cur[j]]){\n\t\t\t\t\t\t\tg2[cur[j]].push_back(to);\n\t\t\t\t\t\t\t// printf(\"%d %d\\n\",cur[j],to);\n\t\t\t\t\t\t\tou[to]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tif(!ou[cur[j]]){\n\t\t\t\t\t\tg2[a*2].push_back(cur[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp+=calc(a*2);\n\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tg2[cur[j]].clear();\n\t\t\t\t\tou[cur[j]]=0;\n\t\t\t\t}\n\t\t\t\tg2[a*2].clear();\n\t\t\t}\n\t\t\ttmp%=mod;\n\t\t\t// printf(\"%d: %lld\\n\",i,tmp);\n\t\t\tret=ret*tmp%mod;\n\t\t}\n\t}\n\n\tret=ret*ks%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n\nconst int kN = 200000 + 5;\nconst int MOD = (int)1e9 + 7;\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a < 0) a += MOD;\n    else if (a >= MOD) a -= MOD;\n}\n\ninline int mul(int x)\n{\n    return x;\n}\n\ntemplate<typename... Args>\ninline int mul(int x, Args... args)\n{\n    return x * 1ll * mul(args...) % MOD;\n}\n\n\nint n;\nstd::vector<int> edges[kN], tree[kN];\nbool vis[kN], in[kN];\nstd::vector<int> vec;\nint F[kN], Finv[kN], Inv[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return mul(F[a], Finv[b], Finv[a - b]);\n}\n\nint dfs(int u)\n{\n    int ret = 1;\n    vis[u] = true;\n    vec.emplace_back(u);\n    for (int v : edges[u]) if (!vis[v])\n        ret -= dfs(v);\n    return ret;\n}\n\nbool find_cycle(int u, int fa, int &s, int &t)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != fa) {\n        if (vis[v]) {\n            s = u;\n            t = v;\n            return true;\n        } else if (find_cycle(v, u, s, t)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int u, int target)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != target) {\n        if (!vis[v])\n            dfs2(v, u);\n        // printf(\"(u, target): (%d, %d)\\n\", u, target);\n        if (v < target) {\n            tree[u].emplace_back(v);\n            // printf(\"%d->%d\\n\", u, v);\n            in[v] = true;\n        }\n    }\n}\n\nusing Val = std::pair<int, int>;\n\nVal combine(Val a, Val b)\n{\n    return Val(a.first + b.first, mul(a.second, b.second, binom(a.first + b.first, a.first)));\n}\n\nVal calc(int u)\n{\n    Val ret(0, 1);\n    for (int v : tree[u]) {\n        ret = combine(ret, calc(v));\n    }\n    ret.first ++;\n    // printf(\"u = %d, ret = (%d, %d)\\n\", u, ret.first, ret.second);\n    return ret;\n}\n\nVal solve(int u)\n{\n    vec.clear();\n    dfs(u);\n    int e = 0;\n    for (int v : vec)\n        e += edges[v].size();\n    if (e / 2 != vec.size() || vec.size() % 2 != 0) {\n        return std::make_pair(0, 0);\n    }\n\n    for (int v : vec) vis[v] = false;\n    int s, t;\n    assert(find_cycle(u, -1, s, t));\n    int ways = 0;\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(s, t);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve0::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(t, s);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve1::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    return std::make_pair(vec.size(), ways);\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = mul(MOD - MOD / i, Inv[MOD % i]);\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = mul(F[i - 1], i);\n        Finv[i] = mul(Finv[i - 1], Inv[i]);\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n * 2; ++ i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b); a --; b --;\n        edges[a].emplace_back(n + b);\n        edges[n + b].emplace_back(a);\n    }\n    Val val(0, 1);\n    for (int i = 0; i < n; ++ i) if (!vis[i]) {\n        val = combine(val, solve(i));\n    }\n    printf(\"%d\\n\", val.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nusing pi = pair<int, int>;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nint n, sz[MAXN], indeg[MAXN];\nvector<pi> gph[MAXN];\nvector<int> tr[MAXN];\nvector<int> dfn;\nint deg[MAXN], vis[MAXN];\nint match[MAXN];\nlint fact[MAXN], invf[MAXN];\n\nlint dfs2(int x){\n\tsz[x] = 0;\n\tlint ret = 1;\n\tfor(auto &i : tr[x]){\n\t\tret *= dfs2(i);\n\t\tret %= mod;\n\t}\n\tfor(auto &i : tr[x]){\n\t\tsz[x] += sz[i];\n\t\tret *= invf[sz[i]];\n\t\tret %= mod;\n\t}\n\tret *= fact[sz[x]];\n\tret %= mod;\n\tsz[x]++;\n\treturn ret;\n}\n\nlint topsort(){\n\tvector<pi> edges; // fi -> se\n\tfor(auto &i : dfn){\n\t\tint to_match = -1;\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(match[i] == j.second){\n\t\t\t\tto_match = j.first;\n\t\t\t}\n\t\t}\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(match[i] > j.second){\n\t\t\t\tedges.emplace_back(j.first, to_match);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto &i : dfn) disj.pa[i] = i;\n\tfor(auto &i : edges){\n\t\tif(!disj.uni(i.first, i.second)){\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(auto &i : edges){\n\t\ttr[i.second].push_back(i.first);\n\t\tindeg[i.first]++;\n\t}\n\tlint ret = 1;\n\tfor(auto &i : dfn){\n\t\tif(indeg[i] == 0){\n\t\t\tret *= dfs2(i) * invf[sz[i]] % mod;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret *= fact[dfn.size()];\n\tfor(auto &i : edges){\n\t\tindeg[i.first] = 0;\n\t\ttr[i.second].clear();\n\t}\n\treturn ret % mod;\n}\n\nlint solve(){\n\tqueue<int> que;\n\tfor(auto &i : dfn){\n\t\tif(deg[i] == 1){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tint x = que.front(); que.pop();\n\t\tdeg[x]--;\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(deg[i.second]){\n\t\t\t\tmatch[x] = i.second;\n\t\t\t\tdeg[i.second]--;\n\t\t\t\tif(deg[i.second] == 1){\n\t\t\t\t\tque.push(i.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> cyc_ord;\n\tfor(auto &i : dfn){\n\t\tif(deg[i] == 2){\n\t\t\tfor(int j=i; deg[j]; ){\n\t\t\t\tdeg[j] = 0;\n\t\t\t\tcyc_ord.push_back(j);\n\t\t\t\tfor(auto &k : gph[j]){\n\t\t\t\t\tif(deg[k.second]){\n\t\t\t\t\t\tj = k.second;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i=0; i<cyc_ord.size(); i++){\n\t\tmatch[cyc_ord[i]] = cyc_ord[(i+1)%cyc_ord.size()];\n\t}\n\tret += topsort();\n\treverse(cyc_ord.begin(), cyc_ord.end());\n\tfor(int i=0; i<cyc_ord.size(); i++){\n\t\tmatch[cyc_ord[i]] = cyc_ord[(i+1)%cyc_ord.size()];\n\t}\n\tret += topsort();\n\treturn ret % mod;\n}\n\nint v, e;\n\nvoid dfs(int x){\n\tif(vis[x]) return;\n\tdfn.push_back(x);\n\tvis[x] = 1;\n\tv++;\n\te += gph[x].size();\n\tfor(auto &i : gph[x]) dfs(i.second);\n}\n\nlint ipow(lint x, lint p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint main(){\n\tfact[0] = invf[0] = 1;\n\tfor(int i=1; i<MAXN; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tinvf[i] = ipow(fact[i], mod - 2);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<2*n; i++){\n\t\tint x, y; scanf(\"%d %d\",&x,&y);\n\t\tx--, y += n - 1;\n\t\tgph[x].emplace_back(i, y);\n\t\tgph[y].emplace_back(i, x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tn <<= 1;\n\tdisj.init(n);\n\tlint ret = 1;\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i]){\n\t\t\tv = e = 0;\n\t\t\tdfn.clear();\n\t\t\tdfs(i);\n\t\t\tif(2 * v != e){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tret *= invf[v] * solve() % mod;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret *= fact[n];\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"2,Ofast,inline\")\n#pragma GCC diagnostic error \"-std=c++11\"\n#include<bits/stdc++.h>\n#define LL long long\n#define int LL\n#define P pair<int,int>\n#define fi first\n#define se second\nconst LL N=2e5+10;\nconst LL mod=1e9+7;\nconst LL inf=0x3f3f3f;\nconst double eps=1e-9;\nusing namespace std;\ntemplate<typename tp> inline void read(tp &x)\n{\n    x=0;char c=getchar();\n    bool f=0; for(; c<'0'||c>'9'; f|=(c=='-'),c = getchar());\n    for(; c>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0',c = getchar());\n    if(f) x=-x;\n}\nP wei[N<<1];\nmap<P,int> Map;\nvector<P> idd;\nvector<int> line[N],row[N],vec,node;\n \nint n,found;\nint head[N<<1],cnt;\nint fa[N<<1],side[N<<1],vis[N<<1];\nint tou[N<<1],num;\nLL siz[N<<1];\n \nstruct Node { int next,to,id;} edge[N<<3];\nstruct E {int next,to;} e[N<<3];\n \nvoid add(int from,int to,int id) { edge[++cnt]= {head[from],to,id}; head[from]=cnt;}\nvoid insert(int from,int to,int id) { add(from,to,id); add(to,from,id);}\nvoid jia(int from,int to) {e[++num]= {tou[from],to}; tou[from]=num;}\nP calc(int x,int y) { if(x>y) swap(x,y); y-=n; return P(x,y);}\nLL KSM(LL a,LL b,LL ret=1) { while(b) { if(b&1) ret=ret*a%mod; a=a*a%mod; b>>=1; } return ret;}\nint ask(P x) { return lower_bound(idd.begin(),idd.end(),x)-idd.begin()+1;}\n\nvoid dfs(int now,int fath)\n{\n    vis[now]=1;\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        if(found==1) return ;\n        int to=edge[i].to;\n        if(to==fath) continue;\n        if(vis[to])\n        {\n            int flag=now;\n            while(flag!=to)\n            {\n                vec.push_back(flag);\n                flag=fa[flag];\n            }\n            vec.push_back(to);\n            found = 1;\n            return ;\n        }\n        fa[to]=now;\n        dfs(to,now);\n    }\n}\nvoid dfs_side_other(int now,int fa)\n{\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        int to=edge[i].to;\n        if(vis[to]==2||to==fa)\n            continue;\n        vis[to]=1;\n        if(to>n) side[edge[i].id]=2;\n        else side[edge[i].id]=1;\n        node.push_back(edge[i].id);\n        dfs_side_other(to,now);\n    }\n}\nLL dfs_size(int now)\n{\n    if(siz[now]) return siz[now];\n    siz[now]=1;\n    for(int i=tou[now]; i; i=e[i].next)\n    {\n        int to=e[i].to;\n        siz[now]+=dfs_size(to);\n    }\n    return siz[now];\n}\nvoid built()\n{\n    for(int i=0; i<node.size(); i++)\n    {\n        int x=wei[node[i]].fi,y=wei[node[i]].se;\n        if(side[node[i]]==1)\n        {\n            int pos=lower_bound(line[x].begin(),line[x].end(),y)-line[x].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(x,line[x][j])));\n        }\n        else\n        {\n            int pos=lower_bound(row[y].begin(),row[y].end(),x)-row[y].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(row[y][j],y)));\n        }\n    }\n}\nLL solve(int now)\n{\n    found = 0;\n    LL ret1=1,ret2=1;\n    vec.clear(), node.clear();\n    dfs(now,now);\n    // for(int i=0;i<vec.size();i++) cout<<vec[i]<<\" \";puts(\"\");\n    for(int i=0; i<vec.size(); i++) vis[vec[i]]=2;\n    for(int i=0; i<vec.size(); i++) dfs_side_other(vec[i],vec[i]);\n    for(int i=0; i<vec.size()-1; i++)\n    {\n        side[ask(calc(vec[i],vec[i+1]))]=(vec[i+1]>n?1:2);\n        node.push_back(ask(calc(vec[i],vec[i+1])));\n    }\n    side[ask(calc(vec[vec.size()-1],vec[0]))]=(vec[0]>n?1:2);\n    node.push_back(ask(calc(vec[vec.size()-1],vec[0])));\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    // for(int i=0; i<node.size();i++) cout<<node[i]<<\" \";puts(\"\");\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret1=ret1*KSM(dfs_size(node[i]),mod-2)%mod;\n    // puts(\"\");\n    // for(int i=0;i<node.size();i++) cout<<node[i]<<\" \"<<dfs_size(node[i])<<endl;\n    // puts(\"\");\n    num=0;\n    for(int i=0; i<node.size(); i++) tou[node[i]]=0;\n    for(int i=vec.size()-1; i>0; i--)\n        side[ask(calc(vec[i],vec[i-1]))]=(vec[i-1]>n?1:2);\n    side[ask(calc(vec[0],vec[vec.size()-1]))]=(vec[vec.size()-1]>n?1:2);\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret2=ret2*KSM(dfs_size(node[i]),mod-2)%mod;\n    return ret1+ret2;\n}\nsigned main()\n{\n\t// freopen(\"data,in\",\"r\",stdin);\n    read(n);\n    for(int i=1,x,y; i<=n*2; i++)\n    {\n        read(x),read(y),insert(x,y+n,i);\n        // wei[i]=P(x,y);\n        // Map[P(x,y)]=i;\n\t\tidd.push_back(P(x,y));\n        line[x].push_back(y);\n        row[y].push_back(x);\n    }\n\tsort(idd.begin(),idd.end());\n\tfor(int i=0;i<n*2;i++)\n\t\twei[i+1]=idd[i];\n    for(int i=1; i<=n; i++)\n    {\n        sort(line[i].begin(),line[i].end()),\n        sort(row[i].begin(),row[i].end());\n        if(!line[i].size()||!row[i].size())\n            return 0*puts(\"0\");\n    }\n    LL ans=1;\n    for(int i=1; i<=n*2; i++)\n        if(!vis[i])\n            ans=ans*solve(i)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n/*\n3\n2 1\n1 2\n2 2\n3 3\n3 2\n2 3\n \noxo\nxxx\noxx\n \n850000006\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=2e5+7;\nvi G[maxn];\nvi lp;\nint ce=0,cc;\nconst int mod=1e9+7;\nbool vis[maxn],ins[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nint st[maxn];\nint p;\nint sz[maxn];\nvi cG;\nint fd=0;\nvoid dfs(int u,int fa=-1)\n{\n    vis[u]=1;\n    ins[u]=1;\n    st[p++]=u;\n    cc++;\n    for(auto v:G[u])\n    {\n        if(v!=fa)\n        {\n            if(ins[v])\n            {\n                ce++;\n                fd++;\n                if(fd>=2) return ;\n                for(int i=p-1;st[i]!=v;i--)\n                    lp.push_back(st[i]);\n                lp.push_back(v);\n            }\n            if(!vis[v]) ce++,dfs(v,u);\n        }\n    }\n    ins[u]=0;\n    p--;\n}\nint n;\nbool vv[maxn];\nvi used;\nll cursz;\nvi nG[maxn];\nvoid dfs2(int u,int fa)\n{\n    vv[u]=1;\n    used.push_back(u);\n    for(auto v:G[u])\n    {\n        if(v==fa) continue;\n        if(!vv[v])\n            dfs2(v,u);\n        if(v<fa) {\n            nG[u].push_back(v);\n        }\n    }\n}\nbool v3[maxn];\nvoid dfs3(int u)\n{\n    if(v3[u]) return;\n    v3[u]=1;\n    sz[u]=1;\n    for(auto v:nG[u])\n    {\n        dfs3(v);\n        sz[u]+=sz[v];\n    }\n    cursz=cursz*sz[u]%mod;\n    //dbg(u,sz[u]);\n}\nint main()\n{\n    cin>>n;\n    for(int i=0,x,y;i<2*n;i++)\n    {\n        cin>>x>>y;\n        G[x].push_back(y+n);\n        G[y+n].push_back(x);\n    }\n    for(int i=1;i<=2*n;i++) sort(G[i].begin(),G[i].end());\n    ll ans=1;\n    for(int i=1;i<=2*n;i++)\n    {\n        if(!vis[i])\n        {\n            ce=cc=0;\n            p=0;\n            fd=0;\n            lp.clear();\n            dfs(i);\n            //dbg(lp);\n            if(ce!=cc||fd>=2)\n            {\n                ans=0;\n                break;\n            }\n            cursz=1;\n            dfs2(lp[1],lp[0]);\n            for(auto v:used) \n            {\n                dfs3(v);\n                vv[v]=0;\n            }\n            //dbg(cursz);\n            ll tmp=inv(cursz);\n            for(auto v:used) nG[v].clear(),v3[v]=0;\n            used.clear();\n            dfs2(lp[0],lp[1]);\n            cursz=1;\n            for(auto v:used)\n            {\n                dfs3(v);\n                vv[v]=0;\n            }\n            used.clear();\n            cursz=(inv(cursz)+tmp)%mod;\n            ans=(ans*cursz)%mod;\n        }\n    }\n    for(int i=1;i<=2*n;i++) ans=ans*i%mod;\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nchar buf[1 << 20], *p1, *p2;\n#define getchar() ((p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)\n\ntemplate<typename T>\nvoid read(T &x) \n{\n\tx = 0;\n\tint f = 1; char c = getchar();\n\twhile (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }\n\twhile (isdigit(c)) { x = x * 10 + c - 48; c = getchar(); }\n\tx *= f;\n}\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G;\nbool vis[MAXN];\nint edge = 0, s, t;\nvoid GetLoop(int x, int Fa) \n{\n\tG.push_back(x);\n\tvis[x] = true;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (!vis[y]) GetLoop(y, x);\n\t\telse if (y != Fa)\n\t\t\ts = x, t = y;\n\t}\n}\n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[G.size()];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tread(n);\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!vis[i])\n\t\t{\n\t\t\tGetLoop(i, 0);\n\t\t\tif (G.size() << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tG.clear();\n\t\t\tedge = 0;\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\nint n,fac[200100],inv[200100],ans,cntv,cnte,a[200100],deg[200100],link[200100],s[200100];\nbool flag[200100];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[600100],*tp=pool,*fst[200100],*fst2[200100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nint c(int n,int m)\n{\n    return LL(fac[n])*inv[m]%p*inv[n-m]%p;\n}\n\nvoid addedge(int u,int v,edge **fst)\n{\n    *tp=(edge){v,fst[u]},fst[u]=tp++;\n}\n\nvoid dfs1(int x)\n{\n    flag[x]=1,a[++cntv]=x;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (flag[i->v])\n            ++cnte,++deg[x],++deg[i->v];\n        else\n            dfs1(i->v);\n}\n\nint dfs2(int x)\n{\n    int ret=s[x]=1;\n    for (edge *i=fst2[x]; i; i=i->nxt)\n    {\n        ret=LL(ret)*dfs2(i->v)%p;\n        s[x]+=s[i->v],ret=LL(ret)*c(s[x]-1,s[i->v])%p;\n    }\n    return ret;\n}\n\nint calc()\n{\n    static bool flag[200100];\n    edge *t=tp;\n    repu(i,1,cntv)\n        flag[a[i]]=0;\n    repu(i,1,cntv)\n        for (edge *j=fst[a[i]]; j; j=j->nxt)\n            if (j->v<link[a[i]])\n                addedge(a[i],j->v,fst2),flag[j->v]=1;\n    int sum=0,ret=1;\n    repu(i,1,cntv)\n        if (!flag[a[i]])\n        {\n            ret=LL(ret)*dfs2(a[i])%p;\n            ret=LL(ret)*c(sum+=s[a[i]],s[a[i]])%p;\n        }\n    tp=t;\n    repu(i,1,cntv)\n        fst2[a[i]]=0;\n    return ret;\n}\n\nint solve(int x)\n{\n    cntv=cnte=0,dfs1(x);\n    if (cntv>cnte)\n    {\n        puts(\"0\");\n        exit(0);\n    }\n    repu(i,1,cntv)\n        if (deg[a[i]]==1)\n            for (int j=a[i],nxt=0; j; j=nxt,nxt=0)\n                for (edge *k=fst[j]; k; k=k->nxt)\n                    if (deg[k->v]>1)\n                    {\n                        link[j]=k->v;\n                        if (--deg[k->v]==1)\n                            nxt=k->v;\n                    }\n    static int cyc[200100],tot;\n    repu(i,1,cntv)\n        if (deg[a[i]]>1)\n        {\n            cyc[tot=1]=a[i];\n            while (tot==1 || cyc[tot]!=a[i])\n                for (edge *j=fst[cyc[tot]]; j; j=j->nxt)\n                    if (deg[j->v]>1 && cyc[tot-1]!=j->v)\n                    {\n                        cyc[++tot]=j->v;\n                        break;\n                    }\n            --tot;\n            break;\n        }\n    repu(i,1,tot)\n        link[cyc[i]]=cyc[i+1];\n    int sum=calc();\n    repu(i,1,tot)\n        link[cyc[i+1]]=cyc[i];\n    (sum+=calc())%=p,ans=LL(ans)*sum%p;\n    return cntv;\n}\n\nint main()\n{\n    n=getint(),ans=1;\n    repu(i,1,n*2)\n    {\n        int u=getint(),v=getint()+n;\n        addedge(u,v,fst),addedge(v,u,fst);\n    }\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    repu(i,2,n*2)\n        inv[i]=LL(p-p/i)*inv[p%i]%p;\n    repu(i,2,n*2)\n        fac[i]=LL(fac[i-1])*i%p,inv[i]=LL(inv[i-1])*inv[i]%p;\n    int sum=0;\n    repu(i,1,n*2)\n        if (!flag[i])\n        {\n            int cnt=solve(i);\n            ans=LL(ans)*c(sum+=cnt,cnt)%p;\n        }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=200010,mod=1000000007;\nint N;\nlong long fac[MaxN],ifac[MaxN];\nlong long inv(int a,int p=mod){return a==1?1:(1+p*(a-inv(p%a,a)))/a%p;}\nstruct edge{int to;edge*next;}E[MaxN*2],*ne=E,*fir[MaxN];\nvoid link(int u,int v){*ne=(edge){v,fir[u]};fir[u]=ne++;}\nint Q[MaxN],deg[MaxN],S[MaxN],fa[MaxN],siz[MaxN],C[MaxN];\nbool vis[MaxN];\nint dfs(int i){\n\tsiz[i]=1;\n\tint s=1;\n\tfor(edge*e=fir[i];e;e=e->next)\n\t\tif(fa[e->to]==i&&e->to<fa[i])s=1ll*s*dfs(e->to)%mod,siz[i]+=siz[e->to];\n\treturn 1ll*s*ifac[siz[i]]%mod*fac[siz[i]-1]%mod;\n}\nint solve(int v){\n\tint*h=Q,*t=Q+1,es=0;\n\tvis[*Q=v]=1;\n\tfor(;h<t;es+=deg[*h++])\n\t\tfor(edge*e=fir[*h];e;e=e->next,deg[*h]++)\n\t\t\tif(!vis[e->to])vis[*t++=e->to]=1;\n\tif(es!=(t-Q)*2)return 0;\n\tint*tp=S;\n\tfor(int*i=Q;i<t;i++)if(deg[*i]==1)*tp++=*i;\n\twhile(tp>S){\n\t\tint x=*--tp;\n\t\tfor(edge*e=fir[x];e;e=e->next)\n\t\t\tif(--deg[e->to])deg[fa[x]=e->to]==1?*tp++=e->to:1;\n\t}\n\tint len=0;\n\tfor(int*i=Q;i<t;i++)if(deg[*i]>1){\n\t\tfor(int j=*i;deg[j];){\n\t\t\tdeg[C[len++]=j]=0;\n\t\t\tfor(edge*e=fir[j];e;e=e->next)\n\t\t\t\tif(deg[e->to]>1){j=e->to;break;}\n\t\t}\n\t\tbreak;\n\t}\n\tint sum=0;\n\tfor(int dir=0;dir<2;dir++){\n\t\tint s=1;\n\t\tfor(int i=0;i<len;i++)fa[C[i]]=C[(dir?i+len-1:i+1)%len];\n\t\tfor(int*i=Q;i<t;i++)if(*i>fa[fa[*i]])s=1ll*s*dfs(*i)%mod;\n\t\t(sum+=s)%=mod;\n\t}\n\treturn sum;\n}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=*fac=1;i<=N*2;i++)fac[i]=fac[i-1]*i%mod;\n\tifac[N*2]=inv(fac[N*2]);\n\tfor(int i=N*2;i;i--)ifac[i-1]=ifac[i]*i%mod;\n\tfor(int i=0,x,y;i<N*2;i++)scanf(\"%d%d\",&x,&y),link(x,y+=N),link(y,x);\n\tint s=fac[N*2];\n\tfor(int i=1;i<=N*2;i++)if(!vis[i])s=1ll*s*solve(i)%mod;\n\tprintf(\"%d\\n\",s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define LL long long\n#define go(G, x, i, v) \\\n  for (int i = G.hd[x], v = G.to[i]; i; v = G.to[i = G.nx[i]])\n#define inline __inline__ __attribute__((always_inline))\ninline LL read() {\n  LL x = 0, w = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x * w;\n}\nconst int Max_n = 4e5 + 5;\nconst int mod = 1e9 + 7;\nint n;\nbool vis[Max_n], u[Max_n], fl, in_cir[Max_n], bk[Max_n];\nint top, up[Max_n], par[Max_n], size[Max_n];\nint cntn, node[Max_n];\npair<int, int> stk[Max_n];\nvector<pair<int, int> > cir;\nint fac[2 * Max_n], ifac[2 * Max_n];\nstruct graph {\n  int hd[Max_n];\n  int cntr, nx[Max_n << 2], to[Max_n << 2], w[Max_n << 2];\n  void addr(int u, int v, int W) {\n    cntr++;\n    nx[cntr] = hd[u], to[cntr] = v, w[cntr] = W;\n    hd[u] = cntr;\n  }\n} G;\ninline int ksm(int a, int b) {\n  int res = 1;\n  for (; b; b >>= 1, a = 1ll * a * a % mod)\n    if (b & 1) res = 1ll * res * a % mod;\n  return res;\n}\ninline int C(int n, int m) {\n  if (n < m || m < 0) return 0;\n  return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\ninline int merge(int a, int b) { return C(a + b, a); }\ninline void Push(pair<int, int> x) { in_cir[x.first] = 1, cir.push_back(x); }\nvoid dfs_cir(int x, int fa, int up) {\n  stk[++top] = make_pair(x, up), u[x] = 1;\n  go(G, x, i, v) if (v != fa) {\n    if (fl) return;\n    if (!u[v]) {\n      dfs_cir(v, x, G.w[i]);\n    } else {\n      while (stk[top].first != v) Push(stk[top--]);\n      Push(stk[top--]), cir.back().second = G.w[i], fl = 1;\n      return;\n    }\n  }\n  u[x] = 0; top--;\n}\nvoid dfs(int x, int fa) {\n  vis[x] = 1, node[++cntn] = x;\n  go(G, x, i, v) if (v != fa and !in_cir[v]) up[v] = G.w[i], dfs(v, x);\n}\nint Count(int x) {\n  int ans = 1;\n  size[x] = 0;\n  go(G, x, i, v) if (par[v] == x) {\n    int res = Count(v);\n    ans = 1ll * ans * res % mod * merge(size[x], size[v]) % mod;\n    size[x] += size[v];\n  }\n  size[x]++;\n  return ans;\n}\nint work() {\n  for (int i = 1, x = node[i]; i <= cntn; x = node[++i])\n    size[x] = 0, par[x] = 0;\n  for (int i = 1, x = node[i]; i <= cntn; x = node[++i])\n    go(G, x, i, v) if (G.w[i] < up[x]) par[v] = x;\n  int tot = 0, ans = 1;\n  for (int i = 1, x = node[i]; i <= cntn; x = node[++i])\n    if (!par[x]) {\n      int res = Count(x);\n      ans = 1ll * ans * res % mod * merge(tot, size[x]) % mod;\n      tot += size[x];\n    }\n  return ans;\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= (n << 1); i++) {\n    int x = read(), y = read();\n    G.addr(x, y + n, x + y), G.addr(y + n, x, x + y);\n    bk[x] = bk[y + n] = 1;\n  }\n  n <<= 1, fac[0] = ifac[0] = 1;\n  for (int i = 1; i < Max_n; i++) fac[i] = 1ll * fac[i - 1] * i % mod;\n  ifac[Max_n - 1] = ksm(fac[Max_n - 1], mod - 2);\n  for (int i = Max_n - 1; i; i--) ifac[i - 1] = 1ll * ifac[i] * i % mod;\n  int tot = 0;\n  for (int i = 1; i <= n; i++) tot += bk[i];\n  if (tot != n) {\n    puts(\"0\");\n    return 0;\n  }\n  int size = 0, ans = 1;\n  for (int i = 1; i <= n && ans; i++) {\n    if (!vis[i]) {\n      int res = top = fl = cntn = 0;\n      cir.clear(), dfs_cir(i, 0, 0);\n      for (int j = 0; j < cir.size(); ++j) dfs(cir[j].first, 0);\n      for (int j = 0; j < cir.size(); ++j) up[cir[j].first] = cir[j].second;\n      (res += work()) %= mod, cir.push_back(cir[0]);\n      for (int j = 1; j < cir.size(); ++j) up[cir[j].first] = cir[j - 1].second;\n      (res += work()) %= mod;\n      ans = 1ll * ans * res % mod * merge(size, cntn) % mod;\n      size += cntn;\n    }\n  }\n  //ans = 1ll * ans * ksm(fac[n], mod - 2) % mod;\n  cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nint vis[202020];\nll ret=1;\nll mo=1000000007;\nll rev[202020];\n\nvector<int> P,LP;\nset<int> Vs,IL;\nset<pair<int,int>> Es;\nmap<pair<int,int>,int> O;\n\nvoid dfs(int cur) {\n\tint i;\n\tif(Vs.count(cur)) {\n\t\tif(LP.size()) return;\n\t\tint add=0;\n\t\tFOR(i,P.size()) {\n\t\t\tif(P[i]==cur) add=1;\n\t\t\tif(add) {\n\t\t\t\tLP.push_back(P[i]);\n\t\t\t\tIL.insert(P[i]);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvis[cur]=1;\n\tVs.insert(cur);\n\tP.push_back(cur);\n\tFORR(e,E[cur]) if(Es.count({min(e,cur),max(e,cur)})==0) {\n\t\tEs.insert({min(e,cur),max(e,cur)});\n\t\tdfs(e);\n\t}\n\tP.pop_back();\n\t\n}\n\nvoid dfs2(int cur,int pre) {\n\tO[{cur,pre}]=O[{pre,cur}]=cur;\n\tFORR(e,E[cur]) if(e!=pre) dfs2(e,cur);\n}\n\nll hoge(int cur) {\n\tLP.clear();\n\tIL.clear();\n\tP.clear();\n\tVs.clear();\n\tEs.clear();\n\t\n\tdfs(cur);\n\tif(Vs.size()!=Es.size()) return 0;\n\tLP.push_back(LP[0]);\n\t\n\tll r[2]={1,1};\n\tint i,x;\n\tFOR(i,2) {\n\t\tO.clear();\n\t\t\n\t\tFORR(v,LP) FORR(e,E[v]) if(IL.count(e)==0) dfs2(e,v);\n\t\tFOR(x,LP.size()-1) O[{LP[x],LP[x+1]}]=O[{LP[x+1],LP[x]}]=LP[x+i];\n\t\tmap<pair<int,int>,int> cost;\n\t\tFORR(p,Es) {\n\t\t\tcost[p]++;\n\t\t\tint take=O[p];\n\t\t\tint oth=p.first+p.second-take;\n\t\t\tFORR(v,E[take]) {\n\t\t\t\tif(v<oth) cost[p]+=cost[{v,take}];\n\t\t\t\tif(v>=oth) break;\n\t\t\t}\n\t\t\t(r[i]*=rev[cost[p]])%=mo;\n\t\t\tcost[{p.second,p.first}]=cost[p];\n\t\t}\n\t\t\n\t}\n\treturn (r[0]+r[1])%mo;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\trev[1]=1;\n\tfor(i=2;i<=201000;i++) rev[i] = rev[mo%i]*(mo-mo/i)%mo;\n\t\n\tcin>>N;\n\tFOR(i,2*N) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1+N);\n\t\tE[y-1+N].push_back(x-1);\n\t}\n\tFOR(i,2*N) sort(ALL(E[i]));\n\t\n\tFOR(i,2*N) {\n\t\tif(E[i].size() && vis[i]==0) (ret*=hoge(i))%=mo;\n\t\tret=ret*(1+i)%mo;\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3e5 + 5;\nconst LL mod = 1e9 + 7;\n\ntemplate <typename T> inline void Read(T &x) {\n  char ch; x = 0;\n  while (!isdigit(ch = getchar()));\n  do {x = (x << 1) + (x << 3) + ch - '0';} while (isdigit(ch = getchar()));\n}\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], point[N], top, tp;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  //cerr << x << \" -> \" << y << endl;\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      point[++ tp] = e[i].id;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      point[++ tp] = e[i].id;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= top; i ++)\n    Fir[vertex[i]] = deg[vertex[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = tp, i; u; u --) {\n    i = point[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = tp, i = point[u]; u; u --, i = point[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  return res;\n}\n\nint main() {\n  pre();\n  Read(n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    Read(x[i]); Read(y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      rt = top = 0;\n      dfs(k);\n      if (!rt) return !puts(\"0\");\n      tp = 0;\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      int g = tp;\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      tp = g;\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      ans = ans * tmp % mod * C(p, top) % mod;\n      p -= top;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int MOD=1e9+7;\ninline int mul(int a,int b)\n{return 1LL*a*b%MOD;}\ninline void Mul(int &a,int b)\n{a=1LL*a*b%MOD;}\ninline int add(int a,int b)\n{a+=b;return a>=MOD?a-MOD:a;}\nint ksm(int a,int b)\n{\n    int ans=1;\n    for(;b;b>>=1,Mul(a,a))\n        if(b&1)Mul(ans,a);\n    return ans;\n}\nint Fac(int n)\n{\n    int tmp=1;\n    for(int i=1;i<=n;i++)\n        Mul(tmp,i);\n    return tmp;\n}\nconst int Q=1<<19;\n#define Link(opsha,xx,yy) opsha[xx].push_back(yy)\nvector<int> lk[Q],ps[Q];\nint n,pi=1;\nint go_to[Q];\nint lst[Q];\nint tp,st[Q];\nint ir[Q];\nint cn,cm;\nvoid dfs1(int x)\n{\n    ++cn;\n    go_to[x]=1;\n    for(int y:lk[x]){\n        ++cm;\n        if(go_to[y]){\n            if(y==lst[x]||tp)continue;\n            for(int t=x;;t=lst[t]){\n                st[++tp]=t;\n                ir[t]=1; \n                if(t==y)break;\n            }\n            continue;\n        }\n        lst[y]=x;\n        dfs1(y);\n    }\n}\nint fa[Q];\nint apr[Q],maxn;\nvoid dfs2(int x)\n{\n    apr[++maxn]=x;\n    for(int y:lk[x]){\n        if(y==fa[x]||ir[y])continue;\n        fa[y]=x;\n        dfs2(y);\n    }\n}\nint Time=0;\nint vis[Q],si[Q];\nint cnt;\nvoid dfs3(int x)\n{\n\tif(vis[x]==Time)return;\n\tvis[x]=Time;\n\tsi[x]=1;\n\tfor(int y: ps[x])\n\t\tdfs3(y),si[x]+=si[y];\n\tMul(cnt,si[x]);\n}\nint Calc()\n{\n\tcnt=1;\n\t++Time;\n\tfor(int i=1;i<=maxn;i++){\n\t\tint x=apr[i],y=fa[x];\n\t\tif(x<fa[y])Link(ps,y,x);\n\t}\n\tfor(int i=1;i<=maxn;i++)\n\t\tif(vis[apr[i]]!=Time)\n\t\t\tdfs3(apr[i]);\n\treturn cnt;\n}\nvoid Deal(int stat)\n{\n\t\n    cn=cm=0;\n    tp=0;\n    dfs1(stat);\n    if((cn<<1)!=cm)\n    {puts(\"0\");exit(0);}\n    maxn=0;\n    for(int i=1;i<=tp;i++)\n        dfs2(st[i]);\n    st[tp+1]=st[1];\n    for(int i=1;i<=tp;i++)\n    \tfa[st[i]]=st[i+1];\n    int rem=Calc();\n    for(int i=1;i<=maxn;i++)\n    \tps[apr[i]].clear();\n    st[0]=st[tp];\n    for(int i=1;i<=tp;i++)\n    \tfa[st[i]]=st[i-1];\n    Mul(pi,add(ksm(rem,MOD-2),ksm(Calc(),MOD-2)));\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    n<<=1;\n    for(int i=1,x,y;i<=n;i++)\n        scanf(\"%d%d\",&x,&y),y+=(n>>1),Link(lk,x,y),Link(lk,y,x);\n    for(int i=1;i<=n;i++)\n        if(!go_to[i])\n            Deal(i);\n    printf(\"%d\",mul(Fac(n),pi));\n    return 0;\n}\n/*\n2\n1 1\n1 2\n2 1\n2 2\n\n\n\n\n\n\n\n4\n1 1\n2 2\n3 3\n4 4\n1 2\n2 1\n3 4\n4 3\n\n\n3\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \n\nusing namespace std;\n\nnamespace Tzh{\n\t\n\ttypedef long long ll;\n\tconst int maxn=200010;\n\tconst ll p=1e9+7;\n\tint st[maxn],top,all,vis[maxn],head[maxn],cnt=1,n,fa[maxn],eid[maxn],flag,size[maxn],point[maxn],num;\n\tll fac[maxn],ans; int val[maxn];\n\n\tll qpow(ll a,ll b){ ll sum=1;\n\t\twhile(b){\n\t\t\tif(b&1) sum=sum*a%p;\n\t\t\ta=a*a%p; b>>=1;\n\t\t}\t\n\t\treturn sum;\n\t}\n\n\tstruct ed{\n\t\tint next,to,w,vis;\n\t}e[maxn<<1];\n\n\tvoid add(int u,int v,int w){\n\t\te[++cnt]=(ed){head[u],v,w,0}; head[u]=cnt;\n\t\te[++cnt]=(ed){head[v],u,w,0}; head[v]=cnt;\n\t}\n\n\tvoid dfs(int now,int f){ vis[now]=1; all++;\n\t\tfor(int i=head[now];i;i=e[i].next){\n\t\t\tint tt=e[i].to; if(tt==f) continue;\n\t\t\tst[++top]=i; if(vis[tt]){\n\t\t\t\tif(flag) {top--; continue;}\n\t\t\t\tint tmp=top; int mx=0,pos=0;\n\t\t\t\twhile(e[st[tmp]^1].to!=e[i].to) tmp--;\n\t\t\t\tfor(int i=tmp;i<=top;i++) \n\t\t\t\t\tif(e[st[i]].w>mx) mx=e[st[i]].w,pos=st[i];\t\n\t\t\t\tflag=pos; top--; continue;\n\t\t\t} dfs(tt,now); top--; \n\t\t}\n\t}\n\n\tvoid dfs2(int now,int f){ fa[now]=f; \n\t\tfor(int i=head[now];i;i=e[i].next){\n\t\t\tint tt=e[i].to; if(tt==f||e[i].vis) continue;\n\t\t\tpoint[++num]=tt; eid[num]=i; dfs2(tt,now);\n\t\t}\n\t}\n\n\tvoid dfs3(int now,int f){ size[now]=1;\n\t\tfor(int i=head[now];i;i=e[i].next){\n\t\t\tint tt=e[i].to; if(tt==f||e[i].vis) continue;\n\t\t\tdfs3(tt,now); size[now]+=size[tt];\n\t\t}\n\t\tans=ans*size[now]%p;\n\t}\n\n\tll suan(int now){\n\t\tans=1; dfs3(now,0); ans=fac[size[now]]*qpow(ans,p-2)%p;\n\t\treturn ans;\n\t}\n\n\tll cal(int now,int f){\n\t\tnum=0; dfs2(now,0); static int st[maxn],top; top=0;\n\t\tstatic ll g[maxn],sz[maxn]; st[++top]=now; fa[now]=f;\n\t\tfor(int i=1;i<=num;i++){int cur=point[i];\n\t\t\tif(fa[fa[cur]]&&fa[fa[cur]]<cur) \n\t\t\t   e[eid[i]].vis=e[eid[i]^1].vis=1,st[++top]=cur;\n\t\t} ll sum=0;\n\t\tfor(int i=1;i<=top;i++) g[i]=suan(st[i]),sz[i]=size[st[i]];\n\t\tfor(int i=1;i<=top;i++) sum=sum+sz[i]; sum=fac[sum];\n\t\tfor(int i=1;i<=top;i++) sum=sum*qpow(fac[sz[i]],p-2)%p;\n\t\tfor(int i=1;i<=top;i++) sum=sum*g[i]%p;\n\t\tfor(int i=1;i<=num;i++) e[eid[i]].vis=e[eid[i]^1].vis=0;\n\t\treturn sum;\n\t}\n\n\tint ffa(int x){return fa[x]==x?x:fa[x]=ffa(fa[x]);}\n\n\tvoid work(){\n\t\tscanf(\"%lld\",&n); n*=2; fac[0]=1;\n\t\tfor(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%p;\n\t\tstatic int sz[maxn],tot; static ll F[maxn]; int x,y;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,val[i]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lld%lld\",&x,&y),add(x,y+(n>>1),x+y);\n\t\t\tint a=x,b=y+(n>>1); \n\t\t\tif(ffa(a)==ffa(b)) val[ffa(a)]--;\n\t\t\telse val[ffa(b)]+=val[ffa(a)]-1,fa[ffa(a)]=ffa(b);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) if(val[ffa(i)]!=0) {puts(\"0\"); return ;}\n\t\tmemset(fa,0,sizeof(fa));\n\t\tfor(int i=1;i<=n;i++) if(!vis[i]){\n\t\t\tflag=0; all=0; dfs(i,0); \n\t\t\tif(!flag) {puts(\"0\"); return ;}\n\t\t\te[flag].vis=e[flag^1].vis=1; \n\t\t\tF[++tot]=(cal(e[flag^1].to,e[flag].to)+cal(e[flag].to,e[flag^1].to))%p;\n\t\t\tsz[tot]=all; \n\t\t} ll sum=0;\n\t\tfor(int i=1;i<=tot;i++) sum+=sz[i]; sum=fac[sum];\n\t\tfor(int i=1;i<=tot;i++) sum=sum*qpow(fac[sz[i]],p-2)%p;\n\t\tfor(int i=1;i<=tot;i++) sum=sum*F[i]%p;\n\t\tprintf(\"%lld\",sum);\n\t\treturn ;\n\t}\n}\n\nsigned main(){\n\tTzh::work();\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nbool dfsc(int v, int p, const vector<vector<int>>& G, vector<int>& vis, vector<int>& cyc, bool& done){\n\tif(vis[v]==1){\n\t\tcyc.pb(v);\n\t\treturn 1;\n\t}\n\tif(vis[v]==2) return 0;\n\n\tvis[v] = 1;\n\tfor(int u:G[v]) if(u != p){\n\t\tif(dfsc(u,v,G,vis,cyc,done)){\n\t\t\tif(v==cyc[0]) done=1;\n\t\t\tif(!done) cyc.pb(v);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tvis[v] = 2;\n\treturn 0;\n}\n\nvector<int> getcycle(const vector<vector<int>>& G, V<int>& vis, int r){\n\tint N = G.size();\n\tbool done = 0;\n\tvector<int> cyc;\n\tassert(dfsc(r,-1,G,vis,cyc,done));\n\treturn cyc;\n}\nstruct UnionFind{\n\tvector<int> par,rank;\n\tUnionFind(int N){\n\t\tpar.assign(N,0);\n\t\trank.assign(N,0);\n\t\trep(i,N) par[i]=i;\n\t}\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]) swap(x,y);\n\n\t\t//x becomes root\n\t\tpar[y]=x;\n\t\tif(rank[x]==rank[y]) rank[x]++;\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tInitFact(500000);\n\n\tint N; cin >> N;\n\tVV<int> G(N+N);\n\tUnionFind UF(N+N);\n\trep(i,N+N){\n\t\tint x,y; cin >> x >> y; x--,y--;\n\t\tG[x].pb(y+N);\n\t\tG[y+N].pb(x);\n\t\tUF.unite(x,y+N);\n\t}\n\tVV<int> r2vs(N+N);\n\trep(i,N+N) r2vs[UF.find(i)].pb(i);\n\tV<int> vis(N+N);\n\tV<bool> incycle(N+N);\n\tmint ans = 1;\n\tint sn = 0;\n\trep(r,N+N) if(r2vs[r].size()){\n\t\tauto vs = r2vs[r];\n\t\tint n = si(vs), m = 0;\n\t\tfor(int v: vs){\n\t\t\tfor(int u: G[v]) if(v<u) m++;\n\t\t}\n\t\tif(n != m){\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans *= Choose(sn+n,n);\n\t\tsn += n;\n\t\tauto c = getcycle(G,vis,r);\n\t\tint K = si(c);\n\t\tfor(int v: c) incycle[v] = true;\n\t\tmint f = 0;\n\t\trep(dir,2){\n\t\t\tmap<int,int> to;\n\t\t\trep(i,K) to[c[i]] = c[(i+1)%K];\n\t\t\tfunction<void(int,int)> dfs = [&](int v,int p){\n\t\t\t\tfor(int u: G[v]) if(u != p && !incycle[u]){\n\t\t\t\t\tto[u] = v;\n\t\t\t\t\tdfs(u,v);\n\t\t\t\t}\n\t\t\t};\n\t\t\trep(i,K) dfs(c[i],-1);\n\t\t\tdump(to);\n\t\t\tmap<int,V<int>> T;\n\t\t\tmap<int,int> sz;\n\t\t\tfor(int a: vs){\n\t\t\t\tint b = to[a], c = to[b];\n\t\t\t\tif(a < c){\n\t\t\t\t\tT[b].pb(a);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap<int,bool> done;\n\t\t\tmap<int,bool> notroot;\n\t\t\tmint tmp = 1;\n\t\t\tfunction<void(int)> dfssz = [&](int v){\n\t\t\t\tif(done[v]) return;\n\t\t\t\tdone[v] = true;\n\t\t\t\tsz[v] = 0;\n\t\t\t\tfor(int u: T[v]){\n\t\t\t\t\tnotroot[u] = true;\n\t\t\t\t\tdfssz(u);\n\t\t\t\t\ttmp *= Choose(sz[v]+sz[u],sz[u]);\n\t\t\t\t\tsz[v] += sz[u];\n\t\t\t\t}\n\t\t\t\tsz[v]++;\n\t\t\t};\n\t\t\tfor(int v: vs){\n\t\t\t\tdfssz(v);\n\t\t\t}\n\t\t\tdump(c);\n\t\t\tdump(T);\n\t\t\tdump(sz);\n\t\t\tdump(done);\n\t\t\tdump(notroot);\n\t\t\tint s = 0;\n\t\t\tfor(int v: vs) if(!notroot[v]){\n\t\t\t\ttmp *= Choose(s+sz[v],sz[v]);\n\t\t\t\ts += sz[v];\n\t\t\t}\n\t\t\tshow(s);\n\t\t\tf += tmp;\n\t\t\treverse(all(c));\n\t\t}\n\t\tans *= f;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\n#define ll long long\n#define maxn 200005\n#define mo 1000000007\ninline ll read()\n{\n\tll x=0,w=0;char ch=getchar();\n\twhile(!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn w?-x:x;\n}\nvector<int>A[maxn];\nvector<int>G[maxn];\nint n,tot;\nint jc[maxn],ans[maxn],inst[maxn];\nint vis[maxn],vis1[maxn],fa[maxn],huan[maxn],size[maxn];\nint headd[maxn],nextt[maxn<<1],to[maxn<<1],cntt;\ninline int ksm(int x,int y)\n{\n    int a=1;\n    while(y)\n    {\n        if(y&1)a=1ll*a*x%mo;\n        x=1ll*x*x%mo;y>>=1;\n    }return a;\n}\ninline void add(int u,int v)\n{nextt[++cntt]=headd[u];headd[u]=cntt;to[cntt]=v;}\ninline void dfs(int u,int f)\n{\n    vis[u]=tot;A[tot].push_back(u);fa[u]=f;inst[u]=1;\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(vis[to[i]]){if(inst[to[i]])huan[fa[to[i]]]=-1,huan[u]++;}\n        else dfs(to[i],u),huan[u]+=huan[to[i]];\n    }inst[u]=0;\n}\ninline void dfs1(int u,int f)\n{\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(huan[to[i]]==1)continue;\n        fa[to[i]]=u;dfs1(to[i],u);\n    }\n}\ninline void dfs2(int u)\n{\n    reg int i,sz=G[u].size();\n    size[u]=1;vis1[u]=1;\n    for(i=0;i<sz;++i)\n    {\n        if(!vis1[G[u][i]])dfs2(G[u][i]);\n        size[u]+=size[G[u][i]];\n    }\n}\ninline void solve1()\n{\n    reg int i,j,u,sz=A[tot].size();\n    for(j=0;j<sz;++j)\n    {\n        u=A[tot][j];G[u].clear();\n        for(i=headd[u];i;i=nextt[i])\n        {\n            if(fa[to[i]]!=u)continue;\n            if(to[i]<fa[u])G[u].push_back(to[i]);\n        }\n    }\n    for(i=0;i<sz;++i)\n        if(!vis1[A[tot][i]])\n            dfs2(A[tot][i]);\n    for(i=0;i<sz;++i)vis1[A[tot][i]]=0;\n    reg int tmp=1;\n    for(i=0;i<sz;++i)tmp=1ll*tmp*size[A[tot][i]]%mo;\n    ans[tot]+=1ll*jc[sz]*ksm(tmp,mo-2)%mo;if(ans[tot]>=mo)ans[tot]-=mo;\n}\ninline void solve()\n{\n    reg int i,sz=A[tot].size(),fi,k;\n    if(sz==1)exit(0);\n    for(i=0;i<sz;++i)\n        if(huan[A[tot][i]]==1){fi=A[tot][i];break;}\n    k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[to[i]]!=k){fa[k]=to[i];k=to[i];break;}\n    }while(fi!=k);solve1();k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[k]!=to[i]){fa[to[i]]=k;k=to[i];break;}\n    }while(fi!=k);solve1();\n}\nint main()\n{\n    n=read();reg int i,x,y;jc[0]=1;\n    for(i=1;i<=2*n;++i)jc[i]=1ll*jc[i-1]*i%mo;\n    for(i=1;i<=2*n;++i)\n    {\n        x=read(),y=read();\n        add(x,n+y),add(n+y,x);\n    }\n    for(i=1;i<=n*2;++i)if(!vis[i])\n        ++tot,dfs(i,0),solve();\n    reg int sum=1,su=1;\n    for(i=1;i<=tot;++i)sum=1ll*sum*ans[i]%mo;\n    for(i=1;i<=tot;++i)su=1ll*su*jc[A[i].size()]%mo;\n    sum=1ll*sum*jc[2*n]%mo*ksm(su,mo-2)%mo;\n    printf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cassert>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 4e5 + 5;\nconst LL mod = 1e9 + 7;\n\ntemplate <typename T> inline void Read(T &x) {\n  char ch; x = 0;\n  while (!isdigit(ch = getchar()));\n  do {x = (x << 1) + (x << 3) + ch - '0';} while (isdigit(ch = getchar()));\n}\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], top;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  //cerr << x << \" -> \" << y << endl;\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n      break;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= top; i ++)\n    Fir[vertex[i]] = deg[vertex[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = top, i; u; u --) {\n    i = vertex[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  assert(!p);\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = top, i = vertex[u]; u; u --, i = vertex[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  assert(!tot);\n  return res;\n}\n\nint main() {\n  pre();\n  Read(n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    Read(x[i]); Read(y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      top = 0;\n      dfs(k);\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      if (ans >= mod) ans -= mod;\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      tmp = tmp * C(p, top) % mod;\n      ans = ans * tmp % mod;\n      p -= top;\n    }\n  assert(!p);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n// #include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 1e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = 0);\n\t\tif (!findcr) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\t// assert(SZ(cir) > 1);\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) ideg[u] = 0;\n\t\tfor (auto u : gt) {\n\t\t\tT[u].clear();\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tauto lim = UB(DT[u], in[u]); \n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v]) {\t// find it!\n\t\t\twhile (top && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tSCir(v, u);\n\t\tif (findcr) return;\n\t} if (S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    UnionFind(int);\n    int find(int);\n    void unite(int, int);\nprivate:\n    vector<int> table;\n};\n\nUnionFind::UnionFind(int size) {\n    table.resize(size);\n    fill(table.begin(), table.end(), -1);\n}\n\nint UnionFind::find(int x) {\n    while (0 <= table[x])\n        x = table[x];\n    return x;\n}\n\nvoid UnionFind::unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry) {\n        int dx = -table[rx];\n        int dy = -table[ry];\n        if (dx != dy) {\n            if (dx < dy) {\n                table[rx] = ry;\n            } else {\n                table[ry] = rx;\n            }\n        } else {\n            table[rx] -= 1;\n            table[ry] = rx;\n        }\n    }\n}\n\n\nconst long M = 1e9 + 7;\nint N;\nlong F[202020];\nint groups[202020];\nint pair_table[202020];\nint counts[202020];\nlong perms[202020];\nvector< vector<int> > edges;\nvector<bool> is_root;\n\n\nlong powmod(long a, long x, long m) {\n    long r = 1;\n    while (0 < x) {\n        if (x & 1) {\n            r *= a;\n            r %= m;\n        }\n        x >>= 1;\n        a *= a;\n        a %= m;\n    }\n    return r;\n}\n\n\nvoid calc_node(int node, const vector< vector<int> > &tree) {\n    if (tree[node].size() == 0) {\n        counts[node] = 1;\n        perms[node] = 1;\n    } else {\n        int c;\n        \n        c = 0;\n        for (int child : tree[node]) {\n            calc_node(child, tree);\n            c += counts[child];\n        }\n        counts[node] = c + 1;\n\n        long p;\n\n        p = F[c];\n        for (int child : tree[node]) {\n            p *= powmod(F[counts[child]], M - 2, M);\n            p %= M;\n            p *= perms[child];\n            p %= M;\n        }\n        perms[node] = p;\n    }\n}\n\nlong calc(const vector<int> &nodes) {\n    vector< vector<int> > tree;\n    int nv, nnv;\n    int c;\n    long p;\n\n    fill(is_root.begin(), is_root.end(), true);\n    tree.resize(2 * N);\n\n    for (int v : nodes) {\n        nv = pair_table[v];\n        nnv = pair_table[nv];\n        if (v < nnv) {\n            is_root[v] = false;\n            tree[nv].push_back(v);\n        }\n    }\n\n    c = 0;\n    for (int v : nodes) {\n        if (is_root[v]) {\n            calc_node(v, tree);\n            c += counts[v];\n        }\n    }\n\n    p = F[c];\n    for (int v : nodes) {\n        if (is_root[v]) {\n            p *= powmod(F[counts[v]], M - 2, M);\n            p %= M;\n            p *= perms[v];\n            p %= M;\n        }\n    }\n\n    return p;\n}\n\n\n\nlong solve(const vector<int> &nodes) {\n    int pv, nv;\n\n    for (int v : nodes) {\n        if (edges[v].size() == 1) {\n            nv = edges[v].back();\n            edges[v].pop_back();\n            pair_table[v] = nv;\n            edges[nv].erase(find(edges[nv].begin(), edges[nv].end(), v));\n            pv = v; v = nv;\n            while (edges[v].size() == 1) {\n                nv = edges[v].back();\n                edges[v].pop_back();\n                pair_table[v] = nv;\n                edges[nv].erase(find(edges[nv].begin(), edges[nv].end(), v));\n                pv = v; v = nv;\n            }\n        }\n    }\n\n    int v0 = 0;\n    int v1, v2;\n    for (int v : nodes) {\n        if (edges[v].size() != 0) {\n            v0 = v;\n            break;\n        }\n    }\n    v1 = edges[v0][0];\n    v2 = edges[v0][1];\n\n    long r = 0;\n    int v;\n    int nv0, nv1, nv2;\n    rep(d, 0, 2) {\n        nv0 = (d == 0) ? v1 : v2;\n        nv = nv0; v = v0;\n        pair_table[v] = nv;\n        pv = v; v = nv;\n        while (v != v0) {\n            nv1 = edges[v][0];\n            nv2 = edges[v][1];\n            nv = (nv1 != pv) ? nv1 : nv2;\n            pair_table[v] = nv;\n            pv = v; v = nv;\n        }\n        r += calc(nodes);\n        r %= M;\n    }\n\n    return r;\n}\n\n\nint main(int argc, const char * argv[]) {\n    vector< tuple<int, int> > balls;\n    int x, y;\n\n    cin >> N;\n    rep(i, 0, 2 * N) {\n        cin >> x >> y;\n        balls.push_back(make_tuple(x - 1, N + y - 1));\n    }\n\n    {\n        long p = 1;\n        rep(i, 1, 2 * N + 1) {\n            p *= i;\n            p %= M;\n            F[i] = p;\n        }\n    }\n\n    UnionFind uf(2 * N);\n    edges.resize(2 * N);\n    is_root.resize(2 * N);\n\n    for (tuple<int, int> t : balls) {\n        int x = get<0>(t);\n        int y = get<1>(t);\n        uf.unite(x, y);\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n\n    long ans = F[2 * N];\n    vector<int> nodes;\n    unsigned long num_nodes, num_edges;\n\n    \n    rep(i, 0, 2 * N) {\n        if (edges[i].empty()) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n\n    rep(i, 0, 2 * N) groups[i] = uf.find(i);\n    \n    rep(i, 0, 2 * N) {\n        if (groups[i] == i) {\n            nodes.clear();\n            rep(v, 0, 2 * N) {\n                if (groups[v] == i) {\n                    nodes.push_back(v);\n                }\n            }\n            num_nodes = nodes.size();\n            num_edges = 0;\n            for (int v : nodes) {\n                num_edges += edges[v].size();\n            }\n            num_edges /= 2;\n            if (num_nodes != num_edges) {\n                cout << 0 << endl;\n                return 0;\n            }\n            ans *= powmod(F[num_nodes], M - 2, M);\n            ans %= M;\n            ans *= solve(nodes);\n            ans %= M;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nconst int N = 5 * 100000 + 100;\nconst int MOD = 1000000007;\nconst int oo = 1e9;\n\nint n , x , y, take[N], in[N], sz[N];\nbool inStack[N], vis[N];\nll fact[N], inv[N];\n\nvector<int> g[N], tree[N], cycle, my;\nstack<int> st;\n\nvoid findCycle(int u , int p) {\n\tif (inStack[u]) {\n\t\twhile (1) {\n\t\t\tcycle.pb(st.top());\n\t\t\tst.pop();\n\t\t\tif (cycle.back() == u)break;\n\t\t}\n\t\tfor (int i = 0; i < cycle.size(); ++i) st.push(cycle[i]);\n\t\treturn;\n\t}\n\tif (vis[u])return;\n\tmy.pb(u);\n\ttake[u] = p;\n\tvis[u] = 1;\n\tinStack[u] = 1;\n\tst.push(u);\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tfindCycle(v, u);\n\t}\n\tinStack[u] = 0;\n\tst.pop();\n}\nbool getType(int idx) {\n\treturn idx > n;\n}\nll fast(ll a , ll b) {\n\tif (!b)return 1ll;\n\tll res = fast(a, b / 2);\n\tres = (res * res) % MOD;\n\tif (b & 1)\n\t\treturn (res * a) % MOD;\n\treturn res;\n}\nll nCk(ll n , ll k) {\n\treturn ((fact[n] * inv[n - k]) % MOD * inv[k]) % MOD;\n}\nll calc(int u) {\n\tsz[u] = 0;\n\tll ans = 1;\n\tfor (int i = 0; i < tree[u].size(); ++i) {\n\t\tint v = tree[u][i];\n\t\tll ff = calc(v);\n\t\tans = ((ans * ff ) % MOD * nCk(sz[u] + sz[v], sz[v]));\n\t\tsz[u] += sz[v];\n\t}\n\tsz[u]++;\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tg[x + n].pb(y);\n\t\tg[y].pb(x + n);\n\t}\n\tfact[0] = 1;\n\tinv[0] = fast(fact[0], MOD - 2);\n\tfor (int i = 1 ; i <= 2 * n ; ++i) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv[i] = fast(fact[i], MOD - 2);\n\t}\n\tll ans = 1;\n\tint len = 0;\n\tfor (int node = 1 ; node <= 2 * n ; ++node) {\n\t\tif (vis[node])continue;\n\t\tcycle.clear();\n\t\tmy.clear();\n\t\tfindCycle(node, -1);\n\t\tfor (int i = 0; i < my.size(); ++i){\n\t\t\tinStack[my[i]]=vis[my[i]]=0;\n\t\t}\n\t\tif(cycle.size()){\n\t\t\tint root = cycle[0];\n\t\t\tcycle.clear();\n\t\t\tmy.clear();\n\t\t\tfindCycle(root,-1);\n\t\t}\n\t\tint E = 0;\n\t\tfor (int i = 0; i < my.size(); ++i){\n\t\t\tE += g[my[i]].size();\n\t\t}\n\t\tif(E != 2*my.size()){\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tll res = 0;\n\t\tfor (int it = 0; it < 2 ; ++it) {\n\t\t\tfor (int i = 0 ; i < my.size(); ++i){\n\t\t\t\tin[my[i]] = 0;\n\t\t\t\ttree[my[i]].clear();\n\t\t\t}\n\t\t\ttree[0].clear();\n\t\t\tfor (int j = 0 ; j < cycle.size(); ++j) {\n\t\t\t\ttake[cycle[j]] = (it == 0 ? cycle[(j + 1) % cycle.size()] :  cycle[(j - 1 + cycle.size()) % cycle.size()]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size() ; ++i) {\n\t\t\t\tint f = my[i];\n\t\t\t\tfor (int j = 0 ; j < g[f].size(); ++j) {\n\t\t\t\t\tint v = g[f][j];\n\t\t\t\t\tif (getType(take[f]) == getType(v) && v < take[f]) {\n\t\t\t\t\t\ttree[f].pb(v);\n\t\t\t\t\t\tin[v]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size(); ++i) {\n\t\t\t\tif (!in[my[i]]) {\n\t\t\t\t\ttree[0].push_back(my[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = (res + calc(0)) % MOD;\n\t\t}\n\n\t\tans = (ans * res ) % MOD;\n\t\tans = (ans * nCk(len+my.size(),my.size()));\n\t\tlen += my.size();\n\t}\n\tprintf(\"%lld\\n\", ans );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <map>\n#include <windows.h>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define Travel(x, i) for (int i = Fir[x]; i; i = E[i].nxt)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e5 + 5;\nconst LL mod = 1e9 + 7;\n\nnamespace MathCal {\n  LL fac[N], inv[N];\n  inline LL C(int x, int y) {\n    if (x < y) return 0;\n    return fac[x] * inv[y] % mod * inv[x - y] % mod;\n  }\n  inline LL pow(LL x, LL exp) {\n    LL ret = 1;\n    for (; exp; exp >>= 1, x = x * x % mod)\n      if (exp & 1) ret = ret * x % mod;\n    return ret;\n  }\n  inline void pre() {\n    for (int i = fac[0] = 1; i < N; i ++) fac[i] = fac[i - 1] * i % mod;\n    inv[N - 1] = pow(fac[N - 1], mod - 2);\n    for (int i = N - 1; i >= 1; i --) inv[i - 1] = inv[i] * i % mod;\n  }\n}\nusing namespace MathCal;\n\nstruct edge {\n  int nxt, to, id;\n} e[N << 1];\nint fir[N], cnt = 0, lst[N], deg[N], size[N], rt;\n\nstruct Edge {\n  int nxt, to;\n} E[N << 1];\nint Fir[N], Cnt = 0;\n\nbool vis[N], cycle[N], found = 0;\nint n, x[N], y[N], con[N];\nmap <int, int> X[N], Y[N];\nint vertex[N], top;\n\ninline void add(int x, int y, int id) {\n  e[++ cnt] = (edge){fir[x], y, id};\n  fir[x] = cnt;\n}\n\ninline void Add(int x, int y) {\n  //cerr << x << \" -> \" << y << endl;\n  E[++ Cnt] = (Edge){Fir[x], y};\n  Fir[x] = Cnt;\n}\n\ninline void dfs(int x) {\n  vis[x] = 1;\n  vertex[++ top] = x;\n  travel(x, i) {\n    if (e[i].to == lst[x]) continue;\n    if (!found && vis[e[i].to]) {\n      found = 1;\n      rt = x;\n      for (int p = x; p != e[i].to; p = lst[p]) cycle[p] = 1;\n      cycle[e[i].to] = 1;\n      break;\n    }\n    else if (!vis[e[i].to]) {\n      lst[e[i].to] = x;\n      dfs(e[i].to);\n    }\n  }\n}\n\ninline void Assign(int x, int pa) {\n  travel(x, i)\n    if (!cycle[e[i].to] && e[i].to != pa) {\n      con[e[i].id] = e[i].to;\n      Assign(e[i].to, x);\n    }\n}\n\ninline void Assign_Cycle(int x, int pre, bool pattern) {\n  travel(x, i)\n    if (cycle[e[i].to] && pre != e[i].to) {\n      if (pattern) con[e[i].id] = x;\n      else con[e[i].id] = e[i].to;\n      if (x != rt || !pre) Assign_Cycle(e[i].to, x, pattern);\n      break;\n    }\n}\n\ninline void Build() {\n  for (int i = 1; i <= top; i ++)\n    Fir[vertex[i]] = deg[vertex[i]] = 0;\n  Cnt = 0;\n  map <int, int> :: iterator it;\n  for (int u = top, i; u; u --) {\n    i = vertex[u];\n    if (con[i] <= n) {\n      it = X[x[i]].find(y[i]);\n      while (it != X[x[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n    else {\n      it = Y[y[i]].find(x[i]);\n      while (it != Y[y[i]].begin()) {\n\tit --;\n\tdeg[it -> second] ++;\n\tAdd(i, it -> second);\n      }\n    }\n  }\n}\n\ninline void Get_Size(int x, int pa) {\n  size[x] = 1;\n  Travel(x, i) {\n    Get_Size(E[i].to, x);\n    size[x] += size[E[i].to];\n  }\n}\n\ninline LL Calc(int x, int pa) {\n  int p = size[x] - 1;\n  LL res = 1;\n  Travel(x, i) {\n    res = res * Calc(E[i].to, x) % mod * C(p, size[E[i].to]) % mod;\n    p -= size[E[i].to];\n  }\n  return res;\n}\n\ninline LL Solve() {\n  LL res = 1;\n  int tot = top;\n  Build();\n  for (int u = top, i = vertex[u]; u; u --, i = vertex[u])\n    if (!deg[i]) {\n      Get_Size(i, 0);\n      res = res * Calc(i, 0) % mod * C(tot, size[i]) % mod;\n      tot -= size[i];\n    }\n  return res;\n}\n\nint main() {\n  pre();\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= (n << 1); i ++) {\n    scanf(\"%d%d\", &x[i], &y[i]);\n    add(x[i], y[i] + n, i);\n    add(y[i] + n, x[i], i);\n    X[x[i]][y[i]] = i;\n    Y[y[i]][x[i]] = i;\n  }\n  for (int i = (n << 1); i; i --)\n    if (!fir[i]) return !puts(\"0\");\n  LL ans = 1, tmp;\n  int p = n << 1;\n  for (int k = 1; k <= (n << 1); k ++)\n    if (!vis[k]) {\n      found = 0;\n      top = 0;\n      dfs(k);\n      for (int i = top; i; i --)\n\tif (cycle[vertex[i]]) Assign(vertex[i], 0);\n      Assign_Cycle(rt, 0, 0);\n      tmp = Solve();\n      if (ans >= mod) ans -= mod;\n      Assign_Cycle(rt, 0, 1);\n      tmp += Solve();\n      if (tmp >= mod) tmp -= mod;\n      tmp = tmp * C(p, top) % mod;\n      ans = ans * tmp % mod;\n      p -= top;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define mod 1000000007\n#define ll long long\nnamespace mymyth{\n\tll f[nn],rf[nn];\n\tll qpow(ll x,ll y)\n\t{\n\t\tll res=1;\n\t\twhile(y)\n\t\t{\n\t\t\tif(y&1) res=res*x%mod;\n\t\t\ty=y/2;x=x*x%mod;\n\t\t}return res;\n\t}\n\tvoid ini()\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod,rf[i]=qpow(f[i],mod-2);\n\t}\n};\nusing namespace mymyth;\n#define pii pair<int,int> \n#define mp make_pair\nvector<int> v[nn];\nint n;pii dot[nn];\n#define err {puts(\"0\");exit(0);}\nvoid adde(int x,int y)\n{\n\tv[x].push_back(y);\n\tv[y].push_back(x);\n}\nint vis[nn];\nint siz[nn],esiz[nn];\nint pa[nn];vector<int> cir;\nvector<int> all;int dep[nn];\nvoid dfs(int x,int p)\n{\n\tsiz[x]=1;esiz[x]=0;vis[x]=1;\n\tall.push_back(x);\n\tpa[x]=p,dep[x]=dep[p]+1;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif(y==p) continue;//there cant be a multi-edge\n\t\tif(!vis[y])\n\t\t{\n\t\t\tdfs(y,x);\n\t\t\tsiz[x]+=siz[y];\n\t\t\tesiz[x]+=1+esiz[y];\n\t\t}\n\t\telse if(dep[y]<dep[x] and cir.size()==0)\n\t\t{\n\t\t\tesiz[x]++;\n\t\t\tint t=x;\n\t\t\twhile(x!=pa[y]) \n\t\t\t\tcir.push_back(x),x=pa[x];\n\t\t\tx=t;\n\t\t}\n\t\telse if(dep[y]<dep[x] and cir.size())\n\t\t{\n\t\t\terr;\n\t\t} \n\t}\n}\n\nunordered_map<int,vector<int> >trans ;\nvector<int> g[nn];int gs[nn];ll dp[nn];\nvoid give(int x,int y)\n{\n//\tcout<<x<<\"-\"<<y<<\"\\n\";\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\nvoid gfs(int x,int p)\n{\n\tgs[x]=1;dp[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t{\n\t\tint y=g[x][i];if(y==p) continue;\n\t\tgfs(y,x);\n\t\tdp[x]=dp[x]*dp[y]%mod*rf[gs[y]]%mod;gs[x]+=gs[y];\n\t}\n\tdp[x]=dp[x]*f[gs[x]-1]%mod;\n}\nint cf[nn];\nll solve()\n{\n\ttrans.clear();\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];g[all[i]].clear();cf[all[i]]=0;\n//\t\tcout<<x<<\"->\"<<y<<\"\\n\";\n\t\t\ttrans[y].push_back(x);\n\t}\n\tg[0].clear();//system(\"pause\");\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];vector<int> tmp=trans[x];\n\t\tfor(int j=0;j<tmp.size();j++)\n\t\t\tif(tmp[j]<y) give(all[i],tmp[j]),cf[tmp[j]]=1; \n\t}\n\tfor(int i=0;i<all.size();i++) if(!cf[all[i]]) give(all[i],0);\n\tgfs(0,-1);\n\treturn dp[0];\n}\n\nint vp[nn];\nvoid vps(int x,int p)\n{\n\tpa[x]=p;vp[x]=1;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==p or vp[v[x][i]]) continue;\n\t\tvps(v[x][i],x); \n\t}\n}\nint main()\n{\n\tini();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tscanf(\"%d%d\",&dot[i].first,&dot[i].second);\n\t\tadde(dot[i].first,dot[i].second+n);\n\t}\n\tll ans=1;\n\tfor(int i=1;i<=n*2;i++) \n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tcir.clear();all.clear();\n\t\t\tdfs(i,0);int cn=cir.size();\n\t\t\tif(siz[i]!=esiz[i]) err;\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tvp[cir[j]]=1,pa[cir[j]]=cir[(j+1)%cn];\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tvps(cir[j],pa[cir[j]]);\n\t\t\tll res=solve();\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tpa[cir[j]]=cir[(j-1+cn)%cn];\n\t\t\tres+=solve();\n\t\t\tans=res%mod*ans%mod*rf[all.size()]%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans*f[n+n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n// #include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 1e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = 0);\n\t\tif (!findcr) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\tassert(SZ(cir) > 1);\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) ideg[u] = 0;\n\t\tfor (auto u : gt) {\n\t\t\tT[u].clear();\n\t\t\tif (SZ(DT[u])) {\n\t\t\t\tauto lim = UB(DT[u], in[u]); \n\t\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v]) {\t// find it!\n\t\t\twhile (top && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tSCir(v, u);\n\t\tif (findcr) return;\n\t} if (S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=400010;\nconst int ha=1e9+7;\nstruct Edge{int to,next;} e[N<<1],et[N<<1];\nint h[N],ht[N],esum=0,tsum=0,n,cmt=0;\nint gay[N],out[N],sz[N];\nbool done[N],inc[N],flag;\nvector<int> crl,vertix;\nstack<int> s;\nint fac[N];\n\nint Pow(int a,int b)\n{\n    int ans=1;\n    for(;b;b>>=1,a=1ll*a*a%ha)\n        if(b&1) ans=1ll*ans*a%ha;\n    return ans;\n}\n\nvoid add_edge(int u,int v)\n{\n    e[++esum]={v,h[u]};h[u]=esum;\n    e[++esum]={u,h[v]};h[v]=esum;\n}\n\nvoid add_topo_edge(int u,int v)\n{\n    out[v]++;\n    et[++tsum].to=v;\n    et[tsum].next=ht[u];\n    ht[u]=tsum;\n}\n\nvoid findcrl(int u,int fa)\n{\n    vertix.push_back(u);\n    done[u]=1;s.push(u);\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa) continue;\n        if(!flag&&done[v])\n        {\n            while(s.top()!=v) crl.push_back(s.top()),inc[s.top()]=1,s.pop();\n            crl.push_back(v);inc[v]=1;s.pop();\n            flag=1;cmt++;return;\n        }\n        else if(!done[v]) cmt++,findcrl(v,u);\n    }\n    if(!s.empty()&&s.top()==u) s.pop();\n}\n\nvoid findgay(int u,int fa)\n{\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa||inc[v]) continue;\n        gay[v]=u;findgay(v,u);\n    }\n}\n\nvoid build_topo()\n{\n    for(int u : vertix)\n        for(int t=h[u];t;t=e[t].next)\n        {\n            int v=e[t].to;\n            if(v>=gay[u]) continue;\n            add_topo_edge(u,v);\n        }\n    for(int u : vertix)\n        if(!out[u]) add_topo_edge(0,u);\n    for(int u : vertix) out[u]=0;\n}\n\nvoid getsize(int u)\n{\n    sz[u]=1;\n    for(int t=ht[u];~t;t=et[t].next)\n    {\n        int v=et[t].to;\n        getsize(v);\n        sz[u]+=sz[v];\n    }\n    ht[u]=-1;\n}\n\nint getans()\n{\n    int prodsz=1;getsize(0);\n    for(int u : vertix)\n        prodsz=1ll*prodsz*sz[u]%ha;\n    return Pow(prodsz,ha-2);\n}\n\nint xi_jin_ping_is_good(int u)\n{\n    flag=0;cmt=0;findcrl(u,0);\n    if(vertix.size()!=cmt) return 0;\n    for(int u : crl) if(inc[u]) findgay(u,0);\n    for(int i=0;i<crl.size()-1;i++) gay[crl[i]]=crl[i+1];\n    gay[crl.back()]=crl[0];\n    build_topo();\n    int res=getans();\n    for(int i=1;i<crl.size();i++) gay[crl[i]]=crl[i-1];\n    gay[crl[0]]=crl.back();\n    tsum=0;build_topo();\n    res=(res+getans())%ha;\n    vertix.clear();\n    return res;\n}\n\nint main()\n{\n    memset(ht,-1,sizeof(ht));\n    int x,y,ans=1;\n    n=read()<<1;fac[0]=1;\n    for(int i=1;i<=n;i++)\n        fac[i]=1ll*fac[i-1]*i%ha;\n    for(int i=1;i<=n;i++)\n    {\n        x=read();y=read();\n        add_edge(x,y+n/2);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(done[i]) continue;\n        x=xi_jin_ping_is_good(i);\n        if(x==0) return puts(\"0\"),0;\n        ans=1ll*ans*x%ha;\n    }\n    ans=1ll*fac[n]*ans%ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include<cstdio>\n    const int MaxN=200010,mod=1000000007;\n    int N;\n    long long fac[MaxN],ifac[MaxN];\n    long long inv(int a,int p=mod){return a==1?1:(1+p*(a-inv(p%a,a)))/a%p;}\n    struct edge{int to;edge*next;}E[MaxN*2],*ne=E,*fir[MaxN];\n    void link(int u,int v){*ne=(edge){v,fir[u]};fir[u]=ne++;}\n    int Q[MaxN],deg[MaxN],S[MaxN],fa[MaxN],siz[MaxN],C[MaxN];\n    bool vis[MaxN];\n    int dfs(int i){\n    \tsiz[i]=1;\n    \tint s=1;\n    \tfor(edge*e=fir[i];e;e=e->next)\n    \t\tif(fa[e->to]==i&&e->to<fa[i])s=1ll*s*dfs(e->to)%mod,siz[i]+=siz[e->to];\n    \treturn 1ll*s*ifac[siz[i]]%mod*fac[siz[i]-1]%mod;\n    }\n    int solve(int v){\n    \tint*h=Q,*t=Q+1,es=0;\n    \tvis[*Q=v]=1;\n    \tfor(;h<t;es+=deg[*h++])\n    \t\tfor(edge*e=fir[*h];e;e=e->next,deg[*h]++)\n    \t\t\tif(!vis[e->to])vis[*t++=e->to]=1;\n    \tif(es!=(t-Q)*2)return 0;\n    \tint*tp=S;\n    \tfor(int*i=Q;i<t;i++)if(deg[*i]==1)*tp++=*i;\n    \twhile(tp>S){\n    \t\tint x=*--tp;\n    \t\tfor(edge*e=fir[x];e;e=e->next)\n    \t\t\tif(--deg[e->to])deg[fa[x]=e->to]==1?*tp++=e->to:1;\n    \t}\n    \tint len=0;\n    \tfor(int*i=Q;i<t;i++)if(deg[*i]>1){\n    \t\tfor(int j=*i;deg[j];){\n    \t\t\tdeg[C[len++]=j]=0;\n    \t\t\tfor(edge*e=fir[j];e;e=e->next)\n    \t\t\t\tif(deg[e->to]>1){j=e->to;break;}\n    \t\t}\n    \t\tbreak;\n    \t}\n    \tint sum=0;\n    \tfor(int dir=0;dir<2;dir++){\n    \t\tint s=1;\n    \t\tfor(int i=0;i<len;i++)fa[C[i]]=C[(dir?i+len-1:i+1)%len];\n    \t\tfor(int*i=Q;i<t;i++)if(*i>fa[fa[*i]])s=1ll*s*dfs(*i)%mod;\n    \t\t(sum+=s)%=mod;\n    \t}\n    \treturn sum;\n    }\n    int main(){\n    \tscanf(\"%d\",&N);\n    \tfor(int i=*fac=1;i<=N*2;i++)fac[i]=fac[i-1]*i%mod;\n    \tifac[N*2]=inv(fac[N*2]);\n    \tfor(int i=N*2;i;i--)ifac[i-1]=ifac[i]*i%mod;\n    \tfor(int i=0,x,y;i<N*2;i++)scanf(\"%d%d\",&x,&y),link(x,y+=N),link(y,x);\n    \tint s=fac[N*2];\n    \tfor(int i=1;i<=N*2;i++)if(!vis[i])s=1ll*s*solve(i)%mod;\n    \tprintf(\"%d\\n\",s);\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=200010;\nconst int ha=1e9+7;\nstruct Edge{int to,next;} e[N<<1],et[N<<1];\nint h[N],ht[N],esum=0,tsum=0,n,cmt=0;\nint gay[N],out[N],sz[N];\nbool done[N],inc[N],flag;\nvector<int> crl,vertix;\nstack<int> s;\nint fac[N];\n\nint Pow(int a,int b)\n{\n    int ans=1;\n    for(;b;b>>=1,a=1ll*a*a%ha)\n        if(b&1) ans=1ll*ans*a%ha;\n    return ans;\n}\n\nvoid add_edge(int u,int v)\n{\n    e[++esum]={v,h[u]};h[u]=esum;\n    e[++esum]={u,h[v]};h[v]=esum;\n}\n\nvoid add_topo_edge(int u,int v)\n{\n    out[v]++;\n    et[++tsum].to=v;\n    et[tsum].next=ht[u];\n    ht[u]=tsum;\n}\n\nvoid findcrl(int u,int fa)\n{\n    vertix.push_back(u);\n    done[u]=1;s.push(u);\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa) continue;\n        if(!flag&&done[v])\n        {\n            while(s.top()!=v) crl.push_back(s.top()),inc[s.top()]=1,s.pop();\n            crl.push_back(v);inc[v]=1;s.pop();\n            flag=1;cmt++;return;\n        }\n        else if(!done[v]) cmt++,findcrl(v,u);\n    }\n    if(!s.empty()&&s.top()==u) s.pop();\n}\n\nvoid findgay(int u,int fa)\n{\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa||inc[v]) continue;\n        gay[v]=u;findgay(v,u);\n    }\n}\n\nvoid build_topo()\n{\n    for(int u : vertix)\n        for(int t=h[u];t;t=e[t].next)\n        {\n            int v=e[t].to;\n            if(v>=gay[u]) continue;\n            add_topo_edge(u,v);\n        }\n    for(int u : vertix)\n        if(!out[u]) add_topo_edge(0,u);\n    for(int u : vertix) out[u]=0;\n}\n\nvoid getsize(int u)\n{\n    sz[u]=1;\n    for(int t=ht[u];~t;t=et[t].next)\n    {\n        int v=et[t].to;\n        getsize(v);\n        sz[u]+=sz[v];\n    }\n    ht[u]=-1;\n}\n\nint getans()\n{\n    int prodsz=1;getsize(0);\n    for(int u : vertix)\n        prodsz=1ll*prodsz*sz[u]%ha;\n    return Pow(prodsz,ha-2);\n}\n\nint xi_jin_ping_is_good(int u)\n{\n    flag=0;cmt=0;findcrl(u,0);\n    if(vertix.size()!=cmt) return 0;\n    for(int u : crl) if(inc[u]) findgay(u,0);\n    for(int i=0;i<crl.size()-1;i++) gay[crl[i]]=crl[i+1];\n    gay[crl.back()]=crl[0];\n    build_topo();\n    int res=getans();\n    for(int i=1;i<crl.size();i++) gay[crl[i]]=crl[i-1];\n    gay[crl[0]]=crl.back();\n    tsum=0;build_topo();\n    res=(res+getans())%ha;\n    vertix.clear();crl.clear();\n    return res;\n}\n\nint main()\n{\n    memset(ht,-1,sizeof(ht));\n    int x,y,ans=1;\n    n=read()<<1;fac[0]=1;\n    for(int i=1;i<=n;i++)\n        fac[i]=1ll*fac[i-1]*i%ha;\n    for(int i=1;i<=n;i++)\n    {\n        x=read();y=read();\n        add_edge(x,y+n/2);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(done[i]) continue;\n        x=xi_jin_ping_is_good(i);\n        if(x==0) return puts(\"0\"),0;\n        ans=1ll*ans*x%ha;\n    }\n    ans=1ll*fac[n]*ans%ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nusing pi = pair<int, int>;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nint n, sz[MAXN], indeg[MAXN];\nvector<pi> gph[MAXN];\nvector<int> tr[MAXN];\nvector<int> dfn;\nint deg[MAXN], vis[MAXN];\nint match[MAXN];\nlint fact[MAXN], invf[MAXN];\n\nlint dfs2(int x){\n\tsz[x] = 0;\n\tlint ret = 1;\n\tfor(auto &i : tr[x]){\n\t\tret *= dfs2(i);\n\t\tret %= mod;\n\t}\n\tfor(auto &i : tr[x]){\n\t\tsz[x] += sz[i];\n\t\tret *= invf[sz[i]];\n\t\tret %= mod;\n\t}\n\tret *= fact[sz[x]];\n\tret %= mod;\n\tsz[x]++;\n\treturn ret;\n}\n\nlint topsort(){\n\tvector<pi> edges; // fi -> se\n\tfor(auto &i : dfn){\n\t\tint to_match = -1;\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(match[i] == j.second){\n\t\t\t\tto_match = j.first;\n\t\t\t}\n\t\t}\n\t\tassert(to_match != -1);\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(match[i] > j.second){\n\t\t\t\tedges.emplace_back(j.first, to_match);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto &i : dfn) disj.pa[i] = i;\n\tfor(auto &i : edges){\n\t\tif(!disj.uni(i.first, i.second)){\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(auto &i : edges){\n\t\ttr[i.second].push_back(i.first);\n\t\tindeg[i.first]++;\n\t}\n\tlint ret = 1;\n\tfor(auto &i : dfn){\n\t\tif(indeg[i] == 0){\n\t\t\tret *= dfs2(i) * invf[sz[i]] % mod;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret *= fact[dfn.size()];\n\tfor(auto &i : edges){\n\t\tindeg[i.first] = 0;\n\t\ttr[i.second].clear();\n\t}\n\treturn ret % mod;\n}\n\nlint solve(){\n\tqueue<int> que;\n\tfor(auto &i : dfn){\n\t\tif(deg[i] == 1){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tint x = que.front(); que.pop();\n\t\tdeg[x]--;\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(deg[i.second]){\n\t\t\t\tmatch[x] = i.second;\n\t\t\t\tdeg[i.second]--;\n\t\t\t\tif(deg[i.second] == 1){\n\t\t\t\t\tque.push(i.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> cyc_ord;\n\tfor(auto &i : dfn){\n\t\tif(deg[i] == 2){\n\t\t\tfor(int j=i; deg[j]; ){\n\t\t\t\tdeg[j] = 0;\n\t\t\t\tcyc_ord.push_back(j);\n\t\t\t\tfor(auto &k : gph[j]){\n\t\t\t\t\tif(deg[k.second]){\n\t\t\t\t\t\tj = k.second;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i=0; i<cyc_ord.size(); i++){\n\t\tmatch[cyc_ord[i]] = cyc_ord[(i+1)%cyc_ord.size()];\n\t}\n\tret += topsort();\n\treverse(cyc_ord.begin(), cyc_ord.end());\n\tfor(int i=0; i<cyc_ord.size(); i++){\n\t\tmatch[cyc_ord[i]] = cyc_ord[(i+1)%cyc_ord.size()];\n\t}\n\tret += topsort();\n\treturn ret % mod;\n}\n\nint v, e;\n\nvoid dfs(int x){\n\tif(vis[x]) return;\n\tdfn.push_back(x);\n\tvis[x] = 1;\n\tv++;\n\te += gph[x].size();\n\tfor(auto &i : gph[x]) dfs(i.second);\n}\n\nlint ipow(lint x, lint p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint main(){\n\tfact[0] = invf[0] = 1;\n\tfor(int i=1; i<MAXN; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tinvf[i] = ipow(fact[i], mod - 2);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<2*n; i++){\n\t\tint x, y; scanf(\"%d %d\",&x,&y);\n\t\tx--, y += n - 1;\n\t\tgph[x].emplace_back(i, y);\n\t\tgph[y].emplace_back(i, x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tn <<= 1;\n\tdisj.init(n);\n\tlint ret = 1;\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i]){\n\t\t\tv = e = 0;\n\t\t\tdfn.clear();\n\t\t\tdfs(i);\n\t\t\tif(2 * v != e){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tret *= invf[v] * solve() % mod;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret *= fact[n];\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 800005\n#define P 1000000007\n#define ll long long\nusing namespace std;\nint n,rd[N],vis[N],fa[N],s1[N],s2[N],a[N],cnt,rt[N],flag[N];\nint fst[N],to[N*2],nxt[N*2],l;\nint inv[N],fac[N],ifac[N];\nvector<int>v[N];\nstruct T\n{\n\tint x,y;\n};\nint C(int x,int y)\n{\n\treturn (ll)fac[y]*ifac[x]%P*ifac[y-x]%P;\n}\nT operator+(T a,T b)\n{\n\treturn (T){(a.x+b.x)%P,a.y};\n}\nT operator*(T a,T b)\n{\n\treturn (T){(ll)a.x*b.x%P*C(a.y,a.y+b.y)%P,a.y+b.y};\n}\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n\trd[x]++;rd[y]++;\n}\nvoid dfs(int x)\n{\n\tif (vis[x]) return;\n\tvis[x]=1;\n\ta[++cnt]=x;\n\tfor (int i=fst[x];i;i=nxt[i])\n\t\tdfs(to[i]);\n}\nvoid Dfs(int x)\n{\n\trd[x]=-1;\n\tfor (int i=fst[x];i;i=nxt[i])\n\t\tif (rd[to[i]]!=-1)\n\t\t{\n\t\t\tfa[x]=to[i];rd[to[i]]--;\n\t\t\tif (rd[to[i]]==1) Dfs(to[i]);\n\t\t}\n}\nT solve(int x)\n{\n\tT ans=(T){1,0};\n\tfor (int i=0;i<v[x].size();i++)\n\t\tans=ans*solve(v[x][i]);\n\tans.y++;\n\treturn ans;\n}\nT work(int x)\n{\n\tcnt=0;\n\tdfs(x);\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tif (rd[a[i]]==1)\n\t\t\tDfs(a[i]);\n\t}\n\tint tmp;\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tif (rd[a[i]]!=-1)\n\t\t{\n\t\t\ttmp=a[i];\n\t\t\tfor (int j=fst[a[i]];j;j=nxt[j])\n\t\t\t\tif (rd[to[j]]!=-1)\n\t\t\t\t\tif (s1[a[i]]) s2[a[i]]=to[j];\n\t\t\t\t\telse s1[a[i]]=to[j];\n\t\t}\n\t}\n\t//puts(\"ok\");\n\tint lst=tmp;fa[tmp]=s2[tmp];\n\tfor (int i=s1[tmp];i!=tmp;)\n\t{\n\t\t//cout<<i<<' '<<tmp<<endl;\n\t\tfa[i]=lst;\n\t\tlst=i;\n\t\ti=s1[i]+s2[i]-fa[i];\n\t\t//swap(lst,tmp);\n\t\t//tmp=s1[lst]+s2[lst]-tmp;\n\t}\n\tfor (int i=1;i<=cnt;i++)\n\t\tflag[a[i]]=0;\n\tint ly=0;\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tfor (int j=fst[a[i]];j;j=nxt[j])\n\t\t\tif (fa[a[i]]>to[j])\n\t\t\t{\n\t\t\t\t//cout<<fa[a[i]]<<' '<<a[i]<<' '<<to[j]<<endl;\n\t\t\t\tv[a[i]].push_back(to[j]);flag[to[j]]=1;\n\t\t\t}\n\t\t//if (flag) rt[++ly]=i;\n\t}\n\tT A1=(T){1,0};\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tif (!flag[a[i]])\n\t\t\tA1=A1*solve(a[i]);\n\t}\n//\tcout<<A1.x<<' '<<A1.y<<endl;\n\t\n\tfor (int i=1;i<=cnt;i++)\n\t\tswap(s1[a[i]],s2[a[i]]);\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tif (rd[a[i]]!=-1)fa[a[i]]=0;\n\t\tv[a[i]].clear();\n\t}\n\tfor (int i=1;i<=cnt;i++)\n\t\tflag[a[i]]=0;\n\tlst=tmp;fa[tmp]=s2[tmp];ly=0;\n\tfor (int i=s1[tmp];i!=tmp;)\n\t{\n\t\tfa[i]=lst;\n\t\tlst=i;\n\t\ti=s1[i]+s2[i]-fa[i];\n\t}\n\tly=0;\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tfor (int j=fst[a[i]];j;j=nxt[j])\n\t\t\tif (fa[a[i]]>to[j]) v[a[i]].push_back(to[j]),flag[to[j]]=1;\n\t}\n\tT A2=(T){1,0};\n\tfor (int i=1;i<=cnt;i++)\n\t{\n\t\tif (!flag[a[i]])\n\t\tA2=A2*solve(a[i]);\n\t}\n\t\n\treturn A1+A2;\n}\nint main()\n{\n//\tfreopen(\"3.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n*2;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y+n);\n\t}\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1;\n\tfor (int i=2;i<=n*2;i++)\n\t{\n\t\tinv[i]=(ll)(P-P/i)*inv[P%i]%P;\n\t\tfac[i]=(ll)fac[i-1]*i%P;\n\t\tifac[i]=(ll)ifac[i-1]*inv[i]%P;\n\t}\n\t//特判 \n\tfor (int i=1;i<=n*2;i++)\n\t\tif (rd[i]==0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\tT Ans=(T){1,0};\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (!vis[i])\n\t\t\tAns=Ans*work(i);\n\t}\n\tprintf(\"%d\\n\",Ans.x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#define Rep(i, x, y) for (int i = x; i <= y; i ++)\n#define Dwn(i, x, y) for (int i = x; i >= y; i --)\n#define RepE(i, x) for (int i = pos[x]; i; i = g[i].nex)\n#define ev g[i].y\n#define eps 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N = 200005, mod = 1000000007;\nint n, pos[N], sz, fl, X, Y, Z, s[N], st[N], top, w[N], vis[N];\nll ans = 1, res;\nstruct edge { int y, nex, z; } g[N * 2];\nvoid init(int x, int y, int z) { g[++ sz] = (edge) { y, pos[x], z }, pos[x] = sz; }\nll power(ll x, int y) {\n\tll z = 1;\n\twhile (y) {\n\t\tif (y & 1) (z *= x) %= mod;\n\t\ty >>= 1; (x *= x) %= mod;\n\t}\n\treturn z;\n}\nvoid dfs1(int x, int fa) {\n\tvis[x] = 2; st[++ top] = x;\n\tRepE(i, x) if (ev != fa) {\n\t\tif (vis[ev] == 2) {\n\t\t\tX = x, Y = ev, Z = g[i].z;\n\t\t\tint k = top - 1;\n\t\t\tdo {\n\t\t\t\tif (w[k] > Z) X = st[k], Y = st[k + 1], Z = w[k];\n\t\t\t\tk --;\n\t\t\t} while (st[k] != ev);\n\t\t\tfl ++;\n\t\t}\n\t\tif (!vis[ev]) w[top] = g[i].z, dfs1(ev, x);\n\t}\n\tvis[x] = 1; top --;\n}\nvoid dfs2(int x, int fa, int z) {\n//\tcout << x <<\" - \"<<s[x]<<endl;\n\ts[x] = 1;\n\tRepE(i, x) if (ev != fa && ev != X && (x != X || ev != Y)) {\n\t\tdfs2(ev, x, g[i].z);\n\t\tif (g[i].z < z) s[x] += s[ev];\n\t}\n\t(res *= power(s[x], mod - 2)) %= mod;\n}\nint main()\n{\n\tscanf (\"%d\", &n);\n\tRep(i, 1, n * 2) {\n\t\tint x, y;\n\t\tscanf (\"%d%d\", &x, &y);\n\t\tinit(x, y + n, x + y);\n\t\tinit(y + n, x, x + y);\n\t}\n\tn = n * 2;\n\tRep(i, 1, n) ans = ans * i % mod;\n\tRep(i, 1, n) if (!vis[i]) {\n\t\tfl = 0;\n\t\tdfs1(i, 0);\n\t\tif (fl != 1) { ans = 0; break ; }\n\t\tres = 1; dfs2(X, 0, Z);\n\t\tll k = res;\n\t\tswap(X, Y);\n\t\tres = 1; dfs2(X, 0, Z);\n\t\t// cout << i<<\" \"<<k<<\" \" <<res<< endl;\n\t\tans = ans * (k + res) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=200010;\nconst int mod=1000000007;\nint n,first[maxn],nxt[maxn<<1],to[maxn<<1],dis[maxn<<1],e;\nvoid Add(int u,int v,int w) {\n//\tprintf(\"%d -> %d %d\\n\",u,v,w);\n\tto[++e]=v;dis[e]=w;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;dis[e]=w;nxt[e]=first[v];first[v]=e;\n}\nint pa[maxn],siz[maxn],es[maxn],vis[maxn];\nint findset(int x) {return x==pa[x]?x:pa[x]=findset(pa[x]);}\nvoid GG() {puts(\"0\");exit(0);}\nint sta[maxn],cir[maxn],left[maxn],right[maxn],col[maxn],clo,top;\nvector<int> s,all;\nint dfs(int x,int la) {\n\tif(vis[x]) {\n\t\twhile(top) {\n\t\t\tint y=sta[top--];\n\t\t\tcir[y]=1;s.pb(y);\n\t\t\tif(x==y) break;\n\t\t}\n\t\treturn 1;\n\t}\n\tvis[x]=++clo;sta[++top]=x;\n\tfor(int i=first[x];i;i=nxt[i]) if((i-1)!=(la-1^1)){\n\t\tif(dfs(to[i],i)) return 1;\n\t}\n\ttop--;\n\treturn 0;\n}\nvoid dfsout(int x,int fa) {\n\tall.pb(x);\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa&&!cir[to[i]]) {\n\t\tcol[to[i]]=dis[i];\n\t\tdfsout(to[i],x);\n\t}\n}\nint fac[maxn],ifac[maxn],size[maxn];\nint C(int a,int b) {return (ll)fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nvector<int> G[maxn];\nint deg[maxn],f[maxn];\nvoid dp(int x) {\n\tf[x]=1;size[x]=0;\n\trep(i,0,G[x].size()-1) {\n\t\tdp(G[x][i]);\n\t\tf[x]=(ll)f[x]*f[G[x][i]]%mod;\n\t\tf[x]=(ll)f[x]*ifac[size[G[x][i]]]%mod;\n\t\tsize[x]+=size[G[x][i]];\n\t}\n\tf[x]=(ll)f[x]*fac[size[x]]%mod;\n\tsize[x]++;\n}\nint work() {\n\trep(j,0,all.size()-1) G[all[j]].clear(),deg[all[j]]=0;\n\trep(j,0,all.size()-1) {\n\t\tint x=all[j];\n\t\tfor(int i=first[x];i;i=nxt[i]) if(dis[i]<col[x]) G[x].pb(to[i]),deg[to[i]]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,0,all.size()-1) if(!deg[all[i]]) {\n\t\tdp(all[i]);\n\t\tans=(ll)ans*C(cur+size[all[i]],cur)%mod;\n\t\tans=(ll)ans*f[all[i]]%mod;\n\t\tcur+=size[all[i]];\n\t}\n\treturn ans;\n}\nint main() {\n\tn=read();\n\tifac[0]=ifac[1]=fac[0]=1;\n\trep(i,2,n*2) ifac[i]=(ll)(mod-mod/i)*ifac[mod%i]%mod;\n\trep(i,1,n*2) fac[i]=(ll)fac[i-1]*i%mod,ifac[i]=(ll)ifac[i-1]*ifac[i]%mod;\n\trep(i,1,n*2) pa[i]=i,siz[i]=1;\n\trep(i,1,n*2) {\n\t\tint x=read(),y=read(),w=x+y;\n\t\tAdd(x,y+n,w);\n\t\tx=findset(x);y=findset(y+n);\n\t\tif(x!=y) {pa[x]=y;siz[y]+=siz[x];es[y]+=es[x];}\n\t\tes[y]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,1,n*2) if(i==findset(i)) {\n\t\tif(siz[i]!=es[i]) GG();\n\t\ts.clear();all.clear();dfs(i,0);top=0;\n\t\trep(j,0,s.size()-1) {\n\t\t\tdfsout(s[j],0);\n\t\t\tint prev=((!j)?s[s.size()-1]:s[j-1]);\n\t\t\tint nxtv=(j==s.size()-1?s[0]:s[j+1]);\n\t\t\tfor(int k=first[s[j]];k;k=nxt[k]) {\n\t\t\t\tif(to[k]==prev) left[s[j]]=dis[k];\n\t\t\t\tif(to[k]==nxtv) right[s[j]]=dis[k];\n\t\t\t}\n\t\t}\n\t\tans=(ll)ans*C(cur+all.size(),cur)%mod;\n\t\tcur+=all.size();\n\t\tint tmp=0;\n\t\trep(j,0,s.size()-1) col[s[j]]=left[s[j]];\n\t\t(tmp+=(ll)work()*ans%mod)%=mod;\n\t\trep(j,0,s.size()-1) col[s[j]]=right[s[j]];\n\t\t(tmp+=(ll)work()*ans%mod)%=mod;\n\t\tans=tmp;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mk make_pair\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int mod = 1e9 + 7;\nint n, root, root1, tag[N], deg[N], size[N];\nll ans = 1, fac[N], inv[N];\nvector<int> s, ss, G[N], E[N];\nmap<int, int> id[N];\nint row[N], col[N];\nvector<int> r[N], c[N];\nbool vis[N];\ninline ll Pow(ll a, int x) {\n\tll res = 1;\n\twhile (x) {\n\t\tif (x & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\nvoid dfs(int x, int f) {\n\tvis[x] = 1;\n\ts.push_back(x);\n\ttag[x] = tag[0];\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (u == f) continue;\n\t\tif (vis[u] && tag[u] != tag[x]) continue;\n\t\tif (!vis[u]) {\n\t\t\tdfs(u, x);\n\t\t\tss.push_back(id[x][u]);\n\t\t} else {\n\t\t\tif (x < u)\n\t\t\t\tss.push_back(id[x][u]);\n\t\t\troot = u;\n\t\t\troot1 = x;\n\t\t}\n\t}\n}\nvoid dfs1(int x, int f, int r) {\n\tif (x <= n) \n\t\tcol[x] = f;\n\telse \n\t\trow[x] = f;\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint u = G[x][i];\n\t\tif (u == f || u == r) continue;\n\t\tdfs1(u, x, r);\n\t}\n}\nll cal(int x) {\n\tsize[x] = 0;\n\tll res = 1;\n\tfor (int i = 0; i < E[x].size(); i++) {\n\t\tint u = E[x][i];\n\t\tres = res * cal(u) % mod;\n\t\tres = res * inv[size[u]] % mod;\n\t\tsize[x] += size[u];\n\t}\n\tres = res * fac[size[x]] % mod;\n\tsize[x]++;\n\treturn res;\n}\nll cal() { //cout << ss.size() << \"/\" << s.size() << endl;\n\tif (ss.size() != s.size()) return 0;\n\tll res = 0;\n\tdfs1(root, root1, root);\n\tE[0].clear();\n\tfor (int i = 0; i < ss.size(); i++) {\n\t\tE[ss[i]].clear();\n\t\tdeg[ss[i]] = 0;\n\t}\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tint x = s[i];\n\t\tif (x <= n) {\n\t\t\tfor (int j = 0; j < c[x].size(); j++) {\n\t\t\t\tint u = c[x][j];\n\t\t\t\tif (u < col[x]) {\n\t\t\t\t\tE[id[x][col[x]]].push_back(id[x][u]);\n\t\t\t\t\tdeg[id[x][u]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int j = 0; j < r[x].size(); j++) {\n\t\t\t\tint u = r[x][j];\n\t\t\t\tif (u < row[x]) {\n\t\t\t\t\tE[id[x][row[x]]].push_back(id[x][u]);\n\t\t\t\t\tdeg[id[x][u]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ss.size(); i++) \n\t\tif (deg[ss[i]] == 0) E[0].push_back(ss[i]);\n\tres += cal(0);\n\tdfs1(root1, root, root1);\n\tE[0].clear();\n\tfor (int i = 0; i < ss.size(); i++) {\n\t\tE[ss[i]].clear();\n\t\tdeg[ss[i]] = 0;\n\t}\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tint x = s[i];\n\t\tif (x <= n) {\n\t\t\tfor (int j = 0; j < c[x].size(); j++) {\n\t\t\t\tint u = c[x][j];\n\t\t\t\tif (u < col[x]) {\n\t\t\t\t\tE[id[x][col[x]]].push_back(id[x][u]);\n\t\t\t\t\tdeg[id[x][u]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int j = 0; j < r[x].size(); j++) {\n\t\t\t\tint u = r[x][j];\n\t\t\t\tif (u < row[x]) {\n\t\t\t\t\tE[id[x][row[x]]].push_back(id[x][u]);\n\t\t\t\t\tdeg[id[x][u]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ss.size(); i++) \n\t\tif (deg[ss[i]] == 0) E[0].push_back(ss[i]);\n\tres += cal(0);\n\treturn res % mod;\n}\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i % mod;\n\tinv[N - 1] = Pow(fac[N - 1], mod - 2);\n\tfor (int i = N - 2; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % mod;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tG[x].push_back(y + n);\n\t\tG[y + n].push_back(x);\n\t\tid[x][y + n] = i;\n\t\tid[y + n][x] = i;\n\t\tr[y + n].push_back(x);\n\t\tc[x].push_back(y + n);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(c[i].begin(), c[i].end());\n\t\tsort(r[i + n].begin(), r[i + n].end());\n\t}\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tif (vis[i]) continue;\n\t\ts.clear();\n\t\tss.clear();\n\t\t++tag[0];\n\t\tdfs(i, 0);\n\t\tans = ans * cal() % mod * inv[s.size()] % mod;\n\t}\n\tans = ans * fac[2 * n] % mod;\n\tcout << ans << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cassert>\n#define MAXN 200010\n#define LL long long\nusing namespace std;\n\nconst LL P=1000000007;\n\nLL getPow(LL x,LL y){\n\tLL res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%P;\n\t\tx=x*x%P;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1];\n\nint n;\nint e2[MAXN][2];\nint g[MAXN],nume;\nint de[MAXN],dp[MAXN],fa[MAXN],tag[MAXN],size[MAXN],pre[MAXN];\nint root;\nvector<int> rt[MAXN],tr;\nLL fac[MAXN],invfac[MAXN];\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nint getf(int x){\n\tif(fa[x]==x) return x;\n\treturn fa[x]=getf(fa[x]);\n}\n\nvoid dfs(int x,int p){\n\tpre[x]=p;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to!=p && e[i].to!=root)\n\t\t\tdfs(e[i].to,x);\n\tif(x>pre[pre[x]]) tr.push_back(x);\n}\n\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%P;\n\tinvfac[MAXN-1]=getPow(fac[MAXN-1],P-2);\n\tfor(int i=MAXN-2;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%P;\n}\n\nLL getC(int x,int y){\n\treturn fac[x]*invfac[y]%P*invfac[x-y]%P;\n}\n\nLL dfs2(int x){\n\tsize[x]=0;\n\tLL res=1;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to<pre[x]){\n\t\t\tLL temp=dfs2(e[i].to);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t\tres=res*temp%P*getC(size[x],size[e[i].to])%P;\n\t\t}\n\tsize[x]++;\n\treturn res;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tscanf(\"%d\",&n);\n\tinit();\n\tn<<=1;\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&e2[i][0],&e2[i][1]);\n\tfor(int i=1;i<=n;i++) fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint x=e2[i][0],y=e2[i][1]+(n/2);\n\t\taddEdge(x,y);\n\t\taddEdge(y,x);\n\t\tde[x]++; de[y]++;\n\t\tif(getf(x)!=getf(y)) fa[fa[x]]=fa[y];\n\t\telse tag[x]=tag[y]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(getf(i)!=i) de[fa[i]]+=de[i];\n\t\tdp[fa[i]]++;\n\t\tif(tag[i]) rt[fa[i]].push_back(i);\n\t}\n\tLL ans=1;\n\tint ts2=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(getf(i)==i){\n\t\t\tif(de[i]!=dp[i]*2){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tassert(rt[i].size()==2);\n\t\t\tLL res=0,res1=1;\n\t\t\ttr.clear();\n\t\t\troot=rt[i][0];\n\t\t\tdfs(rt[i][0],rt[i][1]);\n\t\t\tint ts=0;\n\t\t\tfor(int j=0;j<tr.size();j++){\n\t\t\t\tLL temp=dfs2(tr[j]);\n\t\t\t\tts+=size[tr[j]];\n\t\t\t\tres1=res1*temp%P*getC(ts,size[tr[j]])%P;\n\t\t\t}\n\t\t\tres=(res+res1)%P;\n\t\t\ttr.clear();\n\t\t\troot=rt[i][1];\n\t\t\tdfs(rt[i][1],rt[i][0]);\n\t\t\tts=0;\n\t\t\tres1=1;\n\t\t\tfor(int j=0;j<tr.size();j++){\n\t\t\t\tLL temp=dfs2(tr[j]);\n\t\t\t\tts+=size[tr[j]];\n\t\t\t\tres1=res1*temp%P*getC(ts,size[tr[j]])%P;\n\t\t\t}\n\t\t\tres=(res+res1)%P;\n\t\t\tts2+=ts;\n\t\t\tans=ans*res%P*getC(ts2,ts)%P;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=200010;\nconst int mod=1000000007;\nint n,first[maxn],nxt[maxn<<1],to[maxn<<1],dis[maxn<<1],e;\nvoid Add(int u,int v,int w) {\n//\tprintf(\"%d -> %d %d\\n\",u,v,w);\n\tto[++e]=v;dis[e]=w;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;dis[e]=w;nxt[e]=first[v];first[v]=e;\n}\nint pa[maxn],siz[maxn],es[maxn],vis[maxn];\nint findset(int x) {return x==pa[x]?x:pa[x]=findset(pa[x]);}\nvoid GG() {puts(\"0\");exit(0);}\nint sta[maxn],cir[maxn],left[maxn],right[maxn],col[maxn],clo,top;\nvector<int> s,all;\nvoid dfs(int x,int la) {\n\tvis[x]=++clo;sta[++top]=x;\n\tfor(int i=first[x];i;i=nxt[i]) if((i-1)!=(la-1^1)){\n\t\tif(!vis[to[i]]) dfs(to[i],i);\n\t\telse if(vis[to[i]]<vis[x]) {\n\t\t\twhile(top) {\n\t\t\t\tint y=sta[top--];\n\t\t\t\tcir[y]=1;s.pb(y);\n\t\t\t\tif(to[i]==y) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(top) top--;\n}\nvoid dfsout(int x,int fa) {\n\tall.pb(x);\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa&&!cir[to[i]]) {\n\t\tcol[to[i]]=dis[i];\n\t\tdfsout(to[i],x);\n\t}\n}\nint fac[maxn],ifac[maxn],size[maxn];\nint C(int a,int b) {return (ll)fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nvector<int> G[maxn];\nint deg[maxn],f[maxn];\nvoid dp(int x) {\n\tf[x]=1;size[x]=0;\n\trep(i,0,G[x].size()-1) {\n\t\tdp(G[x][i]);\n\t\tf[x]=(ll)f[x]*f[G[x][i]]%mod;\n\t\tf[x]=(ll)f[x]*ifac[size[G[x][i]]]%mod;\n\t\tsize[x]+=size[G[x][i]];\n\t}\n\tf[x]=(ll)f[x]*fac[size[x]]%mod;\n\tsize[x]++;\n}\nint work() {\n\trep(j,0,all.size()-1) G[all[j]].clear(),deg[all[j]]=0;\n\trep(j,0,all.size()-1) {\n\t\tint x=all[j];\n\t\tfor(int i=first[x];i;i=nxt[i]) if(dis[i]<col[x]) G[x].pb(to[i]),deg[to[i]]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,0,all.size()-1) if(!deg[all[i]]) {\n\t\tdp(all[i]);\n\t\tans=(ll)ans*C(cur+size[all[i]],cur)%mod;\n\t\tans=(ll)ans*f[all[i]]%mod;\n\t\tcur+=size[all[i]];\n\t}\n\treturn ans;\n}\nint main() {\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tn=read();\n\tifac[0]=ifac[1]=fac[0]=1;\n\trep(i,2,n*2) ifac[i]=(ll)(mod-mod/i)*ifac[mod%i]%mod;\n\trep(i,1,n*2) fac[i]=(ll)fac[i-1]*i%mod,ifac[i]=(ll)ifac[i-1]*ifac[i]%mod;\n\trep(i,1,n*2) pa[i]=i,siz[i]=1;\n\trep(i,1,n*2) {\n\t\tint x=read(),y=read(),w=x+y;\n\t\tAdd(x,y+n,w);\n\t\tx=findset(x);y=findset(y+n);\n\t\tif(x!=y) {pa[x]=y;siz[y]+=siz[x];es[y]+=es[x];}\n\t\tes[y]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,1,n*2) if(i==findset(i)) {\n\t//\tif(siz[i]!=es[i]) GG();\n\t\ts.clear();all.clear();dfs(i,0);top=0;\n\t\trep(i,0,s.size()-1) {\n\t\t\tdfsout(s[i],0);\n\t\t\tint prev=(!i?s[s.size()-1]:s[i-1]);\n\t\t\tint nxtv=(i==s.size()-1?s[0]:s[i+1]);\n\t\t\tfor(int j=first[s[i]];j;j=nxt[j]) {\n\t\t\t\tif(to[j]==prev) left[s[i]]=dis[j];\n\t\t\t\tif(to[j]==nxtv) right[s[i]]=dis[j];\n\t\t\t}\n\t\t}\n\t\tans=(ll)ans*C(cur+all.size(),cur)%mod;\n\t\tcur+=all.size();\n\t\tint tmp=0;\n\t\trep(i,0,s.size()-1) col[s[i]]=left[s[i]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\trep(i,0,s.size()-1) col[s[i]]=right[s[i]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\tans=tmp;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nstruct edge{\n\tint k,next;\n}e[N<<2];\nint n,home[N],cnt=-1,a[N],tot,sum=0,s[N],top,to[N],H[N];\nll fac[N],inv[N];\nll quick_pow(ll a,ll b){\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) ans=ans*a%mod;\n\treturn ans;\n}\nll C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nbool vis[N];\nll ans=1;\nvoid add(int *home,int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid dfs(int k){\n\tvis[k]=1;a[++tot]=k;\n\tfor(int i=home[k];~i;i=e[i].next,sum++) if(!vis[e[i].k])\n\t\tdfs(e[i].k);\n}\nint used[N],cir[N],cc;\nint fa[N];\nvoid dfs(int k,int F){\n\tused[k]=++cc;fa[k]=F;\n\tfor(int i=home[k];~i;i=e[i].next) if(i!=F){\n\t\tif(used[e[i].k]){\n\t\t\tif(used[e[i].k]>used[k]) continue;\n\t\t\tint x=k;\n\t\t\tcir[e[i].k]=1;\n\t\t\twhile(x!=e[i].k){\n\t\t\t\ts[++top]=x;\n\t\t\t\tcir[x]=1;\n\t\t\t\tx=e[fa[x]].k;\n\t\t\t}\n\t\t\ts[++top]=e[i].k;\n\t\t\tcontinue;\n\t\t}\n\t\telse dfs(e[i].k,i^1);\n\t}\n}\nvoid dfs1(int k,int F){\n\tused[k]=1;\n\tif(!cir[k]) to[k]=e[F].k;\n\tfor(int i=home[k];~i;i=e[i].next) if(i!=F&&!used[e[i].k]){\n\t\tdfs1(e[i].k,i^1);\n\t}\n}\nint vec,now,siz[N],IN[N];\nll f[N];\nvoid dp(int k){\n\tf[k]=1;now++;siz[k]=0;\n\tfor(int i=H[k];~i;i=e[i].next){\n\t\tdp(e[i].k);\n\t\tsiz[k]+=siz[e[i].k];\n\t\tf[k]=f[k]*C(siz[k],siz[e[i].k])%mod*f[e[i].k]%mod;\n\t}\n\tsiz[k]++;\n}\nvoid solve(){\n\ttop=cc=0;\n\tdfs(a[1],-1);\n\tfor(int i=1;i<=tot;i++) used[a[i]]=0;\n\tdfs1(s[1],-1);\n\tfor(int i=1;i<=tot;i++) used[a[i]]=0;\n\tll ret=0;\n\tint vv=vec,CNT=cnt;\n\tfor(int w=-1;w<=1;w+=2){\n\t\tcnt=CNT;\n\t\tfor(int i=1;i<=tot;i++) H[a[i]]=-1,IN[a[i]]=0;\n\t\tfor(int i=1;i<=top;i++){\n\t\t\tint x=i+w;\n\t\t\tif(x==top+1) x=1;\n\t\t\tif(x==0) x=top;\n\t\t\tto[s[i]]=s[x];\n\t\t}\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tfor(int p=home[a[i]];~p;p=e[p].next)if(e[p].k<to[a[i]]){\n\t\t\t\tadd(H,a[i],e[p].k);\n\t\t\t\tIN[e[p].k]++;\n\t\t\t}\n\t\t}\n\t\tll o=1;vec=vv;\n\t\tfor(int i=1;i<=tot;i++) if(!IN[a[i]]){\n\t\t\tnow=0;\n\t\t\tdp(a[i]);\n\t\t\to=o*C(vec,now)%mod*f[a[i]]%mod;\n\t\t\tvec-=now;\n\t\t}\n\t\tret=(ret+o)%mod;\n\t}\n\tans=ans*ret%mod;\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tmemset(H,-1,sizeof(H));\n\tscanf(\"%d\",&n);\n\tvec=n+n;\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=200002;i++) fac[i]=fac[i-1]*i%mod,inv[i]=quick_pow(fac[i],mod-2);\n\tfor(int i=1,x,y;i<=n+n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(home,x,y+n);add(home,y+n,x);\n\t}\n\tfor(int i=1;i<=n;i++)if(!vis[i]){\n\t\ttot=sum=0;\n\t\tdfs(i);\n\t\tif(sum!=tot+tot) return puts(\"0\"),0;\n\t\tsolve();\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n;\n\nint H(int x,int y){return x*n+y;}\n\nstruct side{\n  int y,next;\n}e[N*4+9];\nint lin[2][N*2+9],cs;\n\nvoid Ins(int id,int x,int y){e[++cs].y=y;e[cs].next=lin[id][x];lin[id][x]=cs;}\nvoid Ins2(int id,int x,int y){Ins(id,x,y);Ins(id,y,x);}\n\nvoid into(){\n  scanf(\"%d\",&n);\n  cs=1;\n  for (int i=1;i<=n<<1;++i){\n\tint x,y;\n\tscanf(\"%d%d\",&x,&y);\n\tIns2(0,H(0,x),H(1,y));\n  }\n}\n\nint inv[N*2+9],fac[N*2+9],ifac[N*2+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n<<1;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint a[N*2+9],vis[N*2+9],ca;\nint st,td,ce;\n\nvoid Dfs_a(int k,int fa){\n  a[++ca]=k;vis[k]=1;\n  for (int i=lin[0][k];i;i=e[i].next){\n\t++ce;\n\tif (!vis[e[i].y]) Dfs_a(e[i].y,k);\n    else if (e[i].y^fa) st=k,td=e[i].y;\n  }\n}\n\nint pre[N*2+9];\n\nvoid Dfs_pre(int k,int fa){\n  for (int i=lin[0][k];i;i=e[i].next)\n\tif (e[i].y^fa&&e[i].y^st){\n\t  pre[e[i].y]=k;\n\t  Dfs_pre(e[i].y,k);\n\t}\n}\n\nint siz[N*2+9];\n\nvoid Dfs_siz(int k,int fa){\n  siz[k]=1;\n  for (int i=lin[1][k];i;i=e[i].next)\n\tif (e[i].y^fa){\n\t  Dfs_siz(e[i].y,k);\n\t  siz[k]+=siz[e[i].y];\n\t}\n}\n\nint deg[N*2+9];\n\nint Get_ans0(){\n  int res=fac[ca];\n  Dfs_pre(st,td);\n  pre[st]=td;\n  for (int i=1;i<=ca;++i) lin[1][a[i]]=0,deg[a[i]]=0;\n  for (int i=1;i<=ca;++i){\n\tint t=a[i];\n\tfor (int j=lin[0][i];j;j=e[j].next)\n\t  if (e[j].y<pre[i]) Ins(1,i,e[j].y),++deg[e[j].y];\n  }\n  for (int i=1;i<=ca;++i)\n\tif (!deg[a[i]]) Dfs_siz(a[i],0);\n  for (int i=1;i<=ca;++i) smul(res,inv[siz[a[i]]]);\n  return res;\n}\n\nint ans;\n\nvoid Get_ans(){\n  ans=fac[n<<1];\n  for (int i=1;i<=n<<1;++i)\n\tif (!vis[i]){\n\t  ca=ce=0;\n\t  Dfs_a(i,0);\n\t  if (ca<<1^ce) {ans=0;return;}\n\t  smul(ans,ifac[ca]);\n\t  int now=Get_ans0();\n\t  swap(st,td);\n\t  smul(ans,add(now,Get_ans0()));\n\t}\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nchar buf[1 << 20], *p1, *p2;\n#define getchar() ((p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)\n\ntemplate<typename T>\nvoid read(T &x) \n{\n\tx = 0;\n\tint f = 1; char c = getchar();\n\twhile (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }\n\twhile (isdigit(c)) { x = x * 10 + c - 48; c = getchar(); }\n\tx *= f;\n}\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G;\nbool vis[MAXN];\nint edge = 0, s, t;\nvoid GetLoop(int x, int Fa) \n{\n\tG.push_back(x);\n\tvis[x] = true;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (!vis[y]) GetLoop(y, x);\n\t\telse if (y != Fa)\n\t\t\ts = x, t = y;\n\t}\n}\n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[G.size()];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tfreopen(\"robot.in\", \"r\", stdin);\n\tfreopen(\"robot.out\", \"w\", stdout);\n\tread(n);\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\ty += n;\n\t\tAdd(x, y), Add(y, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!vis[i])\n\t\t{\n\t\t\tGetLoop(i, 0);\n\t\t\tif (G.size() << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tG.clear();\n\t\t\tedge = 0;\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define int LL\n#define P pair<int,int>\n#define fi first\n#define se second\nconst LL N=2e5+10;\nconst LL mod=1e9+7;\nconst LL inf=0x3f3f3f;\nconst double eps=1e-9;\nusing namespace std;\ntemplate<typename tp> inline void read(tp &x)\n{\n    x=0;char c=getchar();\n    bool f=0; for(; c<'0'||c>'9'; f|=(c=='-'),c = getchar());\n    for(; c>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0',c = getchar());\n    if(f) x=-x;\n}\nP wei[N<<1];\nmap<P,int> Map;\nvector<P> idd;\nvector<int> line[N],row[N],vec,node;\n \nint n,found;\nint head[N<<1],cnt;\nint fa[N<<1],side[N<<1],vis[N<<1];\nint tou[N<<1],num;\nLL siz[N<<1];\n \nstruct Node { int next,to,id;} edge[N<<3];\nstruct E {int next,to;} e[N<<3];\n \nvoid add(int from,int to,int id) { edge[++cnt]= {head[from],to,id}; head[from]=cnt;}\nvoid insert(int from,int to,int id) { add(from,to,id); add(to,from,id);}\nvoid jia(int from,int to) {e[++num]= {tou[from],to}; tou[from]=num;}\nP calc(int x,int y) { if(x>y) swap(x,y); y-=n; return P(x,y);}\nLL KSM(LL a,LL b,LL ret=1) { while(b) { if(b&1) ret=ret*a%mod; a=a*a%mod; b>>=1; } return ret;}\nint ask(P x) { return lower_bound(idd.begin(),idd.end(),x)-idd.begin()+1;}\n\nvoid dfs(int now,int fath)\n{\n    vis[now]=1;\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        if(found==1) return ;\n        int to=edge[i].to;\n        if(to==fath) continue;\n        if(vis[to])\n        {\n            int flag=now;\n            while(flag!=to)\n            {\n                vec.push_back(flag);\n                flag=fa[flag];\n            }\n            vec.push_back(to);\n            found = 1;\n            return ;\n        }\n        fa[to]=now;\n        dfs(to,now);\n    }\n}\nvoid dfs_side_other(int now,int fa)\n{\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        int to=edge[i].to;\n        if(vis[to]==2||to==fa)\n            continue;\n        vis[to]=1;\n        if(to>n) side[edge[i].id]=2;\n        else side[edge[i].id]=1;\n        node.push_back(edge[i].id);\n        dfs_side_other(to,now);\n    }\n}\nLL dfs_size(int now)\n{\n    if(siz[now]) return siz[now];\n    siz[now]=1;\n    for(int i=tou[now]; i; i=e[i].next)\n    {\n        int to=e[i].to;\n        siz[now]+=dfs_size(to);\n    }\n    return siz[now];\n}\nvoid built()\n{\n    for(int i=0; i<node.size(); i++)\n    {\n        int x=wei[node[i]].fi,y=wei[node[i]].se;\n        if(side[node[i]]==1)\n        {\n            int pos=lower_bound(line[x].begin(),line[x].end(),y)-line[x].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(x,line[x][j])));\n        }\n        else\n        {\n            int pos=lower_bound(row[y].begin(),row[y].end(),x)-row[y].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(row[y][j],y)));\n        }\n    }\n}\nLL solve(int now)\n{\n    found = 0;\n    LL ret1=1,ret2=1;\n    vec.clear(), node.clear();\n    dfs(now,now);\n    // for(int i=0;i<vec.size();i++) cout<<vec[i]<<\" \";puts(\"\");\n    for(int i=0; i<vec.size(); i++) vis[vec[i]]=2;\n    for(int i=0; i<vec.size(); i++) dfs_side_other(vec[i],vec[i]);\n    for(int i=0; i<vec.size()-1; i++)\n    {\n        side[ask(calc(vec[i],vec[i+1]))]=(vec[i+1]>n?1:2);\n        node.push_back(ask(calc(vec[i],vec[i+1])));\n    }\n    side[ask(calc(vec[vec.size()-1],vec[0]))]=(vec[0]>n?1:2);\n    node.push_back(ask(calc(vec[vec.size()-1],vec[0])));\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    // for(int i=0; i<node.size();i++) cout<<node[i]<<\" \";puts(\"\");\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret1=ret1*KSM(dfs_size(node[i]),mod-2)%mod;\n    // puts(\"\");\n    // for(int i=0;i<node.size();i++) cout<<node[i]<<\" \"<<dfs_size(node[i])<<endl;\n    // puts(\"\");\n    num=0;\n    for(int i=0; i<node.size(); i++) tou[node[i]]=0;\n    for(int i=vec.size()-1; i>0; i--)\n        side[ask(calc(vec[i],vec[i-1]))]=(vec[i-1]>n?1:2);\n    side[ask(calc(vec[0],vec[vec.size()-1]))]=(vec[vec.size()-1]>n?1:2);\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret2=ret2*KSM(dfs_size(node[i]),mod-2)%mod;\n    return ret1+ret2;\n}\nsigned main()\n{\n\t// freopen(\"data,in\",\"r\",stdin);\n    read(n);\n    for(int i=1,x,y; i<=n*2; i++)\n    {\n        read(x),read(y),insert(x,y+n,i);\n        // wei[i]=P(x,y);\n        // Map[P(x,y)]=i;\n\t\tidd.push_back(P(x,y));\n        line[x].push_back(y);\n        row[y].push_back(x);\n    }\n\tsort(idd.begin(),idd.end());\n\tfor(int i=0;i<n*2;i++)\n\t\twei[i+1]=idd[i];\n    for(int i=1; i<=n; i++)\n    {\n        sort(line[i].begin(),line[i].end()),\n        sort(row[i].begin(),row[i].end());\n        if(!line[i].size()||!row[i].size())\n            return 0*puts(\"0\");\n    }\n    LL ans=1;\n    for(int i=1; i<=n*2; i++)\n        if(!vis[i])\n            ans=ans*solve(i)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n/*\n3\n2 1\n1 2\n2 2\n3 3\n3 2\n2 3\n \noxo\nxxx\noxx\n \n850000006\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,o,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tref(i,0,V[x].size()-1)if(V[x][i]!=f)\n\t\tdfs(x,V[x][i]);\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tref(i,0,vx[X].size()-1)if(vx[X][i]!=x&&vx[X][i]!=o){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tref(i,0,vy[Y].size()-1)if(vy[Y][i]!=x&&vy[Y][i]!=o){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\to=0;int xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\t/*\n\tw[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\tw[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n\t*/\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#define MN 200000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvector<int> v[MN+5];\nint n,head[MN+5],mm,cnt,ans=1,in[MN+5],c[MN+5],num,vis[MN+5],found;\nint Fa[MN+5],q[MN+5],top,p[MN+5],inv[MN+5],size[MN+5],d[MN+5],f[MN+5];\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n    e[++cnt]=(edge){t,head[f]};head[f]=cnt;\n    e[++cnt]=(edge){f,head[t]};head[t]=cnt;\n}\nvoid dfs(int x,int fa)\n{\n    vis[x]=1;q[++top]=x;\n    for(int i=head[x];i;i=e[i].next)\n        if(++mm,!vis[e[i].to]) Fa[e[i].to]=x,dfs(e[i].to,x);\n        else if(e[i].to!=fa&&!found)\n        {\n            for(int t=x;t!=e[i].to;t=Fa[t]) c[++num]=t;\n            c[++num]=e[i].to;found=1;\n        }\n}\nvoid Mark(int x,int fa)\n{\n    Fa[x]=fa;\n    for(int i=head[x];i;i=e[i].next)\n        if(e[i].to!=fa&&!in[e[i].to]) Mark(e[i].to,x);\n}\ninline int CC(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid Solve(int x)\n{\n    size[x]=1;f[x]=1;\n    for(int i=0;i<v[x].size();++i)\n    {\n        Solve(v[x][i]);\n        f[x]=1LL*f[x]*f[v[x][i]]%mod*CC(size[v[x][i]]+size[x]-1,size[v[x][i]])%mod;\n        size[x]+=size[v[x][i]];\n    }\n}\nint main()\n{\n    n=read();p[0]=inv[0]=p[1]=inv[1]=1;\n    for(int i=2;i<=n<<1;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2;i<=n<<1;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n    for(int i=1;i<=n<<1;++i)\n    {\n        int x=read(),y=read();\n        ins(x,y+n);\n    }\n    for(int i=1;i<=n<<1;++i) if(!vis[i])\n    {\n        found=num=top=mm=0;int res=0,way=1;\n        dfs(i,0);if(!found||mm/2!=top) return 0*puts(\"0\");\n        for(int j=1;j<=num;++j) in[c[j]]=j;\n        for(int j=1;j<=num;++j) Mark(c[j],0);\n        for(int j=1;j<=top;++j)\n        {\n            int to=in[q[j]]?c[in[q[j]]%num+1]:Fa[q[j]];\n            for(int k=head[q[j]];k;k=e[k].next)\n                if(e[k].to!=to&&e[k].to<to) v[q[j]].push_back(e[k].to),++d[e[k].to];\n        }\n        for(int j=1;j<=top;++j) if(!d[q[j]]) Solve(q[j]),way=1LL*way*f[q[j]]%mod*inv[size[q[j]]]%mod;\n        res=way;way=1;\n        for(int j=1;j<=top;++j) v[q[j]].clear(),d[q[j]]=0;\n        for(int j=1;j<=top;++j)\n        {\n            int to=in[q[j]]?c[(in[q[j]]+num-2)%num+1]:Fa[q[j]];\n            for(int k=head[q[j]];k;k=e[k].next)\n                if(e[k].to!=to&&e[k].to<to) v[q[j]].push_back(e[k].to),++d[e[k].to];\n        }\n        for(int j=1;j<=top;++j) if(!d[q[j]]) Solve(q[j]),way=1LL*way*f[q[j]]%mod*inv[size[q[j]]]%mod;\n        ans=1LL*ans*(res+way)%mod;\n    }\n    printf(\"%d\",1LL*ans*p[n*2]%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pct puts(\"------ visit ------\");\n#define rep(a, b, c) for(int a = (b); a <= (c); ++ a)\n#define per(a, b, c) for(int a = (b); a >= (c); -- a)\nusing namespace std;\ntemplate <class T> void rd(T &x){\n  x = 0; int f = 1; char ch = getchar();\n  while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }\n  while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();\n  x *= f;\n}\n\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nint n, sdu, tim = 2;\nint mrk[maxn], to[maxn], siz[maxn];\nint p[maxn], cntp;\nint r[maxn], cntr;\nvector <int> h, g[maxn];\nbool ok[maxn], isr[maxn];\n\nnamespace mathematics{\n  ll fac[maxn], fin[maxn];\n\n  ll qpow(ll x, ll n){\n\tll y = 1;\n\tfor(; n; n >>= 1, x = x * x % mod)\n\t  if(n & 1) y = y * x % mod;\n\treturn y;\n  }\n\n#define inv(x) qpow(x, mod - 2)\n\n  ll C(ll n, ll m){ return fac[n] * fin[m] % mod * fin[n - m] % mod; }\n\n  void init(int n){\n\tfac[0] = 1; rep(i, 1, n) fac[i] = fac[i - 1] * i % mod;\n\tfin[n] = inv(fac[n]);\n\tper(i, n, 1) fin[i - 1] = fin[i] * i % mod;\n  }\n\n  void add(ll &a, ll b){ a = (a + b) % mod; }\n\n  void mul(ll &a, ll b){ a = (a * b) % mod; }\n}\nusing namespace mathematics;\n\nstruct edge{ int v, nxt; }; vector <edge> e; int head[maxn];\n\nvoid adde(int u, int v){\n  e.push_back((edge){v, head[u]});\n  head[u] = e.size() - 1;\n}\n\nvoid rebuild(int u, int f){\n  mrk[u] = tim;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v; if(v == f) continue;\n\tif(mrk[v] == tim && v < u) continue;\n\tif(to[u] == v){\n\t  if(to[v] > u) g[v].push_back(u), ok[u] = true;\n\t}\n\telse{\n\t  if(to[u] > v) g[u].push_back(v), ok[v] = true;\n\t}\n\tif(mrk[v] != tim) rebuild(v, u);\n  }\n}\n\nvoid getsize(int u, int f){\n  siz[u] = 1;\n  for(int i = 0; i < g[u].size(); ++ i){\n\tint v = g[u][i];\n\tgetsize(v, u);\n\tsiz[u] += siz[v];\n  }\n}\n\nll getdp(int u, int f){\n  int tot = siz[u] - 1;\n  ll res = 1;\n  for(int i = 0; i < g[u].size(); ++ i){\n\tint v = g[u][i];\n\tmul(res, C(tot, siz[v]) * getdp(v, u) % mod);\n\ttot -= siz[v];\n  }\n  return res;\n}\n\nll query(){\n  ++ tim; \n  rep(i, 1, cntp) ok[p[i]] = false;\n  rebuild(p[1], 0);\n  /*\n  rep(i, 1, cntp) if(g[p[i]].size()){\n\tfor(int j = 0; j < g[p[i]].size(); ++ j)\n\t  printf(\"%d -> %d\\n\", p[i], g[p[i]][j]);\n  }\n  */\n  int tot = cntp;\n  ll res = 1;\n  rep(i, 1, cntp) if(!ok[p[i]]){\n\tgetsize(p[i], 0);\n\tmul(res, C(tot, siz[p[i]]) * getdp(p[i], 0) % mod);\n\ttot -= siz[p[i]];\n  }\n  rep(i, 1, cntp) g[p[i]].clear();\n  return res;\n}\n\nbool getroll(int u, int f){\n  h.push_back(u);\n  mrk[u] = 2;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v;\n\tif(v == f) continue;\n\tif(mrk[v] != 2){\n\t  if(getroll(v, u)) return true;\n\t}\n\telse if(mrk[v] == 2){\n\t  int t = -1;\n\t  while(t != v){\n\t\tt = h.back();\n\t\th.pop_back();\n\t\tr[cntr ++] = t;\n\t\tisr[t] = 1;\n\t  }\n\t  return true;\n\t}\n  }\n  h.pop_back();\n  return false;\n}\n\nvoid match(int u, int f){\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v; if(v == f || isr[v]) continue;\n\tto[v] = u; match(v, u);\n  }\n}\n\nll cal(){\n  if(cntp != sdu){\n\tputs(\"0\");\n\texit(0);\n  }\n  cntr = 0;\n  h.clear();\n  getroll(p[1], 0);\n  /*\n  rep(i, 0, cntr - 1) printf(\"%d \", r[i]); puts(\"\");\n  */\n  rep(i, 0, cntr - 1) match(r[i], 0);\n  rep(i, 0, cntr - 1) to[r[i]] = r[(i + 1) % cntr];\n  ll res = query();\n  rep(i, 0, cntr - 1) to[r[i]] = r[(i + cntr - 1) % cntr];\n  add(res, query());\n  return res;\n}\n\nvoid dfs(int u){\n  p[++ cntp] = u;\n  mrk[u] = 1;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v;\n\tsdu ++;\n\tif(mrk[v]) continue;\n\tdfs(v);\n  }\n}\n\nvoid sol(){\n  int tot = 2 * n;\n  ll res = 1;\n  rep(i, 1, 2 * n) if(!mrk[i]){\n\tcntp = sdu = 0;\n\tdfs(i);\n\tsdu /= 2;\n\tmul(res, C(tot, cntp) * cal() % mod);\n\ttot -= cntp;\n  }\n  printf(\"%lld\\n\", res);\n}\n\nint main(){\n  memset(head, -1, sizeof(head));\n  rd(n);\n  init(2 * n);\n  rep(i, 1, 2 * n){\n\tint u, v; rd(u), rd(v);\n\tadde(u, v + n);\n\tadde(v + n, u);\n  }\n  sol();\n  return 0;\n}\n/*\n7\n3 5\n7 3\n6 4\n7 2\n2 7\n3 6\n5 7\n4 6\n5 2\n6 7\n1 6\n1 1\n6 3\n4 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        // assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            chain_t c = use_generic(i, true);\n            return c * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            chain_t c = use_generic(i, false);\n            return c * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        REP (y, n) acc = acc * go_row(y);\n        REP (x, n) acc = acc * go_col(x);\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=2e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m;\nvector<int>E[N];\n#define pb push_back\nvoid input()\n{\n\tint x,y;\n\tn=read<int>();\n\tFor(i,1,n<<1)\n\t{\n\t\tx=read<int>(),y=read<int>()+n;\n\t\tE[x].pb(y),E[y].pb(x);\n\t}\n}\nconst int mo=1e9+7;\nint ans,inv[N];\nint vis[N],edge;\nint node[N],cnt;\nint c[N],top;\nint fa[N];\nint stk[N],tp;\nvoid dfs1(int u,int pre)\n{\n\t//cerr<<u<<endl;\n\tnode[++cnt]=u;stk[++tp]=u,vis[u]=1,stk[tp+1]=0;\n\t//cerr<<cnt<<endl;\n\tedge+=(int)E[u].size();\n\tfor(int v:E[u])if(v^pre)\n\t{\n\t\tif(!vis[v])dfs1(v,u);\n\t\telse if(!top)\n\t\t{\n\t\t\twhile(stk[tp+1]!=v)vis[c[++top]=stk[tp--]]=2;\n\t\t\tc[0]=v;\n\t\t}\n\t}\n\tif(!top)--tp;\n}\nvoid dfs2(int u,int pre)\n{\n\tfor(int v:E[u])if(v^pre&&vis[v]<2)\n\t{\n\t\tfa[v]=u;\n\t\tdfs2(v,u);\n\t}\n}\nvector<int>G[N];\nint d[N],sz[N];\nvoid dfs3(int u,int &res)\n{\n\tsz[u]=1;\n\tfor(int v:G[u])\n\t{\n\t\tdfs3(v,res);\n\t\tsz[u]+=sz[v];\n\t}\n\tres=1ll*res*inv[sz[u]]%mo;\n}\nint cal()\n{\n\tint res=1;\n\tFor(i,1,cnt)\n\t{\n\t\tres=1ll*res*i%mo;\n\t\td[node[i]]=0;\n\t\tG[node[i]].clear();\n\t}\n\tFor(i,1,cnt)\n\t{\n\t\tfor(int v:E[node[i]])if(v<fa[node[i]])\n\t\t{\n\t\t\tG[node[i]].pb(v);d[v]++;\n\t\t}\n\t}\n\tFor(i,1,cnt)if(!d[node[i]])dfs3(node[i],res);\n\treturn res;\n}\nvoid init(int st)\n{\n\tint res=0;\n\tcnt=top=tp=edge=0;\t\n\tdfs1(st,0);\t\n\tif(edge!=(cnt<<1)){puts(\"0\");exit(0);}\n\tFor(i,1,top)dfs2(c[i],0);\t\n\tFor(i,1,top)fa[c[i-1]]=c[i];\n\tres=cal();\n\tFor(i,1,top)fa[c[i]]=c[i-1];\n\tres=(res+cal())%mo;\n\tans=1ll*ans*res%mo;\n\tFor(i,1,cnt)ans=1ll*ans*inv[i]%mo;\n\t//cerr<<cnt<<endl;\n}\nvoid work()\n{\n\tans=1;\n\tinv[0]=inv[1]=1;\n\tFor(i,2,n<<1)ans=1ll*ans*i%mo,inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,n<<1)if(!vis[i])init(i);\n\twrite(ans,'\\n');\n}\nint main()\n{\n\n\tinput();\n\twork();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lowbit(o) o&(-o)\n#define P 1000000007\n#define N 200005\n#define M 400005\n#define pb push_back\nusing namespace std;\nint i,j,k,l,s,r,n,m,jc[N],ny[N],fa[N],A[2][N],B[2][N],tot,T,vis[2][N],id[N],Si[2][N];\nint ans,Ans,si,G[N];\nvector<int>GT[2][N],V[2][N];\nvector<int>::iterator GTW;\nstruct orz {\n\tint x,y;\n}a[N],q[N],Q[N];\nstruct node {\n\tint tot,last[N],to[M],next[M];\n\tinline void add(int x,int y) {\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A1;\nstruct Node {\n\tint tot,chu[N],ru[N],l,r,last[N],next[M],to[M],f[N],si[N];\n\torz q[N];\n\tinline void add(int x,int y) {\n\t\tchu[x]++; ru[y]++;\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A2;\ninline bool cmp(int x,int y) {\n\treturn G[x]<G[y];\n}\ninline int findl(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=0;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]<x) s=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn s+1;\n}\ninline int findr(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=2*n+1;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]>x) s=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn s-1;\n}\ninline int quick(int x,int y) {\n\tint s=1;\n\twhile (y) {\n\t\tif (y&1) s=1ll*s*x%P;\n\t\tx=1ll*x*x%P;\n\t\ty>>=1;\n\t}\n\treturn s;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\ninline int C(int x,int y) {\n\treturn 1ll*jc[x]*ny[y]%P*ny[x-y]%P;\n}\ninline int getans(int r) {\n\tT=s=0;\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].pb(q[i].y);\n\tint L=findl(get(q[1].x*n+q[1].y)),R=findr(get(q[1].x*n+q[1].y));\n\tfor (int i=L;i<=R;i++) {\n\t\ts++;\n\t\tQ[++T].x=(id[i]-1)/n,Q[T].y=(id[i]-1)%n+1;\n\t\tif (A[Q[T].x][Q[T].y]) {\n \t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>A[Q[T].x][Q[T].y]) continue;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>B[Q[T].x][Q[T].y]) continue;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t}\n\tA2.l=A2.r=0;\n\tA2.f[A2.si[0]=0]=1;\n\tfor (int i=1;i<=T;i++) A2.f[Q[i].x*n+Q[i].y]=1;\n\tfor (int i=1;i<=T;i++) if (!A2.chu[Q[i].x*n+Q[i].y]) A2.add(Q[i].x*n+Q[i].y,0);\n\tfor (int i=1;i<=T;i++) if (!A2.ru[Q[i].x*n+Q[i].y]) A2.q[++A2.r].x=Q[i].x,A2.q[A2.r].y=Q[i].y;\n\twhile (A2.l<A2.r) {\n\t\tA2.l++;\n\t\tA2.si[A2.q[A2.l].x*n+A2.q[A2.l].y]++;\n\t\tfor (int i=A2.last[A2.q[A2.l].x*n+A2.q[A2.l].y];i;i=A2.next[i]) {\n\t\t\tA2.ru[A2.to[i]]--;\n\t\t\tA2.si[A2.to[i]]+=A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y];\n\t\t\t(A2.f[A2.to[i]]=1ll*A2.f[A2.to[i]]*A2.f[A2.q[A2.l].x*n+A2.q[A2.l].y]%P*C(A2.si[A2.to[i]],A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y])%P);\n\t\t\tif (!A2.ru[A2.to[i]]) A2.q[++A2.r].x=(A2.to[i]-1)/n,A2.q[A2.r].y=(A2.to[i]-1)%n+1;\n\t\t}\n\t}\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].pop_back();\n\tA2.tot=0;\n\tfor (int i=1;i<=A2.r;i++) A2.last[A2.q[i].x*n+A2.q[i].y]=0,A2.chu[A2.q[i].x*n+A2.q[i].y]=A2.ru[A2.q[i].x*n+A2.q[i].y]=0;\n\tfor (int i=1;i<=T;i++) A2.f[A2.q[i].x*n+A2.q[i].y]=A2.si[A2.q[i].x*n+A2.q[i].y]=0;\n\treturn A2.f[0];\n}\ninline void work(int x,int y) {\n\tvis[x][y]=1;\n\tint l=0,r=1; q[1].x=x,q[1].y=y;\n\twhile (l<r) {\n\t\t++l;\n\t\tfor (GTW=GT[q[l].x][q[l].y].begin();GTW!=GT[q[l].x][q[l].y].end();GTW++) if (!vis[q[l].x^1][(*GTW)]) q[++r].x=q[l].x^1,q[r].y=(*GTW),vis[q[r].x][q[r].y]=1;\n\t}\n\tfor (int i=1;i<=r;i++) \n\tfor (GTW=GT[q[i].x][q[i].y].begin();GTW!=GT[q[i].x][q[i].y].end();GTW++) A1.add(q[i].x*n+q[i].y,(*GTW));\n\tint xx=x,yy=y;\n\tB[xx][yy]=A1.to[A1.last[xx*n+yy]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) \n\t\tif (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tAns=getans(r);\n\t\n\tfor (int i=1;i<=r;i++) B[q[i].x][q[i].y]=0;\n\tB[xx][yy]=A1.to[A1.next[A1.last[xx*n+yy]]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) if (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tA1.tot=0;\n\tfor (int i=1;i<=r;i++) A1.last[q[i].x*n+q[i].y]=0;\n\t(Ans+=getans(r))%=P;\n\tsi+=s;\n\t(ans=1ll*ans*Ans%P*C(si,s)%P);\n}\ninline void doit() {\n\tjc[0]=1;\n\tfor (int i=1;i<=200000;i++) jc[i]=1ll*jc[i-1]*i%P;\n\tny[200000]=quick(jc[200000],P-2);\n\tfor (int i=199999;i;i--) ny[i]=1ll*ny[i+1]*(i+1)%P;\n\tny[0]=1;\n}\nvoid R(int &x) {\n\tx=0;char ch=getchar();\n\twhile (ch<'0' || '9'<ch) ch=getchar();\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n}\nint main() {\n\tdoit();\n\tans=1; si=0;\n\tR(n);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) fa[i*n+j]=i*n+j;\n\tfor (i=1;i<=2*n;i++) {\n\t\tR(a[i].x),R(a[i].y);\n\t\tif (get(a[i].x)!=get(n+a[i].y)) fa[get(a[i].x)]=get(n+a[i].y);\n\t\tGT[0][a[i].x].pb(a[i].y);\n\t\tSi[0][a[i].x]++;\n\t\tSi[1][a[i].y]++;\n\t\tGT[1][a[i].y].pb(a[i].x);\n\t}\n\tfor (i=1;i<=2*n;i++) if (get(id[i]=i)==i) G[i]=++tot;\n\tfor (i=1;i<=2*n;i++) G[i]=G[get(i)];\n\ttot=0;\n\tsort(id+1,id+1+2*n,cmp);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!Si[i][j]) return puts(\"0\"),0;\n\telse if (Si[i][j]==1) q[++r].x=i,q[r].y=j;\n\twhile (l<r) {\n\t\t++l;\n\t\tif (!Si[q[l].x][q[l].y]) return puts(\"0\"),0;\n\t\tfor (GTW=GT[q[l].x][q[l].y].begin();GTW!=GT[q[l].x][q[l].y].end();GTW++) if (A[q[l].x^1][*GTW]!=q[l].y)\n\t\tA[q[l].x][q[l].y]=(*GTW);\n\t\tSi[q[l].x^1][A[q[l].x][q[l].y]]--;\n\t\tif (Si[q[l].x^1][A[q[l].x][q[l].y]]==1) q[++r].x=q[l].x^1,q[r].y=A[q[l].x][q[l].y];\n\t}\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) GT[i][j].clear();\n\tfor (i=1;i<=2*n;i++) if (A[0][a[i].x]!=a[i].y&&A[1][a[i].y]!=a[i].x) {\n\t\tGT[0][a[i].x].pb(a[i].y);\n\t\tGT[1][a[i].y].pb(a[i].x);\n\t}\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (A[i][j]) V[i^1][A[i][j]].pb(j);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!vis[i][j]&&GT[i][j].size()==2) \n\twork(i,j);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x){\n    char ch=getchar(),ob=0;x=0;\n    while(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 201000;\nstruct Edge {int v, nxt;} a[N*4];\nint head[N], Head[N], indeg[N];\nint sz[N], pr[N];\nbool vis[N];\nint n, _;\n\ninline void add(int x, int y, int*arr) {\n    a[++_].v = y, a[_].nxt = arr[x], arr[x] = _;\n}\n\nconst int p = 1e9+7;\nint fac[N], ifac[N], inv[N];\n\nint st[N], tp;\n#define FID(i) for(int id=1,i;i=st[id],id<=tp;++id)\n\nint X, Y;\nint et, pt;\n\nvoid bfs(int x, int las) {\n    vis[st[++tp] = x] = true;\n    for(int i=head[x];i;++et,i=a[i].nxt)\n        if(!vis[a[i].v]) bfs(a[i].v, x);\n        else if(a[i].v != las) X = x, Y = a[i].v;\n}\n\nvoid tfs(int x, int las) {\n    for(int i=head[x];i;i=a[i].nxt)\n        if(a[i].v != las and a[i].v != X)\n            pr[a[i].v] = x, tfs(a[i].v, x);\n}\n\nvoid dfs(int x, int las) {\n    sz[x] = 1;\n    for(int i=Head[x];i;i=a[i].nxt)\n        if(a[i].v != las)\n            dfs(a[i].v, x), sz[x] += sz[a[i].v];\n}\n\nint solve() {\n    tfs(X, Y);\n    pr[X] = Y;\n    FID(i) Head[i] = indeg[i] = 0;\n    FID(x) for(int i=head[x];i;i=a[i].nxt)\n        if(a[i].v < pr[x]) add(x, a[i].v, Head), ++indeg[a[i].v];\n    FID(i) if(!indeg[i]) dfs(i, i);\n    int Ans = fac[pt];\n    FID(i) Ans = (ll)Ans * inv[sz[i]]%p;\n\t return Ans;\n}\n\nint main() {\n    read(n);\n    for(int i=1,x,y;i<=(n<<1);++i) {\n        read(x), read(y), y += n;\n        add(x, y, head), add(y, x, head);\n    }\n    \n    n <<= 1;\n    fac[0] = fac[1] = inv[0] = inv[1] = ifac[0] = ifac[1] = 1;\n    for(int i=2;i<=n;++i) {\n        fac[i] = (ll)fac[i-1] * i%p;\n        inv[i] = (ll)(p-p/i) * inv[p%i]%p;\n        ifac[i] = (ll)ifac[i-1] * inv[i]%p;\n    }\n    \n    int Ans = fac[n];\n    for(int i=1;i<=n;++i)\n        if(!vis[i]) {\n            tp = pt = et = 0;\n\t\t\t\tbfs(i, i);\n            Ans = (ll)Ans * ifac[pt]%p;\n            if((tp << 1) != et) return puts(\"0\"), 0;\n            X ^= Y, Y ^= X, X ^= Y;\n            int res = solve();\n            X ^= Y, Y ^= X, X ^= Y;\n            res += solve();\n            Ans = (ll)Ans * res%p;\n        }\n    printf(\"%d\\n\", Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lowbit(i) ((i)&(-(i)))\n#define lson(i) ((i)<<1)\n#define rson(i) ((i)<<1|1)\n#define sqr(x) ((x)*(x))\n#define fi first\n#define se second\n#define mp(x,y) make_pair((x),(y))\n#define pb push_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef pair<int,int> pii;\ntypedef vector<int> vii;\ntypedef vector<pii> vpi;\ntypedef queue<int> qii;\n\nconst int inf=0x3f3f3f3f;\nconst int maxn=100007;\nconst int maxv=200007;\nconst int maxe=400007;\nconst int mod=1e9+7;\n\ninline int read(){\n\tint re=0,flag=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-'){\n\t\t\tflag=-1;\n\t\t}\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tre=(re<<3)+(re<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn re*flag;\n}\n\nint n;\nstd::queue<int> q;\nstd::vector<int> cur;\nint pre[maxe],now[maxe],son[maxe];\nint tot;\nint _pre[maxe],_now[maxe],_son[maxe];\nint _tot;\nint vis[maxv];\nint ecnt;\nint cir[maxv],deg[maxv],choose[maxv];\nint fac[maxv],ifac[maxv];\nint f[maxv],size[maxv];\n\nint C(int a,int b){\n\treturn 1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint _ins(int a,int b){\n\t_pre[++_tot]=_now[a];\n\t_now[a]=_tot;\n\t_son[_tot]=b;\n\treturn 0;\n}\n\nint calc(){\n\tfor(auto i:cur){\n\t\tdeg[i]=_now[i]=0;\n\t}\n\tfor(auto i:cur){\n\t\tfor(int j=now[i];j;j=pre[j]){\n\t\t\tint v=son[j];\n\t\t\tif(v<choose[i]){\n\t\t\t\t_ins(v,i);\n\t\t\t\t++deg[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto i:cur){\n\t\tif(!deg[i]){\n\t\t\tq.push(i);\n\t\t}\n\t\tf[i]=1;\n\t\tsize[i]=1;\n\t}\n\tint sz=0,ans=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();\n\t\tint flag=0;\n\t\tq.pop();\n\t\tfor(int i=_now[u];i;i=_pre[i]){\n\t\t\tflag=1;\n\t\t\tint v=_son[i];\n\t\t\t--deg[v];\n\t\t\tsize[v]+=size[u];\n\t\t\tf[v]=1ll*f[v]*f[u]%mod*C(size[v]-1,size[u])%mod;\n\t\t\tif(!deg[v]){\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tsz+=size[u];\n\t\t\tans=1ll*ans*f[u]%mod*C(sz,size[u])%mod;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint ins(int a,int b){\n\tpre[++tot]=now[a];\n\tnow[a]=tot;\n\tson[tot]=b;\n\treturn 0;\n}\n\nint dfs(int u){\n\tvis[u]=1;\n\tcur.push_back(u);\n\tfor(int i=now[u];i;i=pre[i]){\n\t\t++ecnt;\n\t\tint v=son[i];\n\t\tif(!vis[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint search(int u){\n\tcir[++cir[0]]=u;\n\tvis[u]=1;\n\tfor(int i=now[u];i;i=pre[i]){\n\t\tint v=son[i];\n\t\tif(!vis[v]){\n\t\t\tsearch(v);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(){\n\tif(cur.size()!=ecnt){\n\t\treturn 0;\n\t}\n\tfor(auto i:cur){\n\t\tif(deg[i]==1){\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=now[u];i;i=pre[i]){\n\t\t\tint v=son[i];\n\t\t\tif(deg[v]!=1){\n\t\t\t\t--deg[v];\n\t\t\t\tchoose[u]=v;\n\t\t\t\tif(deg[v]==1){\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint st=0;\n\tfor(auto i:cur){\n\t\tif(deg[i]>1){\n\t\t\tst=i;\n\t\t\tvis[i]=0;\n\t\t}\n\t}\n\tcir[0]=0;\n\tsearch(st);\n\tcir[cir[0]+1]=cir[1];\n\tfor(int i=1;i<=cir[0];++i){\n\t\tchoose[cir[i]]=cir[i+1];\n\t}\n\tint res=calc();\n\tfor(int i=2;i<=cir[0]+1;++i){\n\t\tchoose[cir[i]]=cir[i-1];\n\t}\n\tres+=calc();\n\tif(res>=mod){\n\t\tres-=mod;\n\t}\n\tfor(auto i:cur){\n\t\tvis[i]=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tn=read();\n\tfac[0]=1;\n\tfor(int i=1;i<=n<<1;++i){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t}\n\tifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=n<<1;++i){\n\t\tifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;\n\t}\n\tfor(int i=2; i<=n<<1; ++i){\n\t\tifac[i]=1ll*ifac[i-1]*ifac[i]%mod;\n\t}\n\tfor(int i=1; i<=n<<1; ++i){\n\t\tint x=read(),y=read();\n\t\tins(x,y+n);\n\t\tins(y+n,x);\n\t\t++deg[x];\n\t\t++deg[y+n];\n\t}\n\tint tsize=0,ans=1;\n\tfor(int i=1;i<=n<<1;++i){\n\t\tif(!vis[i]){\n\t\t\tcur.clear();\n\t\t\tecnt=0;\n\t\t\tdfs(i);\n\t\t\tecnt/=2;\n\t\t\tint res=solve();\n\t\t\ttsize+=ecnt;\n\t\t\tans=1ll*ans*res%mod*C(tsize,ecnt)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n有点恶心。\n\n每个机器人看做一个点，平面上的每个点看做连接机器人的边。\n形成的图一定是基环树森林。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) // fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 400005, mod = 1000000007;\nint head[maxn], nxt[maxn << 2], to[maxn << 2], hp = 1;\n\ninline ll power(ll x, int k) {\n\tif(k < 0) k += mod - 1;\n\tll res = 1;\n\twhile(k) {\n\t\tif(k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline void add(int u, int v, int *h) {\n\tnxt[++ hp] = h[u];\n\th[u] = hp;\n\tto[hp] = v;\n}\n\nint tmp[maxn], tp;\nbool vis[maxn];\nint cx, cy;\nint dfs(int u, int f) {\n\t/* debug(\"%d -> %d\\n\", f, u); */\n\ttmp[++ tp] = u;\n\tvis[u] = 1;\n\tint res = 0;\n\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f) {\n\t\t\t++ res;\n\t\t\tif(vis[to[i]]) {\n\t\t\t\tcx = u;\n\t\t\t\tcy = to[i];\n\t\t\t} else\n\t\t\t\tres += dfs(to[i], u);\n\t\t}\n\n\treturn res;\n}\n\nint match[maxn];\nvoid mdfs(int u, int f) {\n\t/* debug(\"%d -> %d\\n\", f, u); */\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f and to[i] != cx) {\n\t\t\tmatch[to[i]] = u;\n\t\t\tmdfs(to[i], u);\n\t\t}\n}\n\nint Head[maxn];\nint deg[maxn];\nint stack[maxn], sp;\nll f[maxn];\nint size[maxn];\nll fac[maxn], ifac[maxn];\n\ninline ll C(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nint force_count;\nvoid dp(int u) {\n\t++ force_count;\n\tif(force_count >= 100) {\n\t\tputs(\"0\");\n\t\texit(0);\n\t}\n\n\tsize[u] = 0;\n\tf[u] = 1;\n\tfor(int i = Head[u]; i; i = nxt[i]) {\n\t\tdp(to[i]);\n\t\tsize[u] += size[to[i]];\n\t\t(f[u] *= f[to[i]]) %= mod;\n\t\t(f[u] *= C(size[u], size[to[i]])) %= mod;\n\t}\n\t++ size[u];\n\tdebug(\"%d : %lld %d\\n\", u, f[u], size[u]);\n}\n\nint HP;\nll solve() {\n\tdebug(\"solve %d %d\\n\", cx, cy);\n\tmdfs(cx, cy);\n\tmatch[cx] = cy;\n\n\thp = HP;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tdeg[tmp[i]] = Head[tmp[i]] = 0;\n\n\tfor(int id = 1; id <= tp; id ++) {\n\t\tint u = tmp[id];\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] < match[u]) {\n\t\t\t\tdebug(\"%d -> %d\\n\", u, to[i]);\n\t\t\t\tadd(u, to[i], Head);\n\t\t\t\t++ deg[to[i]];\n\t\t\t}\n\t}\n\n\tHead[0] = 0;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tif(!deg[tmp[i]])\n\t\t\tadd(0, tmp[i], Head);\n\n\tdp(0);\n\tdebug(\"get %lld\\n\", f[0]);\n\n\treturn f[0];\n}\n\nint main() {\n\tint n = read;\n\n\tint N = n << 1 | 1;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[N] = power(fac[N], -1);\n\tfor(int i = N; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n\n\tfor(int i = 1; i < N; i ++) {\n\t\tint x = read, y = read;\n\t\tadd(x, n + y, head);\n\t\tadd(n + y, x, head);\n\t}\n\n\tHP = hp;\n\tll ans = 1;\n\tint SIZE = 0;\n\n\tfor(int r = 1; r < N; r ++)\n\t\tif(!vis[r]) {\n\t\t\ttp = 0;\n\t\t\tif(dfs(r, 0) != (tp << 1)) return puts(\"0\"), 0;\n\t\t\tll now = solve();\n\t\t\tstd::swap(cx, cy);\n\t\t\tnow += solve();\n\t\t\tSIZE += size[0] - 1;\n\t\t\t(ans *= now) %= mod;\n\t\t\t(ans *= C(SIZE, size[0] - 1)) %= mod;\n\t\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n//#define T_ int\nusing namespace std;\n//struct bit{T_ arr[1000005];int lowbit(int x){return x&(-x);}void add(int x,T_ y){for (int i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(int x){T_ s=0;for (int i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{int l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(int id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(int id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(int id,int l,int r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{int mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(int id,int le,int ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(int id,int le,int ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\n//struct bit_2d{T_ a[2005][2005];int lowbit(int x){return x&(-x);}void add(int x,int y,T_ z){int i,j;for (i=x;i<=2000;i+=lowbit(i)){for (j=y;j<=2000;j+=lowbit(j)){a[i][j]+=z;}}}T_ query(int x,int y){int i,j;T_ s=0;for (i=x;i;i-=lowbit(i)){for (j=y;j;j-=lowbit(j)){s+=a[i][j];}}return s;}T_ query(int x,int y,int xx,int yy){return query(xx,yy)-query(x-1,yy)-query(xx,y-1)+query(x-1,y-1);}};\nint n,m,i,j,x,y,fac[200005],fi[200005],inv[200005],mod=1e9+7,vis[200005],ans=1,fa[200005],inc[200005],cnt,deg[200005],sz[200005];\nvector<int> bi[200005],cir,all,bi2[200005];\nvoid dfs1(int x,int p)\n{\n\tfa[x]=p;vis[x]=1;cnt+=2;all.push_back(x);\n\tff(bi[x],it){\n\t\tcnt--;if (*it==p) continue;\n\t\tif (!vis[*it]){\n\t\t\tdfs1(*it,x);\n\t\t}\n\t\telse if (cir.empty()){\n\t\t\tint t=x;\n\t\t\tcir.push_back(*it);inc[*it]=1;\n\t\t\twhile (x!=*it){\n\t\t\t\tinc[x]=1;cir.push_back(x);x=fa[x];\n\t\t\t}x=t;\n\t\t}\n\t}\n}\nvoid dfs2(int x,int p)\n{\n\tfa[x]=p;\n\tff(bi[x],it){\n\t\tif (*it==p||inc[*it]) continue;\n\t\tdfs2(*it,x);\n\t}\n}\nvoid dfs3(int x,int p)\n{\n\tff(bi[x],it){\n\t\tif (*it==fa[x]) break;\n//\t\tcerr<<x<<' '<<*it<<endl;\n\t\tbi2[x].push_back(*it);\n\t\tdeg[*it]++;\n\t}\n\tff(bi[x],it){\n\t\tif (*it==p||inc[*it]) continue;\n\t\tdfs3(*it,x); \n\t}\n}\nvoid init(){ff(all,it){bi2[*it].clear();deg[*it]=0;}}\nint dfs4(int x,int p)\n{\n\tdeg[x]=-1;sz[x]=1;int ans=1;ff(bi2[x],it) if (*it!=p){\n\t\tdeg[*it]=0;ans=1ll*ans*dfs4(*it,x)%mod;sz[x]+=sz[*it];\n\t}\n\treturn 1ll*inv[sz[x]]*ans%mod;\n}\nint solve2()\n{\n\tint i,s=1;\n\tff(all,it) if (!deg[*it]) s=1ll*s*dfs4(*it,0)%mod;\n\treturn s;\n}\nint solve(int x)\n{\n\tint s=0;\n\tcnt=0;cir.clear();all.clear();dfs1(x,0);if (cnt) return 0;\n\tff(cir,it) cerr<<*it<<' ';cerr<<endl;\n\tff(cir,it) dfs2(*it,0);\n\tinit();\n\tfz0k(i,cir.size()) fa[cir[i]]=cir[(i+1)%cir.size()];\n\tff(cir,it) dfs3(*it,0);(s+=solve2())%=mod;//cerr<<\"--------\\n\";\n\tinit();\n\tfz0k(i,cir.size()) fa[cir[i]]=cir[(i+cir.size()-1)%cir.size()];\n\tff(cir,it) dfs3(*it,0);(s+=solve2())%=mod;\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfac[0]=fac[1]=inv[0]=inv[1]=fi[0]=fi[1]=1;\n\tfz(i,2,n+n){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t\tfi[i]=1ll*fi[i-1]*inv[i]%mod;\n\t}\n\tfz1(i,n*2){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tbi[x].push_back(y+n);\n\t\tbi[y+n].push_back(x);\n\t}\n\tfz1(i,n*2) if (!bi[i].empty()) sort(bi[i].begin(),bi[i].end());\n\tfz1(i,n*2) if (!vis[i]) ans=1ll*ans*solve(i)%mod;\n\tcout<<1ll*ans*fac[2*n]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\nconst int MN = 200010;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[MN], invf[MN];\n\nint N;\npii P[MN];\nvector<pii> Vx[MN], Vy[MN];\nvector<int> adj[MN];\nint par[MN], tin[MN], timer;\nvector<int> V, cycle;\nint ans;\n\nbool dfs0(int u, int p) {\n    tin[u] = timer++;\n    V.push_back(u);\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        if(tin[v] != -1) {\n            if(tin[v] < tin[u]) {\n                if(cycle.size()) return false;\n                int t = u;\n                while(1) {\n                    cycle.push_back(t);\n                    if(t == v) break;\n                    t = par[t];\n                }\n            }\n            continue;\n        }\n        par[v] = u;\n        if(!dfs0(v, u)) return false;\n    }\n    return true;\n}\n\nint X[MN], Y[MN];\nint dir[MN];\n\nvoid dfs1(int u, int p) {\n    tin[u] = timer++;\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(tin[v] != -1) continue;\n        if(p == -1 && P[u].first == P[v].first && P[u].second > P[v].second) continue;\n        dir[v] = P[u].second == P[v].second;\n        dfs1(v, u);\n    }\n}\n\nvector<int> tree[MN];\nint root[MN], sz[MN];\n\nint dfs2(int u) {\n    int ret = 1;\n\n    sz[u] = 0;\n    for(int i = 0; i < tree[u].size(); i++) {\n        int v = tree[u][i];\n        int t = dfs2(v);\n        sz[u] += sz[v];\n        ret = 1LL * ret * t % mod;\n        ret = 1LL * ret * invf[ sz[v] ] % mod;\n    }\n    ret = 1LL * ret * fact[ sz[u] ] % mod;\n    sz[u]++;\n    return ret;\n}\n\nint solve(int u) {\n    for(int i = 0; i < V.size(); i++) {\n        tin[V[i]] = -1;\n        X[ P[V[i]].first ] = 0;\n        Y[ P[V[i]].second ] = 0;\n    }\n    dir[u] = 0;\n    Y[ P[u].second ] = 1;\n    dfs1(u, -1);\n\n    for(int i = 0; i < V.size(); i++) {\n        tree[V[i]].clear();\n        root[V[i]] = 1;\n    }\n    for(int i = 0; i < V.size(); i++) {\n        int u = V[i];\n        if(dir[u]) {\n            int x = P[u].first;\n            for(int j = 0; j < Vx[x].size(); j++) {\n                if(Vx[x][j].second == u) break;\n                tree[u].push_back(Vx[x][j].second);\n                root[Vx[x][j].second] = 0;\n            }\n        }\n        else {\n            int y = P[u].second;\n            for(int j = 0; j < Vy[y].size(); j++) {\n                if(Vy[y][j].second == u) break;\n                tree[u].push_back(Vy[y][j].second);\n                root[Vy[y][j].second] = 0;\n            }\n        }\n    }\n\n    int ret = 1;\n    for(int i = 0; i < V.size(); i++) if(root[V[i]]) {\n        int t = dfs2(V[i]);\n        ret = 1LL * ret * t % mod;\n        ret = 1LL * ret * invf[ sz[V[i]] ] % mod;\n    }\n    ret = 1LL * ret * fact[ V.size() ] % mod;\n    return ret;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < MN; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < 2 * N; i++) {\n        scanf(\"%d %d\", &P[i].first, &P[i].second);\n        P[i].first--;\n        P[i].second--;\n\n        Vx[ P[i].first ].push_back(pii(P[i].second, i));\n        Vy[ P[i].second ].push_back(pii(P[i].first, i));\n    }\n    for(int i = 0; i < N; i++) {\n        sort(Vx[i].begin(), Vx[i].end());\n        sort(Vy[i].begin(), Vy[i].end());\n\n        for(int j = 0; j < (int)Vx[i].size() - 1; j++) {\n            int u = Vx[i][j].second;\n            int v = Vx[i][j + 1].second;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        for(int j = 0; j < (int)Vy[i].size() - 1; j++) {\n            int u = Vy[i][j].second;\n            int v = Vy[i][j + 1].second;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n    }\n\n    memset(tin, -1, sizeof(tin));\n    ans = 1;\n    for(int i = 0; i < 2 * N; i++) if(tin[i] == -1) {\n        cycle.clear();\n        V.clear();\n        if(!dfs0(i, -1)) {\n            printf(\"0\");\n            return 0;\n        }\n\n        int mxy = -1, mnx = 1e9, mxx = -1, p1 = -1, p2 = -1;\n        for(int j = 0; j < cycle.size(); j++) {\n            int u = cycle[j];\n            if(mxy < P[u].second) {\n                mxy = P[u].second;\n                mnx = P[u].first;\n                mxx = P[u].first;\n                p1 = u;\n                p2 = u;\n            }\n            else if(mxy == P[u].second) {\n                if(mnx > P[u].first) mnx = P[u].first, p1 = u;\n                if(mxx < P[u].first) mxx = P[u].first, p2 = u;\n            }\n        }\n\n        int tmp = solve(p1) + solve(p2);\n        tmp %= mod;\n        ans = 1LL * ans * tmp % mod;\n        ans = 1LL * ans * invf[ V.size() ] % mod;\n    }\n    ans = 1LL * ans * fact[2 * N] % mod;\n\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\tconst int p = 1000000007;\n\tconst int N = 2e5 + 5;\n\n\tint n, vis[N], fac[N], inv[N], invfac[N], size[N], fa[N], onloop[N];\n\tvector<int> E[N], tr[N], node, loop;\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tvoid init()\n\t{\n\t\tfac[0] = invfac[0] = inv[1] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfac[i] = (ll)fac[i - 1] * i % p;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tinv[i] = (ll)inv[p % i] * (p - p / i) % p;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tinvfac[i] = (ll)invfac[i - 1] * inv[i] % p;\n\t}\n\n\tvoid dfs1(const int u, const int f)\n\t{\n\t\tvis[u] = 1;\n\t\tnode.push_back(u);\n\t\tfor (auto v : E[u])\n\t\t\tif (v != f && !vis[v])\n\t\t\t\tdfs1(v, u);\n\t}\n\n\tbool findloop(const int u, const int f)\n\t{\n\t\tstatic int top, sta[N], in[N];\n\t\tsta[++top] = u, in[u] = 1;\n\t\tfor (auto v : E[u])\n\t\t\tif (v != f)\n\t\t\t{\n\t\t\t\tif (in[v])\n\t\t\t\t{\n\t\t\t\t\tdo \t\t\n\t\t\t\t\t{\n\t\t\t\t\t\tloop.push_back(sta[top]);\n\t\t\t\t\t\tonloop[sta[top--]] = 1;\n\t\t\t\t\t}\n\t\t\t\t\twhile (sta[top + 1] != v);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (findloop(v, u))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t--top, in[u] = 0;\n\t\treturn false;\n\t}\n\n\tvoid dfs2(const int u)\n\t{\n\t\tfor (auto v : E[u])\n\t\t\tif (v != fa[u] && !onloop[v])\n\t\t\t\tfa[v] = u, dfs2(v);\n\t}\n\n\tvoid dfs3(const int u)\n\t{\n\t\tsize[u] = 1;\n\t\tfor (auto v : tr[u])\n\t\t\tdfs3(v), size[u] += size[v];\n\t}\t\n\n\tint calc()\n\t{\n\t\tstatic int in[N];\n\t\tfor (auto i : node)\n\t\t\tfor (auto j : E[i])\n\t\t\t\tif (j < fa[i])\n\t\t\t\t\ttr[i].push_back(j), ++in[j];\n\t\tfor (auto i : node)\n\t\t\tif (!in[i])\n\t\t\t\ttr[0].push_back(i);\n\t\tdfs3(0);\n\t\ttr[0].clear();\n\t\tfor (auto i : node)\n\t\t\ttr[i].clear(), in[i] = 0;\n\t\tint ans = fac[size[0] - 1];\n\t\tfor (auto i : node)\n\t\t\tans = (ll)ans * inv[size[i]] % p;\n\t\treturn ans;\n\t}\n\n\tint solve(const int x)\n\t{\n\t\tnode.clear();\n\t\tdfs1(x, 0);\n\t\tint nc = node.size(), ec = 0;\n\t\tfor (auto i : node)\n\t\t\tec += E[i].size();\n\t\tif ((ec >> 1) != nc)\n\t\t\treturn 0;\n\n\t\tloop.clear();\n\t\tfindloop(x, 0);\n\t\tfor (auto i : loop)\n\t\t\tdfs2(i);\n\n\t\tint tot = loop.size(), u = loop[tot - 1], v = loop[0];\n\t\tfor (int i = 1; i < tot; i++)\n\t\t\tif (loop[i - 1] + loop[i] > u + v)\n\t\t\t\tu = loop[i - 1], v = loop[i];\n\t\tE[u].erase(find(E[u].begin(), E[u].end(), v));\n\t\tE[v].erase(find(E[v].begin(), E[v].end(), u));\n\n\t\tfa[loop[0]] = loop[tot - 1];\n\t\tfor (int i = 1; i < tot; i++)\n\t\t\tfa[loop[i]] = loop[i - 1];\n\t\tint sum = calc();\n\n\t\tfa[loop[tot - 1]] = loop[0];\n\t\tfor (int i = 1; i < tot; i++)\n\t\t\tfa[loop[i - 1]] = loop[i];\n\t\treturn int((ll)(sum + calc()) % p * invfac[nc] % p);\n\t}\n\n\tvoid work()\n\t{\n\t\tn = read() << 1;\n\t\tinit();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint x = read(), y = read() + (n >> 1);\n\t\t\tE[x].push_back(y);\n\t\t\tE[y].push_back(x);\n\t\t}\n\t\tint ans = fac[n];\n\t\tfor (int i = 1; i <= n && ans; i++)\n\t\t\tif (!vis[i])\n\t\t\t\tans = (ll)ans * solve(i) % p;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\nint main()\n{\n#ifdef DINO\n\tfreopen(\"3537.in\", \"r\", stdin);\n\tfreopen(\"3537.out\", \"w\", stdout);\n#endif\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 400005;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct MATH\n{\n\tll fac[MX], faci[MX], ivx[MX];\n\t\n\tvoid init()\n\t{\n\t\tivx[0] = ivx[1] = fac[0] = faci[0] = 1;\n\t\tfor(int i=2; i<MX; i++) ivx[i] = (MOD*MOD - 1ll*(MOD/i)*ivx[MOD%i]) % MOD;\n\t\tfor(int i=1; i<MX; i++) fac[i] = fac[i-1]*i%MOD, faci[i] = faci[i-1]*ivx[i]%MOD;\n\t}\n\t\n\tll C(int n, int m)\n\t{\n\t\tif(m>n || m<0 || n<0) return 0;\n\t\telse return fac[n] * faci[m] % MOD * faci[n-m] % MOD;\n\t}\n} M;\n\nstruct GRAPH\n{\n\tint fst[MX], nxt[MX], v[MX], lnum;\n\tint ind[MX];\n\t\n\tvoid addeg(int nu, int nv)\n\t{\n\t\t//cout<<nu<<\" \"<<nv<<endl;\n\t\tnxt[++lnum] = fst[nu];\n\t\tfst[nu] = lnum;\n\t\tv[lnum] = nv;\n\t\tind[nv]++;\n\t}\n} G, H1, H2;\n\nint n;\n\nvoid input()\n{\n\tint x, y;\n\tread(n);\n\tfor(int i=1; i<=n*2; i++)\n\t{\n\t\tread(x), read(y);\n\t\tG.addeg(x, n+y);\n\t\tG.addeg(n+y, x);\n\t}\n}\n\nvoid check_validity(int x, int *ecnt, int *vcnt, GRAPH &g, int *vis, vector<int> &pot)\n{\n\tpot.push_back(x);\n\tvis[x] = 1, (*vcnt)++;\n\tfor(int i=g.fst[x]; i; i=g.nxt[i])\n\t{\n\t\t(*ecnt)++;\n\t\tif(vis[g.v[i]]) continue;\n\t\telse check_validity(g.v[i], ecnt, vcnt, g, vis, pot);\n\t}\n}\n\nint loops, loopt;\n\nvoid get_loop_tree(int x, int f, GRAPH &g, int *vis)\n{\n\tvis[x] = 1;\n\tfor(int i=g.fst[x]; i; i=g.nxt[i])\n\t{\n\t\tif(vis[g.v[i]] && g.v[i]!=f) loops = x, loopt = g.v[i];\n\t\telse if(!vis[g.v[i]]) get_loop_tree(g.v[i], x, g, vis);\n\t}\n}\n\nvoid cal_subtree(int x, int f, GRAPH &g, GRAPH &h, int *vis)\n{\n\tvis[x] = 1;\n\tfor(int i=g.fst[x]; i; i=g.nxt[i])\n\t{\n\t\tif(!vis[g.v[i]] && g.v[i] != f)\n\t\t{\n\t\t\tcal_subtree(g.v[i], x, g, h, vis);\n\t\t\tif(g.v[i] < f) h.addeg(x, g.v[i]);\n\t\t}\n\t\telse if(x==loops && g.v[i]==loopt && g.v[i]<f) h.addeg(x, g.v[i]);\n\t\telse if(x==loopt && g.v[i]==loops && g.v[i]<f) h.addeg(x, g.v[i]);\n\t}\n}\n\nint siz[MX];\n\nll cal_topo(int x, int f, const GRAPH &g)\n{\n\tll ret = 1;\n\tsiz[x] = 1;\n\tfor(int i=g.fst[x]; i; i=g.nxt[i])\n\t\tif(!siz[g.v[i]])\n\t\t{\n\t\t\tret = ret * cal_topo(g.v[i], x, g) % MOD;\n\t\t\tsiz[x] += siz[g.v[i]];\n\t\t}\n\treturn ret * M.ivx[siz[x]] % MOD;\n}\n\nll get_way(const GRAPH &h, const vector<int> &pot)\n{\n\tll tmp = 1;\n\tfor(auto p : pot) siz[p] = 0;\n\tfor(auto p : pot)\n\t\tif(!siz[p] && !h.ind[p])\n\t\t\ttmp = tmp * cal_topo(p, 0, h) % MOD;\n\treturn tmp % MOD;\n}\n\nint vis1[MX], vis2[MX], vis3[MX], vis4[MX];\n\nvoid work()\n{\n\tll ans = 1;\n\tint tot = 0;\n\tfor(int i=1; i<=n*2; i++)\n\t{\n\t\tvector<int> pot;\n\t\tll tmp = 0;\n\t\tint ecnt = 0, vcnt = 0;\n\t\tif(!vis1[i])\n\t\t{\n\t\t\tcheck_validity(i, &ecnt, &vcnt, G, vis1, pot);\n\t\t\tif(ecnt != vcnt*2) ans = 0;\n\t\t\tget_loop_tree(i, 0, G, vis2);\n\t\t\t//cout<<\"constructing T1:\"<<endl;\n\t\t\tcal_subtree(loops, loopt, G, H1, vis3);\n\t\t\t//cout<<\"constructing T2:\"<<endl;\n\t\t\tcal_subtree(loopt, loops, G, H2, vis4);\n\t\t\ttmp = get_way(H1, pot) + get_way(H2, pot);\n\t\t\tans = ans * M.fac[vcnt] % MOD * tmp % MOD * M.C(tot+vcnt, tot) % MOD;\n\t\t\ttot += vcnt;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tM.init();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int maxn=2e5+10;\nconst int mo=1e9+7;\n\nint n,root,Ans=1,tote=1,edge;\nint fa[maxn],fw[maxn],tmp[maxn];\nint fac[maxn],ifac[maxn],vis[maxn],q[maxn];\nint FIR[maxn],TO[maxn*2],NEXT[maxn*2],W[maxn*2];\nbool vise[maxn*2];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nvoid addedge(int u,int v,int w)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tW[tote]=w;\n\tFIR[u]=tote;\n}\n\nvoid dfs1(int u,int F)\n{\n\tif (vis[u]==1) {root=u; return;}\n\tvis[u]=1;\n\tq[++q[0]]=u;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (v==F) continue;\n\t\tif (!vise[p]) edge++,vise[p]=vise[p^1]=1;\n\t\tdfs1(v,u);\n\t}\n}\n\nvoid dfs2(int u)\n{\n\tif (vis[u]==2) return;\n\tvis[u]=2;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (v==fa[u]) continue;\n\t\tfa[v]=u;\n\t\tfw[v]=w;\n\t\tdfs2(v);\n\t}\n}\n\nnamespace Tree{\n\tint n,fa[maxn],dp[maxn],sz[maxn];\n\tint tote,FIR[maxn],TO[maxn<<1],NEXT[maxn<<1];\n\n\tvoid addedge(int u,int v)\n\t{\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t\tfa[v]=u;\n\t}\n\n\tbool dfs(int u)\n\t{\n\t\tif (dp[u]) return 0;\n\t\tsz[u]=0;\n\t\tdp[u]=1;\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!dfs(v)) return 0;\n\t\t\tsz[u]+=sz[v];\n\t\t\tdp[u]=(LL)dp[u]*dp[v]%mo;\n\t\t\tdp[u]=(LL)dp[u]*ifac[sz[v]]%mo;\n\t\t}\n\t\tdp[u]=(LL)dp[u]*fac[sz[u]]%mo;\n\t\tsz[u]++;\n\t\treturn 1;\n\t}\n\n\tvoid solve(int &Ans)\n\t{\n\t\tint i,u;\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n\t\t\tif (!fa[u]) addedge(0,u);\n\t\t}\n\t\tfor (i=1;i<=q[0];i++) u=q[i];\n\t\tif (!dfs(0)) {Ans=0; return;}\n\t\t(Ans+=dp[0])%=mo;\n\t\tfor (i=1;i<=q[0];i++)\n\t\t\tu=q[i],FIR[u]=fa[u]=dp[u]=sz[u]=0;\n\t\tFIR[0]=fa[0]=dp[0]=sz[0]=0;\n\t\ttote=0;\n\t}\n};\n\nvoid dfs3(int u)\n{\n\tif (vis[u]==3) return;\n\tvis[u]=3;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs3(v);\n\t}\n}\n\nvoid dfs4(int u)\n{\n\tif (vis[u]==4) return;\n\tvis[u]=4;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs4(v);\n\t}\n}\n\nint main()\n{\n\tint i,u,v;\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor (i=1;i<=n+n;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[n+n]=power(fac[n+n],mo-2);\n\tfor (i=n+n;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tfor (i=1;i<=n+n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,n+v,u+v);\n\t\taddedge(n+v,u,u+v);\n\t}\n\tfor (i=1;i<=n+n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tq[0]=0;\n\t\t\troot=0;\n\t\t\tedge=0;\n\t\t\tdfs1(i,0);\n\t\t\tif (!root||edge!=q[0]) {puts(\"0\"); return 0;}\n\t\t\tdfs2(root);\n\t\t\tint Sum=0;\n\t\t\tdfs3(root);\n\t\t\tTree::solve(Sum);\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\ttmp[fa[u]]=fw[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\tfw[u]=tmp[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\t\t\tdfs4(root);\n\t\t\tTree::solve(Sum);\n\t\t\tAns=(LL)Ans*Sum%mo;\n\t\t\tAns=(LL)Ans*ifac[q[0]]%mo;\n\t\t}\n\tAns=(LL)Ans*fac[n+n]%mo;\n\tprintf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tint sz=V[x].size();\n\t\tref(i,0,sz-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\t/*\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n\t*/\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=200100,mod=1000000007;\ntypedef long long ll;\nvoid gofail(){cout<<0<<'\\n';exit(0);}\n\nvector<int>vts,cir,g[N],g2[N];\nstack<int>S;\nint dfn[N],clk,fa[N],n,ans,inv[N],incir[N];\n\nvoid dfs(int x,int fa=-1){\n\tdfn[x]=++clk;vts.push_back(x);S.push(x);\n\tfor(int i:g[x])if(i!=fa){\n\t\tif(!dfn[i])dfs(i,x);\n\t\telse if(dfn[i]<dfn[x]){\n\t\t\tif(!cir.empty())gofail();\n\t\t\tfor(;S.top()!=i;S.pop())cir.push_back(S.top());\n\t\t\tcir.push_back(i);S.pop();\n\t\t}\n\t}\n\tif(!S.empty()&&S.top()==x)S.pop();\n}\nint sz[N];\nint gsz(int x){\n\tif(sz[x])return sz[x];sz[x]=1;\n\tfor(int i:g2[x])sz[x]+=gsz(i);\n\treturn sz[x];\n}\n\nvoid setfa(int x){\n\tfor(int i:g[x])if(i!=fa[x])fa[i]=x,setfa(i);\n}\n\nint solve(){\n\tint ret=1;\n\tfor(int i:vts){\n\t\tg2[i].clear();sz[i]=0;\n\t\tfor(int j:g[i])if(j<fa[i])g2[i].push_back(j);\n\t}\n\tfor(int i:vts)ret=(ll)ret*inv[gsz(i)]%mod;\n\treturn ret;\n}\n\nvoid Init(){\n\tinv[1]=ans=1;\n\tfor(int i=2;i<=n;++i)inv[i]=mod-mod/i*(ll)inv[mod%i]%mod,ans=(ll)ans*i%mod;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;n*=2;Init();\n\tfor(int i=1;i<=n;++i){\n\t\tint x,y;cin>>x>>y;y+=n/2;\n\t\tg[x].push_back(y);g[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;++i)if(!dfn[i]){\n\t\tvts.clear();cir.clear();dfs(i);if(cir.empty())gofail();\n\t\tint tmp=0;\n\t\tfor(int j:cir)incir[j]=1;\n\t\tfor(int j:cir)\n\t\t\tfor(int k:g[j])if(!incir[k])fa[k]=j,setfa(k);\n\t\tint la=cir.back();\n\t\tfor(int j:cir)fa[j]=la,la=j;tmp=(tmp+solve())%mod;\n\t\tla=cir.back();\n\t\tfor(int j:cir)fa[la]=j,la=j;tmp=(tmp+solve())%mod;\n\t\tans=(ll)ans*tmp%mod;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=2e5+7;\nvi G[maxn];\nvi lp;\nint ce=0,cc;\nconst int mod=1e9+7;\nbool vis[maxn],ins[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nint st[maxn];\nint p;\nint sz[maxn];\nvi cG;\nvoid dfs(int u,int fa=-1)\n{\n    vis[u]=1;\n    ins[u]=1;\n    st[p++]=u;\n    cc++;\n    for(auto v:G[u])\n    {\n        if(v!=fa)\n        {\n            if(ins[v])\n            {\n                ce++;\n                for(int i=p-1;st[i]!=v;i--)\n                    lp.push_back(st[i]);\n                lp.push_back(v);\n            }\n            if(!vis[v]) ce++,dfs(v,u);\n        }\n    }\n    ins[u]=0;\n    p--;\n}\nint n;\nbool vv[maxn];\nvi used;\nll cursz;\nvi nG[maxn];\nvoid dfs2(int u,int fa)\n{\n    vv[u]=1;\n    used.push_back(u);\n    for(auto v:G[u])\n    {\n        if(v==fa) continue;\n        if(!vv[v])\n            dfs2(v,u);\n        if(v<fa) {\n            nG[u].push_back(v);\n        }\n    }\n}\nbool v3[maxn];\nvoid dfs3(int u)\n{\n    if(v3[u]) return;\n    v3[u]=1;\n    sz[u]=1;\n    for(auto v:nG[u])\n    {\n        dfs3(v);\n        sz[u]+=sz[v];\n    }\n    cursz=cursz*sz[u]%mod;\n    //dbg(u,sz[u]);\n}\nint main()\n{\n    cin>>n;\n    for(int i=0,x,y;i<2*n;i++)\n    {\n        cin>>x>>y;\n        G[x].push_back(y+n);\n        G[y+n].push_back(x);\n    }\n    for(int i=1;i<=2*n;i++) sort(G[i].begin(),G[i].end());\n    ll ans=1;\n    for(int i=1;i<=2*n;i++)\n    {\n        if(!vis[i])\n        {\n            ce=cc=0;\n            p=0;\n            lp.clear();\n            dfs(i);\n            //dbg(lp);\n            if(ce!=cc)\n            {\n                ans=0;\n                break;\n            }\n            cursz=1;\n            dfs2(lp[1],lp[0]);\n            for(auto v:used) \n            {\n                dfs3(v);\n                vv[v]=0;\n            }\n            //dbg(cursz);\n            ll tmp=inv(cursz);\n            for(auto v:used) nG[v].clear(),v3[v]=0;\n            used.clear();\n            dfs2(lp[0],lp[1]);\n            cursz=1;\n            for(auto v:used)\n            {\n                dfs3(v);\n                vv[v]=0;\n            }\n            used.clear();\n            cursz=(inv(cursz)+tmp)%mod;\n            ans=(ans*cursz)%mod;\n        }\n    }\n    for(int i=1;i<=2*n;i++) ans=ans*i%mod;\n    print(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nvoid update(int &x,int y) {\n\tx = inc(x,y);\n}\nstruct node {\n\tint to,next;\n}E[MAXN * 4];\nint x[MAXN],y[MAXN],N,fac[MAXN],invfac[MAXN];\nmap<pii,int> zz;\nint head[MAXN],sumE;\nbool vis[MAXN];\nint sum,Ncnt,fa[MAXN],s,t,pos[MAXN],par[MAXN];\nvector<int> c[MAXN],r[MAXN],rec,cyc;\nint rpos[MAXN],cpos[MAXN],siz[MAXN];\nvector<int> son[MAXN];\nvoid add(int u,int v) {\n\tE[++sumE].to = v;\n\tE[sumE].next = head[u];\n\thead[u] = sumE;\n}\npii depos(int a,int b) {\n\tif(a > b) swap(a,b);\n\tb -= N;\n\treturn mp(a,b);\n}\nbool dfs(int u) {\n\t++Ncnt;\n\tbool flag = 0;\n\tvis[u] = 1;\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t\t++sum;\n\t\tint v = E[i].to;\n\t\tif(!vis[v]) {\n\t\t\tfa[v] = u;\n\t\t\tif(dfs(v)) {\n\t\t\t\tflag = 1;\n\t\t\t\tpos[zz[depos(u,v)]] = u;\n\t\t\t}\n\t\t}\n\t\telse if(v != fa[u] && !flag){\n\t\t\ts = u,t = v;\n\t\t\tflag = 1;\n\t\t\trec.pb(zz[depos(u,v)]);\n\t\t}\n\t}\n\tif(!flag && fa[u]) {\n\t\tpos[zz[depos(u,fa[u])]] = u;\n\t}\n\tif(fa[u]) rec.pb(zz[depos(u,fa[u])]);\n\treturn flag;\n}\nint Calc(int u) {\n\tsiz[u] = 1;\n\tint res = 1;\n\tfor(auto v : son[u]) {\n\t\tres = mul(res,Calc(v));\n\t\tres = mul(res,invfac[siz[v]]);\n\t\tsiz[u] += siz[v];\n\t}\n\tres = mul(res,fac[siz[u] - 1]);\n\treturn res;\n}\nint Process() {\n\tint res = 0;\n\tfor(auto t : rec) par[t] = 0;\n\tfor(auto t : rec) {\n\t\tif(pos[t] > N) {\n\t\t\tfor(int i = 0 ; i < cpos[t] ; ++i) {\n\t\t\t\tpar[zz[mp(c[y[t]][i],y[t])]] = t;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int i = 0 ; i < rpos[t] ; ++i) {\n\t\t\t\tpar[zz[mp(x[t],r[x[t]][i])]] = t;\n \t\t\t}\n\t\t}\n\t\tson[t].clear();\n\t}\n\tson[0].clear();\n\tfor(auto t : rec) {\n\t\tson[par[t]].pb(t);\n\t}\n\treturn Calc(0);\n}\nvoid Solve() {\n\tread(N);\n\tfor(int i = 1 ; i <= 2 * N ; ++i) {\n\t\tread(x[i]);read(y[i]);add(x[i],y[i] + N);add(y[i] + N,x[i]);\n\t\tzz[mp(x[i],y[i])] = i;\n\t\tr[x[i]].pb(y[i]);c[y[i]].pb(x[i]);\n\t}\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tsort(r[i].begin(),r[i].end());\n\t\tsort(c[i].begin(),c[i].end());\n\t\tfor(int j = 1 ; j < r[i].size() ; ++j) rpos[zz[mp(i,r[i][j])]] = j;\n\t\tfor(int j = 1 ; j < c[i].size() ; ++j) cpos[zz[mp(c[i][j],i)]] = j;\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1 ; i <= 2 * N ; ++i) fac[i] = mul(fac[i - 1],i);\n\tinvfac[2 * N] = fpow(fac[2 * N],MOD - 2);\n\tfor(int i = 2 * N - 1 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n\tint ans = fac[2 * N];\n\tfor(int i = 1 ; i <= 2 * N ; ++i) {\n\t\tif(!vis[i]) {\n\t\t\tsum = 0;Ncnt = 0;\n\t\t\trec.clear();\n\t\t\tdfs(i);\n\t\t\tans = mul(ans,invfac[Ncnt]);\n\t\t\tif(Ncnt * 2 != sum) {puts(\"0\");return;}\n\t\t\tint p = s;\n\t\t\tcyc.clear();\n\t\t\twhile(1) {\n\t\t\t\tcyc.pb(p);\n\t\t\t\tif(p == t) break;\n\t\t\t\tp = fa[p];\n\t\t\t}\n\t\t\tint tmp = 0;\n\t\t\tcyc.pb(s);\n\t\t\tfor(int i = 0 ; i < cyc.size() - 1 ; ++i) {\n\t\t\t\tpos[zz[depos(cyc[i],cyc[i + 1])]] = cyc[i];\n\t\t\t}\n\t\t\tupdate(tmp,Process());\n\t\t\tfor(int i = cyc.size() - 1 ; i >= 1 ; --i) {\n\t\t\t\tpos[zz[depos(cyc[i],cyc[i - 1])]] = cyc[i];\n\t\t\t}\n\t\t\tupdate(tmp,Process());\n\t\t\tans = mul(ans,tmp);\n\t\t}\n\t}\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 2e+5+5;\nconst int mo = 1e+9+7;\n\nint n;\nstruct edge{\n\tint x,nxt;\n}e[N*2];\nint h[N],tot;\nint r[N];\nbool vis[N];\nint he,ta,k,sum;\nint que[N],cir[N],m;\nLL js[N],inv[N];\nint fa[N],dep[N];\nbool bz[N];\nLL ans;\nint xx[N],yy[N],kx,ky;\nint to[N],a[N],pk;\nint lef[N],rig[N];\nint siz[N];\n\nvoid inse(int x,int y){e[++tot].x=y;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid dfs(int x){\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (!bz[e[p].x]&&!to[e[p].x]){\n\t\tto[e[p].x]=x;\n\t\tdfs(e[p].x);\n\t}\n}\n\nLL solve_tree(int x){\n\tsiz[x]=1;\n\tLL tmp=1;\n\tfor(int y=lef[x];y;y=rig[y]){\n\t\ttmp=tmp*solve_tree(y);\n\t\tsiz[x]+=siz[y];\n\t\ttmp=tmp*inv[siz[y]]%mo;\n\t}\n\ttmp=tmp*js[siz[x]-1]%mo;\n\treturn tmp;\n}\n\nLL solve(){\n\tfo(i,1,k)r[que[i]]=lef[que[i]]=rig[que[i]]=0;\n\tfo(i,1,k){\n\t\tint x=que[i];\n\t\tif (x<to[to[x]]){\n\t\t\trig[x]=lef[to[x]];\n\t\t\tlef[to[x]]=x;\n\t\t\tr[x]=1;\n\t\t}\n\t}\n\tLL val=1;\n\tfo(i,1,k)\n\tif (!r[que[i]]){\n\t\tLL tmp=solve_tree(que[i]);\n\t\tval=val*tmp%mo*inv[siz[que[i]]]%mo;\n\t}\n\tval=val*js[k]%mo;\n\treturn val;\n}\n\nvoid bfs(int st){\n\the=0,ta=1;\n\tvis[que[1]=st]=dep[st]=1;\n\tsum=0;\n\twhile(he<ta){\n\t\tint x=que[++he];\n\t\tsum+=r[x];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (!vis[e[p].x]){\n\t\t\tfa[e[p].x]=x;\n\t\t\tdep[e[p].x]=dep[x]+1;\n\t\t\tvis[que[++ta]=e[p].x]=1;\n\t\t}\n\t}\n\tk=ta;\n\tsum/=2;\n\tif (sum!=k){ans=0;return;}\n\tint keyx=0,keyy;\n\tfo(i,1,k){\n\t\tint x=que[i];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (fa[e[p].x]!=x&&fa[x]!=e[p].x)keyx=x,keyy=e[p].x;\n\t\tif (keyx)break;\n\t}\n\tkx=ky=1;\n\txx[1]=keyx;yy[1]=keyy;\n\twhile(keyx!=keyy){\n\t\tif (dep[keyx]>dep[keyy])xx[++kx]=keyx=fa[keyx];\n\t\telse yy[++ky]=keyy=fa[keyy];\n\t}\n\tpk=kx+ky-1;\n\tfo(i,1,kx)a[i]=xx[i];\n\tfo(i,1,ky)a[pk-i+1]=yy[i];\n\tLL tmp=0;\n\tfo(i,1,pk)bz[a[i]]=1;\n\tfo(i,1,pk){\n\t\tto[a[i]]=a[i%pk+1];\n\t\tdfs(a[i]);\n\t}\n\ttmp=solve();\n\tfo(i,1,pk)to[a[i%pk+1]]=a[i];\n\ttmp=(tmp+solve())%mo;\n\tans=ans*tmp%mo;\n\tans=ans*inv[k]%mo;\n}\n\nint main(){\n\tn=get()*2;\n\tjs[0]=inv[0]=js[1]=inv[1]=1;\n\tfo(i,2,n)js[i]=js[i-1]*i%mo,inv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;\n\tfo(i,1,n)inv[i]=inv[i]*inv[i-1]%mo;\n\tfo(i,1,n){\n\t\tint x=get(),y=get()+n/2;\n\t\tinse(x,y),inse(y,x);\n\t\tr[x]++,r[y]++;\n\t}\n\tans=1;\n\tfo(i,1,n)\n\tif (!vis[i])bfs(i);\n\tans=ans*js[n]%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define cbn(u,y) ((LL)fac[u]*inv[y]%mod*inv[(u)-(y)]%mod)\n\nconst int mod=1e9+7;\nstruct Combin{\n\t#define N 400005\n\tint fac[N],rv[N],facrv[N];\n\tCombin(){\n\t\tfac[0]=rv[1]=facrv[0]=1;\n\t\tfor(int i=2;i<N;i++) rv[i]=((-(LL)(mod/i)*rv[mod%i]%mod)+mod)%mod;\n\t\tfor(int i=1;i<N;i++) fac[i]=(LL)fac[i-1]*i%mod;\n\t\tfor(int i=1;i<N;i++) facrv[i]=(LL)facrv[i-1]*rv[i]%mod;\n\t}\n\tint C(int r1,int n1){\n\t\tif(r1>n1) return 0;\n\t\treturn fac[n1]*(LL)facrv[r1]%mod*facrv[n1-r1]%mod;\n\t}\n\t#undef N\n}C;\n\n#define N 200005\nusing namespace std;\nstruct edge{\n    int d,t,next;//d=x+y\n}e[N*2];int ecnt,head[N];\nvoid addedge(int dp,int t,int d){\n    e[++ecnt]=(edge){d,t,head[dp]};head[dp]=ecnt;\n    e[++ecnt]=(edge){d,dp,head[t]};head[t]=ecnt;\n}\n\nint medge,sta[N],top,vis[N],vise[N];\nvoid dfsc(int u,int fr_edge){//染色\n\tvis[u]=1;sta[++top]=u;\n\tfor(int i=head[u],y;i;i=e[i].next) \n        if((i^1)!=fr_edge){\n            if (vise[i>>1]==0) vise[i>>1]=1,medge++;\n            if (vis[e[i].t]==0) dfsc(e[i].t,i);\n\t    }\n}\n\nint fre[N],mxp;//mxp 连通块中最右上角的点\nvoid dfsp(int u,int fr_edge){//找到环上权值最大的边\n\tvis[u]=2;\n\tfor(int i=head[u];i;i=e[i].next)\n        if((i^1)!=fr_edge){\n            if (vis[e[i].t]!=2){\n                fre[e[i].t]=i;\n                dfsp(e[i].t,i);\n            }else if(mxp==0){//找到环了\n                mxp=i;\n                for (int t=u;t!=e[i].t;t=e[fre[t]^1].t)\n                    if (e[fre[t]].d>e[mxp].d) mxp=fre[t];\n            }\n\t    }\n}\n\nint n,m,ans;\nint dp[N],sz[N];\nvoid calc(int u,int fr_edge){\n\tsz[u]=dp[u]=1;\n\tfor(int i=head[u];i;i=e[i].next)\n        if(((i^1)!=fr_edge)&&(i>>1)!=(mxp>>1)){\n            calc(e[i].t,i);\n            if(e[i].d>e[fr_edge].d){\n                ans=(LL)ans*dp[e[i].t]%mod*C.facrv[sz[e[i].t]]%mod;\n            }else{\n                sz[u]+=sz[e[i].t];\n                dp[u]=(LL)dp[u]*dp[e[i].t]%mod*C.C(sz[e[i].t],sz[u]-1)%mod;\n            }\n    \t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);ecnt=1;\n\tfor(int i=1,x,y;i<=n*2;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y+n,x+y);\n\t}\n\n\tint sum=C.fac[n*2],tot;\n\tfor(int i=1,v;i<=n*2;i++)\n        if(vis[i]==0){\n            mxp=medge=top=tot=0;\n            dfsc(i,0);\n            if(medge!=top) return puts(\"0\"),0;\n            dfsp(i,0);\n\n            v=e[mxp].t,ans=1,calc(v,mxp);\n            ans=(LL)ans*dp[v]%mod*C.facrv[sz[v]]%mod;\n            tot+=ans;\n\n            v=e[mxp^1].t,ans=1,calc(v,mxp);\n            ans=(LL)ans*dp[v]%mod*C.facrv[sz[v]]%mod;\n            tot+=ans;\n\n            sum=(LL)sum*tot%mod;\n    \t}\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\n#include<set>\n#define lowbit(o) o&(-o)\n#define P 1000000007\n#define N 200005\nusing namespace std;\nint i,j,k,l,s,r,n,m,jc[N],ny[N],fa[N],A[2][N],B[2][N],tot,T,vis[2][N],id[N];\nint ans,Ans,si,G[N];\nset<int>GT[2][N],V[2][N];\nset<int>::iterator GTW;\nstruct orz {\n\tint x,y;\n}a[N],q[N],Q[N];\nstruct node {\n\tint tot,last[N],to[N],next[N];\n\tinline void add(int x,int y) {\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A1;\nstruct Node {\n\tint tot,chu[N],ru[N],l,r,last[N],next[N],to[N],f[N],si[N];\n\torz q[N];\n\tinline void add(int x,int y) {\n\t\tchu[x]++; ru[y]++;\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A2;\ninline bool cmp(int x,int y) {\n\treturn G[x]<G[y];\n}\ninline int findl(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=0;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]<x) s=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn s+1;\n}\ninline int findr(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=2*n+1;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]>x) s=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn s-1;\n}\ninline int quick(int x,int y) {\n\tint s=1;\n\twhile (y) {\n\t\tif (y&1) s=1ll*s*x%P;\n\t\tx=1ll*x*x%P;\n\t\ty>>=1;\n\t}\n\treturn s;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\ninline int C(int x,int y) {\n\treturn 1ll*jc[x]*ny[y]%P*ny[x-y]%P;\n}\ninline int getans(int r) {\n\tT=s=0;\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].insert(q[i].y);\n//\tfor (int i=0;i<=1;i++) for (int j=1;j<=n;j++) if (get(i*n+j)==get(q[1].x*n+q[1].y)) {\n\tint L=findl(get(q[1].x*n+q[1].y)),R=findr(get(q[1].x*n+q[1].y));\n\tfor (int i=L;i<=R;i++) {\n\t\ts++;\n\t\tQ[++T].x=(id[i]-1)/n,Q[T].y=(id[i]-1)%n+1;\n\t\tif (A[Q[T].x][Q[T].y]) {\n \t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>A[Q[T].x][Q[T].y]) break;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>B[Q[T].x][Q[T].y]) break;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t}\n\tA2.l=A2.r=0;\n\tA2.f[A2.si[0]=0]=1;\n\tfor (int i=1;i<=T;i++) A2.f[Q[i].x*n+Q[i].y]=1;\n\tfor (int i=1;i<=T;i++) if (!A2.chu[Q[i].x*n+Q[i].y]) A2.add(Q[i].x*n+Q[i].y,0);\n\tfor (int i=1;i<=T;i++) if (!A2.ru[Q[i].x*n+Q[i].y]) A2.q[++A2.r].x=Q[i].x,A2.q[A2.r].y=Q[i].y;\n\twhile (A2.l<A2.r) {\n\t\tA2.l++;\n\t\tA2.si[A2.q[A2.l].x*n+A2.q[A2.l].y]++;\n\t\tfor (int i=A2.last[A2.q[A2.l].x*n+A2.q[A2.l].y];i;i=A2.next[i]) {\n\t\t\tA2.ru[A2.to[i]]--;\n\t\t\tA2.si[A2.to[i]]+=A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y];\n\t\t\t(A2.f[A2.to[i]]=1ll*A2.f[A2.to[i]]*A2.f[A2.q[A2.l].x*n+A2.q[A2.l].y]%P*C(A2.si[A2.to[i]],A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y])%P);\n\t\t\tif (!A2.ru[A2.to[i]]) A2.q[++A2.r].x=(A2.to[i]-1)/n,A2.q[A2.r].y=(A2.to[i]-1)%n+1;\n\t\t}\n\t}\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].erase(q[i].y);\n\tA2.tot=0;\n\tfor (int i=1;i<=A2.r;i++) A2.last[A2.q[i].x*n+A2.q[i].y]=0,A2.chu[A2.q[i].x*n+A2.q[i].y]=A2.ru[A2.q[i].x*n+A2.q[i].y]=0;\n\tfor (int i=1;i<=T;i++) A2.f[A2.q[i].x*n+A2.q[i].y]=A2.si[A2.q[i].x*n+A2.q[i].y]=0;\n\treturn A2.f[0];\n}\ninline void work(int x,int y) {\n\tvis[x][y]=1;\n\tint l=0,r=1; q[1].x=x,q[1].y=y;\n\twhile (l<r) {\n\t\t++l;\n\t\tfor (GTW=GT[q[l].x][q[l].y].begin();GTW!=GT[q[l].x][q[l].y].end();GTW++) if (!vis[q[l].x^1][(*GTW)]) q[++r].x=q[l].x^1,q[r].y=(*GTW),vis[q[r].x][q[r].y]=1;\n\t}\n\tfor (int i=1;i<=r;i++) for (GTW=GT[q[i].x][q[i].y].begin();GTW!=GT[q[i].x][q[i].y].end();GTW++) A1.add(q[i].x*n+q[i].y,(*GTW));\n\tint xx=x,yy=y;\n\tB[xx][yy]=A1.to[A1.last[xx*n+yy]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) if (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tAns=getans(r);\n\t\n\tfor (int i=1;i<=r;i++) B[q[i].x][q[i].y]=0;\n\tB[xx][yy]=A1.to[A1.next[A1.last[xx*n+yy]]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) if (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tA1.tot=0;\n\tfor (int i=1;i<=r;i++) A1.last[q[i].x*n+q[i].y]=0;\n\t(Ans+=getans(r))%=P;\n\tsi+=s;\n\t(ans=1ll*ans*Ans%P*C(si,s)%P);\n}\ninline void doit() {\n\tjc[0]=1;\n\tfor (int i=1;i<=200000;i++) jc[i]=1ll*jc[i-1]*i%P;\n\tny[200000]=quick(jc[200000],P-2);\n\tfor (int i=199999;i;i--) ny[i]=1ll*ny[i+1]*(i+1)%P;\n\tny[0]=1;\n}\nint main() {\n\tdoit();\n\tans=1; si=0;\n\tscanf(\"%d\",&n);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) fa[i*n+j]=i*n+j;\n\tfor (i=1;i<=2*n;i++) {\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tif (get(a[i].x)!=get(n+a[i].y)) fa[get(a[i].x)]=get(n+a[i].y);\n\t\tGT[0][a[i].x].insert(a[i].y);\n\t\tGT[1][a[i].y].insert(a[i].x);\n\t}\n\tfor (i=1;i<=2*n;i++) if (get(id[i]=i)==i) G[i]=++tot;\n\tfor (i=1;i<=2*n;i++) G[i]=G[get(i)];\n\ttot=0;\n\tsort(id+1,id+1+2*n,cmp);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!GT[i][j].size()) return puts(\"0\"),0;\n\telse if (GT[i][j].size()==1) q[++r].x=i,q[r].y=j;\n\twhile (l<r) {\n\t\t++l;\n\t\tif (!GT[q[l].x][q[l].y].size()) return puts(\"0\"),0;\n\t\tA[q[l].x][q[l].y]=(*GT[q[l].x][q[l].y].begin());\n\t\tGT[q[l].x^1][A[q[l].x][q[l].y]].erase(q[l].y);\n\t\tif (GT[q[l].x^1][A[q[l].x][q[l].y]].size()==1) q[++r].x=q[l].x^1,q[r].y=A[q[l].x][q[l].y];\n\t}\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (A[i][j]) V[i^1][A[i][j]].insert(j);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!vis[i][j]&&GT[i][j].size()==2) \n\twork(i,j);\n\tprintf(\"%d\\n\",ans);\n}\n "
  },
  {
    "language": "C++",
    "code": "#include \"bits//stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n\n#define rep(i,n) for (int i = 0; i < (n); i++)\n#define ALL(v) v.begin(), v.end()\n\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\n\nvector<ll> fact;\nvector<ll> inv_fact;\n\nvoid comb_init(int n) {\n\tfact.resize(n + 1);\n\tinv_fact.resize(n + 1);\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n}\n\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\n\nset<int> G[200000];\nset<int> tmp[200000];\nvector<int> forest[200000];\nvector<int> comp;\nint in[200000];\nbool vis[200000];\nint collect[200000];\nll dp[200000];\nint sum[200000];\n\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tcomp.push_back(v);\n\tfor (int to : G[v]) {\n\t\tif (vis[to]) continue;\n\t\tdfs(to);\n\t}\n}\nll calc(int v) {\n\tsum[v] = 1;\n\tif (forest[v].size() == 0) return dp[v] = 1;\n\tfor (int child : forest[v]) {\n\t\tcalc(child);\n\t\tsum[v] += sum[child];\n\t}\n\tll ans = 1;\n\tint rest = sum[v] - 1;\n\tfor (int child : forest[v]) {\n\t\t(ans *= comb(rest, sum[child])) %= MOD;\n\t\t(ans *= dp[child]) %= MOD;\n\t\trest -= sum[child];\n\t}\n\treturn dp[v] = ans;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tcomb_init(2 * N);\n\trep(i, 2 * N) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tG[y].insert(x + N);\n\t\tG[x + N].insert(y);\n\t\ttmp[y].insert(x + N);\n\t\ttmp[x + N].insert(y);\n\t}\n\tll ans = 1;\n\tint tot= 2 * N;\n\trep(i, 2 * N) {\n\t\tif (vis[i]) continue;\n\t\tcomp.clear();\n\t\tdfs(i);\n\t\tint deg = 0;\n\t\tfor (int v : comp) deg += G[v].size();\n\t\tif (comp.size() != deg / 2) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tqueue<int> leaf;\n\t\tfor (int v : comp) if (tmp[v].size() == 1) leaf.push(v);\n\t\twhile (!leaf.empty()) {\n\t\t\tint x = leaf.front(); leaf.pop();\n\t\t\tint y = *tmp[x].begin();\n\t\t\tcollect[x] = y;\n\t\t\ttmp[x].erase(y);\n\t\t\ttmp[y].erase(x);\n\t\t\tif (tmp[y].size() == 1) leaf.push(y);\n\t\t}\n\t\tint head = -1;\n\t\tfor (int v : comp) {\n\t\t\tif (tmp[v].size()) {\n\t\t\t\thead = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tll mul = 0;\n\t\tfor (int to : tmp[head]) {\n\t\t\tcollect[head] = to;\n\t\t\tint prev = head;\n\t\t\tint now = to;\n\t\t\twhile (now != head) {\n\t\t\t\tfor (int x : tmp[now]) {\n\t\t\t\t\tif (x != prev) {\n\t\t\t\t\t\tcollect[now] = x;\n\t\t\t\t\t\tprev = now;\n\t\t\t\t\t\tnow = x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int v : comp) in[v] = 0;\n\t\t\tfor (int v : comp) {\n\t\t\t\tforest[v].clear();\n\t\t\t\tfor (int x : G[v]) {\n\t\t\t\t\tif (x < collect[v]) {\n\t\t\t\t\t\tforest[v].push_back(x);\n\t\t\t\t\t\tin[x]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll t = 1;\n\t\t\tint rest = comp.size();\n\t\t\tfor (int v : comp) {\n\t\t\t\tif (in[v] == 0) {\n\t\t\t\t\tcalc(v);\n\t\t\t\t\t(t *= comb(rest, sum[v])) %= MOD;\n\t\t\t\t\t(t *= dp[v]) %= MOD;\n\t\t\t\t\trest -= sum[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\t(mul += t) %= MOD;\n\t\t}\n\t\t(ans *= mul) %= MOD;\n\t\t(ans *= comb(tot, comp.size())) %= MOD;\n\t\ttot -= comp.size();\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200005; \nconst long long mod = 1000000007; \n\nusing namespace std;\n\nint n, T; \n\nbool oncir[N], vis[N]; \nint num, sum, cir[N], cur[N]; \n\nint tp, sta[N]; \nbool insta[N]; \n\nint match[N], ind[N], siz[N]; \nlong long f[N]; \n\nvector< int > G[N]; \nvector< int > S[N]; \n\nlong long fac[N], inv[N]; \n\nlong long Pow(long long a, long long e) {\n\tlong long ret=1, cnt=a;\n\twhile(e) {\n\t\tif(e & 1) ret = ret * cnt % mod;\n\t\tcnt = cnt * cnt % mod; \n\t\te >>= 1; \n\t} \n\treturn ret; \n}\n\nvoid prepare() {\n\tfac[1] = 1; \n\tfor(int i=2; i<=n; ++i) fac[i] = fac[i-1] * i % mod; \n\tinv[n] = Pow(fac[n], mod-2); \n\tfor(int i=n-1; i>=0; --i) inv[i] = inv[i+1] * (i+1) % mod;  \n}\n\nlong long C(int n, int m) {\n\treturn fac[n] * inv[n-m] % mod * inv[m] % mod; \n}\n\nvoid dfs_Circle(int u, int f) {\n\tif(insta[u]) {\n\t\tint now; \n\t\tdo {\n\t\t\tnow = sta[tp--];\n\t\t\tinsta[now] = 0; \n\t\t\tcir[++num] = now; \n\t\t\toncir[now] = 1; \n\t\t}while(now != u); \n\t\t++T; \n\t\treturn ; \n\t}\n\tvis[u] = 1; \n\tinsta[u] = 1; \n\tsta[++tp] = u; \n\tcur[++sum] = u; \n\tfor(int v : G[u]) {\n\t\tif(v == f || oncir[v]) continue; \n\t\tdfs_Circle(v, u); \n\t}\n\tinsta[u] = 0; \n\tsta[tp--] = 0; \n}\n\nvoid dfs_Tree(int u, int f) {\n\tmatch[u] = f; \n\tfor(int v : G[u]) {\n\t\tif(oncir[v] || v == f) continue; \n\t\tdfs_Tree(v, u); \n\t}\n}\n\nvoid dfs_calc(int u) {\n\tf[u] = 1; \n\tsiz[u] = 0; \n\tfor(int v : S[u]) {\n\t\tdfs_calc(v);\n\t\tsiz[u] += siz[v]; \n\t\tf[u] = 1ll * f[u] * f[v] % mod * C(siz[u], siz[v]) % mod; \n\t}\n\t++siz[u]; \n}\n\nlong long calc() {\n\tfor(int i=1; i<=sum; ++i) ind[cur[i]] = 0; \n\tfor(int i=1; i<=sum; ++i) {\n\t\tint u = cur[i];\n\t\tS[u].clear(); \n\t\tfor(int v : G[u]) {\n\t\t\tif(v == match[u]) break; \n\t\t\tS[u].push_back(v); \n\t\t\t++ind[v]; \n\t\t}\n\t}\n\tS[0].clear();\n\tfor(int i=1; i<=sum; ++i) \n\t\tif(!ind[cur[i]]) S[0].push_back(cur[i]);\n\tdfs_calc(0);\n\treturn f[0];  \n}\n\nint main() {\n\t\n\tint u, v; \n\t\n\tint psum=0; \n\tlong long ans = 1; \n\t\n\tcin >> n; \n\tfor(int i=1; i<=(n<<1); ++i) {\n\t\tcin >> u >> v;  \n\t\tG[u].push_back(v+n); \n\t\tG[v+n].push_back(u); \n\t}\n\t\n\tn <<= 1; \n\tfor(int i=1; i<=n; ++i) sort(G[i].begin(), G[i].end()); \n\t\n\tprepare(); \n\t\n\tfor(int i=1; i<=n; ++i) {\n\t\t\n\t\tif(vis[i]) continue; \n\t\t\n\t\tT = sum = num = tp = 0; \n\t\tdfs_Circle(i, 0); \n\t\t\n\t\tif(T > 1) {\n\t\t\tans = 0; \n\t\t\tbreak; \n\t\t}\n\t\t\n\t\tfor(int j=1; j<=num; ++j) dfs_Tree(cir[j], 0); \n\t\t\n\t\tlong long tmp = 0; \n\t\t\n\t\tfor(int j=2; j<=num; ++j) match[cir[j]] = cir[j-1]; \n\t\tmatch[cir[1]] = cir[num]; \n\t\ttmp += calc(); \n\t\t\n\t\tfor(int j=1; j<num; ++j)  match[cir[j]] = cir[j+1];\n\t\tmatch[cir[num]] = cir[1];\n\t\ttmp += calc(); \n\t\t\n\t\tpsum += sum; \n\t\tans = 1ll * ans * tmp % mod * C(psum, sum) % mod; \n\t\t\n\t}\n\t\n\tcout << ans << endl; \n\t\n\treturn 0; \n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define mod 1000000007\n#define next nxt\n \nint n,x[N],y[N],z[N],next[N],p[N],h[N],q[N],f[N],g[N],s[N],cnt,cmt,cir;\nlong long fac[N],inv[N],ans;\nvector<int> v[N];\n \nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n \nvoid travel(int x,int pre){\n\th[x]=true;q[++cnt]=x;\n\tfor (int t=p[x];t;cmt++,t=next[t])\n\t\tif (!h[y[t]]) travel(y[t],t);\n\t\telse if (t/2!=pre/2) cir=t;\n}\n \nvoid build(int x,int pre){\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (t/2!=pre/2){\n\t\t\tif (y[t]<g[x]) v[x].push_back(y[t]),f[y[t]]=true;\n\t\t\tif (t/2!=cir/2) g[y[t]]=x,build(y[t],t);\n\t\t}\n}\n \nlong long solve(int x){\n\ts[x]=0;long long ans=1;\n\tfor (int i=0;i<(int)v[x].size();i++){\n\t\tans=ans*solve(v[x][i])%mod;\n\t\ts[x]+=s[v[x][i]];\n\t\tans=ans*C(s[x],s[v[x][i]])%mod;\n\t}\n\ts[x]++;return ans;\n}\n \nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n \nint main(){\n\tn=read();\n\tfor (int i=1;i<=2*n;i++){\n\t\tx[2*i]=y[2*i+1]=read();\n\t\ty[2*i]=x[2*i+1]=n+read();\n\t\tz[2*i]=z[2*i+1]=x[2*i]+y[2*i];\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t\tnext[2*i+1]=p[x[2*i+1]];p[x[2*i+1]]=2*i+1;\n\t}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tans=fac[2*n];\n\tfor (int i=1;i<=2*n;i++)\n\t\tif (!h[i]){\n\t\t\tcnt=cmt=0;travel(i,0);\n\t\t\tif (cmt!=cnt*2) {printf(\"0\\n\");return 0;}\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),g[q[i]]=0,f[q[i]]=false;\n\t\t\tg[x[cir]]=y[cir];build(x[cir],cir);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!f[q[i]]) v[0].push_back(q[i]);\n\t\t\tlong long tmp=solve(0);\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),g[q[i]]=0,f[q[i]]=false;\n\t\t\tg[y[cir]]=x[cir];build(y[cir],cir);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!f[q[i]]) v[0].push_back(q[i]);\n\t\t\ttmp+=solve(0);\n\t\t\t\n\t\t\tans=ans*tmp%mod*inv[cnt]%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll fac[200010],finv[200010];\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll merge(ll a,ll b,ll asz,ll bsz){\n  ll f=((finv[asz]*finv[bsz])%mod)*fac[asz+bsz]%mod;\n  return ((f*a)%mod)*b%mod;\n}\n\nint N;\nvector<int> g[200001],t[200010];\nbool vis1[200010],vis2[200010];\nll ecnt=0;\nvector<int> vs,loop;\nint nxt[200001],indeg[200010];\nll tsz[200010];\n\nll predfs(int v){\n  vs.push_back(v);\n  vis1[v]=true;\n  ll sz=1;\n  for(int nv : g[v]){\n    ecnt++;\n    if(vis1[nv])continue;\n    sz+=predfs(nv);\n  }\n  return sz;\n}\n\nint dfs(int v,int pre){\n  vis2[v]=true;\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    if(vis2[nv]){\n      loop.push_back(nv); return nv;\n    }\n    int tmp=dfs(nv,v);\n    if(tmp!=-1){\n      if(nv==tmp) return -1;\n      else{\n        loop.push_back(nv); return tmp;\n      }\n    }\n  }\n  return -1;\n}\n\nll dfs2(int v){\n  vis2[v]=true;\n  ll res=1;\n  tsz[v]=0;\n  for(int nv : t[v]){\n    ll tmp=dfs2(nv);\n    res=merge(res,tmp,tsz[v],tsz[nv]);\n    tsz[v]+=tsz[nv];\n  }\n  tsz[v]++;\n  return res;\n}\n\nvoid dfs3(int v,int pre){\n  nxt[v]=pre;\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    dfs3(nv,v);\n  }\n}\n\nll calc(int v){\n  int V=vs.size();\n  rep(i,V)vis2[vs[i]]=false;\n  dfs(v,-1);\n\n  int L=loop.size();\n\n  ll sum=0;\n  ll res1=1,res2=1;\n  { // +\n    rep(i,V)nxt[vs[i]]=-1;\n    rep(i,L){\n      nxt[loop[i]]=loop[(i+1)%L];\n      int crt=loop[i];\n      for(int nv : g[crt]){\n        if(nv==loop[(i+1)%L]||nv==loop[(i-1+L)%L])continue;\n        dfs3(nv,crt);\n      }\n    }\n    rep(i,V){\n      int crt=vs[i];\n      for(int nv : g[crt]){\n        if(nv<nxt[crt]){\n          t[crt].push_back(nv); indeg[nv]++;\n        }\n      }\n    }\n    rep(i,V)vis2[vs[i]]=false;\n    rep(i,V){\n      if(vis2[vs[i]]||indeg[vs[i]]>0)continue;\n      ll add=dfs2(vs[i]);\n      res1=merge(res1,add,sum,tsz[vs[i]]);\n      sum+=tsz[vs[i]];\n    }\n  }\n\n  sum=0;\n  { // +\n    rep(i,V){\n      nxt[vs[i]]=-1; indeg[vs[i]]=0;\n      t[vs[i]].clear(); tsz[vs[i]]=0;\n    }\n    rep(i,L){\n      nxt[loop[i]]=loop[(i-1+L)%L];\n      int crt=loop[i];\n      for(int nv : g[crt]){\n        if(nv==loop[(i+1)%L]||nv==loop[(i-1+L)%L])continue;\n        dfs3(nv,crt);\n      }\n    }\n    rep(i,V){\n      int crt=vs[i];\n      for(int nv : g[crt]){\n        if(nv<nxt[crt]){\n          t[crt].push_back(nv); indeg[nv]++;\n        }\n      }\n    }\n    rep(i,V)vis2[vs[i]]=false;\n    rep(i,V){\n      if(vis2[vs[i]]||indeg[vs[i]]>0)continue;\n      ll add=dfs2(vs[i]);\n      res2=merge(res2,add,sum,tsz[vs[i]]);\n      sum+=tsz[vs[i]];\n    }\n  }\n\n  return (res1+res2)%mod;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  fac[0]=1;\n  rep(i,200000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,200001)finv[i]=mod_pow(fac[i],mod-2);\n\n  cin>>N;\n  rep(i,2*N){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    g[x].push_back(N+y);\n    g[N+y].push_back(x);\n  }\n\n  ll res=1;\n  ll sum=0;\n  rep(i,2*N){\n    if(vis1[i])continue;\n    vs.clear(); ecnt=0;\n    ll sz=predfs(i); ecnt/=2;\n    if(sz!=ecnt) res=0;\n    else res=merge(res,calc(i),sum,sz);\n    sum+=sz;\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nllint fact[200005], fact_inv[200005];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 200005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 200005; i++){\n\t\tfact_inv[i] = modpow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint n;\nllint x[200005], y[200005];\nvector<llint> G[200005];\nUnionFind uf(200005);\nmap<llint, vector<llint> > mp;\nvector<llint> cmp[200005];\n\nbool used[200005];\nbool cycled[200005];\nbool pointed[200005];\nvector<llint> g[200005], g2[200005];\n\nvector<llint> cycle;\nint cycledfs(int v, int pre)\n{\n\tif(used[v]) return v;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == pre) continue;\n\t\tint res = cycledfs(G[v][i], v);\n\t\tif(res){\n\t\t\tcycle.push_back(v);\n\t\t\tcycled[v] = true;\n\t\t\tif(res == v) return 0;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid treedfs(int v, int pre)\n{\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == pre) continue;\n\t\tif(cycled[G[v][i]]) continue;\n\t\tg[G[v][i]].push_back(v);\n\t\ttreedfs(G[v][i], v);\n\t}\n}\n\nllint merge(llint a, llint b)\n{\n\treturn comb(a+b, b);\n}\n\nP cntdfs(llint v)\n{\n\tllint len = 0, ret = 1;\n\tfor(int i = 0; i < g2[v].size(); i++){\n\t\tP res = cntdfs(g2[v][i]);\n\t\tret *= res.first, ret %= mod;\n\t\tret *= merge(len, res.second), ret %= mod;\n\t\tlen += res.second;\n\t}\n\tlen++;\n\treturn make_pair(ret, len);\n}\n\nllint calc2(llint c)\n{\n\tfor(int i = 0; i < cmp[c].size(); i++) g2[cmp[c][i]].clear();\n\tfor(int i = 0; i < cmp[c].size(); i++){\n\t\tint v = cmp[c][i];\n\t\tif(g[g[v][0]][0] > v) g2[g[v][0]].push_back(v);\n\t}\n\t\n\tfor(int i = 0; i < cmp[c].size(); i++) pointed[cmp[c][i]] = false;\n\tfor(int i = 0; i < cmp[c].size(); i++){\n\t\tint v = cmp[c][i];\n\t\tfor(int j = 0; j < g2[v].size(); j++){\n\t\t\tpointed[g2[v][j]] = true;\n\t\t}\n\t}\n\t\n\tllint len = 0, ret = 1;\n\tfor(int i = 0; i < cmp[c].size(); i++){\n\t\tif(!pointed[cmp[c][i]]){\n\t\t\tP res = cntdfs(cmp[c][i]);\n\t\t\tret *= res.first, ret %= mod;\n\t\t\tret *= merge(len, res.second), ret %= mod;\n\t\t\tlen += res.second;\n\t\t}\n\t}\n\treturn ret;\n}\n\nllint calc(llint c)\n{\n\tcycle.clear();\n\tcycledfs(cmp[c][0], -1);\n\tfor(int i = 0; i < cycle.size(); i++) treedfs(cycle[i], -1);\n\t\n\tllint ret = 0;\n\tint C = cycle.size();\n\tfor(int i = 0; i < C; i++) g[cycle[i]].push_back(cycle[(i+1)%C]);\n\tret += calc2(c), ret %= mod;\n\t\n\tfor(int i = 0; i < C; i++) g[cycle[i]].clear();\n\tfor(int i = 0; i < C; i++) g[cycle[i]].push_back(cycle[(i-1+C)%C]);\n\tret += calc2(c), ret %= mod;\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tmake_fact();\n\t\n\tcin >> n;\n\tfor(int i = 1; i <= 2*n; i++) cin >> x[i] >> y[i];\n\tfor(int i = 1; i <= 2*n; i++){\n\t\tG[x[i]].push_back(y[i]+n);\n\t\tG[y[i]+n].push_back(x[i]);\n\t\tuf.unite(x[i], y[i]+n);\n\t}\n\t\n\tfor(int i = 1; i <= 2*n; i++) mp[uf.root(i)].push_back(i);\n\tllint id = 0;\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tfor(int i = 0; i < it->second.size(); i++){\n\t\t\tcmp[id].push_back(it->second[i]);\n\t\t}\n\t\tid++;\n\t}\n\t\n\tfor(int i = 0; i < id; i++){\n\t\tllint e = 0;\n\t\tfor(int j = 0; j < cmp[i].size(); j++) e += G[cmp[i][j]].size();\n\t\tif(e/2 != cmp[i].size()){\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tllint ans = 1, len = 0;\n\tfor(int i = 0; i < id; i++){\n\t\tllint tmp = calc(i);\n\t\tans *= tmp, ans %= mod;\n\t\tans *= merge(len, cmp[i].size()), ans %= mod;\n\t\tlen += cmp[i].size();\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nconst int mod=1e9+7;\nint n,ans;\nint x[maxn],y[maxn],par[maxn],dep[maxn],deg[maxn];\nbool vis[maxn],incyc[maxn];\nvector<int>edge[maxn],cyc,nedge[maxn],path,qryx[maxn],qryy[maxn];\nint fac[maxn],ifac[maxn],dp[maxn],sz[maxn];\nbool ok;\nvector<pii>xs[maxn],ys[maxn];\n\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nvoid dfs1(int x,int p,int d){\n\tvis[x]=true;\n\tpar[x]=p;\n\tdep[x]=d;\n\tpath.pb(x);\n\trep(i,edge[x].size()){\n\t\tint y=edge[x][i];\n\t\tif(y==p||incyc[y])continue;\n\t\tif(!vis[y])dfs1(y,x,d+1);\n\t\telse if(dep[y]<dep[x]){\n\t\t\tif(!cyc.empty()){\n\t\t\t\tok=false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint z=x;\n\t\t\twhile(z!=y)cyc.pb(z),z=par[z];\n\t\t\tcyc.pb(z);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x){\n\tdp[x]=1;\n\tsz[x]=0;\n\trep(i,nedge[x].size()){\n\t\tint y=nedge[x][i];\n\t\tdfs2(y);\n\t\tdp[x]=1LL*dp[x]*C(sz[x]+sz[y],sz[y])%mod*dp[y]%mod; \n\t\tsz[x]+=sz[y];\n\t}\n\tsz[x]++;\n}\n\nvoid add(int cur,int nxt){\n\tif(cur<=n){\n\t\tint pos=lower_bound(xs[cur].begin(),xs[cur].end(),mp(nxt-n,0))-xs[cur].begin();\n\t\tqryx[cur].pb(pos);\n\t}\n\telse{\n\t\tint pos=lower_bound(ys[cur-n].begin(),ys[cur-n].end(),mp(nxt,0))-ys[cur-n].begin();\n\t\tqryy[cur-n].pb(pos);\n\t}\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2*n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,2*n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tREP(i,2*n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\txs[x[i]].pb(mp(y[i],i));\n\t\tys[y[i]].pb(mp(x[i],i));\n\t\tedge[x[i]].pb(y[i]+n);\n\t\tedge[y[i]+n].pb(x[i]);\n\t}\n\tREP(i,n){\n\t\tsort(xs[i].begin(),xs[i].end());\n\t\tsort(ys[i].begin(),ys[i].end());\n\t}\n\tans=1;\n\tint tsz=0;\n\tREP(i,2*n)if(!vis[i]){\n\t\tok=true;\n\t\tcyc.clear();\n\t\tpath.clear();\n\t\tdfs1(i,0,0);\n\t\tif(cyc.empty())ok=false;\n\t\tif(!ok){\n\t\t\tans=0;\n\t\t\tbreak;\n\t\t}\n\t\trep(j,cyc.size())incyc[cyc[j]]=true;\n\t\trep(j,path.size())vis[path[j]]=false;\n\t\tpath.clear();\n\t\trep(j,cyc.size())dfs1(cyc[j],0,0);\n\t\tint sum=0;\n\t\tvector<int>v;\n\t\trep(j,path.size()){\n\t\t\tint x=path[j];\n\t\t\tif(x<=n)rep(k,xs[x].size())v.pb(xs[x][k].snd);\n\t\t\telse rep(k,ys[x-n].size())v.pb(ys[x-n][k].snd);\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tv.resize(unique(v.begin(),v.end())-v.begin());\n\t\tfor(int t=-1;t<=1;t+=2){\n\t\t\trep(j,path.size())if(!incyc[path[j]])add(path[j],par[path[j]]);\n\t\t\trep(j,cyc.size())add(cyc[j],cyc[(j+t+int(cyc.size()))%int(cyc.size())]);\n\t\t\trep(j,path.size()){\n\t\t\t\tint x=path[j];\n\t\t\t\tif(x<=n){\n\t\t\t\t\tsort(qryx[x].begin(),qryx[x].end());\n\t\t\t\t\tint last=0;\n\t\t\t\t\trep(k,qryx[x].size()){\n\t\t\t\t\t\tfor(int p=last;p<qryx[x][k];p++){\n\t\t\t\t\t\t\tnedge[xs[x][qryx[x][k]].snd].pb(xs[x][p].snd);\n\t\t\t\t\t\t\tdeg[xs[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryx[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryx[x].clear();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx-=n;\n\t\t\t\t\tsort(qryy[x].begin(),qryy[x].end());\n\t\t\t\t\tint last=0;\n\t\t\t\t\trep(k,qryy[x].size()){\n\t\t\t\t\t\tfor(int p=last;p<qryy[x][k];p++){\n\t\t\t\t\t\t\tnedge[ys[x][qryy[x][k]].snd].pb(ys[x][p].snd);\n\t\t\t\t\t\t\tdeg[ys[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryy[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryy[x].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cur=1,csz=0;\n\t\t\trep(j,v.size())if(!deg[v[j]]){\n\t\t\t\tdfs2(v[j]);\n\t\t\t\tcur=1LL*cur*dp[v[j]]%mod*C(csz+sz[v[j]],sz[v[j]])%mod;\n\t\t\t\tcsz+=sz[v[j]];\n\t\t\t}\n\t\t\trep(j,v.size())nedge[v[j]].clear(),deg[v[j]]=0;\n\t\t\tsum=(sum+cur)%mod;\n\t\t}\n\t\tans=1LL*ans*sum%mod*C(tsz+v.size(),v.size())%mod;\n\t\ttsz+=v.size();\n\t}\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            chain_t c = use_generic(i, true);\n            return c * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            chain_t c = use_generic(i, false);\n            return c * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        REP (y, n) acc = acc * go_row(y);\n        REP (x, n) acc = acc * go_col(x);\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                // assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define run(x) for(int k=head[x];k;k=e[k].ne)\n#define v e[k].t\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<int,int> pa;\nconst int N=4e6+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);\n}\nll fac[N],ifac[N],f[N];\nint siz[N],vis[N],cnt=1,n;\nstruct edge{int s,t,ne,w;}e[N];\nint head[N];\nll C(ll n,ll m){\n\tif(n<0||m<0||n-m<0)return 0;\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint cv,ce,pre[N],S,mx;\nvoid dfs(int x,int f){\n\tvis[x]=1;cv++;\n\trun(x){\n\t\tce++;\n\t\tif(!vis[v]){pre[v]=k,dfs(v,x);}else\n\t\t\tif(v!=f&&!S)S=k;\n\t}\n}\nll qaq=1;\nvoid calc(int x,int lase){\n\tsiz[x]=0;f[x]=1;\n\trun(x)if(k!=lase&&(k/2!=mx/2)){\n\t\tcalc(v,k^1);\n\t\tif(e[k].w>e[lase].w){\n\t\t\tqaq=qaq*ifac[siz[v]]%mod*f[v]%mod;\n\t\t}else{\n\t\t\tsiz[x]+=siz[v];\n\t\t\tf[x]=f[x]*f[v]%mod*C(siz[x],siz[v])%mod;\n\t\t}\n\t}\n\tsiz[x]++;\n}\nvoid adde(int a,int b,int c){e[++cnt]=(edge){a,b,head[a],c};head[a]=cnt;}\nint main(){\n\tread(n);fac[0]=1;rep(i,1,n+n)fac[i]=fac[i-1]*i%mod;\n\tifac[n+n]=qpow(fac[n+n],mod-2,mod);\n\trepd(i,n+n-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\trep(i,1,n+n){\n\t\tint x,y;read(x,y);y+=n;\n\t\tadde(x,y,x+y);adde(y,x,x+y);\n\t}ll res=fac[n+n];\n\trep(i,1,n+n)if(!vis[i]){\n\t\tS=0;cv=ce=0;dfs(i,0);\n\t\tif(cv*2!=ce)return puts(\"0\"),0;mx=S;\n\t\tfor(int o=S;e[o].s!=e[S].t;o=pre[e[o].s],mx=(e[mx].w<e[o].w?o:mx));\n\t\tll all=0;\n\t\tint x=e[mx].s;\n\t\tqaq=1;calc(x,mx);\n\t\tall+=ifac[siz[x]]*f[x]%mod*qaq%mod;\n\t\tx=e[mx].t;\n\t\tqaq=1;calc(x,mx);\n\t\tall+=ifac[siz[x]]*f[x]%mod*qaq%mod;\n\t\tres=res*all%mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1000000007;\ninline int rd(){\n\tchar c=getchar();int x=0;\n\tfor(;c<'0'||c>'9';c=getchar());\n\tfor(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x;\n}\nint n,ans=1;\nint a[200010],fa[200010],dep[200010],size[200010];\nbool vis[200010]={false};\nvector<int>vec[200010],v,vv;\nint power(int x,int k){\n\tint res=1,s=x;\n\tfor(;k;k>>=1){\n\t\tif(k&1)\n\t\t\tres=(ll)res*s%mod;\n\t\ts=(ll)s*s%mod;\n\t}\n\treturn res;\n}\nint solve(int root){\n\tv.clear();v.push_back(root);\n\tvis[root]=true;\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i];\n\t\tsize[x]=1;fa[x]=0;a[x]=0;\n\t\tfor(int j=0;j<vec[x].size();j++){\n\t\t\tint y=vec[x][j];\n\t\t\tif(!vis[y]){\n\t\t\t\tv.push_back(y);\n\t\t\t\tvis[y]=true;\n\t\t\t}\n\t\t}\n\t}\n\tint total=0;\n\tfor(int i=0;i<v.size();i++)\n\t\tfor(int j=0;j<vec[v[i]].size();j++)\n\t\t\ta[vec[v[i]][j]]++,total++;\n\tif(total/2!=v.size())\n\t\treturn 0;\n\tvv.clear();\n\tfor(int i=0;i<v.size();i++)\n\t\tif(a[v[i]]==1)\n\t\t\tvv.push_back(v[i]);\n\tfor(int i=0;i<vv.size();i++){\n\t\tint x=vv[i];\n\t\tfor(int j=0;j<vec[x].size();j++){\n\t\t\tint y=vec[x][j];\n\t\t\tif(--a[y]){\n\t\t\t\tfa[x]=y;\n\t\t\t\tif(a[y]==1)\n\t\t\t\t\tvv.push_back(y);\n\t\t\t\telse\n\t\t\t\t\troot=y;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x=root;;){\n\t\tfor(int i=0;i<vec[x].size();i++){\n\t\t\tint y=vec[x][i];\n\t\t\tif(a[y]>1&&fa[y]!=x){\n\t\t\t\tfa[x]=y;x=y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(x==root)\n\t\t\tbreak;\n\t}\n\tint res=1;\n\tfor(int i=0;i<vv.size();i++){\n\t\tint x=vv[i];\n\t\tres=(ll)res*size[x]%mod;\n\t\tif(x<fa[fa[x]])\n\t\t\tsize[fa[x]]+=size[x];\n\t}\n\tfor(int x=root;;){\n\t\tif(x>fa[fa[x]]){\n\t\t\troot=fa[x];\n\t\t\tbreak;\n\t\t}\n\t\tx=fa[x];\n\t\tif(x==root)\n\t\t\treturn 0;\n\t}\n\tfor(int x=root;;){\n\t\tres=(ll)res*size[x]%mod;\n\t\tif(x<fa[fa[x]])\n\t\t\tsize[fa[x]]+=size[x];\n\t\tx=fa[x];\n\t\tif(x==root)\n\t\t\tbreak;\n\t}\n\treturn power(res,mod-2);\n}\nint main(){\n\tn=rd();\n\tfor(int i=1;i<=n*2;i++)\n\t\tvec[i].clear();\n\tfor(int i=1;i<=n*2;i++){\n\t\tint x=rd(),y=rd();\n\t\tvec[x].push_back(n+y);\n\t\tvec[n+y].push_back(x);\n\t}\n\tfor(int i=1;i<=n*2;i++)\n\t\tans=(ll)ans*i%mod;\n\tfor(int i=1;i<=n*2;i++)\n\t\tif(!vis[i]){\n\t\t\tint res=solve(i);\n\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\tvis[v[j]]=false;\n\t\t\t\treverse(vec[v[j]].begin(),vec[v[j]].end());\n\t\t\t}\n\t\t\tres+=solve(i);\n\t\t\tif(res>=mod)\n\t\t\t\tres-=mod;\n\t\t\tans=(ll)ans*res%mod;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<vector<int>> g(2 * n);\n\trep(i, 2 * n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx --, y --;\n\t\tg[x].push_back(y + n);\n\t\tg[y + n].push_back(x);\n\t}\n\n\tvector<bool> used(n);\n\tset<pair<int, int>> eused;\n\tint ec = 0, nc = 0;\n\tfunction<void (int, int)> dfs = [&](int u, int prev) {\n\t\tnc ++;\n\t\tused[u] = true;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tif (eused.count(make_pair(min(u, v), max(u, v))) == 0) {\n\t\t\t\teused.insert(make_pair(min(u, v), max(u, v)));\n\t\t\t\tec ++;\n\t\t\t}\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t}\n\t\t}\n\t};\n\trep(i, 2 * n) if (!used[i]) {\n\t\tec = 0, nc = 0;\n\t\tdfs(i, -1);\n\t\tif (ec != nc) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tassert(false);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid read(T &x) \n{\n\tx = 0;\n\tint f = 1; char c = getchar();\n\twhile (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }\n\twhile (isdigit(c)) { x = x * 10 + c - 48; c = getchar(); }\n\tx *= f;\n}\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 4];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G, loop;\nint dfn[MAXN], fa[MAXN], s, t, cnt = 0, edge = 0;\nvoid GetLoop(int x) // 找环 \n{\n\tG.push_back(x); // 森林中的一棵树 \n\tdfn[x] = ++cnt;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == fa[x])\n\t\t\tcontinue;\n\t\tif (dfn[y]) \n\t\t{\n\t\t\tif (dfn[y] < dfn[x]) continue;\n\t\t\tloop.push_back(y);\n\t\t\tfor (; y != x; y = fa[y])\n\t\t\t\tloop.push_back(fa[y]);\n\t\t}\n\t\telse { fa[y] = x; GetLoop(y); }\n\t}\n} \n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[cnt];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tread(n);\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!dfn[i])\n\t\t{\n\t\t\tcnt = edge = 0;\n\t\t\tGetLoop(i);\n\t\t\tif (cnt << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\ts = loop[0], t = loop[loop.size() - 1]; // 环的起点、终点 \n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tloop.clear();\n\t\t\tG.clear();\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010,mo=int(1e9+7);\nstruct edge{int s,t,w,n;}e[2*N];\nint n,h[N],fac[N],ifac[N],vis[N],f[N],siz[N],ecnt,cnt,S,p,ans,res;\n\nint qpow(int a,int b)\n{\n\tint x=a;  a=1;\n\twhile (b)\n\t\t{\n\t\t\tif (b&1)  a=1LL*a*x%mo;\n\t\t\tx=1LL*x*x%mo,b>>=1;\n\t\t}\n\treturn a;\n}\n\nint C(int n,int m){return 1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo;}\n\nvoid dfs(int x,int fa)\n{\n\tvis[x]=1,cnt++;\n\tfor (int i=h[x],y; y=e[i].t,i; ecnt++,i=e[i].n)\n\t\tif (!vis[y])  f[y]=i,dfs(y,x);\n\t\telse  if ((y!=fa)&&(!S)) S=i;\n}\n\nvoid dfs2(int x,int fe)\n{\n\tsiz[x]=0,f[x]=1;\n\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\tif ((i!=fe)&&((i^p)>1))\n\t\t\t{\n\t\t\t\tdfs2(y,i^1);\n\t\t\t\tif (e[i].w>e[fe].w)  res=1LL*res*ifac[siz[y]]%mo*f[y]%mo;\n\t\t\t\telse  siz[x]+=siz[y],f[x]=1LL*f[x]*f[y]%mo*C(siz[x],siz[y])%mo;\n\t\t\t}\n\tsiz[x]++;\n}\n\nvoid work()\n{\n\tscanf(\"%d\",&n),fac[0]=1;\n\tfor (int i=1; i<=2*n; i++)  fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[2*n]=qpow(fac[2*n],mo-2);\n\tfor (int i=2*n; i; i--)  ifac[i-1]=1LL*ifac[i]*i%mo;\n\tfor (int i=1,x,y,tot=1; i<=2*n; i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&x,&y),y+=n;\n\t\t\te[++tot]=(edge){x,y,x+y,h[x]},h[x]=tot;\n\t\t\te[++tot]=(edge){y,x,x+y,h[y]},h[y]=tot;\n\t\t}\n\tans=fac[2*n];\n\tfor (int i=1,s; i<=2*n; i++)\n\t\tif (!vis[i])\n\t\t\t{\n\t\t\t\tecnt=cnt=S=s=0,dfs(i,0);\n\t\t\t\tif (cnt!=ecnt/2)  puts(\"0\"),exit(0);\n\t\t\t\tp=S;\n\t\t\t\tfor (int j=S; e[j].s!=e[S].t; j=f[e[j].s],p=(e[p].w<e[j].w?j:p));\n\t\t\t\tres=1,dfs2(e[p].s,p),s+=1LL*ifac[siz[e[p].s]]*f[e[p].s]%mo*res%mo;\n\t\t\t\tres=1,dfs2(e[p].t,p),s+=1LL*ifac[siz[e[p].t]]*f[e[p].t]%mo*res%mo;\n\t\t\t\tans=1LL*ans*s%mo;\n\t\t\t}\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\nconst int   mod = 1e9 + 7;\n\nvoid add(int&a,int b)   {   a += b; if (a >= mod)   a -= mod;   }\nvoid sub(int&a,int b)   {   a -= b; if (a <  0)     a += mod;   }\n\nint mul(int a,int b)    {   return  1ll * a * b % mod;  }\nint inv(int a,int p)    {   return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;    }\n\ntypedef pair<int,int>   ii;\n\nvector<int> g[N];\nvector<int> a[N];\n\nint p[N], s[N];\nint e[N], r[N];\n\nint lead(int x) {   return  x == p[x] ? x : p[x] = lead(p[x]);  }\nint join(int x,int y)   {\n    x = lead(x);\n    y = lead(y);\n\n    e[x]++;\n\n    if (x == y) return  0;\n    if (s[x] < s[y])\n        swap(x,y);\n    \n    p[y] = x;\n    s[x] += s[y];\n    e[x] += e[y];\n\n    return  1;\n}\nvector<int> vec[N];\n\nint Fac[N], Inv[N];\nint nxt[N], nCh[N];\nint ban[N];\n\nvoid Try(int u,int p)   {\n    nxt[u] = p;\n\n    for(int v : g[u])   if (v != p && ban[u] != v)\n        Try(v,u);\n}\nvoid dfs(int u) {\n    if (nCh[u])\n        return;\n        \n    nCh[u] = 1;\n\n    for(int v : a[u])\n        dfs(v),\n        nCh[u] += nCh[v];\n}\nint cal(int R)  {\n    int ans = 1;\n\n    for(int x : vec[R]) a[x] = vector<int>(g[x].begin(),lower_bound(all(g[x]),nxt[x]));\n    for(int x : vec[R]) dfs(x), ans = mul(ans,Inv[nCh[x]]);\n    for(int x : vec[R]) nCh[x] = 0;\n\n    //cerr << ans << \"\\n\";\n    return  ans;\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    Inv[1] = 1;\n    Fac[0] = Fac[1] = 1;\n\n    for(int i = 2 ; i < N ; ++i)\n        Inv[i] = mul(mod - mod / i,Inv[mod % i]),\n        Fac[i] = mul(Fac[i - 1],i);\n\n    int n;  cin >> n;\n\n    fill(ban,ban + n + n,-1);\n\n    iota(p,p + n + n,0);\n    fill(s,s + n + n,1);\n\n    vector<ii>  Cycle_Edges;\n\n    for(int i = 0 ; i < n + n ; ++i)    {\n        int x;  cin >> x;   x -= 1;\n        int y;  cin >> y;   y += n - 1;\n        \n        if(!join(x,y))  {\n            Cycle_Edges.pb(x,y);\n            ban[x] = y;\n            ban[y] = x;\n        }\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    for(int i = 0 ; i < n + n ; ++i)    sort(all(g[i]));\n    for(int i = 0 ; i < n + n ; ++i)    {\n        if (i == lead(i) && s[i] != e[i])   {\n            cout << 0;\n            return  0;\n        }\n        vec[p[i]].pb(i);\n    }\n    int ans = Fac[n + n];\n\n    for(ii  e : Cycle_Edges)    {\n        int R = lead(e.X);\n        int C = 0;\n\n        Try(e.X,e.Y);   add(C,cal(R));\n        Try(e.Y,e.X);   add(C,cal(R));\n\n        ans = mul(ans,C);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mo 1000000007\n#define M 400005\n#define ll long long\nint read() {\n\tint s=0,w=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-') w=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();\n\treturn s*w;\n}\nll ksm(ll a,int k) {\n\tll s=1;\n\twhile(k)\n\t{\n\t\tif(k&1) s=s*a%mo;\n\t\ta=a*a%mo;\n\t\tk>>=1;\n\t}\n\treturn s;\n}\nstruct edge{\n\tint t,nxt;\n}a[M*2],e[M*2];\nint h1[M],t1,h2[M],t2,du[M];\nvoid add(int st,int t) {\n\ta[++t1].nxt=h1[st],a[t1].t=t,h1[st]=t1;\n\tdu[st]++,du[t]++;\n}\nvoid Add(int st,int t) {\n\te[++t2].nxt=h2[st],e[t2].t=t,h2[st]=t2;\n}\nint n;\nll ans=1,jc[M];\nint col[M];\nvoid dfs1(int x,int fa) {\n\tif(col[x]) return ;\n\tcol[x]=1;\n\tfor(int i=h1[x];i;i=a[i].nxt)\n\t{\n\t\tint to=a[i].t;\n\t\tif(to==fa) continue ;\n\t\tdfs1(to,x);\n\t}\n}\nint findl;\nint vis[M],sta[M],top,cir[M],tp[M],cnt,tol[M],cnt2;\nvoid dfs2_2(int x) {\n\tvis[x]=1,tol[++cnt2]=x;\n\tfor(int i=h1[x];i;i=a[i].nxt)\n\t{\n\t\tint to=a[i].t;\n\t\tif(vis[to]) continue ;\n\t\tdfs2_2(to);\n\t}\n}\nvoid dfs2(int x,int fa) {\n\tif(vis[x]&&!findl)\n\t{\n\t\tfindl=1;\n\t\tint p=top;\n\t\twhile(sta[p+1]!=x) cir[++cnt]=sta[p--],tp[cir[cnt]]=1;\n\t\treturn ;\n\t}\n\tif(vis[x]) return ;\n\tvis[x]=1,sta[++top]=x;\n\tfor(int i=h1[x];i;i=a[i].nxt)\n\t{\n\t\tint to=a[i].t;\n\t\tif(to==fa) continue ;\n\t\tdfs2(to,x);\n\t\tif(findl) return ;\n\t}\n\tvis[x]=0,top--;\n}\nint sz[M],dfn[M];\nvoid dfs3(int x) {\n\tif(dfn[x]) return ;\n\tsz[x]=dfn[x]=1;\n\tfor(int i=h2[x];i;i=e[i].nxt)\n\t{\n\t\tint to=e[i].t;\n\t\tdfs3(to);\n\t\tsz[x]+=sz[to];\n\t}\n}\nvoid dfs4(int x,int fa) {\n\tfor(int i=h1[x];i;i=a[i].nxt)\n\t{\n\t\tint to=a[i].t;\n\t\tif(tp[to]||to==fa) continue ;\n\t\tif(fa>to) Add(x,to);\n\t\tdfs4(to,x);\n\t}\n}\nvoid clear() {\n\tfor(int i=1;i<=cnt2;i++) h2[tol[i]]=dfn[tol[i]]=sz[tol[i]]=0;\n\tt2=0;\n}\nvoid link(int k) {\n\tif(!k) for(int i=1;i<=cnt;i++) dfs4(cir[i],cir[i+1]);\n\telse for(int i=1;i<=cnt;i++) dfs4(cir[i],cir[i-1]);\n}\nll sol(int s) {\n\tfindl=0;\n\tll s1=1,s2=1;\n\tcnt=cnt2=0;\n\tdfs2_2(s);\n\tfor(int i=1;i<=cnt2;i++) vis[tol[i]]=0;\n\tdfs2(s,0);\n\tcir[0]=cir[cnt],cir[cnt+1]=cir[1],cir[cnt+2]=cir[2];\n\tlink(0);\n\tfor(int i=2;i<=cnt+1;i++) if(cir[i+1]>cir[i-1]) Add(cir[i],cir[i-1]);\n\tfor(int i=1;i<=cnt2;i++) dfs3(tol[i]);\n\tfor(int i=1;i<=cnt2;i++) s1=s1*sz[tol[i]]%mo;\n\tclear();\n\tlink(1);\n\tfor(int i=2;i<=cnt+1;i++) if(cir[i+1]<cir[i-1]) Add(cir[i],cir[i+1]);\n\tfor(int i=1;i<=cnt2;i++) dfs3(tol[i]);\n\tfor(int i=1;i<=cnt2;i++) s2=s2*sz[tol[i]]%mo;\n\tclear();\n\tfor(int i=1;i<=cnt;i++) tp[cir[i]]=0;\n\tfor(int i=1;i<=cnt2;i++) vis[tol[i]]=0;\n\ttop=0;\n\ts1=(ksm(s1,mo-2)+ksm(s2,mo-2))%mo;\n\treturn s1;\n}\nvoid work() {\n\tfor(int i=1;i<=n*2;i++)\n\t\tif(!col[i])\n\t\t{\n\t\t\tdfs1(i,0);\n\t\t\tans=ans*sol(i)%mo;\n\t\t}\n\tans=jc[n*2]*ans%mo;\n\tcout<<ans<<endl;\n}\nint main()\n{\n\t//freopen(\"2.in\",\"r\",stdin);\n\tjc[0]=1;\n\tfor(int i=1;i<M;i++) jc[i]=jc[i-1]*i%mo;\n\tn=read();\n\tfor(int i=1,u,v;i<=n*2;i++)\n\t{\n\t\tu=read();v=read();\n\t\tadd(u+n,v),add(v,u+n);\n\t}\n\tfor(int i=1;i<=n*2;i++) if(!du[i]) {cout<<0<<endl;return 0;}\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline mint<MOD> operator /  (mint<MOD> other) const { return *this *  other.inv(); }\n    inline mint<MOD> operator /= (mint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (mint<MOD> other) const { return value == other.value; }\n    inline bool operator != (mint<MOD> other) const { return value != other.value; }\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\ntemplate <int32_t MOD>\nmint<MOD> permute(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r);\n}\ntemplate <int32_t MOD>\nmint<MOD> multichoose(int n, int r) {\n    assert (0 <= n and 0 <= r);\n    if (n == 0 and r == 0) return 1;\n    return choose<MOD>(n + r - 1, r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            return use_generic(i, true) * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            return use_generic(i, false) * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        try {\n            REP (y, n) acc = acc * go_row(y);\n            REP (x, n) acc = acc * go_col(x);\n        } catch (bool e) {\n            assert (not e);\n            acc.size = -1;\n        }\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int maxn=2e5+10;\nconst int mo=1e9+7;\n\nint n,root,Ans=1,tote=1;\nint fa[maxn],fw[maxn],tmp[maxn],fac[maxn],ifac[maxn];\nint FIR[maxn],TO[maxn<<1],NEXT[maxn<<1],W[maxn<<1];\nint vis[maxn];\nint q[maxn];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nvoid addedge(int u,int v,int w)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tW[tote]=w;\n\tFIR[u]=tote;\n}\n\nvoid dfs1(int u,int F)\n{\n\tif (vis[u]==1) {root=u; return;}\n\tvis[u]=1;\n\tq[++q[0]]=u;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (v==F) continue;\n\t\tdfs1(v,u);\n\t}\n}\n\nvoid dfs2(int u)\n{\n\tif (vis[u]==2) return;\n\tvis[u]=2;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (v==fa[u]) continue;\n\t\tfa[v]=u;\n\t\tfw[v]=w;\n\t\tdfs2(v);\n\t}\n}\n\nnamespace Tree{\n\tint n,fa[maxn],dp[maxn],sz[maxn];\n\tint tote,FIR[maxn],TO[maxn<<1],NEXT[maxn<<1];\n\n\tvoid addedge(int u,int v)\n\t{\n//\t\tprintf(\"%d----->%d\\n\",u,v);\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t\tfa[v]=u;\n\t}\n\n\tbool dfs(int u)\n\t{\n//\t\tprintf(\"u=%d\\n\",u);\n\t\tif (dp[u]) return 0;\n\t\tsz[u]=0;\n\t\tdp[u]=1;\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!dfs(v)) return 0;\n\t\t\tsz[u]+=sz[v];\n\t\t\tdp[u]=(LL)dp[u]*dp[v]%mo;\n\t\t\tdp[u]=(LL)dp[u]*ifac[sz[v]]%mo;\n\t\t}\n\t\tdp[u]=(LL)dp[u]*fac[sz[u]]%mo;\n\t\tsz[u]++;\n\t\treturn 1;\n\t}\n\n\tvoid solve(int &Ans)\n\t{\n\t\tint i,u;\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n\t\t\tif (!fa[u]) addedge(0,u);\n\t\t}\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n//\t\t\tprintf(\"%d : %d\\n\",u,fw[u]);\n\t\t}\n\n\t\tif (!dfs(0)) {Ans=0; return;}\n\t\t(Ans+=dp[0])%=mo;\n\n//\t\tprintf(\"Ans=%d\\nclear\\n\\n\\n\",Ans);\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t\tu=q[i],FIR[u]=fa[u]=dp[u]=sz[u]=0;\n\t\tFIR[0]=fa[0]=dp[0]=sz[0]=0;\n\t\ttote=0;\n\t}\n};\n\nvoid dfs3(int u)\n{\n\tif (vis[u]==3) return;\n\tvis[u]=3;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs3(v);\n\t}\n}\n\nvoid dfs4(int u)\n{\n\tif (vis[u]==4) return;\n\tvis[u]=4;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs4(v);\n\t}\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,u,v;\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor (i=1;i<=n+n;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[n+n]=power(fac[n+n],mo-2);\n\tfor (i=n+n;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tfor (i=1;i<=n+n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,n+v,u+v);\n\t\taddedge(n+v,u,u+v);\n\t}\n\n\tfor (i=1;i<=n+n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tq[0]=0;\n\t\t\troot=0;\n\t\t\tdfs1(i,0);\n\t\t\tif (!root) {puts(\"0\"); return 0;}\n\t\t\tdfs2(root);\n\n\t\t\tint Sum=0;\n\n\t\t\tdfs3(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\ttmp[fa[u]]=fw[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\tfw[u]=tmp[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\n\t\t\tdfs4(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tAns=(LL)Ans*Sum%mo;\n//\t\t\tprintf(\"q0=%d\\n\",q[0]);\n\t\t\tAns=(LL)Ans*ifac[q[0]]%mo;\n\t\t}\n\tAns=(LL)Ans*fac[n+n]%mo;\n\tprintf(\"%d\\n\",Ans);\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define next nxt\nusing namespace std;\nint fac[100010],nifac[100010],e[100010];\nint first[100010],next[100010],des[100010],w[100010];\nint size[100010],ans,f[100010],vn,en,ed;\nbool vis[100010];\nint tt,n;\nint C(int n,int m){return (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;}\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nvoid dfs(int s,int pre)\n{\n\tvis[s]=true;vn++;\n\tfor (int k=first[s];k;k=next[k])\n\t{\n\t\ten++;\n\t\tif (!vis[des[k]]) {e[des[k]]=k^1;dfs(des[k],s);}\n\t\telse if (des[k]!=pre) ed=k;\n\t}\n}\nvoid dp(int s,int e)\n{\n\tf[s]=1;size[s]=0;\n\tfor (int k=first[s];k;k=next[k]) if (k/2!=ed/2&&(k^1^e))\n\t{\n\t\tdp(des[k],k);\n\t\tif (w[k]>w[e]) ans=1LL*ans*nifac[size[des[k]]]%mo*f[des[k]]%mo;\n\t\telse f[s]=1LL*f[s]*f[des[k]]%mo*C(size[s]+=size[des[k]],size[des[k]])%mo;\n\t}\n\tsize[s]++;\n}\nint main()\n{\n\ttt=1;scanf(\"%d\",&n);n<<=1;\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);v+=n/2;\n\t\tdes[++tt]=v;next[tt]=first[u];first[u]=tt;\n\t\tdes[++tt]=u;next[tt]=first[v];first[v]=tt;\n\t\tw[tt]=w[tt^1]=u+v;\n\t}\n \n\tint all=fac[n];\n\tfor (int s=1;s<=n;s++) if (!vis[s])\n\t{\n\t\tvn=en=ed=0;dfs(s,0);en>>=1;\n\t\tif (vn!=en) {puts(\"0\");return 0;}\n\t\tint u=des[ed],v=des[ed^1];\n\t\tfor (;u!=v;u=des[e[u]]) if (w[e[u]]>w[ed]) ed=e[u];\n\t\tans=1;dp(des[ed],ed);\n\t\tint p1=(long long)ans*nifac[size[des[ed]]]%mo*f[des[ed]]%mo;\n\t\tans=1;dp(des[ed^1],ed);\n\t\tint p2=(long long)ans*nifac[size[des[ed^1]]]%mo*f[des[ed^1]]%mo;\n\t\tall=(long long)all*(p1+p2)%mo;\n\t}\n\tprintf(\"%d\\n\",all);\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint fac[200111],invf[200111];\nint cal(int x,int y){return 1ll*fac[x+y]*invf[x]%mod*invf[y]%mod;}\npii comb(pii x,pii y){return mp(1ll*x.ff*y.ff%mod*cal(x.ss,y.ss)%mod,x.ss+y.ss);}\n\nvector<int> g[200111],g2[200111];\nint n,vs[200111],tot,cyc[200111],len,to[200111],dgr[200111];\n\nbool incyc[200111],use[200111];\nint stk[200111],top,cnt,dep[200111];\n\npii dfs2(int x)\n{\n\tpii ret=mp(1,0);\n\tfor(int i=0;i<(int)g2[x].size();i++)\n\t\tret=comb(ret,dfs2(g2[x][i]));\n\tret.ss++;return ret;\n}\nvoid dfs(int x,int f=0)\n{\n\tstk[++top]=x;dep[x]=top;cnt++;\n\tvs[++tot]=x;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t{\n\t\tif(g[x][i]==f)continue;\n\t\tcnt--;\n\t\tif(!dep[g[x][i]])\n\t\t\tdfs(g[x][i],x);\n\t\telse if(dep[g[x][i]]<dep[x])\n\t\t{\n\t\t\tlen=0;\n\t\t\tfor(int j=dep[g[x][i]];j<=top;j++){cyc[++len]=stk[j];incyc[stk[j]]=1;}\n\t\t}\n\t\telse cnt++;\n\t}\n\ttop--;\n}\nvoid rdfs(int x,int f=0)\n{\n\tto[x]=f;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f&&!incyc[g[x][i]])\n\t\t\trdfs(g[x][i],x);\n}\n\nint calc()\n{\n\tfor(int i=1;i<=tot;i++){g2[vs[i]].clear();dgr[vs[i]]=0;}\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tfor(int j=0;j<(int)g[vs[i]].size();j++)\n\t\t{\n\t\t\tif(to[vs[i]]>g[vs[i]][j])\n\t\t\t{\n\t\t\t\tg2[vs[i]].pb(g[vs[i]][j]);\n\t\t\t\tdgr[g[vs[i]][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tpii ret=mp(1,0);\n\tfor(int i=1;i<=tot;i++)if(dgr[vs[i]]==0)ret=comb(ret,dfs2(vs[i]));else if(dgr[vs[i]]>1)exit(0);\n\treturn ret.ff;\n}\nint main()\n{\n\tfac[0]=invf[0]=1;for(int i=1;i<200111;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinvf[200111-1]=power(fac[200111-1],mod-2);\n\tfor(int i=200111-2;i>=0;i--)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\t\n\tget1(n);\n\tfor(int i=1,x,y;i<=n+n;i++)\n\t{\n\t\tget2(x,y);\n\t\tg[x].pb(y+n);\n\t\tg[y+n].pb(x);\n\t}\n\tn<<=1;\n\t\n\tpii now=mp(1,0);\n\tfor(int _=1;_<=n;_++)\n\t{\n\t\tif(dep[_])continue;\n\t\ttot=0;dfs(_);\n\t\tif(cnt)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=len;i++)rdfs(cyc[i]);\n\t\tint sum=0;\n\t\tfor(int i=1;i<=len;i++)to[cyc[i]]=cyc[i%len+1];\n\t\tsum+=calc();\n\t\tfor(int i=1;i<=len;i++)to[cyc[i%len+1]]=cyc[i];\n\t\tsum+=calc();if(sum>=mod)sum-=mod;\n\t\tnow=comb(now,mp(sum,tot));\n\t}\n\t\n\tprintendl(now.ff);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define int LL\n#define P pair<int,int>\n#define fi first\n#define se second\nconst LL N=2e5+10;\nconst LL mod=1e9+7;\nconst LL inf=0x3f3f3f;\nconst double eps=1e-9;\nusing namespace std;\ntemplate<typename tp> inline void read(tp &x)\n{\n    x=0;char c=getchar();\n    bool f=0; for(; c<'0'||c>'9'; f|=(c=='-'),c = getchar());\n    for(; c>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0',c = getchar());\n    if(f) x=-x;\n}\nP wei[N<<1];\nmap<P,int> Map;\nvector<P> idd;\nvector<int> line[N],row[N],vec,node;\n \nint n,found;\nint head[N<<1],cnt;\nint fa[N<<1],side[N<<1],vis[N<<1];\nint tou[N<<1],num;\nLL siz[N<<1];\n \nstruct Node { int next,to,id;} edge[N<<3];\nstruct E {int next,to;} e[N<<3];\n \nvoid add(int from,int to,int id) { edge[++cnt]= {head[from],to,id}; head[from]=cnt;}\nvoid insert(int from,int to,int id) { add(from,to,id); add(to,from,id);}\nvoid jia(int from,int to) {e[++num]= {tou[from],to}; tou[from]=num;}\nP calc(int x,int y) { if(x>y) swap(x,y); y-=n; return P(x,y);}\nLL KSM(LL a,LL b,LL ret=1) { while(b) { if(b&1) ret=ret*a%mod; a=a*a%mod; b>>=1; } return ret;}\nint ask(P x) { return lower_bound(idd.begin(),idd.end(),x)-idd.begin()+1;}\n\nvoid dfs(int now,int fath)\n{\n    vis[now]=1;\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        if(found==1) return ;\n        int to=edge[i].to;\n        if(to==fath) continue;\n        if(vis[to])\n        {\n            int flag=now;\n            while(flag!=to)\n            {\n                vec.push_back(flag);\n                flag=fa[flag];\n            }\n            vec.push_back(to);\n            found = 1;\n            return ;\n        }\n        fa[to]=now;\n        dfs(to,now);\n    }\n}\nvoid dfs_side_other(int now,int fa)\n{\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        int to=edge[i].to;\n        if(vis[to]==2||to==fa)\n            continue;\n        vis[to]=1;\n        if(to>n) side[edge[i].id]=2;\n        else side[edge[i].id]=1;\n        node.push_back(edge[i].id);\n        dfs_side_other(to,now);\n    }\n}\nLL dfs_size(int now)\n{\n    if(siz[now]) return siz[now];\n    siz[now]=1;\n    for(int i=tou[now]; i; i=e[i].next)\n    {\n        int to=e[i].to;\n        siz[now]+=dfs_size(to);\n    }\n    return siz[now];\n}\nvoid built()\n{\n    for(int i=0; i<node.size(); i++)\n    {\n        int x=wei[node[i]].fi,y=wei[node[i]].se;\n        if(side[node[i]]==1)\n        {\n            int pos=lower_bound(line[x].begin(),line[x].end(),y)-line[x].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(x,line[x][j])));\n        }\n        else\n        {\n            int pos=lower_bound(row[y].begin(),row[y].end(),x)-row[y].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(row[y][j],y)));\n        }\n    }\n}\nLL solve(int now)\n{\n    found = 0;\n    LL ret1=1,ret2=1;\n    vec.clear(), node.clear();\n    dfs(now,now);\n    // for(int i=0;i<vec.size();i++) cout<<vec[i]<<\" \";puts(\"\");\n    for(int i=0; i<vec.size(); i++) vis[vec[i]]=2;\n    for(int i=0; i<vec.size(); i++) dfs_side_other(vec[i],vec[i]);\n    for(int i=0; i<vec.size()-1; i++)\n    {\n        side[ask(calc(vec[i],vec[i+1]))]=(vec[i+1]>n?1:2);\n        node.push_back(ask(calc(vec[i],vec[i+1])));\n    }\n    side[ask(calc(vec[vec.size()-1],vec[0]))]=(vec[0]>n?1:2);\n    node.push_back(ask(calc(vec[vec.size()-1],vec[0])));\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    // for(int i=0; i<node.size();i++) cout<<node[i]<<\" \";puts(\"\");\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret1=ret1*KSM(dfs_size(node[i]),mod-2)%mod;\n    // puts(\"\");\n    // for(int i=0;i<node.size();i++) cout<<node[i]<<\" \"<<dfs_size(node[i])<<endl;\n    // puts(\"\");\n    num=0;\n    for(int i=0; i<node.size(); i++) tou[node[i]]=0;\n    for(int i=vec.size()-1; i>0; i--)\n        side[ask(calc(vec[i],vec[i-1]))]=(vec[i-1]>n?1:2);\n    side[ask(calc(vec[0],vec[vec.size()-1]))]=(vec[vec.size()-1]>n?1:2);\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret2=ret2*KSM(dfs_size(node[i]),mod-2)%mod;\n    return ret1+ret2;\n}\nsigned main()\n{\n\t// freopen(\"data,in\",\"r\",stdin);\n    read(n);\n    for(int i=1,x,y; i<=n*2; i++)\n    {\n        read(x),read(y),insert(x,y+n,i);\n        // wei[i]=P(x,y);\n        // Map[P(x,y)]=i;\n\t\tidd.push_back(P(x,y));\n        line[x].push_back(y);\n        row[y].push_back(x);\n    }\n\tsort(idd.begin(),idd.end());\n\tfor(int i=0;i<n*2;i++)\n\t\twei[i+1]=idd[i];\n    for(int i=1; i<=n; i++)\n    {\n        sort(line[i].begin(),line[i].end()),\n        sort(row[i].begin(),row[i].end());\n        if(!line[i].size()||!row[i].size())\n            return 0*puts(\"0\");\n    }\n    LL ans=1;\n    for(int i=1; i<=n*2; i++)\n        if(!vis[i])\n            ans=ans*solve(i)%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n/*\n3\n2 1\n1 2\n2 2\n3 3\n3 2\n2 3\n \noxo\nxxx\noxx\n \n850000006\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v; };\n\nint f[300000], fi[300000];\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n>>=1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint inv_mod(int x, int p) {\n\treturn pow_mod(x, p - 2, p);\n}\n\nint C(int x, int y) {\n\treturn (ll)f[x] * fi[y] % MOD * fi[x - y] % MOD;\n}\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint prod;\n\nint dfs(int u, vector<vector<int> >& G) {\n\tint tot = 0;\n\tfor (int v: G[u]) {\n\t\tint sz = dfs(v, G);\n\t\ttot += sz;\n\t\tprod = (ll)prod * C(tot, sz) % MOD;\n\t}\n\treturn tot + 1;\n}\n\nint calc(int N, int M, vector<int> a, vector<int> b, vector<int> dir) {\n\trep(i, N + M) if (dir[i] == -1) return 0;\n\tvector<int> unko(N + M);\n\trep(i, N + M) {\n\t\tif (dir[i] == 0) unko[a[i]]++;\n\t\tif (dir[i] == 1) unko[N + b[i]]++;\n\t}\n\trep(u, N + M) if (unko[u] != 1) return 0;\n\tvector<vector<i_i> > xs(N), ys(M);\n\trep(i, N + M) xs[a[i]].pb(i_i(b[i], i));\n\trep(i, N + M) ys[b[i]].pb(i_i(a[i], i));\n\tvector<vector<int> > G(N + M);\n\tvector<bool> root(N + M, true);\n\trep(k, N) {\n\t\tsort(xs[k].begin(), xs[k].end());\n\t\trep(l, xs[k].size()) {\n\t\t\tint i = xs[k][l].second;\n\t\t\tif (dir[i] == 0)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(xs[k][_l].second);\n\t\t}\n\t}\n\trep(k, M) {\n\t\tsort(ys[k].begin(), ys[k].end());\n\t\trep(l, ys[k].size()) {\n\t\t\tint i = ys[k][l].second;\n\t\t\tif (dir[i] == 1)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(ys[k][_l].second);\n\t\t}\n\t}\n\trep(u, N + M) for (int v: G[u]) root[v] = false;\n\tvector<int> to;\n\trep(u, N + M) if (root[u]) to.pb(u);\n\tG.pb(to);\n\tprod = 1;\n\tdfs(N + M, G);\n\treturn prod;\n}\n\nint solve(int N, int M, vector<int> a, vector<int> b) {\n\tif (N + M != a.size()) return 0;\n\tvector<vector<edge> > G(N + M);\n\trep(i, N + M) G[a[i]].pb(edge{i, N + b[i]}), G[N + b[i]].pb(edge{i, a[i]});\n\tvector<int> d(N + M);\n\trep(u, N + M) d[u] = G[u].size();\n\tqueue<int> q;\n\trep(u, N + M) if (d[u] == 1) q.push(u);\n\tvector<bool> exist(N + M, true);\n\tvector<int> dir(N + M, -1);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\texist[u] = false;\n\t\tint i;\n\t\tfor (edge e: G[u]) if (exist[e.v]) {\n\t\t\ti = e.i;\n\t\t\td[e.v]--;\n\t\t\tif (d[e.v] == 1) q.push(e.v);\n\t\t}\n\t\tdir[i] = (u >= N);\n\t}\n\tint i0 = -1;\n\trep(i, N + M) if (dir[i] == -1) i0 = i;\n\tif (i0 == -1) return calc(N, M, a, b, dir);\n\tvector<int> dir0 = dir;\n\tint ans = 0;\n\trep(t, 2) {\n\t\tdir = dir0;\n\t\tint s;\n\t\tif (t == 0) s = a[i0], dir[i0] = 0;\n\t\tif (t == 1) s = N + b[i0], dir[i0] = 1;\n\t\tvector<bool> vis(N + M); vis[s] = true;\n\t\tqueue<int> q; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (edge e: G[u]) if (dir[e.i] == -1) {\n\t\t\t\tdir[e.i] = (e.v >= N);\n\t\t\t\tif (!vis[e.v]) {\n\t\t\t\t\tvis[e.v] = true;\n\t\t\t\t\tq.push(e.v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (ans + calc(N, M, a, b, dir)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tf[0] = fi[0] = 1;\n\tfor (int x = 1; x < 300000; x++) {\n\t\tf[x] = (ll)f[x - 1] * x % MOD;\n\t\tfi[x] = (ll)fi[x - 1] * inv_mod(x, MOD) % MOD;\n\t}\n\tint N; cin >> N;\n\tvector<int> a(N * 2), b(N * 2);\n\trep(i, N * 2) scanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\tunion_find uf(N * 2);\n\trep(i, N * 2) uf.unite(a[i], b[i] + N);\n\tvector<vector<int> > vv(N * 2);\n\trep(i, N * 2) vv[uf.find(a[i])].pb(i);\n\tint ans = 1;\n\tfor (vector<int> v: vv) if (!v.empty()) {\n\t\tvector<int> _a, _b;\n\t\tfor (int i: v) _a.pb(a[i]), _b.pb(b[i]);\n\t\tvector<int> A = _a, B = _b;\n\t\tsort(A.begin(), A.end());\n\t\tsort(B.begin(), B.end());\n\t\tA.erase(unique(A.begin(), A.end()), A.end());\n\t\tB.erase(unique(B.begin(), B.end()), B.end());\n\t\tfor (int& u: _a) u = lower_bound(A.begin(), A.end(), u) - A.begin();\n\t\tfor (int& u: _b) u = lower_bound(B.begin(), B.end(), u) - B.begin();\n\t\tans = (ll)ans * solve(A.size(), B.size(), _a, _b) % MOD;\n\t}\n\tint tot = 0;\n\trep(u, N * 2) if (uf.root(u)) {\n\t\ttot += uf.size(u);\n\t\tans = (ll)ans * C(tot, uf.size(u)) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\n#define LL long long\nusing namespace std;\nconst int mo=1e9+7;\nvector<int> G[N],E[N]; int d[N],w[N],lw,cnt,z[N],lz;\nint n,f[N],F[N],vis[N],ans=1,sum,res,now,cir[N],X,Y,fc[N],xf[N],pr[N],sz[N];\nLL fpm(LL x,LL y){ LL s=1; while(y){ if(y&1) s=(s*x)%mo; y>>=1,x=(x*x)%mo;} return s;}\nvoid Tell(int t,int fa)\n{\n\tint i; vis[t]=cnt,now+=2,z[++lz]=t;\n\tfor(i=0;i<G[t].size();i++)\n\t\tif(vis[G[t][i]]!=cnt) Tell(G[t][i],t);\n\t\telse if(G[t][i]!=fa) X=t,Y=G[t][i];\n\tnow-=G[t].size();\n}\nvoid dfs(int t,int fa)\n{\n\tint i; vis[t]=cnt,f[t]=fa;\n\tfor(i=0;i<G[t].size();i++)\n\t\tif(vis[G[t][i]]!=cnt) dfs(G[t][i],t);\n}\nvoid DFS(int t,int fa)\n{\n\tint i;\n\tfor(i=0;i<G[t].size();i++)\n\t\tif(G[t][i]!=fa&&!cir[G[t][i]]){\n\t\t\tpr[G[t][i]]=t,DFS(G[t][i],t);\n\t\t\tif(G[t][i]<pr[t])\n\t\t\t\tE[t].push_back(G[t][i]),d[G[t][i]]++;\n\t\t  }\n}\nvoid dp(int t)\n{\n\tint i; sz[t]=0,F[t]=1;\n\tfor(i=0;i<E[t].size();i++){\n\t\tdp(E[t][i]),sz[t]+=sz[E[t][i]];\n\t\tF[t]=1LL*F[t]*F[E[t][i]]%mo*xf[sz[E[t][i]]]%mo;\n\t  }\n\tF[t]=1LL*F[t]*fc[sz[t]]%mo,sz[t]++;\n}\nvoid solve(int t)\n{\n\tint i;\n\tnow=sum=lw=lz=0,++cnt;\n\tTell(t,0);\n\tif(now){ ans=0; return ;}\n\t++cnt,dfs(X,0);\n\tfor(i=Y;i;i=f[i]) cir[i]=1,w[++lw]=i;\n\tfor(i=1;i<=lz;i++) E[z[i]].clear(),d[z[i]]=0;\n\tres=1,now=0;\n\tfor(i=1;i<=lw;i++){\n\t\tpr[w[i]]=w[i%lw+1];\n\t\tif(w[i%lw+1]>w[(i+lw-2)%lw+1])\n\t\t\tE[w[i]].push_back(w[(i+lw-2)%lw+1]),d[w[(i+lw-2)%lw+1]]++;\n\t  }\n\tfor(i=1;i<=lw;i++) DFS(w[i],0);\n\tfor(i=1;i<=lz;i++)\n\t\tif(!d[z[i]]){\n\t\t\tdp(z[i]);\n\t\t\tres=1LL*res*xf[sz[z[i]]]%mo*F[z[i]]%mo;\n\t\t  }\n\tsum=(sum+res)%mo;\n\tfor(i=1;i<=lz;i++) E[z[i]].clear(),d[z[i]]=0;\n\tres=1,now=0;\n\tfor(i=1;i<=lw;i++){\n\t\tpr[w[i]]=w[(i+lw-2)%lw+1];\n\t\tif(w[i%lw+1]<w[(i+lw-2)%lw+1])\n\t\t\tE[w[i]].push_back(w[i%lw+1]),d[w[i%lw+1]]++;\n\t  }\n\tfor(i=1;i<=lw;i++) DFS(w[i],0);\n\tfor(i=1;i<=lz;i++)\n\t\tif(!d[z[i]]){\n\t\t\tdp(z[i]);\n\t\t\tres=1LL*res*xf[sz[z[i]]]%mo*F[z[i]]%mo;\n\t\t  }\n\tsum=(sum+res)%mo;\n\tans=1LL*ans*sum%mo;\n}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d\",&n);\n\tfc[0]=xf[0]=1;\n\tfor(i=1;i<N;i++){\n\t\tfc[i]=1LL*fc[i-1]*i%mo;\n\t\txf[i]=fpm(fc[i],mo-2);\n\t  }\n\tfor(i=1;i<=2*n;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x].push_back(y+n);\n\t\tG[y+n].push_back(x);\n\t  }\n\tfor(i=1;i<=2*n;i++)\n\t\tif(!vis[i])\n\t\t\tsolve(i);\n\tans=1LL*ans*fc[2*n]%mo;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n    return powmod(a, MOD-2);\n}\nll f[200020], invf[200020];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(!(0<=y && y<=x)) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint n;\nint x[200020], y[200020];\nvector<P> g[200020];\nbool nuo[200020];\nvector<int> v, ve;\nvoid dfs0(int a){\n\tnuo[a]=1;\n\tv.push_back(a);\n\tfor(auto p:g[a]){\n\t\tint b=p.first;\n\t\tve.push_back(p.second);\n\t\tif(!nuo[b]){\n\t\t\tdfs0(b);\n\t\t}\n\t}\n}\nvector<P> gr[2][200020];\nvector<int> gd[2][200020];\nP g0[2][200020];\nbool used[200020];\nint d[200020];\nll dp[2][200020];\nint sz[2][200020];\nvoid dfs(int t, int a){\n\tdp[t][a]=1;\n\tfor(auto b:gd[t][a]){\n\t\tdfs(t, b);\n\t\tsz[t][a]+=sz[t][b];\n\t\t(dp[t][a]*=invf[sz[t][b]])%=MOD;\n\t\t(dp[t][a]*=dp[t][b])%=MOD;\n\t}\n\t(dp[t][a]*=f[sz[t][a]])%=MOD;\n\tsz[t][a]++;\n}\nbool r[2][200020];\nll solve(){\n\tqueue<int> que;\n\tfor(auto a:v){\n\t\tif(d[a]==1) que.push(a);\n\t}\n\twhile(!que.empty()){\n\t\tint a=que.front(); que.pop();\n\t\tfor(auto p:g[a]){\n\t\t\tif(used[p.second]) continue;\n\t\t\tint b=p.first;\n\t\t\tused[p.second]=1;\n\t\t\td[b]--;\n\t\t\tint i=p.second;\n\t\t\tg0[0][a]=g0[1][a]=P(b, i);\n\t\t\tgr[0][b].push_back({a, i});\n\t\t\tgr[1][b].push_back({a, i});\n\t\t\tif(d[b]==1) que.push(b);\n\t\t}\n\t}\n\tint now, pr=-1, cyc=0;\n\tfor(auto i:ve){\n\t\tif(!used[i]){\n\t\t\tnow=x[i];\n\t\t\tcyc++;\n\t\t}\n\t}\n\tfor(int j=0; j<cyc; j++){\n\t\tfor(auto p:g[now]){\n\t\t\tif(used[p.second] || p.first==pr) continue;\n\t\t\tpr=now;\n\t\t\tnow=p.first;\n\t\t\tint i=p.second;\n\t\t\tg0[0][pr]=P(now, i);\n\t\t\tgr[0][now].push_back({pr, i});\n\t\t\tg0[1][now]=P(pr, i);\n\t\t\tgr[1][pr].push_back({now, i});\n\t\t\tbreak;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int t=0; t<2; t++){\n\t\tll ans1=f[v.size()];\n\t\tfor(auto a:v){\n\t\t\tint b=g0[t][a].first, i=g0[t][a].second;\n\t\t\tfor(auto p:gr[t][a]){\n\t\t\t\tif(p.first<b){\n\t\t\t\t\tgd[t][i].push_back(p.second);\n\t\t\t\t\tr[t][p.second]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto i:ve){\n\t\t\tif(!r[t][i]){\n\t\t\t\tdfs(t, i);\n\t\t\t\t(ans1*=dp[t][i])%=MOD;\n\t\t\t\t(ans1*=invf[sz[t][i]])%=MOD;\n\t\t\t}\n\t\t}\n\t\t(ans+=ans1)%=MOD;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=0; i<2*n; i++){\n\t\tcin>>x[i]>>y[i]; x[i]--; y[i]--;\n\t\ty[i]+=n;\n\t\td[x[i]]++; d[y[i]]++;\n\t\tg[x[i]].push_back({y[i], i});\n\t\tg[y[i]].push_back({x[i], i});\n\t}\n\tfac(2*n);\n\tll ans=f[2*n];\n\tfor(int i=0; i<2*n; i++){\n\t\tif(!nuo[i]){\n\t\t\tv.clear();\n\t\t\tve.clear();\n\t\t\tdfs0(i);\n\t\t\tsort(ve.begin(), ve.end());\n\t\t\tve.erase(unique(ve.begin(), ve.end()), ve.end());\n\t\t\tif(ve.size()!=v.size()){\n\t\t\t\tcout<<0<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t(ans*=invf[v.size()])%=MOD;\n\t\t\t(ans*=solve())%=MOD;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int UF_MAX = 200020;\n\nclass UF{\n\tint x[UF_MAX];\n\tint co;\n\t\npublic:\n\t\n\tUF(){\n\t\tfill(x,x+UF_MAX,-1);\n\t\tco = 0;\n\t}\n\t\n\tint boss(int a){\n\t\tint s = a;\n\t\twhile(x[s] > -1) s = x[s];\n\t\tif(s != a) x[a] = s;\n\t\treturn s;\n\t}\n\t\n\tvoid uni(int a , int b){\n\t\tint s = boss(a);\n\t\tint t = boss(b);\n\t\tif(s != t){\n\t\t\t++co;\n\t\t\tif(x[s] < x[t]){\n\t\t\t\tx[s] += x[t];\n\t\t\t\tx[t] = s;\n\t\t\t} else {\n\t\t\t\tx[t] += x[s];\n\t\t\t\tx[s] = t;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool find(int a , int b){\n\t\treturn boss(a) == boss(b);\n\t}\n\t\n\tint count(){\n\t\treturn co;\n\t}\n\t\n\tint member(int a){\n\t\treturn -x[boss(a)];\n\t}\n} uf;\n\nconst int MC = 100010;\nconst LL mod = 1e9 + 7;\nint N;\nint x[MC*2] , y[MC*2];\nvector<int> V[MC*2];\nvector<int> C[MC*2];\nvector<int> G[MC*2];\nvector<int> rG[MC*2];\nint e[MC*2];\nint al[MC*2];\nint co[MC*2];\nint sz[MC*2];\nLL h[MC*2];\nLL fct[MC*2];\nLL inv[MC*2];\nLL ans;\n\nvoid build(){\n\tfct[0] = fct[1] = 1;\n\trepp(i,2,MC*2){\n\t\tfct[i] = fct[i-1] * i % mod;\n\t}\n\tLL x = fct[MC*2-1];\n\tinv[MC*2-1] = 1;\n\tfor(int i = mod - 2 ; i > 0 ; i >>= 1){\n\t\tif(i % 2 == 1) (inv[MC*2-1] *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t}\n\trepm(i,MC*2-1,0){\n\t\tinv[i-1] = inv[i] * i % mod;\n\t}\n}\n\nLL fanc(int z){\n\tqueue<int> Q;\n\tLL k = fct[(int)C[z].size()];\n\tfor(auto u : C[z]) rG[u].clear();\n\tfor(auto u : C[z]){\n\t\tG[u].clear();\n\t\tfor(auto w : V[u]){\n\t\t\tif(w == al[u]) break;\n\t\t\tG[u].PB(w);\n\t\t\trG[w].PB(u);\n\t\t}\n\t\tsz[u] = 0;\n\t\th[u] = 1;\n\t\tco[u] = G[u].size();\n\t\tif(co[u] == 0) Q.push(u);\n\t\t//cerr << u << ' ' << al[u] << endl;\n\t}\n\twhile(!Q.empty()){\n\t\tint u = Q.front(); Q.pop();\n\t\tsz[u] = 1;\n\t\tfor(auto w : G[u]){\n\t\t\t(h[u] *= h[w]) %= mod;\n\t\t\t(h[u] *= inv[sz[w]]) %= mod;\n\t\t\tsz[u] += sz[w];\n\t\t}\n\t\t(h[u] *= fct[sz[u]-1]) %= mod;\n\t\t//cerr << u << ' ' << h[u] << ' ' << sz[u] << endl;\n\t\tif(rG[u].size() == 0){\n\t\t\t(k *= h[u]) %= mod;\n\t\t\t(k *= inv[sz[u]]) %= mod;\n\t\t}\n\t\tfor(auto w : rG[u]){\n\t\t\t--co[w];\n\t\t\tif(co[w] == 0) Q.push(w);\n\t\t}\n\t}\n\t//cerr << k << endl;\n\treturn k;\n}\n\nLL calc(int z){\n\tqueue<int> Q;\n\tint t = 0;\n\tfor(auto u : C[z]) if(V[u].size() == 1) Q.push(u);\n\twhile(!Q.empty()){\n\t\tint p = Q.front(); Q.pop();\n\t\tfor(auto u : V[p]){\n\t\t\tif(al[u] == 0){\n\t\t\t\tal[p] = u;\n\t\t\t\t++co[u];\n\t\t\t\t++t;\n\t\t\t\tif(V[u].size() == co[u] + 1) Q.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tint r,s;\n\tfor(auto u : C[z]){\n\t\tif(al[u] == 0){\n\t\t\tr = s = u;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(C[z].size() > t + 1){\n\t\tfor(auto u : V[r]){\n\t\t\tif(al[u] == 0){\n\t\t\t\tal[r] = u;\n\t\t\t\tr = u;\n\t\t\t\t++t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tal[r] = s;\n\tLL rv = fanc(z);\n\tqueue<P2> Q2;\n\tr = s;\n\twhile(Q2.empty() || r != s){\n\t\tQ2.push(MP(al[r],r));\n\t\tr = al[r];\n\t}\n\twhile(!Q2.empty()){\n\t\tal[Q2.front().first] = Q2.front().second;\n\t\tQ2.pop();\n\t}\n\treturn (rv + fanc(z)) % mod;\n}\n\nint main(){\n\tbuild();\n\tcin >> N;\n\trepp(i,0,2*N){\n\t\tcin >> x[i] >> y[i];\n\t\tV[x[i]].PB(MC+y[i]);\n\t\tV[MC+y[i]].PB(x[i]);\n\t\tuf.uni(x[i],MC+y[i]);\n\t}\n\trepp(i,1,N+1){\n\t\tC[uf.boss(i)].PB(i);\n\t\te[uf.boss(i)] += V[i].size();\n\t\tC[uf.boss(MC+i)].PB(MC+i);\n\t\te[uf.boss(MC+i)] += V[MC+i].size();\n\t\tsort(V[i].begin(),V[i].end());\n\t\tsort(V[MC+i].begin(),V[MC+i].end());\n\t}\n\tans = fct[2*N];\n\trepp(i,1,N+1){\n\t\tif(uf.boss(i) == i){\n\t\t\tif(C[i].size() * 2 != e[i]){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t(ans *= calc(i)) %= mod;\n\t\t\t(ans *= inv[(int)C[i].size()]) %= mod;\n\t\t}\n\t\tif(uf.boss(MC+i) == MC+i){\n\t\t\tif(C[MC+i].size() * 2 != e[MC+i]){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t(ans *= calc(MC+i)) %= mod;\n\t\t\t(ans *= inv[(int)C[MC+i].size()]) %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\n#define ll long long\n#define maxn 200005\n#define mo 1000000007\ninline ll read()\n{\n\tll x=0,w=0;char ch=getchar();\n\twhile(!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn w?-x:x;\n}\nvector<int>A[maxn];\nvector<int>G[maxn];\nint n,tot;\nint jc[maxn],ans[maxn],inst[maxn];\nint vis[maxn],vis1[maxn],fa[maxn],huan[maxn],size[maxn];\nint headd[maxn],nextt[maxn<<1],to[maxn<<1],cntt;\ninline int ksm(int x,int y)\n{\n    int a=1;\n    while(y)\n    {\n        if(y&1)a=1ll*a*x%mo;\n        x=1ll*x*x%mo;y>>=1;\n    }return a;\n}\ninline void add(int u,int v)\n{nextt[++cntt]=headd[u];headd[u]=cntt;to[cntt]=v;}\ninline void dfs(int u,int f)\n{\n    vis[u]=tot;A[tot].push_back(u);fa[u]=f;inst[u]=1;\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(vis[to[i]]){if(inst[to[i]])huan[fa[to[i]]]=-1,huan[u]++;}\n        else dfs(to[i],u),huan[u]+=huan[to[i]];\n    }inst[u]=0;\n}\ninline void dfs1(int u,int f)\n{\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(huan[to[i]]==1)continue;\n        fa[to[i]]=u;dfs1(to[i],u);\n    }\n}\ninline void dfs2(int u)\n{\n    reg int i,sz=G[u].size();\n    size[u]=1;vis1[u]=1;\n    for(i=0;i<sz;++i)\n    {\n        if(!vis1[G[u][i]])dfs2(G[u][i]);\n        size[u]+=size[G[u][i]];\n    }\n}\ninline void solve1()\n{\n    reg int i,j,u,sz=A[tot].size();\n    for(j=0;j<sz;++j)\n    {\n        u=A[tot][j];G[u].clear();\n        for(i=headd[u];i;i=nextt[i])\n        {\n            if(fa[to[i]]!=u)continue;\n            if(to[i]<fa[u])G[u].push_back(to[i]);\n        }\n    }\n    for(i=0;i<sz;++i)\n        if(!vis1[A[tot][i]])\n            dfs2(A[tot][i]);\n    for(i=0;i<sz;++i)vis1[A[tot][i]]=0;\n    reg int tmp=1;\n    for(i=0;i<sz;++i)tmp=1ll*tmp*size[A[tot][i]]%mo;\n    ans[tot]+=1ll*jc[sz]*ksm(tmp,mo-2)%mo;if(ans[tot]>=mo)ans[tot]-=mo;\n}\ninline void solve()\n{\n    reg int i,sz=A[tot].size(),fi,k;\n    for(i=0;i<sz;++i)\n        if(huan[A[tot][i]]==1){fi=A[tot][i];break;}\n    k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[to[i]]!=k){fa[k]=to[i];k=to[i];break;}\n    }while(fi!=k);solve1();k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[k]!=to[i]){fa[to[i]]=k;k=to[i];break;}\n    }while(fi!=k);solve1();\n}\nint ha[maxn],ha1[maxn];\nint main()\n{\n    n=read();reg int i,x,y;jc[0]=1;\n    for(i=1;i<=2*n;++i)jc[i]=1ll*jc[i-1]*i%mo;\n    for(i=1;i<=2*n;++i)\n    {\n        x=read(),y=read();ha[x]=1;ha1[y]=1;\n        add(x,n+y),add(n+y,x);\n    }\n    for(i=1;i<=n;++i)if(!ha[i])return 0;\n    for(i=1;i<=n;++i)if(!ha1[i])return 0;\n    for(i=1;i<=n*2;++i)if(!vis[i])\n        ++tot,dfs(i,0),solve();\n    reg int sum=1,su=1;\n    for(i=1;i<=tot;++i)sum=1ll*sum*ans[i]%mo;\n    for(i=1;i<=tot;++i)su=1ll*su*jc[A[i].size()]%mo;\n    sum=1ll*sum*jc[2*n]%mo*ksm(su,mo-2)%mo;\n    printf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#undef LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename V>\nstring to_string(V v) {\n    bool f = true; string res = \"[\";\n    for (const auto& x: v) {\n        if (!f) res += \", \";\n        f = false;\n        res += to_string(x); } res += \"]\";\n    return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) { cerr << \" \" << to_string(h); debug(t...); }\n#ifdef LOCAL\n#define dbg(args...) cerr<<\"(\"<<#args<<\") =\", debug(args)\n#else\n#define dbg(args...) 2019\n#endif\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n    // sum x = s, x > 0\n    mint p(int s, int k) {\n        return c(s-1, k-1);\n    }\n    // sum x = s, x >= 0\n    mint z(int s, int k) {\n        return p(s+k, k);\n    }\n    // \\E Y-X >= m\n    mint hit(int n, int k, int m=1) {\n        if (m <= k-n) return c(n+k, n);\n        return c(n+k, k-m);\n    }\n    // catalan trapezoids C_m(n, k)\n    // \\A Y-X < m,  =c(n+k,n) - hit\n    mint cat(int n, int k, int m=1) {\n        if (m > k) return c(n+k, n);\n        if (m <= k-n) return 0;\n        return c(n+k,n) - c(n+k, k-m);\n    }\n}c(300000);\n\nstruct Graph {\n    int n, m;\n    vector<vector<int>> g;\n    bool is_digraph;\n    Graph(int _n) : n(_n), m(0) {\n        assert(n >= 1);\n        g.resize(n);\n        set_di(true); // TRUE!\n    }\n    Graph(int _n, int _m, bool _di=false) : n(_n), m(0) {\n        assert(n >= 1);\n        assert(1ll*n*(n-1)/2 >= m);\n        g.resize(n);\n        set_di(_di);\n        input(_m);\n    }\n    inline void add(int u, int v) {\n        assert(0 <= u && u < n);\n        assert(0 <= v && v < n);\n        assert(u != v);\n        g[u].emplace_back(v);\n        pa[v] = u;\n        if (!is_digraph)\n            g[v].emplace_back(u);\n        m++;\n    }\n    void input(int _m) {\n        int u, v;\n        for (int i = 0; i < _m; i++) {\n            cin >> u >> v;\n            u--;v--; // to 0-based\n            add(u, v);\n        }\n    }\n    void set_di(bool _di) {\n        is_digraph = _di;\n        trk = vector<bool>(n, false);\n        pa = vector<int>(n, -1);\n        sz = vector<int>(n, 0);\n        ans = vector<mint>(n, 0);\n    }\n    vector<bool> trk;\n    vector<int> pa;\n    vector<int> sz;\n    vector<mint> ans;\n    void dfs(int u) {\n        trk[u] = true;\n        ans[u] = 1;\n        for (int v: g[u]) {\n            if (trk[v]) continue;\n            dfs(v);\n            ans[u] *= c.ifac[sz[v]];\n            ans[u] *= ans[v];\n            sz[u] += sz[v];\n        }\n        ans[u] *= c.fac[sz[u]];\n        sz[u] += 1;\n    }\n\n    void clear_comp(vector<int>& comp) {\n        for (int u: comp) {\n            trk[u] = false;\n            pa[u] = -1;\n            sz[u] = 0;\n            g[u].clear();\n        }\n    }\n\n    mint full_dfs(vector<int>& comp){\n        mint res = c.fac[comp.size()];\n        for (int u: comp) if(pa[u]==-1) {\n            dfs(u);\n            dbg(sz[u],(int)ans[u]);\n            res *= c.ifac[sz[u]];\n            res *= ans[u];\n        }\n        return res;\n    }\n};\n\nvoid solve() {\n    int n; cin >> n; int N = n<<1;\n    vector<vector<int>> g(N);\n    for (int _ = 0; _ < N; _++) {\n        int x,y;\n        cin >> x >> y;\n        x--;y--;y+=n;\n        g[x].emplace_back(y);\n        g[y].emplace_back(x);\n    }\n    for (int i = 0; i < N; i++) {\n        sort(g[i].begin(), g[i].end());\n    }\n\n    int cycnt = 0, high = -1, low = -1;\n    vector<bool> trk(N, false);\n    vector<int> pa(N, -1);\n    vector<bool> in_c(N, false);\n    vector<int> comp;\n    vector<int> cycle;\n    // find cycle\n    function<bool(int,int)> dfs = [&](int u, int p){\n        trk[u] = true;\n        comp.emplace_back(u);\n        for (int v: g[u])if(v!=p){\n            if (trk[v]) {\n                cycnt++;  high = u;  low = v;\n                if (cycnt > 2) return false;\n            } else {\n                pa[v] = u;\n                if (!dfs(v, u)) return false;\n            }\n        }\n        return true;\n    };\n    vector<bool> trk_asn(N, false);\n    vector<int> assign(N,-1);\n    function<void(int)> asn = [&](int u){\n        trk_asn[u] = true;\n        for (int v: g[u])if(!in_c[v] && !trk_asn[v]){\n            assign[v] = u;\n            asn(v);\n        }\n    };\n\n    Graph digraph(N);\n\n    auto make_before = [&](int u){\n        for (int v: g[u]) {\n            if (v >= assign[u]) break;\n            digraph.add(u, v);\n        }\n    };\n    mint res = c.fac[N];\n\n    dbg(g);\n    for (int i = 0; i < N; i++) {\n        if (trk[i]) continue;\n        comp.clear(); cycle.clear();\n        cycnt = 0, high = -1, low = -1;\n        if (!dfs(i, -1) || cycnt < 2) {\n            dbg(pa); dbg(cycnt);\n            cout << 0; return;\n        }\n        assert(cycnt == 2 && high != -1 && low != -1);\n        {// mark cycle\n            int x = low;\n            while (x != high) {\n                cycle.emplace_back(x);\n                in_c[x] = true;\n                x = pa[x];\n            }cycle.emplace_back(x); in_c[x] = true;\n        }\n        dbg(high, low);\n        dbg(comp, cycle);\n        {// assgin out\n            for (int u: cycle) asn(u);\n        }\n        mint sub = 0;\n        {// +1\n            int csz = cycle.size();\n            for (int i = 0; i < csz; i++) {\n                assign[cycle[i]] = cycle[(i+1)%csz];\n            }\n            dbg(assign);\n            for (int u: comp){\n                make_before(u);\n            }\n            dbg(digraph.g);\n            sub += digraph.full_dfs(comp);\n            dbg((int)sub);\n            digraph.clear_comp(comp);\n        }\n        {// -1\n            int csz = cycle.size();\n            for (int i = 0; i < csz; i++) {\n                assign[cycle[i]] = cycle[(i+csz-1)%csz];\n            }\n            dbg(assign);\n            for (int u: comp){\n                make_before(u);\n            }\n            dbg(digraph.g);\n            sub += digraph.full_dfs(comp);\n            dbg((int)sub);\n        }\n        res *= c.ifac[comp.size()];\n        res *= sub;\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define gc getchar\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define x1 uvuvwevwevwe\n#define y1 onyetenyevwe\n#define x2 ugwemubwem\n#define y2 ossas\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> pii;\ntemplate <typename T> void scan(T &angka){\n\tangka=0;char input=gc();T kali=1;\n\twhile(!(48<=input&&input<=57)){\tif(input=='-')\tkali=-1;input=gc();}\n\twhile(48<=input&&input<=57)\tangka=(angka<<3)+(angka<<1)+input-48,input=gc();angka*=kali;\n}\ntemplate <typename T1,typename T2> void scan(T1 &angka1,T2 &angka2){\n\tscan(angka1);scan(angka2);\n}\nconst int MAXN=100000;\nconst int MAXNODE=2*MAXN;\nconst LL mods=1000000007LL;\nstruct M{\n\tLL x;\n\tM(LL angka){\n\t\tif(angka>=mods||angka<=-mods)\n\t\t\tangka%=mods;\n\t\tif(angka<0)\n\t\t\tangka+=mods;\n\t\tx=angka;\n\t}\n\tM(){\n\t\tx=0;\n\t}\n\tM operator + (const M &other) const{\n\t\treturn M(x+other.x);\n\t}\n\tM operator - (const M &other) const{\n\t\treturn M(x-other.x);\n\t}\n\tM operator * (const M &other) const{\n\t\treturn M(x*other.x);\n\t}\n\tM operator - () const{\n\t\treturn M(-x);\n\t}\n};\nint n,rootcc,par[MAXNODE+5],subtree[MAXNODE+5];\nM fakt[MAXNODE+5],inv[MAXNODE+5],ans;\nvector <int> node[MAXNODE+5],cc,dag[MAXNODE+5];\nbool partofcycle[MAXNODE+5],partofcc[MAXNODE+5],rootdag[MAXNODE+5];\nvoid inis(){\n\tmemset(partofcycle,false,sizeof(partofcycle));\t\t\t//part of cycle gak\n\tmemset(partofcc,false,sizeof(partofcc));\t\t\t\t//sudah pernah gak jadi cc\n}\nvoid exteuclid(LL a,LL b,M &x,M &y){\n\tif(b==0)\n\t{\n\t\tx=1;\n\t\ty=0;\n\t}\n\telse\n\t{\n\t\texteuclid(b,a%b,x,y);\n\t\tM tempx,tempy;\n\t\ttempx=x,tempy=y;\n\t\t\n\t\tx=tempy;\n\t\ty=tempx-tempy*(a/b);\n\t}\n}\nM invers(LL angka){\n\tM x,y;\n\texteuclid(angka,mods,x,y);\n\treturn x;\n}\nM invers(M angka){\n\treturn invers(angka.x);\n}\nvoid precomp(){\n\tfakt[0]=1;\n\tinv[0]=1;\n\tfor(int i=1;i<=MAXNODE;i++)\n\t\tfakt[i]=fakt[i-1]*i;\n\tfor(int i=1;i<=MAXNODE;i++)\n\t\tinv[i]=invers(fakt[i]);\n}\nvoid dfs(int now,int tadi){\n\tassert(!partofcc[now]);\n\tpartofcc[now]=true;\n\tcc.pb(now);\n\tfor(auto v:node[now])\n\t{\n\t\tif(v==tadi)\n\t\t\tcontinue;\n\t\tif(partofcc[v])\n\t\t{\n\t\t\tif(rootcc==-1)\n\t\t\t\trootcc=v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdfs(v,now);\n\t\t}\n\t}\n}\nbool isicc(int s){\t\t\t//return valid tidak, dan cari root, dan isi cc\n\tcc.clear();\n\trootcc=-1;\n\tdfs(s,-1);\t\t\t\t//isi cc\n\tassert(rootcc!=-1);\n\tint total=0;\n\tfor(auto isi:cc)\n\t\ttotal+=(node[isi].size())-1;\n\treturn (total==cc.size());\n}\nvoid tentukancycle(int now,int _par){\t\t\t\t//sekalian isi parnya, par root itu teman cyclenya\n\tpar[now]=_par;\n\tfor(auto v:node[now])\n\t{\n\t\tif(v==_par)\n\t\t\tcontinue;\n\t\tif(v==rootcc)\n\t\t{\n\t\t\tpartofcycle[now]=true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(now==rootcc&&partofcycle[v])\t\t\t\t//berarti sudah visited\n\t\t{\n\t\t\t//cout<<\"ketemu par\"<<endl;\n\t\t\tassert(partofcycle[now]);\n\t\t\tpar[now]=v;\n\t\t\tcontinue;\n\t\t}\n\t\ttentukancycle(v,now);\n\t\tif(partofcycle[v])\n\t\t{\n\t\t\tassert(!partofcycle[now]);\n\t\t\tpartofcycle[now]=true;\n\t\t}\n\t}\n}\nvoid bagidag(int jenis){\t\t\t//bagi menjadi dag, tergantung loop ke berapa, loop1 based on par, loop2 yang cycle di reverse\n\tfor(auto isi:cc)\n\t{\n\t\tdag[isi].clear();\n\t\tint patokan;\n\t\tif(jenis==0)\n\t\t\tpatokan=par[isi];\n\t\telse\n\t\t{\n\t\t\tif(partofcycle[isi])\n\t\t\t{\n\t\t\t\tassert(partofcycle[par[isi]]);\n\t\t\t\tfor(auto v:node[isi])\n\t\t\t\t{\n\t\t\t\t\tif(v==par[isi])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(partofcycle[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tpatokan=v;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tpatokan=par[isi];\n\t\t}\n\t\t\n\t\tfor(auto v:node[isi])\n\t\t{\n\t\t\tif(v<patokan)\n\t\t\t\tdag[isi].pb(v);\n\t\t}\n\t}\n}\nvoid tentukanrootdag(){\t\t\t\t//cari root dari dag\n\tfor(auto isi:cc)\n\t\trootdag[isi]=true;\n\tfor(auto isi:cc)\n\t{\n\t\tfor(auto v:dag[isi])\n\t\t\trootdag[v]=false;\n\t}\n}\nvoid hitungsubtree(int now){\n\tsubtree[now]=1;\n\tfor(auto v:dag[now])\n\t{\n\t\thitungsubtree(v);\n\t\tsubtree[now]+=subtree[v];\n\t}\n\t//cout<<\"subtree dari \"<<now<<\" \"<<subtree[now]<<endl;\n}\nvoid hitungsubtree(){\t\t\t\t//subtree dari dag\n\tfor(auto isi:cc)\n\t{\n\t\tif(rootdag[isi])\n\t\t\thitungsubtree(isi);\n\t}\n}\nM costdag(int now){\t\t\t\t//ini sudah jadi dag\n\tM ret=fakt[subtree[now]-1];\n\tfor(auto v:dag[now])\n\t\tret=ret*costdag(v)*inv[subtree[v]];\n\t//cout<<\"cost dag dari \"<<now<<\" \"<<ret.x<<endl;\n\treturn ret;\n}\nM costdag(){\n\tM ret=fakt[cc.size()];\n\t//cout<<\"ret awal \"<<ret.x<<endl;\n\tfor(auto isi:cc)\n\t{\n\t\tif(!rootdag[isi])\n\t\t\tcontinue;\n\t\t//cout<<\"rootdag \"<<subtree[isi]<<\" \"<<costdag(isi).x<<endl;\n\t\tret=ret*inv[subtree[isi]]*costdag(isi);\n\t}\n\t//cout<<\"cost akhir \"<<ret.x<<endl;\n\treturn ret;\n}\nvoid printtree(int now){\n\tcout<<\"anak dari \"<<now<<endl;\n\tfor(auto v:dag[now])\n\t\tcout<<v<<\" \";\n\tcout<<endl;\n\tfor(auto v:dag[now])\n\t\tprinttree(v);\n}\nvoid solve(){\t\t\t//bagi jadi beberapa cc\n\tans=fakt[2*n];\n\tfor(int i=1;i<=2*n;i++)\n\t{\n\t\tif(partofcc[i])\n\t\t\tcontinue;\n\t\tif(!isicc(i))\n\t\t{\n\t\t\tans=0;\n\t\t\tbreak;\n\t\t}\n\t\t//cout<<\"rootnya \"<<rootcc<<endl;\n\t\ttentukancycle(rootcc,-1);\n\t\t/*cout<<\"ini part of cyclenya \"<<endl;\n\t\tfor(auto isi:cc)\n\t\t\tif(partofcycle[isi])\n\t\t\t\tcout<<isi<<\" \";\n\t\tcout<<endl;*/\n\t\tM costhere;\n\t\tfor(int ulang=0;ulang<2;ulang++)\n\t\t{\n\t\t\t//cout<<\"pengulangan \"<<ulang<<endl;\n\t\t\tbagidag(ulang);\n\t\t\ttentukanrootdag();\n\t\t\t/*for(auto isi:cc)\n\t\t\t\tif(rootdag[isi])\n\t\t\t\t\tprinttree(isi);*/\n\t\t\thitungsubtree();\n\t\t\tcosthere=costhere+costdag();\n\t\t}\n\t\t\n\t\t//updateans\n\t\tans=ans*costhere*inv[(int) cc.size()];\n\t}\n}\nint main()\n{\n\tinis();\n\tprecomp();\n\tscan(n);\n\tfor(int ulang=0;ulang<2;ulang++)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscan(x,y);\n\t\t\tnode[x].pb(y+n);\n\t\t\tnode[y+n].pb(x);\n\t\t}\n\t}\n\tsolve();\n\tprintf(\"%lld\\n\",ans.x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nnamespace zyt\n{\n\ttemplate<typename T>\n\tinline bool read(T &x)\n\t{\n\t\tchar c;\n\t\tbool f = false;\n\t\tx = 0;\n\t\tdo\n\t\t\tc = getchar();\n\t\twhile (c != EOF && c != '-' && !isdigit(c));\n\t\tif (c == EOF)\n\t\t\treturn false;\n\t\tif (c == '-')\n\t\t\tf = true, c = getchar();\n\t\tdo\n\t\t\tx = x * 10 + c - '0', c = getchar();\n\t\twhile (isdigit(c));\n\t\tif (f)\n\t\t\tx = -x;\n\t\treturn true;\n\t}\n\ttemplate<typename T>\n\tinline void write(T x)\n\t{\n\t\tstatic char buf[20];\n\t\tchar *pos = buf;\n\t\tif (x < 0)\n\t\t\tputchar('-'), x = -x;\n\t\tdo\n\t\t\t*pos++ = x % 10 + '0';\n\t\twhile (x /= 10);\n\t\twhile (pos > buf)\n\t\t\tputchar(*--pos);\n\t}\n\ttypedef pair<int, int> pii;\n\ttypedef long long ll;\n\tconst int N = 2e5 + 10, p = 1e9 + 7;\n\tint head[N], fac[N], inv[N], finv[N], ecnt, n;\n\tbool vis[N];\n\tstruct edge\n\t{\n\t\tint to, w;\n\t\tbool tag;\n\t\tint next;\n\t}e[N << 1];\n\tvoid add(const int a, const int b, const int c)\n\t{\n\t\te[ecnt] = (edge){b, c, false, head[a]}, head[a] = ecnt++;\n\t}\n\tint fa[N], ptnum[N], ednum[N];\n\tint f(const int x)\n\t{\n\t\treturn x == fa[x] ? x : fa[x] = f(fa[x]);\n\t}\n\tbool findcir(const int u, const int f, vector<int> &ve)\n\t{\n\t\tif (vis[u])\n\t\t\treturn true;\n\t\tvis[u] = true;\n\t\tfor (int i = head[u]; ~i; i = e[i].next)\n\t\t{\n\t\t\tint v = e[i].to;\n\t\t\tif (v == f)\n\t\t\t\tcontinue;\n\t\t\tif (findcir(v, u, ve))\n\t\t\t{\n\t\t\t\tve.push_back(i);\n\t\t\t\treturn u != e[*ve.begin()].to;\n\t\t\t}\n\t\t}\n\t\tvis[u] = false;\n\t\treturn false;\n\t}\n\tint size[N];\n\tint dfs(const int u, const int f, const int from, const bool rot, vector<pii> &ans)\n\t{\n\t\tint mul = 1;\n\t\tsize[u] = 1;\n\t\tfor (int i = head[u]; ~i; i = e[i].next)\n\t\t{\n\t\t\tint v = e[i].to;\n\t\t\tif ((i ^ 1) == from || e[i].tag)\n\t\t\t\tcontinue;\n\t\t\tmul = ll(mul) * dfs(v, u, i, f && f < v, ans) % p;\n\t\t\tif (!(f && f < v))\n\t\t\t\tsize[u] += size[v];\n\t\t}\n\t\tmul = (ll)mul * inv[size[u]] % p;\n\t\tif (rot)\n\t\t{\n\t\t\tans.push_back(pii((ll)fac[size[u]] * mul % p, size[u]));\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\treturn mul;\n\t}\n\tint cal(const vector<pii> &buf)\n\t{\n\t\tint ans = 1, mul = 1, sum = 0;\n\t\tfor (auto it = buf.begin(); it != buf.end(); it++)\n\t\t\tans = (ll)ans * it->first % p, mul = (ll)mul * finv[it->second] % p, sum += it->second;\n\t\tans = (ll)ans * mul % p * fac[sum] % p;\n\t\treturn ans;\n\t}\n\tint solve(const int u)\n\t{\n\t\tstatic vector<int> ve;\n\t\tstatic vector<pii> ans1, ans2;\n\t\tve.clear();\n\t\tans1.clear();\n\t\tans2.clear();\n\t\tfindcir(u, 0, ve);\n\t\tpii mx = pii(-1, -1);\n\t\tfor (int i = 0; i < ve.size(); i++)\n\t\t\tmx = max(mx, pii(e[ve[i]].w, ve[i]));\n\t\tint a = e[mx.second].to, b = e[mx.second ^ 1].to;\n\t\te[mx.second].tag = e[mx.second ^ 1].tag = true;\n\t\tdfs(a, b, -1, true, ans1);\n\t\tdfs(b, a, -1, true, ans2);\n\t\treturn (cal(ans1) + cal(ans2)) % p;\n\t}\n\tinline void init()\n\t{\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < N; i++)\n\t\t\tinv[i] = ll(p - p / i) * inv[p % i] % p;\n\t\tfac[0] = finv[0] = 1;\n\t\tfor (int i = 1; i < N; i++)\n\t\t{\n\t\t\tfac[i] = (ll)fac[i - 1] * i % p;\n\t\t\tfinv[i] = (ll)finv[i - 1] * inv[i] % p;\n\t\t}\n\t}\n\tint work()\n\t{\n\t\tinit();\n\t\tread(n);\n\t\tmemset(head, -1, sizeof(int[n * 2 + 1]));\n\t\tfor (int i = 1; i <= (n << 1); i++)\n\t\t\tfa[i] = i, ptnum[i] = 1, ednum[i] = 0;\n\t\tfor (int i = 1; i <= (n << 1); i++)\n\t\t{\n\t\t\tint u, v, x, y;\n\t\t\tread(u), read(v);\n\t\t\tadd(u, v + n, u + v), add(v + n, u, u + v);\n\t\t\tx = f(u), y = f(v + n);\n\t\t\tif (x != y)\n\t\t\t\tfa[x] = y, ptnum[y] += ptnum[x], ednum[y] += ednum[x];\n\t\t\t++ednum[y];\n\t\t}\n\t\tn *= 2;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (i == fa[i] && ptnum[i] != ednum[i])\n\t\t\t{\n\t\t\t\twrite(0);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tstatic vector<pii> tmp;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (i == fa[i])\n\t\t\t\ttmp.push_back(pii(solve(i), ptnum[i]));\n\t\twrite(cal(tmp));\n\t\treturn 0;\n\t}\n}\nint main()\n{\n#ifdef BlueSpirit\n\tfreopen(\"3537.in\", \"r\", stdin);\n#endif\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pct puts(\"------ visit ------\");\n#define rep(a, b, c) for(int a = (b); a <= (c); ++ a)\n#define per(a, b, c) for(int a = (b); a >= (c); -- a)\nusing namespace std;\ntemplate <class T> void rd(T &x){\n  x = 0; int f = 1; char ch = getchar();\n  while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }\n  while(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();\n  x *= f;\n}\n\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nint n, sdu, tim;\nint mrk[maxn], to[maxn], siz[maxn];\nint p[maxn], cntp;\nint r[maxn], cntr;\nvector <int> h, g[maxn];\nbool ok[maxn], isr[maxn];\n\nnamespace mathematics{\n  ll fac[maxn], fin[maxn];\n\n  ll qpow(ll x, ll n){\n\tll y = 1;\n\tfor(; n; n >>= 1, x = x * x % mod)\n\t  if(n & 1) y = y * x % mod;\n\treturn y;\n  }\n\n#define inv(x) qpow(x, mod - 2)\n\n  ll C(ll n, ll m){ return fac[n] * fin[m] % mod * fin[n - m] % mod; }\n\n  void init(int n){\n\tfac[0] = 1; rep(i, 1, n) fac[i] = fac[i - 1] * i % mod;\n\tfin[n] = inv(fac[n]);\n\tper(i, n, 1) fin[i - 1] = fin[i] * i % mod;\n  }\n\n  void add(ll &a, ll b){ a = (a + b) % mod; }\n\n  void mul(ll &a, ll b){ a = (a * b) % mod; }\n}\nusing namespace mathematics;\n\nstruct edge{ int v, nxt; }; vector <edge> e; int head[maxn];\n\nvoid adde(int u, int v){\n  e.push_back((edge){v, head[u]});\n  head[u] = e.size() - 1;\n}\n\nvoid rebuild(int u, int f){\n  mrk[u] = tim;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v; if(v == f) continue;\n\tif(mrk[v] == tim && v < u) continue;\n\tif(to[u] == v){\n\t  if(to[v] > u) g[v].push_back(u), ok[u] = true;\n\t}\n\telse{\n\t  if(to[u] > v) g[u].push_back(v), ok[v] = true;\n\t}\n\tif(mrk[v] != tim) rebuild(v, u);\n  }\n}\n\nvoid getsize(int u, int f){\n  siz[u] = 1;\n  for(int i = 0; i < g[u].size(); ++ i){\n\tint v = g[u][i];\n\tgetsize(v, u);\n\tsiz[u] += siz[v];\n  }\n}\n\nll getdp(int u, int f){\n  int tot = siz[u] - 1;\n  ll res = 1;\n  for(int i = 0; i < g[u].size(); ++ i){\n\tint v = g[u][i];\n\tmul(res, C(tot, siz[v]) * getdp(v, u) % mod);\n\ttot -= siz[v];\n  }\n  return res;\n}\n\nll query(){\n  ++ tim; \n  rebuild(p[1], 0);\n  int tot = cntp;\n  ll res = 1;\n  rep(i, 1, cntp) if(!ok[p[i]]){\n\tgetsize(p[i], 0);\n\tmul(res, C(tot, siz[p[i]]) * getdp(p[i], 0) % mod);\n\ttot -= siz[p[i]];\n  }\n  rep(i, 1, cntp) g[p[i]].clear();\n  return res;\n}\n\nbool getroll(int u, int f){\n  h.push_back(u);\n  mrk[u] = 2;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v;\n\tif(v == f) continue;\n\tif(mrk[v] != 2){\n\t  if(getroll(v, u)) return true;\n\t}\n\telse if(mrk[v] == 2){\n\t  int t = -1;\n\t  while(t != v){\n\t\tt = h.back();\n\t\th.pop_back();\n\t\tr[cntr ++] = t;\n\t\tisr[t] = 1;\n\t  }\n\t  return true;\n\t}\n  }\n  h.pop_back();\n  return false;\n}\n\nvoid match(int u, int f){\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v; if(v == f || isr[v]) continue;\n\tto[v] = u; match(v, u);\n  }\n}\n\nll cal(){\n  if(cntp != sdu){\n\tputs(\"0\");\n\texit(0);\n  }\n  cntr = 0;\n  h.clear();\n  getroll(p[1], 0);\n  rep(i, 0, cntr - 1) match(r[i], 0);\n  rep(i, 0, cntr - 1) to[r[i]] = r[(i + 1) % cntr];\n  ll res = query();\n  rep(i, 0, cntr - 1) to[r[i]] = r[(i + cntr - 1) % cntr];\n  add(res, query());\n  return res;\n}\n\nvoid dfs(int u){\n  p[++ cntp] = u;\n  mrk[u] = 1;\n  for(int i = head[u]; ~i; i = e[i].nxt){\n\tint v = e[i].v;\n\tsdu ++;\n\tif(mrk[v]) continue;\n\tdfs(v);\n  }\n}\n\nvoid sol(){\n  int tot = 2 * n;\n  ll res = 1;\n  rep(i, 1, 2 * n) if(!mrk[i]){\n\tcntp = sdu = 0;\n\tdfs(i);\n\tsdu /= 2;\n\tmul(res, C(tot, cntp) * cal() % mod);\n\ttot -= cntp;\n  }\n  printf(\"%lld\\n\", res);\n}\n\nint main(){\n  memset(head, -1, sizeof(head));\n  rd(n);\n  init(2 * n);\n  rep(i, 1, 2 * n){\n\tint u, v; rd(u), rd(v);\n\tadde(u, v + n);\n\tadde(v + n, u);\n  }\n  sol();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 2e+5+5;\nconst int mo = 1e+9+7;\n\nint n;\nstruct edge{\n\tint x,nxt;\n}e[N*2];\nint h[N],tot;\nint r[N];\nbool vis[N];\nint he,ta,k,sum;\nint que[N],cir[N],m;\nLL js[N],inv[N];\nint fa[N],dep[N];\nbool bz[N];\nLL ans;\nint xx[N],yy[N],kx,ky;\nint to[N],a[N],pk;\nint lef[N],rig[N];\nint siz[N];\n\nvoid inse(int x,int y){e[++tot].x=y;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid dfs(int x){\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (!bz[e[p].x]&&!to[e[p].x]){\n\t\tto[e[p].x]=x;\n\t\tdfs(e[p].x);\n\t}\n}\n\nLL solve_tree(int x){\n\tsiz[x]=1;\n\tLL tmp=1;\n\tfor(int y=lef[x];y;y=rig[y]){\n\t\ttmp=tmp*solve_tree(y);\n\t\tsiz[x]+=siz[y];\n\t\ttmp=tmp*inv[siz[y]]%mo;\n\t}\n\ttmp=tmp*js[siz[x]-1]%mo;\n}\n\nLL solve(){\n\tfo(i,1,k)r[que[i]]=lef[que[i]]=rig[que[i]]=0;\n\tfo(i,1,k){\n\t\tint x=que[i];\n\t\tif (x<to[to[x]]){\n\t\t\trig[x]=lef[to[x]];\n\t\t\tlef[to[x]]=x;\n\t\t\tr[x]=1;\n\t\t}\n\t}\n\tLL val=1;\n\tfo(i,1,k)\n\tif (!r[que[i]]){\n\t\tLL tmp=solve_tree(que[i]);\n\t\tval=val*tmp%mo*inv[siz[que[i]]]%mo;\n\t}\n\tval=val*js[k]%mo;\n\treturn val;\n}\n\nvoid bfs(int st){\n\the=0,ta=1;\n\tvis[que[1]=st]=dep[st]=1;\n\tsum=0;\n\twhile(he<ta){\n\t\tint x=que[++he];\n\t\tsum+=r[x];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (!vis[e[p].x]){\n\t\t\tfa[e[p].x]=x;\n\t\t\tdep[e[p].x]=dep[x]+1;\n\t\t\tvis[que[++ta]=e[p].x]=1;\n\t\t}\n\t}\n\tk=ta;\n\tsum/=2;\n\tif (sum!=k){ans=0;return;}\n\tint keyx=0,keyy;\n\tfo(i,1,k){\n\t\tint x=que[i];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (fa[e[p].x]!=x&&fa[x]!=e[p].x)keyx=x,keyy=e[p].x;\n\t\tif (keyx)break;\n\t}\n\tkx=ky=1;\n\txx[1]=keyx;yy[1]=keyy;\n\twhile(keyx!=keyy){\n\t\tif (dep[keyx]>dep[keyy])xx[++kx]=keyx=fa[keyx];\n\t\telse yy[++ky]=keyy=fa[keyy];\n\t}\n\tpk=kx+ky-1;\n\tfo(i,1,kx)a[i]=xx[i];\n\tfo(i,1,ky)a[pk-i+1]=yy[i];\n\tLL tmp=0;\n\tfo(i,1,pk)bz[a[i]]=1;\n\tfo(i,1,pk){\n\t\tto[a[i]]=a[i%pk+1];\n\t\tdfs(a[i]);\n\t}\n\ttmp=solve();\n\tfo(i,1,pk)to[a[i%pk+1]]=a[i];\n\ttmp=(tmp+solve())%mo;\n\tans=ans*tmp%mo;\n\tans=ans*inv[k]%mo;\n}\n\nint main(){\n\tn=get()*2;\n\tjs[0]=inv[0]=js[1]=inv[1]=1;\n\tfo(i,2,n)js[i]=js[i-1]*i%mo,inv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;\n\tfo(i,1,n)inv[i]=inv[i]*inv[i-1]%mo;\n\tfo(i,1,n){\n\t\tint x=get(),y=get()+n/2;\n\t\tinse(x,y),inse(y,x);\n\t\tr[x]++,r[y]++;\n\t}\n\tans=1;\n\tfo(i,1,n)\n\tif (!vis[i])bfs(i);\n\tans=ans*js[n]%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200005\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n        if(c == '-') f = -1;\n        c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n        res = res * 10 + c - '0';\n        c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n        out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n        if(c & 1) res = mul(res,t);\n        t = mul(t,t);\n        c >>= 1;\n    }\n    return res;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nstruct node {\n    int to,next;\n}E[MAXN * 4];\nint x[MAXN],y[MAXN],N,fac[MAXN],invfac[MAXN];\nmap<pii,int> zz;\nint head[MAXN],sumE;\nbool vis[MAXN];\nint sum,Ncnt,fa[MAXN],s,t,pos[MAXN],par[MAXN];\nvector<int> c[MAXN],r[MAXN],rec,cyc;\nint rpos[MAXN],cpos[MAXN],siz[MAXN];\nvector<int> son[MAXN];\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\npii depos(int a,int b) {\n    if(a > b) swap(a,b);\n    b -= N;\n    return mp(a,b);\n}\nbool dfs(int u) {\n    ++Ncnt;\n    bool flag = 0;\n    vis[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        ++sum;\n        int v = E[i].to;\n        if(!vis[v]) {\n            fa[v] = u;\n            if(dfs(v)) {\n                flag = 1;\n                pos[zz[depos(u,v)]] = u;\n            }\n        }\n        else if(v != fa[u] && !flag){\n            s = u,t = v;\n            flag = 1;\n            rec.pb(zz[depos(u,v)]);\n        }\n    }\n    if(!flag && fa[u]) {\n        pos[zz[depos(u,fa[u])]] = u;\n    }\n    if(fa[u]) rec.pb(zz[depos(u,fa[u])]);\n    return flag;\n}\nint Calc(int u) {\n    siz[u] = 1;\n    int res = 1;\n    for(auto v : son[u]) {\n        res = mul(res,Calc(v));\n        res = mul(res,invfac[siz[v]]);\n        siz[u] += siz[v];\n    }\n    res = mul(res,fac[siz[u] - 1]);\n    return res;\n}\nint Process() {\n    int res = 0;\n    for(auto t : rec) par[t] = 0;\n    for(auto t : rec) {\n        if(pos[t] > N) {\n            for(int i = 0 ; i < cpos[t] ; ++i) {\n                par[zz[mp(c[y[t]][i],y[t])]] = t;\n            }\n        }\n        else {\n            for(int i = 0 ; i < rpos[t] ; ++i) {\n                par[zz[mp(x[t],r[x[t]][i])]] = t;\n            }\n        }\n        son[t].clear();\n    }\n    son[0].clear();\n    for(auto t : rec) {\n        son[par[t]].pb(t);\n    }\n    return Calc(0);\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= 2 * N ; ++i) {\n        read(x[i]);read(y[i]);add(x[i],y[i] + N);add(y[i] + N,x[i]);\n        zz[mp(x[i],y[i])] = i;\n        r[x[i]].pb(y[i]);c[y[i]].pb(x[i]);\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n        sort(r[i].begin(),r[i].end());\n        sort(c[i].begin(),c[i].end());\n        for(int j = 1 ; j < r[i].size() ; ++j) rpos[zz[mp(i,r[i][j])]] = j;\n        for(int j = 1 ; j < c[i].size() ; ++j) cpos[zz[mp(c[i][j],i)]] = j;\n    }\n    fac[0] = 1;\n    for(int i = 1 ; i <= 2 * N ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[2 * N] = fpow(fac[2 * N],MOD - 2);\n    for(int i = 2 * N - 1 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    int ans = fac[2 * N];\n    for(int i = 1 ; i <= 2 * N ; ++i) {\n        if(!vis[i]) {\n            sum = 0;Ncnt = 0;\n            rec.clear();\n            dfs(i);\n            ans = mul(ans,invfac[Ncnt]);\n            if(Ncnt * 2 != sum) {puts(\"0\");return;}\n            int p = s;\n            cyc.clear();\n            while(1) {\n                cyc.pb(p);\n                if(p == t) break;\n                p = fa[p];\n            }\n            int tmp = 0;\n            cyc.pb(s);\n            for(int i = 0 ; i < cyc.size() - 1 ; ++i) {\n                pos[zz[depos(cyc[i],cyc[i + 1])]] = cyc[i];\n            }\n            update(tmp,Process());\n            for(int i = cyc.size() - 1 ; i >= 1 ; --i) {\n                pos[zz[depos(cyc[i],cyc[i - 1])]] = cyc[i];\n            }\n            update(tmp,Process());\n            ans = mul(ans,tmp);\n        }\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll MAX=300053;\nconst ll MOD=1000000007;\nvector<ll> conn[MAX],dir[MAX],now;\nll N,cnt[MAX],par[MAX],fact[MAX],chk[MAX],fin=1,npar[MAX],inv_dir[MAX];\nvoid build(ll x, ll px){\n    if(npar[x]!=0) return;\n    npar[x]=px; now.push_back(x);\n    for(ll i=0;i<conn[x].size();i++) if(px!=conn[x][i]) build(conn[x][i],x);\n}\nll power(ll x,ll y){\n    if(y==0) return 1;\n    ll t=power(x,y/2);\n    if(y%2) return t*t%MOD*x%MOD;\n    return t*t%MOD;\n}\npll counter(ll x){\n    ll t1=1,t2=1;\n    for(ll i=0;i<dir[x].size();i++){\n        pll tmp=counter(dir[x][i]);\n        t1+=tmp.first,t2*=tmp.second*power(fact[tmp.first],MOD-2)%MOD; t2%=MOD;\n    }\n    t2*=fact[t1-1]; t2%=MOD;\n    return make_pair(t1,t2);\n}\nll calc(ll x){\n    ll val[2]={1,1},pt=-1;\n    for(ll i=0;i<2;i++){\n        for(pt++;pt<conn[x].size();pt++) if(par[conn[x][pt]]==0) break;\n        build(x,conn[x][pt]);\n        for(ll j=0;j<now.size();j++) {\n            ll t=now[j];\n            for(ll k=0;k<conn[t].size();k++) {\n                if(conn[t][k]==npar[t]) break;\n                dir[t].push_back(conn[t][k]),inv_dir[conn[t][k]]++;\n            }\n        }\n        for(ll j=0;j<now.size();j++) {\n            ll t=now[j];\n            if(chk[t]==0&&inv_dir[t]==0) {\n                pll tmp=counter(t);\n                val[i]*=tmp.second*power(fact[tmp.first],MOD-2)%MOD; val[i]%=MOD;\n            }\n        }\n        while(!now.empty()){ll t=now.back(); dir[t].clear(); inv_dir[t]=0; npar[t]=0; chk[t]=i; now.pop_back();}\n    }\n    return (val[0]+val[1])%MOD;\n}\nint main(){\n    scanf(\"%lld\",&N);\n    for(ll i=1;i<=2*N;i++){\n        ll t1,t2;\n        scanf(\" %lld %lld\",&t1,&t2); t2+=N;\n        cnt[t1]++, cnt[t2]++;\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    for(ll i=1;i<=2*N;i++) sort(conn[i].begin(),conn[i].end());\n    for(ll i=1;i<=2*N;i++) {\n        if(cnt[i]<=1) now.push_back(i);\n    }\n    while(!now.empty()){\n        ll u=now.back(),up=0;\n        now.pop_back();\n        if(cnt[u]==1){\n            cnt[u]=0;\n            for(ll i=0;i<conn[u].size();i++) if(par[conn[u][i]]==0){\n                cnt[conn[u][i]]--; up=conn[u][i];\n                if(cnt[conn[u][i]]<=1) now.push_back(conn[u][i]);\n            }\n            par[u]=up;\n        }\n        else{\n            printf(\"0\\n\");\n            return 0;\n        }\n    }\n    for(ll i=1;i<=2*N;i++) if(par[i]==0&&conn[i].size()<2){\n        printf(\"0\\n\");\n        return 0;\n    }\n    fact[0]=1;\n    for(ll i=1;i<=2*N;i++) fact[i]=fact[i-1]*i%MOD;\n    for(ll i=1;i<=2*N;i++){\n        if(par[i]==0&&chk[i]==0) {\n            fin*=calc(i),fin%=MOD;\n        }\n    }\n    fin*=fact[2*N],fin%=MOD;\n    printf(\"%lld\\n\",fin);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) // fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 200005, mod = 1000000007;\nint head[maxn], nxt[maxn << 2], to[maxn << 2], hp = 1;\n\ninline ll power(ll x, int k) {\n\tif(k < 0) k += mod - 1;\n\tll res = 1;\n\twhile(k) {\n\t\tif(k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline void add(int u, int v, int *h) {\n\tnxt[++ hp] = h[u];\n\th[u] = hp;\n\tto[hp] = v;\n}\n\nint tmp[maxn], tp;\nbool vis[maxn];\nint cx, cy;\nvoid dfs(int u, int f) {\n\ttmp[++ tp] = u;\n\tvis[u] = 1;\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f) {\n\t\t\tif(vis[to[i]]) {\n\t\t\t\tcx = u;\n\t\t\t\tcy = to[i];\n\t\t\t} else\n\t\t\t\tdfs(to[i], u);\n\t\t}\n}\n\nint match[maxn];\nvoid mdfs(int u, int f) {\n\t/* debug(\"%d %d\\n\", u, f); */\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f and to[i] != cx) {\n\t\t\tmatch[to[i]] = u;\n\t\t\tmdfs(to[i], u);\n\t\t}\n}\n\nint Head[maxn];\nint deg[maxn];\nint stack[maxn], sp;\nll f[maxn];\nint size[maxn];\nll fac[maxn], ifac[maxn];\n\ninline ll C(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nvoid dp(int u) {\n\tsize[u] = 0;\n\tf[u] = 1;\n\tfor(int i = Head[u]; i; i = nxt[i]) {\n\t\tdp(to[i]);\n\t\tsize[u] += size[to[i]];\n\t\t(f[u] *= f[to[i]]) %= mod;\n\t\t(f[u] *= C(size[u], size[to[i]])) %= mod;\n\t}\n\t++ size[u];\n\tdebug(\"%d : %lld %d\\n\", u, f[u], size[u]);\n}\n\nint HP;\nll solve() {\n\tdebug(\"solve %d %d\\n\", cx, cy);\n\tmdfs(cx, cy);\n\tmatch[cx] = cy;\n\n\thp = HP;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tdeg[tmp[i]] = Head[tmp[i]] = 0;\n\n\tfor(int id = 1; id <= tp; id ++) {\n\t\tint u = tmp[id];\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] < match[u]) {\n\t\t\t\tdebug(\"%d -> %d\\n\", u, to[i]);\n\t\t\t\tadd(u, to[i], Head);\n\t\t\t\t++ deg[to[i]];\n\t\t\t}\n\t}\n\n\tHead[0] = 0;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tif(!deg[tmp[i]])\n\t\t\tadd(0, tmp[i], Head);\n\n\tdp(0);\n\tdebug(\"get %lld\\n\", f[0]);\n\n\treturn f[0];\n}\n\nint main() {\n\tint n = read;\n\n\tint N = n << 1 | 1;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[N] = power(fac[N], -1);\n\tfor(int i = N; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n\n\tfor(int i = 1; i < N; i ++) {\n\t\tint x = read, y = read;\n\t\tadd(x, n + y, head);\n\t\tadd(n + y, x, head);\n\t}\n\n\tHP = hp;\n\tll ans = 1;\n\tint SIZE = 0;\n\n\tfor(int r = 1; r < N; r ++)\n\t\tif(!vis[r]) {\n\t\t\ttp = 0;\n\t\t\tdfs(r, 0);\n\t\t\tll now = solve();\n\t\t\tstd::swap(cx, cy);\n\t\t\tnow += solve();\n\t\t\tSIZE += size[0] - 1;\n\t\t\t(ans *= now) %= mod;\n\t\t\t(ans *= C(SIZE, size[0] - 1)) %= mod;\n\t\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6 + 5;\n\n#define st first\n#define nd second\n\ntypedef pair<int,int> pun;\ntypedef long long ll;\n\nint mod = 1000 * 1000 * 1000 + 7;\n\nlong long pow(int a, int k) {\n\tif (k == 0) return 1;\n\tif (k == 1) return a;\n\tlong long b = pow(a, k / 2);\n\tb = b * b % mod;\n\tif (k % 2) b = a * b % mod;\n\treturn b;\n}\n\nlong long odw(int a) {\n\treturn pow(a, mod - 2);\n}\n\nlong long silnia[N];\nlong long odw_silnia[N];\n\nlong long newton(int n, int k) {\n\treturn (silnia[n] * odw_silnia[n - k] % mod) * odw_silnia[k] % mod;\n}\n\nvector<int> G[N];\nint deg[N];\nint skierowany[N];\nvector<int> odw_skierowany[N];\nint vis[N];\nint timer = 0;\n\nlong long wynik = 1;\nint size_so_far;\nvector<int> skladowa;\n\nvoid dfs_skladowa(int x) {\n\tif (vis[x]) return;\n\tvis[x] = timer;\n\tskladowa.push_back(x);\n\tfor (int y : G[x]) {\n\t\tdfs_skladowa(y);\n\t}\n}\n\nvector<int> cykl;\n\nvoid dfs_cykl(int x) {\n\tif (vis[x] == timer) return;\n\tvis[x] = timer;\n\tcykl.push_back(x);\n\tfor (int y: G[x]) dfs_cykl(y);\n}\n\nlong long mozliwosci;\nlong long tmp;\n\nvector<int> F[N];\nvector<int> transF[N];\n\nint size[N];\nlong long res[N];\n\nvoid dfs_dziwny(int x) {\n\tif (vis[x] == timer) return;\n\tvis[x] = timer;\n\tsize[x] = 0;\n\tres[x] = 1;\n\tfor (int y: F[x]) {\n\t\tdfs_dziwny(y);\n\t\tsize[x] += size[y];\n\t\tres[x] = (res[x] * res[y]) % mod;\n\t\tres[x] = (res[x] * newton(size[x], size[y])) % mod;\n\t}\n\tsize[x] ++;\n// \tprintf(\"dfs dziwny %d \", x);\n// \tprintf(\"%lld\\n\", res[x]);\n}\n\nvoid oblicz(int root, int size) {\n// \tprintf(\"oblicz %d\\n\", root);\n\ttimer ++;\n\tfor (int x: skladowa) {\n\t\tF[x].clear();\n\t\ttransF[x].clear();\n\t}\n\tF[0].clear();\n\tfor (int x: skladowa) {\n\t\tfor (int y: odw_skierowany[x]) {\n\t\t\tif (y < skierowany[x]) {\n\t\t\t\tF[x].push_back(y);\n\t\t\t\ttransF[y].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x: skladowa) {\n\t\tif (transF[x].empty() && (x != root || size == skladowa.size())) {\n\t\t\tF[0].push_back(x);\n\t\t}\n\t}\n\tdfs_dziwny(0);\n\tmozliwosci += res[0];\n\tmozliwosci %= mod;\n}\n\n\nvoid algos(int x) {\n\tskladowa.clear();\n\ttimer ++;\n\tdfs_skladowa(x);\n\ttimer ++;\n\tqueue<int> kol;\n\tint stopnie = 0;\n\tfor (int y : skladowa) {\n\t\tstopnie += deg[y];\n\t\tif (deg[y] <= 1) {\n\t\t\tkol.push(y);\n\t\t}\n\t}\n\tif (stopnie > skladowa.size() * 2) wynik = 0;\n\tint root = x;\n\twhile(!kol.empty()) {\n\t\tint y = kol.front();\n\t\troot = y;\n\t\tvis[y] = timer;\n\t\tkol.pop();\n\t\tfor (int z : G[y]) {\n\t\t\tif (vis[z] != timer) {\n\t\t\t\tskierowany[y] = z;\n\t\t\t\todw_skierowany[z].push_back(y);\n\t\t\t\tdeg[z] --;\n\t\t\t\tif (deg[z] == 1) {\n\t\t\t\t\tkol.push(z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmozliwosci = 0;\n\tfor (int y: skladowa) {\n\t\tif (vis[y] != timer) {\n\t\t\t//Medusa\n\t\t\tcykl.clear();\n\t\t\tdfs_cykl(y);\n\t\t\tfor (int i = 0; i < cykl.size() - 1; i ++) {\n\t\t\t\tskierowany[cykl[i]] = cykl[i+1];\n\t\t\t\todw_skierowany[cykl[i+1]].push_back(cykl[i]);\n\t\t\t}\n\t\t\tskierowany[cykl.back()] = cykl[0];\n\t\t\todw_skierowany[cykl[0]].push_back(cykl.back());\n\t\t\toblicz(cykl.back(), skladowa.size());\n\t\t\tfor (int i = 0; i < cykl.size(); i ++) {\n\t\t\t\todw_skierowany[cykl[i]].pop_back();\n\t\t\t}\n\t\t\tfor (int i = cykl.size() - 1; i > 0; i --) {\n\t\t\t\tskierowany[cykl[i]] = cykl[i-1];\n\t\t\t\todw_skierowany[cykl[i-1]].push_back(cykl[i]);\n\t\t\t}\n\t\t\tskierowany[cykl[0]] = cykl.back();\n\t\t\todw_skierowany[cykl.back()].push_back(cykl[0]);\n\t\t\toblicz(cykl[0], skladowa.size());\n\t\t\tgoto end;\n\t\t}\n\t}\n\t//Tree\n\toblicz(root, skladowa.size() - 1);\n\t\n\tend:\n\tsize_so_far += skladowa.size();\n\twynik *= newton(size_so_far, skladowa.size());\n\twynik %= mod;\n\twynik *= mozliwosci;\n\twynik %= mod;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 2 * n; i ++ ){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tG[a].push_back(b + n);\n\t\tG[b + n].push_back(a);\n\t\tdeg[a] ++;\n\t\tdeg[b + n] ++;\n\t}\n\tsilnia[0] = 1;\n\todw_silnia[0] = 1;\n\tfor (int i = 1; i <= 2 * n; i ++) {\n\t\tsilnia[i] = silnia[i - 1] * i % mod;\n\t\todw_silnia[i] = odw_silnia[i - 1] * odw(i) % mod;\n\t}\n\tfor (int i = 1; i <= 2 * n; i ++) {\n\t\tif (vis[i] == 0) {\n\t\t\talgos(i);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wynik);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#define MOD 1000000007\ntypedef long long ll; \ninline int quick_pow(int a, int n)\n{\n\tint res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (ll)res * a % MOD; \n\t\ta = (ll)a * a % MOD; \n\t\tn >>= 1; \n\t}\n\treturn res; \n}\nstd::map<int, int> idx_e[200005]; \nint lst[200005], to[400005], pre[400005], w[400005], tot; \nint st[200005], vis[200005], sz[200005], e, tp; \nint fact[200005], inv[200005], dp[200005], res; \nbool cyc, del[400005]; \ninline void add_edge(int u, int v, int _w)\n{\n\tto[tot] = v; \n\tpre[tot] = lst[u]; \n\tw[tot] = _w; \n\tidx_e[u][v] = tot; \n\tlst[u] = tot++; \n}\nvoid dfs(int u, int fa = -1)\n{\n\tvis[u] = 1; \n\tst[tp++] = u; \n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tint v = to[i]; \n\t\tif (v == fa)\n\t\t\tcontinue; \n\t\tif (vis[v] == 1)\n\t\t{\n\t\t\te = i; \n\t\t\tfor (int j = tp - 2; j >= 0; j--)\n\t\t\t{\n\t\t\t\tint cur = idx_e[st[j]][st[j + 1]]; \n\t\t\t\tif (w[cur] > w[e])\n\t\t\t\t\te = cur;\n\t\t\t\tif (st[j] == v)\n\t\t\t\t\tbreak; \n\t\t\t}\n\t\t\tif (cyc)\n\t\t\t{\n\t\t\t\tputs(\"0\");\n\t\t\t\texit(0); \n\t\t\t}\n\t\t\tcyc = true; \n\t\t}\n\t\telse if (!vis[v])\n\t\t\tdfs(v, u); \n\t}\n\tvis[u] = 2; \n\ttp--; \n}\nvoid work(int u, int fae)\n{\n\tsz[u] = 0; \n\tdp[u] = 1; \n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tint v = to[i]; \n\t\tif (i == fae || del[i])\n\t\t\tcontinue; \n\t\twork(v, i ^ 1); \n\t\tif (w[i] > w[fae])\n\t\t\tres = (ll)res * inv[sz[v]] % MOD * dp[v] % MOD; \n\t\telse\n\t\t{\n\t\t\tsz[u] += sz[v]; \n\t\t\tdp[u] = (ll)dp[u] * dp[v] % MOD * fact[sz[u]] % MOD\n\t\t\t * inv[sz[v]] % MOD * inv[sz[u] - sz[v]] % MOD; \n\t\t}\n\t}\n\tsz[u]++; \n}\nint main()\n{\n\t// freopen(\"ARC083-F.in\", \"r\", stdin); \n\tmemset(lst, -1, sizeof(lst)); \n\tint n; \n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n << 1; i++)\n\t{\n\t\tint x, y; \n\t\tscanf(\"%d%d\", &x, &y); \n\t\tx--; \n\t\ty--; \n\t\tadd_edge(x, y + n, x + y); \n\t\tadd_edge(y + n, x, x + y); \n\t}\n\tn <<= 1; \n\tfact[0] = inv[0] = 1; \n\tfor (int i = 1; i <= n; i++)\n\t\tfact[i] = (ll)fact[i - 1] * i % MOD; \n\tinv[n] = quick_pow(fact[n], MOD - 2); \n\tfor (int i = n; i; i--)\n\t\tinv[i - 1] = (ll)inv[i] * i % MOD; \n\tint ans = fact[n]; \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (vis[i])\n\t\t\tcontinue; \n\t\tcyc = false; \n\t\tdfs(i, 0); \n\t\tdel[e] = del[e ^ 1] = true; \n\t\tint sum = 0; \n\t\tres = 1; \n\t\twork(to[e], e ^ 1); \n\t\tsum += (ll)inv[sz[to[e]]] * dp[to[e]] % MOD * res % MOD; \n\t\tres = 1; \n\t\twork(to[e ^ 1], e); \n\t\tsum += (ll)inv[sz[to[e ^ 1]]] * dp[to[e ^ 1]] % MOD * res % MOD; \n\t\tans = (ll)ans * sum % MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ll long long\n#define N 200005\nusing namespace std;\nvector<int> e[N];\nint vis[N],du[N],fa[N],sz[N];\nint q[N],t,nq[N],n;\nll power(ll x,ll y){\n\tll s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nll solve(int rt){\n\tt=1; q[1]=rt; vis[rt]=1;\n\tfor (int h=1;h<=t;h++){\n\t\tint x=q[h]; du[x]=0;\n\t\tsz[x]=1; fa[x]=0;\n\t\tfor (int i=0;i<e[x].size();i++){\n\t\t\tint to=e[x][i];\n\t\t\tif (!vis[to]){\n\t\t\t\tq[++t]=to;\n\t\t\t\tvis[to]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint ecnt=0;\n\tfor (int i=1;i<=t;i++)\n\t\tfor (int j=0;j<e[q[i]].size();j++)\n\t\t\tdu[e[q[i]][j]]++,ecnt++;\n\tif (ecnt/2!=t) return 0;\n\tint nt=0;\n\tfor (int i=1;i<=t;i++)\n\t\tif (du[q[i]]==1) nq[++nt]=q[i];\n\tfor (int h=1;h<=nt;h++){\n\t\tint x=nq[h];\n\t\tfor (int i=0;i<e[x].size();i++){\n\t\t\tint to=e[x][i];\n\t\t\tif (--du[to]){\n\t\t\t\tfa[x]=to;\n\t\t\t\tif (du[to]==1)\n\t\t\t\t\tnq[++nt]=to;\n\t\t\t\telse rt=to;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x=rt;;){\n\t\tfor (int i=0;i<e[x].size();i++)\n\t\t\tif (du[e[x][i]]>1&&fa[e[x][i]]!=x){\n\t\t\t\tfa[x]=e[x][i]; x=e[x][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (x==rt) break;\n\t}\n\tll ans=1;\n\tfor (int i=1;i<=nt;i++){\n\t\tint x=nq[i];\n\t\tans=ans*sz[x]%mo;\n\t\tif (x<fa[fa[x]]) sz[fa[x]]+=sz[x];\n\t}\n\tfor (int x=rt;;){\n\t\tif (x>fa[fa[x]]){\n\t\t\trt=fa[x];\n\t\t\tbreak;\n\t\t}\n\t\tx=fa[x];\n\t\tif (x==rt) return 0;\n\t}\n\tfor (int x=rt;;){\n\t\tans=ans*sz[x]%mo;\n\t\tif (x<fa[fa[x]]) sz[fa[x]]+=sz[x];\n\t\tx=fa[x]; if (x==rt) break;\n\t}\n\treturn power(ans,mo-2);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n*2;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].push_back(y+n);\n\t\te[y+n].push_back(x);\n\t}\n\tll ans=1;\n\tfor (int i=1;i<=n*2;i++)\n\t\tans=ans*i%mo;\n\tfor (int x=1;x<=n*2;x++)\n\t\tif (!vis[x]){\n\t\t\tll s=solve(x);\n\t\t\tfor (int i=1;i<=t;i++){\n\t\t\t\tint x=q[i]; vis[x]=0;\n\t\t\t\treverse(e[x].begin(),e[x].end());\n\t\t\t}\n\t\t\tans=ans*(s+solve(x))%mo;\n\t\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define mod 1000000007\n#define next nxt\n\nint n,x[N],y[N],z[N],next[N],p[N],h[N],q[N],f[N],g[N],s[N],cnt,cmt,cir;\nlong long fac[N],inv[N],ans;\nvector<int> v[N];\n\nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nvoid travel(int x,int pre){\n\th[x]=true;q[++cnt]=x;\n\tfor (int t=p[x];t;cmt++,t=next[t])\n\t\tif (!h[y[t]]) travel(y[t],t);\n\t\telse if (t/2!=pre/2) cir=t;\n}\n\nvoid build(int x,int pre){\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (t/2!=pre/2){\n\t\t\tif (y[t]<y[pre^1]) v[x].push_back(y[t]),f[y[t]]=true;\n\t\t\tif (t/2!=cir/2) g[y[t]]=x,build(y[t],t);\n\t\t}\n}\n\nlong long solve(int x){\n\ts[x]=0;long long ans=1;\n\tfor (int i=0;i<(int)v[x].size();i++){\n\t\tans=ans*solve(v[x][i])%mod;\n\t\ts[x]+=s[v[x][i]];\n\t\tans=ans*C(s[x],s[v[x][i]])%mod;\n\t}\n\ts[x]++;return ans;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=2*n;i++){\n\t\tx[2*i]=y[2*i+1]=read();\n\t\ty[2*i]=x[2*i+1]=n+read();\n\t\tz[2*i]=z[2*i+1]=x[2*i]+y[2*i];\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t\tnext[2*i+1]=p[x[2*i+1]];p[x[2*i+1]]=2*i+1;\n\t}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tans=fac[2*n];\n\tfor (int i=1;i<=2*n;i++)\n\t\tif (!h[i]){\n\t\t\tcnt=cmt=0;travel(i,0);\n\t\t\tif (cmt!=cnt*2) {printf(\"0\\n\");return 0;}\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),g[q[i]]=0,f[q[i]]=false;\n\t\t\tbuild(x[cir],cir);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!f[q[i]]) v[0].push_back(q[i]);\n\t\t\tlong long tmp=solve(0);\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),g[q[i]]=0,f[q[i]]=false;\n\t\t\tbuild(y[cir],cir);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!f[q[i]]) v[0].push_back(q[i]);\n\t\t\ttmp+=solve(0);\n\t\t\t\n\t\t\tans=ans*tmp%mod*inv[cnt]%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=4e5+10;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nconst int mod=1e9+7;\nint fac[N],inv[N],e[N];\nint head[N],nxt[N],to[N],w[N];\nint siz[N],ans,f[N],V,E,C;\nbool vis[N];\ninline int binom(int n,int m) { return 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod; }\ninline void dfs(int k,int fa) {\n\tvis[k]=true;V++;\n\tfor (int i=head[k];i;i=nxt[i],E++)\n\t\tif (!vis[to[i]])\n\t\t\te[to[i]]=i^1,dfs(to[i],k);\n\t\telse if (to[i]!=fa) C=i;\n}\ninline void dp(int k,int e) {\n\tf[k]=1;siz[k]=0;\n\tfor (int i=head[k];i;i=nxt[i])\n\t\tif (i/2!=C/2&&(i^1^e)) {\n\t\t\tdp(to[i],i);\n\t\t\tif (w[i]>w[e])\n\t\t\t\tans=1LL*ans*inv[siz[to[i]]]%mod*f[to[i]]%mod;\n\t\t\telse\n\t\t\t\tf[k]=1LL*f[k]*f[to[i]]%mod*binom(siz[k]+=siz[to[i]],siz[to[i]])%mod;\n\t\t}\n\tsiz[k]++;\n}\nint main()\n{\n\tint n=gi()*2,i,tot=1,a,b,sum,k;\n\t\n\tfor (i=fac[0]=1;i<=n;i++) fac[i]=1LL*fac[i-1]*i%mod;\n\tfor (i=2,inv[0]=inv[1]=1;i<=n;i++) inv[i]=mod-1LL*(mod/i)*inv[mod%i]%mod;\n\tfor (i=3;i<=n;i++) inv[i]=1LL*inv[i]*inv[i-1]%mod;\n\t\n\tfor (i=1;i<=n;i++) {\n\t\ta=gi(),b=gi()+n/2;\n\t\tto[++tot]=b,nxt[tot]=head[a],head[a]=tot;\n\t\tto[++tot]=a,nxt[tot]=head[b],head[b]=tot;\n\t\tw[tot]=w[tot^1]=a+b;\n\t}\n\n\tint res=fac[n];\n\tfor (k=1;k<=n;k++)\n\t\tif (!vis[k]) {\n\t\t\tV=E=C=0;\n\t\t\tdfs(k,0);\n\t\t\tif (V*2!=E) return puts(\"0\"),0;\n\t\t\tfor (a=to[C],b=to[C^1];a!=b;a=to[e[a]]) if (w[e[a]]>w[C]) C=e[a];\n\t\t\tans=1;\n\t\t\tdp(to[C],C);\n\t\t\tsum=1LL*ans*inv[siz[to[C]]]%mod*f[to[C]]%mod;\n\t\t\tans=1;\n\t\t\tdp(to[C^1],C);\n\t\t\tsum=(sum+1LL*ans*inv[siz[to[C^1]]]%mod*f[to[C^1]])%mod;\n\t\t\tres=1LL*res*sum%mod;\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <algorithm>\n#include<bits/stdc++.h> \nint read()\n{\n    int x = 0, f = 1;\n    char ch = getchar();\n    while ((ch < '0') || (ch > '9'))\n    {\n        if (ch == '-')\n        {\n            f = -f;\n        }\n        ch = getchar();\n    }\n    while ((ch >= '0') && (ch <= '9'))\n    {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    return x * f;\n}\n\nconst int maxn = 100000;\nconst int maxv = maxn * 2;\nconst int maxe = maxv * 2;\nconst int mod = 1000000007;\n\nstd::queue<int> q;\nstd::vector<int> cur;\nint n, pre[maxe + 10], now[maxv + 10], son[maxe + 10], tot, _pre[maxe + 10], _now[maxv + 10], _son[maxe + 10], _tot, vis[maxv + 10], ecnt, cir[maxv + 10], deg[maxv + 10], choose[maxv + 10], fac[maxv + 10], ifac[maxv + 10], f[maxv + 10], size[maxv + 10];\n\nint C(int a, int b)\n{\n    return 1ll * fac[a] * ifac[b] % mod * ifac[a - b] % mod;\n}\n\nint _ins(int a, int b)\n{\n    _pre[++_tot] = _now[a];\n    _now[a] = _tot;\n    _son[_tot] = b;\n    return 0;\n}\n\nint calc()\n{\n    for (auto i : cur)\n    {\n        deg[i] = _now[i] = 0;\n    }\n    for (auto i : cur)\n    {\n        for (int j = now[i]; j; j = pre[j])\n        {\n            int v = son[j];\n            if (v < choose[i])\n            {\n                _ins(v, i);\n                ++deg[i];\n            }\n        }\n    }\n    for (auto i : cur)\n    {\n        if (!deg[i])\n        {\n            q.push(i);\n        }\n        f[i] = 1;\n        size[i] = 1;\n    }\n    int sz = 0, ans = 1;\n    while (!q.empty())\n    {\n        int u = q.front(), flag = 0;\n        q.pop();\n        for (int i = _now[u]; i; i = _pre[i])\n        {\n            flag = 1;\n            int v = _son[i];\n            --deg[v];\n            size[v] += size[u];\n            f[v] = 1ll * f[v] * f[u] % mod * C(size[v] - 1, size[u]) % mod;\n            if (!deg[v])\n            {\n                q.push(v);\n            }\n        }\n        if (!flag)\n        {\n            sz += size[u];\n            ans = 1ll * ans * f[u] % mod * C(sz, size[u]) % mod;\n        }\n    }\n    return ans;\n}\n\nint ins(int a, int b)\n{\n    pre[++tot] = now[a];\n    now[a] = tot;\n    son[tot] = b;\n    return 0;\n}\n\nint dfs(int u)\n{\n    vis[u] = 1;\n    cur.push_back(u);\n    for (int i = now[u]; i; i = pre[i])\n    {\n        ++ecnt;\n        int v = son[i];\n        if (!vis[v])\n        {\n            dfs(v);\n        }\n    }\n    return 0;\n}\n\nint search(int u)\n{\n    cir[++cir[0]] = u;\n    vis[u] = 1;\n    for (int i = now[u]; i; i = pre[i])\n    {\n        int v = son[i];\n        if (!vis[v])\n        {\n            search(v);\n        }\n    }\n    return 0;\n}\n\nint solve()\n{\n    if ((int)cur.size() != ecnt)\n    {\n        return 0;\n    }\n    for (auto i : cur)\n    {\n        if (deg[i] == 1)\n        {\n            q.push(i);\n        }\n    }\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for (int i = now[u]; i; i = pre[i])\n        {\n            int v = son[i];\n            if (deg[v] != 1)\n            {\n                --deg[v];\n                choose[u] = v;\n                if (deg[v] == 1)\n                {\n                    q.push(v);\n                }\n            }\n        }\n    }\n    int st = 0;\n    for (auto i : cur)\n    {\n        if (deg[i] > 1)\n        {\n            st = i;\n            vis[i] = 0;\n        }\n    }\n    cir[0] = 0;\n    search(st);\n    cir[cir[0] + 1] = cir[1];\n    for (int i = 1; i <= cir[0]; ++i)\n    {\n        choose[cir[i]] = cir[i + 1];\n    }\n    int res = calc();\n    for (int i = 2; i <= cir[0] + 1; ++i)\n    {\n        choose[cir[i]] = cir[i - 1];\n    }\n    res += calc();\n    if (res >= mod)\n    {\n        res -= mod;\n    }\n    for (auto i : cur)\n    {\n        vis[i] = 1;\n    }\n    return res;\n}\n\nint main()\n{\n    n = read();\n    fac[0] = 1;\n    for (int i = 1; i <= n << 1; ++i)\n    {\n        fac[i] = 1ll * fac[i - 1] * i % mod;\n    }\n    ifac[0] = ifac[1] = 1;\n    for (int i = 2; i <= n << 1; ++i)\n    {\n        ifac[i] = 1ll * (mod - mod / i) * ifac[mod % i] % mod;\n    }\n    for (int i = 2; i <= n << 1; ++i)\n    {\n        ifac[i] = 1ll * ifac[i - 1] * ifac[i] % mod;\n    }\n    for (int i = 1; i <= n << 1; ++i)\n    {\n        int x = read(), y = read();\n        ins(x, y + n);\n        ins(y + n, x);\n        ++deg[x];\n        ++deg[y + n];\n    }\n    int tsize = 0, ans = 1;\n    for (int i = 1; i <= n << 1; ++i)\n    {\n        if (!vis[i])\n        {\n            cur.clear();\n            ecnt = 0;\n            dfs(i);\n            ecnt /= 2;\n            int res = solve();\n            tsize += ecnt;\n            ans = 1ll * ans * res % mod * C(tsize, ecnt) % mod;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nvoid Get_Val(int &Ret)\n{\n\tRet = 0;\n\tchar ch;\n\twhile (ch = getchar(), ch > '9' || ch < '0')\n\t\t;\n\tdo\n\t{\n\t\t(Ret *= 10) += ch - '0';\n\t}\n\twhile (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\ninline int Mult(const int &a, const int &b)\n{\n\treturn (a * 1LL) * b % MOD;\n}\n\ninline void update(int &a, const int &b)\n{\n\t((a += b) >= MOD) ? (a -= MOD) : 0;\n}\n\nvoid exgcd(const int &a, const int &b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(const int &a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\n//把x轴上的机器人当成X集合的点，把y轴上的机器人当成Y集合的点，一个球(xi, yi)当成一条连接X[xi]和Y[yi]的一条边，边权为xi + yi\n//这样就构成了一个点数为2N边数为2N的图，每次激活一个机器人等价于删去对应的点和与该点相连的未被删除的边权最小的边（唯一）\n//考虑每个联通块，必有边数 <= 点数，由于整个图边数 = 点数，所以每个联通块均有边数 = 点数，即是一个基环树\n//我们可以得出结论：每个点都与一条边一一对应\n//树上的点显然只有唯一的对应方式，即每个点对应自己的父亲边。而环上也只有两种对应方式，可以枚举是哪一种 \n//考虑x期望对应的边e，那么删去x时不能存在边权比e小的边，即所有与x相连边权比e小的边的连接的点y都要先于x删除 \n//对于这样的(x, y)，我们从x向y连边，这样一定得到了一个森林 \n//问题转化成给树上每个点标上连续且互不相等的标号使得父亲的标号小于孩子的标号，直接树形dp计数即可 \n\nconst int Max_N(100050);\n\nint N, Fac[Max_N], Inv[Max_N];\n\ninline int C(const int &n, const int &m)\n{\n\treturn (n < m) ? 0 : Mult(Fac[n], Mult(Inv[m], Inv[n - m]));\n}\n\nnamespace T\n{\n\tint Head[Max_N << 1], Total, From[Max_N << 1], To[Max_N << 1], Next[Max_N << 1];\n\tint F[Max_N << 1], Size[Max_N << 1];\n\tbool In[Max_N << 1];\n\tvoid clear()\n\t{\n\t\tfor (int i = 1;i <= Total;++i)\n\t\t\tHead[From[i]] = In[To[i]] = false, From[i] = To[i] = Next[i] = 0;\n\t\tTotal = 0;\n\t}\n\tinline void Add_Edge(const int &s, const int &t)\n\t{\n\t\t++Total, From[Total] = s, To[Total] = t, Next[Total] = Head[s], Head[s] = Total, In[t] = true;\n\t}\n\tvoid dp(const int &u)\n\t{\n\t\tF[u] = 1, Size[u] = 0;\n\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\tdp(v = To[i]), F[u] = Mult(F[u], Mult(F[v], C(Size[u] += Size[v], Size[v])));\n\t\t++Size[u];\n\t}\n}\n\nnamespace G\n{\n\tstruct edge\n\t{\n\t\tedge(const int &_t = 0, const int &_w = 0) : t(_t), w(_w) {}\n\t\tint t, w;\n\t};\n\tinline bool comp(const edge &a, const edge &b)\n\t{\n\t\treturn a.w < b.w;\n\t}\n\tint Head[Max_N << 1], Total, To[Max_N << 2], Next[Max_N << 2], Weight[Max_N << 2], A, B;\n\tint dfsclock, Pre[Max_N << 1];\n\tbool Cut[Max_N << 2], done[Max_N << 1];\n\tvector<edge> E[Max_N << 1];\n\tinline void Add_Edge(const int &tot, const int &s, const int &t, const int &w)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Weight[tot] = w, E[s].push_back(edge(t, w));\n\t}\n\tinline void Add_Link(const int &u, const int &v, const int &w)\n\t{\n\t\tTotal += 2, Add_Edge(Total, u, v, w), Add_Edge(Total ^ 1, v, u, w);\n\t}\n\tint Tarjan(const int &u, const int &fa)\n\t{\n\t\tint lowu(Pre[u] = ++dfsclock), lowv;\n\t\t++A;\n\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t{\n\t\t\t++B;\n\t\t\tif (!Pre[v = To[i]])\n\t\t\t{\n\t\t\t\tlowu = min(lowu, lowv = Tarjan(v, u));\n\t\t\t\tif (lowv > Pre[u])\n\t\t\t\t\tCut[i] = Cut[i ^ 1] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (v != fa && Pre[v] < Pre[u])\n\t\t\t\t\tlowu = min(lowu, Pre[v]);\n\t\t}\n\t\treturn lowu;\n\t}\n\tint Tot, V[Max_N << 1], Sum, NowSum, dpAns, go[Max_N << 1];\n\tvoid dfscircle(const int &u)\n\t{\n\t\tdone[V[++Tot] = u] = true;\n\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\tif (!done[v = To[i]] && !Cut[i])\n\t\t\t\tdfscircle(v);\n\t}\n\tvoid insert(const int &x, const int &eto)\n\t{\n\t\tfor (int i = 0;i < E[x].size();++i)\n\t\t\tif (E[x][i].t == eto)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tT::Add_Edge(x, E[x][i].t);\n\t}\n\tvoid maketree(const int &u, const int &fa)\n\t{\n\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\tif (Cut[i] && (v = To[i]) != fa)\n\t\t\t\tmaketree(v, u), insert(v, u), ++NowSum;\n\t}\n\tvoid dp(const int &u, const int &gg)\n\t{\n\t\tif (go[u] == gg)\n\t\t\treturn;\n\t\t++go[u];\n\t\tif (!T::In[u])\n\t\t\tT::dp(u), dpAns = Mult(dpAns, Mult(T::F[u], C(NowSum += T::Size[u], T::Size[u])));\n\t\tfor (int i = Head[u];i;i = Next[i])\n\t\t\tdp(To[i], gg);\n\t}\n\tvoid work()\n\t{\n\t\tint Ans(1);\n\t\tfor (int i = 1;i <= (N << 1);++i)\n\t\t{\n\t\t\tsort(E[i].begin(), E[i].end(), comp);\n\t\t\tif (!Pre[i])\n\t\t\t\tA = B = 0, Tarjan(i, -1), B /= 2;\n\t\t\tif (A != B)\n\t\t\t{\n\t\t\t\tprintf(\"0\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (int u = 1, val;u <= (N << 1);++u)\n\t\t\tif (!done[u])\n\t\t\t{\n\t\t\t\tTot = val = 0, dfscircle(u);\n\t\t\t\tif (Tot >= 2)\n\t\t\t\t{\n\t\t\t\t\tT::clear();\n\t\t\t\t\tfor (int i = 1;i <= Tot;++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaketree(V[i], -1);\n\t\t\t\t\t\tif (i - 1 >= 1)\n\t\t\t\t\t\t\tinsert(V[i], V[i - 1]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinsert(V[i], V[Tot]);\n\t\t\t\t\t}\n\t\t\t\t\tNowSum = 0, dpAns = 1, dp(V[1], 1), update(val, dpAns);\n\t\t\t\t\tT::clear();\n\t\t\t\t\tfor (int i = 1;i <= Tot;++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaketree(V[i], -1);\n\t\t\t\t\t\tif (i + 1 <= Tot)\n\t\t\t\t\t\t\tinsert(V[i], V[i + 1]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinsert(V[i], V[1]);\n\t\t\t\t\t}\n\t\t\t\t\tNowSum = 0, dpAns = 1, dp(V[1], 2), update(val, dpAns);\n\t\t\t\t\tAns = Mult(Ans, Mult(val, C(Sum += NowSum, NowSum)));\n\t\t\t\t}\n\t\t\t}\n\t\tprintf(\"%d\", Ans);\n\t}\n}\n\nint main()\n{\n\tGet_Val(N);\n\tfor (int i = 1, x, y;i <= (N << 1);++i)\n\t\tGet_Val(x), Get_Val(y), G::Add_Link(x, N + y, x + y);\n\tFac[0] = 1;\n\tfor (int i = 1;i <= (N << 1);++i)\n\t\tFac[i] = Mult(Fac[i - 1], i);\n\tInv[N << 1] = inverse(Fac[N << 1]);\n\tfor (int i = (N << 1) - 1;i >= 0;--i)\n\t\tInv[i] = Mult(Inv[i + 1], i + 1);\n\tG::work();\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 33; i++) {\n\t\tif ((b & (1LL << i)) != 0) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long a, long long b, long long m) {\n\treturn (a * modpow(b, m - 2, m)) % m;\n}\n\nlong long N, X[1 << 18], Y[1 << 18], dir[1 << 18];\nlong long cntX[1 << 18], cntY[1 << 18];\nvector<pair<long long, long long> > GX[1 << 17], GY[1 << 17];\nvector<int> G[1 << 18], G2[1 << 18];\nint pre_G[1 << 18], pre_G2[1 << 18];\n\nconst long long mod = 1000000007;\nlong long cur[1 << 18];\nlong long ret = 0;\nlong long ret2 = 0;\nvector<int> E, E2;\n\nint dfs(int pos) {\n\tint mi = 1;\n\tfor (int i : G[pos]) mi += dfs(i);\n\tret *= mi; ret %= mod;\n\treturn mi;\n}\n\nint dfs2(int pos) {\n\tint mi = 1;\n\tfor (int i : G[pos]) mi += dfs2(i);\n\tret *= mi; ret %= mod;\n\tret2 *= cur[pos]; ret2 %= mod;\n\treturn mi;\n}\n\nvoid add_edge(int pos) {\n\tif (dir[pos] == 1) {\n\t\tint pos1 = lower_bound(GX[X[pos]].begin(), GX[X[pos]].end(), make_pair(Y[pos], 1LL * pos)) - GX[X[pos]].begin();\n\t\tfor (int j = 0; j < pos1; j++) { G[pos].push_back(GX[X[pos]][j].second); G2[GX[X[pos]][j].second].push_back(pos); E2.push_back(GX[X[pos]][j].second); }\n\t}\n\tif (dir[pos] == 2) {\n\t\tint pos1 = lower_bound(GY[Y[pos]].begin(), GY[Y[pos]].end(), make_pair(X[pos], 1LL * pos)) - GY[Y[pos]].begin();\n\t\tfor (int j = 0; j < pos1; j++) { G[pos].push_back(GY[Y[pos]][j].second); G2[GY[Y[pos]][j].second].push_back(pos); E2.push_back(GY[Y[pos]][j].second); }\n\t}\n}\n\nint main() {\n\t// ステップ 1: 入力・前処理\n\tscanf(\"%lld\", &N);\n\tfor (int i = 1; i <= 2 * N; i++) {\n\t\tscanf(\"%lld%lld\", &X[i], &Y[i]);\n\t\tcntX[X[i]]++; GX[X[i]].push_back(make_pair(Y[i], i));\n\t\tcntY[Y[i]]++; GY[Y[i]].push_back(make_pair(X[i], i));\n\t}\n\tfor (int i = 1; i <= N; i++) sort(GX[i].begin(), GX[i].end());\n\tfor (int i = 1; i <= N; i++) sort(GY[i].begin(), GY[i].end());\n\tfor (int i = 1; i <= N; i++) { if (cntX[i] == 0) { cout << \"0\" << endl; return 0; } }\n\tfor (int i = 1; i <= N; i++) { if (cntY[i] == 0) { cout << \"0\" << endl; return 0; } }\n\n\t// ステップ 2: ある程度決める\n\tqueue<pair<int, int>> Q;\n\tfor (int i = 1; i <= N; i++) { if (cntX[i] == 1) Q.push(make_pair(1, i)); }\n\tfor (int i = 1; i <= N; i++) { if (cntY[i] == 1) Q.push(make_pair(2, i)); }\n\twhile (!Q.empty()) {\n\t\tint pos1 = Q.front().first, pos2 = Q.front().second; Q.pop();\n\t\tint num = -1;\n\t\tif (pos1 == 1) { for (pair<long long, long long> i : GX[pos2]) { if (dir[i.second] == 0) num = i.second; } }\n\t\tif (pos1 == 2) { for (pair<long long, long long> i : GY[pos2]) { if (dir[i.second] == 0) num = i.second; } }\n\t\tdir[num] = pos1; cntX[X[num]]--; cntY[Y[num]]--;\n\t\tif (pos1 == 1) { if (cntY[Y[num]] == 1) Q.push(make_pair(2, Y[num])); }\n\t\tif (pos1 == 2) { if (cntX[X[num]] == 1) Q.push(make_pair(1, X[num])); }\n\t}\n\n\t// ステップ 3: 既に決まったところに辺を貼る\n\tfor (int i = 1; i <= 2 * N; i++) {\n\t\tif (dir[i] == 0) continue;\n\t\tadd_edge(i);\n\t}\n\tfor (int i = 1; i <= 2 * N; i++) pre_G[i] = G[i].size();\n\tfor (int i = 1; i <= 2 * N; i++) pre_G2[i] = G2[i].size();\n\n\t// ステップ 4: 幅優先探索で確率を求める\n\tlong long val = 1;\n\tfor (int i = 1; i <= 2 * N; i++) {\n\t\tif (G2[i].size() >= 1) { cur[i] = 1; continue; }\n\t\tret = 1; dfs(i);\n\t\tcur[i] = ret; val *= ret; val %= mod;\n\t}\n\tlong long Answer = Div(1, val, mod);\n\n\t// ステップ 5: それぞれの場合に計算する\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (cntX[i] == 0) continue;\n\n\t\t// 最終的に記録しておく割合\n\t\tlong long wari1 = 0;\n\t\tlong long wari2 = 0;\n\n\t\t// 方向が 1 の場合\n\t\tE.clear(); E2.clear(); Q.push(make_pair(1, i));\n\t\twhile (!Q.empty()) {\n\t\t\tint pos1 = Q.front().first, pos2 = Q.front().second; Q.pop();\n\t\t\tint num = -1;\n\t\t\tif (pos1 == 1) { for (pair<long long, long long> i : GX[pos2]) { if (dir[i.second] == 0) num = i.second; } }\n\t\t\tif (pos1 == 2) { for (pair<long long, long long> i : GY[pos2]) { if (dir[i.second] == 0) num = i.second; } }\n\t\t\tdir[num] = pos1; cntX[X[num]]--; cntY[Y[num]]--; E.push_back(num);\n\t\t\tif (pos1 == 1) { if (cntY[Y[num]] == 1) Q.push(make_pair(2, Y[num])); }\n\t\t\tif (pos1 == 2) { if (cntX[X[num]] == 1) Q.push(make_pair(1, X[num])); }\n\t\t}\n\t\tfor (int j : E) add_edge(j);\n\t\tret = 1; ret2 = 1;\n\t\tfor (int j : E) {\n\t\t\tif (G2[j].size() >= 1) continue;\n\t\t\tdfs2(j);\n\t\t}\n\t\twari1 = Div(ret, ret2, mod);\n\t\tfor (int j : E) { while (G[j].size() > pre_G[j]) G[j].pop_back(); }\n\t\tfor (int j : E2) { while (G2[j].size() > pre_G2[j]) G2[j].pop_back(); }\n\t\tE2.clear();\n\n\t\t// 方向が 2 の場合\n\t\tfor (int j : E) dir[j] = 3 - dir[j];\n\t\tfor (int j : E) add_edge(j);\n\t\tret = 1; ret2 = 1;\n\t\tfor (int j : E) {\n\t\t\tif (G2[j].size() >= 1) continue;\n\t\t\tdfs2(j);\n\t\t}\n\t\twari2 = Div(ret, ret2, mod);\n\t\tfor (int j : E) { while (G[j].size() > pre_G[j]) G[j].pop_back(); }\n\t\tfor (int j : E2) { while (G2[j].size() > pre_G2[j]) G2[j].pop_back(); }\n\t\tE2.clear();\n\n\t\t// 最終的な計算\n\t\tAnswer *= (Div(1, wari1, mod) + Div(1, wari2, mod));\n\t\tAnswer %= mod;\n\t}\n\n\tfor (int i = 1; i <= 2 * N; i++) {\n\t\tAnswer *= (1LL * i); Answer %= mod;\n\t}\n\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nconst int mod=1e9+7;\nint n,ans;\nint x[maxn],y[maxn],par[maxn],dep[maxn],deg[maxn];\nbool vis[maxn],incyc[maxn],done[maxn];\nvector<int>edge[maxn],cyc,nedge[maxn],path,qryx[maxn],qryy[maxn];\nint fac[maxn],ifac[maxn],dp[maxn],sz[maxn];\nbool ok;\nvector<pii>xs[maxn],ys[maxn];\n\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nvoid dfs1(int x,int p,int d){\n\tvis[x]=true;\n\tpar[x]=p;\n\tdep[x]=d;\n\tpath.pb(x);\n\trep(i,edge[x].size()){\n\t\tint y=edge[x][i];\n\t\tif(y==p||incyc[y])continue;\n\t\tif(!vis[y])dfs1(y,x,d+1);\n\t\telse if(dep[y]<dep[x]){\n\t\t\tif(!cyc.empty())ok=false;\n\t\t\tint z=x;\n\t\t\twhile(z!=y)cyc.pb(z),z=par[z];\n\t\t\tcyc.pb(z);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x){\n\tdp[x]=1;\n\tsz[x]=0;\n\trep(i,nedge[x].size()){\n\t\tint y=nedge[x][i];\n\t\tdfs2(y);\n\t\tdp[x]=1LL*dp[x]*C(sz[x]+sz[y],sz[y])%mod*dp[y]%mod; \n\t\tsz[x]+=sz[y];\n\t}\n\tsz[x]++;\n}\n\nvoid add(int cur,int nxt){\n\tif(cur<=n){\n\t\tint pos=lower_bound(xs[cur].begin(),xs[cur].end(),mp(nxt-n,0))-xs[cur].begin();\n\t\tqryx[cur].pb(pos);\n//\t\tcout<<\"add: \"<<cur<<\" \"<<pos<<endl;\n\t}\n\telse{\n\t\tint pos=lower_bound(ys[cur-n].begin(),ys[cur-n].end(),mp(nxt,0))-ys[cur-n].begin();\n\t\tqryy[cur-n].pb(pos);\n//\t\tcout<<\"add: \"<<cur-n<<\" \"<<pos<<endl;\n\t}\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2*n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,2*n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tREP(i,2*n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\txs[x[i]].pb(mp(y[i],i));\n\t\tys[y[i]].pb(mp(x[i],i));\n\t\tedge[x[i]].pb(y[i]+n);\n\t\tedge[y[i]+n].pb(x[i]);\n\t}\n\tREP(i,n){\n\t\tsort(xs[i].begin(),xs[i].end());\n\t\tsort(ys[i].begin(),ys[i].end());\n\t}\n\tans=1;\n\tint tsz=0;\n\tREP(i,2*n)if(!vis[i]){\n\t\tok=true;\n\t\tcyc.clear();\n\t\tpath.clear();\n\t\tdfs1(i,0,0);\n\t\tif(cyc.empty())ok=false;\n\t\tif(!ok){\n\t\t\tans=0;\n\t\t\tbreak;\n\t\t}\n\t\trep(j,cyc.size())incyc[cyc[j]]=true;//,cout<<cyc[j]<<\" \";\n//\t\tcout<<endl;\n\t\trep(j,path.size())vis[path[j]]=false;\n\t\tpath.clear();\n\t\trep(j,cyc.size())dfs1(cyc[j],0,0);\n//\t\trep(j,path.size())if(!incyc[path[j]])cout<<path[j]<<\" \"<<par[path[j]]<<endl;\n\t\tint sum=0;\n\t\tfor(int t=-1;t<=1;t+=2){\n\t\t\trep(j,path.size())done[path[j]]=false;\n\t\t\trep(j,path.size())if(!incyc[path[j]])add(path[j],par[path[j]]);\n\t\t\trep(j,cyc.size())add(cyc[j],cyc[(j+t+int(cyc.size()))%int(cyc.size())]);\n\t\t\tvector<int>tmp;\n\t\t\trep(j,path.size()){\n\t\t\t\tint x=path[j];\n\t\t\t\tif(done[x])continue;\n\t\t\t\tdone[x]=true;\n\t\t\t\tif(x<=n){\n\t\t\t\t\tsort(qryx[x].begin(),qryx[x].end());\n\t\t\t\t\tint last=-1;\n\t\t\t\t\trep(k,qryx[x].size()){\n\t\t\t\t\t\ttmp.pb(xs[x][qryx[x][k]].snd);\n\t\t\t\t\t\tfor(int p=last+1;p<qryx[x][k];p++){\n\t\t\t\t\t\t\tnedge[xs[x][qryx[x][k]].snd].pb(xs[x][p].snd);\n\t\t\t\t\t\t\tdeg[xs[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryx[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryx[x].clear();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx-=n;\n\t\t\t\t\tsort(qryy[x].begin(),qryy[x].end());\n\t\t\t\t\tint last=-1;\n\t\t\t\t\trep(k,qryy[x].size()){\n\t\t\t\t\t\ttmp.pb(ys[x][qryy[x][k]].snd);\n\t\t\t\t\t\tfor(int p=last+1;p<qryy[x][k];p++){\n\t\t\t\t\t\t\tnedge[ys[x][qryy[x][k]].snd].pb(ys[x][p].snd);\n\t\t\t\t\t\t\tdeg[ys[x][p].snd]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast=qryy[x][k];\n\t\t\t\t\t}\n\t\t\t\t\tqryy[x].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cur=1,csz=0;\n\t\t\trep(j,path.size())if(!deg[path[j]]){\n\t\t\t\tdfs2(path[j]);\n\t\t\t\tcur=1LL*cur*dp[path[j]]%mod*C(csz+sz[path[j]],sz[path[j]])%mod;\n\t\t\t\tcsz+=sz[path[j]];\n\t\t\t}\n\t\t\trep(j,tmp.size())nedge[tmp[j]].clear(),deg[tmp[j]]=0;\n\t\t\tsum=(sum+cur)%mod;\n\t\t}\n\t\tans=1LL*ans*sum%mod*C(tsz+path.size(),path.size())%mod;\n\t\ttsz+=path.size();\n\t}\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define N 200010\n#define ll long long\nusing namespace std;\n\nint n,t,tag,cnt1,cnt2,st[N],control[N],du[N],sz[N];\nll fac[N],inv[N];\nvector<int>e[N],tp[N],cir,lt;\nbool vis[N],onc[N];\n\nll fpow(ll a,ll b){\n\tll ret=1;\n\twhile(b){\n\t\tif(b&1)ret=ret*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ret;\n}\n\nvoid dfs(int u,int fa){\n\tst[++t]=u;vis[u]=1;cnt1++;lt.push_back(u);\n\tfor(int i=0;i<e[u].size();i++)\n\t  if(e[u][i]!=fa&&!onc[e[u][i]]){\n\t  \tint v=e[u][i];cnt2++;\n\t  \tif(!tag&&vis[v]){\n\t  \t\ttag=1;\n\t  \t\twhile(st[t]!=v)cir.push_back(st[t]),onc[st[t]]=1,t--;\n\t  \t\tcir.push_back(st[t]);onc[st[t]]=1;t--;\n\t\t}\n\t\telse if(!vis[v])dfs(v,u);\n\t  }\n\tif(!tag)t--;\n}\n\nvoid dfs1(int u,int fa){\n\tfor(int i=0;i<e[u].size();i++){\n\t\tif(e[u][i]==control[u])break;\n\t\ttp[u].push_back(e[u][i]);du[e[u][i]]++;\n\t}\n\tfor(int i=0;i<e[u].size();i++)\n\t  if(e[u][i]!=fa&&!onc[e[u][i]])\n\t  \tcontrol[e[u][i]]=u,dfs1(e[u][i],u);\n}\n\nll dfs2(int u,int fa){\n\tll ret=sz[u]=1;\n\tfor(int i=0;i<tp[u].size();i++)\n\t  if(tp[u][i]!=fa){\n\t  \tret=ret*dfs2(tp[u][i],u)%mod;\n\t  \tsz[u]+=sz[tp[u][i]];\n\t  }\n\treturn ret*inv[sz[u]]%mod;\n}\n\nll solve1(){\n\tll ret=1;\n\tfor(int i=0;i<lt.size();i++)\n\t  if(!du[lt[i]])\n\t    ret=ret*dfs2(lt[i],0)%mod;\n\tfor(int i=0;i<lt.size();i++)tp[lt[i]].clear(),du[lt[i]]=0;\n\treturn ret;\n}\n\nll solve(int u){\n\tll ret=0;\n\tt=tag=cnt1=cnt2=0;\n\tcir.clear();lt.clear();\n\tdfs(u,0);\n\tif(cnt1!=cnt2)return 0;\n\t\n\tfor(int i=0;i<cir.size()-1;i++)control[cir[i]]=cir[i+1];\n\tcontrol[cir[cir.size()-1]]=cir[0];\n\tfor(int i=0;i<cir.size();i++)dfs1(cir[i],0);\n\tret+=solve1();\n\t\n\tfor(int i=1;i<cir.size();i++)control[cir[i]]=cir[i-1];\n\tcontrol[cir[0]]=cir[cir.size()-1];\n\tfor(int i=0;i<cir.size();i++)dfs1(cir[i],0);\n\tret+=solve1();\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<=n*2;i++)scanf(\"%d%d\",&x,&y),e[x].push_back(y+n),e[y+n].push_back(x);\n\tfor(int i=1;i<=n*2;i++)sort(e[i].begin(),e[i].end());\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor(int i=1;i<=n*2;i++)fac[i]=fac[i-1]*i%mod;\n\tfor(int i=2;i<=n*2;i++)inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n\tll ans=fac[n*2];\n\tfor(int i=1;i<=n*2;i++)\n\t  if(!vis[i])\n\t    ans=ans*solve(i)%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"2,Ofast,inline\")\n#pragma GCC diagnostic error \"-std=c++11\"\n#include<bits/stdc++.h>\n#define LL long long\n#define int LL\n#define P pair<int,int>\n#define fi first\n#define se second\nconst LL N=2e5+10;\nconst LL mod=1e9+7;\nconst LL inf=0x3f3f3f;\nconst double eps=1e-9;\nusing namespace std;\ntemplate<typename tp> inline void read(tp &x)\n{\n    x=0;char c=getchar();\n    bool f=0; for(; c<'0'||c>'9'; f|=(c=='-'),c = getchar());\n    for(; c>='0'&&c<='9'; x=(x<<3)+(x<<1)+c-'0',c = getchar());\n    if(f) x=-x;\n}\nP wei[N<<1];\nmap<P,int> Map;\nvector<P> idd;\nvector<int> line[N],row[N],vec,node;\n  \nint n,found;\nint head[N<<1],cnt;\nint fa[N<<1],side[N<<1],vis[N<<1];\nint tou[N<<1],num;\nLL siz[N<<1];\n  \nstruct Node { int next,to,id;} edge[N<<3];\nstruct E {int next,to;} e[N<<3];\n  \nvoid add(int from,int to,int id) { edge[++cnt]= {head[from],to,id}; head[from]=cnt;}\nvoid insert(int from,int to,int id) { add(from,to,id); add(to,from,id);}\nvoid jia(int from,int to) {e[++num]= {tou[from],to}; tou[from]=num;}\nP calc(int x,int y) { if(x>y) swap(x,y); y-=n; return P(x,y);}\nLL KSM(LL a,LL b,LL ret=1) { while(b) { if(b&1) ret=ret*a%mod; a=a*a%mod; b>>=1; } return ret;}\nint ask(P x) { return lower_bound(idd.begin(),idd.end(),x)-idd.begin()+1;}\n \nvoid dfs(int now,int fath)\n{\n    vis[now]=1;\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        if(found==1) return ;\n        int to=edge[i].to;\n        if(to==fath) continue;\n        if(vis[to])\n        {\n            int flag=now;\n            while(flag!=to)\n            {\n                vec.push_back(flag);\n                flag=fa[flag];\n            }\n            vec.push_back(to);\n            found = 1;\n            return ;\n        }\n        fa[to]=now;\n        dfs(to,now);\n    }\n}\nvoid dfs_side_other(int now,int fa)\n{\n    for(int i=head[now]; i; i=edge[i].next)\n    {\n        int to=edge[i].to;\n        if(vis[to]==2||to==fa)\n            continue;\n        vis[to]=1;\n        if(to>n) side[edge[i].id]=2;\n        else side[edge[i].id]=1;\n        node.push_back(edge[i].id);\n        dfs_side_other(to,now);\n    }\n}\nLL dfs_size(int now)\n{\n    if(siz[now]) return siz[now];\n    siz[now]=1;\n    for(int i=tou[now]; i; i=e[i].next)\n    {\n        int to=e[i].to;\n        siz[now]+=dfs_size(to);\n    }\n    return siz[now];\n}\nvoid built()\n{\n    for(int i=0; i<node.size(); i++)\n    {\n        int x=wei[node[i]].fi,y=wei[node[i]].se;\n        if(side[node[i]]==1)\n        {\n            int pos=lower_bound(line[x].begin(),line[x].end(),y)-line[x].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(x,line[x][j])));\n        }\n        else\n        {\n            int pos=lower_bound(row[y].begin(),row[y].end(),x)-row[y].begin() - 1;\n            for(int j=0;j<=pos;j++)\n                jia(node[i],ask(P(row[y][j],y)));\n        }\n    }\n}\nLL solve(int now)\n{\n    found = 0;\n    LL ret1=1,ret2=1;\n    vec.clear(), node.clear();\n    dfs(now,now);\n    for(int i=0; i<vec.size(); i++) vis[vec[i]]=2;\n    for(int i=0; i<vec.size(); i++) dfs_side_other(vec[i],vec[i]);\n    for(int i=0; i<vec.size()-1; i++)\n    {\n        side[ask(calc(vec[i],vec[i+1]))]=(vec[i+1]>n?1:2);\n        node.push_back(ask(calc(vec[i],vec[i+1])));\n    }\n    side[ask(calc(vec[vec.size()-1],vec[0]))]=(vec[0]>n?1:2);\n    node.push_back(ask(calc(vec[vec.size()-1],vec[0])));\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret1=ret1*KSM(dfs_size(node[i]),mod-2)%mod;\n    num=0;\n    for(int i=0; i<node.size(); i++) tou[node[i]]=0;\n    for(int i=vec.size()-1; i>0; i--)\n        side[ask(calc(vec[i],vec[i-1]))]=(vec[i-1]>n?1:2);\n    side[ask(calc(vec[0],vec[vec.size()-1]))]=(vec[vec.size()-1]>n?1:2);\n    for(int i=0; i<node.size(); i++) siz[node[i]]=0;\n    built();\n    for(int i=0; i<node.size(); i++)\n        ret2=ret2*KSM(dfs_size(node[i]),mod-2)%mod;\n    return ret1+ret2;\n}\nsigned main()\n{\n    read(n);\n    for(int i=1,x,y; i<=n*2; i++)\n    {\n        read(x),read(y);\n        idd.push_back(P(x,y));\n        line[x].push_back(y);\n        row[y].push_back(x);\n    }\n    sort(idd.begin(),idd.end());\n    for(int i=0;i<n*2;i++)\n    {\n        wei[i+1]=idd[i];\n        insert(idd[i].fi,idd[i].se+n,i+1);\n    }\n    for(int i=1; i<=n; i++)\n    {\n        sort(line[i].begin(),line[i].end()),\n        sort(row[i].begin(),row[i].end());\n        if(!line[i].size()||!row[i].size())\n            return 0*puts(\"0\");\n    }\n    LL ans=1;\n    for(int i=1; i<=n*2; i++)\n        if(!vis[i])\n            ans=ans*solve(i)%mod;\n    for(int i=1;i<=n*2;i++)\n        ans=ans*i*1LL%mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\ntypedef vector <int> vr;\n\nconst ld inf = 2e18;\nconst int N = 3e6 + 10;\nconst int maxn = 200020;\nconst ll mod = 1e9 + 7;\n\ninline ll power(ll x,ll y){\n\ty = ((y % (mod - 1)) + (mod - 1)) % (mod - 1);\n//\tif ( y < 0 ) return power(power(x,-y),mod - 2);\n\tll res = 1;\n\twhile ( y ){\n\t\tif ( y & 1 ) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nstruct node{\n\tint next,to;\n}e[maxn * 2];\nint head[maxn],cnt,n;\nll fac[maxn],inv[maxn],inv2[maxn],a[maxn],f[maxn];\nvector <int> cir[maxn],vec[maxn],comp[maxn];\nint flag;\nint st[maxn],tops,vis[maxn],tag[maxn],q[maxn],hh,tt,deg[maxn],fa[maxn],sz[maxn];\n\nvoid init(){\n\tfac[0] = inv[0] = 1;\n\trep(i,1,2 * n ) fac[i] = fac[i - 1] * i % mod , inv[i] = power(fac[i],mod - 2);\n}\ninline void adde(int x,int y){\n//\tcout<<x<<\" \"<<y<<endl;\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nvoid dfs(int x,int fa){\n//\tcout<<x<<\" \"<<fa<<endl;\n\tif ( vis[x] ){\n\t\tflag = 1;\n\t\trepd(i,tops,1){\n\t\t\tint y = st[i];\n\t\t\ttag[y] = 1 , cir[cnt].pb(y);\n\t\t\tif ( y == x ) break;\n\t\t}\n\t\treturn;\n\t}\n\tst[++tops] = x , vis[x] = 1;\n\tfore(i,x){\n\t\tif ( e[i].to == fa ) continue;\n\t\tdfs(e[i].to,x);\n\t\tif ( flag ) return;\n\t}\n\ttops--;\n}\ninline void adde2(int x,int y);\nvoid dfs_e(int x,int fa){\n\tll res = 1;\n\tif ( fa ){\n\t\trvc(i,vec[x]){\n\t\t\tif ( fa <= vec[x][i] ) break;\n\t\t\tadde2(x,vec[x][i]);\n\t\t}\t\t\n\t}\n\tfore(i,x){\n\t\tif ( e[i].to == fa || tag[e[i].to] ) continue;\n\t\tdfs_e(e[i].to,x);\n\t}\n}\n\nnode e2[maxn * 2];\nint head2[maxn],cnt2;\n#define head head2\n#define e e2\n#define cnt cnt2\n#define fore2(i,x) for (register int i = head2[x] ; i ; i = e2[i].next)\ninline ll C(int n,int m){\n\tif ( n < 0 || m < 0 || n < m ) return 0;\n\treturn fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\ninline void adde2(int x,int y){\n//\tcout<<x<<\" \"<<y<<endl;\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n\tdeg[y]++;\n\tfa[y] = x;\n}\n\nvoid clear(vector <int> &a){\n\trvc(i,a){\n\t\thead[a[i]] = 0;\n\t\tdeg[a[i]] = 0;\n\t\tfa[a[i]] = 0;\n\t}\n\tcnt2 = 0;\n}\n\nbool check(vector <int> a){\n\tint ecnt = 0;\n\trvc(i,a){\n\t\tecnt += deg[a[i]];\n\t}\n//\tcout<<ecnt<<\" \"<<a.size()<<endl;\n\tif ( ecnt != a.size() * 2 ) return 0;\n\treturn 1;\n}\nll topo(vr &a){\n//\tcout<<\"getans\\n\";\n\tll res = 1; int S = 0;\n\ttt = hh = 0;\n\trvc(i,a){\n\t\tint x = a[i];\n\t\tif ( !deg[x] ) q[tt++] = x;\n\t}\n\twhile ( hh < tt ){\n\t\tint x = q[hh++];\n\t\tfore2(i,x){\n\t\t\tdeg[e[i].to]--;\n\t\t\tif ( deg[e[i].to] == 0 ) q[tt++] = e[i].to;\n\t\t}\n\t}\n\trepd(i,tt - 1,0){\n\t\tint x = q[i];\n\t\tf[x] = 1 , sz[x] = 0;\n\t\tfore2(j,x){\n\t\t\tsz[x] += sz[e[j].to];\n\t\t\tf[x] = f[x] * C(sz[x],sz[e[j].to]) % mod * f[e[j].to] % mod;\n\t\t}\n\t\tsz[x]++;\n\t\tif ( !fa[x] ){\n\t\t   \tS += sz[x];\n\t\t\tres = res * f[x] % mod * C(S,sz[x]) % mod;\n\t//\t\tcout<<x<<\" \"<<f[x]<<\" \"<<sz[x]<<endl;\n\t\t}\n\t}\n//\tcout<<\"topo \"<<res<<endl;\n\treturn res;\n}\nll solve(vector <int> &V,vector <int> &a){\n\tif ( !check(a) ) return 0;\n\tll res = 0;\n\tclear(a);\n\trvc(i,V){\n\t\tdfs_e(V[i],0);\n\t}\n\tint n = V.size(),last = V[0];\n\trep(i,1,n - 1){\n\t\tint x = V[i];\n\t\trvc(j,vec[x]){\n\t\t\tif ( vec[x][j] >= last ) break;\n\t\t\tadde2(x,vec[x][j]);\n\t\t}\n\t\tlast = x;\n\t}\n\trvc(j,vec[V[0]]){\n\t\tif ( vec[V[0]][j] >= last ) break;\n\t\tadde2(V[0],vec[V[0]][j]);\t\n\t}\n\tres = topo(a);\n\n\t//倒着分配\n\tclear(a);\n\trvc(i,V){\n\t\tdfs_e(V[i],0);\n\t}\n\tlast = V[n - 1];\n\trepd(i,n - 2,0){\n\t\tint x = V[i];\n\t\trvc(j,vec[x]){\n\t\t\tif ( vec[x][j] >= last ) break;\n\t\t\tadde2(x,vec[x][j]);\n\t\t}\n\t\tlast = x;\n\t}\n\trvc(j,vec[V[n - 1]]){\n\t\tif ( vec[V[n - 1]][j] >= last ) break;\n\t\tadde2(V[n - 1],vec[V[n - 1]][j]);\t\n\t}\n\tres += topo(a);\n\treturn res;\n}\n#undef e\n#undef cnt\n#undef head\nint vis2[maxn];\nvoid dfs2(int x){\n\tvis2[x] = 1;\n\tcomp[cnt].pb(x);\n\tfore(i,x){\n\t\tif ( vis2[e[i].to] ) continue;\n\t\tdfs2(e[i].to);\n\t}\n}\nint main(){\n\t\n\tscanf(\"%d\",&n);\n\tinit();\n\trep(i,1,n * 2){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadde(x,y + n) , adde(y + n,x);\n\t\tdeg[x]++ , deg[y + n]++;\n\t\tvec[x].pb(y + n);\n\t\tvec[y + n].pb(x);\n\t}\n\trep(i,1,n * 2) sort(vec[i].begin(),vec[i].end());\n\tcnt = 0;\n\trep(i,1,n * 2) if ( !vis2[i] ){\n\t   \t++cnt , flag = 0 , dfs(i,0);\n\t\tif ( !flag ) return puts(\"0\"),0;\n\t\tdfs2(i);\n\t}\n\tll ans = 1; int S = 0;\n\trep(i,1,cnt){\n\t\tS += comp[i].size();\n\t\tans = ans * solve(cir[i],comp[i]) % mod * C(S,comp[i].size()) % mod;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof((x).end())i=(x).begin();i!=(x).end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007,P=1000000007;\n\ninline int pow(int a,int b)\n{\n\tint r=1;\n\tfor(;b;b>>=1,a=(ll)a*a%P)\n\t\tif(b&1)r=(ll)r*a%P;\n\treturn r;\n}\n\nstd::vector<int>p[N],pv[N],ux,uy,ps[N];\nint n,uf[N],fa[N],fac[N],fin[N],f[N],sz[N],ec[N];\nbool vis[N],vv[N],flag;\n\ninline int find(int x)\n{\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\n\ninline void dfs(int x)\n{\n\tfoe(i,p[x])if(*i!=fa[x])fa[*i]=x,dfs(*i);\n}\n\ninline void dfs2(int x)\n{\n\tif(vv[x]){flag=1;return;}vv[x]=1;\n\tsz[x]=1,f[x]=1;\n\tfoe(i,pv[x])if(*i<fa[x])\n\t{\n\t\tdfs2(*i);\n\t\tf[x]=(ll)f[x]*fin[sz[*i]]%P*f[*i]%P;\n\t\tsz[x]+=sz[*i];\n\t}\n\tf[x]=(ll)f[x]*fac[sz[x]-1]%P;\n}\n\ninline int solve(int ux,int uy,std::vector<int>&li)\n{\n\t//out,\"solve:\",ux,' ',uy,' ',li.size(),'\\n';\n\tfa[ux]=uy;\n\tdfs(ux);\n\tfoe(i,li)vis[*i]=0;\n\tfoe(i,li)foe(j,pv[*i])if(*j<fa[*i])vis[*j]=1;\n\t//foe(i,li)foe(j,pv[*i])if(*j<fa[*i])out,\"tree:\",*i,' ',*j,'\\n';\n\tint res=fac[li.size()];\n\tfoe(i,li)vv[*i]=0;flag=0;\n\tfoe(i,li)if(!vis[*i])dfs2(*i),res=(ll)res*fin[sz[*i]]%P*f[*i]%P;\n\tfoe(i,li)if(!vv[*i])return 0;\n\tif(flag)return 0;\n\t//foe(i,li)out,'(',f[*i],',',sz[*i],')',' ';out,'\\n';\n\t//out,ux,' ',uy,' ',res,'\\n';\n\treturn res;\n}\n\nint main()\n{\n\tfac[0]=1;\n\tfo1(i,N-1)fac[i]=(ll)fac[i-1]*i%P;\n\tfin[N-1]=pow(fac[N-1],P-2);\n\tfd1(i,N-1)fin[i-1]=(ll)fin[i]*i%P;\n\tin,n;n*=2;\n\tfo1(i,n)fa[i]=i;\n\tfo1(i,n)\n\t{\n\t\tint x,y;\n\t\tin,x,y;y+=n/2;\n\t\t//out,\"e:\",x,' ',y,'\\n';\n\t\t//if(find(x)==find(y))out,\"u:\",x,' ',y,'\\n';\n\t\tif(find(x)==find(y))ux.pb(x),uy.pb(y);\n\t\telse fa[find(x)]=find(y),p[x].pb(y),p[y].pb(x);\n\t\tpv[x].pb(y),pv[y].pb(x);\n\t}\n\tfo1(i,n)ps[find(i)].pb(i);\n\tfo1(i,n)ec[find(i)]+=pv[i].size();\n\tfo1(i,n)if(find(i)==i&&ps[i].size()*2!=ec[i])return puts(\"0\"),0;\n\tfo1(i,n)std::sort(pv[i].begin(),pv[i].end());\n\tint ans=fac[n];\n\tfo0(i,ux.size())\n\t{\n\t\tint ro=find(ux[i]);\n\t\tans=(ll)ans*fin[ps[ro].size()]%P*(solve(ux[i],uy[i],ps[ro])+solve(uy[i],ux[i],ps[ro]))%P;\n\t}\n\tout,ans,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nint x[210000];\nint y[210000];\nint UF[210000];\nvector<int>g[210000];\nint FIND(int a){\n\tif(UF[a]<0)return a;return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint h[210000];\nint v[210000];\nvector<int>cy;\nvector<int>cur;\nint dfs(int a,int b){\n\tv[a]=b;\n\t\n\tcur.push_back(a);\n\tint ret=-2;\n\t// printf(\"%d %d %d\\n\",a,b,(int)g[a].size());\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]==b)continue;\n\t\tif(v[g[a][i]]==-2){\n\t\t\tint val=dfs(g[a][i],a);\n\t\t\tif(val!=-2){\n\t\t\t\tcy.push_back(a);\n\t\t\t\tif(a==val)val=-2;\n\t\t\t}\n\t\t\tif(val!=-2) ret=val;\n\t\t}else{\n\t\t\tcy.push_back(a);\n\t\t\treturn g[a][i];\n\t\t}\n\t}\n\t// printf(\"fin %d %d\\n\",a,b);fflush(stdout);\n\treturn ret;\n}\nvector<int>g2[210000];\nint sz[210000];\nint ou[210000];\nlong long calc(int a){\n\tlong long ret=1;\n\tsz[a]=0;\n\tfor(int i=0;i<g2[a].size();i++){\n\t\tret=ret*calc(g2[a][i])%mod;\n\t\tret=ret*Comb(sz[a]+sz[g2[a][i]],sz[a])%mod;\n\t\tsz[a]+=sz[g2[a][i]];\n\t}\n\tsz[a]++;\n\t// printf(\"%d: %lld\\n\",a,ret);\n\treturn ret;\n}\nint tl[210000];\nint n;\nvoid dfs2(int a,int b){\n\tfor(int i=0;i<g[a].size();i++){\n\n\t\tif(b==g[a][i])continue;\n\t\t// printf(\"%d %d\\n\",a,g[a][i]);\n\t\ttl[g[a][i]]=a;\n\t\tif(g[a][i]==cy[0])continue;\n\t\tdfs2(g[a][i],a);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tfor(int i=0;i<a*2;i++)UF[i]=-1;\n\tfor(int i=0;i<a*2;i++)v[i]=-2;\n\tinit_C(410000);\n\tfor(int i=0;i<2*a;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tx[i]--;y[i]--;\n\t\tg[x[i]].push_back(y[i]+a);\n\t\tg[y[i]+a].push_back(x[i]);\n\t\tUNION(x[i],y[i]+a);\n\t}\n\tfor(int i=0;i<a*2;i++){\n\t\th[FIND(x[i])]++;\n\t}\n\tlong long ret=1;\n\tlong long ks=1;\n\tint tn=0;\n\tfor(int i=0;i<a*2;i++){\n\t\tif(UF[i]<0&&h[i]!=-UF[i]){\n\t\t\tprintf(\"0\\n\");return 0;\n\t\t}\n\t\tif(UF[i]<0){\n\t\t\tcur.clear();\n\t\t\tks=Comb(tn+h[i],h[i]);\n\t\t\ttn+=h[i];\n\t\t\tcy.clear();\n\t\t\tdfs(i,-1);\n\t\t\t// for(int j=0;j<cy.size();j++)printf(\"%d \",cy[j]);printf(\"\\n\");\n\t\t\tlong long tmp=0;\n\t\t\tfor(int k=0;k<2;k++){\n\n\t\t\t\tif(k==0)dfs2(cy[0],cy[1]);\n\t\t\t\telse dfs2(cy[0],cy[cy.size()-1]);\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tfor(int k=0;k<g[cur[j]].size();k++){\n\t\t\t\t\t\tint to=g[cur[j]][k];\n\t\t\t\t\t\tif(to<tl[cur[j]]){\n\t\t\t\t\t\t\tg2[cur[j]].push_back(to);\n\t\t\t\t\t\t\t// printf(\"%d %d\\n\",cur[j],to);\n\t\t\t\t\t\t\tou[to]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tif(!ou[cur[j]]){\n\t\t\t\t\t\tg2[a*2].push_back(cur[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp+=calc(a*2);\n\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tg2[cur[j]].clear();\n\t\t\t\t\tou[cur[j]]=0;\n\t\t\t\t}\n\t\t\t\tg2[a*2].clear();\n\t\t\t}\n\t\t\ttmp%=mod;\n\t\t\t// printf(\"%d: %lld\\n\",i,tmp);\n\t\t\tret=ret*tmp%mod;\n\t\t}\n\t}\n\n\tret=ret*ks%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<stack>\n#include<vector>\n#include<set>\n#define MOD 1000000007\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nll inv[200010],fac[200010];\nnamespace topo{\n\tint first[200010],cnte;\n\tvector<int>e[200010];\n\tint in[200010];\n\tset<int>app;\n\tinline void add(int u,int v){\n//\t\tcout<<\"\t\ttopo add \"<<u<<' '<<v<<'\\n';\n\t\te[u].push_back(v);\n\t\tin[v]++;\n\t}\n\tint siz[200010];\n\tll dfs(int u,int f){\n\t\tll re=1;siz[u]=1;\n//\t\tcout<<\"\t\ttopo dfs \"<<u<<'\\n';\n\t\tassert(u);\n\t\tfor(auto v:e[u]){\n\t\t\tif(v==f) continue;\n//\t\t\tcout<<\"\t\t\tto \"<<' '<<v<<' '<<u<<'\\n';\n\t\t\t(re*=dfs(v,u))%=MOD;siz[u]+=siz[v];\n\t\t}\n//\t\tcout<<\"\t\ttopo return \"<<re<<' '<<siz[u]<<' '<<inv[siz[u]]<<' '<<re*inv[siz[u]]%MOD<<'\\n';\n\t\treturn re*inv[siz[u]]%MOD;\n\t}\n\tll solve(){\n\t\tll re=1,tmp;\n//\t\tcout<<\"toposolve \"<<app.size()<<'\\n';\n\t\tfor(auto u:app){\n\t\t\tif(!in[u]){\n\t\t\t\ttmp=dfs(u,0);\n\t\t\t\t(re*=tmp%MOD)%=MOD;\n//\t\t\t\tcout<<\"appear \"<<u<<' '<<re<<' '<<siz[u]<<' '<<fac[siz[u]]<<' '<<tmp<<'\\n';\n\t\t\t}\n\t\t}\n\t\tfor(auto u:app) e[u].clear(),in[u]=0;\n\t\treturn re;\n\t}\n}\nvector<int>e[200010];\nstack<int>s;\nbool vis[200010],in[200010];int cnt1,cnt2,lped;\nvector<int>cir;\nvoid dfs(int u,int f){\n\tint i,v;cnt1++;s.push(u);\n\tvis[u]=1;\n//\tcout<<\"dfs \"<<u<<' '<<f<<'\\n';\n\tfor(i=0;i<e[u].size();i++){\n\t\tv=e[u][i];if(v==f||in[v]) continue;\n\t\tcnt2++;\n\t\tif(!lped&&vis[v]){\n\t\t\tlped=1;\n//\t\t\tcout<<\"\tget loop \"<<v<<' '<<u<<'\\n';\n\t\t\twhile(s.top()!=v) cir.push_back(s.top()),in[s.top()]=1,s.pop();\n\t\t\tcir.push_back(s.top()),in[s.top()]=1,s.pop();\n\t\t}\n\t\telse if(!vis[v]){\n//\t\t\tcout<<\"goto \"<<v<<' '<<u<<'\\n';\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n\tif(!s.empty()&&s.top()==u) s.pop();\n//\tcout<<\"finish \"<<u<<'\\n';\n}\nint ch[200010];\nvoid dfs2(int u,int f){\n//\tcout<<\"dfs2 \"<<u<<' '<<f<<'\\n';\n\tint i,v;\n\tfor(i=0;i<e[u].size();i++){\n\t\tv=e[u][i];if(v==f||in[v]) continue;\n\t\tch[v]=u;\n\t\tdfs2(v,u);\n\t}\n}\nvoid adde(int u,int f){\n//\tcout<<\"adde \"<<u<<' '<<f<<' '<<ch[u]<<'\\n';\n\ttopo::app.insert(u);\n\tfor(auto v:e[u]){\n\t\tif(v==ch[u]) break;\n\t\ttopo::add(u,v);\n\t}\n\tfor(auto v:e[u]){\n\t\tif(v==f||in[v]) continue;\n\t\tadde(v,u);\n\t}\n}\nll solve(int u){\n//\tcout<<\"solve \"<<u<<'\\n';\n\tcnt1=cnt2=lped=0;\n\tdfs(u,0);\n//\tcout<<\"fin dfs \"<<cnt1<<' '<<cnt2<<'\\n';\n\tif(cnt1!=cnt2) return 0;\n\tint i;ll re=0;\n\tfor(i=0;i<cir.size();i++){\n\t\tdfs2(cir[i],0);\n\t}\n\t//first\n\tfor(i=0;i<cir.size();i++){\n\t\tch[cir[i]]=cir[(i+1)%cir.size()];\n\t}\n\tfor(i=0;i<cir.size();i++){\n\t\tadde(cir[i],0);\n\t}\n\tre+=topo::solve();\n\t//second\n\tfor(i=0;i<cir.size();i++){\n\t\tch[cir[i]]=cir[(i-1+cir.size())%cir.size()];\n\t}\n\tfor(i=0;i<cir.size();i++){\n\t\tadde(cir[i],0);\n\t}\n\tre+=topo::solve();\n\ttopo::app.clear();\n\tfor(i=0;i<cir.size();i++) in[i]=0;\n\tcir.clear();\n//\tcout<<\"finsolve \"<<topo::app.size()<<\"\\n\";\n\treturn re%MOD;\n}\nint n;\nint main(){\n\tn=read();int i,t1,t2;\n\tmemset(topo::first,-1,sizeof(topo::first));\n\tinv[1]=1;fac[1]=1;\n\tfor(i=2;i<=n*2;i++) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;\n\tfor(i=2;i<=n*2;i++) fac[i]=fac[i-1]*i%MOD;\n\tfor(i=1;i<=n*2;i++){\n\t\tt1=read();t2=read();t2+=n;\n\t\te[t1].push_back(t2);\n\t\te[t2].push_back(t1);\n\t}\n\tfor(i=1;i<=n*2;i++){\n\t\tif(e[i].size()) sort(e[i].begin(),e[i].end());\n\t}\n\tll ans=1;\n\tfor(i=1;i<=n*2;i++){\n\t\tif(!vis[i]) (ans=ans*solve(i))%=MOD;\n\t}\n\tcout<<(fac[2*n]*ans)%MOD<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 200005;\nconst ll M = ll(1e9) + 7;\n\nstruct E{ int x, i; };\n\nint n, ln, vis[MN], cyc[MN], as[MN], nas[MN], vc, ec, sz[MN], oth[MN], hp[MN], fnd;\nvector<E> e[MN];\nvector<int> vl, cv, tv, ch[MN];\nll fc[MN], ifc[MN], ans = 1;\n\nvoid T_T(){\n\tputs(\"0\");\n\texit(0);\n}\n\nll pw(ll x, ll k){\n\tif(k == 1) return x;\n\treturn pw(x * x % M, k / 2) * (k % 2 ? x : 1) % M;\n}\n\nll cm(int n, int r){\n\treturn fc[n] * ifc[r] % M * ifc[n - r] % M;\n}\n\nvoid g(int x){\n\tvis[x] = 1;\n\tvc++;\n\tec += e[x].size();\n\ttv.push_back(x);\n\tfor(auto &i : e[x]) if(!vis[i.x]) g(i.x);\n}\n\nvoid h(int x, int p){\n\t//printf(\"%d\\n\", x);\n\tif(vis[x] == 2){\n\t\t//puts(\"CYCLE\");\n\t\tcyc[x] = 1;\n\t\tcv.push_back(x);\n\t\tfor(int i = int(vl.size()) - 1; vl[i] != x; i--){\n\t\t\t//printf(\"%d\\n\", vl[i]);\n\t\t\tcyc[vl[i]] = 1;\n\t\t\tcv.push_back(vl[i]);\n\t\t}\n\t\t//puts(\"--\");\n\t\tfnd = 1;\n\t\treturn;\n\t}\n\tvis[x] = 2;\n\tvl.push_back(x);\n\tfor(auto &i : e[x]){\n\t\tif(i.x != p){\n\t\t\t//printf(\"%d -> %d\\n\", x, i.x);\n\t\t\th(i.x, x);\n\t\t}\n\t\tif(fnd) return;\n\t}\n\tvl.pop_back();\n}\n\nvoid af(int x, int p){\n\tfor(auto &i : e[x]){\n\t\tif(i.x != p && !cyc[i.x]){\n\t\t\tas[i.x] = nas[i.x] = i.i;\n\t\t\taf(i.x, x);\n\t\t}\n\t}\n}\n\nvoid cf(){\n\tint cs = int(cv.size());\n\tfor(int i = 0; i < cs; i++){\n\t\tfor(auto &j : e[cv[i]]){\n\t\t\tif(j.x == cv[(i + 1) % cs]){\n\t\t\t\t//printf(\"%d : %d - %d (%d)\\n\", i, cv[i], j.x, j.i);\n\t\t\t\tas[cv[i]] = nas[j.x] = j.i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint sf(int x){\n\tsz[x] = 1;\n\tvc++;\n\tfor(auto &i : ch[x]) sz[x] += sf(i);\n\treturn sz[x];\n}\n\nll tf(int x){\n\tll ret = 1;\n\tint cs = sz[x] - 1;\n\tfor(auto &i : ch[x]){\n\t\tret = ret * cm(cs, sz[i]) % M;\n\t\tret = ret * tf(i) % M;\n\t\tcs -= sz[i];\n\t}\n\t//printf(\"tf %d : %lld\\n\", x, ret);\n\treturn ret;\n}\n\nll get(){\n\tputs(\"GET\");\n\tfor(auto &i : tv){\n\t\tint to = oth[as[i]] - i;\n\t\tfor(auto &j : e[i]){\n\t\t\tif(j.x < to){\n\t\t\t\t//printf(\"%d - %d\\n\", j.x, i);\n\t\t\t\tch[i].push_back(j.x);\n\t\t\t\thp[j.x]++;\n\t\t\t}\n\t\t}\n\t}\n\tll ret = 1;\n\tint tln = int(tv.size());\n\tfor(auto &i : tv){\n\t\tif(!hp[i]){\n\t\t\tvc = 0;\n\t\t\tsf(i);\n\t\t\tret = ret * cm(tln, vc) % M;\n\t\t\tret = ret * tf(i) % M;\n\t\t\ttln -= vc;\n\t\t}\n\t}\n\tfor(auto &i : tv){\n\t\tfor(auto &j : ch[i]){\n\t\t\thp[j]--;\n\t\t}\n\t\tch[i].clear();\n\t}\n\treturn ret;\n}\n\nll f(int x){\n\tvl.clear();\n\tcv.clear();\n\tfnd = 0;\n\th(x, x);\n\tfor(auto &i : cv) af(i, i);\n\tcf();\n\t//for(auto &i : cv) printf(\"%d : %d %d\\n\", i, as[i], nas[i]);\n\tll t = get();\n\tfor(auto &i : cv) as[i] = nas[i];\n\tt += get();\n\treturn t % M;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1, x, y; i <= 2 * n; i++){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ty += n;\n\t\te[x].push_back({y, i});\n\t\te[y].push_back({x, i});\n\t\toth[i] = x + y;\n\t}\n\tfc[0] = ifc[0] = 1;\n\tfor(int i = 1; i <= 2 * n; i++){\n\t\tfc[i] = fc[i - 1] * i % M;\n\t\tifc[i] = pw(fc[i], M - 2);\n\t}\n\tln = 2 * n;\n\tfor(int i = 1; i <= 2 * n; i++){\n\t\tif(!vis[i]){\n\t\t\tvc = ec = 0;\n\t\t\ttv.clear();\n\t\t\tg(i);\n\t\t\tif(ec != 2 * vc) T_T();\n\t\t\t//printf(\"%d %d\\n\", ln, vc);\n\t\t\tans = ans * cm(ln, vc) % M;\n\t\t\tln -= vc;\n\t\t\t//printf(\"%lld\\n\", ans);\n\t\t\tans = ans * f(i) % M;\n\t\t\t//printf(\"////// %lld\\n\", ans);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nstruct StronglyConnectedComponent {\n        int n;\n        vector<bool> used;\n        vector<int> order, cmp;\n        vector<vector<int>> g, rg;\n        StronglyConnectedComponent(int x) {\n                n = x;\n                g.resize(x);\n                rg.resize(x);\n                used.resize(x);\n                cmp.resize(x);\n        }\n        void add_edge(int from, int to) {\n                g[from].push_back(to);\n                rg[to].push_back(from);\n        }\n        void dfs(int u) {\n                used[u] = true;\n                for (auto v : g[u]) if (!used[v]) {\n                        dfs(v);\n                }\n                order.push_back(u);\n        }\n        void rdfs(int u, int k) {\n                used[u] = true;\n                cmp[u] = k;\n                for (auto v : rg[u]) if (!used[v]) {\n                        rdfs(v, k);\n                }\n        }\n        int init() {\n                used.assign(n, false);\n                for (int u = 0; u < n; u ++) {\n                        if (!used[u]) {\n                                dfs(u);\n                        }\n                }\n                used.assign(n, false);\n                int k = 0;\n                for (int i = order.size() - 1; i >= 0; i --) {\n                        if (!used[order[i]]) {\n                                rdfs(order[i], k ++);\n                        }\n                }\n                return k;\n        }\n};\n\nconst int N = 5000001;\nlong long fact[N];\nlong long invfact[N];\nlong long inv[N];\nvoid init() {\n        fact[0] = fact[1] = 1;\n        for (int i = 2; i < N; i ++) fact[i] = fact[i - 1] * i % MOD;\n        inv[1] = 1;\n        for (int i = 2; i < N; i ++) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;\n        invfact[0] = invfact[1] = 1;\n        for (int i = 2; i < N; i ++) invfact[i] = invfact[i - 1] * inv[i] % MOD;\n}\nlong long C(long long n, long long r) {\n        if (n < 0 || r < 0 || n < r) return 0;\n        return fact[n] * invfact[n - r] % MOD * invfact[r] % MOD;\n}\n\nlong long calc(vector<vector<int>> &forest) {\n\tint n = forest.size();\n\tStronglyConnectedComponent scc(n);\n\tfor (int i = 0; i < n; i ++) {\n\t\tfor (auto j : forest[i]) {\n\t\t\tscc.add_edge(i, j);\n\t\t\tcerr << i << ' ' << j << endl;\n\t\t}\n\t}\n\tscc.init();\n\tvector<int> idx(n);\n\trep(i, n) idx[i] = i;\n\tsort(idx.begin(), idx.end(), [&](const int &i, const int &j) {\n\t\treturn scc.cmp[i] < scc.cmp[j];\n\t});\n\tvector<bool> used(n);\n\tlong long res = 1;\n\tlong long resres = 1;\n\tint tot = 0;\n\tfunction<int (int, int)> dfs = [&](int u, int prev) {\n\t\tused[u] = true;\n\t\tint total = 0;\n\t\tfor (auto v : forest[u]) if (v != prev) {\n\t\t\tint szsz = dfs(v, u);\n\t\t\ttotal += szsz;\n\t\t\t(resres *= C(total, szsz)) %= MOD;\n\t\t}\n\t\treturn total + 1;\n\t};\n\tfor (int i = 0; i < n; i ++) {\n\t\tint u = idx[i];\n\t\tif (!used[u]) {\n\t\t\tresres = 1;\n\t\t\tint sz = dfs(u, -1);\n\t\t\ttot += sz;\n\t\t\t(res *= C(tot, sz)) %= MOD;\n\t\t\t(res *= resres) %= MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tinit();\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<vector<int>> g(2 * n);\n\trep(i, 2 * n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx --, y --;\n\t\tg[x].push_back(y + n);\n\t\tg[y + n].push_back(x);\n\t}\n\n\tvector<vector<bool>> used(3, vector<bool> (n));\n\tvector<set<pair<int, int>>> eused(3);\n\tint ec = 0, nc = 0;\n\tvector<int> target(n, -1), app;\n\tint on_cycle = -1;\n\tfunction<void (int, int, int)> dfs = [&](int u, int prev, int num) {\n\t\tapp.push_back(u);\n\t\tnc ++;\n\t\tused[num][u] = true;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tif (eused[num].count(make_pair(min(u, v), max(u, v))) == 0) {\n\t\t\t\ttarget[v] = u;\n\t\t\t\teused[num].insert(make_pair(min(u, v), max(u, v)));\n\t\t\t\tec ++;\n\t\t\t\tif (used[num][v]) {\n\t\t\t\t\ton_cycle = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!used[num][v]) {\n\t\t\t\tdfs(v, u, num);\n\t\t\t}\n\t\t}\n\t};\n\tlong long ans = 1;\n\trep(i, 2 * n) if (!used[0][i]) {\n\t\tec = 0, nc = 0;\n\t\tdfs(i, -1, 0);\n\t\tif (ec != nc) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tlong long tmp = 0;\n\t\t// define target\n\t\tapp.clear();\n\t\tdfs(on_cycle, -1, 1);\n\t\t{\n\t\t\tmap<int, int> mp;\n\t\t\tint k = 0;\n\t\t\tfor (auto a : app) {\n\t\t\t\tassert(target[a] != -1);\n\t\t\t\tmp[a] = k ++;\n\t\t\t}\n\t\t\tvector<vector<int>> ggg(k);\n\t\t\tfor (auto a : app) {\n\t\t\t\tfor (auto v : g[a]) {\n\t\t\t\t\tif (v < target[a]) {\n\t\t\t\t\t\tggg[mp[a]].push_back(mp[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t(tmp += calc(ggg)) %= MOD;\n\t\t}\n\t\t// change target\n\t\treverse(g[on_cycle].begin(), g[on_cycle].end());\n\t\tapp.clear();\n\t\tdfs(on_cycle, -1, 2);\n\t\t{\n\t\t\tmap<int, int> mp;\n\t\t\tint k = 0;\n\t\t\tfor (auto a : app) {\n\t\t\t\tassert(target[a] != -1);\n\t\t\t\tmp[a] = k ++;\n\t\t\t}\n\t\t\tvector<vector<int>> ggg(k);\n\t\t\tfor (auto a : app) {\n\t\t\t\tfor (auto v : g[a]) {\n\t\t\t\t\tif (v < target[a]) {\n\t\t\t\t\t\tggg[mp[a]].push_back(mp[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t(tmp += calc(ggg)) %= MOD;\n\t\t}\n\t\t(ans *= tmp) %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N];\n\nint cnt,head[N];\nstruct Xint{int to,next;}V[N*8];\nvoid add(int x,int y){\n\tV[++cnt]=(Xint){y,head[x]};head[x]=cnt;\n\tV[++cnt]=(Xint){x,head[y]};head[y]=cnt;\n}\n\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tfor(int i=head[x];i;i=V[i].next){\n\t\tint y=V[i].to;if(y!=f)dfs(x,y);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\treturn;\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)add(vx[i][j],vx[i][j+1]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)add(vy[i][j],vy[i][j+1]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nint vis[202020];\nll ret=1;\nll mo=1000000007;\nll rev[202020];\n\nvector<int> P,LP;\nset<int> Vs,IL;\nset<pair<int,int>> Es;\nmap<pair<int,int>,int> O;\n\nvoid dfs(int cur) {\n\tint i;\n\tif(Vs.count(cur)) {\n\t\tif(LP.size()) return;\n\t\tint add=0;\n\t\tFOR(i,P.size()) {\n\t\t\tif(P[i]==cur) add=1;\n\t\t\tif(add) {\n\t\t\t\tLP.push_back(P[i]);\n\t\t\t\tIL.insert(P[i]);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvis[cur]=1;\n\tVs.insert(cur);\n\tP.push_back(cur);\n\tFORR(e,E[cur]) if(Es.count({min(e,cur),max(e,cur)})==0) {\n\t\tEs.insert({min(e,cur),max(e,cur)});\n\t\tdfs(e);\n\t}\n\tP.pop_back();\n\t\n}\n\nvoid dfs2(int cur,int pre) {\n\tO[{min(cur,pre),max(cur,pre)}]=cur;\n\tFORR(e,E[cur]) if(e!=pre) dfs2(e,cur);\n}\n\nll hoge(int cur) {\n\tLP.clear();\n\tIL.clear();\n\tP.clear();\n\tVs.clear();\n\tEs.clear();\n\t\n\tdfs(cur);\n\tif(Vs.size()!=Es.size()) return 0;\n\tLP.push_back(LP[0]);\n\t\n\tll r[2]={1,1};\n\tint i,x;\n\tFOR(i,2) {\n\t\tO.clear();\n\t\t\n\t\tFORR(v,LP) FORR(e,E[v]) if(IL.count(e)==0) dfs2(e,v);\n\t\tFOR(x,LP.size()-1) O[{min(LP[x],LP[x+1]),max(LP[x],LP[x+1])}]=LP[x+i];\n\t\tmap<pair<int,int>,int> cost;\n\t\tFORR(p,Es) {\n\t\t\tcost[p]++;\n\t\t\tint take=O[p];\n\t\t\tint oth=p.first+p.second-take;\n\t\t\tFORR(v,E[take]) {\n\t\t\t\tif(v<oth) cost[p]+=cost[{min(v,take),max(v,take)}];\n\t\t\t\tif(v>=oth) break;\n\t\t\t}\n\t\t\t(r[i]*=rev[cost[p]])%=mo;\n\t\t}\n\t\t\n\t}\n\treturn (r[0]+r[1])%mo;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\trev[1]=1;\n\tfor(i=2;i<=201000;i++) rev[i] = rev[mo%i]*(mo-mo/i)%mo;\n\t\n\tcin>>N;\n\tFOR(i,2*N) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1+N);\n\t\tE[y-1+N].push_back(x-1);\n\t}\n\tFOR(i,2*N) sort(ALL(E[i]));\n\t\n\tFOR(i,2*N) {\n\t\tif(E[i].size() && vis[i]==0) (ret*=hoge(i))%=mo;\n\t\tret=ret*(1+i)%mo;\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Have a nice day:)\n#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\ninline int read();\n\nconst int maxn=2e5+2;\nconst int mod=1e9+7;\n\nint n, c, N, tp, cnt_edge, cnt_node, ans, total, cnt_cir;\nbool fail;\nint stk[maxn], inv[maxn], fac[maxn], siz[maxn], cir[maxn], all[maxn], mx[maxn], must[maxn];\nint he[maxn], ne[maxn<<1], to[maxn<<1], w[maxn<<1];\nbool vis[maxn], col[maxn<<1], yes[maxn];\n\nint Pow(int a, int b) \n{\n    int u=1;\n    for(; b; b>>=1, a=1ll*a*a%mod) if(b&1) u=1ll*u*a%mod;\n    return u;\n}\n\nvoid Init()\n{\n    inv[0]=fac[0]=1;\n    for(int i=1; i<=N; ++i) fac[i]=1ll*fac[i-1]*i%mod;\n    inv[N]=Pow(fac[N], mod-2);\n    for(int i=N-1; i>=1; --i) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\n\nint C(int a, int b)\n{\n    if(a>b || a<0 || b<0) return 0;\n    return 1ll*fac[b]*inv[a]%mod*inv[b-a]%mod;\n}\n\nvoid Add_Edge(int x, int y, int z)\n{\n    ne[++c]=he[x]; he[x]=c; to[c]=y; w[c]=z;\n    ne[++c]=he[y]; he[y]=c; to[c]=x; w[c]=z;\n    mx[x]=max(mx[x], z); mx[y]=max(mx[y], z);\n}\n\nvoid Find_Circle(int p, int f)\n{\n    vis[p]=1; all[++cnt_node]=p;  \n\n    for(int i=he[p]; i; i=ne[i])\n    {\n        if(to[i]==f || col[i]) continue;\n        ++cnt_edge; stk[++tp]=i;\n        \n        if(vis[to[i]]) \n        {\n            if(cnt_cir) continue;\n            \n            do\n            {\n                int edge=stk[tp]; --tp;\n                col[edge]=col[edge^1]=1;\n                cir[++cnt_cir]=edge;\n            }\n            while(to[stk[tp+1]^1]!=to[i]);\n\n            continue;\n        }\n        \n        Find_Circle(to[i], p); \n        if(!col[i]) tp--;\n    }\n}\n\nvoid Must_Link(int p, int f)\n{\n    for(int i=he[p]; i; i=ne[i])\n    {\n        if(to[i]==f || col[i]) continue;\n        must[to[i]]=i^1; \n        Must_Link(to[i], p);\n    }\n}\n\nint fa[maxn];\nint Count(int p, int f)\n{\n    int now=1; siz[p]=0;\n    for(int i=he[p]; i; i=ne[i])\n    {\n        if(to[i]==f || fa[to[i]]!=p) continue;\n        int way=Count(to[i], p);\n        siz[p]+=siz[to[i]];\n        now=1ll*C(siz[to[i]], siz[p])*way%mod*now%mod;\n    }\n    ++siz[p];\n    return now;\n}\n\nvoid Subtree_Build()\n{\n    for(int i=1; i<=cnt_node; ++i) fa[all[i]]=0;\n    for(int i=1; i<=cnt_node; ++i)\n    {\n        for(int j=he[all[i]]; j; j=ne[j])\n        {\n            if(w[j]<w[must[all[i]]]) fa[to[j]]=all[i];\n        }\n    }\n}\n\nvoid Work()\n{\n    n=read(); N=n<<1; c=ans=1; Init();\n    for(int i=1; i<=N; ++i) \n    {\n        int x=read(), y=read();\n        Add_Edge(x, y+n, x+y);\n    }\n\n    for(int i=1; i<=N; ++i)\n    {\n        if(vis[i]) continue;\n\n        tp=0; cnt_node=cnt_edge=cnt_cir=0;\n        Find_Circle(i, 0);\n        if(cnt_node!=cnt_edge) \n        {\n            fail=1; break;\n        }\n\n        for(int j=1; j<=cnt_cir; ++j) Must_Link(to[cir[j]], 0);\n        for(int j=1; j<=cnt_cir; ++j) must[to[cir[j]]]=cir[j];\n\n        Subtree_Build();\n        \n        int now1=1, cnt1=0;\n        for(int j=1; j<=cnt_node; ++j)\n        {\n            if(fa[all[j]]) continue;\n            now1=1ll*now1*Count(all[j], 0)%mod*C(siz[all[j]], siz[all[j]]+cnt1)%mod;\n            cnt1+=siz[all[j]];\n        }\n\n        for(int j=1; j<=cnt_cir; ++j) must[to[cir[j]^1]]=cir[j]^1;\n\n        Subtree_Build();\n        \n        int now2=1, cnt2=0;\n        for(int j=1; j<=cnt_node; ++j)\n        {\n            if(fa[all[j]]) continue;\n            now2=1ll*now2*Count(all[j], 0)%mod*C(siz[all[j]], siz[all[j]]+cnt2)%mod;\n            cnt2+=siz[all[j]];\n        }\n\n        total+=cnt_node;\n        ans=1ll*C(cnt_node, total)*ans%mod*((now1+now2)%mod)%mod;\n    }\n\n    if(fail) printf(\"0\");\n    else printf(\"%d\", ans);\n}\n\nint main()\n{\n   \n\n    Work();\n\n    return 0;\n}\n\ninline int read()\n{\n    char c; bool type=1;\n    while((c=getchar())<'0' || c>'9')\n        if(c=='-') type=0;\n    int ans=c^48;\n    while((c=getchar())>='0' && c<='9')\n        ans=(ans<<3)+(ans<<1)+(c^48);\n    return type?ans:-ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <math.h>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 400005;\nconst int mod = 1e9+7;\n\nint n,p[maxn],sum[maxn],ans;\n\nint findp(int t) {\n\treturn p[t]?p[t]=findp(p[t]):t;\n}\nvoid merge(int u,int v) {\n\tu=findp(u);v=findp(v);\n\tu!=v?(p[u]=v,sum[v]+=sum[u]):0;\n}\n\nstruct edge {\n\tint u,v,next;\n}edg[maxn];\nint ehead[maxn],ecnt;\nvoid add(int u,int v) {\n\tedg[++ecnt]=(edge){u,v,ehead[u]};\n\tehead[u]=ecnt;sum[findp(u)]--;\n\tedg[++ecnt]=(edge){v,u,ehead[v]};\n\tehead[v]=ecnt;sum[findp(v)]--;\n}\n\nLL fpm(LL p,LL k) {\n\tLL res=1ll;p%=mod;\n\twhile (k) {\n\t\tif (k&1) (res*=p)%=mod;\n\t\t(p*=p)%=mod;k>>=1;\n\t}\n\treturn res;\n}\n\nint stk[maxn],top,fa[maxn],cal[maxn],res,val;bool ins[maxn],tag,onr[maxn];\nvoid FindRing(int u)\n{\n\tins[u]=true;\n\tfor (int v,j=ehead[u];j&&!tag;j=edg[j].next)\n\tif ((v=edg[j].v)!=fa[u]) {\n\t\tif (ins[v]) {\n\t\t\ttag=onr[u]=true;stk[++top]=u;\n\t\t\tfor (int i=u;i!=v;i=fa[i])\n\t\t\t\tstk[++top]=fa[i],onr[fa[i]]=true;\n\t\t}\n\t\telse fa[v]=u,FindRing(v);\n\t}\n\tins[u]=false;\n}\nvoid calc(int u,int fa)\n{\n\tcal[u]=1;ins[u]=true;\n\tfor (int v,j=ehead[u];j;j=edg[j].next)\n\tif ((v=edg[j].v)!=fa&&!onr[v]) {\n\t\tcalc(v,u);v<fa?cal[u]+=cal[v]:0;\n\t}\n\tif (fa) res=(LL)res*cal[u]%mod;\n}\nvoid calcR(int u,int fa)\n{\n\tif (ins[u]) return ;\n\tcal[u]=1;ins[u]=true;\n\tfor (int v,j=ehead[u];j;j=edg[j].next)\n\tif ((v=edg[j].v)!=fa&&v<fa) {\n\t\tcalcR(v,u);cal[u]+=cal[v];\n\t}\n\tval=(LL)val*cal[u]%mod;\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc083f.in\",\"r\",stdin);\n\t\tfreopen(\"arc083f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);ans=1;\n\tfor (int i=1;i<=n<<1;i++) ans=(LL)ans*i%mod;\n\tfor (int i=2;i<=(n<<1|1);i++) sum[i]=2;\n\tfor (int u,v,i=1;i<=n<<1;i++)\n\t\tscanf(\"%d %d\",&u,&v),add(u<<1,v<<1|1),merge(u<<1,v<<1|1);\n\tfor (int i=2;i<=(n<<1|1);i++)\n\t\tif (sum[i]&&!p[i]) {puts(\"0\");return 0;}\n\t\n\tfor (int i=2;i<=(n<<1|1);i++)\n\tif (!p[i]) {\n\t\tres=1;tag=false;top=0;FindRing(i);\n\t\tfor (int j=1;j<=top;j++) calc(stk[j],0);\n\t\tstk[0]=stk[top];stk[top+1]=stk[1];\n\t\tint oans=0;val=1;\n\t\tfor (int j=1;j<=top;j++) ins[stk[j]]=false;\n\t\tfor (int j=1;j<=top;j++) calcR(stk[j],stk[j-1]);\n\t\toans=fpm((LL)res*val,mod-2);val=1;\n\t\tfor (int j=1;j<=top;j++) ins[stk[j]]=false;\n\t\tfor (int j=1;j<=top;j++) calcR(stk[j],stk[j+1]);\n\t\toans=(oans+fpm((LL)res*val,mod-2))%mod;\n\t\tans=(LL)ans*oans%mod;\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = 1;\n    fact[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact[i] = fact[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = 1;\n    seq_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = 1;\n    fact_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz, es;\n    vector<vector<int>> items;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        es.resize(n);\n        items.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n            items[i] = {i};\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        es[x]++;\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        par[x] = y;\n        sz[y] += sz[x];\n        es[y] += es[x];\n        for(int a : items[x]) items[y].push_back(a);\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int size(int x){\n        return sz[find(x)];\n    }\n    int esize(int x){\n        return es[find(x)];\n    }\n};\n\nvoid fail(){\n    cout << 0 << endl;\n    exit(0);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    create_mod_tables(2*N);\n    UnionFind uf(2*N);\n    vector<set<int>> edges(2*N);\n    vector<vector<int>> edges_org(2*N);\n    for(int i=0; i<2*N; i++){\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y += N-1;\n        edges[x].insert(y);\n        edges[y].insert(x);\n        edges_org[x].push_back(y);\n        edges_org[y].push_back(x);\n        uf.unite(x, y);\n    }\n    for(int i=0; i<2*N; i++) if(uf.size(i) != uf.esize(i)) fail();\n\n    vector<int> ball(2*N, -1);\n    int64_t C = fact[2*N], ans = 1;\n    for(int pa=0; pa<2*N; pa++) if(uf.find(pa) == pa){\n        auto vs = uf.items[pa];\n        int sz = vs.size();\n        mul(C, fact_inv[sz]);\n        \n        queue<int> que;\n        for(int a : vs) if(edges[a].size() == 1) que.push(a);\n        while(que.size()){\n            int a = que.front(); que.pop();\n            int b = *edges[a].begin();\n            ball[a] = b;\n            edges[a].erase(b);\n            edges[b].erase(a);\n            if(edges[b].size() == 1) que.push(b);\n        }\n\n        vector<int> cycle;\n        for(int a : vs) if(edges[a].size()){\n            int prv = a, now = *edges[a].begin();\n            cycle = {a};\n            while(now != a){\n                cycle.push_back(now);\n                int nxt = *edges[now].begin();\n                if(nxt == prv) nxt = *edges[now].rbegin();\n                prv = now; now = nxt;\n            }\n            break;\n        }\n\n        int64_t res = 0;\n        for(int t=0; t<2; t++){\n            int csz = cycle.size();\n            for(int i=0; i<csz; i++) ball[cycle[i]] = cycle[(i+1)%csz];\n\n            static vector<int> to(2*N+1), indeg(2*N+1), psz(2*N+1);\n            static vector<int64_t> dp(2*N+1);\n            for(int a : vs){\n                to[a] = -1; indeg[a] = 0; psz[a] = 0; dp[a] = 1;\n            }\n            indeg[2*N] = 1e9; psz[2*N] = 0; dp[2*N] = 1;\n            for(int a : vs) for(int b : edges_org[a]) if(b < ball[a] && ball[b] == a){\n                to[b] = a;\n                indeg[a]++;\n            }\n            for(int a : vs) if(to[a] == -1) to[a] = 2*N;\n            queue<int> que;\n            for(int a : vs) if(indeg[a] == 0) que.push(a);\n            while(que.size()){\n                int a = que.front(); que.pop();\n                int b = to[a];\n                psz[a]++;\n                indeg[b]--;\n                if(indeg[b] == 0) que.push(b);\n                mul(dp[b], dp[a]);\n                mul(dp[b], comb_mod(psz[b]+psz[a], psz[a]));\n                psz[b] += psz[a];\n            }\n            add(res, dp[2*N]);\n\n            reverse(cycle.begin(), cycle.end());\n        }\n        mul(ans, res);\n    }\n    mul(ans, C);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"2,Ofast,inline\")\n#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int mod = 1e9 + 7;\n\ntemplate <typename T> T read(T &x) {\n\tint f = 0;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') f |= (c == '-'), c = getchar();\n\tfor (x = 0; c >= '0' && c <= '9'; c = getchar())\n\t\tx = (x << 3) + (x << 1) + (c ^ 48);\n\tif (f) x = -x;\n\treturn x;\n}\n\nint n, E, tim;\nint top, st[N];\nint x[N], y[N], dir[N];\nint fir[N], nex[N << 1], arr[N << 1], num[N << 2];\nint vis[N], used[N], incir[N], dp[N];\nvector<int> X[N], Y[N], cir, Eg, node;\nmap<pii, int> Map;\n\nint Qpow(int x, int p) {\n\tint ans = 1;\n\twhile (p) {\n\t\tif (p & 1) ans = 1LL * ans * x % mod;\n\t\tx = 1LL * x * x % mod;\n\t\tp >>= 1;\n\t}\n\treturn ans;\n}\n\nint Inv(int x) {\n\treturn Qpow(x, mod - 2);\n}\n\ninline void Add_Edge(int x, int y, int t) {\n \tnex[++E] = fir[x];\n\tfir[x] = E; arr[E] = y; num[E] = t;\n}\n\nvoid dfs(int x, int fa) {\n\tvis[x] = ++tim;\n\tnode.push_back(x);\n\tst[++top] = x;\n\tfor (int i = fir[x]; i; i = nex[i]) {\n\t\tif (!used[num[i]]) {\n\t\t\tEg.push_back(num[i]);\n\t\t\tused[num[i]] = 1;\n\t\t}\n\t\tif (arr[i] == fa) continue;\n\t\tif (!vis[arr[i]]) dfs(arr[i], x);\n\t\telse if (vis[arr[i]] < vis[x]) {\n\t\t\tfor (int j = top; st[j] != arr[i]; --j) {\n\t\t\t\tcir.push_back(st[j]);\n\t\t\t}\n\t\t\tcir.push_back(arr[i]);\n\t\t}\n\t}\n\t--top;\n}\n\nvoid dfs2(int x, int fa) {\n\tfor (int i = fir[x]; i; i = nex[i]) {\n\t\tif (arr[i] == fa) continue;\n\t\tif (incir[arr[i]]) continue;\n\t\tdir[num[i]] = arr[i];\n\t\tdfs2(arr[i], x);\n\t}\n}\n\nint dp_solve(int t) {\n\tif (~dp[t]) return dp[t];\n\tdp[t] = 1;\n\tif (dir[t] <= n) {\n\t\tfor (int i = 0; i < Y[y[t]].size(); ++i) {\n\t\t\tif (x[Y[y[t]][i]] < x[t]) dp[t] += dp_solve(Y[y[t]][i]);\n\t\t}\n\t}\n\tif (dir[t] > n) {\n\t\tfor (int i = 0; i < X[x[t]].size(); ++i) {\n\t\t\tif (y[X[x[t]][i]] < y[t]) dp[t] += dp_solve(X[x[t]][i]);\n\t\t}\n\t}\n\treturn dp[t];\n}\n\nint doit() {\n\tint ans = 1;\n\tfor (int i = 0; i < Eg.size(); ++i) {\n\t\tdp[Eg[i]] = -1;\n\t}\n\tfor (int i = 0; i < Eg.size(); ++i) {\n\t\tans = 1LL * ans * dp_solve(Eg[i]) % mod;\n\t\t// cout << x[Eg[i]] << ' ' << y[Eg[i]] << ' '\n\t\t// \t  << dir[Eg[i]] << ' ' << dp[Eg[i]] << endl;\n\t}\n//\tputs(\"\");\n\treturn Inv(ans);\n}\n\nint solve(int c) {\n\tint ans = 0;\n\ttop = 0;\n\tEg.clear();\n\tcir.clear();\n\tnode.clear();\n\tdfs(c, 0);\n\tif (Eg.size() != node.size()) return 0;\n\t// for (int i = 0; i < cir.size(); ++i)\n\t// \tcout << cir[i] << ' ';\n\t// puts(\"\");\n\t// puts(\"-----------------------\");\n\tfor (int i = 0; i < cir.size(); ++i) {\n\t\tincir[cir[i]] = 1;\n\t}\n\tfor (int i = 0; i < cir.size(); ++i) {\n\t\tdfs2(cir[i], 0);\n\t}\n\tcir.push_back(cir[0]);\n\tfor (int i = 0; i < cir.size() - 1; ++i) {\n\t\tdir[Map[make_pair(cir[i], cir[i + 1])]] = cir[i + 1];\n\t}\n\tans += doit();\n\tassert(cir.size() > 2);\n\tfor (int i = 0; i < cir.size() - 1; ++i) {\n\t\tdir[Map[make_pair(cir[i], cir[i + 1])]] = cir[i];\n\t}\n\tans += doit();\n\treturn ans % mod;\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n * 2; ++i) {\n\t\tread(x[i]); read(y[i]);\n\t\tAdd_Edge(x[i] + n, y[i], i);\n\t\tAdd_Edge(y[i], x[i] + n, i);\n\t\tX[x[i]].push_back(i);\n\t\tY[y[i]].push_back(i);\n\t\tMap[make_pair(x[i] + n, y[i])] = i;\n\t\tMap[make_pair(y[i], x[i] + n)] = i;\n\t}\n\tint ans = 1;\n\tfor (int i = 1; i <= n * 2; ++i) {\n\t\tif (!vis[i]) ans = 1LL * ans * solve(i) % mod;\n\t}\n\tfor (int i = 1; i <= n * 2; ++i)\n\t\tans = 1LL * ans * i % mod;\n\tcout << ans << endl;\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nstruct edge{\n\tint k,next;\n}e[N<<2];\nint n,home[N],cnt=-1,a[N],tot,sum=0,s[N],top,to[N],H[N];\nll fac[N],inv[N];\nll quick_pow(ll a,ll b){\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) ans=ans*a%mod;\n\treturn ans;\n}\nll C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nbool vis[N];\nll ans=1;\nvoid add(int *home,int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid dfs(int k){\n\tvis[k]=1;a[++tot]=k;\n\tfor(int i=home[k];~i;i=e[i].next,sum++) if(!vis[e[i].k])\n\t\tdfs(e[i].k);\n}\nint used[N],cir[N],cc;\nint fa[N];\nvoid dfs(int k,int F){\n\tused[k]=++cc;fa[k]=F;\n\tfor(int i=home[k];~i;i=e[i].next) if(i!=F){\n\t\tif(used[e[i].k]){\n\t\t\tif(used[e[i].k]>used[k]) continue;\n\t\t\tint x=k;\n\t\t\tcir[e[i].k]=1;\n\t\t\twhile(x!=e[i].k){\n\t\t\t\ts[++top]=x;\n\t\t\t\tcir[x]=1;\n\t\t\t\tx=e[fa[x]].k;\n\t\t\t}\n\t\t\ts[++top]=e[i].k;\n\t\t\tcontinue;\n\t\t}\n\t\telse dfs(e[i].k,i^1);\n\t}\n}\nvoid dfs1(int k,int F){\n\tused[k]=1;\n\tif(!cir[k]) to[k]=e[F].k;\n\tfor(int i=home[k];~i;i=e[i].next) if(i!=F&&!used[e[i].k]){\n\t\tdfs1(e[i].k,i^1);\n\t}\n}\nint vec,now,siz[N],IN[N];\nll f[N];\nvoid dp(int k){\n\tf[k]=1;now++;siz[k]=0;\n\tfor(int i=H[k];~i;i=e[i].next){\n\t\tdp(e[i].k);\n\t\tsiz[k]+=siz[e[i].k];\n\t\tf[k]=f[k]*C(siz[k],siz[e[i].k])%mod*f[e[i].k]%mod;\n\t}\n\tsiz[k]++;\n}\nvoid solve(){\n\ttop=cc=0;\n\tdfs(a[1],-1);\n\tfor(int i=1;i<=tot;i++) used[a[i]]=0;\n\tdfs1(s[1],-1);\n\tfor(int i=1;i<=tot;i++) used[a[i]]=0;\n\tll ret=0;\n\tint vv=vec,CNT=cnt;\n\tfor(int w=-1;w<=1;w+=2){\n\t\tcnt=CNT;\n\t\tfor(int i=1;i<=tot;i++) H[a[i]]=-1,IN[a[i]]=0;\n\t\tfor(int i=1;i<=top;i++){\n\t\t\tint x=i+w;\n\t\t\tif(x==top+1) x=1;\n\t\t\tif(x==0) x=top;\n\t\t\tto[s[i]]=s[x];\n\t\t}\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tfor(int p=home[a[i]];~p;p=e[p].next)if(e[p].k<to[a[i]]){\n\t\t\t\tadd(H,a[i],e[p].k);\n\t\t\t\tIN[e[p].k]++;\n\t\t\t}\n\t\t}\n\t\tll o=1;vec=vv;\n\t\tfor(int i=1;i<=tot;i++) if(!IN[a[i]]){\n\t\t\tnow=0;\n\t\t\tdp(a[i]);\n\t\t\to=o*C(vec,now)%mod*f[a[i]]%mod;\n\t\t\tvec-=now;\n\t\t}\n\t\tret=(ret+o)%mod;\n\t}\n\tans=ans*ret%mod;\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tmemset(H,-1,sizeof(H));\n\tscanf(\"%d\",&n);\n\tvec=n+n;\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=200002;i++) fac[i]=fac[i-1]*i%mod,inv[i]=quick_pow(fac[i],mod-2);\n\tfor(int i=1,x,y;i<=n+n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(home,x,y+n);add(home,y+n,x);\n\t}\n\tfor(int i=1;i<=n;i++)if(!vis[i]){\n\t\ttot=sum=0;\n\t\tdfs(i);\n\t\tif(sum!=tot+tot) return puts(\"0\"),0;\n\t\tsolve();\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//little jump frog txdy\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define pb push_back\nusing namespace std;\nconst int N=2e5+10,P=1e9+7;\nvector<int> F[N],G[N];\nint vis[N],s[N],tp,x,y,n,u,v,fac[N],inv[N],ifac[N],sz[N],dsy[N],tot;\nvoid dfs(int u,int fa=0){\n    vis[u]=1;s[++tp]=u;tot+=G[u].size();\n    for(int v:G[u]) if(v^fa){\n        if(!vis[v]) dfs(v,u);\n        else x=u,y=v;\n    }\n}\nvoid DFS(int u,int fa){for(int v:G[u]) if((v^fa)&&(v^x)) DFS(v,u),dsy[v]=u;}\nvoid cmz(int u){\n    sz[u]=1;\n    for(int v:F[u]) cmz(v),sz[u]+=sz[v];\n}\nint QFJ(){\n    dsy[x]=y;DFS(x,y);\n    rep(i,1,tp) vis[s[i]]=0,F[s[i]].clear();\n    rep(i,1,tp) for(int v:G[s[i]]) if(v<dsy[s[i]]) vis[v]=1,F[s[i]].pb(v);\n    rep(i,1,tp) if(!vis[s[i]]) cmz(s[i]);\n    int ans=fac[tp];\n    rep(i,1,tp) ans=1ll*ans*inv[sz[s[i]]]%P;\n    rep(i,1,tp) vis[s[i]]=1;\n    return ans;\n}\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,(n<<1)) scanf(\"%d%d\",&u,&v),G[u].pb(v+n),G[v+n].pb(u);\n    fac[0]=inv[1]=ifac[0]=1;\n    rep(i,2,(n<<1)) inv[i]=1ll*(P-P/i)*inv[P%i]%P;\n    rep(i,1,(n<<1)) fac[i]=1ll*fac[i-1]*i%P,ifac[i]=1ll*ifac[i-1]*inv[i]%P;\n    int qfj=0,ans=fac[n<<1];\n    rep(i,1,(n<<1)) if(!vis[i]){\n        tp=tot=0,dfs(i);if(tot^(tp<<1)) return puts(\"0\"),0;\n        qfj=QFJ(),swap(x,y),qfj=(qfj+QFJ())%P,ans=1ll*ans*ifac[tp]%P*qfj%P;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cfloat>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n\n#define EPS 1e-12\n#define ull unsigned long long\n#define ll long long\n#define VI vector<ll>\n#define PII pair<ll, ll> \n#define VVI vector<vector<ll> >\n#define REP(i,n) for(int i=0,_n=(n);(i)<(int)_n;++i)\n#define RANGE(i,a,b) for(int i=(int)a,_b=(int)(b);(i)<_b;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define ALLR(c) (c).rbegin(), (c).rend()\n#define PB push_back\n#define MP(a, b) make_pair(a, b)\n#define POPCOUNT __builtin_popcount\n#define POPCOUNTLL __builtin_popcountll\n#define CLEAR(table, v) memset(table, v, sizeof(table));\n#define PRINT1(table, D0) REP(d0, D0) cout<<table[d0]<<\" \"; cout<<\"\\n\";\n#define PRINT2(table, D0, D1) REP(d0, D0) { REP(d1, D1) cout<<table[d0][d1]<<\" \"; cout<<\"\\n\"; }\n#define PRINT3(table, D0, D1, D2) REP(d0, D0) { REP(d1, D1) { REP(d2, D2) cout<<table[d0][d1][d2]<<\" \"; cout<<\"\\n\"; } cout<<\"\\n\"; }\n#define UNIFORM_DOUBLE(a, b) (((b-a)*(double)rand()/RAND_MAX)+a) // [a, b) \n#define UNIFORM_LL(a, b) (ll)UNIFORM_DOUBLE(a, b) // [a, b) \n#define IN(v, lo, hi) ((lo)<=(v) && (v)<(hi))\n#define DD(v) cout<<#v<<\": \"<<v<<endl\ntemplate <typename T0, typename T1> std::ostream& operator<<(std::ostream& os, const map<T0, T1>& v) { for( typename map<T0, T1>::const_iterator p = v.begin(); p!=v.end(); p++ ){os << p->first << \": \" << p->second << \" \";} return os; }\ntemplate <typename T0, typename T1> std::ostream& operator<<(std::ostream& os, const pair<T0, T1>& v) { os << v.first << \": \" << v.second << \" \"; return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& v) { for( int i = 0; i < (int)v.size(); i++ ) { os << v[i] << \" \"; } return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const vector<vector<T> >& v) { for( int i = 0; i < (int)v.size(); i++ ) { os << v[i] << endl; } return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const set<T>& v) { vector<T> tmp(v.begin(), v.end()); os << tmp; return os; }\ntemplate <typename T> std::ostream& operator<<(std::ostream& os, const deque<T>& v) { vector<T> tmp(v.begin(), v.end()); os << tmp; return os; }\n\n#define MOD 1000000007LL\n#define INF (1LL<<60)\n\nstruct modll {\n\tstatic const ll MODVAL;\n\tll val;\n\tmodll() : val(0) {}\n\tmodll(ll v) : val(v) { normalize(); }\n\tvoid normalize() { val = (val+MODVAL) % MODVAL; }\n\tmodll  operator+ (ll v) { return modll(val+v); }\n\tmodll& operator+=(ll v) { val+=v; normalize(); return *this; }\n\tmodll  operator- (ll v) { return modll(val-v); }\n\tmodll& operator-=(ll v) { val-=v; normalize(); return *this; }\n\tmodll  operator* (ll v) { return modll(val*v); }\n\tmodll& operator*=(ll v) { val*=v; normalize(); return *this; }\n\tmodll  operator^ (ll e) { modll x(val); modll v(1); for(;e;x=x*x,e>>=1) if(e&1) v = v * x; return v; } // pow\n\tmodll inv() { modll x(val); return x^(MODVAL-2); } // MODVAL must be prime number when use this!\n\tstatic modll inv(ll v) { return modll(v).inv(); }\n\toperator ll() { return val; }\n};\nconst ll modll::MODVAL = 1000000007;\nstd::ostream& operator<<(std::ostream& os, const modll& v) { os << v.val; return os; }\n\n///////////////////////////// mod 上の演算\n\n#define MAXN 200009\nmodll facts[MAXN];\nmodll inv_facts[MAXN];\nll mod_combination(ll n, ll r) {\n\tassert(0<=n && n<MAXN); assert(0<=r && r<=n);\n\treturn modll(facts[n]) * inv_facts[r] * inv_facts[n-r];\n}\nvoid gen_facts() {\n\tfacts[0] = 1;\n\tinv_facts[0] = modll::inv(facts[0]);\n\tRANGE(i, 1, MAXN) facts[i] = facts[i-1] * modll(i);\n\tRANGE(i, 1, MAXN) inv_facts[i] = inv_facts[i-1] * modll::inv(i);\n\tREP(i, MAXN) assert((facts[i] * inv_facts[i])==1);\n}\n\n\nvoid dfs(int idx, int prev, VVI& g, VI& vis, VI& vs) {\n\tvis[idx]=1;\n\tvs.PB(idx);\n\tfor(int i : g[idx]) if(i!=prev && !vis[i]) {\n\t\tdfs(i, idx, g, vis, vs);\n\t}\n}\n\nvoid dfs2(int idx, int prev, VVI& g, VI& vis, VI& hi, VI& loop) {\n//\tDD(idx);\n\tvis[idx]=1;\n\thi.PB(idx);\n\tfor(int i : g[idx]) if(i!=prev) {\n//\t\tDD(i);\n\t\tif(vis[i]) {\n\t\t\tif(loop.size()==0) {\n//\t\t\t\tDD(\"vis\");\n//\t\t\t\tDD(hi);\n\t\t\t\tfor(int j=hi.size()-1;j>=0;j--) {\n\t\t\t\t\tloop.PB(hi[j]);\n\t\t\t\t\tif(hi[j]==i) break;\n\t\t\t\t}\n//\t\t\t\tDD(loop);\n\t\t\t}\n\t\t} else {\n\t\t\tdfs2(i, idx, g, vis, hi, loop);\n\t\t}\n\t}\n\thi.pop_back();\n}\n\nvoid dfs3(int idx, int prev, VVI& g, VI& P) {\n\tP[idx] = prev;\n\tfor(int i : g[idx]) if(i!=prev) {\n\t\tdfs3(i, idx, g, P);\n\t}\n}\n\nusing PLM = pair<ll, modll>;\n\nPLM combine(PLM x, PLM y) {\n\t// (lx+ly)!/lx!/ly!\n\tll lx = x.first;\n\tll ly = y.first;\n\treturn {lx+ly, x.second * y.second * mod_combination(lx+ly, ly)};\n}\n\nPLM dfs4(int idx, int prev, VVI& g) {\n\tPLM v = MP(0, modll(1));\n\tvector<PLM> w;\n\tint cnt=0;\n\tfor(int i : g[idx]) if(i!=prev) {\n\t\tauto son = dfs4(i, idx, g);\n\t\tw.PB(son);\n\t\tv = combine(v, son);\n\t\tcnt++;\n\t}\n\tif(cnt==0) return MP(1, modll(1));\n\tv.first++;\n\n//\tDD(\"dfs4\");\n//\tDD(idx);\n//\tDD(w);\n//\tDD(v);\n\treturn v;\n}\ntemplate <typename T>\nstruct TopologicalSort {\n\tvector<T> sorted;\n\tvector<bool> visited;\n\tvector<vector<T> > g;\n\tTopologicalSort(const vector<vector<T> >& g) {\n\t\tthis->g = g;\n\t\tvisited.resize(g.size());\n\t\tREP(i, g.size()) if(!visited[i]) dfs(i);\n\t\treverse(ALL(sorted));\n\t}\n\tvoid dfs(int v) {\n\t\tvisited[v]=true;\n\t\tREP(i, g[v].size()) if(!visited[g[v][i]]) dfs(g[v][i]);\n\t\tsorted.PB(v);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tgen_facts();\n\tll N;\n\twhile(cin>>N) {\n\t\tVI X(N*2), Y(N*2);\n\t\tREP(i, N*2) {\n\t\t\tcin>>X[i]>>Y[i];\n\t\t\tX[i]--; Y[i]--;\n\t\t}\n\t\tVVI g(N*2);\n\t\tauto add_edge = [&](int x, int y) {\n\t\t\tg[x].PB(y);\n\t\t\tg[y].PB(x);\n\t\t};\n\t\tREP(i, N*2) {\n\t\t\tadd_edge(X[i], Y[i]+N);\n\t\t}\n//\t\tDD(g);\n\t\tVI vis(N*2);\n\t\tVVI vss;\n\t\tREP(i, N*2) if(!vis[i]) {\n\t\t\tVI vs;\n\t\t\tdfs(i, -1, g, vis, vs);\n\t\t\tvss.PB(vs);\n\t\t}\n//\t\tDD(vss);\n\t\tbool ok = 1;\n\t\tPLM ans = MP(0, modll(1));\n\n\t\tREP(i, vss.size()) {\n\t\t\tVI w(N*2);\n\t\t\tREP(j, vss[i].size()) {\n\t\t\t\tw[vss[i][j]] = 1;\n\t\t\t}\n\t\t\tll e = 0;\n\t\t\tREP(i, g.size()) if(w[i]) {\n\t\t\t\tfor(int j : g[i]) {\n\t\t\t\t\tif(w[j]) e++;\n\t\t\t\t}\n\t\t\t}\n\t\t\te/=2;\n//\t\t\tDD(vss[i].size());\n//\t\t\tDD(e);\n\t\t\tif(vss[i].size()!=e) {\n\t\t\t\tok=0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// ループ検出\n\t\t\tVI vis(N*2);\n\t\t\tVI hi;\n\t\t\tVI loop;\n\t\t\tdfs2(vss[i][0], -1, g, vis, hi, loop);\n//\t\t\tDD(loop);\n\n\t\t\t// ループ以外の部分について点と辺の対応付け\n\t\t\tVI P(N*2);\n\t\t\tREP(j, loop.size()) {\n\t\t\t\tint c = loop[j];\n\t\t\t\tint n = loop[(j+1)%loop.size()];\n\t\t\t\tint p = loop[(j-1+loop.size())%loop.size()];\n\t\t\t\tfor(int k : g[c]) if(k!=n&&k!=p) {\n//\t\t\t\t\tDD(c);\n//\t\t\t\t\tDD(k);\n\t\t\t\t\tdfs3(k, c, g, P);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tDD(P);\n\t\t\tPLM lans = MP(vss[i].size(), modll(0));\n\t\t\tREP(l, 2) {\n\t\t\t\t// ループの部分について点と辺の対応付け\n\t\t\t\tREP(k, loop.size()) {\n\t\t\t\t\tP[loop[k]] = loop[(k+1)%loop.size()];\n\t\t\t\t}\n\n//\t\t\t\tDD(P);\n\n\t\t\t\t// 頂点の依存関係をグラフ化\n\t\t\t\tVVI g2(N*2);\n\t\t\t\tVVI g3(N*2);\n\t\t\t\tauto add_edge2 = [&](int x, int y) {\n\t\t\t\t\tg2[x].PB(y);\n\t\t\t\t};\n\t\t\t\tauto add_edge3 = [&](int x, int y) {\n\t\t\t\t\tg3[x].PB(y);\n\t\t\t\t};\n\t\t\t\tREP(j, vss[i].size()) {\n\t\t\t\t\tint v = vss[i][j];\n\t\t\t\t\tfor(auto ai : g[v]) {\n\t\t\t\t\t\tif(ai < P[v]) {\n\t\t\t\t\t\t\tadd_edge2(ai, v); // leaf -> root   v depends on ai\n\t\t\t\t\t\t\tadd_edge3(v, ai); // root -> leaf\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tDD(g2);\n//\t\t\t\tDD(g3);\n\n\t\t\t\t// 有向グラフ→その通りに並べる組み合わせ数\n//\t\t\t\tTopologicalSort<ll> ts(g2);\n//\t\t\t\tDD(ts.sorted);\n\t\t\t\t// 出ていく辺がないやつはroot\n\t\t\t\tVI roots;\n\t\t\t\tREP(j, vss[i].size()) {\n\t\t\t\t\tint v = vss[i][j];\n\t\t\t\t\tif(g2[v].size()==0) roots.PB(v);\n\t\t\t\t}\n//\t\t\t\tDD(roots);\n\n\t\t\t\t// 木DPで各rootまで行く組み合わせ数を求め、それらのcombineを求める\n\t\t\t\tPLM a = MP(0LL, modll(1));\n\t\t\t\tfor(int ri : roots) {\n\t\t\t\t\tPLM z = dfs4(ri, -1, g3);\n//\t\t\t\t\tDD(ri);\n//\t\t\t\t\tDD(z);\n\t\t\t\t\ta = combine(a, z);\n\t\t\t\t}\n//\t\t\t\tDD(a);\n\t\t\t\tlans.second += a.second;\n\n\t\t\t\treverse(ALL(loop));\n\t\t\t}\n//\t\t\tDD(lans);\n\t\t\tans = combine(ans, lans);\n\t\t}\n//\t\tDD(ok);\n\t\tif(!ok) ans.second = 0LL;\n//\t\tDD(ans);\n\t\tcout<<ans.second<<endl;\n//\t\tbreak;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e5 + 5;\nconst int MOD = 1e9 + 7;\n\nint N;\nPii A[MAXN];\n\nvoid input()\n{\n    read(N);\n    N *= 2;\n    for (int i = 1; i <= N; ++i) {\n        read(A[i].x); read(A[i].y);\n    }\n}\n\nstd::map<Pii, int> id;\nvector<int> G[MAXN];\nvector<int> cyc;\nvector<Pii> edges;\nint cycflag;\nint dep[MAXN];\nint st[MAXN];\nint top;\n\nLL fpm(LL base, LL exp)\n{\n    LL ret = 1;\n    for (; exp; exp >>= 1) {\n        if (exp & 1)\n            (ret *= base) %= MOD;\n        (base *= base) %= MOD;\n    }\n    return ret;\n}\n\nvoid dfs(int u, int f)\n{\n    dep[u] = dep[f] + 1;\n    for (int i = 0; i < SZ(G[u]); ++i) {\n        int v = G[u][i];\n        if (v == f)\n            continue;\n        if (!dep[v]) {\n            st[++top] = SZ(edges);\n            edges.push_back(MP(v, u));\n            dfs(v, u);\n            --top;\n        } else if (dep[v] < dep[u]) {\n            if (++cycflag == 1) {\n                int t = top;\n                do {\n                    cyc.push_back(st[t]);\n                } while (edges[st[t--]].y != v);\n                cyc.push_back(SZ(edges));\n                edges.push_back(MP(v, u));\n            } else {\n                puts(\"0\");\n                exit(0);\n            }\n        }\n    }\n}\n\nnamespace MickeyMouseClubhouse\n{\n\nvector<int> T[MAXN];\nbool vis[MAXN], rt[MAXN];\nint size[MAXN];\n\nLL dfs(int u)\n{\n    LL ret = 1;\n    size[u] = 1;\n    vis[u] = true;\n    for (int i = 0; i < SZ(T[u]); ++i) {\n        int v = T[u][i];\n        if (vis[v] || !((ret *= dfs(v)) %= MOD))\n            return 0;\n        size[u] += size[v];\n    }\n    return ret * fpm(size[u], MOD - 2) % MOD;\n}\n\nLL count()\n{\n    std::set<int> V;\n\n    for (int i = 0; i < SZ(edges); ++i) {\n        int u = edges[i].x, v = edges[i].y;\n        int t = std::lower_bound(ALL(G[u]), v) - G[u].begin();\n        int y = id[MP(u, v)];\n        if (V.insert(y).y) {\n            T[y].clear();\n            vis[y] = false;\n            rt[y] = true;\n        }\n        while (t--) {\n            int x = id[MP(u, G[u][t])];\n            if (V.insert(x).y) {\n                T[x].clear();\n                vis[x] = false;\n            }\n            T[y].push_back(x);\n            rt[x] = false;\n        }\n    }\n\n    LL ret = 1;\n    for (auto x : V) {\n        if (rt[x])\n            (ret *= dfs(x)) %= MOD;\n    }\n\n    return ret;\n}\n\n}\n\nvoid solve()\n{\n    std::sort(A + 1, A + N + 1);\n    for (int i = 1; i <= N; ++i) {\n        G[A[i].x].push_back(A[i].y + N / 2);\n        G[A[i].y + N / 2].push_back(A[i].x);\n        // printf(\"%d %d %d\\n\", A[i].x, A[i].y + N / 2, i);\n        id[MP(A[i].x, A[i].y + N / 2)] = i;\n        id[MP(A[i].y + N / 2, A[i].x)] = i;\n    }\n\n    LL ans = 1;\n    for (int i = 1; i <= N; ++i) {\n        if (dep[i])\n            continue;\n        cycflag = 0; edges.clear(); cyc.clear();\n        dfs(i, 0);\n        if (cycflag != 1) {\n            puts(\"0\");\n            return;\n        }\n        int rt = edges[cyc[0]].x;\n        for (auto e : edges) {\n            dep[e.x] = dep[e.y] = 0;\n        }\n        cycflag = 0; edges.clear(); cyc.clear();\n        dfs(rt, 0);\n\n        LL cur = 0;\n        (cur += MickeyMouseClubhouse::count()) %= MOD;\n        for (int j = 0; j < SZ(cyc); ++j) {\n            std::swap(edges[cyc[j]].x, edges[cyc[j]].y);\n        }\n        (cur += MickeyMouseClubhouse::count()) %= MOD;\n\n        (ans *= cur) %= MOD;\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        (ans *= i) %= MOD;\n    }\n\n    printf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n}\n\n// 优化原则：雕琢前先得有原型，跑之前先学会走。\n//     -- UNIX哲学基础第十五条，《UNIX编程艺术》by ESR\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        // assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            chain_t c = use_generic(i, true);\n            return c * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            chain_t c = use_generic(i, false);\n            return c * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        REP (y, n) acc = acc * go_row(y);\n        REP (x, n) acc = acc * go_col(x);\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define fore(e, u, v) for (int p = e(u), v = e[p].y; p; v = e[p = e[p].nxt].y)\n#define ri rd<int>\nconst int maxN = 2e5 + 7;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\ninline int pls(int x, int y) { return (x += y) >= mod ? x - mod : x; }\ninline int mns(int x, int y) { return (x -= y) < 0 ? x + mod : x; }\ninline int mul(int x, int y) { return 1LL * x * y % mod; }\ninline void Add(int &x, int y) { x = pls(x, y); }\ninline void Mul(int &x, int y) { x = mul(x, y); }\ninline void Minus(int &x, int y) { x = mns(x, y); }\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\ninline void NIE() { puts(\"0\"); exit(0); }\n\nint n, m, tt;\nint deg[maxN];\nint fac[maxN], iv[maxN], ifac[maxN];\nint pt[maxN], ed[maxN];\nbool use[maxN];\n\nstruct Vec {\n\tstatic const int maxE = maxN;\n\tint g[maxN], te;\n\tstruct edge {int y, id, nxt;} e[maxE << 1];\n\tinline void push(int x, int y, int i = 0) { e[++te] = (edge){y, i, g[x]}; g[x] = te;}\n\tinline void link(int x, int y, int i = 0) { push(x, y, i), push(y, x, i); }\n\tinline int& operator () (int x) { return g[x]; }\n\tinline edge& operator [] (int x) { return e[x]; }\n};\n\nstruct Rec { int v, id; };\n\nnamespace T {\n\tVec e;\n\tint in[maxN], sz[maxN], f[maxN];\n\n\tvoid dfs(int x) {\n\t\tf[x] = sz[x] = 1;\n\t\tfore (e, x, y) {\n\t\t\tdfs(y);\n\t\t\tMul(f[x], mul(f[y], ifac[sz[y]]));\n\t\t\tsz[x] += sz[y];\n\t\t}\n\t\tMul(f[x], fac[sz[x]-1]);\n\t}\n\n\tint main() {\n\t\tint res = 1;\n\t\trep (i, 1, m) if (in[ed[i]] == 0) {\n\t\t\tdfs(ed[i]);\n\t\t\tMul(res, mul(f[ed[i]], ifac[sz[ed[i]]]));\n\t\t}\n\t\treturn mul(res, fac[m]);\n\t}\n}\n\nnamespace G {\n\tVec e;\n\tint vis[maxN];\n\tint q[maxN];\n\tRec to[maxN];\n\tRec lop[maxN]; int tl;\n\tint num[maxN];\n\n\tvoid dfs(int x) {\n\t\tvis[x] = 1; pt[++tt] = x;\n\t\tfore (e, x, y) if (!vis[y]) dfs(y);\n\t}\n\n\tint gao() {\n\t\tT::e.te = 0; rep (i, 1, m) T::e.g[ed[i]] = T::in[ed[i]] = 0;\n\t\trep (i, 1, tt) {\n\t\t\tint x = pt[i];\n\t\t\tfore (e, x, y) if (y < to[x].v) T::e.push(to[x].id, e[p].id), ++T::in[e[p].id];\n\t\t}\n\t\treturn T::main();\n\t}\n\n\tint calc() {\n\t\tint h = 0, t = 0; rep (i, 1, tt) if (deg[pt[i]] == 1) q[++t] = pt[i];\n\t\twhile (h != t) {\n\t\t\tint x = q[++h]; vis[x] = 2;\n\t\t\tfore (e, x, y) {\n\t\t\t\t--deg[y];\n\t\t\t\tif (deg[y] == 1) q[++t] = y;\n\t\t\t\tif (deg[y] != 0) to[x] = (Rec){y, e[p].id};\n\t\t\t}\n\t\t}\n\t\trep (i, 1, tt) if (vis[pt[i]] != 2) {\n\t\t\ttl = 0; q[++t] = pt[i];\n\t\t\twhile (h != t) {\n\t\t\t\tint x = q[++h]; vis[x] = 2; deg[x] = 0;\n\t\t\t\tfore (e, x, y) if (--deg[y] == 1) { \n\t\t\t\t\tq[++t] = y; lop[++tl] = (Rec){x, e[p].id}; \n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t}\n\t\t\tfore (e, q[t], y) if (y == pt[i]) lop[++tl] = (Rec){q[t], e[p].id};\n\t\t\tlop[++tl] = lop[1];\n\t\t\tbreak;\n\t\t}\n\n\t\tint res = 0;\n\t\tFor (i, 1, tl) to[lop[i].v] = (Rec){lop[i+1].v, lop[i].id};\n\t\tAdd(res, gao());\n\t\trep (i, 2, tl) to[lop[i].v] = (Rec){lop[i-1].v, lop[i-1].id};\n\t\tAdd(res, gao());\n\t\treturn res;\n\t}\n\n\tint main() {\n\t\tint res = 1;\n\t\trep (i, 1, n) if (!vis[i]) {\n\t\t\tm = tt = 0;\n\t\t\tdfs(i);\n\t\t\trep (i, 1, tt) fore (e, pt[i], y) if (!use[e[p].id]) use[ed[++m] = e[p].id] = 1;\n\t\t\tif (tt != m) NIE();\n\t\t\tMul(res, mul(calc(), ifac[m]));\n\t\t}\n\t\tMul(res, fac[n]);\n\t\treturn res;\n\t}\n}\n\nvoid init() {\n\tiv[1] = 1; rep (i, 2, n) iv[i] = mul(iv[mod % i], mod - mod / i);\n\tfac[0] = 1; rep (i, 1, n) fac[i] = mul(fac[i-1], i);\n\tifac[0] = 1; rep (i, 1, n) ifac[i] = mul(ifac[i-1], iv[i]);\n}\n\nint main() {\n\n\tn = ri() << 1;\n\trep (i, 1, n) {\n\t\tint x = ri(), y = ri();\n\t\tG::e.link(x, y+n/2, i);\n\t\t++deg[x], ++deg[y+n/2];\n\t}\n\n\tinit();\n\tprintf(\"%d\\n\", G::main());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200005; \nconst long long mod = 1000000007; \n\nusing namespace std;\n\nint n, T; \n\nbool oncir[N], vis[N]; \nint num, sum, cir[N], cur[N]; \n\nint tp, sta[N]; \nbool insta[N]; \n\nint match[N], ind[N], siz[N]; \nlong long f[N]; \n\nvector< int > G[N]; \nvector< int > S[N]; \n\nlong long fac[N], inv[N]; \n\nlong long Pow(long long a, long long e) {\n\tlong long ret=1, cnt=a%mod;\n\twhile(e) {\n\t\tif(e & 1) ret = ret * cnt % mod;\n\t\tcnt = cnt * cnt % mod; \n\t\te >>= 1; \n\t} \n\treturn ret; \n}\n\nvoid prepare() {\n\tfac[1] = 1; \n\tfor(int i=2; i<=n; ++i) fac[i] = fac[i-1] * i % mod; \n\tinv[n] = Pow(fac[n], mod-2); \n\tfor(int i=n-1; i>=0; --i) inv[i] = inv[i+1] * (i+1) % mod;  \n}\n\nlong long C(int n, int m) {\n\treturn fac[n] * inv[n-m] % mod * inv[m] % mod; \n}\n\nvoid dfs_Circle(int u, int f) {\n\tif(insta[u]) {\n\t\tint now; \n\t\tdo {\n\t\t\tnow = sta[tp--];\n\t\t\tinsta[now] = 0; \n\t\t\tcir[++num] = now; \n\t\t\toncir[now] = 1; \n\t\t}while(now != u); \n\t\t++T; \n\t\treturn ; \n\t}\n\tvis[u] = 1; \n\tinsta[u] = 1; \n\tsta[++tp] = u; \n\tcur[++sum] = u; \n\tint size = G[u].size();  \n\tfor(int k=0; k<size; ++k) {\n\t\tint v = G[u][k]; \n\t\tif(oncir[v] || v == f) continue; \n\t\tdfs_Circle(v, u); \n\t}\n\tif(insta[u]) {\n\t\tsta[tp--] = 0;\n\t\tinsta[u] = 0;  \n\t}\n}\n\nvoid dfs_Tree(int u, int f) {\n\tmatch[u] = f; \n\tint size = G[u].size();  \n\tfor(int k=0; k<size; ++k) {\n\t\tint v = G[u][k]; \n\t\tif(oncir[v] || v == f) continue; \n\t\tdfs_Tree(v, u); \n\t}\n}\n\nvoid dfs_calc(int u) {\n\tf[u] = 1; \n\tsiz[u] = 0; \n\tint size = S[u].size(); \n\tfor(int k=0; k<size; ++k) {\n\t\tint v = S[u][k]; \n\t\tdfs_calc(v);\n\t\tsiz[u] += siz[v]; \n\t\tf[u] = 1ll * f[u] * f[v] % mod * C(siz[u], siz[v]) % mod; \n\t}\n\t++siz[u]; \n}\n\nlong long calc() {\n\tfor(int i=1; i<=sum; ++i) ind[cur[i]] = 0; \n\tfor(int i=1; i<=sum; ++i) {\n\t\tint u = cur[i];\n\t\tS[u].clear();\n\t\tint size = G[u].size();  \n\t\tfor(int k=0; k<size; ++k) {\n\t\t\tint v = G[u][k]; \n\t\t\tif(v == match[u]) break; \n\t\t\tS[u].push_back(v); \n\t\t\t++ind[v]; \n\t\t}\n\t}\n\tS[0].clear();\n\tfor(int i=1; i<=sum; ++i) \n\t\tif(!ind[cur[i]]) S[0].push_back(cur[i]);\n\tdfs_calc(0);\n\treturn f[0];  \n}\n\nint main() {\n\t\n\tint u, v; \n\t\n\tint psum=0; \n\tlong long ans = 1; \n\t\n\tcin >> n; \n\tfor(int i=1; i<=(n<<1); ++i) {\n\t\tcin >> u >> v;  \n\t\tG[u].push_back(v+n); \n\t\tG[v+n].push_back(u); \n\t}\n\t\n\tn <<= 1; \n\tfor(int i=1; i<=n; ++i) sort(G[i].begin(), G[i].end()); \n\t\n\tprepare(); \n\t\n\tfor(int i=1; i<=n; ++i) {\n\t\t\n\t\tif(vis[i]) continue; \n\t\t\n\t\tT = sum = num = tp = 0; \n\t\tdfs_Circle(i, 0); \n\t\t\n\t\tif(T != 1) {\n\t\t\tans = 0; \n\t\t\tbreak; \n\t\t}\n\t\t\n\t\tfor(int j=1; j<=num; ++j) dfs_Tree(cir[j], 0); \n\t\t\n\t\tlong long tmp = 0; \n\t\t\n\t\tfor(int j=2; j<=num; ++j) match[cir[j]] = cir[j-1]; \n\t\tmatch[cir[1]] = cir[num]; \n\t\ttmp += calc(); \n\t\t\n\t\tfor(int j=1; j<num; ++j)  match[cir[j]] = cir[j+1];\n\t\tmatch[cir[num]] = cir[1];\n\t\ttmp += calc(); \n\t\t\n\t\tpsum += sum; \n\t\tans = 1ll * ans * tmp % mod * C(psum, sum) % mod; \n\t\t\n\t}\n\t\n\tcout << ans << endl; \n\t\n\treturn 0; \n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\nusing namespace std;\nconst int maxn=200100;\nconst long long md=1000000007;\nvoid broke(){\n\tprintf(\"0\\n\");\n\texit(0);\n}\nlong long fac[maxn+10],inv[maxn+10];\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nstruct point{\n\tint x,y;\n}a[maxn];\nint dr[maxn],d[maxn];//1->x,2->y\nvector<int> vx[maxn],vy[maxn];\nvector<int> vec[maxn];\nbool us[maxn];\nint cntx[maxn],cnty[maxn];\nint q[maxn];\nint f[maxn];\nint fa(int x){\n\treturn f[x]==x?x:f[x]=fa(f[x]);\n}\nstruct node{\n\tlong long len,ans;\n};\nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%md*inv[x-y]%md;\n}\nvoid merge(node &A,node B){\n\tA.len=A.len+B.len;\n\tA.ans=A.ans*C(A.len,B.len)%md;\n\tA.ans=A.ans*B.ans%md;\n}\nbool vis[maxn],havef[maxn];\nnode dp[maxn];\nvoid dfs(int u){\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tdp[u]=(node){0,1};\n\tint v;\n\tif(d[u]==1){\n\t\tfor(int i=0;i<(int)vx[a[u].x].size();i++){\n\t\t\tv=vx[a[u].x][i];\n\t\t\tif(a[v].y<a[u].y){\n\t\t\t\thavef[v]=1;\n\t\t\t\tdfs(v);\n\t\t\t\tmerge(dp[u],dp[v]);\n\t\t\t}\n\t\t}\n\t\tdp[u].len++;\n\t}\n\telse{\n\t\tfor(int i=0;i<(int)vy[a[u].y].size();i++){\n\t\t\tv=vy[a[u].y][i];\n\t\t\tif(a[v].x<a[u].x){\n\t\t\t\thavef[v]=1;\n\t\t\t\tdfs(v);\n\t\t\t\tmerge(dp[u],dp[v]);\n\t\t\t}\n\t\t}\n\t\tdp[u].len++;\n\t}\n}\nbool getall(int u){\n\tint v;\n\tif(d[u]==1){\n\t\tfor(int i=0;i<(int)vx[a[u].x].size();i++){\n\t\t\tv=vx[a[u].x][i];\n\t\t\tif(u==v) continue;\n\t\t\tif(!d[v]){\n\t\t\t\td[v]=3-d[u];\n\t\t\t\tif(!getall(v)) return 0;\n\t\t\t}\n\t\t\telse if(d[v]==d[u]) return 0;\n\t\t}\n\t}\n\tif(d[u]==2){\n\t\tfor(int i=0;i<(int)vy[a[u].y].size();i++){\n\t\t\tv=vy[a[u].y][i];\n\t\t\tif(u==v) continue;\n\t\t\tif(!d[v]){\n\t\t\t\td[v]=3-d[u];\n\t\t\t\tif(!getall(v)) return 0;\n\t\t\t}\n\t\t\telse if(d[v]==d[u]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\nlong long Solve(int x,int y){\n\tint v;\n\tfor(int i=0;i<(int)vec[x][i];i++){\n\t\tv=vec[x][i];\n\t\td[v]=dr[v];\n\t\tvis[v]=havef[v]=0;\n\t}\n\tbool bo=1;\n\tfor(int i=0;i<(int)vec[x].size();i++)\n\t\tif(!d[vec[x][i]]){\n\t\t\td[vec[x][i]]=y;\n\t\t\tbo=getall(vec[x][i]);\n\t\t\tbreak;\n\t\t}\n\tif(bo){\n\t\tnode st=(node){0,1};\n\t\tfor(int i=0;i<(int)vec[x].size();i++)\n\t\t\tif(!vis[vec[x][i]])\n\t\t\t\tdfs(vec[x][i]);\n\t\tfor(int i=0;i<(int)vec[x].size();i++)\n\t\t\tif(!havef[vec[x][i]])\n\t\t\t\tmerge(st,dp[vec[x][i]]);\n\t\treturn st.ans;\n\t}\n\treturn 0;\n}\nnode solve(int x){\n\tnode ans=(node){(int)vec[x].size(),0};\n\tans.ans=ans.ans+Solve(x,1);\n\tans.ans=ans.ans+Solve(x,2);\n\treturn ans;\n}\nint main(){\n//\tfreopen(\"F.in\",\"r\",stdin);\n\tfac[0]=1;\n\tfor(int i=1;i<=maxn;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[maxn]=powd(fac[maxn],md-2);\n\tfor(int i=maxn;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\tf[i]=i;\n\t\tif(!vx[a[i].x].empty()) f[fa(i)]=fa(vx[a[i].x].front());\n\t\tvx[a[i].x].push_back(i);\n\t\tif(!vy[a[i].y].empty()) f[fa(i)]=fa(vy[a[i].y].front());\n\t\tvy[a[i].y].push_back(i);\n\t}\n\tint l=1,r=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(vx[i].size()==0)\n\t\t\tbroke();\n\t\tif(vx[i].size()==1){\n\t\t\tq[++r]=vx[i][0];\n\t\t\tif(dr[vx[i][0]]) broke();\n\t\t\tdr[vx[i][0]]=1;\n\t\t}\n\t\tcntx[i]=vx[i].size();\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(vy[i].size()==0)\n\t\t\tbroke();\n\t\tif(vy[i].size()==1)\n\t\t{\n\t\t\tq[++r]=vy[i][0];\n\t\t\tif(dr[vy[i][0]]) broke();\n\t\t\tdr[vy[i][0]]=2;\n\t\t}\n\t\tcnty[i]=vy[i].size();\n\t}\n\tint u;\n\twhile(l<=r){\n\t\tu=q[l],l++;\n\t\tcntx[a[u].x]--;\n\t\tif(cntx[a[u].x]==1){\n\t\t\tfor(int i=0;i<(int)vx[a[u].x].size();i++){\n\t\t\t\tif(!dr[vx[a[u].x][i]]){\n\t\t\t\t\tdr[vx[a[u].x][i]]=1;\n\t\t\t\t\tq[++r]=vx[a[u].x][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i==(int)vx[a[u].x].size()-1) broke();\n\t\t\t}\n\t\t}\n\t\tcnty[a[u].y]--;\n\t\tif(cnty[a[u].y]==1){\n\t\t\tfor(int i=0;i<(int)vy[a[u].y].size();i++){\n\t\t\t\tif(!dr[vy[a[u].y][i]]){\n\t\t\t\t\tdr[vy[a[u].y][i]]=2;\n\t\t\t\t\tq[++r]=vy[a[u].y][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i==(int)vy[a[u].y].size()-1) broke();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(cntx[i]>2||cnty[i]>2)\n\t\t\tbroke();\n\tfor(int i=1;i<=n*2;i++)\n\t\tvec[fa(i)].push_back(i);\n\tnode ans=(node){0,1},st;\n\tfor(int i=1;i<=n*2;i++){\n\t\tif(us[fa(i)]) continue;\n\t\tus[fa(i)]=1;\n\t\tst=solve(fa(i));\n\t\tmerge(ans,st);\n\t}\n\tprintf(\"%lld\\n\",ans.ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tint sz=V[x].size();\n\t\tref(i,0,sz-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;/*s=dfs(o);*/Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;/*s=dfs(o);*/Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v; };\n\nint f[300000], fi[300000];\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n>>=1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint inv_mod(int x, int p) {\n\treturn pow_mod(x, p - 2, p);\n}\n\nint C(int x, int y) {\n\treturn (ll)f[x] * fi[y] % MOD * fi[x - y] % MOD;\n}\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint prod;\n\nint dfs(int u, vector<vector<int> >& G) {\n\tint tot = 0;\n\tfor (int v: G[u]) {\n\t\tint sz = dfs(v, G);\n\t\ttot += sz;\n\t\tprod = (ll)prod * C(tot, sz) % MOD;\n\t}\n\treturn tot + 1;\n}\n\nint calc(int N, int M, vector<int> a, vector<int> b, vector<int> dir) {\n\trep(i, N + M) if (dir[i] == -1) return 0;\n\tvector<int> unko(N + M);\n\trep(i, N + M) {\n\t\tif (dir[i] == 0) unko[a[i]]++;\n\t\tif (dir[i] == 1) unko[N + b[i]]++;\n\t}\n\trep(u, N + M) if (unko[u] != 1) return 0;\n\tvector<vector<i_i> > xs(N), ys(M);\n\trep(i, N + M) xs[a[i]].pb(i_i(b[i], i));\n\trep(i, N + M) ys[b[i]].pb(i_i(a[i], i));\n\tvector<vector<int> > G(N + M);\n\tvector<bool> root(N + M, true);\n\trep(k, N) {\n\t\tsort(xs[k].begin(), xs[k].end());\n\t\trep(l, xs[k].size()) {\n\t\t\tint i = xs[k][l].second;\n\t\t\tif (dir[i] == 0)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(xs[k][_l].second);\n\t\t}\n\t}\n\trep(k, N) {\n\t\tsort(ys[k].begin(), ys[k].end());\n\t\trep(l, ys[k].size()) {\n\t\t\tint i = ys[k][l].second;\n\t\t\tif (dir[i] == 1)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(ys[k][_l].second);\n\t\t}\n\t}\n\trep(u, N + M) for (int v: G[u]) root[v] = false;\n\tvector<int> to;\n\trep(u, N + M) if (root[u]) to.pb(u);\n\tG.pb(to);\n\tprod = 1;\n\tdfs(N + M, G);\n\treturn prod;\n}\n\nint solve(int N, int M, vector<int> a, vector<int> b) {\n\treturn 0;\n\tif (N + M != a.size()) return 0;\n\tvector<vector<edge> > G(N + M);\n\trep(i, N + M) G[a[i]].pb(edge{i, N + b[i]}), G[N + b[i]].pb(edge{i, a[i]});\n\tvector<int> d(N + M);\n\trep(u, N + M) d[u] = G[u].size();\n\tqueue<int> q;\n\trep(u, N + M) if (d[u] == 1) q.push(u);\n\tvector<bool> exist(N + M, true);\n\tvector<int> dir(N + M, -1);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\texist[u] = false;\n\t\tint i;\n\t\tfor (edge e: G[u]) if (exist[e.v]) {\n\t\t\ti = e.i;\n\t\t\td[e.v]--;\n\t\t\tif (d[e.v] == 1) q.push(e.v);\n\t\t}\n\t\tdir[i] = (u >= N);\n\t}\n\tint i0 = -1;\n\trep(i, N + M) if (dir[i] == -1) i0 = i;\n\tif (i0 == -1) return calc(N, M, a, b, dir);\n\tvector<int> dir0 = dir;\n\tint ans = 0;\n\trep(t, 2) {\n\t\tdir = dir0;\n\t\tint s;\n\t\tif (t == 0) s = a[i0], dir[i0] = 0;\n\t\tif (t == 1) s = N + b[i0], dir[i0] = 1;\n\t\tvector<bool> vis(N + M); vis[s] = true;\n\t\tqueue<int> q; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (edge e: G[u]) if (dir[e.i] == -1) {\n\t\t\t\tdir[e.i] = (e.v >= N);\n\t\t\t\tif (!vis[e.v]) {\n\t\t\t\t\tvis[e.v] = true;\n\t\t\t\t\tq.push(e.v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (ans + calc(N, M, a, b, dir)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tf[0] = fi[0] = 1;\n\tfor (int x = 1; x < 300000; x++) {\n\t\tf[x] = (ll)f[x - 1] * x % MOD;\n\t\tfi[x] = (ll)fi[x - 1] * inv_mod(x, MOD) % MOD;\n\t}\n\tint N; cin >> N;\n\tvector<int> a(N * 2), b(N * 2);\n\trep(i, N * 2) scanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\tunion_find uf(N * 2);\n\trep(i, N * 2) uf.unite(a[i], b[i] + N);\n\tvector<vector<int> > vv(N * 2);\n\trep(i, N * 2) vv[uf.find(a[i])].pb(i);\n\tint ans = 1;\n\tfor (vector<int> v: vv) if (!v.empty()) {\n\t\tvector<int> _a, _b;\n\t\tfor (int i: v) _a.pb(a[i]), _b.pb(b[i]);\n\t\tvector<int> A = _a, B = _b;\n\t\tsort(A.begin(), A.end());\n\t\tsort(B.begin(), B.end());\n\t\tA.erase(unique(A.begin(), A.end()), A.end());\n\t\tB.erase(unique(B.begin(), B.end()), B.end());\n\t\tfor (int& u: _a) u = lower_bound(A.begin(), A.end(), u) - A.begin();\n\t\tfor (int& u: _b) u = lower_bound(B.begin(), B.end(), u) - B.begin();\n\t\tans = (ll)ans * solve(A.size(), B.size(), _a, _b) % MOD;\n\t}\n\tint tot = 0;\n\trep(u, N * 2) if (uf.root(u)) {\n\t\ttot += uf.size(u);\n\t\tans = (ll)ans * C(tot, uf.size(u)) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 4e5 + 10, mod = 1e9 + 7;\n\nint n, cntv, cnte, ans, oth, root, fac[maxn], ifac[maxn], par[maxn], dep[maxn], siz[maxn], flag;\nbool vis[maxn], on_cyc[maxn], isr[maxn][2], viss[maxn];\nstd::vector<int> dag[maxn][2], cur;\n\nstruct edge {\n\tint to, id;\n\n\tedge() {}\n\tedge(int to, int id): to(to), id(id) {}\n};\n\nstd::vector<edge> g[maxn];\n\ninline int pow_mod(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * x * y % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < maxn; ++i) {\n\t\tfac[i] = (long long) i * fac[i - 1] % mod;\n\t}\n\tifac[maxn - 1] = pow_mod(fac[maxn - 1], mod - 2);\n\tfor (int i = maxn - 1; i; --i) {\n\t\tifac[i - 1] = (long long) i * ifac[i] % mod;\n\t}\n\treturn;\n}\n\ninline int C(int n, int m) {\n\treturn n < m || m < 0 ? 0 : (long long) fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\ninline void dfs1(int u, int p = -1, int d = 0) {\n\tcur.push_back(u);\n\tvis[u] = 1;\n\tpar[u] = p;\n\tdep[u] = d;\n\t++cntv;\n\tcnte += (int) g[u].size();\n\tfor (auto &e: g[u]) {\n\t\tint v = e.to;\n\t\tif(v == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[v]) {\n\t\t\troot = dep[u] < dep[v] ? v : u;\n\t\t\toth = u + v - root;\n\t\t}\n\t\telse {\n\t\t\tdfs1(v, u, d + 1);\n\t\t}\n\t}\n\treturn;\n}\n\ninline void dfs2(int u, int p = -1) {\n\tviss[u] = 1;\n\tpar[u] = p;\n\tfor (auto &e: g[u]) {\n\t\tint v = e.to;\n\t\tif(!viss[v]) {\n\t\t\tdfs2(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\ninline int DP(int u) {\n\tsiz[u] = 1;\n\tint ret = 1;\n\tfor (int &v: dag[u][flag]) {\n\t\tret = (long long) DP(v) * ret % mod;\n\t\tsiz[u] += siz[v];\n\t\tret = (long long) ret * ifac[siz[v]] % mod;\n\t}\n\treturn (long long) ret * fac[siz[u] - 1] % mod;\n}\n\nint main() {\n\tprepare();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x;\n\t\ty += n - 1;\n\t\tg[x].push_back(edge(y, i));\n\t\tg[y].push_back(edge(x, i));\n\t}\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tisr[i][0] = isr[i][1] = 1;\n\t}\n\tans = fac[n << 1];\n\tfor (int i = 0; i < (n << 1); ++i) {\n\t\tif(!vis[i]) {\n\t\t\tcur.clear();\n\t\t\tcntv = cnte = 0;\n\t\t\tdfs1(i);\n\t\t\tif((cntv << 1) != cnte) {\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t#ifdef DEBUG\n\t\t\tprintf(\"%d %d\\n\", cntv, cnte);\n\t\t\t#endif\n\t\t\tflag = 0;\n\t\t\tint ban;\n\t\t\tfor (int u = root; u != oth; u = par[u]) {\n\t\t\t\ton_cyc[u] = 1;\n\t\t\t}\n\t\t\ton_cyc[oth] = 1;\n\t\t\tfor (auto &e: g[root]) {\n\t\t\t\tif(e.to == oth) {\n\t\t\t\t\tban = e.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u = root; ; ) {\n\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\tif(on_cyc[v] && i != ban) {\n\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tban = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u == root) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs2(root);\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(!on_cyc[u]) {\n\t\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\t\tif(v == par[u]) {\n\t\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res1 = 1;\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(isr[u][flag]) {\n\t\t\t\t\tres1 = (long long) DP(u) * res1 % mod * ifac[siz[u]] % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflag = 1;\n\t\t\tfor (auto &e: g[root]) {\n\t\t\t\tif(on_cyc[e.to] && e.id != ban) {\n\t\t\t\t\tban = e.id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int u = root; ; ) {\n\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\tif(on_cyc[v] && i != ban) {\n\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu = v;\n\t\t\t\t\t\tban = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u == root) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs2(root);\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(!on_cyc[u]) {\n\t\t\t\t\tfor (auto &e: g[u]) {\n\t\t\t\t\t\tint v = e.to, i = e.id;\n\t\t\t\t\t\tif(v == par[u]) {\n\t\t\t\t\t\t\tfor (auto &ee: g[u]) {\n\t\t\t\t\t\t\t\tif(ee.to < v) {\n\t\t\t\t\t\t\t\t\tdag[i][flag].push_back(ee.id);\n\t\t\t\t\t\t\t\t\tisr[ee.id][flag] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res2 = 1;\n\t\t\tfor (int &u: cur) {\n\t\t\t\tif(isr[u][flag]) {\n\t\t\t\t\tres2 = (long long) DP(u) * res2 % mod * ifac[siz[u]] % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = (long long) (res1 + res2) * ans % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ll long long\n#define N 200005\nusing namespace std;\nvector<int> e[N];\nint vis[N],du[N],fa[N],sz[N];\nint q[N],t,nq[N],n;\nll power(ll x,ll y){\n\tll s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nll solve(int rt){\n\tt=1; q[1]=rt; vis[rt]=1;\n\tfor (int h=1;h<=t;h++){\n\t\tint x=q[h]; du[x]=0;\n\t\tsz[x]=1; fa[x]=0;\n\t\tfor (int i=0;i<e[x].size();i++){\n\t\t\tint to=e[x][i];\n\t\t\tif (!vis[to]){\n\t\t\t\tq[++t]=to;\n\t\t\t\tvis[to]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint ecnt=0;\n\tfor (int i=1;i<=t;i++)\n\t\tfor (int j=0;j<e[q[i]].size();j++)\n\t\t\tdu[e[q[i]][j]]++,ecnt++;\n\tif (ecnt/2!=t) return 0;\n\tint nt=0;\n\tfor (int i=1;i<=t;i++)\n\t\tif (du[q[i]]==1) nq[++nt]=q[i];\n\tfor (int h=1;h<=nt;h++){\n\t\tint x=nq[h];\n\t\tfor (int i=0;i<e[x].size();i++){\n\t\t\tint to=e[x][i];\n\t\t\tif (--du[to]){\n\t\t\t\tfa[x]=to;\n\t\t\t\tif (du[to]==1)\n\t\t\t\t\tnq[++nt]=to;\n\t\t\t\telse rt=to;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x=rt;;){\n\t\tfor (int i=0;i<e[x].size();i++)\n\t\t\tif (du[e[x][i]]>1&&fa[e[x][i]]!=x){\n\t\t\t\tfa[x]=e[x][i]; x=e[x][i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (x==rt) break;\n\t}\n\tll ans=1;\n\tfor (int i=1;i<=nt;i++){\n\t\tint x=nq[i];\n\t\tans=ans*sz[x]%mo;\n\t\tif (x<fa[fa[x]]) sz[fa[x]]+=sz[x];\n\t}\n\tfor (int x=rt;;){\n\t\tif (x>fa[fa[x]]){\n\t\t\trt=fa[x];\n\t\t\tbreak;\n\t\t}\n\t\tx=fa[x];\n\t\tif (x==rt) return 0;\n\t}\n\tfor (int x=rt;;){\n\t\tans=ans*sz[x]%mo;\n\t\tif (x<fa[fa[x]]) sz[fa[x]]+=sz[x];\n\t\tx=fa[x]; if (x==rt) break;\n\t}\n\treturn power(ans,mo-2);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n*2;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].push_back(y+n);\n\t\te[y+n].push_back(x);\n\t}\n\tll ans=1;\n\tfor (int i=1;i<=n*2;i++)\n\t\tans=ans*i%mo;\n\tfor (int x=1;x<=n*2;x++)\n\t\tif (!vis[x]){\n\t\t\tll s=solve(x);\n\t\t\tfor (int i=1;i<=t;i++){\n\t\t\t\tint x=q[i]; vis[x]=0;\n\t\t\t\treverse(e[x].begin(),e[x].end());\n\t\t\t}\n\t\t\tans=ans*(s+solve(x))%mo;\n\t\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nint n,cnt=0,num=0,B=0;\nvi x,y,ax,ay,vis,b,c,d,used;\nvl dp;\nvvi g,G;\nvvp X,Y;\n\nint dfs(int v,int w){\n\tb.push_back(v);\n\tvis[v]++;cnt++;\n\tif(!ax[x[v]]) num++,ax[x[v]]=1;\n\tif(!ay[y[v]]) num++,ay[y[v]]=1;\n\tint t=-1;\n\tfor(auto u:g[v]) if(u!=-1&&u!=w){\n\t\tif(vis[u]&&!B){\n\t\t\tint I=d.size()-1;\n\t\t\tpip p={{x[u],y[u]},u};\n\t\t\twhile(I>=0&&d[I]!=u){\n\t\t\t\tint u_=d[I--];\n\t\t\t\tp=min(p,{{x[u_],y[u_]},u_});\n\t\t\t}\n\t\t\tt=p.second;\n\t\t\tB=1;\n\t\t}\n\t\telse if(!vis[u]){\n\t\t\td.push_back(u);\n\t\t\tint t_=dfs(u,v);\n\t\t\tif(t_!=-1) t=t_;\n\t\t\td.pop_back();\n\t\t}\n\t}\n\treturn t;\n}\n\nvoid DFS(int v,int I){\n\tint u=g[v][I];\n\tif(u==-1||c[u]!=-1) return;\n\tc[u]=1-I%2;\n\tfor(int i=0;i<4;i++){\n\t\tint w=g[u][i];\n\t\tif(w!=-1&&c[w]==-1) DFS(u,i);\n\t}\n}\n\npll Rec(int v){\n\tll res=1,S=0;\n\tfor(auto u:G[v]){\n\t\tpll p=Rec(u);\n\t\tll T=p.second;\n\t\tres=Div(res*p.first%mod,F[T]);\n\t\tS+=T;\n\t}\n\t(res*=F[S])%=mod;\n\treturn {res,S+1};\n}\n\nll f(int v,int t){\n\tc[v]=t;\n\tfor(int i=0;i<4;i++) DFS(v,i%2*2+abs(i/2-t));\n\tfor(auto i:b){\n\t\tint u=g[i][c[i]];\n\t\twhile(u!=-1){\n\t\t\tG[i].push_back(u);\n\t\t\tused[u]=1;\n\t\t\tu=g[u][c[i]];\n\t\t}\n\t}\n\tfor(auto i:b) if(!used[i]) G[n].push_back(i);\n\tll res=Rec(n).first;\n\tfor(auto i:b){\n\t\tc[i]=-1;\n\t\tused[i]=0;\n\t\tG[i].clear();\n\t}\n\tG[n].clear();\n\treturn res;\n}\n\nint main(){\n\tInit();\n\tcin>>n;\n\tn*=2;\n\tx=y=ax=ay=vis=used=vi(n);\n\tc=vi(n,-1);\n\tX=Y=vvp(n);\n\tg=vvi(n,vi(4,-1));\n\tG=vvi(n+1);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tx[i]--;y[i]--;\n\t\tX[x[i]].push_back({y[i],i});\n\t\tY[y[i]].push_back({x[i],i});\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tsort(X[i].begin(),X[i].end());\n\t\tsort(Y[i].begin(),Y[i].end());\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<X[i].size();j++){\n\t\t\tint u=X[i][j-1].second,v=X[i][j].second;\n\t\t\tg[u][3]=v;g[v][1]=u;\n\t\t}\n\t\tfor(int j=1;j<Y[i].size();j++){\n\t\t\tint u=Y[i][j-1].second,v=Y[i][j].second;\n\t\t\tg[u][2]=v;g[v][0]=u;\n\t\t}\n\t}\n\tll res=F[n];\n\tfor(int i=0;i<n;i++) if(!vis[i]){\n\t\tcnt=0;num=0;B=0;\n\t\tb.clear();d.clear();\n\t\td.push_back(i);\n\t\tint v=dfs(i,-1);\n\t\td.pop_back();\n\t\tres=(cnt==num?Div((f(v,0)+f(v,1))%mod*res%mod,F[cnt]):0);\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 400005\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\nint n, m, vis[N], fac[N], inv[N];\nint tot = 1, fir[N], nxt[N << 1], to[N << 1];\nvector<int> G[N];\n\ninline void addE(int u, int v) {\n    nxt[++tot] = fir[u], fir[u] = tot, to[tot] = v;\n}\n\nint now[N], top, deg[N], fa[N], sz[N];\n\nvoid predfs(int u, int p, int &e, int &x, int &y) {\n    now[++top] = u, vis[u] = 1;\n    for (int i = fir[u], v; i; i = nxt[i], ++e) {\n        v = to[i]; if (v == p) continue;\n        if (vis[v]) x = u, y = v;\n        else predfs(v, u, e, x, y);\n    }\n}\n\nvoid dfs(int u, int p, int b) {\n    fa[u] = p;\n    for (int i = fir[u]; i; i = nxt[i])\n        if (to[i] != p && to[i] != b)\n            dfs(to[i], u, b);\n}\n\nint getsz(int u, int p) {\n    int res = 1; sz[u] = 1;\n    for (int i = 0, v; i < (int) G[u].size(); ++i) {\n        v = G[u][i];\n        if (v == p) continue;\n        res = 1ll * res * getsz(v, u) % Mod;\n        sz[u] += sz[v];\n    } res = 1ll * res * inv[sz[u]] % Mod;\n    return res;\n}\n\ninline int solve(int x, int y) {\n//    cout << x << \" # \" << y << endl;\n    dfs(x, y, x);\n//    for (int i = 1; i <= top; ++i)\n//        cout << now[i] << \" \" << fa[now[i]] << endl;\n    for (int i = 1; i <= top; ++i)\n        G[now[i]].clear(), deg[now[i]] = 0;\n    for (int i = 1; i <= top; ++i) {\n        int u = now[i];\n        for (int j = fir[u]; j; j = nxt[j])\n            if (to[j] < fa[u]) G[u].push_back(to[j]), ++deg[to[j]];//, cout << u << \" \" << to[j] << endl;\n    } int res = 1;\n    for (int i = 1; i <= top; ++i)\n        if (!deg[now[i]]) res = 1ll * res * getsz(now[i], now[i]) % Mod;\n    return res;\n}\n\nint main() {\n    cin >> n, m = n << 1;\n    for (int i = 1, u, v; i <= m; ++i)\n        scanf(\"%d%d\", &u, &v),\n        addE(u, v + n), addE(v + n, u);\n\n    fac[0] = fac[1] = inv[1] = 1;\n    for (int i = 2; i <= m; ++i) {\n        fac[i] = 1ll * fac[i - 1] * i % Mod;\n        inv[i] = 1ll * inv[Mod % i] * (Mod - Mod / i) % Mod;\n    }\n\n    int ans = fac[m];\n\n    for (int u = 1; u <= m; ++u) {\n        if (vis[u]) continue;\n        int num, x, y;\n        top = num = x = y = 0;\n        predfs(u, 0, num, x, y);\n        if (num != top * 2) \n            return puts(\"0\"), 0;\n        ans = 1ll * ans * (solve(x, y) + solve(y, x)) % Mod;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\n\nconst int N = 200005; \n\nconst long long mod = 1000000007; \n\n\n\nusing namespace std;\n\n\n\nint n, T; \n\n\n\nbool oncir[N], vis[N]; \n\nint num, sum, cir[N], cur[N]; \n\n\n\nint tp, sta[N]; \n\nbool insta[N]; \n\n\n\nint match[N], ind[N], siz[N]; \n\nlong long f[N]; \n\n\n\nvector< int > G[N]; \n\nvector< int > S[N]; \n\n\n\nlong long fac[N], inv[N]; \n\n\n\nlong long Pow(long long a, long long e) {\n\n\tlong long ret=1, cnt=a%mod;\n\n\twhile(e) {\n\n\t\tif(e & 1) ret = ret * cnt % mod;\n\n\t\tcnt = cnt * cnt % mod; \n\n\t\te >>= 1; \n\n\t} \n\n\treturn ret; \n\n}\n\n\n\nvoid prepare() {\n\n\tfac[1] = 1; \n\n\tfor(int i=2; i<=n; ++i) fac[i] = fac[i-1] * i % mod; \n\n\tinv[n] = Pow(fac[n], mod-2); \n\n\tfor(int i=n-1; i>=0; --i) inv[i] = inv[i+1] * (i+1) % mod;  \n\n}\n\n\n\nlong long C(int n, int m) {\n\n\treturn fac[n] * inv[n-m] % mod * inv[m] % mod; \n\n}\n\n\n\nvoid dfs_Circle(int u, int f) {\n\n\tif(insta[u]) {\n\n\t\tint now; \n\n\t\tdo {\n\n\t\t\tnow = sta[tp--];\n\n\t\t\tinsta[now] = 0; \n\n\t\t\tcir[++num] = now; \n\n\t\t\toncir[now] = 1; \n\n\t\t}while(now != u); \n\n\t\t++T; \n\n\t\treturn ; \n\n\t}\n\n\tvis[u] = 1; \n\n\tinsta[u] = 1; \n\n\tsta[++tp] = u; \n\n\tcur[++sum] = u; \n\n\tint size = G[u].size();  \n\n\tfor(int k=0; k<size; ++k) {\n\t\tint v = G[u][k]; \n\t\tif(oncir[v] || v == f) continue; \n\n\t\tdfs_Circle(v, u); \n\n\t}\n\tif(insta[u]) {\n\t\tsta[tp--] = 0;\n\n\t\tinsta[u] = 0;  \n\t}\n\n}\n\n\n\nvoid dfs_Tree(int u, int f) {\n\n\tmatch[u] = f; \n\n\tint size = G[u].size();  \n\n\tfor(int k=0; k<size; ++k) {\n\t\tint v = G[u][k]; \n\n\t\tif(oncir[v] || v == f) continue; \n\n\t\tdfs_Tree(v, u); \n\n\t}\n\n}\n\n\n\nvoid dfs_calc(int u) {\n\n\tf[u] = 1; \n\n\tsiz[u] = 0; \n\n\tint size = S[u].size(); \n\tfor(int k=0; k<size; ++k) {\n\t\tint v = S[u][k]; \n\n\t\tdfs_calc(v);\n\n\t\tsiz[u] += siz[v]; \n\n\t\tf[u] = 1ll * f[u] * f[v] % mod * C(siz[u], siz[v]) % mod; \n\n\t}\n\n\t++siz[u]; \n\n}\n\n\n\nlong long calc() {\n\n\tfor(int i=1; i<=sum; ++i) ind[cur[i]] = 0; \n\n\tfor(int i=1; i<=sum; ++i) {\n\n\t\tint u = cur[i];\n\n\t\tS[u].clear();\n\t\tint size = G[u].size();  \n\n\t\tfor(int k=0; k<size; ++k) {\n\t\t\tint v = G[u][k]; \n\n\t\t\tif(v == match[u]) break; \n\n\t\t\tS[u].push_back(v); \n\n\t\t\t++ind[v]; \n\n\t\t}\n\n\t}\n\n\tS[0].clear();\n\n\tfor(int i=1; i<=sum; ++i) \n\n\t\tif(!ind[cur[i]]) S[0].push_back(cur[i]);\n\n\tdfs_calc(0);\n\n\treturn f[0];  \n\n}\n\n\n\nint main() {\n\n\t\n\n\tint u, v; \n\n\t\n\n\tint psum=0; \n\n\tlong long ans = 1; \n\n\t\n\n\tcin >> n; \n\n\tfor(int i=1; i<=(n<<1); ++i) {\n\n\t\tcin >> u >> v;  \n\n\t\tG[u].push_back(v+n); \n\n\t\tG[v+n].push_back(u); \n\n\t}\n\n\t\n\n\tn <<= 1; \n\n\tfor(int i=1; i<=n; ++i) sort(G[i].begin(), G[i].end()); \n\n\t\n\n\tprepare(); \n\n\t\n\n\tfor(int i=1; i<=n; ++i) {\n\n\t\t\n\n\t\tif(vis[i]) continue; \n\n\t\t\n\n\t\tT = sum = num = tp = 0; \n\n\t\tdfs_Circle(i, 0); \n\n\t\t\n\n\t\tif(T != 1) {\n\n\t\t\tans = 0; \n\n\t\t\tbreak; \n\n\t\t}\n\n\t\t\n\n\t\tfor(int j=1; j<=num; ++j) dfs_Tree(cir[j], 0); \n\n\t\t\n\n\t\tlong long tmp = 0; \n\n\t\t\n\n\t\tfor(int j=2; j<=num; ++j) match[cir[j]] = cir[j-1]; \n\n\t\tmatch[cir[1]] = cir[num]; \n\n\t\ttmp += calc(); \n\n\t\t\n\n\t\tfor(int j=1; j<num; ++j)  match[cir[j]] = cir[j+1];\n\n\t\tmatch[cir[num]] = cir[1];\n\n\t\ttmp += calc(); \n\n\t\t\n\n\t\tpsum += sum; \n\n\t\tans = 1ll * ans * tmp % mod * C(psum, sum) % mod; \n\n\t\t\n\n\t}\n\n\t\n\n\tcout << ans << endl; \n\n\t\n\n\treturn 0; \n\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n\n#define MAX_INT 2147483647\n#define MOD 1000000007L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nint n;\nvector<vector<int>> g;\nvector<vector<int>> gg;\nvector<int> z;\n\nint nn = 0;\nint mm = 0;\nvector<int> comp;\nvector<int> st;\nvector<int> cycle;\nvector<int> des;\nvector<long> dp;\n\nvoid dfs(int x, int p) {\n    if (z[x] == 2) return;\n    if (z[x] == 1) {\n        if (cycle.size() == 0) {\n            int i = st.size() - 1;\n            while (st[i] != x) {\n                cycle.push_back(st[i]);\n                i--;\n            }\n            cycle.push_back(x);\n        }\n        return;\n    }\n    st.push_back(x);\n    comp.push_back(x);\n    z[x] = 1;\n    nn++;\n    for (int y : g[x]) {\n        mm++;\n        if (y != p) {\n            dfs(y, x);\n        }\n    }\n    z[x] = 2;\n    st.pop_back();\n}\n\nvoid dfs2(int x) {\n    z[x] = 3;\n    for (int y : g[x]) {\n        if (z[y] != 3) {\n            des[y] = x;\n            dfs2(y);\n        }\n    }\n}\n\nvector<long> fact;\nvector<long> inv_fact;\n\nlong mult(long a, long b) {\n    return (a * b) % MOD;\n}\n\nlong calc_c(int n, int k) {\n    return mult(mult(fact[n], inv_fact[k]), inv_fact[n - k]);\n}\n\nlong pow(long a, int pow) {\n    long res = 1;\n    while (pow > 0) {\n        if (pow & 1) {\n            res = mult(res, a);\n        }\n        a = mult(a, a);\n        pow /= 2;\n    }\n    return res;\n}\n\nint dfs3(int x, int p) {\n    int s = 0;\n    dp[x] = 1;\n    for (int y : gg[x]) {\n        if (y != p) {\n            int ss = dfs3(y, x);\n            s += ss;\n            dp[x] = mult(dp[x], dp[y]);\n            dp[x] = mult(dp[x], calc_c(s, ss));\n        }\n    }\n    return s + 1;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    cin >> n;\n    n *= 2;\n\n    fact.resize(n + 1);\n    inv_fact.resize(n + 1);\n    fact[0] = inv_fact[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv_fact[i] = pow(fact[i], MOD - 2);\n//        cout << fact[i] << \" \" << inv_fact[i] << \"\\n\";\n    }\n\n    g.resize(n);\n    gg.resize(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        g[x].push_back(y + n / 2);\n        g[y + n / 2].push_back(x);\n    }\n\n    long res = 1;\n    des.resize(n);\n    z.resize(n);\n    vector<int> deg(n);\n    dp.resize(n);\n    int q = 0;\n    for (int i = 0; i < n; i++) {\n        if (z[i]) continue;\n        cycle.resize(0);\n        comp.resize(0);\n        nn = 0;\n        mm = 0;\n        dfs(i, -1);\n//        cerr << nn << \" \" << mm << \"\\n\";\n        mm /= 2;\n        if (mm != nn) {\n            cout << \"0\\n\";\n            return 0;\n        }\n//        for (auto item : comp) {\n//            cerr << item << \" \";\n//        }\n//        cerr << \"\\n\";\n//        for (auto item : cycle) {\n//            cerr << item << \" \";\n//        }\n//        cerr << \" cc\\n\";\n\n        long ss = 0;\n\n        for (int t = 0; t < 2; t++) {\n            long pp = 1;\n            for (int i = 0; i < cycle.size(); i++) {\n                des[cycle[i]] = cycle[(i + 1) % cycle.size()];\n                z[cycle[i]] = 3;\n            }\n            for (int v : cycle) {\n                dfs2(v);\n            }\n            for (int v : comp) {\n                deg[v] = 0;\n            }\n\n//            for (auto item : des) {\n//                cerr << item << \" \";\n//            }\n//            cerr << \" des\\n\";\n\n            for (int v : comp) {\n                gg[v].resize(0);\n                for (int u : g[v]) {\n                    if (u < des[v]) {\n//                        cerr << u << \"<-\" << v << \"\\n\";\n                        gg[v].push_back(u);\n                        deg[u]++;\n                    }\n                }\n            }\n//            for (auto item : deg) {\n//                cerr << item << \" \";\n//            }\n//            cerr << \" deg\\n\";\n            int q = 0;\n            for (int v : comp) {\n                if (deg[v] == 0) {\n                    int x = dfs3(v, -1);\n                    q += x;\n                    pp = mult(pp, dp[v]);\n                    pp = mult(pp, calc_c(q, x));\n//                    cerr << v << \" \" << x << \"!\\n\";\n                }\n            }\n//            for (auto item : dp) {\n//                cerr << item << \" \";\n//            }\n//            cerr << \" dp\\n\";\n            ss = (ss + pp) % MOD;\n//            cerr << pp << \" \" << ss << \"\\n\";\n            std::reverse(cycle.begin(), cycle.end());\n        }\n        q += nn;\n        res = mult(res, ss);\n        res = mult(res, calc_c(q, nn));\n    }\n    cout << res << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll N = 200005, mod = 1e9+7;\n\nll n, ans = 1, fac[N] = {1}, fi[N] = {1};\nll vis[N], wh[N], sz[N], cv, ms;\nvector<ll> adj[N], tree[N], cur, cyc;\nbool done[N], onc[N];\n\nll calc (ll A, ll B) {\n\tif(!B) return 1;\n\tll R = calc(A, B/2);\n\tR = (R * R) % mod;\n\tif(B%2) R = (R * A) % mod;\n\treturn R;\n}\n\nll comb (ll A, ll B) {\n\treturn fac[A] * fi[B] % mod * fi[A-B] % mod;\n}\n\nll multicomb (vector<ll> &V) {\n\tll R = 1, C = 0;\n\tfor(auto &T : V) {\n\t\tC += T;\n\t}\n\tfor(auto &T : V) {\n\t\tR = (R * comb(C, T)) % mod;\n\t\tC -= T;\n\t}\n\treturn R;\n}\n\nll dfs1 (ll I) {\n\tms += adj[I].size();\n\tcur.push_back(I);\n\tdone[I] = true;\n\tvis[I] = cv;\n\tfor(auto &T : adj[I]) {\n\t\tif(vis[T] != cv) dfs1(T);\n\t}\n}\n\nll dfs2 (ll I, ll P) {\n\tvis[I] = cv;\n\tfor(auto &T : adj[I]) {\n\t\tll X;\n\t\tif(vis[T] != cv) {\n\t\t\tX = dfs2(T, I);\n\t\t\tif(X == -1) return -1;\n\t\t\telse if(X) {\n\t\t\t\tcyc.push_back(I);\n\t\t\t\tonc[I] = true;\n\t\t\t\treturn (X == I ? -1 : X);\n\t\t\t}\n\t\t}\n\t\telse if(T != P) {\n\t\t\tcyc.push_back(I);\n\t\t\tonc[I] = true;\n\t\t\treturn T;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid dfs3 (ll I) {\n\tvis[I] = cv;\n\tfor(auto &T : adj[I]) {\n\t\tif(onc[T] || vis[T] == cv) continue;\n\t\twh[T] = I;\n\t\tdfs3(T);\n\t}\n}\n\nll dfs4 (ll I) {\n\tsz[I] = 1;\n\tvector<ll> S;\n\tll R = 1;\n\tfor(auto &T : tree[I]) {\n\t\tR = (R * dfs4(T)) % mod;\n\t\tS.push_back(sz[T]);\n\t\tsz[I] += sz[T];\n\t}\n\treturn (R * multicomb(S)) % mod;\n}\n\nll subsol () {\n\tcv++;\n\tfor(auto &C : cur) {\n\t\ttree[C].clear();\n\t\tfor(auto &T : adj[C]) {\n\t\t\tif(T < wh[C]) {\n\t\t\t\tvis[T] = cv;\n\t\t\t\ttree[C].push_back(T);\n\t\t\t}\n\t\t}\n\t}\n\ttree[0].clear();\n\tfor(auto &C : cur) {\n\t\tif(vis[C] == cv) continue;\n\t\ttree[0].push_back(C);\n\t}\n\treturn dfs4(0);\n}\n\nll solve (ll I) {\n\tcv++;\n\tcur.clear();\n\tms = 0;\n\tdfs1(I);\n\tif(ms != 2*cur.size()) {\n\t\tputs(\"0\");\n\t\texit(0);\n\t}\n\tcv++;\n\tcyc.clear();\n\tdfs2(I, 0);\n\tcv++;\n\tfor(auto &C : cyc) {\n\t\tdfs3(C);\n\t}\n\tll R = 0, S = (ll)cyc.size();\n\tfor(ll i=0;i<S;i++) {\n\t\twh[cyc[i]] = cyc[(i+1)%S];\n\t}\n\tR += subsol();\n\tfor(ll i=0;i<S;i++) {\n\t\twh[cyc[(i+1)%S]] = cyc[i];\n\t}\n\tR += subsol();\n\treturn R % mod;\n}\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tn *= 2;\n\tfor(ll i=1;i<=n;i++) {\n\t\tfac[i] = (fac[i-1] * i) % mod;\n\t\tfi[i] = calc(fac[i], mod-2);\n\t}\n\tfor(ll i=1;i<=n;i++) {\n\t\tll A, B;\n\t\tscanf(\"%lld%lld\",&A,&B);\n\t\tB += n/2;\n\t\tadj[A].push_back(B);\n\t\tadj[B].push_back(A);\n\t}\n\tvector<ll> S;\n\tfor(ll i=1;i<=n;i++) {\n\t\tif(done[i]) continue;\n\t\tans = (ans * solve(i)) % mod;\n\t\tS.push_back((ll)cur.size());\n\t}\n\tprintf(\"%lld\\n\", (ans * multicomb(S)) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\ntypedef long long lint;\nconst int N=1e5+5;\nconst int mod=1e9+7;\nint n;\n\nnamespace utils{\n\ttemplate <class T> inline void apx(T &x,const T y){\n\t\tx<y?x=y:0;\n\t}\n\ttemplate <class T> inline void apn(T &x,const T y){\n\t\tx>y?x=y:0;\n\t}\n\tinline char get_c(){\n\t\tstatic char buf[20000],*h,*t;\n\t\tif(h==t){\n\t\t\tt=(h=buf)+fread(buf,1,20000,stdin);\n\t\t\tif(h==t) return EOF;\n\t\t}\n\t\treturn *h++;\n\t}\n\tinline int nxi(FILE *fd=stdin){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile((c=get_c())>'9'||c<'0');\n\t\twhile(x=x*10-48+c,(c=get_c())>='0'&&c<='9');\n\t\treturn x;\n\t}\n}\nusing namespace utils;\n\ntemplate <class T>\ninline int fpow(int x,T t){\n\tint ans=1;\n\tfor(; t; x=(lint)x*x%mod,t>>=1){\n\t\tif(t&1) ans=(lint)ans*x%mod;\n\t}\n\treturn ans;\n}\n\nnamespace G{\n\tint rt,ans,cnt,fir[N<<1];\n\tint cir_dep,dep[N<<1];\n\tint eg_cnt,nd_cnt;\n\tbool vis[N<<1];\n\tstd::vector <int> cir_l;\n\tstruct edge{\n\t\tint to,nx;\n\t}eg[N<<2];\n\n\tinline void add(const int a,const int b){\n\t\teg[++cnt]=(edge){b,fir[a]};\n\t\tfir[a]=cnt;\n\t}\n\n\tbool dfs_cir(const int x,const int fa){\n\t\t++nd_cnt;\n\t\tvis[x]=1;\n\t\tbool on_cir=0;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tconst int y=eg[i].to;\n\t\t\t++eg_cnt;\n\t\t\tif(y==fa) continue;\n\t\t\tif(vis[y]){\n\t\t\t\tif(~cir_dep) continue;\n\t\t\t\tcir_dep=dep[y];\n\t\t\t\ton_cir=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\ton_cir|=dfs_cir(y,x);\n\t\t\t}\n\t\t}\n\t\ton_cir&=dep[x]>=cir_dep;\n\t\tif(on_cir) cir_l.push_back(x);\n\t\treturn on_cir;\n\t}\n\n\tint dfs_tot(const int x,const int fa){\n\t\tint sz=1;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tconst int y=eg[i].to;\n\t\t\tif(y==rt&&y!=fa) assert(y>fa);\n\t\t\tif(y==fa||y==rt) continue;\n\t\t\tif(y<fa) sz+=dfs_tot(y,x);\n\t\t\telse dfs_tot(y,x);\n\t\t}\n\t\tans=(lint)ans*sz%mod;\n\t\treturn sz;\n\t}\n\n\tint solve(const int x){\n\t\tcir_l.clear();\n\t\teg_cnt=nd_cnt=0;\n\t\tcir_dep=-1;\n\t\tdfs_cir(x,0);\n\t\tif(eg_cnt!=nd_cnt<<1) return 0;\n\t\tconst int sz=cir_l.size();\n\t\tassert(sz);\n\t\tint r=0,res=0;\n\t\tfor(int i=1; i<(int)cir_l.size(); ++i){\n\t\t\tif(cir_l[i]<cir_l[r]) r=i;\n\t\t}\n\t\t{\n\t\t\tint f,x;\n\t\t\tif((f=r-1)<0) f=sz-1;\n\t\t\tif((x=f-1)<0) x=sz-1;\n\t\t\tans=1;\n\t\t\tG::rt=cir_l[x];\n\t\t\tdfs_tot(cir_l[x],cir_l[f]);\n\t\t\tres=(res+fpow(ans,mod-2))%mod;\n\t\t}\n\t\t{\n\t\t\tint f,x;\n\t\t\tif((f=r+1)==sz) f=0;\n\t\t\tif((x=f+1)==sz) x=0;\n\t\t\tans=1;\n\t\t\tG::rt=cir_l[x];\n\t\t\tdfs_tot(cir_l[x],cir_l[f]);\n\t\t\tres=(res+fpow(ans,mod-2))%mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n\tn=nxi();\n\tfor(int i=1; i<=n<<1; ++i){\n\t\tint x=nxi(),y=nxi();\n\t\tG::add(x,y+n);\n\t\tG::add(y+n,x);\n\t}\n\tint res=1;\n\tfor(int i=1; res&&i<=n; ++i){\n\t\tif(!G::vis[i]) res=(lint)res*G::solve(i)%mod;\n\t}\n\tfor(int i=1; i<=n<<1; ++i){\n\t\tres=(lint)res*i%mod;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=400010;\nconst int ha=1e9+7;\nstruct Edge{int to,next;} e[N<<1],et[N<<1];\nint h[N],ht[N],esum=0,tsum=0,n,cmt=0;\nint gay[N],out[N],sz[N];\nbool done[N],inc[N],flag;\nvector<int> crl,vertix;\nstack<int> s;\nint fac[N];\n\nint Pow(int a,int b)\n{\n    int ans=1;\n    for(;b;b>>=1,a=1ll*a*a%ha)\n        if(b&1) ans=1ll*ans*a%ha;\n    return ans;\n}\n\nvoid add_edge(int u,int v)\n{\n    e[++esum]={v,h[u]};h[u]=esum;\n    e[++esum]={u,h[v]};h[v]=esum;\n}\n\nvoid add_topo_edge(int u,int v)\n{\n    out[v]++;\n    et[++tsum].to=v;\n    et[tsum].next=ht[u];\n    ht[u]=tsum;\n}\n\nvoid findcrl(int u,int fa)\n{\n    vertix.push_back(u);\n    done[u]=1;s.push(u);\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa) continue;\n        if(!flag&&done[v])\n        {\n            while(s.top()!=v) crl.push_back(s.top()),inc[s.top()]=1,s.pop();\n            crl.push_back(v);inc[v]=1;s.pop();\n            flag=1;cmt++;return;\n        }\n        else if(!done[v]) cmt++,findcrl(v,u);\n    }\n    if(!s.empty()&&s.top()==u) s.pop();\n}\n\nvoid findgay(int u,int fa)\n{\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa||inc[v]) continue;\n        gay[v]=u;findgay(v,u);\n    }\n}\n\nvoid build_topo()\n{\n    for(int u : vertix)\n        for(int t=h[u];t;t=e[t].next)\n        {\n            int v=e[t].to;\n            if(v>=gay[u]) continue;\n            add_topo_edge(u,v);\n        }\n    for(int u : vertix)\n        if(!out[u]) add_topo_edge(0,u);\n    for(int u : vertix) out[u]=0;\n}\n\nvoid getsize(int u)\n{\n    sz[u]=1;\n    for(int t=ht[u];~t;t=et[t].next)\n    {\n        int v=et[t].to;\n        getsize(v);\n        sz[u]+=sz[v];\n    }\n    ht[u]=-1;\n}\n\nint getans()\n{\n    int prodsz=1;getsize(0);\n    for(int u : vertix)\n        prodsz=1ll*prodsz*sz[u]%ha;\n    return Pow(prodsz,ha-2);\n}\n\nint xi_jin_ping_is_good(int u)\n{\n    flag=0;cmt=0;findcrl(u,0);\n    if(vertix.size()!=cmt) return 0;\n    for(int u : crl) if(inc[u]) findgay(u,0);\n    for(int i=0;i<crl.size()-1;i++) gay[crl[i]]=crl[i+1];\n    gay[crl.back()]=crl[0];\n    tsum=-1;build_topo();\n    int res=getans();\n    for(int i=1;i<crl.size();i++) gay[crl[i]]=crl[i-1];\n    gay[crl[0]]=crl.back();\n    tsum=-1;build_topo();\n    res=(res+getans())%ha;\n    for(int u : vertix) inc[u]=0;\n    vertix.clear();crl.clear();\n    return res;\n}\n\nint main()\n{\n    memset(ht,-1,sizeof(ht));\n    int x,y,ans=1;\n    n=read()<<1;fac[0]=1;\n    for(int i=1;i<=n;i++)\n        fac[i]=1ll*fac[i-1]*i%ha;\n    for(int i=1;i<=n;i++)\n    {\n        x=read();y=read();\n        add_edge(x,y+n/2);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(done[i]) continue;\n        x=xi_jin_ping_is_good(i);\n        if(x==0) return puts(\"0\"),0;\n        ans=1ll*ans*x%ha;\n    }\n    ans=1ll*fac[n]*ans%ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=200010;\nconst int ha=1e9+7;\nstruct Edge{int to,next;} e[N<<1],et[N<<1];\nint h[N],ht[N],esum=0,tsum=0,n,cmt=0;\nint gay[N],out[N],sz[N];\nbool done[N],inc[N],flag;\nvector<int> crl,vertix;\nstack<int> s;\nint fac[N];\n\nint Pow(int a,int b)\n{\n    int ans=1;\n    for(;b;b>>=1,a=1ll*a*a%ha)\n        if(b&1) ans=1ll*ans*a%ha;\n    return ans;\n}\n\nvoid add_edge(int u,int v)\n{\n    e[++esum]={v,h[u]};h[u]=esum;\n    e[++esum]={u,h[v]};h[v]=esum;\n}\n\nvoid add_topo_edge(int u,int v)\n{\n    out[v]++;\n    et[++tsum].to=v;\n    et[tsum].next=ht[u];\n    ht[u]=tsum;\n}\n\nvoid findcrl(int u,int fa)\n{\n    vertix.push_back(u);\n    done[u]=1;s.push(u);\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa) continue;\n        if(!flag&&done[v])\n        {\n            while(s.top()!=v) crl.push_back(s.top()),inc[s.top()]=1,s.pop();\n            crl.push_back(v);inc[v]=1;s.pop();\n            flag=1;cmt++;return;\n        }\n        else if(!done[v]) cmt++,findcrl(v,u);\n    }\n    if(!s.empty()&&s.top()==u) s.pop();\n}\n\nvoid findgay(int u,int fa)\n{\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa||inc[v]) continue;\n        gay[v]=u;findgay(v,u);\n    }\n}\n\nvoid build_topo()\n{\n    for(int u : vertix)\n        for(int t=h[u];t;t=e[t].next)\n        {\n            int v=e[t].to;\n            if(v>=gay[u]) continue;\n            add_topo_edge(u,v);\n        }\n    for(int u : vertix)\n        if(!out[u]) add_topo_edge(0,u);\n    for(int u : vertix) out[u]=0;\n}\n\nvoid getsize(int u)\n{\n    sz[u]=1;\n    for(int t=ht[u];~t;t=et[t].next)\n    {\n        int v=et[t].to;\n        getsize(v);\n        sz[u]+=sz[v];\n    }\n    ht[u]=-1;\n}\n\nint getans()\n{\n    int prodsz=1;getsize(0);\n    for(int u : vertix)\n        prodsz=1ll*prodsz*sz[u]%ha;\n    return Pow(prodsz,ha-2);\n}\n\nint xi_jin_ping_is_good(int u)\n{\n    flag=0;cmt=0;findcrl(u,0);\n    if(vertix.size()!=cmt) return 0;\n    for(int u : crl) if(inc[u]) findgay(u,0);\n    for(int i=0;i<crl.size()-1;i++) gay[crl[i]]=crl[i+1];\n    gay[crl.back()]=crl[0];\n    build_topo();\n    int res=getans();\n    for(int i=1;i<crl.size();i++) gay[crl[i]]=crl[i-1];\n    gay[crl[0]]=crl.back();\n    tsum=0;build_topo();\n    res=(res+getans())%ha;\n    vertix.clear();\n    return res;\n}\n\nint main()\n{\n    memset(ht,-1,sizeof(ht));\n    int x,y,ans=1;\n    n=read()<<1;fac[0]=1;\n    for(int i=1;i<=n;i++)\n        fac[i]=1ll*fac[i-1]*i%ha;\n    for(int i=1;i<=n;i++)\n    {\n        x=read();y=read();\n        add_edge(x,y+n/2);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(done[i]) continue;\n        x=xi_jin_ping_is_good(i);\n        if(x==0) return puts(\"0\"),0;\n        ans=1ll*ans*x%ha;\n    }\n    ans=1ll*fac[n]*ans%ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int N = 305;\nlong long in[N][N];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) cin >> in[i][j];\n\n    long long res = 0;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j) {\n            int cnt = 0;\n            for (int k = 1; k <= n; ++k) {\n                if(i == k or j == k) continue;\n                if (in[i][k] + in[k][j] < in[i][j]) return !printf(\"-1\\n\");\n                if (in[i][k] + in[k][j] == in[i][j]) cnt++;\n            }\n            if (cnt == 0) res += in[i][j];\n        }\n\n    printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <functional>\nusing namespace std;\nconst int mod = 1000000007;\nvector<int> fact, inv, factinv;\nint subsolve(int n, vector<int> x, vector<int> y) {\n\tvector<set<int> > cx(n), cy(n);\n\tvector<vector<int> > vx(n), vy(n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tcx[x[i]].insert(i);\n\t\tcy[y[i]].insert(i);\n\t\tvx[x[i]].push_back(i);\n\t\tvy[y[i]].push_back(i);\n\t}\n\tqueue<int> que;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (cx[i].size() == 1) que.push(i);\n\t\tif (cy[i].size() == 1) que.push(i + n);\n\t}\n\tvector<int> part_col(2 * n, -1);\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tif (u < n) {\n\t\t\tint idx = *cx[u].begin();\n\t\t\tpart_col[idx] = 0;\n\t\t\tcy[y[idx]].erase(idx);\n\t\t\tif (cy[y[idx]].size() == 1) que.push(y[idx] + n);\n\t\t}\n\t\telse {\n\t\t\tint idx = *cy[u - n].begin();\n\t\t\tpart_col[idx] = 1;\n\t\t\tcx[x[idx]].erase(idx);\n\t\t\tif (cx[x[idx]].size() == 1) que.push(x[idx]);\n\t\t}\n\t}\n\tint src = -1;\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (part_col[i] == -1) {\n\t\t\tsrc = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < (src == -1 ? 1 : 2); i++) {\n\t\tvector<int> col = part_col;\n\t\tif (src != -1) {\n\t\t\tint cur = src, fl = 0;\n\t\t\twhile (col[cur] == -1) {\n\t\t\t\tcol[cur] = fl ^ i;\n\t\t\t\tif (fl == 0) {\n\t\t\t\t\tset<int>::iterator it = cx[x[cur]].begin();\n\t\t\t\t\twhile (*it == cur) it++;\n\t\t\t\t\tcur = *it;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tset<int>::iterator it = cy[y[cur]].begin();\n\t\t\t\t\twhile (*it == cur) it++;\n\t\t\t\t\tcur = *it;\n\t\t\t\t}\n\t\t\t\tfl ^= 1;\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > g(2 * n);\n\t\tvector<int> outdeg(2 * n);\n\t\tfor (int j = 0; j < 2 * n; j++) {\n\t\t\tif (col[j] == 0) {\n\t\t\t\tfor (int k : vx[x[j]]) {\n\t\t\t\t\tif (y[k] < y[j]) {\n\t\t\t\t\t\tg[j].push_back(k);\n\t\t\t\t\t\toutdeg[k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k : vy[y[j]]) {\n\t\t\t\t\tif (x[k] < x[j]) {\n\t\t\t\t\t\tg[j].push_back(k);\n\t\t\t\t\t\toutdeg[k]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> sub_sz(2 * n);\n\t\tfunction<int(int)> calc = [&](int pos) {\n\t\t\tint ret = 1;\n\t\t\tsub_sz[pos] = 1;\n\t\t\tfor (int j : g[pos]) {\n\t\t\t\tint res = calc(j);\n\t\t\t\tret = 1LL * ret * res % mod * factinv[sub_sz[j]] % mod;\n\t\t\t\tsub_sz[pos] += sub_sz[j];\n\t\t\t}\n\t\t\tret = 1LL * ret * fact[sub_sz[pos] - 1] % mod;\n\t\t\treturn ret;\n\t\t};\n\t\tint res = fact[2 * n];\n\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\tif (outdeg[i] == 0) {\n\t\t\t\tint subres = calc(i);\n\t\t\t\tres = 1LL * res * subres % mod * factinv[sub_sz[i]] % mod;\n\t\t\t}\n\t\t}\n\t\tret = (ret + res) % mod;\n\t}\n\treturn ret;\n}\nint solve(int n, vector<int> x, vector<int> y) {\n\tfact = vector<int>(2 * n + 1); fact[0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tinv = vector<int>(2 * n + 1); inv[1] = 1;\n\tfor (int i = 2; i <= 2 * n; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfactinv = vector<int>(2 * n + 1); factinv[0] = 1;\n\tfor (int i = 1; i <= 2 * n; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\tvector<vector<int> > g(2 * n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tg[x[i]].push_back(y[i] + n);\n\t\tg[y[i] + n].push_back(x[i]);\n\t}\n\tvector<int> col(2 * n, -1);\n\tint col_cnt = 0;\n\tfunction<void(int)> dfs = [&](int pos) {\n\t\tcol[pos] = col_cnt;\n\t\tfor (int i : g[pos]) {\n\t\t\tif (col[i] == -1) {\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (col[i] == -1) {\n\t\t\tdfs(i);\n\t\t\tcol_cnt++;\n\t\t}\n\t}\n\tvector<int> col_num(col_cnt), col_num2(col_cnt);\n\tvector<int> idx(2 * n);\n\tfor (int i = 0; i < 2; i++) {\n\t\tvector<int> pre(n, -1);\n\t\tfor (int j = i * n; j < i * n + n; j++) {\n\t\t\tif (pre[col[j]] != -1) idx[j] = idx[pre[col[j]]] + 1;\n\t\t\tpre[col[j]] = j;\n\t\t\tcol_num[col[j]]++;\n\t\t\tif (i == 0) col_num2[col[j]]++;\n\t\t}\n\t}\n\tvector<vector<int> > comps(col_cnt);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tcomps[col[x[i]]].push_back(i);\n\t}\n\tint ret = fact[2 * n];\n\tfor (int i = 0; i < col_cnt; i++) {\n\t\tif (col_num[i] != comps[i].size() || col_num2[i] * 2 != col_num[i]) return 0;\n\t\tvector<int> subx(col_num[i]), suby(col_num[i]);\n\t\tfor (int j = 0; j < col_num[i]; j++) {\n\t\t\tsubx[j] = idx[x[comps[i][j]]];\n\t\t\tsuby[j] = idx[y[comps[i][j]] + n];\n\t\t}\n\t\tint res = subsolve(comps[i].size() / 2, subx, suby);\n\t\tret = 1LL * ret * res % mod * factinv[col_num[i]] % mod;\n\t}\n\treturn ret;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<int> x(2 * n), y(2 * n);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--;\n\t\ty[i]--;\n\t}\n\tint ret = solve(n, x, y);\n\tcout << ret << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define mod 1000000007\n#define ll long long\nnamespace mymyth{\n\tll f[nn],rf[nn];\n\tll qpow(ll x,ll y)\n\t{\n\t\tll res=1;\n\t\twhile(y)\n\t\t{\n\t\t\tif(y&1) res=res*x%mod;\n\t\t\ty=y/2;x=x*x%mod;\n\t\t}return res;\n\t}\n\tvoid ini()\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod,rf[i]=qpow(f[i],mod-2);\n\t}\n};\nusing namespace mymyth;\n#define pii pair<int,int> \n#define mp make_pair\nvector<int> v[nn];\nint n;pii dot[nn];\n#define err {puts(\"0\");exit(0);}\nvoid adde(int x,int y)\n{\n\tv[x].push_back(y);\n\tv[y].push_back(x);\n}\nint vis[nn];\nint siz[nn],esiz[nn];\nint pa[nn];vector<int> cir;\nvector<int> all;int dep[nn];\nvoid dfs(int x,int p)\n{\n\tsiz[x]=1;esiz[x]=0;vis[x]=1;\n\tall.push_back(x);\n\tpa[x]=p,dep[x]=dep[p]+1;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tint y=v[x][i];\n\t\tif(y==p) continue;//there cant be a multi-edge\n\t\tif(!vis[y])\n\t\t{\n\t\t\tdfs(y,x);\n\t\t\tsiz[x]+=siz[y];\n\t\t\tesiz[x]+=1+esiz[y];\n\t\t}\n\t\telse if(dep[y]<dep[x] and cir.size()==0)\n\t\t{\n\t\t\tesiz[x]++;\n\t\t\tint t=x;\n\t\t\twhile(x!=pa[y]) \n\t\t\t\tcir.push_back(x),x=pa[x];\n\t\t\tx=t;\n\t\t}\n\t}\n}\n\nunordered_map<int,vector<int> >trans ;\nvector<int> g[nn];int gs[nn];ll dp[nn];\nvoid give(int x,int y)\n{\n//\tcout<<x<<\"-\"<<y<<\"\\n\";\n\tg[x].push_back(y);\n\tg[y].push_back(x);\n}\nvoid gfs(int x,int p)\n{\n\tgs[x]=1;dp[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t{\n\t\tint y=g[x][i];if(y==p) continue;\n\t\tgfs(y,x);\n\t\tdp[x]=dp[x]*dp[y]%mod*rf[gs[y]]%mod;gs[x]+=gs[y];\n\t}\n\tdp[x]=dp[x]*f[gs[x]-1]%mod;\n}\nint cf[nn];\nll solve()\n{\n\ttrans.clear();\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];g[all[i]].clear();cf[all[i]]=0;\n//\t\tcout<<x<<\"->\"<<y<<\"\\n\";\n\t\t\ttrans[y].push_back(x);\n\t}\n\tg[0].clear();//system(\"pause\");\n\tfor(int i=0;i<all.size();i++)\n\t{\n\t\tint x=all[i],y=pa[x];vector<int> tmp=trans[x];\n\t\tfor(int j=0;j<tmp.size();j++)\n\t\t\tif(tmp[j]<y) give(all[i],tmp[j]),cf[tmp[j]]=1; \n\t}\n\tfor(int i=0;i<all.size();i++) if(!cf[all[i]]) give(all[i],0);\n//\tgfs(0,-1);\n\treturn dp[0];\n}\n\nint vp[nn];\nvoid vps(int x,int p)\n{\n\tpa[x]=p;\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==p or vp[v[x][i]]) continue;\n\t\tvps(v[x][i],x); \n\t}\n}\nint main()\n{\n\tini();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tscanf(\"%d%d\",&dot[i].first,&dot[i].second);\n\t\tadde(dot[i].first,dot[i].second+n);\n\t}\n\tll ans=1;\n\tfor(int i=1;i<=n*2;i++) \n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tcir.clear();all.clear();\n\t\t\tdfs(i,0);int cn=cir.size();\n\t\t\tif(siz[i]!=esiz[i]) err;\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tvp[cir[i]]=1,pa[cir[j]]=cir[(j+1)%cn];\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tvps(cir[j],pa[cir[j]]);\n\t\t\tll res=solve();\n\t\t\tfor(int j=0;j<cn;j++)\n\t\t\t\tpa[cir[j]]=cir[(j-1+cn)%cn];\n\t\t\tres+=solve();\n\t\t\tans=res%mod*ans%mod*rf[all.size()]%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans*f[n+n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int N = 200000;\nconst int MOD = (int)1e9 + 7;\n\nint INV[N + 1], x[N + N], parent[N], from[N], size[N];\nstd::vector<int> graph[N], vertices;\n\nint find(int u)\n{\n    return ~parent[u] ? parent[u] = find(parent[u]) : u;\n}\n\nbool dfs(int u, int v)\n{\n    if (~from[v]) {\n        if (from[v] != u) {\n            return false;\n        }\n    } else {\n        from[v] = u;\n        size[v] = 0;\n        vertices.push_back(v);\n        for (auto w : graph[v]) {\n            if (w != u) {\n                if (!dfs(v, w)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint rec(int u, int v)\n{\n    if (!size[v]) {\n        size[v] = 1;\n        for (int w : graph[v]) {\n            if (w < u) {\n                size[v] += rec(v, w);\n            }\n        }\n    }\n    return size[v];\n}\n\nint solve(int a, int b)\n{\n    for (int v : vertices) {\n        from[v] = -1;\n    }\n    vertices.clear();\n    if (!dfs(a, b)) {\n        return 0;\n    }\n    int result = 1;\n    for (int v : vertices) {\n        result = 1LL * result * INV[rec(from[v], v)] % MOD;\n    }\n    return result;\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"F.in\", \"r\", stdin);\n#endif\n    INV[1] = 1;\n    for (int i = 2; i <= N; ++ i) {\n        INV[i] = 1LL * (MOD - MOD / i) * INV[MOD % i] % MOD;\n    }\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        for (int i = 0; i < n << 1; ++ i) {\n            graph[i].clear();\n        }\n        for (int i = 0; i < n << 2; ++ i) {\n            scanf(\"%d\", x + i);\n            x[i] --;\n            if (i & 1) {\n                x[i] += n;\n            }\n        }\n        for (int i = 0; i < n << 2; ++ i) {\n            graph[x[i]].push_back(x[i ^ 1]);\n        }\n        int result = 1;\n        memset(from, -1, sizeof(from));\n        memset(parent, -1, sizeof(parent));\n        for (int i = 0; i < n << 1 && result; ++ i) {\n            result = result * (i + 1LL) % MOD;\n            int a = x[i << 1];\n            int b = x[i << 1 | 1];\n            if (find(a) == find(b)) {\n                result = 1LL * result * (solve(a, b) + solve(b, a)) % MOD;\n            } else {\n                parent[find(a)] = find(b);\n            }\n        }\n        printf(\"%d\\n\", result);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\nint read() {\n\tint x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) flag *= (ch == '-' ? -1 : 1);\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';\n\treturn flag * x;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 2e5 + 9, Mod = 1e9 + 7;\nnamespace Math {\n\tint fpm(int base, int tims) {\n\t\tint r = 1;\n\t\tfor (; tims; base = 1ll * base * base % Mod, tims >>= 1) \n\t\t\tif (tims & 1) r = 1ll * r * base % Mod;\n\t\treturn r;\n\t}\n\tint fac[Maxn], invFac[Maxn];\n\tvoid Init() {\n\t\tfac[0] = 1;\n\t\trep (i, 1, Maxn - 1) \n\t\t\tfac[i] = fac[i - 1] * 1ll * i % Mod;\n\t\tinvFac[Maxn - 1] = fpm(fac[Maxn - 1], Mod - 2);\n\t\tdrep (i, Maxn - 2, 0) invFac[i] = invFac[i + 1] * (i + 1ll) % Mod;\n\t}\n\tint C(int _n, int _m) {\n\t\tif (_n < _m) return 0;\n\t\treturn fac[_n] * 1ll * invFac[_n - _m] % Mod * invFac[_m] % Mod;\n\t}\n}\nusing namespace Math;\n\nstruct node { int u, v, w; };\nstruct edge { int to, nxt, w; }g[Maxn << 2], g1[Maxn << 2];\nint head[Maxn], e;\nint head1[Maxn], e1;\nvoid add(int u, int v, int w) { g[++e] = (edge){v, head[u], w}, head[u] = e; }\nvoid add1(int u, int v, int w = 0) { g1[++e1] = (edge){v, head1[u], w}, head1[u] = e1; }\n\nint vis[Maxn], inCir[Maxn], found, _top, delta, n;\nnode stk[Maxn];\nvector <node> cir;\nvector <int> cus, cun;\n\nvoid dfsCir(int u, int pa) {\n\tif (!vis[u]) ++delta, cun.push_back(u);\n\tvis[u] = 1; \n\t\t\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tif (!vis[v]) {\n\t\t\t\tstk[++_top] = (node){u, v, g[i].w};\n\t\t\t\tdfsCir(v, u);\n\t\t\t\t--_top;\n\t\t\t} else if (!found) {\n\t\t\t\tnode tmp; int bak = _top;\n\t\t\t\tdo {\n\t\t\t\t\ttmp = stk[bak--];\n\t\t\t\t\tcir.push_back(tmp);\n\t\t\t\t\tif (!inCir[tmp.u]) cus.push_back(tmp.u);\n\t\t\t\t\tif (!inCir[tmp.v]) cus.push_back(tmp.v);\n\t\t\t\t\tinCir[tmp.u] = inCir[tmp.v] = 1;\n\t\t\t\t} while (tmp.u != v);\n\t\t\t\tcir.push_back((node){u, v, g[i].w});\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint val[Maxn];\nvoid dfs1(int u, int pa) {\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (!inCir[v] && v != pa) val[v] = g[i].w, dfs1(v, u);\n\t}\n}\n\nint size[Maxn], dp[Maxn];\nvoid dfsDp(int u, int pa) {\n\tdp[u] = 1;\n\tint sum = 0;\n\tfor (int i = head1[u]; ~i; i = g1[i].nxt) {\n\t\tint v = g1[i].to;\n\t\tif (v != pa) {\n\t\t\tdfsDp(v, u);\n\t\t\tsize[u] += size[v];\n\t\t\tdp[u] = 1ll * dp[u] * dp[v] % Mod * C(size[u], sum) % Mod;\n\t\t\tsum += size[v];\n\t\t}\n\t}\n\t++size[u];\n}\nint deg[Maxn], toward[Maxn];\nint calc() {\n\te1 = 0;\n\trep (i, 0, cun.size() - 1) {\n\t\tint u = cun[i];\n\t\tsize[u] = dp[u] = deg[u] = 0;\n\t\thead1[u] = -1;\n\t}\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (g[i].w < val[u]) add1(u, v), ++deg[v];\n\t\t}\n\t}\n\tint res = 1, sum = 0;\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tif (!deg[u]) {\n\t\t\tdfsDp(u, 0);\n\t\t\tres = 1ll * res * dp[u] * C(sum + size[u], sum) % Mod;\n\t\t\tsum += size[u];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"robot.in\", \"r\", stdin);\n\tfreopen(\"robot.out\", \"w\", stdout);\n\n\tstatic int x[Maxn], y[Maxn], xjig[Maxn], amt = 0;\n\n\tclar (head, -1), e = 0;\n\tMath :: Init();\n\n\tn = read() << 1;\n\trep (i, 1, n) {\n\t\tx[i] = read(), y[i] = read();\n\t\tadd(x[i], y[i] + n / 2, x[i] + y[i]);\n\t\tadd(y[i] + n / 2, x[i], x[i] + y[i]);\n\t\tif (!xjig[x[i]]) ++amt, xjig[x[i]] = 1;\n\t\tif (!xjig[y[i] + n / 2]) ++amt, xjig[y[i] + n / 2] = 1;\n\t}\n\tif (amt != n) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tLL ans = 1, sum = 0;\n\trep (i, 1, n) \n\t\tif (!vis[i]) {\n\t\t\tint res = 0; _top = 0, cir.clear(), found = 0, delta = 0, cus.clear(), cun.clear();\n\t\t\tdfsCir(i, 0);\n\t\t\trep (j, 0, cus.size() - 1) dfs1(cus[j], 0);\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].u] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].v] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\n\t\t\tans = 1ll * ans * res % Mod * C(sum += delta, delta) % Mod;\n\t\t}\n\tprintf(\"%d\\n\", 1ll * ans * fpm(fac[n], Mod - 1) % Mod);\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nusing pi = pair<int, int>;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nint n, sz[MAXN], indeg[MAXN];\nvector<pi> gph[MAXN];\nvector<int> tr[MAXN];\nvector<int> dfn;\nint deg[MAXN], vis[MAXN];\nint match[MAXN];\nlint fact[MAXN], invf[MAXN];\n\nlint dfs2(int x){\n\tsz[x] = 0;\n\tlint ret = 1;\n\tfor(auto &i : tr[x]){\n\t\tret *= dfs2(i);\n\t\tret %= mod;\n\t}\n\tfor(auto &i : tr[x]){\n\t\tsz[x] += sz[i];\n\t\tret *= invf[sz[i]];\n\t\tret %= mod;\n\t}\n\tret *= fact[sz[x]];\n\tret %= mod;\n\tsz[x]++;\n\treturn ret;\n}\n\nlint topsort(){\n\tvector<pi> edges; // fi -> se\n\tvector<int> edge_list;\n\tfor(auto &i : dfn){\n\t\tint to_match = -1;\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(match[i] == j.second){\n\t\t\t\tto_match = j.first;\n\t\t\t}\n\t\t}\n\t\tassert(to_match != -1);\n\t\tedge_list.push_back(to_match);\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(match[i] > j.second){\n\t\t\t\tedges.emplace_back(j.first, to_match);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto &i : dfn) disj.pa[i] = i;\n\tfor(auto &i : edges){\n\t\tif(!disj.uni(i.first, i.second)){\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(auto &i : edges){\n\t\ttr[i.second].push_back(i.first);\n\t\tindeg[i.first]++;\n\t}\n\tlint ret = 1;\n\tfor(auto &i : edge_list){\n\t\tif(indeg[i] == 0){\n\t\t\tret *= dfs2(i) * invf[sz[i]] % mod;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret *= fact[edge_list.size()];\n\tfor(auto &i : edges){\n\t\tindeg[i.first] = 0;\n\t\ttr[i.second].clear();\n\t}\n\treturn ret % mod;\n}\n\nlint solve(){\n\tqueue<int> que;\n\tfor(auto &i : dfn){\n\t\tif(deg[i] == 1){\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tint x = que.front(); que.pop();\n\t\tdeg[x]--;\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(deg[i.second]){\n\t\t\t\tmatch[x] = i.second;\n\t\t\t\tdeg[i.second]--;\n\t\t\t\tif(deg[i.second] == 1){\n\t\t\t\t\tque.push(i.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> cyc_ord;\n\tfor(auto &i : dfn){\n\t\tif(deg[i] == 2){\n\t\t\tfor(int j=i; deg[j]; ){\n\t\t\t\tdeg[j] = 0;\n\t\t\t\tcyc_ord.push_back(j);\n\t\t\t\tfor(auto &k : gph[j]){\n\t\t\t\t\tif(deg[k.second]){\n\t\t\t\t\t\tj = k.second;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i=0; i<cyc_ord.size(); i++){\n\t\tmatch[cyc_ord[i]] = cyc_ord[(i+1)%cyc_ord.size()];\n\t}\n\tret += topsort();\n\treverse(cyc_ord.begin(), cyc_ord.end());\n\tfor(int i=0; i<cyc_ord.size(); i++){\n\t\tmatch[cyc_ord[i]] = cyc_ord[(i+1)%cyc_ord.size()];\n\t}\n\tret += topsort();\n\treturn ret % mod;\n}\n\nint v, e;\n\nvoid dfs(int x){\n\tif(vis[x]) return;\n\tdfn.push_back(x);\n\tvis[x] = 1;\n\tv++;\n\te += gph[x].size();\n\tfor(auto &i : gph[x]) dfs(i.second);\n}\n\nlint ipow(lint x, lint p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint main(){\n\tfact[0] = invf[0] = 1;\n\tfor(int i=1; i<MAXN; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tinvf[i] = ipow(fact[i], mod - 2);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<2*n; i++){\n\t\tint x, y; scanf(\"%d %d\",&x,&y);\n\t\tx--, y += n - 1;\n\t\tgph[x].emplace_back(i, y);\n\t\tgph[y].emplace_back(i, x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tn <<= 1;\n\tdisj.init(n);\n\tlint ret = 1;\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i]){\n\t\t\tv = e = 0;\n\t\t\tdfn.clear();\n\t\t\tdfs(i);\n\t\t\tif(2 * v != e){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tret *= invf[v] * solve() % mod;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret *= fact[n];\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define db double\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define vi vector<int>\n#define vl vector<ll>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define eps 1e-9\n#define clv(V) (V).clear()\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\n#define MAXN (300005)\n#define upmax(a,b) (a)=max((a),(b))\nusing namespace std;\nconst db pi = acos(-1.0);\ninline int read()\n{\n    int x = 0, f = 1; char ch = getchar();\n    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n}\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nll operator * (pll a, pll b) { return a.first*b.second - b.first*a.second; }\nll ccw(pll a, pll b, pll c) { return a*b + b*c + c*a; }\nstruct CHT\n{\n\tvector<pll> V;\n\tvoid init() { clv(V); }\n\tvoid push(ll a, ll b)\n\t{\n\t\tfor(; 1 < sz(V) && ccw(befv(V), V.back(), {a, b}) <= 0; V.pop_back());\n\t\tV.pb({a, b});\n\t}\n\tll f(ll x, int idx) { return V[idx].first*x + V[idx].second; }\n\tll f(ll x)\n\t{\n\t\tif(V.empty()) return -INFLL;\n\t\tint s = 0, e = sz(V)-1;\n\t\tfor(int m; s < e;)\n\t\t{\n\t\t\tm = (s+e)/2;\n\t\t\tll l = f(x, m), r = f(x, m+1);\n\t\t\tif(l < r) s = m+1; else e = m;\n\t\t}\n\t\treturn f(x, s);\n\t}\n};\n\nCHT cht;\nll L[MAXN], R[MAXN], P[MAXN];\nll S[MAXN];\nll T[MAXN];\nint N, M;\n\nvoid f(ll d[])\n{\n\trep(i, 1, N) S[i] = S[i-1] + T[i];\n\tcht.init(); cht.push(0, 0);\n\trep(i, 1, N)\n\t{\n\t\td[i] = max(d[i - 1], cht.f(i) + ((ll)i * i + i) / 2 - S[i]);\n\t\tcht.push(-i, d[i] + S[i] + ((ll)i * i - i) / 2);\n\t}\n}\nvoid f(ll d[], int s, int e)\n{\n\tif(s > e) return;\n\tif(s == e)\n\t{\n\t\tupmax(d[s], L[s-1] + R[s+1] + 1 - T[s]);\n\t\treturn;\n\t}\n\tint m = (s+e)/2; ll x = -INFLL;\n\tcht.init();\n\tfor(int j = m+1; j <= e; j++)\n\t\tcht.push(-j, R[j+1] - S[j] + ((ll)j*j + j) / 2);\n\tfor(int i = s-1; i < m; i++)\n\t{\n\t\tll t = cht.f(i) + L[i] + S[i] - ((ll)i*i - i) / 2;\n\t\tupmax(x, t);\n\t\tupmax(d[i+1], x);\n\t}\n\tcht.init(); x = -INFLL;\n\tfor(int i = s-1; i < m; i++)\n\t\tcht.push(-i, L[i] + S[i] + ((ll)i*i - i) / 2);\n\tfor(int j = e; m < j; j--) {\n\t\tll t = cht.f(j) + R[j+1] - S[j] + ((ll)j*j + j) / 2;\n\t\tupmax(x, t); upmax(d[j], x);\n\t}\n\tf(d, s, m); f(d, m+1, e);\n}\nint main()\n{\n\tscanf(\"%d\", &N);\n\trep(i, 1, N) scanf(\"%lld\", &T[i]);\n\tf(L); reverse(T + 1, T + N + 1);\n\tf(R); reverse(R + 1, R + N + 1);\n\treverse(T + 1, T + N + 1);\n\trep(i, 1, N) S[i] = S[i  -1] + T[i];\n\tfill(P + 1, P + N + 1, -INFLL);\n\tf(P, 1, N);\n\tfor(scanf(\"%d\", &M); M --;)\n\t{\n\t\tint p;\n\t\tll x;\n\t\tscanf(\"%d%lld\", &p, &x);\n\t\tprintf(\"%lld\\n\", max(0ll, max(L[p - 1] + R[p + 1], P[p] + T[p] - x)));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nint x[210000];\nint y[210000];\nint UF[210000];\nvector<int>g[210000];\nint FIND(int a){\n\tif(UF[a]<0)return a;return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint h[210000];\nint v[210000];\nvector<int>cy;\nvector<int>cur;\nint dfs(int a,int b){\n\tv[a]=b;\n\t\n\tcur.push_back(a);\n\tint ret=-2;\n\t// printf(\"%d %d %d\\n\",a,b,(int)g[a].size());\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]==b)continue;\n\t\tif(v[g[a][i]]==-2){\n\t\t\tint val=dfs(g[a][i],a);\n\t\t\tif(val!=-2){\n\t\t\t\tcy.push_back(a);\n\t\t\t\tif(a==val)val=-2;\n\t\t\t}\n\t\t\tif(val!=-2) ret=val;\n\t\t}else{\n\t\t\tcy.push_back(a);\n\t\t\treturn g[a][i];\n\t\t}\n\t}\n\t// printf(\"fin %d %d\\n\",a,b);fflush(stdout);\n\treturn ret;\n}\nvector<int>g2[210000];\nint sz[210000];\nint ou[210000];\nlong long calc(int a){\n\tlong long ret=1;\n\tsz[a]=0;\n\tfor(int i=0;i<g2[a].size();i++){\n\t\tret=ret*calc(g2[a][i])%mod;\n\t\tret=ret*Comb(sz[a]+sz[g2[a][i]],sz[a])%mod;\n\t\tsz[a]+=sz[g2[a][i]];\n\t}\n\tsz[a]++;\n\t// printf(\"%d: %lld\\n\",a,ret);\n\treturn ret;\n}\nint tl[210000];\nint n;\nvoid dfs2(int a,int b){\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\t// printf(\"%d %d\\n\",a,g[a][i]);\n\t\ttl[g[a][i]]=a;\n\t\tif(g[a][i]==cy[0])continue;\n\t\tdfs2(g[a][i],a);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tfor(int i=0;i<a*2;i++)UF[i]=-1;\n\tfor(int i=0;i<a*2;i++)v[i]=-2;\n\tinit_C(410000);\n\tfor(int i=0;i<2*a;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tx[i]--;y[i]--;\n\t\tg[x[i]].push_back(y[i]+a);\n\t\tg[y[i]+a].push_back(x[i]);\n\t\tUNION(x[i],y[i]+a);\n\t}\n\tfor(int i=0;i<a*2;i++){\n\t\th[FIND(x[i])]++;\n\t}\n\tlong long ret=1;\n\tlong long ks=1;\n\tint tn=0;\n\tfor(int i=0;i<a*2;i++){\n\t\tif(UF[i]<0&&h[i]!=-UF[i]){\n\t\t\tprintf(\"0\\n\");return 0;\n\t\t}\n\t\tif(UF[i]<0){\n\t\t\tcur.clear();\n\t\t\tks=ks*Comb(tn+h[i],h[i])%mod;\n\t\t\ttn+=h[i];\n\t\t\tcy.clear();\n\t\t\tdfs(i,-1);\n\t\t\t// for(int j=0;j<cy.size();j++)printf(\"%d \",cy[j]);printf(\"\\n\");\n\t\t\tlong long tmp=0;\n\t\t\tfor(int k=0;k<2;k++){\n\n\t\t\t\tif(k==0)dfs2(cy[0],cy[1]);\n\t\t\t\telse dfs2(cy[0],cy[cy.size()-1]);\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tfor(int k=0;k<g[cur[j]].size();k++){\n\t\t\t\t\t\tint to=g[cur[j]][k];\n\t\t\t\t\t\tif(to<tl[cur[j]]){\n\t\t\t\t\t\t\tg2[cur[j]].push_back(to);\n\t\t\t\t\t\t\t// printf(\"%d %d\\n\",cur[j],to);\n\t\t\t\t\t\t\tou[to]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tif(!ou[cur[j]]){\n\t\t\t\t\t\tg2[a*2].push_back(cur[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp+=calc(a*2);\n\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tg2[cur[j]].clear();\n\t\t\t\t\tou[cur[j]]=0;\n\t\t\t\t}\n\t\t\t\tg2[a*2].clear();\n\t\t\t}\n\t\t\ttmp%=mod;\n\t\t\tprintf(\"%d: %lld\\n\",i,tmp);\n\t\t\tret=ret*tmp%mod;\n\t\t}\n\t}\n\n\tret=ret*ks%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define next nxt\nusing namespace std;\nint fac[200010],nifac[200010],e[200010];\nint first[200010],next[200010],des[200010],w[200010];\nint size[200010],ans,f[200010],vn,en,ed;\nbool vis[200010];\nint tt,n;\nint C(int n,int m){return (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;}\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nvoid dfs(int s,int pre)\n{\n\tvis[s]=true;vn++;\n\tfor (int k=first[s];k;k=next[k])\n\t{\n\t\ten++;\n\t\tif (!vis[des[k]]) {e[des[k]]=k^1;dfs(des[k],s);}\n\t\telse if (des[k]!=pre) ed=k;\n\t}\n}\nvoid dp(int s,int e)\n{\n\tf[s]=1;size[s]=0;\n\tfor (int k=first[s];k;k=next[k]) if (k/2!=ed/2&&(k^1^e))\n\t{\n\t\tdp(des[k],k);\n\t\tif (w[k]>w[e]) ans=1LL*ans*nifac[size[des[k]]]%mo*f[des[k]]%mo;\n\t\telse f[s]=1LL*f[s]*f[des[k]]%mo*C(size[s]+=size[des[k]],size[des[k]])%mo;\n\t}\n\tsize[s]++;\n}\nint main()\n{\n\ttt=1;scanf(\"%d\",&n);n<<=1;\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);v+=n/2;\n\t\tdes[++tt]=v;next[tt]=first[u];first[u]=tt;\n\t\tdes[++tt]=u;next[tt]=first[v];first[v]=tt;\n\t\tw[tt]=w[tt^1]=u+v;\n\t}\n \n\tint all=fac[n];\n\tfor (int s=1;s<=n;s++) if (!vis[s])\n\t{\n\t\tvn=en=ed=0;dfs(s,0);en>>=1;\n\t\tif (vn!=en) {puts(\"0\");return 0;}\n\t\tint u=des[ed],v=des[ed^1];\n\t\tfor (;u!=v;u=des[e[u]]) if (w[e[u]]>w[ed]) ed=e[u];\n\t\tans=1;dp(des[ed],ed);\n\t\tint p1=(long long)ans*nifac[size[des[ed]]]%mo*f[des[ed]]%mo;\n\t\tans=1;dp(des[ed^1],ed);\n\t\tint p2=(long long)ans*nifac[size[des[ed^1]]]%mo*f[des[ed^1]]%mo;\n\t\tall=(long long)all*(p1+p2)%mo;\n\t}\n\tprintf(\"%d\\n\",all);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n\ntypedef long long LL;\nusing namespace std;\nconst int mod = 1e9 + 7, maxn = 2e5 + 10;\n#define pb push_back\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x << 3) + (x << 1) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nint fix, top, sta[maxn], xz[maxn], f[maxn], vis[maxn], fac[maxn], ifac[maxn], inv[maxn], zj[maxn];\nvector<int> vec, G[maxn], E[maxn];\n\nvoid dfs(int u, int fa)\n{\n\tvis[u] = 1; if(!fix) sta[++top] = u;\n\tvec.pb(u);\n\tfor(int i = 0; i < G[u].size(); ++i)\n\t{\n\t\tint v = G[u][i]; if(v == fa) continue;\n\t\tif(vis[v]) \n\t\t{\n\t\t\tint tmp = top; top = 0;\n\t\t\twhile(tmp)\n\t\t\t{\n\t\t\t\tzj[++top] = sta[tmp];\n\t\t\t\tif(sta[tmp] == v) break;\n\t\t\t\ttmp--;\n\t\t\t}\n\t\t\tswap(zj, sta);\n\t\t\tfix = 1;\n\t\t}\n\t\telse dfs(v, u), f[v] = u;\n\t}\n\tif(sta[top] == u && !fix) --top;\n}\n\nvoid Dfs(int u, int fa)\n{\n\tf[u] = fa;\n\tfor(auto v : G[u]) if(v != fa) Dfs(v, u);\n}\n\ninline int C(int N, int M) { return (LL)fac[N] * ifac[M] % mod * ifac[N - M] % mod; }\n\nint dfs1(int u)\n{\n\txz[u] = 1; int sum = 0, ans = 1;\n\tfor(auto v : E[u])\n\t{\n\t\tans = (LL)ans * dfs1(v) % mod * C(sum + xz[v], xz[v]) % mod;\n\t\txz[u] += xz[v]; sum += xz[v];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n = read();\n\n\tinv[0] = inv[1] = ifac[0] = ifac[1] = fac[0] = fac[1] = 1;\n\tfor(int i = 2; i <= 2 * n + 5; ++i)\n\t{\n\t\tfac[i] = (LL)fac[i - 1] * i % mod;\n\t\tinv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod;\n\t\tifac[i] = (LL)ifac[i - 1] * inv[i] % mod;\n\t}\n\n\tfor(int i = 1; i <= 2 * n; ++i)\n\t{\n\t\tint x = read(), y = read() + n;\n\t\t//cout << x << ' ' << y << endl;\n\t\tG[x].pb(y); G[y].pb(x);\n\t}\n\tfor(int i = 1; i <= 2 * n; ++i) if(!G[i].size()) { puts(\"0\"); return 0; };\n\n\tint Ans = 1, xhb = 0;\n\tfor(int i = 1; i <= 2 * n; ++i) if(!vis[i])\n\t{\n\t\ttop = 0; fix = 0; vec.clear(); int now = 0;\n\t\tdfs(i, 0);\n\n\t\tfor(int j = 1; j <= top; ++j)\n\t\t\tfor(auto k : G[sta[j]]) if(k != sta[(j - 1) == 0 ? top : j - 1] && k != sta[j == top ? 1 : j + 1])\n\t\t\t\tDfs(k, sta[j]);\n\t\tif(top) { f[sta[1]] = sta[top]; }\n\n\t\tfor(auto j : vec) E[j].clear(), xz[j] = 0;\n\t\tfor(auto j : vec) if(f[j])\n\t\t\tfor(auto k : G[j])\n\t\t\t\tif(k < f[j]) E[j].pb(k), xz[k] = 1;//, cout << k << ' ' << j << endl;\n\t\tint sum = 0, ans = 1;\n\t\tfor(auto j : vec) if(!xz[j]) \n\t\t\tans = (LL)ans * dfs1(j) % mod * C(sum + xz[j], xz[j]) % mod, sum += xz[j];\n\t\t(now += ans) %= mod;\n\n\t\tif(top)\n\t\t{\n\t\t\tf[sta[top]] = sta[1];\n\t\t\tfor(int j = top - 1; j >= 1; --j) f[sta[j]] = sta[j + 1];\n\t\t\tfor(auto j : vec) E[j].clear(), xz[j] = 0;\n\t\t\tfor(auto j : vec) if(f[j])\n\t\t\t\tfor(auto k : G[j])\n\t\t\t\t\tif(k < f[j]) E[j].pb(k), xz[k] = 1;\n\t\t\tsum = 0, ans = 1;\n\t\t\tfor(auto j : vec) if(!xz[j]) ans = (LL)ans * dfs1(j) % mod * C(sum + xz[j], xz[j]) % mod, sum += xz[j];\n\t\t\t(now += ans) %= mod;\n\t\t}\n\n\t\tAns = (LL)Ans * now % mod * C(xhb + vec.size(), xhb) % mod;\n\t\txhb += vec.size();\n\t}\n\tcout << Ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat pw(cat a, cat e, cat mod) {\n\tif(e <= 0) return 1;\n\tcat x =pw(a,e/2,mod);\n\tx =(x*x)%mod;\n\tif(e&1) x =(x*a)%mod;\n\treturn x;\n}\n\ncat mod =1000000007;\nvector<cat> fac;\nvector< vector<int> > GT;\nvector<int> DT;\n\ncat DFST(int R, cat &ret) {\n\tcat S =0;\n\tALL_THE(GT[R],it) {\n\t\tcat Ss =DFST(*it,ret);\n\t\tS +=Ss;\n\t\tret =(ret*pw(fac[Ss],mod-2,mod))%mod;\n\t}\n\tret =(ret*fac[S])%mod;\n\tS++;\n\treturn S;\n}\n\ncat count(vector<int> &comp, vector<int> &par, vector< vector<int> > &G) {\n\tALL_THE(comp,it) {\n\t\tGT[*it].clear();\n\t\tDT[*it] =0;\n\t}\n\tALL_THE(comp,it) ALL_THE(G[*it],jt) if(*jt < par[*it]) {\n\t\tGT[*it].push_back(*jt);\n\t\tDT[*jt]++;\n\t}\n\tcat ret =1;\n\tint S =0;\n\tALL_THE(comp,it) if(DT[*it] == 0) {\n\t\tint Ss =DFST(*it,ret);\n\t\tret =(ret*pw(fac[Ss],mod-2,mod))%mod;\n\t\tS +=Ss;\n\t}\n\tret =(ret*fac[S])%mod;\n\treturn ret;\n}\n\nvoid DFS(int R, vector< vector<int> > &G, vector<int> &par, vector<int> &vis, vector<int> &comp, int &on_cyc) {\n\tcomp.push_back(R);\n\tALL_THE(G[R],it) {\n\t\tif(par[R] != *it) {\n\t\t\tif(par[*it] == -1) par[*it] =R;\n\t\t\tif(vis[*it]) on_cyc =*it;\n\t\t}\n\t\tif(vis[*it] == 0) {\n\t\t\tvis[*it] =1;\n\t\t\tDFS(*it,G,par,vis,comp,on_cyc);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tGT.resize(2*N);\n\tDT.resize(2*N);\n\tvector< vector<int> > G(2*N);\n\tfor(int i =0; i < 2*N; i++) {\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tG[--x].push_back(--y+N);\n\t\tG[y+N].push_back(x);\n\t}\n\tfac.resize(2*N+1,1);\n\tfor(int i =1; i <= 2*N; i++) fac[i] =(i*fac[i-1])%mod;\n\tcat ans =fac[2*N];\n\n\tvector<int> vis(2*N,0), par(2*N,-1);\n\tfor(int i =0; i < 2*N; i++) if(vis[i] == 0) {\n\t\tvector<int> comp;\n\t\tvis[i] =1;\n\t\tint on_cyc =-1;\n\t\tDFS(i,G,par,vis,comp,on_cyc);\n\t\tif(on_cyc == -1) {\n\t\t\tcout << \"0\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tint e =0;\n\t\tALL_THE(comp,it) {\n\t\t\te +=G[*it].size();\n\t\t\tpar[*it] =-1;\n\t\t\tvis[*it] =0;\n\t\t}\n\t\tif(e/2 != (int)comp.size()) {\n\t\t\tcout << \"0\\n\";\n\t\t\treturn 0;\t\t\t\n\t\t}\n\t\tcomp.clear();\n\t\tint v =on_cyc;\n\t\tvis[on_cyc] =1;\n\t\tDFS(v,G,par,vis,comp,on_cyc);\n\t\tvector<int> cyc;\n\t\tint a =par[v];\n\t\twhile(true) {\n\t\t\tcyc.push_back(a);\n\t\t\tif(a == v) break;\n\t\t\ta =par[a];\n\t\t}\n\n\t\tcat akt =count(comp,par,G);\n\t\tfor(int j =0; j < (int)cyc.size(); j++) par[cyc[(j+1)%cyc.size()]] =cyc[j];\n\t\takt +=count(comp,par,G);\n\n\t\tans =(ans*akt)%mod;\n\t\tans =(ans*pw(fac[comp.size()],mod-2,mod))%mod;\n\t}\n\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[100010],nifac[100010],e[100010];\nint first[100010],next[100010],des[100010],w[100010];\nint size[100010],ans,f[100010],vn,en,ed;\nbool vis[100010];\nint tt,n;\nint C(int n,int m){return (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;}\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nvoid dfs(int s,int pre)\n{\n\tvis[s]=true;vn++;\n\tfor (int k=first[s];k;k=next[k])\n\t{\n\t\ten++;\n\t\tif (!vis[des[k]]) {e[des[k]]=k^1;dfs(des[k],s);}\n\t\telse if (des[k]!=pre) ed=k;\n\t}\n}\nvoid dp(int s,int e)\n{\n\tf[s]=1;size[s]=0;\n\tfor (int k=first[s];k;k=next[k]) if (k/2!=ed/2&&(k^1^e))\n\t{\n\t\tdp(des[k],k);\n\t\tif (w[k]>w[e]) ans=1LL*ans*nifac[size[des[k]]]%mo*f[des[k]]%mo;\n\t\telse f[s]=1LL*f[s]*f[des[k]]%mo*C(size[s]+=size[des[k]],size[des[k]])%mo;\n\t}\n\tsize[s]++;\n}\nint main()\n{\n\ttt=1;scanf(\"%d\",&n);n<<=1;\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);v+=n/2;\n\t\tdes[++tt]=v;next[tt]=first[u];first[u]=tt;\n\t\tdes[++tt]=u;next[tt]=first[v];first[v]=tt;\n\t\tw[tt]=w[tt^1]=u+v;\n\t}\n \n\tint all=fac[n];\n\tfor (int s=1;s<=n;s++) if (!vis[s])\n\t{\n\t\tvn=en=ed=0;dfs(s,0);en>>=1;\n\t\tif (vn!=en) {puts(\"0\");return 0;}\n\t\tint u=des[ed],v=des[ed^1];\n\t\tfor (;u!=v;u=des[e[u]]) if (w[e[u]]>w[ed]) ed=e[u];\n\t\tans=1;dp(des[ed],ed);\n\t\tint p1=(long long)ans*nifac[size[des[ed]]]%mo*f[des[ed]]%mo;\n\t\tans=1;dp(des[ed^1],ed);\n\t\tint p2=(long long)ans*nifac[size[des[ed^1]]]%mo*f[des[ed^1]]%mo;\n\t\tall=(long long)all*(p1+p2)%mo;\n\t}\n\tprintf(\"%d\\n\",all);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,O=1000000007;\ninline int fpow(int x,int n){\n\tint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\nint nlst[N],ns,ecnt;\nint fac[N],invfac[N];\ninline void gmath(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=(lint)fac[i-1]*i%O;\n\t}\n\tinvfac[n]=inv(fac[n]);\n\tfor(int i=n;i>=1;i--){\n\t\tinvfac[i-1]=(lint)invfac[i]*i%O;\n\t}\n}\nnamespace G{\n\tconst int E=N;\n\tint to[E],bro[E],head[N],e=0;\n\tint size[N],ringe;\n\tint edg[N];\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tvoid getring(int x){\n\t\tnlst[++ns]=x;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tecnt++;\n\t\t\tif((v=to[i])!=edg[x]){\n\t\t\t\tif(edg[v]){\n\t\t\t\t\tif(ringe==-1){\n\t\t\t\t\t\tringe=i;\n\t\t\t\t\t}else if(to[ringe]!=x){\n\t\t\t\t\t\tringe=-2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tedg[v]=x;\n\t\t\t\t\tgetring(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x){\n\t\tsize[x]=1;\n\t\tlint ans=1;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tans=ans*dfs(v)%O;\n\t\t\t\tans=ans*invfac[size[v]]%O;\n\t\t\t\tsize[x]+=size[v];\n\t\t\t}\n\t\t}\n\t\treturn ans*fac[size[x]-1]%O;\n\t}\n}\nint deg[N];\ninline int work2(){\n\tusing namespace G;\n\tfor(int i=1;i<=ns;i++){\n\t\tint x=nlst[i];\n\t\tdeg[x]=0;\n\t}\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tdeg[v]++;\n\t\t\t}\n\t\t}\n\t}\n\tlint ans=fac[ns];\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tif(deg[x]==0){\n\t\t\tans=ans*dfs(x)%O;\n\t\t\tans=ans*invfac[size[x]]%O;\n\t\t}\n\t}\n\treturn ans;\n}\ninline int work(int x){//kind*invfac[n]\n\tusing namespace G;\n\tns=0,ecnt=0;\n\tringe=-1;\n\tedg[x]=-1;\n\tgetring(x);\n\tif((ecnt>>1)!=ns)return 0;\n\tassert(ringe>=0);\n\tfor(int p=to[ringe],q=to[ringe^1];~p;swap(edg[p],q),swap(p,q));\n\tint ans=work2();\n\tfor(int p=to[ringe^1],q=to[ringe],tp=p;swap(edg[p],q),swap(p,q),p!=tp;);\n\treturn (lint)invfac[ns]*(ans+work2())%O;\n}\ninline int Main(){\n\tint n=ni,n2=n<<1;\n\tG::init();\n\tfor(int i=1;i<=n2;i++){\n\t\tG::add(ni,n+ni);\n\t}\n\tgmath(n<<1);\n\tlint ans=fac[n<<1];\n\tmemset(G::edg,0,sizeof(G::edg));\n\tmemset(G::size,0,sizeof(G::size));\n\tfor(int i=1;i<=n2;i++){\n\t\tif(G::edg[i]==0){\n\t\t\t(ans*=work(i))%=O;\n\t\t\tif(ans==0)return 0;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tprintf(\"%d\\n\",Main());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define M 400005\n#define mod 1000000007\n#define PB push_back\n#define MP std::make_pair\n#define FI first\n#define SE second\ntypedef long long ll;\nint n, X[M], Y[M], deg[M], bel[M], fa[M], size[M], V, E;\nstd::vector <int> Edge[M], vec, cir, tmp, Tree[M];\nstd::map <std::pair <int, int>, int> Map;\nstd::vector <std::pair <int, int> > row[M], col[M];\nbool vis[M], Vis[M];\nll fac[M], fac_inv[M], inv[M];\nint read() {\n\tchar c = getchar(); int ans = 0;\n\twhile (c < '0' || c > '9') c = getchar();\n\twhile (c >= '0' && c <= '9') ans = ans * 10 + c - '0', c = getchar();\n\treturn ans;\n}\nvoid Write(int x) {\n\tif (x < 10) putchar(x + '0');\n\telse Write(x / 10), putchar(x % 10 + '0');\n}\nll invs(ll x) {return x == 1 ? 1 : (mod - mod / x) * invs(mod % x) % mod;}\nvoid dfs1(int x) {\n\tvec.PB(x), vis[x] = 1, V++;\n\tfor (auto i : Edge[x]) {\n\t\tif (i != fa[x]) E++;\n\t\tif (!vis[i]) fa[i] = x, dfs1(i);\n\t}\n}\nvoid dfs2(int x) {\n\tfor (auto i : Edge[x]) {\n\t\tif (i == fa[x]) continue;\n\t\tif (fa[i] == x) dfs2(i);\n\t\telse if (cir.empty()) {\n\t\t\tfor (int j = x; j != i; j = fa[j]) cir.PB(j);\n\t\t\tcir.PB(i);\n\t\t}\n\t}\n}\nll dfs3(int x) {\n\tsize[x] = 1; ll ans = 1;\n\tfor (auto i : Tree[x]) ans = ans * dfs3(i) % mod, size[x] += size[i];\n\treturn ans * inv[size[x]] % mod;\n}\nll calc() {\n\tfor (auto i : tmp) Tree[i].clear(), Vis[i] = deg[i] = 0; ll ans = 1;\n\tfor (auto i : tmp) {\n\t\tif (bel[i] <= n) {\n\t\t\tfor (auto j : row[bel[i]])\n\t\t\t\tif (j.SE == i) break;\n\t\t\t\telse Tree[i].PB(j.SE), deg[j.SE]++;\n\t\t}\n\t\telse {\n\t\t\tfor (auto j : col[bel[i] - n])\n\t\t\t\tif (j.SE == i) break;\n\t\t\t\telse Tree[i].PB(j.SE), deg[j.SE]++;\n\t\t}\n\t}\n\tfor (auto i : tmp)\n\t\tif (!deg[i]) ans = ans * dfs3(i) % mod;\n\treturn ans;\n}\nll calc(int rt) {\n\tvec.clear(), cir.clear(), tmp.clear(), V = E = 0, dfs1(rt);\n\tif (V != --E) return 0; dfs2(rt); std::queue <int> Q;\n\tfor (auto i : vec)\n\t\tfor (auto j : Edge[i]) deg[j]++;\n\tfor (auto i : vec)\n\t\tif (deg[i] == 1) Q.push(i), deg[i] = 0;\n\twhile (!Q.empty()) {\n\t\tint now = Q.front(); Q.pop();\n\t\tfor (auto i : Edge[now])\n\t\t\tif (deg[i]) {\n\t\t\t\tdeg[i]--, bel[Map[MP(now, i)]] = now, tmp.PB(Map[MP(now, i)]);\n\t\t\t\tif (deg[i] == 1) deg[i] = 0, Q.push(i);\n\t\t\t}\n\t}\n\tll ans = 0;\n\tfor (int _ = 0; _ < 2; tmp.resize(tmp.size() - cir.size()), std::reverse(cir.begin(), cir.end()), _++) {\n\t\tfor (int j = 0; j < cir.size() - 1; j++) bel[Map[MP(cir[j], cir[j + 1])]] = cir[j], tmp.PB(Map[MP(cir[j], cir[j + 1])]);\n\t\tbel[Map[MP(cir.back(), cir[0])]] = cir.back(), tmp.PB(Map[MP(cir.back(), cir[0])]), ans += calc();\n\t}\n\treturn ans % mod;\n}\nint main() {\n\tn = read(); ll ans = 1; fac[0] = 1;\n\tfor (int i = 1; i <= n * 2; i++) fac[i] = fac[i - 1] * i % mod; fac_inv[n * 2] = invs(fac[n * 2]);\n\tfor (int i = n * 2; i; i--) fac_inv[i - 1] = fac_inv[i] * i % mod;\n\tfor (int i = 1; i <= n * 2; i++) inv[i] = fac_inv[i] * fac[i - 1] % mod;\n\tfor (int i = 1; i <= n * 2; i++)\n\t\tX[i] = read(), Y[i] = read(), row[X[i]].PB(MP(Y[i], i)), col[Y[i]].PB(MP(X[i], i)),\n\t\tEdge[X[i]].PB(Y[i] + n), Edge[Y[i] + n].PB(X[i]),\n\t\tMap[MP(X[i], Y[i] + n)] = Map[MP(Y[i] + n, X[i])] = i;\n\tfor (int i = 1; i <= n; i++) std::sort(row[i].begin(), row[i].end()), std::sort(col[i].begin(), col[i].end());\n\tfor (int i = 1; i <= n * 2; i++)\n\t\tif (!vis[i]) ans = ans * calc(i) % mod;\n\treturn Write(ans * fac[n * 2] % mod), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G, loop;\nint dfn[MAXN], fa[MAXN], s, t, cnt = 0, edge = 0;\nvoid GetLoop(int x) // 找环 \n{\n\tG.push_back(x); // 森林中的一棵树 \n\tdfn[x] = ++cnt;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == fa[x])\n\t\t\tcontinue;\n\t\tif (dfn[y]) \n\t\t{\n\t\t\tif (dfn[y] < dfn[x]) continue;\n\t\t\tloop.push_back(y);\n\t\t\tfor (; y != x; y = fa[y])\n\t\t\t\tloop.push_back(fa[y]);\n\t\t}\n\t\telse { fa[y] = x; GetLoop(y); }\n\t}\n} \n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[cnt];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\t//freopen(\"robot.in\", \"r\", stdin);\n\t//freopen(\"robot.out\", \"w\", stdout);\n\tscanf(\"%d\", &n);;\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!dfn[i])\n\t\t{\n\t\t\tcnt = edge = 0;\n\t\t\tGetLoop(i);\n\t\t\tif (cnt << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\ts = loop[0], t = loop[loop.size() - 1]; // 环的起点、终点 \n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tloop.clear();\n\t\t\tG.clear();\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\nconst int N=200010;\nconst int ha=1e9+7;\nstruct Edge{int to,next;} e[N<<1],et[N<<1];\nint h[N],ht[N],esum=0,tsum=0,n,cmt=0;\nint gay[N],out[N],sz[N];\nbool done[N],inc[N],flag;\nvector<int> crl,vertix;\nstack<int> s;\nint fac[N];\n\nint Pow(int a,int b)\n{\n    int ans=1;\n    for(;b;b>>=1,a=1ll*a*a%ha)\n        if(b&1) ans=1ll*ans*a%ha;\n    return ans;\n}\n\nvoid add_edge(int u,int v)\n{\n    e[++esum]={v,h[u]};h[u]=esum;\n    e[++esum]={u,h[v]};h[v]=esum;\n}\n\nvoid add_topo_edge(int u,int v)\n{\n    out[v]++;\n    et[++tsum].to=v;\n    et[tsum].next=ht[u];\n    ht[u]=tsum;\n}\n\nvoid findcrl(int u,int fa)\n{\n    vertix.push_back(u);\n    done[u]=1;s.push(u);\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa) continue;\n        if(!flag&&done[v])\n        {\n            while(s.top()!=v) crl.push_back(s.top()),inc[s.top()]=1,s.pop();\n            crl.push_back(v);inc[v]=1;s.pop();\n            flag=1;cmt++;return;\n        }\n        else if(!done[v]) cmt++,findcrl(v,u);\n    }\n    if(!s.empty()&&s.top()==u) s.pop();\n}\n\nvoid findgay(int u,int fa)\n{\n    for(int t=h[u];t;t=e[t].next)\n    {\n        int v=e[t].to;\n        if(v==fa||inc[v]) continue;\n        gay[v]=u;findgay(v,u);\n    }\n}\n\nvoid build_topo()\n{\n    for(int u : vertix)\n        for(int t=h[u];t;t=e[t].next)\n        {\n            int v=e[t].to;\n            if(v>=gay[u]) continue;\n            add_topo_edge(u,v);\n        }\n    for(int u : vertix)\n        if(!out[u]) add_topo_edge(0,u);\n    for(int u : vertix) out[u]=0;\n}\n\nvoid getsize(int u)\n{\n    sz[u]=1;\n    for(int t=ht[u];~t;t=et[t].next)\n    {\n        int v=et[t].to;\n        getsize(v);\n        sz[u]+=sz[v];\n    }\n    ht[u]=-1;\n}\n\nint getans()\n{\n    int prodsz=1;getsize(0);\n    for(int u : vertix)\n        prodsz=1ll*prodsz*sz[u]%ha;\n    return Pow(prodsz,ha-2);\n}\n\nint xi_jin_ping_is_good(int u)\n{\n    flag=0;cmt=0;findcrl(u,0);\n    if(vertix.size()!=cmt) return 0;\n    for(int u : crl) if(inc[u]) findgay(u,0);\n    for(int i=0;i<crl.size()-1;i++) gay[crl[i]]=crl[i+1];\n    gay[crl.back()]=crl[0];\n    tsum=0;build_topo();\n    int res=getans();\n    for(int i=1;i<crl.size();i++) gay[crl[i]]=crl[i-1];\n    gay[crl[0]]=crl.back();\n    tsum=0;build_topo();\n    res=(res+getans())%ha;\n    for(int u : vertix) inc[u]=0;\n    vertix.clear();crl.clear();\n    return res;\n}\n\nint main()\n{\n    memset(ht,-1,sizeof(ht));\n    int x,y,ans=1;\n    n=read()<<1;fac[0]=1;\n    for(int i=1;i<=n;i++)\n        fac[i]=1ll*fac[i-1]*i%ha;\n    for(int i=1;i<=n;i++)\n    {\n        x=read();y=read();\n        add_edge(x,y+n/2);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(done[i]) continue;\n        x=xi_jin_ping_is_good(i);\n        if(x==0) return puts(\"0\"),0;\n        ans=1ll*ans*x%ha;\n    }\n    ans=1ll*fac[n]*ans%ha;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int L=2e5+10;\nconst int P=1e9+7;\n\nil int pwr(int x,int y){\n\tint z=1;\n\tfor(;y;y>>=1,x=(ll)x*x%P)\n\t\tif(y&1)z=(ll)z*x%P;\n\treturn z;\n}\nint fac[L],inv[L];\nil void getfac(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=(ll)fac[i-1]*i%P;\n\tinv[n]=pwr(fac[n],P-2);\n\tfor(int i=n;i;--i)\n\t\tinv[i-1]=(ll)inv[i]*i%P;\n}\nil int C(int n,int m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\n\nint F[L];\nint get(int x){return x==F[x]?x:F[x]=get(F[x]);}\n\nint To[L<<1],Fs[L],Nx[L<<1],W[L<<1],E;\nil void Add(int x,int y,int z){\n\tTo[++E]=y;\n\tNx[E]=Fs[x];\n\tFs[x]=E;\n\tW[E]=z;\n}\n\nvector<int>vec[L];\n\nint to[L<<1],fs[L],nx[L<<1],w[L<<1],e;\nil void add(int x,int y,int z){\n\tto[++e]=y;\n\tnx[e]=fs[x];\n\tfs[x]=e;\n\tw[e]=z;\n}\n\nint st[L],top;\nint in[L];\n\nint stx[L],wgt[L],tp;\nint num[L],val[L],cnt;\nint vis[L];\nint Flg;\nvoid findcir(int x,int f){\n\tstx[++tp]=x,vis[x]=1;\n\tfor(int i=fs[x];i;i=nx[i]){\n\t\tint k=to[i];\n\t\tif(k==f)continue;\n\t\twgt[tp]=w[i];\n\t\tif(!Flg&&vis[k]){\n\t\t\tFlg=1;\n\t\t\tint lb=tp;\n\t\t\twhile(stx[lb]!=k)--lb;\n\t\t\tfor(int t=lb;t<=tp;++t)\n\t\t\t\tnum[t-lb+1]=stx[t],val[t-lb+1]=wgt[t];\n\t\t\tcnt=tp-lb+1;\n\t\t}\n\t\telse if(!vis[k])findcir(k,x);\n\t}\n\t--tp,vis[x]=0;\n}\n\nint Fa[L];\nint Vis[L],Wgt[L];\nint res;\nint ans[L],siz[L];\nvoid dfs(int x,int f){\n\tsiz[x]=ans[x]=1;\n\tfor(int i=fs[x];i;i=nx[i]){\n\t\tint k=to[i];\n\t\tif(k==f||Vis[k])continue;\n\t\tVis[k]=1,Wgt[k]=w[i];\n\t\tif(w[i]<Wgt[x])Fa[k]=x;\n\t\telse Fa[k]=0;\n\t\tdfs(k,x);\n\t\tif(Fa[k]){\n\t\t\tans[x]=(ll)ans[x]*ans[k]%P*C(siz[x]+siz[k]-1,siz[k])%P;\n\t\t\tsiz[x]+=siz[k];\n\t\t}\n\t}\n}\n\nil int Pre(int x){return x==1?cnt:x-1;}\nil int Nxt(int x){return x==cnt?1:x+1;}\n\nint main(){\n\tint n=rd<int>();\n\tint lim=n<<1;\n\tfor(int i=1;i<=lim;++i)F[i]=i;\n\tfor(int i=1;i<=lim;++i){\n\t\tint x=rd<int>(),y=rd<int>();\n\t\tAdd(x,y+n,x+y),Add(y+n,x,x+y);\n\t\tF[get(x)]=get(y+n);\n\t}\n\tfor(int i=1;i<=lim;++i)\n\t\tvec[get(i)].pb(i);\n\tgetfac(lim);\n\tint Ans=1,Sum=0;\n\tfor(int T=1;T<=lim;++T){\n\t\tif(vec[T].empty())continue;\n\t\ttop=0;\n\t\tint cnta=(int)vec[T].size(),cntb=0;\n\t\tfor(int t=vec[T].size()-1;~t;--t){\n\t\t\tint x=vec[T][t];\n\t\t\tst[++top]=x;\n\t\t\tfor(int i=Fs[x];i;i=Nx[i]){\n\t\t\t\tint k=To[i];\n\t\t\t\tif(get(k)==get(x)){\n\t\t\t\t\t++cntb;\n\t\t\t\t\tadd(x,k,W[i]),++in[k];//反向边在枚举到k时加\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcntb>>=1;\n\t\tif(cnta^cntb)return puts(\"0\"),0;\n\n\n\t\ttp=0,Flg=0;\n\t\tfindcir(st[1],0);\n\n\n\t\tint Res=0,Siz=0;\n\t\tres=1;\n\t\tfor(int i=1;i<=cnt;++i)\n\t\t\tVis[num[i]]=1,Wgt[num[i]]=val[i];\n\t\tfor(int i=1;i<=cnt;++i)\n\t\t\tdfs(num[i],0);\n\t\tfor(int i=1;i<=cnt;++i){\n\t\t\tint nxt=Nxt(i);\n\t\t\tif(Wgt[num[i]]<Wgt[num[nxt]])Fa[num[i]]=num[nxt];\n\t\t\telse Fa[num[i]]=0;\n\t\t}\n\t\tfor(int i=1;i<=cnt;++i){\n\t\t\tif(Fa[num[i]])continue;\n\t\t\tfor(int k=Nxt(i);Fa[num[k]];k=Nxt(k)){\n\t\t\t\tint nxt=Nxt(k);\n\t\t\t\tans[num[nxt]]=(ll)ans[num[nxt]]*ans[num[k]]%P*C(siz[num[nxt]]+siz[num[k]]-1,siz[num[k]])%P;\n\t\t\t\tsiz[num[nxt]]+=siz[num[k]];\n\t\t\t}\n\t\t}\n\t\tSiz=0;\n\t\tfor(int i=1;i<=top;++i){\n\t\t\tif(Fa[st[i]])continue;\n\t\t\tres=(ll)res*ans[st[i]]%P*C(Siz+siz[st[i]],siz[st[i]])%P;\n\t\t\tSiz+=siz[st[i]];\n\t\t}\n\t\tfor(int i=1;i<=top;++i)\n\t\t\tVis[st[i]]=Wgt[st[i]]=0;\n\t\t(Res+=res)%=P;\n\n\t\tres=1;\n\t\tfor(int i=1;i<=cnt;++i)\n\t\t\tVis[num[i]]=1,Wgt[num[i]]=i==1?val[cnt]:val[i-1];\n\t\tfor(int i=1;i<=cnt;++i)\n\t\t\tdfs(num[i],0);\n\t\tfor(int i=1;i<=cnt;++i){\n\t\t\tint nxt=Pre(i);\n\t\t\tif(Wgt[num[i]]<Wgt[num[nxt]])Fa[num[i]]=num[nxt];\n\t\t\telse Fa[num[i]]=0;\n\t\t}\n\t\tfor(int i=1;i<=cnt;++i){\n\t\t\tif(Fa[num[i]])continue;\n\t\t\tfor(int k=Pre(i);Fa[num[k]];k=Pre(k)){\n\t\t\t\tint nxt=Pre(k);\n\t\t\t\tans[num[nxt]]=(ll)ans[num[nxt]]*ans[num[k]]%P*C(siz[num[nxt]]+siz[num[k]]-1,siz[num[k]])%P;\n\t\t\t\tsiz[num[nxt]]+=siz[num[k]];\n\t\t\t}\n\t\t}\n\t\tSiz=0;\n\t\tfor(int i=1;i<=top;++i){\n\t\t\tif(Fa[st[i]])continue;\n\t\t\tres=(ll)res*ans[st[i]]%P*C(Siz+siz[st[i]],siz[st[i]])%P;\n\t\t\tSiz+=siz[st[i]];\n\t\t}\n\t\tfor(int i=1;i<=top;++i)\n\t\t\tVis[st[i]]=Wgt[st[i]]=0;\n\t\t(Res+=res)%=P;\n\n\t\tAns=(ll)Ans*Res%P*C(Sum+cnta,cnta)%P;\n\t\tSum+=cnta;\n\n\n\t\tfor(int i=1;i<=top;++i)\n\t\t\tfs[st[i]]=in[st[i]]=vis[st[i]]=0;//\n\t\te=0;\n\t}\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\nnamespace IO {\n    template <typename _T>\n    inline bool read (_T& x) {\n        x = 0;\n        _T y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return false;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return true;\n    }\n\n    template <typename _T>\n    inline _T input () {\n        _T x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return x;\n    }\n};\nusing namespace IO;\n\nnamespace modular {\n    const int MOD = 1000000007;\n\n    inline int add (int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n\n    inline void inc (int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n\n    inline int mul (int x, int y) { return 1LL * x * y % MOD; }\n\n    inline int qpow (int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x)) if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};\nusing namespace modular;\n\n#define reg register\n#define MAX_N 200007\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define lep(i, l, r) for(int i = l; i < r; ++i)\n#define irep(i, r, l) for(int i = r; i >= l; --i)\n#define ilep(i, r, l) for(int i = r; i > l; --i)\ntypedef long long ll;\n\nstruct edge {\n    int head[MAX_N], to[MAX_N << 1], nxt[MAX_N << 1], val[MAX_N << 1], cap;\n    edge () : cap(0) {}\n    inline void addE (int u, int v, int w = 0) {\n        nxt[++cap] = head[u];\n        head[u] = cap;\n        to[cap] = v;\n        val[cap] = w;\n    }\n}E, en;\n\nint N, M, res = 1, ans = 0, totv, tote, now;\nint dep[MAX_N], st[MAX_N], top, fa[MAX_N], val[MAX_N];\nint vert[MAX_N], tp;\nint deg[MAX_N], fac[MAX_N], ifac[MAX_N];\nbool vis[MAX_N], vise[MAX_N], onc[MAX_N];\n\nbool findcir (int x, int las = 0) {\n    if (vis[x]) return false;\n    totv++;\n    vis[x] = true;\n    vert[++tp] = x;\n    bool flag = false;\n    for (int i = E.head[x]; i; i = E.nxt[i]) {\n        // printf(\"%d %d\\n\", x, E.to[i]);\n        tote++;\n        if (!vis[E.to[i]]) {\n            if (findcir(E.to[i], x)) flag = true;\n        } else if (E.to[i] != las && x != now) {\n            // printf(\"%d %d\\n\", x, E.to[i]);\n            flag = true;\n            now = E.to[i];\n        }\n    }\n    // printf(\"%d %d\\n\", x, flag);\n    if (flag) onc[x] = true, st[++top] = x;\n    // printf(\"%d %d\\n\", x, flag);\n    return flag && (now != x);\n}\n\nvoid getd (int x, int las) {\n    for (int i = E.head[x]; i; i = E.nxt[i])\n        if (E.to[i] != las && !onc[E.to[i]]) {\n            dep[E.to[i]] = dep[x] + 1;\n            fa[E.to[i]] = x, val[E.to[i]] = E.val[i];\n            getd(E.to[i], x);\n        }\n}\n\nvoid getc (int x, int las, int t) {\n    for (int i = E.head[x], v = E.to[i]; i; i = E.nxt[i], v = E.to[i])\n        if (onc[v] && v != las) {\n            fa[x] = v, val[x] = E.val[i];\n            if (v != t) getc(v, x, t);\n        }\n}\n\nint f[MAX_N], sz[MAX_N];\n\ninline int C (int x, int y) {\n    if (x < y || y < 0) return 0;\n    return mul(fac[x], mul(ifac[y], ifac[x - y]));\n}\n\nvoid dp (int x) {\n    // printf(\"%d\\n\", x);\n    sz[x] = f[x] = 1;\n    for (int i = en.head[x], v = en.to[i]; i; i = en.nxt[i], v = en.to[i]) {\n        dp(v);\n        f[x] = mul(f[x], mul(f[v], ifac[sz[v]]));\n        // f[x] = mul(mul(f[x], f[v]), C(sz[x] + sz[v] - 1, sz[v]));\n        sz[x] += sz[v];\n    }\n    f[x] = mul(f[x], fac[sz[x] - 1]);\n}\n\ninline void solve () {\n    en.cap = 0;\n    rep (i, 1, tp) en.head[vert[i]] = 0;\n    en.head[M + 1] = 0;\n    rep (t, 1, tp) {\n        int x = vert[t];\n        // printf(\"%d %d %d\\n\", x, fa[x], val[x]);\n        for (int i = E.head[x], v = E.to[i]; i; i = E.nxt[i], v = E.to[i])\n            if (v != fa[x] && E.val[i] < val[x]) {\n                // printf(\"%d %d\\n\", x, E.to[i]);\n                en.addE(x, E.to[i]);\n                deg[E.to[i]]++;\n            }\n    }\n    rep (i, 1, tp) if (!deg[vert[i]]) {\n        en.addE(M + 1, vert[i]);\n    }\n    rep (i, 1, tp) deg[vert[i]] = 0;\n    dp(M + 1);\n    inc(ans, f[M + 1]);\n}\n\ninline void init () {\n    fac[0] = ifac[0] = 1;\n    rep (i, 1, M) fac[i] = mul(fac[i - 1], i);\n    ifac[M] = qpow(fac[M], MOD - 2);\n    irep (i, M, 2) ifac[i - 1] = mul(ifac[i], i);\n}\n\nint main () {\n    read(N);\n    M = 2 * N;\n    init();\n    int x, y;\n    rep (i, 1, M) {\n        read(x), read(y);\n        // printf(\"%d %d %d\\n\", x, y + N, x + y);\n        E.addE(x, y + N, x + y);\n        E.addE(y + N, x, x + y);\n    }\n    int tot = 0;\n    rep (i, 1, N * 2) if (!vis[i]) {\n        totv = tote = top = tp = 0;\n        findcir(i);\n        // printf(\"%d %d\\n\", tote, totv);\n        // rep (i, 1, top) printf(\"%d \", st[i]); puts(\"\");\n        // break;\n        if (tote != totv * 2) { res = 0; break; }\n        tot += totv;\n        rep (i, 1, top) {\n            dep[st[i]] = 0;\n            getd(st[i], 0);\n        }\n        ans = 0;\n        int u = st[1];\n        for (int j = E.head[u]; j; j = E.nxt[j])\n            if (onc[E.to[j]]) {\n                // printf(\"%d %d\\n\", u, E.to[j]);\n                fa[u] = E.to[j];\n                val[u] = E.val[j];\n                getc(E.to[j], u, u);\n                solve();\n                // printf(\"%d\\n\", ans);\n                // return 0;\n            }\n        // printf(\"%d\\n\", ans);\n        res = mul(mul(res, ans), C(tot, totv));\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct union_find {\n    vi P, R, S;\n\n    union_find(int N) {\n        P.resize(N), R.resize(N, 0), S.resize(N, 1);\n        for (int i = 0; i < N; i++)\n            P[i] = i;\n    }\n\n    int rep(int i) {\n        if(P[i] != i) P[i] = rep(P[i]);\n        return P[i];\n    }\n\n    bool unio(int a, int b) {\n        a = rep(a), b = rep(b);\n        if(a == b) return false;\n        if(R[a] < R[b]) swap(a, b);\n        P[b] = a;\n        S[a] += S[b];\n        if(R[a] == R[b]) R[a]++;\n        return true;\n    }\n};\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\nusing mn = modnum<int(1e9 + 7)>;\nusing vmn = vector<mn>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    vvi adj(2 * N);\n    union_find uf(2 * N);\n\n    for (int i = 0, x, y; i < 2 * N; i++) {\n        cin >> x >> y;\n        uf.unio(--x, --y + N);\n        adj[x].push_back(y + N);\n        adj[y + N].push_back(x);\n    }\n\n    vvi comp(2 * N);\n    for (int i = 0; i < 2 * N; i++) {\n        comp[uf.rep(i)].push_back(i);\n    }\n\n    auto comb = [](const pair<int, mn>& a, const pair<int, mn>& b) -> pair<int, mn> {\n        return { a.first + b.first,\n            mn::ncr(a.first + b.first, a.first) * a.second * b.second };\n    };\n\n    pair<int, mn> ans = { 0, 1 };\n\n    vi deg(2 * N), assign(2 * N, -1);\n    for (const vi& grp : comp) if (sz(grp)) {\n        vector<pair<int, int>> edges;\n        for (int x : grp) {\n            deg[x] = sz(adj[x]);\n            if (x < N) for (int y : adj[x])\n                edges.emplace_back(x, y);\n        }\n        if (sz(grp) != sz(edges)) { cerr << \"Bad group\\n\"; ans.second = 0; break; }\n\n        sort(all(edges));\n        auto inx = [&](int x, int y) {\n            if (x > y) swap(x, y);\n            return lower_bound(all(edges), make_pair(x, y)) - edges.begin();\n        };\n\n        queue<int> leaf;\n        for (int v : grp) if (deg[v] == 1) leaf.push(v);\n        for (; !leaf.empty(); leaf.pop()) {\n            int v = leaf.front();\n            for (int u : adj[v]) if (deg[u] > 1) {\n                assign[v] = inx(v, u);\n                if (--deg[u] == 1)\n                    leaf.push(u);\n            }\n        }\n\n        auto go = [&](auto&& self, vvi& tree, int loc) -> pair<int, mn> {\n            pair<int, mn> res = { 0, 1 };\n            for (int ch : tree[loc])\n                res = comb(res, self(self, tree, ch));\n            res.first++;\n            return res;\n        };\n\n        auto ct = [&](){\n            vvi tree(sz(edges) + 1); vi par(sz(edges) + 1, -1);\n            auto arc = [&](int p, int c) {\n                tree[p].push_back(c);\n                par[c] = p;\n            };\n\n            for (int v : grp) {\n                int e = assign[v];\n                int x, y; tie(x, y) = edges[e];\n                if (v >= N) for (int xn : adj[v]) {\n                    if (xn < x && edges[assign[xn]] == make_pair(xn, y))\n                        arc(e, assign[xn]);\n                }\n                else for (int yn : adj[v]) {\n                    if (yn < y && edges[assign[yn]] == make_pair(x, yn))\n                        arc(e, assign[yn]);\n                }\n            }\n\n            for (int i = 0; i < sz(edges); i++)\n                if (par[i] == -1)\n                    arc(sz(edges), i);\n            return go(go, tree, sz(edges));\n        };\n\n        int cyc = -1;\n        for (int v : grp) if (assign[v] == -1) {\n            assert(deg[v] == 2);\n            cyc = v;\n        }\n\n        pair<int, mn> tot = { sz(grp), 0 };\n        for (int u : adj[cyc]) if (deg[u] == 2) {\n            assign[cyc] = inx(cyc, u);\n            for (int loc = u, prv = cyc; loc != cyc; ) {\n                for (int nbr : adj[loc]) if (deg[nbr] == 2) {\n                    assign[loc] = inx(loc, nbr);\n                    if (assign[loc] == assign[prv]) continue;\n                    prv = loc;\n                    loc = nbr;\n                    break;\n                }\n            }\n            tot.second += ct().second;\n        }\n        ans = comb(ans, tot);\n    }\n\n    cout << ans.second << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define f1(a,b,c) for(int c=a;c<=b;c++)\n#define f2(a,b,c) for(int c=a;c>=b;c--)\n#define f3(a,b,c) for(int c=a;c;c=b)\n#define so1(a,n) sort(a+1,a+n+1,mycmp);\n#define so2(a,n) sort(a+1,a+n+1);\n#define ll long long\n#define itn int\n#define ubt int \n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\nconst int twx=4e5+100;\nconst int inf=0x3f3f3f3f;\nconst int MOD=1e9+7;\nll read()\n{\n    ll sum=0;\n    ll flag=1;\n    char c=getchar();\n    while(c<'0'||c>'9')  \n    {\n        if(c=='-')\n        {\n            flag=-1;\n        }\n        c=getchar();\n    }\n    while(c>='0'&&c<='9')\n    {\n        sum=((sum*10)+c-'0');\n        c=getchar();\n    }\n    return sum*flag;\n}\nint n;\nint fac[twx];\nint inv[twx];\nstruct LV \n{\n    int y;\n    int Next;\n}a[twx];\nint Link[twx];\nint len;\nstruct LV_\n{\n    int y_;\n    int Next_;\n}a_[twx];\nint Link_[twx];\nint len_;\nint du[twx];\nint cnt=0;\nvector<int> cur;\nqueue<int> q;\nint cir[twx];\nint ans=1;\nint vis[twx];\nint choose[twx];\nint asd[twx];\nint Size[twx];\nvoid Insert(int x,int y)\n{\n    a[++len].y=y;\n    a[len].Next=Link[x];\n    Link[x]=len;\n}\nvoid Insert_(int x,int y)\n{\n    a_[++len_].y_=y;\n    a_[len_].Next_=Link_[x];\n    Link_[x]=len_;\n}\nll add(ll x,ll y)\n{\n    return x+y>=MOD?x+y-MOD:x+y;\n}\nll sub(ll x,ll y)\n{\n    return x-y<0?x-y+MOD:x-y;\n}\nll mul(ll x,ll y)\n{\n    return 1LL*x*y%MOD;\n}\nint C(int a, int b)\n{\n    return 1ll*fac[a]*inv[b]%MOD*inv[a-b]%MOD;\n}\nvoid Search(int x)\n{\n    cir[++cir[0]]=x;\n    vis[x]=1;\n    f3(Link[x],a[i].Next,i)\n    {\n        int y=a[i].y;\n        if(!vis[y])\n        {\n            Search(y);\n        }\n    }\n}\nint calc()\n{\n    f1(0,(int)cur.size()-1,i)\n    {\n        du[i]=Link_[i]=0;\n    }\n    f1(0,(int)cur.size()-1,i)\n    {\n        f3(Link[i],a[j].Next,j)\n        {\n            int y=a[j].y;\n            cout<<i<<\" asd\\n\";\n            cout<<choose[i]<<\" asdasdasdasd\\n\";\n            if(y<choose[i])\n            {\n                Insert_(y,i);\n                du[i]++;\n            }\n        }\n    }\n    f1(0,(int)cur.size()-1,i)\n    {\n        if(!du[i])\n        {\n            q.push(i);\n        }\n        asd[i]=1;\n        Size[i]=1;\n    }\n    int sz=0;\n    int ans=1;\n    while(!q.empty())\n    {\n        int x=q.front();\n        int flag=0;\n        q.pop();\n        f3(Link_[x],a_[i].Next_,i)\n        {\n            flag=1;\n            int y=a_[i].y_;\n            du[y]--;\n            Size[y]+=Size[x];\n            asd[y]=1LL*asd[y]*asd[x]%MOD*C(Size[y]-1,Size[x])%MOD;\n            if(!du[y])\n            {\n                q.push(y);\n            }\n        }\n        if(!flag)\n        {\n            sz+=Size[x];\n            ans+=1LL*ans*asd[x]%MOD*C(sz,Size[x])%MOD;\n        }\n    }\n    return ans;\n}\nint solve()\n{\n    if((int)cur.size()!=cnt)\n    {\n        return 0;\n    }\n    f1(0,(int)cur.size()-1,i)\n    {\n        if(du[i]==1)\n        {\n            q.push(i);\n        }\n    }\n    while(!q.empty())\n    {\n        int x=q.front();\n        q.pop();\n        f3(Link[x],a[i].Next,i)\n        {\n            int y=a[i].y;\n            if(du[y]!=1)\n            {\n                du[y]--;\n                choose[x]=y;\n                if(du[y]==1)\n                {\n                    q.push(y);\n                }\n            }\n        }\n    }\n    int st=0;\n    f1(0,(int)cur.size()-1,i)\n    {\n        if(du[i]>1)\n        {\n            st=i;\n            vis[i]=0;\n        }\n    }\n    cir[0]=0;\n    Search(st);\n    cir[cir[0]+1]=cir[1];\n    f1(1,cir[0],i)\n    {\n        choose[cir[i]]=cir[i+1];\n    }\n    int res=calc();\n    f1(2,cir[0]+1,i)\n    {\n        choose[cir[i]]=cir[i-1];\n    }\n    res+=calc();\n    if(res>=MOD)\n    {\n        res-=MOD;\n    }\n    f1(0,(int)cur.size()-1,i)\n    {\n        vis[i]=1;\n    }\n    return res;\n}\nvoid pre()\n{\n    fac[0]=1;\n    f1(1,n<<1,i)\n    {\n        fac[i]=mul(fac[i-1],i);\n    }\n    inv[0]=inv[1]=1;\n    f1(2,n<<1,i)\n    {\n        inv[i]=MOD-(ll)MOD/i*inv[MOD%i]%MOD;\n    }\n    f1(2,n<<1,i)\n    {\n        inv[i]=(ll)inv[i]*inv[i-1]%MOD;\n    }\n}\nvoid dfs(int x)\n{\n    vis[x]=1;\n    cur.pb(x);\n    f3(Link[x],a[i].Next,i)\n    {\n        ++cnt;\n        int y=a[i].y;\n        if(!vis[y])\n        {\n            dfs(y);\n        }\n    }\n}\nvoid init()\n{\n\tn=read();\n    f1(1,n<<1,i)\n    {\n        int x=read(); \n        int y=read();\n        Insert(x,y+n);\n        Insert(y+n,x);\n        du[x]++;\n        du[y+n]++;\n    }\n}\nvoid work()\n{\n\tint tsize=0;\n    f1(1,n<<1,i)\n    {\n        if(!vis[i])\n        {\n            cur.clear();\n            cnt=0;\n            dfs(i);\n            cnt/=2;\n            int res=solve();\n            tsize+=cnt;\n            ans=1LL*ans*res%MOD*C(tsize,cnt)%MOD;\n        }\n    }\n}\nvoid print()\n{\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n    pre();\n    init();\n    work();\n    print();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll int\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(int i=int(x);i<int(y);++i)\n#define For(i,x,y)  for(int i=int(x);i<=int(y);++i)\n#define FOr(i,x,y)  for(int i=int(x);i>=int(y);--i)\n#define pi acos(-1) \n#define mk make_pair\n#define pa pair<ll,ll>\n#define lf else if\n#define IL inline\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n#define Add(x,y)    ((x)=((x)+(y))%mod)\n#define Max(x,y)    ((x)=((x)<(y)?(y):(x)))\n#define Min(x,y)    ((x)=((x)>(y)?(y):(x)))\n#define E(x)        return writeln(x),0\n#define LL\t\t\t(long long)\n#define p(x)        printf(\"~%lld~\\n\",LL(x))\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",LL(x),LL(y))\n#define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",LL(x),LL(y),LL(z))\n#define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\n#define GuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_; \n#endif \n#define NEG 1\n    static const int GYN=2333333;\n    char SZB[GYN],*SS=SZB,*TT=SZB;\n    inline char gc(){   if (SS==TT){  TT=(SS=SZB)+fread(SZB,1,GYN,stdin); if (SS==TT) return '\\n';  }   return *SS++;    }\n#if NEG\n    inline ll read(){    ll x=0,g=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') g=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*g; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n\tvoid Print(long long *a,int s,int t){For(i,s,t)printf(\"%lld \",a[i]);}\n\tvoid Print(int *a,int s,int t){For(i,s,t)printf(\"%d \",a[i]);}\n\tvoid Print(char *a,int s,int t){For(i,s,t)putchar(a[i]);}\n\tvoid writeln(ll x){write(x);puts(\"\");}\n}using namespace SHENZHEBEI;\nconst int N=500105,mod=1e9+7;\nbool f[5010];\nvector<ll>g[5010];\nll ans[5010],should[5010],fa[5010],n;\nvoid dfs(ll x){\n\tll cogito=0,sum=0;\n\tmemset(f,0,sizeof f);f[0]=1;\n\trep(i,0,g[x].size()){\n\t\tll to=g[x][i];\n\t\tdfs(to);\n\t\tsum+=ans[to]+should[to];\n\t\tFOr(j,should[x],0)f[j]=\t(j>=ans[to]?f[j-ans[to]]:0)|\n\t\t\t\t\t\t\t\t(j>=should[to]?f[j-should[to]]:0);\n\t}\n\tFOr(i,should[x],0)if (f[i]){\n\t\t ans[x]=min(5001,sum-i);\n\t\t return;\n\t}\n\tputs(\"IMPOSSIBLE\");exit(0);\n}\nint main(){\n\tn=read();\n\tFor(i,2,n)g[read()].push_back(i);\n\tFor(i,1,n)should[i]=read();\n\tdfs(1);puts(\"POSSIBLE\");\n\tFor(i,1,n)writeln(ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nchar buf[1 << 20], *p1, *p2;\n#define getchar() ((p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)\n\ntemplate<typename T>\nvoid read(T &x) \n{\n\tx = 0;\n\tint f = 1; char c = getchar();\n\twhile (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }\n\twhile (isdigit(c)) { x = x * 10 + c - 48; c = getchar(); }\n\tx *= f;\n}\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G, loop;\nint dfn[MAXN], fa[MAXN], s, t, cnt = 0, edge = 0;\nvoid GetLoop(int x) // 找环 \n{\n\tG.push_back(x); // 森林中的一棵树 \n\tdfn[x] = ++cnt;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == fa[x])\n\t\t\tcontinue;\n\t\tif (dfn[y]) \n\t\t{\n\t\t\tif (dfn[y] < dfn[x]) continue;\n\t\t\tloop.push_back(y);\n\t\t\tfor (; y != x; y = fa[y])\n\t\t\t\tloop.push_back(fa[y]);\n\t\t}\n\t\telse { fa[y] = x; GetLoop(y); }\n\t}\n} \n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[cnt];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tread(n);\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!dfn[i])\n\t\t{\n\t\t\tcnt = edge = 0;\n\t\t\tGetLoop(i);\n\t\t\tif (cnt << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\ts = loop[0], t = loop[loop.size() - 1]; // 环的起点、终点 \n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tloop.clear();\n\t\t\tG.clear();\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            return use_generic(i, true) * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            return use_generic(i, false) * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        try {\n            REP (y, n) acc = acc * go_row(y);\n            REP (x, n) acc = acc * go_col(x);\n        } catch (bool e) {\n            assert (not e);\n            acc.size = -1;\n        }\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n\nconst int kN = 200000 + 5;\nconst int MOD = (int)1e9 + 7;\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a < 0) a += MOD;\n    else if (a >= MOD) a -= MOD;\n}\n\ninline int mul(int x)\n{\n    return x;\n}\n\ntemplate<typename... Args>\ninline int mul(int x, Args... args)\n{\n    return x * 1ll * mul(args...) % MOD;\n}\n\n\nint n;\nstd::vector<int> edges[kN], tree[kN];\nbool vis[kN], in[kN];\nstd::vector<int> vec;\nint F[kN], Finv[kN], Inv[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return mul(F[a], Finv[b], Finv[a - b]);\n}\n\nint dfs(int u)\n{\n    int ret = 1;\n    vis[u] = true;\n    vec.emplace_back(u);\n    for (int v : edges[u]) if (!vis[v])\n        ret -= dfs(v);\n    return ret;\n}\n\nbool find_cycle(int u, int fa, int &s, int &t)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != fa) {\n        if (vis[v]) {\n            s = u;\n            t = v;\n            return true;\n        } else if (find_cycle(v, u, s, t)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int u, int target)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != target) {\n        if (!vis[v])\n            dfs2(v, u);\n        // printf(\"(u, target): (%d, %d)\\n\", u, target);\n        if (v < target) {\n            tree[u].emplace_back(v);\n            // printf(\"%d->%d\\n\", u, v);\n            in[v] = true;\n        }\n    }\n}\n\nusing Val = std::pair<int, int>;\n\nVal combine(Val a, Val b)\n{\n    return Val(a.first + b.first, mul(a.second, b.second, binom(a.first + b.first, a.first)));\n}\n\nVal calc(int u)\n{\n    Val ret(0, 1);\n    for (int v : tree[u]) {\n        ret = combine(ret, calc(v));\n    }\n    ret.first ++;\n    // printf(\"u = %d, ret = (%d, %d)\\n\", u, ret.first, ret.second);\n    return ret;\n}\n\nstd::pair<int, int> solve(int u)\n{\n    vec.clear();\n    if (dfs(u))\n        return std::make_pair(0, 0);\n    int e = 0;\n    for (int v : vec)\n        e += edges[v].size();\n    if (e / 2 != vec.size()) {\n        return std::make_pair(0, 0);\n    }\n\n    for (int v : vec) vis[v] = false;\n    int s, t;\n    assert(find_cycle(u, -1, s, t));\n    int ways = 0;\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(s, t);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve0::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(t, s);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve1::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    return std::make_pair(vec.size(), ways);\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = mul(MOD - MOD / i, Inv[MOD % i]);\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = mul(F[i - 1], i);\n        Finv[i] = mul(Finv[i - 1], Inv[i]);\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n * 2; ++ i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b); a --; b --;\n        edges[a].emplace_back(n + b);\n        edges[n + b].emplace_back(a);\n    }\n    Val val(0, 1);\n    for (int i = 0; i < n; ++ i) if (!vis[i]) {\n        val = combine(val, solve(i));\n    }\n    printf(\"%d\\n\", val.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n\n#define fir first\n#define sec second\n\nusing namespace std;\nusing LL = long long;\nusing pii = pair<int, int>;\n\nconst int maxN = 2e5 + 5;\nconst int mod = 1e9 + 7;\n\nint n, ans = 1, curs, tmps;\nint fac[maxN], inv[maxN];\nint pre[maxN], deg[maxN], val[maxN], size[maxN], fa[maxN], prod[maxN];\nbitset<maxN> vis;\nvector<int> wib;\nvector<pii> G[maxN];\nvector<int> newG[maxN];\n\ninline void Mod(int& x)\n{ x >= mod ? x -= mod : x < 0 ? x += mod : 0; }\n\nint QPow(int bas, int ind)\n{\n    int res = 1;\n    while (ind)\n    {\n        if (ind & 1)\n            res = (LL)res * bas % mod;\n        bas = (LL)bas * bas % mod;\n        ind >>= 1;\n    }\n    return res;\n}\n\ninline int C(int n, int m)\n{ return (LL)fac[n] * inv[m] % mod * inv[n - m] % mod; }\n\nvoid Init(int lim)\n{\n    fac[0] = inv[0] = 1;\n    for (int i = 1; i <= lim; ++i)\n        fac[i] = (LL)fac[i - 1] * i % mod;\n    inv[lim] = QPow(fac[lim], mod - 2);\n    for (int i = lim - 1; i; --i)\n        inv[i] = (LL)inv[i + 1] * (i + 1) % mod;\n}\n\nvoid Topsort()\n{\n    static queue<int> q;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (deg[i] == 1)\n            q.push(i);\n        if (deg[i] == 0)\n        {\n            cout << 0 << endl;\n            exit(0);\n        }\n    }\n    while (!q.empty())\n    {\n        int u = q.front();\n        deg[u] = -1, q.pop();\n        for (auto i : G[u]) if (~deg[i.fir])\n        {\n            val[u] = i.sec;\n            if (--deg[i.fir] == 1)\n                q.push(i.fir);\n            if (deg[i.fir] == 0)\n            {\n                cout << 0 << endl;\n                exit(0);\n            }\n        }\n    }\n}\n\nvoid DFS(int u)\n{\n    for (auto i : G[u]) if (deg[i.fir] == 2 and i.sec != val[u])\n    {\n        if (!pre[i.fir])\n        {\n            pre[i.fir] = u, val[i.fir] = i.sec;\n            DFS(i.fir);\n        }\n        else\n            pre[i.fir] = u, val[i.fir] = i.sec;\n    }\n}\n\nvoid Getlink(int u)\n{\n    vis.set(u), wib.push_back(u);\n    for (auto i : G[u]) if (!vis[i.fir])\n        Getlink(i.fir);\n}\n\nvoid Getsize(int u)\n{\n    if (size[u])\n        return;\n    size[u] = prod[u] = 1;\n    for (auto i : G[u])\n        if (i.sec != val[u] and val[i.fir] < val[u])\n        {\n            fa[i.fir] = u;\n            Getsize(i.fir);\n            prod[u] = (LL)prod[u] * prod[i.fir] % mod;\n            size[u] += size[i.fir];\n        }\n    prod[u] = (LL)prod[u] * size[u] % mod;\n}\n\nint Getans()\n{\n    int siz = 1, pd = 1;\n    for (int i : wib)\n        size[i] = fa[i] = 0;\n    for (int i : wib)\n        if (!fa[i])\n            Getsize(i);\n    for (int i : wib)\n        if (!fa[i])\n            siz += size[i], pd = (LL)pd * prod[i] % mod;\n    tmps = siz - 1;\n    return (LL)fac[siz] * QPow((LL)pd * siz % mod, mod - 2) % mod;\n}\n\nint rt;\nvoid Rev(int u)\n{\n    if (pre[u] != rt)\n        Rev(pre[u]);\n    val[pre[u]] = val[u];\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n;\n    n <<= 1;\n    for (int i = 1; i <= n; ++i)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].emplace_back(y + (n >> 1), x + y);\n        G[y + (n >> 1)].emplace_back(x, x + y);\n        ++deg[x], ++deg[y + (n >> 1)];\n        // cout << x << ' ' << y + (n >> 1) << ' ' << x + y << endl;\n    }\n    Init(maxN - 2), Topsort();\n    //for (int i = 1; i <= n; ++i)\n    //    cout << deg[i] << endl;\n    for (int i = 1; i <= n; ++i)\n        if (deg[i] == 2 and !pre[i])\n        {\n            pre[i] = -1, DFS(i);\n            Getlink(i);\n            int res = Getans(), tmp = val[i];\n            rt = i, Rev(i), val[pre[i]] = tmp;\n            // for (int i = 1; i <= n; ++i)\n            // cout << val[i] << endl;\n            Mod(res += Getans());\n            ans = (LL)ans * res % mod * C(curs + tmps, tmps) % mod;\n            curs += tmps;\n            wib.clear();\n            // cout << res << ' ' << tmps << ' ' << ans << endl;\n        }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\nint fac[200111],invf[200111];\nint cal(int x,int y){return 1ll*fac[x+y]*invf[x]%mod*invf[y]%mod;}\npii comb(pii x,pii y){return mp(1ll*x.ff*y.ff%mod*cal(x.ss,y.ss)%mod,x.ss+y.ss);}\n\nvector<int> g[200111],g2[200111];\nint n,vs[200111],tot,cyc[200111],len,to[200111],dgr[200111];\n\nbool incyc[200111],use[200111];\nint stk[200111],top,cnt,dep[200111];\n\npii dfs2(int x)\n{\n\tif(use[x])return mp(1,0);\n\tuse[x]=1;\n\tpii ret=mp(1,0);\n\tfor(int i=0;i<(int)g2[x].size();i++)\n\t\tret=comb(ret,dfs2(g2[x][i]));\n\tret.ss++;return ret;\n}\nvoid dfs(int x,int f=0)\n{\n\tstk[++top]=x;dep[x]=top;cnt++;\n\tvs[++tot]=x;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t{\n\t\tif(g[x][i]==f)continue;\n\t\tcnt--;\n\t\tif(!dep[g[x][i]])\n\t\t\tdfs(g[x][i],x);\n\t\telse if(dep[g[x][i]]<dep[x])\n\t\t{\n\t\t\tlen=0;\n\t\t\tfor(int j=dep[g[x][i]];j<=top;j++){cyc[++len]=stk[j];incyc[stk[j]]=1;}\n\t\t}\n\t\telse cnt++;\n\t}\n\ttop--;\n}\nvoid rdfs(int x,int f=0)\n{\n\tto[x]=f;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f&&!incyc[g[x][i]])\n\t\t\trdfs(g[x][i],x);\n}\n\nint calc()\n{\n\tfor(int i=1;i<=tot;i++){g2[vs[i]].clear();dgr[vs[i]]=use[vs[i]]=0;}\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tfor(int j=0;j<(int)g[vs[i]].size();j++)\n\t\t{\n\t\t\tif(to[vs[i]]>g[vs[i]][j])\n\t\t\t{\n\t\t\t\tg2[vs[i]].pb(g[vs[i]][j]);\n\t\t\t\tdgr[g[vs[i]][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tpii ret=mp(1,0);\n\tfor(int i=1;i<=tot;i++)if(dgr[vs[i]]==0)ret=comb(ret,dfs2(vs[i]));\n\treturn ret.ff;\n}\nint main()\n{\n\tfac[0]=invf[0]=1;for(int i=1;i<200111;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinvf[200111-1]=power(fac[200111-1],mod-2);\n\tfor(int i=200111-2;i>=0;i--)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\t\n\tget1(n);\n\tfor(int i=1,x,y;i<=n+n;i++)\n\t{\n\t\tget2(x,y);\n\t\tg[x].pb(y+n);\n\t\tg[y+n].pb(x);\n\t}\n\tn<<=1;\n\t\n\tpii now=mp(1,0);\n\tfor(int _=1;_<=n;_++)\n\t{\n\t\tif(dep[_])continue;\n\t\ttot=0;dfs(_);\n\t\tif(cnt)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=len;i++)rdfs(cyc[i]);\n\t\tint sum=0;\n\t\tfor(int i=1;i<=len;i++)to[cyc[i]]=cyc[i%len+1];\n\t\tsum+=calc();\n\t\tfor(int i=1;i<=len;i++)to[cyc[i%len+1]]=cyc[i];\n\t\tsum+=calc();if(sum>=mod)sum-=mod;\n\t\tnow=comb(now,mp(sum,tot));\n\t}\n\t\n\tprintendl(now.ff);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <cstdlib>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n#define pb push_back\n\nusing namespace std;\n\nconst int N = 200010;\nconst int Mod = 1e9 + 7;\n\ntypedef long long LL;\n\nLL Pow(LL x, LL e){\n\tLL ret = 1;\n\twhile(e){\n\t\tif(e & 1) ret = ret * x % Mod;\n\t\tx = x * x % Mod;\n\t\te >>= 1;\n\t}\n\treturn ret;\n}\n\nLL fac[N], inv[N];\n\nvoid init(int n){\n\tfac[0] = 1;\n\tFor(i, 1, n) fac[i] = fac[i - 1] * i % Mod;\n\tinv[n] = Pow(fac[n], Mod - 2);\n\tForr(i, n - 1, 0) inv[i] = inv[i + 1] * (i + 1) % Mod;\n}\n\ninline LL C(int n, int m){\n\treturn fac[n] * inv[m] % Mod * inv[n - m] % Mod;\n}\n\nvector<int> G[N];\n\nbool vis[N];\nint stk[N], cir[N], ver[N], c, m, sume, sumv;\nbool flag;\n\nvoid DFS(int o, int f){\n\tstk[++c] = o;\n\tver[++sumv] = o;\n\tvis[o] = true;\n\tfor(int v : G[o]){\n\t\t++sume;\n\t\tif(v == f) continue;\n\t\tif(!vis[v]) DFS(v, o);\n\t\telse if(!flag){\n\t\t\tflag = true;\n\t\t\tint x = c;\n\t\t\twhile(stk[c] != v) cir[++m] = stk[c--];\n\t\t\tcir[++m] = stk[c--];\n\t\t\tc = x;\n\t\t}\n\t}\n\t--c;\n}\n\nbool oncir[N];\nint match[N];\n\nvoid DFS_init(int o, int f = 0){\n\tif(f) match[o] = f;\n\tfor(int v : G[o]){\n\t\tif(oncir[v] || v == f) continue;\n\t\tDFS_init(v, o);\n\t}\n}\n\nvector<int> S[N];\nbool calced[N];\nint sz[N], f[N];\n\nvoid DFS_calc(int o){\n\tsz[o] = 0;\n\tcalced[o] = true;\n\tf[o] = 1;\n\tfor(int v : S[o]){\n\t\tDFS_calc(v);\n\t\tf[o] = 1LL * C(sz[o] + sz[v], sz[v]) * f[o] % Mod * f[v] % Mod;\n\t\tsz[o] += sz[v];\n\t}\n\t++sz[o];\n}\n\nint ind[N];\n\nint work(){\n\tS[0].clear();\n\tFor(i, 1, sumv) ind[ver[i]] = 0;\n\tFor(i, 1, sumv){\n\t\tint o = ver[i];\n\t\tS[o].clear(), calced[o] = false;\n\t\tfor(int j = 0; G[o][j] != match[o]; ++j) S[o].pb(G[o][j]), ind[G[o][j]]++;\n\t}\n\tFor(i, 1, sumv) if(!ind[ver[i]]) S[0].pb(ver[i]);\n\tDFS_calc(0);\n\treturn f[0];\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tinit(2 * n);\n\tFor(i, 1, 2 * n){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].pb(y + n), G[y + n].pb(x);\n\t}\n\tn *= 2;\n\tFor(i, 1, n) sort(G[i].begin(), G[i].end());\n\tint ans = 1;\n\tint pre = 0;\n\tFor(i, 1, n){\n\t\tif(vis[i]) continue;\n\t\tc = m = sume = sumv = 0, flag = false;\n\t\tDFS(i, 0);\n\t\tif(sume != sumv * 2){\n\t\t\tans = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t//For(j, 1, sumv) printf(\"%d%c\", ver[j], j == sumv ? '\\n' : ' ');\n\t\tFor(j, 1, m) oncir[cir[j]] = true;//, printf(\"%d%c\", cir[j], j == m ? '\\n' : ' ');\n\t\tFor(j, 1, m) DFS_init(cir[j]);\n\n\t\tFor(j, 1, m - 1) match[cir[j]] = cir[j + 1];\n\t\tmatch[cir[m]] = cir[1];\n\t\tint ret = work();\n\n\t\tFor(j, 2, m) match[cir[j]] = cir[j - 1];\n\t\tmatch[cir[1]] = cir[m];\n\t\tret += work();\n\n\t\tans = 1LL * ans * ret % Mod * C(sumv + pre, sumv) % Mod;\n\t\tpre += sumv;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nstruct StronglyConnectedComponent {\n        int n;\n        vector<bool> used;\n        vector<int> order, cmp;\n        vector<vector<int>> g, rg;\n        StronglyConnectedComponent(int x) {\n                n = x;\n                g.resize(x);\n                rg.resize(x);\n                used.resize(x);\n                cmp.resize(x);\n        }\n        void add_edge(int from, int to) {\n                g[from].push_back(to);\n                rg[to].push_back(from);\n        }\n        void dfs(int u) {\n                used[u] = true;\n                for (auto v : g[u]) if (!used[v]) {\n                        dfs(v);\n                }\n                order.push_back(u);\n        }\n        void rdfs(int u, int k) {\n                used[u] = true;\n                cmp[u] = k;\n                for (auto v : rg[u]) if (!used[v]) {\n                        rdfs(v, k);\n                }\n        }\n        int init() {\n                used.assign(n, false);\n                for (int u = 0; u < n; u ++) {\n                        if (!used[u]) {\n                                dfs(u);\n                        }\n                }\n                used.assign(n, false);\n                int k = 0;\n                for (int i = order.size() - 1; i >= 0; i --) {\n                        if (!used[order[i]]) {\n                                rdfs(order[i], k ++);\n                        }\n                }\n                return k;\n        }\n};\n\nconst int N = 5000001;\nlong long fact[N];\nlong long invfact[N];\nlong long inv[N];\nvoid init() {\n        fact[0] = fact[1] = 1;\n        for (int i = 2; i < N; i ++) fact[i] = fact[i - 1] * i % MOD;\n        inv[1] = 1;\n        for (int i = 2; i < N; i ++) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;\n        invfact[0] = invfact[1] = 1;\n        for (int i = 2; i < N; i ++) invfact[i] = invfact[i - 1] * inv[i] % MOD;\n}\nlong long C(long long n, long long r) {\n        if (n < 0 || r < 0 || n < r) return 0;\n        return fact[n] * invfact[n - r] % MOD * invfact[r] % MOD;\n}\n\n// ここに有向木のトポロジカルソート順の総数を求める関数を貼る\nlong long calc(vector<vector<int>> &forest) {\n\t/*\n\tint n = forest.size();\n\tStronglyConnectedComponent scc(n);\n\tfor (int i = 0; i < n; i ++) {\n\t\tfor (auto j : forest[i]) {\n\t\t\tscc.add_edge(i, j);\n\t\t\tcerr << i << ' ' << j << endl;\n\t\t}\n\t}\n\tscc.init();\n\tvector<int> idx(n);\n\trep(i, n) idx[i] = i;\n\tsort(idx.begin(), idx.end(), [&](const int &i, const int &j) {\n\t\treturn scc.cmp[i] < scc.cmp[j];\n\t});\n\tvector<bool> used(n);\n\tlong long res = 1;\n\tlong long resres = 1;\n\tint tot = 0;\n\tfunction<int (int, int)> dfs = [&](int u, int prev) {\n\t\tused[u] = true;\n\t\tint total = 0;\n\t\tfor (auto v : forest[u]) if (v != prev) {\n\t\t\tint szsz = dfs(v, u);\n\t\t\ttotal += szsz;\n\t\t\t(resres *= C(total, szsz)) %= MOD;\n\t\t}\n\t\treturn tot + 1;\n\t};\n\tfor (int i = 0; i < n; i ++) {\n\t\tint u = idx[i];\n\t\tif (!used[u]) {\n\t\t\tresres = 1;\n\t\t\tint sz = dfs(u, -1);\n\t\t\ttot += sz;\n\t\t\t(res *= C(tot, sz)) %= MOD;\n\t\t\t(res *= resres) %= MOD;\n\t\t}\n\t}\n\treturn res;\n\t*/\n\treturn 0;\n}\n\nint main() {\n\tinit();\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<vector<int>> g(2 * n);\n\trep(i, 2 * n) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx --, y --;\n\t\tg[x].push_back(y + n);\n\t\tg[y + n].push_back(x);\n\t}\n\n\tvector<vector<bool>> used(3, vector<bool> (n));\n\tvector<set<pair<int, int>>> eused(3);\n\tint ec = 0, nc = 0;\n\tvector<int> target(n, -1), app;\n\tint on_cycle = -1;\n\tfunction<void (int, int, int)> dfs = [&](int u, int prev, int num) {\n\t\tapp.push_back(u);\n\t\tnc ++;\n\t\tused[num][u] = true;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tif (eused[num].count(make_pair(min(u, v), max(u, v))) == 0) {\n\t\t\t\ttarget[v] = u;\n\t\t\t\teused[num].insert(make_pair(min(u, v), max(u, v)));\n\t\t\t\tec ++;\n\t\t\t\tif (used[num][v]) {\n\t\t\t\t\ton_cycle = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!used[num][v]) {\n\t\t\t\tdfs(v, u, num);\n\t\t\t}\n\t\t}\n\t};\n\tlong long ans = 1;\n\trep(i, 2 * n) if (!used[0][i]) {\n\t\tec = 0, nc = 0;\n\t\tdfs(i, -1, 0);\n\t\tif (ec != nc) {\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tlong long tmp = 0;\n\t\t// define target\n\t\tapp.clear();\n\t\tdfs(on_cycle, -1, 1);\n\t\t{\n\t\t\tmap<int, int> mp;\n\t\t\tint k = 0;\n\t\t\tfor (auto a : app) {\n\t\t\t\tassert(target[a] != -1);\n\t\t\t\tmp[a] = k ++;\n\t\t\t}\n\t\t\tvector<vector<int>> ggg(k);\n\t\t\tfor (auto a : app) {\n\t\t\t\tfor (auto v : g[a]) {\n\t\t\t\t\tif (v < target[a]) {\n\t\t\t\t\t\tggg[mp[a]].push_back(mp[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t(tmp += calc(ggg)) %= MOD;\n\t\t}\n\t\t// change target\n\t\treverse(g[on_cycle].begin(), g[on_cycle].end());\n\t\tapp.clear();\n\t\tdfs(on_cycle, -1, 2);\n\t\t{\n\t\t\tmap<int, int> mp;\n\t\t\tint k = 0;\n\t\t\tfor (auto a : app) {\n\t\t\t\tassert(target[a] != -1);\n\t\t\t\tmp[a] = k ++;\n\t\t\t}\n\t\t\tvector<vector<int>> ggg(k);\n\t\t\tfor (auto a : app) {\n\t\t\t\tfor (auto v : g[a]) {\n\t\t\t\t\tif (v < target[a]) {\n\t\t\t\t\t\tggg[mp[a]].push_back(mp[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t(tmp += calc(ggg)) %= MOD;\n\t\t}\n\t\t(ans *= tmp) %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nint n,cnt=0,num=0;\nvi x,y,ax,ay,vis,b,c,d,used;\nvl dp;\nvvi g,G;\nvvp X,Y;\n\nint dfs(int v,int w){\n\tb.push_back(v);\n\tvis[v]++;cnt++;\n\tif(!ax[x[v]]) num++,ax[x[v]]=1;\n\tif(!ay[y[v]]) num++,ay[y[v]]=1;\n\tint t=-1;\n\tfor(auto u:g[v]) if(u!=-1&&u!=w){\n\t\tif(vis[u]&&w!=-1){\n\t\t\tint I=d.size()-1;\n\t\t\tpip p={{x[u],y[u]},u};\n\t\t\twhile(I>=0&&d[I]!=u){\n\t\t\t\tint u_=d[I--];\n\t\t\t\tp=min(p,{{x[u_],y[u_]},u_});\n\t\t\t}\n\t\t\tt=p.second;\n\t\t}\n\t\telse if(!vis[u]){\n\t\t\td.push_back(u);\n\t\t\tint t_=dfs(u,v);\n\t\t\tif(t_!=-1) t=t_;\n\t\t\td.pop_back();\n\t\t}\n\t}\n\treturn t;\n}\n\nvoid DFS(int v,int I){\n\tint u=g[v][I];\n\tif(u==-1||c[u]!=-1) return;\n\tc[u]=1-I%2;\n\tfor(int i=0;i<4;i++){\n\t\tint w=g[u][i];\n\t\tif(w!=-1&&c[w]==-1) DFS(u,i);\n\t}\n}\n\npll Rec(int v){\n\tll res=1,S=0;\n\tfor(auto u:G[v]){\n\t\tpll p=Rec(u);\n\t\tll T=p.second;\n\t\tres=Div(res*p.first%mod,F[T]);\n\t\tS+=T;\n\t}\n\t(res*=F[S])%=mod;\n\treturn {res,S+1};\n}\n\nll f(int v,int t){\n\tc[v]=t;\n\tfor(int i=0;i<4;i++) DFS(v,i%2*2+abs(i/2-t));\n\tfor(auto i:b){\n\t\tint u=g[i][c[i]];\n\t\twhile(u!=-1){\n\t\t\tG[i].push_back(u);\n\t\t\tused[u]=1;\n\t\t\tu=g[u][c[i]];\n\t\t}\n\t}\n\tfor(auto i:b) if(!used[i]) G[n].push_back(i);\n\tll res=Rec(n).first;\n\tfor(auto i:b){\n\t\tc[i]=-1;\n\t\tused[i]=0;\n\t\tG[i].clear();\n\t}\n\tG[n].clear();\n\treturn res;\n}\n\nint main(){\n\tInit();\n\tcin>>n;\n\tn*=2;\n\tx=y=ax=ay=vis=used=vi(n);\n\tc=vi(n,-1);\n\tX=Y=vvp(n);\n\tg=vvi(n,vi(4,-1));\n\tG=vvi(n+1);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tx[i]--;y[i]--;\n\t\tX[x[i]].push_back({y[i],i});\n\t\tY[y[i]].push_back({x[i],i});\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tsort(X[i].begin(),X[i].end());\n\t\tsort(Y[i].begin(),Y[i].end());\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<X[i].size();j++){\n\t\t\tint u=X[i][j-1].second,v=X[i][j].second;\n\t\t\tg[u][3]=v;g[v][1]=u;\n\t\t}\n\t\tfor(int j=1;j<Y[i].size();j++){\n\t\t\tint u=Y[i][j-1].second,v=Y[i][j].second;\n\t\t\tg[u][2]=v;g[v][0]=u;\n\t\t}\n\t}\n\tll res=F[n];\n\tfor(int i=0;i<n;i++) if(!vis[i]){\n\t\tcnt=0;num=0;\n\t\tb.clear();d.clear();\n\t\td.push_back(i);\n\t\tint v=dfs(i,-1);\n\t\td.pop_back();\n\t\tres=(cnt==num?Div(res*(f(v,0)+f(v,1))%mod,F[cnt]):0);\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=200005;\nint head[maxn],t[maxn<<1],ne[maxn<<1],num,rd[maxn];\nconst int mod=1e9+7;\ninline void addedge(int x,int y){\n\tne[++num]=head[x];head[x]=num;t[num]=y;rd[x]++;\n\tne[++num]=head[y];head[y]=num;t[num]=x;rd[y]++;\n}\ninline int powmod(int a,int b){\n\tint res=1;for(;b;b>>=1){\n\t\tif(b&1)res=1ll*res*a%mod;\n\t\ta=1ll*a*a%mod;\n\t}return res;\n}\nint n,fac[maxn],facinv[maxn];\ninline int C(int n,int m){\n\tif(m<0||n<m)return 0;\n\treturn 1ll*fac[n]*facinv[m]%mod*facinv[n-m]%mod;\n}\ninline void prprpr(){\n\tfac[0]=1;\n\trep(i,1,200000)fac[i]=1ll*fac[i-1]*i%mod;\n\tfacinv[200000]=powmod(fac[200000],mod-2);\n\tper(i,199999,0)facinv[i]=1ll*facinv[i+1]*(i+1)%mod;\n}\nbool vis[maxn];\nint Queue[maxn],f[maxn];\ninline int calc(int st){\n\tint front=0,finish=0;\n\tQueue[++finish]=st;vis[st]=1;\n\twhile(front!=finish){\n\t\tint x=Queue[++front];\n\t\tforE(i,x)if(!vis[t[i]])\n\t\t\tvis[Queue[++finish]=t[i]]=1;\n\t}return finish;\n}\nint Q2[maxn],fr,ed;\ninline void topsort(){\n\twhile(fr!=ed){\n\t\tint x=Q2[++fr];\n\t\tforE(i,x){\n\t\t\trd[t[i]]--;\n\t\t\tif(rd[t[i]]==1){\n\t\t\t\tQ2[++ed]=t[i];\n\t\t\t}\n\t\t}\n\t}\n}\nint size=0,sz[maxn],myt;\ninline void dp(int x,int fa,int rt){\n\tforE(i,x){\n\t\tif(t[i]==rt||t[i]==fa)continue;\n\t\tdp(t[i],x,rt);\n\t}\n\tf[x]=1;sz[x]=0;\n\tforE(i,x){\n\t\tif(t[i]==rt||t[i]==fa)continue;\n\t\tif(t[i]<fa){\n\t\t\tf[x]=1ll*f[x]*f[t[i]]%mod*C(sz[x]+sz[t[i]],sz[t[i]])%mod;\n\t\t\tsz[x]+=sz[t[i]];\n\t\t}else{\n\t\t\tmyt=1ll*myt*f[t[i]]%mod*C(size+sz[t[i]],sz[t[i]])%mod;\n\t\t\tsize+=sz[t[i]];\n\t\t}\n\t}sz[x]++;\n}\ninline pin solve(int x){\n\tint res=0,tot=calc(x),m=0;\n\tfr=ed=0;\n\trep(k,1,tot){\n\t\tint x=Queue[k];\n\t\tforE(i,x)m++;//,rd[t[i]]++;\n\t\tif(rd[x]==1)Q2[++ed]=x;\n\t}\n\tif(2*tot!=m)return mk(res,tot);\n\ttopsort();ed=0;int rt=0;\n\trep(i,1,tot)if(rd[Queue[i]]>1)rt=max(rt,Queue[i]);\n\tforE(i,rt)if(rd[t[i]]>1)Q2[++ed]=t[i];\n\trep(i,1,ed){\n\t\tmyt=1;size=0;\n\t\tdp(rt,Q2[i],rt);\n\t\tmyt=1ll*myt*f[rt]%mod*C(size+sz[rt],sz[rt])%mod;\n\t\tres=(res+myt)%mod;\n\t}\n\treturn mk(res,tot);\n}\nint main(){\n\tprprpr();\n\tread(n);\n\trep(i,1,(n<<1))head[i]=-1;\n\trep(i,1,n<<1){\n\t\tint x,y;read(x);read(y);\n\t\taddedge(x,y+n);\n\t}\n\tint ans=1;int sum=0;\n\trep(i,1,n)if(!vis[i]){\n\t\tpin w=solve(i);\n\t\tans=1ll*ans*w.w1%mod*C(sum+w.w2,w.w2)%mod;\n\t\tsum+=w.w2;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define M 200020\n#define mod 1000000007\nusing namespace std;\nnamespace IO{\n    const int BS=(1<<22)+5; int Top=0;\n    char Buffer[BS],OT[BS],*OS=OT,*HD,*TL,SS[20]; const char *fin=OT+BS-1;\n    inline char Getchar(){if(HD==TL){TL=(HD=Buffer)+fread(Buffer,1,BS,stdin);} return (HD==TL)?EOF:*HD++;}\n    inline void write(int x){\n        if(!x){putchar('0');return;} if(x<0) x=-x,putchar('-');\n        while(x) SS[++Top]=x%10,x/=10;\n        while(Top) putchar(SS[Top]+'0'),--Top;\n    }\n    inline int read(){\n        int nm=0; char cw=Getchar(); for(;!isdigit(cw);cw=Getchar());\n        for(;isdigit(cw);cw=Getchar()) nm=nm*10+(cw-'0'); return nm;\n    }\n}\nusing namespace IO;\n#define mul(x,y) (LL)(x)*(y)%mod \n#define upd(x,y) x=((x)+(y)>=mod)?(x)+(y)-mod:(x)+(y)\nint n,m,fs[M],nt[M<<1],to[M<<1],tmp,ans=1,EG,top,ind[M],node[M];\nint S[M],c[M],fa[M],nxt[M],fst[M],tar[M],cur,cnt,sz[M],inv[M],vis[M];\ninline void link(int x,int y){\n    nt[tmp]=fs[x],fs[x]=tmp,to[tmp++]=y;\n    nt[tmp]=fs[y],fs[y]=tmp,to[tmp++]=x;\n}\ninline void edge(int x,int y){nxt[cur]=fst[x],fst[x]=cur,tar[cur++]=y;}\nvoid init(int x,int last){\n    node[++cnt]=x,S[++top]=x,ind[x]=1,S[top+1]=0;\n    for(register int i=fs[x];~i;i=nt[i],EG++){\n        if(to[i]==last) continue;\n        if(!ind[to[i]]){init(to[i],x);continue;}\n\t\tif(m) continue;\n        while(S[top+1]!=to[i]) vis[c[++m]=S[top--]]=true; c[0]=to[i];\n    } top--,ind[x]=2;\n}\nvoid build(int x,int last){\n    for(register int i=fs[x];~i;i=nt[i]){\n        if(vis[to[i]]||to[i]==last) continue;\n        fa[to[i]]=x,build(to[i],x);\n    }\n}\nint dfs(int x){\n    if(sz[x]) return 1; int res=sz[x]=1;\n    for(register int i=fst[x];i!=-1;i=nxt[i]){\n        res=mul(res,dfs(tar[i])),sz[x]+=sz[tar[i]];\n    } return mul(res,inv[sz[x]]);\n}\ninline int calc(){\n    for(register int i=1;i<=cnt;i++) fst[node[i]]=-1,sz[node[i]]=0; cur=0; int res=1;\n    for(register int x=1;x<=cnt;x++) for(register int i=fs[node[x]];i!=-1;i=nt[i]) if(to[i]<fa[node[x]]) edge(node[x],to[i]);\n    for(register int x=1;x<=cnt;x++) if(!sz[node[x]]) res=mul(res,dfs(node[x])); return res;\n}\ninline int solve(int x){\n    top=0,init(x,0); if(EG!=(cnt<<1)) puts(\"0\"),exit(0);\n    for(register int i=1;i<=m;i++) build(c[i],0); int res=0;\n    for(register int i=1;i<=m;i++) fa[c[i-1]]=c[i]; upd(res,calc());\n    for(register int i=1;i<=m;i++) fa[c[i]]=c[i-1]; upd(res,calc());\n    return res;\n}\nint main(){\n    n=read(),ans=inv[1]=1,memset(fs,-1,sizeof(fs));\n    for(int i=2;i<=(n<<1);i++) ans=mul(ans,i),inv[i]=mul(inv[mod%i],mod-(mod/i));\n    for(int i=1;i<=(n<<1);i++) link(read()+n,read());\n    for(int i=1;i<=(n<<1);i++) if(!ind[i]) cnt=m=EG=0,ans=mul(ans,solve(i));\n    printf(\"%d\\n\",ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2, \"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair <int, int> pii;\n \nconst int N = 4e5 + 5, mod = 1e9 + 7;\nint n, m, ans, ways;\nint fac[N], inv[N];\nint pre[N], rp[N][2], cp[N][2];\nint deg[N], color[N], os[N];\nint dir[N], id[N];\npii nowp, rep[N], a[N];\nmap <pii, int> exi;\nvector <int> dlt, e[N], g[N], r[N], ance[N];\nqueue <int> sing;\ninline int read () {\n\tint x = 0; char ch = getchar();\n\twhile (ch < '0' || ch > '9') {\n\t\tch = getchar();\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn x;\n}\ninline int power (int a, int b) {\n    int ret = 1;\n    for ( ; b; b >>= 1, a = 1ll * a * a % mod) {\n        if (b & 1) {\n            ret = 1ll * ret * a % mod;\n        }\n    }\n    return ret;\n}\nvoid predo () {\n    fac[0] = 1;\n    for (int i = 1; i <= n + n; ++i) {\n        fac[i] = 1ll * fac[i - 1] * i % mod;\n    }\n    inv[n + n] = power(fac[n + n], mod - 2);\n    for (int i = n + n - 1; ~i; --i) {\n        inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n    }\n}\nvoid adds (int x, int y) {\n    g[x].push_back(y), g[y].push_back(x);\n}\nvoid cover (int x) {\n    color[x] = m;\n    r[m].push_back(x);\n    if (!dir[x]) {\n        ++os[m];\n    }\n    for (auto y : g[x]) {\n        if (!color[y]) {\n            cover(y);\n        }\n    }\n}\nvoid bring (int x, int c) {\n    r[color[x]].clear();\n    color[x] = c;\n    r[c].push_back(x);\n    for (auto y : ance[x]) {\n        bring(y, c);\n    }\n}\nstruct Tr {\n    int n, dg[N], subs[N], fa[N];\n    vector <int> c[N];\n    void init (int _n) {\n        n = _n;\n        for (int i = 0; i <= n; ++i) {\n            dg[i] = subs[i] = 0;\n            fa[i] = -1;\n            c[i].clear();\n        }\n    }\n    void add (int x, int y) {\n        if (fa[y] == -1) {\n            fa[y] = x;\n            c[x].push_back(y), ++dg[y];\n        }\n    }\n    int dp (int x, int p) {\n        int ret = 1;\n        subs[x] = 1;\n        for (auto y : c[x]) {\n            if (y != p) {\n                ret = 1ll * ret * dp(y, x) % mod;\n                subs[x] += subs[y];\n                ret = 1ll * ret * inv[subs[y]] % mod;\n            }\n        }\n        ret = 1ll * ret * fac[subs[x] - 1] % mod;\n        return ret;\n    }\n} T;\nint deter (int x, int f) {\n    T.init(r[x].size());\n    for (int i = 0; i < os[x]; ++i) {\n        dir[r[x][i]] = ((i + f) & 1) + 1;\n    }\n    for (int i = 0; i < r[x].size(); ++i) {\n        id[r[x][i]] = i;\n    }\n    for (int i = os[x], u, v; i < r[x].size(); ++i) {\n        u = r[x][i], nowp = a[u];\n        for (auto v : ance[u]) {\n            T.add(i + 1, id[v] + 1);\n        }\n        if (os[x]) {\n            if (dir[u] == 1) {\n                v = rp[a[u].fi][0];\n                if (a[u].se < a[v].se && dir[v] == 2) {\n                    T.add(id[v] + 1, i + 1);\n                } else {\n                    v = rp[a[u].fi][1];\n                    if (a[u].se < a[v].se && dir[v] == 2) {\n                        T.add(id[v] + 1, i + 1);\n                    }\n                }\n            } else {\n                v = cp[a[u].se][0];\n                if (a[u].fi < a[v].fi && dir[v] == 1) {\n                    T.add(id[v] + 1, i + 1);\n                } else {\n                    v = cp[a[u].se][1];\n                    if (a[u].fi < a[v].fi && dir[v] == 1) {\n                        T.add(id[v] + 1, i + 1);\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 0, u, v; i < os[x]; ++i) {\n        u = r[x][i], v = r[x][(i + 1) % os[x]];\n        if (dir[u] == 1 && dir[v] == 2) {\n            if (a[u].fi == a[v].fi && a[u].se < a[v].se) {\n                T.add((i + 1) % os[x] + 1, i + 1);\n            }\n            if (a[u].se == a[v].se && a[u].fi > a[v].fi) {\n                T.add(i + 1, (i + 1) % os[x] + 1);\n            }\n        } else {\n            if (a[u].fi == a[v].fi && a[u].se > a[v].se) {\n                T.add(i + 1, (i + 1) % os[x] + 1);\n            }\n            if (a[u].se == a[v].se && a[u].fi < a[v].fi) {\n                T.add((i + 1) % os[x] + 1, i + 1);\n            }\n        }\n    }\n    for (int i = 1; i <= T.n; ++i) {\n        if (T.dg[i] == 0) {\n            T.add(0, i);\n        }\n    }\n    return T.dp(0, -1);\n}\nint main () {\n\tn = read(), predo();\n    for (int i = 1, x, y; i <= n + n; ++i) {\n    \tx = read(), y = read();\n        a[i] = make_pair(x, y);\n        exi[a[i]] = i;\n        y += n;\n        e[x].push_back(y), e[y].push_back(x);\n        ++deg[x], ++deg[y];\n    }\n    for (int i = 1; i <= n + n; ++i) {\n        if (deg[i] == 0) {\n            return puts(\"0\"), 0;\n        }\n    }\n    for (int i = 1; i <= n + n; ++i) {\n        if (deg[i] == 1) {\n            if (i <= n) {\n                rep[i] = make_pair(i, e[i][0] - n);\n                dir[exi[rep[i]]] = 2;\n            } else {\n                rep[i] = make_pair(e[i][0], i - n);\n                dir[exi[rep[i]]] = 1;\n            }\n            sing.push(i), dlt.push_back(i);\n        }\n    }\n    for ( ; !sing.empty(); ) {\n        int x = sing.front(), z;\n        sing.pop();\n        for (auto y : e[x]) {\n            if ((--deg[y]) == 1) {\n                for (auto u : e[y]) {\n                    if (deg[u] > 1) {\n                        z = u;\n                        break;\n                    }\n                }\n                if (y <= n) {\n                    rep[y] = make_pair(y, z - n);\n                    dir[exi[rep[y]]] = 2;\n                } else {\n                    rep[y] = make_pair(z, y - n);\n                    dir[exi[rep[y]]] = 1;\n                }\n                sing.push(y), dlt.push_back(y);\n            }\n        }\n    }\n    memset(deg, 0, sizeof deg);\n    for (int i = 1, p, q, u, v; i <= n + n; ++i) {\n        u = exi[rep[i]], p = dir[u];\n        if (p) {\n            for (auto j : e[i]) {\n                v = exi[rep[j]], q = dir[v];\n                if (!v) {\n                    continue;\n                }\n                if (p == 1 && q == 2) {\n                    if (rep[i].fi > rep[j].fi) {\n                        ance[u].push_back(v), ++deg[v];\n                    }\n                } else {\n                    if (rep[i].se > rep[j].se) {\n                        ance[u].push_back(v), ++deg[v];\n                    }\n                }\n            }\n        }\n    }\n    for (auto x : dlt) {\n        exi[rep[x]] = 0;\n    }\n    for (auto p : exi) {\n        if (p.se) {\n            if (rp[p.fi.fi][0]) {\n                rp[p.fi.fi][1] = p.se;\n                if (a[rp[p.fi.fi][0]].se > a[rp[p.fi.fi][1]].se) {\n                    swap(rp[p.fi.fi][0], rp[p.fi.fi][1]);\n                }\n            } else {\n                rp[p.fi.fi][0] = p.se;\n            }\n            if (cp[p.fi.se][0]) {\n                cp[p.fi.se][1] = p.se;\n                if (a[cp[p.fi.se][0]].fi > a[cp[p.fi.se][1]].fi) {\n                    swap(cp[p.fi.se][0], cp[p.fi.se][1]);\n                }\n            } else {\n                cp[p.fi.se][0] = p.se;\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (rp[i][0] && rp[i][1]) {\n            adds(rp[i][0], rp[i][1]);\n        }\n        if (cp[i][0] && cp[i][1]) {\n            adds(cp[i][0], cp[i][1]);\n        }\n    }\n    for (int i = 1; i <= n + n; ++i) {\n        if (!color[i]) {\n            ++m, cover(i);\n        }\n    }\n    for (int i = 1, ci; i <= n + n; ++i) {\n        if ((int)r[color[i]].size() == 1) {\n            nowp = a[i], ci = -1;\n            if (dir[i] == 2) {\n                if (cp[nowp.se][0]) {\n                    ci = color[cp[nowp.se][0]];\n                }\n            } else {\n                if (rp[nowp.fi][0]) {\n                    ci = color[rp[nowp.fi][0]];\n                }\n            }\n            if (~ci) {\n                bring(i, ci);\n            } else {\n                if (!deg[i]) {\n                    for (auto j : ance[i]) {\n                        bring(j, color[i]);\n                    }\n                }\n            }\n        }\n    }\n    ans = 1, ways = 1;\n    for (int i = 1, tmp; i <= m; ++i) {\n        if ((int)r[i].size() > 0) {\n            if (os[i]) {\n                tmp = (deter(i, 0) + deter(i, 1)) % mod;\n            } else {\n                tmp = deter(i, 0);\n            }\n            ways = 1ll * ways * tmp % mod;\n            ans = 1ll * ans * inv[r[i].size()] % mod;\n        }\n    }\n    ans = 1ll * ans * ways % mod;\n    ans = 1ll * ans * fac[n + n] % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=4e5+10;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nconst int mod=1e9+7;\nint fac[N],inv[N],e[N];\nint head[N],nxt[N],to[N],w[N];\nint siz[N],ans,f[N],V,E,C;\nbool vis[N];\ninline int binom(int n,int m) { return 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod; }\ninline void dfs(int k,int fa) {\n\tvis[k]=true;V++;\n\tfor (int i=head[k];i;i=nxt[i],E++)\n\t\tif (!vis[to[i]])\n\t\t\te[to[i]]=i^1,dfs(to[i],k);\n\t\telse if (to[i]!=fa) C=i;\n}\ninline void dp(int k,int e) {\n\tf[k]=1;siz[k]=0;\n\tfor (int i=head[k];i;i=nxt[i])\n\t\tif (i/2!=C/2&&(i^1^e)) {\n\t\t\tdp(to[i],i);\n\t\t\tif (w[i]>w[e])\n\t\t\t\tans=1LL*ans*inv[siz[to[i]]]%mod*f[to[i]]%mod;\n\t\t\telse\n\t\t\t\tf[k]=1LL*f[k]*f[to[i]]%mod*binom(siz[k]+=siz[to[i]],siz[to[i]])%mod;\n\t\t}\n\tsiz[k]++;\n}\nint main()\n{\n\tint n=gi()*2,i,tot=1,a,b,sum,k;\n\t\n\tfor (i=fac[0]=1;i<=n;i++) fac[i]=1LL*fac[i-1]*i%mod;\n\tfor (i=2,inv[0]=inv[1]=1;i<=n;i++) inv[i]=mod-1LL*(mod/i)*inv[mod%i]%mod;\n\tfor (i=3;i<=n;i++) inv[i]=1LL*inv[i]*inv[i-1]%mod;\n\t\n\tfor (i=1;i<=n;i++) {\n\t\ta=gi(),b=gi()+n/2;\n\t\tto[++tot]=b,nxt[tot]=head[a],head[a]=tot;\n\t\tto[++tot]=a,nxt[tot]=head[b],head[b]=tot;\n\t\tw[tot]=w[tot^1]=a+b;\n\t}\n\n\tint res=fac[n];\n\tfor (k=1;k<=n;k++)\n\t\tif (!vis[k]) {\n\t\t\tV=E=C=0;\n\t\t\tdfs(k,0);\n\t\t\tif (V*2!=E) return puts(\"0\"),0;\n\t\t\tfor (a=to[C],b=to[C^1];a!=b;a=to[e[a]]) if (w[e[a]]<w[C]) C=e[a];\n\t\t\tans=1;\n\t\t\tdp(to[C],C);\n\t\t\tsum=1LL*ans*inv[siz[to[C]]]%mod*f[to[C]]%mod;\n\t\t\tans=1;\n\t\t\tdp(to[C^1],C);\n\t\t\tsum=(sum+1LL*ans*inv[siz[to[C^1]]]%mod*f[to[C^1]])%mod;\n\t\t\tres=1LL*res*sum%mod;\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(x) cerr<<#x\" = \"<<x<<endl;\nusing namespace std;\n\ntemplate<typename T> il T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> il void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> il void cmin(T &x,T y){x=x<y?x:y;}\ninline void proc_status(){\n\tifstream t (\"/proc/self/status\");\n\tcerr<<string(istreambuf_iterator<char>(t),istreambuf_iterator<char>())<<endl;\n\t/*freopen(\"/proc/self/status\",\"r\",stdin);\n\tchar ch[100];\n\twhile(scanf(\"%s\",ch)!=EOF)cerr<<ch<<endl;*/\n}\n\nconst int L=2e5+10;\nconst int P=1e9+7;\n\nil int pwr(int x,int y){\n\tint z=1;\n\tfor(;y;y>>=1,x=(ll)x*x%P)\n\t\tif(y&1)z=(ll)z*x%P;\n\treturn z;\n}\nint fac[L],inv[L];\nil void getfac(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=(ll)fac[i-1]*i%P;\n\tinv[n]=pwr(fac[n],P-2);\n\tfor(int i=n;i;--i)\n\t\tinv[i-1]=(ll)inv[i]*i%P;\n}\nil int C(int n,int m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\n\nint F[L];\nint get(int x){return x==F[x]?x:F[x]=get(F[x]);}\n\nint To[L<<1],Fs[L],Nx[L<<1],W[L<<1],E;\nil void Add(int x,int y,int z){\n\tTo[++E]=y;\n\tNx[E]=Fs[x];\n\tFs[x]=E;\n\tW[E]=z;\n}\n\nvector<int>vec[L];\n\nint to[L<<1],fs[L],nx[L<<1],w[L<<1],e;\nil void add(int x,int y,int z){\n\tto[++e]=y;\n\tnx[e]=fs[x];\n\tfs[x]=e;\n\tw[e]=z;\n}\n\nint st[L],top;\nint in[L];\n\nint stx[L],wgt[L],tp;\nint num[L],val[L],cnt;\nint vis[L];\nint Flg;\nvoid findcir(int x,int f){\n\tstx[++tp]=x,vis[x]=1;\n\tfor(int i=fs[x];i;i=nx[i]){\n\t\tint k=to[i];\n\t\tif(k==f)continue;\n\t\twgt[tp]=w[i];\n\t\tif(!Flg&&vis[k]){\n\t\t\tFlg=1;\n\t\t\tint lb=tp;\n\t\t\twhile(stx[lb]!=k)--lb;\n\t\t\tfor(int t=lb;t<=tp;++t)\n\t\t\t\tnum[t-lb+1]=stx[t],val[t-lb+1]=wgt[t];\n\t\t\tcnt=tp-lb+1;\n\t\t}\n\t\telse if(!vis[k])findcir(k,x);\n\t}\n\t--tp,vis[x]=0;\n}\n\nint Fa[L];\nint Vis[L],Wgt[L];\nint res;\nint ans[L],siz[L];\nvoid dfs(int x,int f){\n\tsiz[x]=ans[x]=1;\n\tfor(int i=fs[x];i;i=nx[i]){\n\t\tint k=to[i];\n\t\tif(k==f||Vis[k])continue;\n\t\tVis[k]=1,Wgt[k]=w[i];\n\t\tif(w[i]<Wgt[x])Fa[k]=x;\n\t\telse Fa[k]=0;\n\t\tdfs(k,x);\n\t\tif(Fa[k]){\n\t\t\tans[x]=(ll)ans[x]*ans[k]%P*C(siz[x]+siz[k]-1,siz[k])%P;\n\t\t\tsiz[x]+=siz[k];\n\t\t}\n\t}\n}\n\nil int Pre(int x){return x==1?cnt:x-1;}\nil int Nxt(int x){return x==cnt?1:x+1;}\n\nint main(){\n\tint n=rd<int>();\n\tint lim=n<<1;\n\tfor(int i=1;i<=lim;++i)F[i]=i;\n\tfor(int i=1;i<=lim;++i){\n\t\tint x=rd<int>(),y=rd<int>();\n\t\tAdd(x,y+n,x+y),Add(y+n,x,x+y);\n\t\tF[get(x)]=get(y+n);\n\t}\n\tfor(int i=1;i<=lim;++i)\n\t\tvec[get(i)].pb(i);\n\tgetfac(lim);\n\tint Ans=1,Sum=0;\n\tfor(int T=1;T<=lim;++T){\n\t\tif(vec[T].empty())continue;\n\t\ttop=0;\n\t\tint cnta=(int)vec[T].size(),cntb=0;\n\t\tfor(int t=vec[T].size()-1;~t;--t){\n\t\t\tint x=vec[T][t];\n\t\t\tst[++top]=x;\n\t\t\tfor(int i=Fs[x];i;i=Nx[i]){\n\t\t\t\tint k=To[i];\n\t\t\t\tif(get(k)==get(x)){\n\t\t\t\t\t++cntb;\n\t\t\t\t\tadd(x,k,W[i]),++in[k];//反向边在枚举到k时加\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcntb>>=1;\n\t\tif(cnta^cntb)return puts(\"0\"),0;\n\n\n\t\ttp=0,Flg=0;\n\t\tfindcir(st[1],0);\n\n\n\t\tint Res=0,Siz=0;\n\t\tres=1;\n\t\tfor(int i=1;i<=cnt;++i)\n\t\t\tVis[num[i]]=1,Wgt[num[i]]=val[i];\n\t\tfor(int i=1;i<=cnt;++i)\n\t\t\tdfs(num[i],0);\n\t\tfor(int i=1;i<=cnt;++i){\n\t\t\tint nxt=Nxt(i);\n\t\t\tif(Wgt[num[i]]<Wgt[num[nxt]])Fa[num[i]]=num[nxt];\n\t\t\telse Fa[num[i]]=0;\n\t\t}\n\t\tfor(int i=1;i<=cnt;++i){\n\t\t\tif(Fa[num[i]])continue;\n\t\t\tfor(int k=Nxt(i);Fa[num[k]];k=Nxt(k)){\n\t\t\t\tint nxt=Nxt(k);\n\t\t\t\tans[num[nxt]]=(ll)ans[num[nxt]]*ans[num[k]]%P*C(siz[num[nxt]]+siz[num[k]]-1,siz[num[k]])%P;\n\t\t\t\tsiz[num[nxt]]+=siz[num[k]];\n\t\t\t}\n\t\t}\n\t\tSiz=0;\n\t\tfor(int i=1;i<=top;++i){\n\t\t\tif(Fa[st[i]])continue;\n\t\t\tres=(ll)res*ans[st[i]]%P*C(Siz+siz[st[i]],siz[st[i]])%P;\n\t\t\tSiz+=siz[st[i]];\n\t\t}\n\t\tfor(int i=1;i<=top;++i)\n\t\t\tVis[st[i]]=Wgt[st[i]]=0;\n\t\t(Res+=res)%=P;\n\n\t\tres=1;\n\t\tfor(int i=1;i<=cnt;++i)\n\t\t\tVis[num[i]]=1,Wgt[num[i]]=i==1?val[cnt]:val[i-1];\n\t\tfor(int i=1;i<=cnt;++i)\n\t\t\tdfs(num[i],0);\n\t\tfor(int i=1;i<=cnt;++i){\n\t\t\tint nxt=Pre(i);\n\t\t\tif(Wgt[num[i]]<Wgt[num[nxt]])Fa[num[i]]=num[nxt];\n\t\t\telse Fa[num[i]]=0;\n\t\t}\n\t\tfor(int i=1;i<=cnt;++i){\n\t\t\tif(Fa[num[i]])continue;\n\t\t\tfor(int k=Pre(i);Fa[num[k]];k=Pre(k)){\n\t\t\t\tint nxt=Pre(k);\n\t\t\t\tans[num[nxt]]=(ll)ans[num[nxt]]*ans[num[k]]%P*C(siz[num[nxt]]+siz[num[k]]-1,siz[num[k]])%P;\n\t\t\t\tsiz[num[nxt]]+=siz[num[k]];\n\t\t\t}\n\t\t}\n\t\tSiz=0;\n\t\tfor(int i=1;i<=top;++i){\n\t\t\tif(Fa[st[i]])continue;\n\t\t\tres=(ll)res*ans[st[i]]%P*C(Siz+siz[st[i]],siz[st[i]])%P;\n\t\t\tSiz+=siz[st[i]];\n\t\t}\n\t\tfor(int i=1;i<=top;++i)\n\t\t\tVis[st[i]]=Wgt[st[i]]=0;\n\t\t(Res+=res)%=P;\n\n\t\tAns=(ll)Ans*Res%P*C(Sum+cnta,cnta)%P;\n\t\tSum+=cnta;\n\n\n\t\tfor(int i=1;i<=top;++i)\n\t\t\tfs[st[i]]=in[st[i]]=vis[st[i]]=0;//\n\t\te=0;\n\t}\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 200011\n#define mod 1000000007\n\nint n, i, x, y;\nvector<int> list[maxN], son[maxN];\nll ans = 1;\nbool us[maxN];\n\nint nodes, edges;\n\nbool need;\nvector<int> way, act;\nbool cyc[maxN], any_father[maxN];\n\nll fact[maxN], inv_fact[maxN];\nll dp[maxN], down[maxN];\n\nll poww(ll a, ll b) {\n    ll ans = 1;\n\n    while (b > 0) {\n        if (b & 1) ans = (ans * a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n\n    return ans;\n}\n\nvoid dfs(int node) {\n    us[node] = true;\n    nodes++;\n    edges += list[node].size();\n    act.pb(node);\n\n    if (need) way.pb(node);\n\n    for (auto to : list[node]) {\n        if (us[to] && need) {\n            if (to != way[way.size() - 2])\n                way.pb(to), need = false;\n            continue;\n        }\n\n        if (us[to]) continue;\n\n        dfs(to);\n    }\n\n    if (need) way.pop_back();\n}\n\nvoid assoc(int n1, int n2) {\n    int p = 0;\n\n    while (list[n1][p] != n2) {\n        son[n1].pb(list[n1][p]);\n        any_father[ list[n1][p] ] = true;\n        p++;\n    }\n\n}\n\nvoid dfs_low(int node, int root) {\n    for (auto to : list[node]) {\n        if (cyc[to]) continue;\n        if (to == root) continue;\n        dfs_low(to, node);\n        assoc(to, node);\n    }\n}\n\nll dfs_calc(int node) {\n    dp[node] = 1;\n    down[node] = 1;\n\n    for (auto to : son[node]) {\n        dp[node] *= dfs_calc(to);\n        dp[node] %= mod;\n        down[node] += down[to];\n    }\n\n    dp[node] *= fact[down[node] - 1];\n    dp[node] %= mod;\n\n    for (auto to : son[node]) {\n        dp[node] *= inv_fact[down[to]];\n        dp[node] %= mod;\n    }\n\n    return dp[node];\n}\n\nll solve(ll R) {\n    ll ans1 = 1;\n    ll ans2 = 1;\n\n    nodes = edges = 0;\n    act.clear();\n    way.clear(); need = true;\n\n    dfs(R);\n\n    edges /= 2;\n    if (nodes != edges)\n        return 0;\n\n    reverse(way.begin(), way.end());\n    for (i = 1; way[i] != way[0]; i++);\n    way.resize(i);\n\n    for (auto e : way) cyc[e] = true;\n    way.pb(way[0]);\n\n    //! first try\n    for (auto e : act) any_father[e] = false;\n    for (auto e : act) son[e].clear();\n    for (i = 0; i + 1 < way.size(); i++) {\n        assoc(way[i], way[i + 1]);\n        dfs_low(way[i], 0);\n    }\n\n    ans1 = fact[act.size()];\n    for (auto e : act) {\n        if (any_father[e]) continue;\n        ans1 *= dfs_calc(e);\n        ans1 %= mod;\n        ans1 *= inv_fact[down[e]];\n        ans1 %= mod;\n    }\n\n    //! second try\n    for (auto e : act) any_father[e] = false;\n    for (auto e : act) son[e].clear();\n    for (i = 0; i + 1 < way.size(); i++) {\n        assoc(way[i + 1], way[i]);\n        dfs_low(way[i], 0);\n    }\n\n    ans2 = fact[act.size()];\n    for (auto e : act) {\n        if (any_father[e]) continue;\n        ans2 *= dfs_calc(e);\n        ans2 %= mod;\n        ans2 *= inv_fact[down[e]];\n        ans2 %= mod;\n    }\n\n    return (ans1 + ans2) % mod;\n}\n\nint main()\n{\n //   freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n;\n    for (i = 1; i <= 2 * n; i++) {\n        cin >> x >> y;\n        list[x].pb(n + y);\n        list[n + y].pb(x);\n    }\n\n    fact[0] = 1;\n    for (i = 1; i <= 2 * n; i++)\n        fact[i] = (fact[i - 1] * i) % mod;\n\n    inv_fact[2 * n] = poww(fact[2 * n], mod - 2);\n    for (i = 2 * n - 1; i > 0; i--)\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % mod;\n    inv_fact[0] = 1;\n\n    for (i = 1; i <= 2 * n; i++)\n        sort(list[i].begin(), list[i].end());\n\n    ans = fact[2 * n];\n    for (i = 1; i <= 2 * n; i++) {\n        if (us[i]) continue;\n        ans *= solve(i);\n        ans %= mod;\n\n        ans *= inv_fact[nodes];\n        ans %= mod;\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=200100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N];\n\nint cnt,head[N];\nstruct Xint{int to,next;}V[N*8];\nvoid add(int x,int y){\n\tV[++cnt]=(Xint){y,head[x]};head[x]=cnt;\n\tV[++cnt]=(Xint){x,head[y]};head[y]=cnt;\n}\n\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;i>0;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tfor(int i=head[x];i;i=V[i].next){\n\t\tint y=V[i].to;if(y!=f)dfs(x,y);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\treturn;\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n)f[i]=(LL)f[i-1]*i%mod;\n\tF[n]=mi(f[n],mod-2);\n\tdef(i,n-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)add(vx[i][j],vx[i][j+1]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)add(vy[i][j],vy[i][j+1]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct union_find {\n    vi P, R, S;\n\n    union_find(int N) {\n        P.resize(N), R.resize(N, 0), S.resize(N, 1);\n        for (int i = 0; i < N; i++)\n            P[i] = i;\n    }\n\n    int rep(int i) {\n        if(P[i] != i) P[i] = rep(P[i]);\n        return P[i];\n    }\n\n    bool unio(int a, int b) {\n        a = rep(a), b = rep(b);\n        if(a == b) return false;\n        if(R[a] < R[b]) swap(a, b);\n        P[b] = a;\n        S[a] += S[b];\n        if(R[a] == R[b]) R[a]++;\n        return true;\n    }\n};\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\nusing mn = modnum<int(1e9 + 7)>;\nusing vmn = vector<mn>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    vvi adj(2 * N);\n    union_find uf(2 * N);\n\n    for (int i = 0, x, y; i < 2 * N; i++) {\n        cin >> x >> y;\n        uf.unio(--x, --y + N);\n        adj[x].push_back(y + N);\n        adj[y + N].push_back(x);\n    }\n\n    vvi comp(2 * N);\n    for (int i = 0; i < 2 * N; i++) {\n        comp[uf.rep(i)].push_back(i);\n    }\n\n    auto comb = [](const pair<int, mn>& a, const pair<int, mn>& b) -> pair<int, mn> {\n        return { a.first + b.first,\n            mn::ncr(a.first + b.first, a.first) * a.second * b.second };\n    };\n\n    pair<int, mn> ans = { 0, 1 };\n\n    vi deg(2 * N), assign(2 * N, -1);\n    for (const vi& grp : comp) if (sz(grp)) {\n        vector<pair<int, int>> edges;\n        for (int x : grp) {\n            deg[x] = sz(adj[x]);\n            if (x < N) for (int y : adj[x])\n                edges.emplace_back(x, y);\n        }\n        if (sz(grp) != sz(edges)) { cerr << \"Bad group\\n\"; ans.second = 0; break; }\n\n        sort(all(edges));\n        auto inx = [&](int x, int y) {\n            if (x > y) swap(x, y);\n            return lower_bound(all(edges), make_pair(x, y)) - edges.begin();\n        };\n\n        queue<int> leaf;\n        for (int v : grp) if (deg[v] == 1) leaf.push(v);\n        for (; !leaf.empty(); leaf.pop()) {\n            int v = leaf.front();\n            for (int u : adj[v]) if (deg[u] > 1) {\n                assign[v] = inx(v, u);\n                if (--deg[u] == 1)\n                    leaf.push(u);\n            }\n        }\n\n        auto go = [&](auto&& self, vvi& tree, int loc) -> pair<int, mn> {\n            pair<int, mn> res = { 0, 1 };\n            for (int ch : tree[loc])\n                res = comb(res, self(self, tree, ch));\n            res.first++;\n            return res;\n        };\n\n        auto ct = [&](){\n            vvi tree(sz(edges) + 1); vi par(sz(edges) + 1, -1);\n            auto arc = [&](int p, int c) {\n                tree[p].push_back(c);\n                par[c] = p;\n            };\n\n            for (int v : grp) {\n                int e = assign[v]; auto [x, y] = edges[e];\n                if (v >= N) for (int xn : adj[v]) {\n                    if (xn < x && edges[assign[xn]] == make_pair(xn, y))\n                        arc(e, assign[xn]);\n                }\n                else for (int yn : adj[v]) {\n                    if (yn < y && edges[assign[yn]] == make_pair(x, yn))\n                        arc(e, assign[yn]);\n                }\n            }\n\n            for (int i = 0; i < sz(edges); i++)\n                if (par[i] == -1)\n                    arc(sz(edges), i);\n            return go(go, tree, sz(edges));\n        };\n\n        int cyc = -1;\n        for (int v : grp) if (assign[v] == -1) {\n            assert(deg[v] == 2);\n            cyc = v;\n        }\n\n        pair<int, mn> tot = { sz(grp), 0 };\n        for (int u : adj[cyc]) if (deg[u] == 2) {\n            assign[cyc] = inx(cyc, u);\n            for (int loc = u, prv = cyc; loc != cyc; ) {\n                for (int nbr : adj[loc]) if (deg[nbr] == 2) {\n                    assign[loc] = inx(loc, nbr);\n                    if (assign[loc] == assign[prv]) continue;\n                    prv = loc;\n                    loc = nbr;\n                    break;\n                }\n            }\n            tot.second += ct().second;\n        }\n        ans = comb(ans, tot);\n    }\n\n    cout << ans.second << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n有点恶心。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) // fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nconst int maxn = 400005, mod = 1000000007;\nint head[maxn], nxt[maxn << 2], to[maxn << 2], hp = 1;\n\ninline ll power(ll x, int k) {\n\tif(k < 0) k += mod - 1;\n\tll res = 1;\n\twhile(k) {\n\t\tif(k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\ninline void add(int u, int v, int *h) {\n\tnxt[++ hp] = h[u];\n\th[u] = hp;\n\tto[hp] = v;\n}\n\nint tmp[maxn], tp;\nbool vis[maxn];\nint cx, cy;\nvoid dfs(int u, int f) {\n\ttmp[++ tp] = u;\n\tvis[u] = 1;\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f) {\n\t\t\tif(vis[to[i]]) {\n\t\t\t\tcx = u;\n\t\t\t\tcy = to[i];\n\t\t\t} else\n\t\t\t\tdfs(to[i], u);\n\t\t}\n}\n\nint match[maxn];\nvoid mdfs(int u, int f) {\n\t/* debug(\"%d %d\\n\", u, f); */\n\tfor(int i = head[u]; i; i = nxt[i])\n\t\tif(to[i] != f and to[i] != cx) {\n\t\t\tmatch[to[i]] = u;\n\t\t\tmdfs(to[i], u);\n\t\t}\n}\n\nint Head[maxn];\nint deg[maxn];\nint stack[maxn], sp;\nll f[maxn];\nint size[maxn];\nll fac[maxn], ifac[maxn];\n\ninline ll C(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nvoid dp(int u) {\n\tsize[u] = 0;\n\tf[u] = 1;\n\tfor(int i = Head[u]; i; i = nxt[i]) {\n\t\tdp(to[i]);\n\t\tsize[u] += size[to[i]];\n\t\t(f[u] *= f[to[i]]) %= mod;\n\t\t(f[u] *= C(size[u], size[to[i]])) %= mod;\n\t}\n\t++ size[u];\n\tdebug(\"%d : %lld %d\\n\", u, f[u], size[u]);\n}\n\nint HP;\nll solve() {\n\tdebug(\"solve %d %d\\n\", cx, cy);\n\tmdfs(cx, cy);\n\tmatch[cx] = cy;\n\n\thp = HP;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tdeg[tmp[i]] = Head[tmp[i]] = 0;\n\n\tfor(int id = 1; id <= tp; id ++) {\n\t\tint u = tmp[id];\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] < match[u]) {\n\t\t\t\tdebug(\"%d -> %d\\n\", u, to[i]);\n\t\t\t\tadd(u, to[i], Head);\n\t\t\t\t++ deg[to[i]];\n\t\t\t}\n\t}\n\n\tHead[0] = 0;\n\tfor(int i = 1; i <= tp; i ++)\n\t\tif(!deg[tmp[i]])\n\t\t\tadd(0, tmp[i], Head);\n\n\tdp(0);\n\tdebug(\"get %lld\\n\", f[0]);\n\n\treturn f[0];\n}\n\nint main() {\n\tint n = read;\n\n\tint N = n << 1 | 1;\n\tfac[0] = 1;\n\tfor(int i = 1; i <= N; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tifac[N] = power(fac[N], -1);\n\tfor(int i = N; i; i --)\n\t\tifac[i - 1] = ifac[i] * i % mod;\n\n\tfor(int i = 1; i < N; i ++) {\n\t\tint x = read, y = read;\n\t\tadd(x, n + y, head);\n\t\tadd(n + y, x, head);\n\t}\n\n\tHP = hp;\n\tll ans = 1;\n\tint SIZE = 0;\n\n\tfor(int r = 1; r < N; r ++)\n\t\tif(!vis[r]) {\n\t\t\ttp = 0;\n\t\t\tdfs(r, 0);\n\t\t\tll now = solve();\n\t\t\tstd::swap(cx, cy);\n\t\t\tnow += solve();\n\t\t\tSIZE += size[0] - 1;\n\t\t\t(ans *= now) %= mod;\n\t\t\t(ans *= C(SIZE, size[0] - 1)) %= mod;\n\t\t}\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef long double ld; \ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\n\nstruct Combi\n{\n\tvector<ll> fact;\n\tvector<ll> ifact;\n\tvector<ll> inv;\n\tvector<ll> pow2;\n\tconst int MOD = 1e9 + 7;\n\tll add(ll a, ll b)\n\t{\n\t\ta+=b;\n\t\twhile(a>=MOD) a-=MOD;\n\t\treturn a;\n\t}\n\tll mult(ll a, ll b)\n\t{\n\t\treturn (a*b)%MOD;\n\t}\n\tll modpow(ll a, ll b)\n\t{\n\t\tll r=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r=mult(r,a);\n\t\t\ta=mult(a,a);\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tll choose(ll a, ll b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tll inverse(ll a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tinv[i] = inverse(i);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t\tifact[i]=mult(ifact[i-1],inv[i]);\n\t\t}\n\t}\n};\n\n\nCombi combi;\nvi adj[211111];\nset<ii> S;\nset<ii> ad[211111];\nvector<vi> cyc;\nbool vis[211111];\n\nvoid dfscyc(int u)\n{\n\tvis[u]=1;\n\tcyc.back().pb(u);\n\tfor(auto it=ad[u].begin();it!=ad[u].end();it++)\n\t{\n\t\tint v=(*it).fi;\n\t\tif(!vis[v])\n\t\t{\n\t\t\tdfscyc(v);\n\t\t}\n\t}\n}\n\nmap<ii,int> ma;\nint n; \nint match[200011];\nint imatch[200011];\nvi comp[200011];\n\nvoid dfs(int u, int idx)\n{\n\tvis[u]=1;\n\tcomp[idx].pb(u);\n\t//////////cerr<<u<<'\\n';\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(vis[v]) continue;\n\t\tii cur = mp(u,v%n);\n\t\tif(u>=n) cur = mp(v,u%n);\n\t\tmatch[ma[cur]] = v;\n\t\timatch[v] = ma[cur];\n\t\tdfs(v,idx);\n\t}\n}\nconst int MOD=1e9+7;\n\nll add(ll &a, ll b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nvector<ii> pt;\nvi T[200001];\nint indeg[200001];\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nii calctree(int u ,int p = -1)\n{\n\tll ans = 1;\n\tll siz=1;\n\tfor(int i=0;i<T[u].size();i++)\n\t{\n\t\tint v=T[u][i];\n\t\tii res = calctree(v,u);\n\t\tans = mult(ans,res.fi);\n\t\tans = mult(ans,combi.ifact[res.se]);\n\t\tsiz+=res.se;\n\t}\n\tans = mult(ans,combi.fact[siz-1]);\n\t//////cerr<<u<<' '<<p<<' '<<ans<<' '<<siz<<'\\n';\n\treturn mp(ans,siz);\n}\n\nint timer;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tint x, y; cin>>x>>y;\n\t\tx--; y--;\n\t\tadj[x].pb(y+n);\n\t\tadj[y+n].pb(x);\n\t\tad[x].insert(mp(y+n,++timer));\n\t\tad[y+n].insert(mp(x,timer));\n\t\tma[mp(x,y)] = i;\n\t\tpt.pb(mp(x,y));\n\t}\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tS.insert(mp(int(ad[i].size()),i));\n\t}\n\twhile(!S.empty())\n\t{\n\t\tii tmp = (*S.begin());\n\t\t//////cerr<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\tif(tmp.fi==0)\n\t\t{\n\t\t\tcout<<0<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t\telse if(tmp.fi==1)\n\t\t{\n\t\t\tint u = tmp.se;\n\t\t\tint v = (*ad[u].begin()).fi;\n\t\t\tS.erase(mp(ad[u].size(),u));\n\t\t\tS.erase(mp(ad[v].size(),v));\n\t\t\t//////cerr<<\"ERASE : \"<<v<<' '<<ad[v].size()<<'\\n';\n\t\t\tad[u].erase(ad[u].lower_bound(mp(v,-1)));\n\t\t\tad[v].erase(ad[v].lower_bound(mp(u,-1)));\n\t\t\t//////cerr<<\"ERASE : \"<<v<<' '<<ad[v].size()<<'\\n';\n\t\t\tS.insert(mp(ad[v].size(),v));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tvi vertices;\n\tfor(auto it = S.begin(); it != S.end(); it++)\n\t{\n\t\tif(!vis[it->se]) \n\t\t{\n\t\t\tcyc.pb(vi());\n\t\t\tdfscyc(it->se);\n\t\t}\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=0;i<cyc.size();i++) \n\t{\n\t\tfor(int j=0;j<cyc[i].size();j++)\n\t\t{\n\t\t\t////cerr<<cyc[i][j]<<' ';\n\t\t\tvis[cyc[i][j]]=1;\n\t\t}\n\t\t////cerr<<'\\n';\n\t}\n\tfor(int i=0;i<cyc.size();i++)\n\t{\n\t\tfor(int j=0;j<cyc[i].size();j++)\n\t\t{\n\t\t\tdfs(cyc[i][j],i);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tsort(adj[i].begin(),adj[i].end());\n\t}\n\tcombi.init(212121);\n\tvector<ll> results;\n\tll res = combi.fact[2*n];\n\tfor(int z=0;z<cyc.size();z++)\n\t{\n\t\tsort(comp[z].begin(),comp[z].end());\n\t\tres=mult(res,combi.ifact[comp[z].size()]);\n\t\tll ans=1;\n\t\tfor(int i=0;i<cyc[z].size();i++)\n\t\t{\n\t\t\tint u=cyc[z][i];\n\t\t\tint v=cyc[z][(i+1)%int(cyc[z].size())];\n\t\t\t//////////cerr<<u<<' '<<v<<'\\n';\n\t\t\tii cur = mp(u,v%n);\n\t\t\tif(u>=n) cur = mp(v,u%n);\n\t\t\tmatch[ma[cur]] = u;\n\t\t\timatch[u] = ma[cur];\n\t\t\t//////////cerr<<u<<' '<<ma[cur]<<'\\n';\n\t\t}\n\t\tvi FF;\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tint x = imatch[i];\n\t\t\tii V = pt[x];\n\t\t\tint cr = V.se + n;\n\t\t\tif(i>=n)\n\t\t\t{\n\t\t\t\tcr = V.fi;\n\t\t\t}\n\t\t\tif(i<n) FF.pb(ma[mp(i,cr-n)]);\n\t\t\telse FF.pb(ma[mp(cr,i-n)]);\n\t\t\tfor(int j=0;j<adj[i].size();j++)\n\t\t\t{\n\t\t\t\tint v=adj[i][j];\n\t\t\t\tif(v<cr)\n\t\t\t\t{\n\t\t\t\t\tif(i<n)\n\t\t\t\t\t{\n\t\t\t\t\t\t//////////cerr<<i<<' '<<v-n<<' '<<i<<' '<<cr-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(i,cr-n)]].pb(ma[mp(i,v-n)]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//////////cerr<<v<<' '<<i-n<<' '<<cr<<' '<<i-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(cr,i-n)]].pb(ma[mp(v,i-n)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(FF.begin(),FF.end());\n\t\tFF.erase(unique(FF.begin(),FF.end()),FF.end());\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tfor(int j=0;j<T[i].size();j++)\n\t\t\t{\n\t\t\t\t//cerr<<\"T1 : \"<<i<<' '<<T[i][j]<<'\\n';\n\t\t\t\tindeg[T[i][j]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi vec;\n\t\t\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tif(indeg[i]==0)\n\t\t\t{\n\t\t\t\tii tmp = calctree(i);\n\t\t\t\t////////cerr<<\"DEG : \"<<i<<' '<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\t\t\tans = mult(ans,tmp.fi);\n\t\t\t\t//////cerr<<i<<' '<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\t\t\tvec.pb(tmp.se);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll r=0;\n\t\tfor(int i=0;i<vec.size();i++)\n\t\t{\n\t\t\tr+=vec[i];\n\t\t\tans=mult(ans,combi.ifact[vec[i]]);\n\t\t}\n\t\tans=mult(ans,combi.fact[r]);\n\t\t//////////cerr<<ans<<'\\n';\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tT[i].clear();\n\t\t\tindeg[i]=0;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<cyc[z].size();i++)\n\t\t{\n\t\t\tint u=cyc[z][i];\n\t\t\tint v=cyc[z][(i+1)%int(cyc[z].size())];\n\t\t\tii cur = mp(u,v%n);\n\t\t\tif(u>=n) cur = mp(v,u%n);\n\t\t\tmatch[ma[cur]] = v;\n\t\t\timatch[v] = ma[cur];\n\t\t}\n\t\tFF.clear();\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tint x = imatch[i];\n\t\t\tii V = pt[x];\n\t\t\tint cr = V.se + n;\n\t\t\tif(i>=n)\n\t\t\t{\n\t\t\t\tcr = V.fi;\n\t\t\t}\n\t\t\tif(i<n) FF.pb(ma[mp(i,cr-n)]);\n\t\t\telse FF.pb(ma[mp(cr,i-n)]);\n\t\t\tfor(int j=0;j<adj[i].size();j++)\n\t\t\t{\n\t\t\t\tint v=adj[i][j];\n\t\t\t\tif(v<cr)\n\t\t\t\t{\n\t\t\t\t\tif(i<n)\n\t\t\t\t\t{\n\t\t\t\t\t\t//////////cerr<<i<<' '<<v-n<<' '<<i<<' '<<cr-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(i,cr-n)]].pb(ma[mp(i,v-n)]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//////////cerr<<v<<' '<<i-n<<' '<<cr<<' '<<i-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(cr,i-n)]].pb(ma[mp(v,i-n)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(FF.begin(),FF.end());\n\t\tFF.erase(unique(FF.begin(),FF.end()),FF.end());\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tfor(int j=0;j<T[i].size();j++)\n\t\t\t{\n\t\t\t\t//cerr<<\"T2 : \"<<i<<' '<<T[i][j]<<'\\n';\n\t\t\t\tindeg[T[i][j]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans2 = 1;\n\t\tvec.clear();\n\t\t\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tif(indeg[i]==0)\n\t\t\t{\n\t\t\t\tii tmp = calctree(i);\n\t\t\t\tans2 = mult(ans2,tmp.fi);\n\t\t\t\t//////cerr<<i<<' '<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\t\t\tvec.pb(tmp.se);\n\t\t\t}\n\t\t}\n\t\t\n\t\tr=0;\n\t\tfor(int i=0;i<vec.size();i++)\n\t\t{\n\t\t\tr+=vec[i];\n\t\t\tans2=mult(ans2,combi.ifact[vec[i]]);\n\t\t}\n\t\t\n\t\tans2=mult(ans2,combi.fact[r]);\n\t\n\t\tadd(ans,ans2);\n\t\tres = mult(res,ans);\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tT[i].clear();\n\t\t\tindeg[i]=0;\n\t\t}\n\t\t//cerr<<comp[z].size()<<' '<<ans<<'\\n';\n\t}\n\tcout<<res<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\ntypedef long long LL;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=400100,mod=1e9+7;\nbool instk[N];\nint n,tp,top,tmpr,ans,w[N],res,f[N],mkx[N],mky[N],F[N],vis[N],stk[N],h[N],t[N];\nstruct xint{int x,y;}p[N];\nvector<int> vx[N],vy[N],V[N];\nbool cmpx(int a,int b){return p[a].x<p[b].x;}\nbool cmpy(int a,int b){return p[a].y<p[b].y;}\nvoid nosolution(){\n\tprintf(\"0\\n\");exit(0);\n}\nvoid dfs(int f,int x){\n\tif(instk[x]){\n\t\tfor(int i=top;;i--){\n\t\t\th[++h[0]]=stk[i];\n\t\t\tif(stk[i]==x)break;\n\t\t}return;\n\t}\n\tif(vis[x])return;\n\tif(!mkx[p[x].x])tmpr++;mkx[p[x].x]=1;\n\tif(!mky[p[x].y])tmpr++;mky[p[x].y]=1;\n\ttmpr--;\n\tvis[x]=1;stk[++top]=x;instk[x]=1;\n\tif(!V[x].empty()){\n\t\tint sz=V[x].size();\n\t\tref(i,0,sz-1)if(V[x][i]!=f)\n\t\t\tdfs(x,V[x][i]);\n\t}\n\tstk[top--]=0;instk[x]=0;\n}\nint dfs(int x){\n\tvis[x]=tp;\n\tt[x]=0;\n\tint X=p[x].x,Y=p[x].y,sum=1;\n\tint sz=V[x].size();\n\tif(w[x]==1){\n\t\tint sz=vx[X].size();\n\t\tref(i,0,sz-1)if(vx[X][i]!=x&&vis[vx[X][i]]!=tp){\n\t\t\tint y=vx[X][i];w[y]=2;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].y<Y){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tif(w[x]==2){\n\t\tint sz=vy[Y].size();\n\t\tref(i,0,sz-1)if(vy[Y][i]!=x&&vis[vy[Y][i]]!=tp){\n\t\t\tint y=vy[Y][i];w[y]=1;\n\t\t\tint s=dfs(y);\n\t\t\tif(p[y].x<X){\n\t\t\t\tt[x]+=t[y];\n\t\t\t\tsum=(LL)sum*F[t[y]]%mod*s%mod;\n\t\t\t}else res=(LL)res*F[t[y]]%mod*s%mod;\n\t\t}\n\t}\n\tsum=(LL)sum*f[t[x]]%mod;\n\tt[x]++;\n\treturn sum;\n}\nvoid work(int x){\n\ttmpr=0;h[0]=0;dfs(0,x);\n\tif(tmpr!=0)nosolution();\n\tint o=0,xx,yy,s=0,Res=0;res=1;\n\tref(i,1,h[0])if(!o||xx<p[h[i]].x||xx==p[h[i]].x&&yy<p[h[i]].y)\n\t\to=h[i],xx=p[h[i]].x,yy=p[h[i]].y;\n\ttp=2;w[o]=1;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;res=1;\n\ttp=3;w[o]=2;s=dfs(o);Res=(Res+(LL)res*F[t[o]]%mod*s%mod)%mod;\n\tans=(LL)ans*Res%mod;\n}\nint mi(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(LL)a*a%mod)\n\t\tif(b&1)s=(LL)s*a%mod;\n\treturn s;\n}\nvoid init(){\n\tf[0]=F[0]=1;\n\tref(i,1,n*2)f[i]=(LL)f[i-1]*i%mod;\n\tF[n*2]=mi(f[n*2],mod-2);\n\tdef(i,n*2-1,1)F[i]=(LL)F[i+1]*(i+1)%mod;\n}\nint main(){\n\tn=read();n=n*2;\n\tref(i,1,n)p[i].x=read(),p[i].y=read();\n\tref(i,1,n)vx[p[i].x].pb(i),vy[p[i].y].pb(i);\n\tref(i,1,n/2)if(!vx[i].empty()){\n\t\tsort(vx[i].begin(),vx[i].end(),cmpy);\n\t\tint s=vx[i].size();\n\t\tref(j,0,s-2)V[vx[i][j]].pb(vx[i][j+1]);\n\t\tref(j,0,s-2)V[vx[i][j+1]].pb(vx[i][j]);\n\t}\n\tref(i,1,n/2)if(!vy[i].empty()){\n\t\tsort(vy[i].begin(),vy[i].end(),cmpx);\n\t\tint s=vy[i].size();\n\t\tref(j,0,s-2)V[vy[i][j]].pb(vy[i][j+1]);\n\t\tref(j,0,s-2)V[vy[i][j+1]].pb(vy[i][j]);\n\t}\n\tinit();ans=f[n];\n\tref(i,1,n)if(!vis[i])work(i);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int maxn=2e5+10;\nconst int mo=1e9+7;\n\nint n,root,Ans=1,tote=1,edge;\nint fa[maxn],fw[maxn],tmp[maxn];\nint fac[maxn],ifac[maxn],vis[maxn],q[maxn];\nint FIR[maxn],TO[maxn*2],NEXT[maxn*2],W[maxn*2];\nbool vise[maxn*2];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nvoid addedge(int u,int v,int w)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tW[tote]=w;\n\tFIR[u]=tote;\n}\n\nvoid dfs1(int u,int F)\n{\n\tif (vis[u]==1) {root=u; return;}\n\tvis[u]=1;\n\tq[++q[0]]=u;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (v==F) continue;\n\t\tif (!vise[p]) edge++,vise[p]=vise[p^1]=1;\n\t\tdfs1(v,u);\n\t}\n}\n\nvoid dfs2(int u)\n{\n\tif (vis[u]==2) return;\n\tvis[u]=2;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (v==fa[u]) continue;\n\t\tfa[v]=u;\n\t\tfw[v]=w;\n\t\tdfs2(v);\n\t}\n}\n\nnamespace Tree{\n\tint n,fa[maxn],dp[maxn],sz[maxn];\n\tint tote,FIR[maxn],TO[maxn<<1],NEXT[maxn<<1];\n\n\tvoid addedge(int u,int v)\n\t{\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t\tfa[v]=u;\n\t}\n\n\tbool dfs(int u)\n\t{\n\t\tif (dp[u]) return 0;\n\t\tsz[u]=0;\n\t\tdp[u]=1;\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!dfs(v)) return 0;\n\t\t\tsz[u]+=sz[v];\n\t\t\tdp[u]=(LL)dp[u]*dp[v]%mo;\n\t\t\tdp[u]=(LL)dp[u]*ifac[sz[v]]%mo;\n\t\t}\n\t\tdp[u]=(LL)dp[u]*fac[sz[u]]%mo;\n\t\tsz[u]++;\n\t\treturn 1;\n\t}\n\n\tvoid solve(int &Ans)\n\t{\n\t\tint i,u;\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n\t\t\tif (!fa[u]) addedge(0,u);\n\t\t}\n\t\tfor (i=1;i<=q[0];i++) u=q[i];\n\t\tif (!dfs(0)) {Ans=0; return;}\n\t\t(Ans+=dp[0])%=mo;\n\t\tfor (i=1;i<=q[0];i++)\n\t\t\tu=q[i],FIR[u]=fa[u]=dp[u]=sz[u]=0;\n\t\tFIR[0]=fa[0]=dp[0]=sz[0]=0;\n\t\ttote=0;\n\t}\n};\n\nvoid dfs3(int u)\n{\n\tif (vis[u]==3) return;\n\tvis[u]=3;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs3(v);\n\t}\n}\n\nvoid dfs4(int u)\n{\n\tif (vis[u]==4) return;\n\tvis[u]=4;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs4(v);\n\t}\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,u,v;\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor (i=1;i<=n+n;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[n+n]=power(fac[n+n],mo-2);\n\tfor (i=n+n;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tfor (i=1;i<=n+n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,n+v,u+v);\n\t\taddedge(n+v,u,u+v);\n\t}\n\tfor (i=1;i<=n+n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tq[0]=0;\n\t\t\troot=0;\n\t\t\tedge=0;\n\t\t\tdfs1(i,0);\n\t\t\tif (!root||edge!=q[0]) {puts(\"0\"); return 0;}\n\t\t\tdfs2(root);\n\t\t\tint Sum=0;\n\t\t\tdfs3(root);\n\t\t\tTree::solve(Sum);\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\ttmp[fa[u]]=fw[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\tfw[u]=tmp[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\t\t\tdfs4(root);\n\t\t\tTree::solve(Sum);\n\t\t\tAns=(LL)Ans*Sum%mo;\n\t\t\tAns=(LL)Ans*ifac[q[0]]%mo;\n\t\t}\n\tAns=(LL)Ans*fac[n+n]%mo;\n\tprintf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR(i,a,b) for(int i=a;i>=b;i--)\n#define FO(i,a,b) for(int i=a;i<=b;i++)\n#define FE(i,a,b) for(int i=a;i<b;i++)\n#define R(i) i=read()\nusing namespace std;\ntypedef long long ll;\nconst int N=200005,MOD=1e9+7;\nint fac[N+10],inv[N+10],head[N],nxt[2*N],to[2*N];\nint pd[N],vis[N],in_cycle[N],f[N],sz[N],instack[N],use[2*N],ass[N],dg[N];\nint n,t,find_cycle,node_cnt,edge_cnt;\nstruct ANS {\n\tint size,ans;\n};\nstack <int> S;\nvector <int> E[N],cycle,Node;\nvector <ANS> Ans;\nint read() {\n\tint x=0;char c=getchar();\n\twhile((c<48||c>57)&&c!='-') c=getchar();\n\tif(c=='-') {c=getchar();while(c>=48&&c<=57) x=x*10-c+48,c=getchar();}\n\telse while(c>=48&&c<=57) x=x*10+c-48,c=getchar();\n\treturn x;\n}\nvoid add(int x,int y) {\n\tnxt[++t]=head[x],head[x]=t,to[t]=y;\n//\tcout<<x<<\" ---> \"<<y<<endl;\n}\nint qmd(int a,int b,int p) {\n\tint t=1;\n\twhile(b) {\n\t\tif(b&1) t=(ll) t*a%MOD;\n\t\ta=(ll) a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn t;\n}\nvoid dfs_cycle(int u,int fa) {\n\tS.push(u);instack[u]=1;\n\tfor(int i=head[u];i!=-1;i=nxt[i]) {\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tif(instack[v]) {\n\t\t\tfind_cycle=1;\n\t\t\tint now=-1;\n\t\t\twhile(now!=v) {\n\t\t\t\tnow=S.top();S.pop();instack[now]=0;\n\t\t\t\tcycle.push_back(now),in_cycle[now]=1;\n\t\t\t}\n\t\t}\n\t\telse dfs_cycle(v,u); \n\t\tif(find_cycle) return ;\n\t}\n\tS.pop(),instack[u]=0;\n}\nvoid dfs_all(int u,int fa) {\n\tvis[u]=1,Node.push_back(u);node_cnt++;\n\tfor(int i=head[u];i!=-1;i=nxt[i]) {\n\t\tint v=to[i];\n\t\tif(!use[i]&&!use[i^1]) edge_cnt++,use[i]=use[i^1]=1;\n\t\tif(!vis[v]&&v!=fa) dfs_all(v,u);\n\t}\n}\nvoid dfs(int u,int fa) {\n\tpd[u]=1;\n\tfor(int i=head[u];i!=-1;i=nxt[i]) {\n\t\tint v=to[i];\n\t\tif(!pd[v]&&v!=fa) \n\t\t\tdfs(v,u);\n\t}\n\tif(!in_cycle[u]) ass[u]=fa;\n}\nvoid dfs_cal(int u) {\n\tint lim=E[u].size(),sum=0,mul=1,aans;\n\tFE(i,0,lim) {\n\t\tdfs_cal(E[u][i]);\n\t\tsum+=sz[E[u][i]],mul=(ll) mul*f[E[u][i]]%MOD;\n\t}\n\taans=fac[sum];\n\tFE(i,0,lim)\n\t\taans=(ll) aans*inv[sz[E[u][i]]]%MOD;\n\taans=(ll) aans*mul%MOD;\n\tsz[u]=sum+1,f[u]=aans;\n}\nint work(int u) {\n\tfind_cycle=0,cycle.clear(),Node.clear();\n\twhile(!S.empty()) instack[S.top()]=0,S.pop();\n\tint l_node_cnt=node_cnt,l_edge_cnt=edge_cnt;\n\tdfs_all(u,0);\n\tif(node_cnt-l_node_cnt!=edge_cnt-l_edge_cnt) return 0;\n\tdfs_cycle(u,0);\n\t\n//\tint tmp=cycle.size();\n//\tcout<<\"cycle : \";\n//\tFE(i,0,tmp) cout<<cycle[i]<<' ';\n//\tcout<<endl;\n\t\n\tdfs(cycle[0],0);\n\t\n\tint lim=cycle.size();\n\tFE(i,0,lim) ass[cycle[i]]=cycle[(i-1+lim)%lim];\n\tlim=Node.size();\n\tFE(i,0,lim) E[Node[i]].clear(),dg[Node[i]]=0;\t//先清零dg[] \n\tFE(i,0,lim) {\n\t\tint u=Node[i];\n\t\tfor(int j=head[u];j!=-1;j=nxt[j]) {\n\t\t\tint v=to[j];\n\t\t\tif(v<ass[u]) \n\t\t\t\tE[u].push_back(v),dg[v]++;\n//\t\t\t\tcout<<u<<\" ---> \"<<v<<endl;\n\t\t}\n\t}\n\t\n//\tcout<<endl<<endl;\n\t\n\t\n\tE[0].clear();\n\tFE(i,0,lim) if(dg[Node[i]]==0) E[0].push_back(Node[i]);\n\tf[0]=0;\n\tdfs_cal(0);\n\tint ans1=f[0];\n\tlim=cycle.size();\n\tFE(i,0,lim) ass[cycle[i]]=cycle[(i+1)%lim];\n\tlim=Node.size();\n\tFE(i,0,lim) E[Node[i]].clear(),dg[Node[i]]=0;\n\tFE(i,0,lim) {\n\t\tint u=Node[i];\n\t\tfor(int j=head[u];j!=-1;j=nxt[j]) {\n\t\t\tint v=to[j];\n\t\t\tif(v<ass[u]) \n\t\t\t\tE[u].push_back(v),dg[v]++;\n//\t\t\t\tcout<<u<<\" ---> \"<<v<<endl;\n\t\t}\n\t}\n\tE[0].clear();\n\tFE(i,0,lim) if(dg[Node[i]]==0) E[0].push_back(Node[i]);\n\tf[0]=0;\n\tdfs_cal(0);\n\tint ans2=f[0];\n\tAns.push_back((ANS) {Node.size(),(ans1+ans2)%MOD});\n\treturn 1;\n}\nvoid init() {\n\tfac[0]=inv[0]=1;\n\tFO(i,1,N) \n\t\tfac[i]=((ll)fac[i-1]*i)%MOD;\n\tFO(i,1,N) inv[i]=qmd(fac[i],MOD-2,MOD);\n\tmemset(head,-1,sizeof(head));\n\tt=-1;\n}\nint main() {\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tinit();\n\tcin>>n;\n\tint a,b;\n\tFO(i,1,2*n) cin>>a>>b,add(a,n+b),add(n+b,a);\n\tFO(i,1,2*n) \n\t\tif(!vis[i])\n\t\t\tif(!work(i)) {cout<<0;return 0;}\n\tint lim=Ans.size(),sum=0,mul=1,ans;\n\tFE(i,0,lim) \n\t\tsum+=Ans[i].size,mul=(ll) mul*Ans[i].ans%MOD;\n\tans=fac[sum];\n\tFE(i,0,lim)\n\t\tans=(ll) ans*inv[Ans[i].size]%MOD;\n\tans=(ll) ans*mul%MOD;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<TEN(9) + 7>;\n\nstruct UnionFind {\n    V<int> p, r;\n    int gn;\n    UnionFind(int n = 0) : p(n, -1), r(n, 1), gn(n) {}\n    void merge(int a, int b) {\n        int x = group(a), y = group(b);\n        if (x == y) return;  // same\n        gn--;\n        if (r[x] < r[y]) {\n            p[x] = y;\n        } else {\n            p[y] = x;\n            if (r[x] == r[y]) r[x]++;\n        }\n    }\n    int group(int a) {\n        if (p[a] == -1) return a;\n        return p[a] = group(p[a]);\n    }\n    bool same(int a, int b) { return group(a) == group(b); }\n};\n\nconst int N = 233333;\nint n;\nMint fac[N], ifac[N];\nint a[N], b[N];\nV<int> cc[N];\n\nvoid first() {\n    fac[0] = 1;\n    for (int i = 1; i < N; i++) fac[i] = Mint(i) * fac[i - 1];\n    for (int i = 0; i < N; i++) ifac[i] = fac[i].inv();\n}\n\nMint C(int n, int k) {\n    return fac[n] * ifac[k] * ifac[n - k];\n}\n\nstruct E {\n    int to, id;\n};\n\nusing P = pair<int, int>;\nMint gao(int n, int m, V<int> a, V<int> b, V<int> dir) {\n    V<V<P>> xs(n), ys(m);\n    for (int i = 0; i < n + m; i++) {\n        xs[a[i]].push_back(P(b[i], i));\n        ys[b[i]].push_back(P(a[i], i));\n    }\n    \n    V<V<int>> g(n + m);\n    \n    for (int d = 0; d < n; d++) {\n        sort(xs[d].begin(), xs[d].end());\n        for (int k = 0; k < (int)xs[d].size(); k++) {\n            int i = xs[d][k].second;\n            if (dir[i] == 0) {\n                for (int j = 0; j < k; j++) {\n                    g[i].push_back(xs[d][j].second);\n                }\n            }\n        }\n    }\n    \n    for (int d = 0; d < m; d++) {\n        sort(ys[d].begin(), ys[d].end());\n        for (int k = 0; k < (int)ys[d].size(); k++) {\n            int i = ys[d][k].second;\n            if (dir[i] == 1) {\n                for (int j = 0; j < k; j++) {\n                    g[i].push_back(ys[d][j].second);\n                }\n            }\n        }\n    }\n    \n    V<bool> rt(n + m, true);\n    for (int i = 0; i < n + m; i++) {\n        for (int v: g[i]) rt[v] = false;\n    }\n    V<int> to;\n    for (int i = 0; i < n + m; i++) {\n        if (rt[i]) to.push_back(i);\n    }\n    g.push_back(to);\n    \n    Mint pr = 1;\n    function<int(int)> dfs = [&](int v) {\n        int sz = 1;\n        for (int u: g[v]) {\n            int csz = dfs(u);\n            sz += csz;\n            pr *= C(sz - 1, csz);\n        }\n        return sz;\n    };\n    dfs(n + m);\n    \n    return pr;\n}\n\nMint calc(int n, int m, V<int> a, V<int> b) {\n    if (n + m != (int)a.size()) return Mint(0);\n    \n    V<V<E>> g(n + m);\n    for (int i = 0; i < n + m; i++) {\n        g[a[i]].push_back(E{n + b[i], i});\n        g[n + b[i]].push_back(E{a[i], i});\n    }\n    \n    V<int> deg(n + m);\n    for (int i = 0; i < n + m; i++) {\n        deg[i] = g[i].size();\n    }\n    \n    queue<int> que;\n    for (int i = 0; i < n + m; i++) {\n        if (deg[i] == 1) {\n            que.push(i);\n        }\n    }\n    \n    V<bool> used(n + m);\n    V<int> dir(n + m, -1);\n    while (que.size()) {\n        int v = que.front(); que.pop();\n        used[v] = true;\n        int i = -1;\n        for (E e: g[v]) {\n            if (used[e.to]) continue;\n            i = e.id;\n            deg[e.to]--;\n            if (deg[e.to] == 1) que.push(e.to);\n        }\n        assert(i != -1);\n        dir[i] = (v >= n);\n    }\n    \n    int i2 = -1;\n    for (int i = 0; i < n + m; i++) {\n        if (dir[i] == -1) i2 = i;\n    }\n    if (i2 == -1) return gao(n, m, a, b, dir);\n    \n    V<int> memo = dir;\n    Mint ans = 0;\n    for (int c = 0; c < 2; c++) {\n        dir = memo;\n        int st = -1;\n        if (c == 0) {\n            st = a[i2];\n            dir[i2] = 0;\n        } else {\n            st = n + b[i2];\n            dir[i2] = 1;\n        }\n        \n        V<bool> used(n + m);\n        used[st] = true;\n        queue<int> que;\n        que.push(st);\n        while (que.size()) {\n            int v = que.front(); que.pop();\n            for (E e: g[v]) {\n                if (dir[e.id] >= 0) continue;\n                dir[e.id] = (e.to >= n);\n                if (!used[e.to]) {\n                    used[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        ans += gao(n, m, a, b, dir);\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    first();\n    \n    cin >> n;\n    UnionFind uf(2 * n);\n    for (int i = 0; i < 2 * n; i++) {\n        cin >> a[i] >> b[i]; a[i]--; b[i]--;\n        uf.merge(a[i], b[i] + n);\n    }\n    \n    for (int i = 0; i < 2 * n; i++) {\n        cc[uf.group(a[i])].push_back(i);\n    }\n    \n    Mint ans = 1;\n    int r = 2 * n;\n    for (int i = 0; i < 2 * n; i++) {\n        auto v = cc[i];\n        if (v.empty()) continue;\n        V<int> c, d;\n        for (int i: v) {\n            c.push_back(a[i]);\n            d.push_back(b[i]);\n        }\n        V<int> c2 = c, d2 = d;\n        sort(c2.begin(), c2.end());\n        sort(d2.begin(), d2.end());\n        c2.erase(unique(c2.begin(), c2.end()), c2.end());\n        d2.erase(unique(d2.begin(), d2.end()), d2.end());\n        for (int& u: c) {\n            u = lower_bound(c2.begin(), c2.end(), u) - c2.begin();\n        }\n        for (int& u: d) {\n            u = lower_bound(d2.begin(), d2.end(), u) - d2.begin();\n        }\n        ans *= calc(c2.size(), d2.size(), c, d) * C(r, int(v.size()));\n        r -= int(v.size());\n    }\n    \n    cout << ans.v << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nclass unionfind {\n\tvector<int> par, rank;\n\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return ;\n\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y]) ++rank[x];\n\t\t}\n\t}\n\n\tbool same(int x, int y) { return (find(x) == find(y)); }\n} uf;\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = TEN(5) + 10;\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < MX; ++i) {\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t}\n\tfact[0] = ifact[0] = 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tifact[i] = ifact[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(int n, int r) {\n\tif (n < 0 || r < 0 || r > n) return 0;\n\treturn fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\n// allow multiple components\nconst int maxn = 200010;\n\nint V;\nint deg[maxn], par[maxn];\nvi g[maxn], g2[maxn];\nbool vis[maxn];\nvector<vi> cycles;\n\nvoid add_edge(int a, int b) {\n\tg[a].pb(b); g[b].pb(a);\n\t++deg[a]; ++deg[b];\n}\n\nvoid dfs(int v, vi& cycle) {\n\tvis[v] = true;\n\tcycle.pb(v);\n\n\tfor (int to : g[v]) if (deg[to] == 2 && !vis[to]) {\n\t\tdfs(to, cycle);\n\t}\n}\n\nvoid build() {\n\tmemset(par, -1, sizeof(par));\n\n\tqueue<int> que;\n\trep(i, V) {\n\t\tif (deg[i] == 1) {\n\t\t\tque.push(i);\n\t\t}\n\t}\n\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tvis[v] = true;\n\t\tfor (int to : g[v]) if (deg[to] > 1) {\n\t\t\tg2[to].pb(v);\n\t\t\tpar[v] = to;\n\n\t\t\tif (--deg[to] == 1) {\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, V) if (deg[i] == 2 && !vis[i]) {\n\t\tvi cyc;\n\t\tcycles.eb(cyc);\n\t\tdfs(i, cycles.back());\n\t}\n}\n\nint dp[maxn];\n\nbool us[maxn];\nint ord[maxn];\n\nvoid topo(int v, int &k, const vector<vi>& gp) {\n\tus[v] = true;\n\tfor (int to : gp[v]) {\n\t\tif (!us[to]) {\n\t\t\ttopo(to, k, gp);\n\t\t}\n\t}\n\tord[v] = k++;\n}\n\nint reach(int v, const vector<vi>& gp) {\n\tif (dp[v] != -1) {\n\t\treturn dp[v];\n\t}\n\tint s = 0;\n\tfor (int to : gp[v]) {\n\t\ts += reach(to, gp) + 1;\n\t}\n\treturn dp[v] = s;\n}\n\nvi cmp[maxn];\nint id[maxn];\n\nint main() {\n\tint N; cin >> N; V = N * 2;\n\tinit();\n\tuf.init(V);\n\n\trep(i, N*2) {\n\t\tint x, y; cin >> x >> y;\n\t\t--x; --y;\n\t\tadd_edge(x, y + N);\n\t\tuf.unite(x, y + N);\n\t}\n\n\tbuild();\n\tbool ok = true;\n\trep(i, V) if (!vis[i]) {\n\t\tok = false;\n\t}\n\n\tif (!ok) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\n\tll ans = 1;\n\n\trep(i, V) cmp[uf.find(i)].pb(i);\n\tint s = 0;\n\n\trep(i, cycles.size()) {\n\t\tint c = uf.find(cycles[i][0]);\n\t\tvi& vec = cmp[c];\n\t\tvi match(vec.size(), -1);\n\t\trep(j, vec.size()) id[vec[j]] = j;\n\n\t\tll way = 0;\n\t\trep(t, 2) { //try 2 directions\n\t\t\tvector<vi> gp(vec.size());\n\n\t\t\trep(j, vec.size()) {\n\t\t\t\tdp[j] = -1;\n\t\t\t\tus[j] = 0;\n\t\t\t}\n\n\t\t\tfor (int v : vec) if (par[v] != -1) {\n\t\t\t\tmatch[id[v]] = id[par[v]];\n\t\t\t}\n\t\t\trep(j, cycles[i].size()) {\n\t\t\t\tint nx = (j + 1) % cycles[i].size();\n\t\t\t\tmatch[id[cycles[i][j]]] = id[cycles[i][nx]];\n\t\t\t}\n/*\n\t\t\trep(j, vec.size()) {\n\t\t\t\tcout << vec[j] << \", id = \" << j << \" \" << match[j] << endl;\n\t\t\t}\n*/\n\t\t\tfor (int v : vec) {\n\t\t\t\tint to = match[id[v]];\n\t\t\t\tfor (int u : g[v]) {\n\t\t\t\t\tif (u < vec[to]) {\n\t\t\t\t\t\tgp[id[v]].pb(id[u]);\n\t\t\t\t\t\t//cerr << id[v] << \"---\" << id[u] << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint now = 0;\n\n\t\t\trep(j, vec.size()) {\n\t\t\t\tif (!us[j]) {\n\t\t\t\t\ttopo(j, now, gp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool ok = true;\n\t\t\trep(j, vec.size()) {\n\t\t\t\tfor (int to : gp[j]) {\n\t\t\t\t\tif (ord[j] < ord[to]) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tll f = 1;\n\t\t\tif (ok) {\n\t\t\t\trep(j, vec.size()) {\n\t\t\t\t\tf = f * inv[reach(j, gp) + 1] % MOD;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tf = 0;\n\t\t\t}\n\n\t\t\tway = (way + f) % MOD;\n\n\t\t\treverse(ALL(cycles[i]));\n\t\t}\n\n\t\tway = way * fact[cmp[c].size()] % MOD;\n\n\t\tans = ans * way % MOD * comb(s + cmp[c].size(), s) % MOD;\n\t\ts += cmp[c].size();\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\n#define ll long long\n#define maxn 200005\n#define mo 1000000007\ninline ll read()\n{\n\tll x=0,w=0;char ch=getchar();\n\twhile(!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn w?-x:x;\n}\nvector<int>A[maxn];\nvector<int>G[maxn];\nint n,tot;\nint jc[maxn],ans[maxn],inst[maxn];\nint vis[maxn],vis1[maxn],fa[maxn],huan[maxn],size[maxn];\nint headd[maxn],nextt[maxn<<1],to[maxn<<1],cntt;\ninline int ksm(int x,int y)\n{\n    int a=1;\n    while(y)\n    {\n        if(y&1)a=1ll*a*x%mo;\n        x=1ll*x*x%mo;y>>=1;\n    }return a;\n}\ninline void add(int u,int v)\n{nextt[++cntt]=headd[u];headd[u]=cntt;to[cntt]=v;}\ninline void dfs(int u,int f)\n{\n    vis[u]=tot;A[tot].push_back(u);fa[u]=f;inst[u]=1;\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(vis[to[i]]){if(inst[to[i]])huan[fa[to[i]]]=-1,huan[u]++;}\n        else dfs(to[i],u),huan[u]+=huan[to[i]];\n    }inst[u]=0;\n}\ninline void dfs1(int u,int f)\n{\n    for(reg int i=headd[u];i;i=nextt[i])\n    {\n        if(to[i]==f)continue;\n        if(huan[to[i]]==1)continue;\n        fa[to[i]]=u;dfs1(to[i],u);\n    }\n}\ninline void dfs2(int u)\n{\n    reg int i,sz=G[u].size();\n    size[u]=1;vis1[u]=1;\n    for(i=0;i<sz;++i)\n    {\n        if(!vis1[G[u][i]])dfs2(G[u][i]);\n        size[u]+=size[G[u][i]];\n    }\n}\ninline void solve1()\n{\n    reg int i,j,u,sz=A[tot].size();\n    for(j=0;j<sz;++j)\n    {\n        u=A[tot][j];G[u].clear();\n        for(i=headd[u];i;i=nextt[i])\n        {\n            if(fa[to[i]]!=u)continue;\n            if(to[i]<fa[u])G[u].push_back(to[i]);\n        }\n    }\n    for(i=0;i<sz;++i)\n        if(!vis1[A[tot][i]])\n            dfs2(A[tot][i]);\n    for(i=0;i<sz;++i)vis1[A[tot][i]]=0;\n    reg int tmp=1;\n    for(i=0;i<sz;++i)tmp=1ll*tmp*size[A[tot][i]]%mo;\n    ans[tot]+=1ll*jc[sz]*ksm(tmp,mo-2)%mo;if(ans[tot]>=mo)ans[tot]-=mo;\n}\ninline void solve()\n{\n    reg int i,sz=A[tot].size(),fi,k;\n    for(i=0;i<sz;++i)\n        if(huan[A[tot][i]]==1){fi=A[tot][i];break;}\n    k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[to[i]]!=k){fa[k]=to[i];k=to[i];break;}\n    }while(fi!=k);solve1();k=fi;\n    for(i=0;i<sz;++i)fa[A[tot][i]]=0;\n    do\n    {\n        dfs1(k,0);\n        for(i=headd[k];i;i=nextt[i])\n            if(huan[to[i]]==1&&fa[k]!=to[i]){fa[to[i]]=k;k=to[i];break;}\n    }while(fi!=k);solve1();\n}\nint ha[maxn],ha1[maxn];\nint main()\n{\n    n=read();reg int i,x,y;jc[0]=1;\n    for(i=1;i<=2*n;++i)jc[i]=1ll*jc[i-1]*i%mo;\n    for(i=1;i<=2*n;++i)\n    {\n        x=read(),y=read();ha[x]=1;ha1[y]=1;\n        add(x,n+y),add(n+y,x);\n    }\n    for(i=1;i<=n;++i)if(!ha[i]){puts(\"0\");return 0;}\n    for(i=1;i<=n;++i)if(!ha1[i]){puts(\"0\");return 0;}\n    for(i=1;i<=n*2;++i)if(!vis[i])\n        ++tot,dfs(i,0),solve();\n    reg int sum=1,su=1;\n    for(i=1;i<=tot;++i)sum=1ll*sum*ans[i]%mo;\n    for(i=1;i<=tot;++i)su=1ll*su*jc[A[i].size()]%mo;\n    sum=1ll*sum*jc[2*n]%mo*ksm(su,mo-2)%mo;\n    printf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,m,i,j,xia[200005],zuo[200005],book[200005],book2[200005],sum1,sum2,now,flag;\nlong long x,y,z,top2,zhan1[200005],zhan2[200005],sum,ans,sum3[200005],jc[200005],ny[200005];\nlong long top=1,nex[400005],to[400005],fir[200005],p1,p2,p3;\nlong long top3,nex2[400005],to2[400005],fir2[200005];\nlong long maxx(long long u,long long v){\n\treturn u>v?u:v;\n}\nlong long ksm(long long u,long long v){\n\tlong long o=1;\n\twhile(v){\n\t\tif(v&1)\n\t\t\to=o*u%mo;\n\t\tu=u*u%mo;\n\t\tv>>=1;\t\n\t}\n\treturn o;\n}\nvoid lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\nvoid lj2(int u,int v){\n\ttop3++;\n\tnex2[top3]=fir2[u];\n\tfir2[u]=top3;\n\tto2[top3]=v;\n}\nstruct nyh{\n\tint x,y,id;\n}o[200005];\nbool cmp(nyh u,nyh v){\n\treturn u.x<v.x||u.x==v.x&&u.y<v.y;\n}\nbool cmp2(nyh u,nyh v){\n\treturn u.y<v.y||u.y==v.y&&u.x<v.x;\n}\nbool cmp3(nyh u,nyh v){\n\treturn u.id<v.id;\n}\nvoid ss(int u,int v){\n\tbook[v]=1;\n\tsum1++;\n\tfor(int top1=fir[v];top1;top1=nex[top1]){\n\t\tsum2++;\n\t\tif(book[to[top1]]==0)\n\t\t\tss(v,to[top1]);\n\t}\n}\nint ss2(int u,int v){\n\tif(flag==1)\n\t\treturn 0;\n\tbook[v]=2;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(to[top1]!=u){\n\t\t\tif(book[to[top1]]==2){\n\t\t\t\tx=v;\n\t\t\t\ty=to[top1];\n\t\t\t\tz=top1/2;\n\t\t\t\tflag=1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tss2(v,to[top1]);\n\t\t\tif(flag==1)\n\t\t\t\treturn 0;\n\t\t}\n}\nvoid ss3(int u,int v,long long w){\n\ttop2++;\n\tzhan1[top2]=v;\n\tzhan2[top2]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(to[top1]!=u&&top1/2!=z)\n\t\t\tss3(v,to[top1],top1/2);\n}\nvoid ss4(int v){\n\tsum3[v]=1;\n\tbook[v]=maxx(3,book[v]+1);\n\tfor(int top1=fir2[v];top1;top1=nex2[top1]){\n\t\tif(book[to2[top1]]!=book[v])\n\t\t\tss4(to2[top1]);\t\t\n\t\tsum3[v]+=sum3[to2[top1]];\n\t}\n\tnow=now*jc[sum3[v]-1]%mo*ny[sum3[v]]%mo;\n}\nint main(){\n\tn=read();m=n*2;\n\tjc[0]=1;\n\tfor(i=1;i<=m;i++)\n\t\tjc[i]=jc[i-1]*i%mo;\n\tny[m]=ksm(jc[m],mo-2);\n\tfor(i=m-1;i>=0;i--)\n\t\tny[i]=ny[i+1]*(i+1)%mo;\n\tfor(i=1;i<=m;i++){\n\t\to[i].x=read();\n\t\to[i].y=read();\n\t\to[i].id=i;\n\t}\n\tsort(o+1,o+m+1,cmp);\n\tfor(i=2;i<=m;i++)\n\t\tif(o[i].x==o[i-1].x)\n\t\t\txia[o[i].id]=o[i-1].id;\n\tsort(o+1,o+m+1,cmp2);\n\tfor(i=2;i<=m;i++)\n\t\tif(o[i].y==o[i-1].y)\n\t\t\tzuo[o[i].id]=o[i-1].id;\n\tsort(o+1,o+m+1,cmp3);\n\tfor(i=1;i<=m;i++){\n\t\tlj(o[i].x,o[i].y+n);\n\t\tlj(o[i].y+n,o[i].x);\n\t}\n\tans=jc[m];\n\tfor(i=1;i<=m;i++)\n\t\tif(book[i]==0){\n\t\t\tss(i,i);\n\t\t\tif(sum1!=sum2/2){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tflag=0;\n\t\t\tss2(i,i);\n\t\t\tsum=0;\n\n\t\t\ttop2=0;\n\t\t\tss3(x,x,z);\n\t\t\tnow=jc[top2];\n\t\t\tfor(j=1;j<=top2;j++)\n\t\t\t\tbook2[zhan2[j]]=zhan1[j];\n\t\t\tfor(j=1;j<=top2;j++){\n\t\t\t\tif(zhan1[j]>n){\n\t\t\t\t\tp1=zuo[zhan2[j]];\n\t\t\t\t\twhile(p1!=0){\n\t\t\t\t\t\tlj2(zhan1[j],book2[p1]);\n\t\t\t\t\t\tp1=zuo[p1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tp1=xia[zhan2[j]];\n\t\t\t\t\twhile(p1!=0){\n\t\t\t\t\t\tlj2(zhan1[j],book2[p1]);\n\t\t\t\t\t\tp1=xia[p1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=1;j<=top2;j++)\n\t\t\t\tif(book[zhan1[j]]!=3)\n\t\t\t\t\tss4(zhan1[j]);\n\t\t\tfor(j=1;j<=top3;j++){\n\t\t\t\tnex2[j]=0;\n\t\t\t\tto2[j]=0;\n\t\t\t}\n\t\t\tfir2[0]=0;\n\t\t\tfor(j=1;j<=top2;j++)\n\t\t\t\tfir2[zhan1[j]]=0;\n\t\t\ttop3=0;\n\t\t\tsum=(sum+now)%mo;\n\t\t\t\n\t\t\ttop2=0;\n\t\t\tss3(y,y,z);\n\t\t\tnow=jc[top2];\n\t\t\tfor(j=1;j<=top2;j++)\n\t\t\t\tbook2[zhan2[j]]=zhan1[j];\n\t\t\tfor(j=1;j<=top2;j++){\n\t\t\t\tif(zhan1[j]>n){\n\t\t\t\t\tp1=zuo[zhan2[j]];\n\t\t\t\t\twhile(p1!=0){\n\t\t\t\t\t\tlj2(zhan1[j],book2[p1]);\n\t\t\t\t\t\tp1=zuo[p1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tp1=xia[zhan2[j]];\n\t\t\t\t\twhile(p1!=0){\n\t\t\t\t\t\tlj2(zhan1[j],book2[p1]);\n\t\t\t\t\t\tp1=xia[p1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=1;j<=top2;j++)\n\t\t\t\tif(book[zhan1[j]]!=4)\n\t\t\t\t\tss4(zhan1[j]);\n\t\t\tfor(j=1;j<=top3;j++){\n\t\t\t\tnex2[j]=0;\n\t\t\t\tto2[j]=0;\n\t\t\t}\n\t\t\tfir2[0]=0;\n\t\t\tfor(j=1;j<=top2;j++)\n\t\t\t\tfir2[zhan1[j]]=0;\n\t\t\ttop3=0;\n\t\t\tsum=(sum+now)%mo;\n\t\t\tans=ans*sum%mo*ny[top2]%mo;\n\t\t}\n\tpus(ans,2);\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define M 400005\n#define mod 1000000007\n#define PB push_back\n#define MP std::make_pair\n#define FI first\n#define SE second\ntypedef long long ll;\nint n, X[M], Y[M], deg[M], bel[M], fa[M], size[M], id[M], V, E;\nstd::vector <int> vec, tmp, Tree[M];\nstd::vector <std::pair <int, int> > cir;\nstd::vector <std::pair <int, int> > Edge[M];\nstd::vector <std::pair <int, int> > row[M], col[M];\nbool vis[M];\nll fac[M], fac_inv[M], inv[M];\nint read() {\n\tchar c = getchar(); int ans = 0;\n\twhile (c < '0' || c > '9') c = getchar();\n\twhile (c >= '0' && c <= '9') ans = ans * 10 + c - '0', c = getchar();\n\treturn ans;\n}\nvoid Write(int x) {\n\tif (x < 10) putchar(x + '0');\n\telse Write(x / 10), putchar(x % 10 + '0');\n}\nll invs(ll x) {return x == 1 ? 1 : (mod - mod / x) * invs(mod % x) % mod;}\nvoid dfs1(int x) {\n\tvec.PB(x), vis[x] = 1, V++;\n\tfor (auto i : Edge[x]) {\n\t\tif (i.SE != fa[x]) E++;\n\t\tif (!vis[i.SE]) fa[i.SE] = x, id[i.SE] = i.FI, dfs1(i.SE);\n\t}\n}\nvoid dfs2(int x) {\n\tfor (auto i : Edge[x]) {\n\t\tif (i.SE == fa[x]) continue;\n\t\tif (fa[i.SE] == x) dfs2(i.SE);\n\t\telse if (cir.empty()) {\n\t\t\tfor (int j = x; j != i.SE; j = fa[j]) cir.PB(MP(j, id[j]));\n\t\t\tcir.PB(MP(i.SE, i.FI));\n\t\t}\n\t}\n}\nll dfs3(int x) {\n\tsize[x] = 1; ll ans = 1;\n\tfor (auto i : Tree[x]) ans = ans * dfs3(i) % mod, size[x] += size[i];\n\treturn ans * inv[size[x]] % mod;\n}\nll calc() {\n\tfor (auto i : tmp) Tree[i].clear(), deg[i] = 0; ll ans = 1;\n\tfor (auto i : tmp) {\n\t\tif (bel[i] <= n) {\n\t\t\tfor (auto j : row[bel[i]])\n\t\t\t\tif (j.FI < Y[i]) Tree[i].PB(j.SE), deg[j.SE]++;\n\t\t}\n\t\telse {\n\t\t\tfor (auto j : col[bel[i] - n])\n\t\t\t\tif (j.FI < X[i]) Tree[i].PB(j.SE), deg[j.SE]++;\n\t\t}\n\t}\n\tfor (auto i : tmp)\n\t\tif (!deg[i]) ans = ans * dfs3(i) % mod;\n\treturn ans;\n}\nll calc(int rt) {\n\tvec.clear(), cir.clear(), tmp.clear(), V = E = 0, dfs1(rt);\n\tif (V != --E) return 0; dfs2(rt); std::queue <int> Q;\n\tfor (auto i : vec) deg[i] = Edge[i].size();\n\tfor (auto i : vec)\n\t\tif (deg[i] == 1) Q.push(i), deg[i] = 0;\n\twhile (!Q.empty()) {\n\t\tint now = Q.front(); Q.pop();\n\t\tfor (auto i : Edge[now])\n\t\t\tif (deg[i.SE]) {\n\t\t\t\tdeg[i.SE]--, bel[i.FI] = now, tmp.PB(i.FI);\n\t\t\t\tif (deg[i.SE] == 1) deg[i.SE] = 0, Q.push(i.SE);\n\t\t\t}\n\t}\n\tll ans = 0;\n\tfor (int j = 0; j < cir.size() - 1; j++) bel[cir[j].SE] = cir[j].FI, tmp.PB(cir[j].SE);\n\tbel[cir.back().SE] = cir.back().FI, tmp.PB(cir.back().SE), ans += calc();\n\tstd::reverse(cir.begin(), cir.end()); int u = cir.begin() -> SE; tmp.resize(tmp.size() - cir.size());\n\tfor (int j = 0; j < cir.size() - 1; j++) cir[j].SE = cir[j + 1].SE; cir.back().SE = u;\n\tfor (int j = 0; j < cir.size() - 1; j++) bel[cir[j].SE] = cir[j].FI, tmp.PB(cir[j].SE);\n\tbel[cir.back().SE] = cir.back().FI, tmp.PB(cir.back().SE), ans += calc();\n\treturn ans;\n}\nint main() {\n\tn = read(); ll ans = 1; fac[0] = 1;\n\tfor (int i = 1; i <= n * 2; i++) fac[i] = fac[i - 1] * i % mod; fac_inv[n * 2] = invs(fac[n * 2]);\n\tfor (int i = n * 2; i; i--) fac_inv[i - 1] = fac_inv[i] * i % mod;\n\tfor (int i = 1; i <= n * 2; i++) inv[i] = fac_inv[i] * fac[i - 1] % mod;\n\tfor (int i = 1; i <= n * 2; i++)\n\t\tX[i] = read(), Y[i] = read(), row[X[i]].PB(MP(Y[i], i)), col[Y[i]].PB(MP(X[i], i)),\n\t\tEdge[X[i]].PB(MP(i, Y[i] + n)), Edge[Y[i] + n].PB(MP(i, X[i]));\n\tfor (int i = 1; i <= n * 2; i++)\n\t\tif (!vis[i]) ans = ans * calc(i) % mod;\n\treturn Write(ans * fac[n * 2] % mod), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v; };\n\nint f[300000], fi[300000];\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n>>=1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint inv_mod(int x, int p) {\n\treturn pow_mod(x, p - 2, p);\n}\n\nint C(int x, int y) {\n\treturn (ll)f[x] * fi[y] % MOD * fi[x - y] % MOD;\n}\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint prod;\n\nint dfs(int u, vector<vector<int> >& G) {\n\tint tot = 0;\n\tfor (int v: G[u]) {\n\t\tint sz = dfs(v, G);\n\t\ttot += sz;\n\t\tprod = (ll)prod * C(tot, sz) % MOD;\n\t}\n\treturn tot + 1;\n}\n\nint calc(int N, int M, vector<int> a, vector<int> b, vector<int> dir) {\n\trep(i, N + M) if (dir[i] == -1) return 0;\n\tvector<int> unko(N + M);\n\trep(i, N + M) {\n\t\tif (dir[i] == 0) unko[a[i]]++;\n\t\tif (dir[i] == 1) unko[N + b[i]]++;\n\t}\n\trep(u, N + M) if (unko[u] != 1) return 0;\n\tvector<vector<i_i> > xs(N), ys(M);\n\trep(i, N + M) xs[a[i]].pb(i_i(b[i], i));\n\trep(i, N + M) ys[b[i]].pb(i_i(a[i], i));\n\tvector<vector<int> > G(N + M);\n\tvector<bool> root(N + M, true);\n\trep(k, N) {\n\t\tsort(xs[k].begin(), xs[k].end());\n\t\trep(l, xs[k].size()) {\n\t\t\tint i = xs[k][l].second;\n\t\t\tif (dir[i] == 0)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(xs[k][_l].second);\n\t\t}\n\t}\n\trep(k, N) {\n\t\tsort(ys[k].begin(), ys[k].end());\n\t\trep(l, ys[k].size()) {\n\t\t\tint i = ys[k][l].second;\n\t\t\tif (dir[i] == 1)\n\t\t\t\trep(_l, l)\n\t\t\t\tG[i].pb(ys[k][_l].second);\n\t\t}\n\t}\n\trep(u, N + M) for (int v: G[u]) root[v] = false;\n\tvector<int> to;\n\trep(u, N + M) if (root[u]) to.pb(u);\n\tG.pb(to);\n\tprod = 1;\n\tdfs(N + M, G);\n\treturn prod;\n}\n\nint solve(int N, int M, vector<int> a, vector<int> b) {\n\tif (N + M != a.size()) return 0;\n\tvector<vector<edge> > G(N + M);\n\trep(i, N + M) G[a[i]].pb(edge{i, N + b[i]}), G[N + b[i]].pb(edge{i, a[i]});\n\tvector<int> d(N + M);\n\trep(u, N + M) d[u] = G[u].size();\n\tqueue<int> q;\n\trep(u, N + M) if (d[u] == 1) q.push(u);\n\tvector<bool> exist(N + M, true);\n\tvector<int> dir(N + M, -1);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\texist[u] = false;\n\t\tint i;\n\t\tfor (edge e: G[u]) if (exist[e.v]) {\n\t\t\ti = e.i;\n\t\t\td[e.v]--;\n\t\t\tif (d[e.v] == 1) q.push(e.v);\n\t\t}\n\t\tdir[i] = (u >= N);\n\t}\n\tint i0 = -1;\n\trep(i, N + M) if (dir[i] == -1) i0 = i;\n\tif (i0 == -1) return calc(N, M, a, b, dir);\n\tvector<int> dir0 = dir;\n\tint ans = 0;\n\trep(t, 2) {\n\t\tdir = dir0;\n\t\tint s;\n\t\tif (t == 0) s = a[i0], dir[i0] = 0;\n\t\tif (t == 1) s = N + b[i0], dir[i0] = 1;\n\t\tvector<bool> vis(N + M); vis[s] = true;\n\t\tqueue<int> q; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (edge e: G[u]) if (dir[e.i] == -1) {\n\t\t\t\tdir[e.i] = (e.v >= N);\n\t\t\t\tif (!vis[e.v]) {\n\t\t\t\t\tvis[e.v] = true;\n\t\t\t\t\tq.push(e.v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (ans + calc(N, M, a, b, dir)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tf[0] = fi[0] = 1;\n\tfor (int x = 1; x < 300000; x++) {\n\t\tf[x] = (ll)f[x - 1] * x % MOD;\n\t\tfi[x] = (ll)fi[x - 1] * inv_mod(x, MOD) % MOD;\n\t}\n\tint N; cin >> N;\n\tvector<int> a(N * 2), b(N * 2);\n\trep(i, N * 2) scanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\tunion_find uf(N * 2);\n\trep(i, N * 2) uf.unite(a[i], b[i] + N);\n\tvector<vector<int> > vv(N * 2);\n\trep(i, N * 2) vv[uf.find(a[i])].pb(i);\n\tint ans = 1;\n\tfor (vector<int> v: vv) if (!v.empty()) {\n\t\tvector<int> _a, _b;\n\t\tfor (int i: v) _a.pb(a[i]), _b.pb(b[i]);\n\t\tvector<int> A = _a, B = _b;\n\t\tsort(A.begin(), A.end());\n\t\tsort(B.begin(), B.end());\n\t\tA.erase(unique(A.begin(), A.end()), A.end());\n\t\tB.erase(unique(B.begin(), B.end()), B.end());\n\t\tfor (int& u: _a) u = lower_bound(A.begin(), A.end(), u) - A.begin();\n\t\tfor (int& u: _b) u = lower_bound(B.begin(), B.end(), u) - B.begin();\n\t\tans = (ll)ans * solve(A.size(), B.size(), _a, _b) % MOD;\n\t}\n\tint tot = 0;\n\trep(u, N * 2) if (uf.root(u)) {\n\t\ttot += uf.size(u);\n\t\tans = (ll)ans * C(tot, uf.size(u)) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[201000];\nint n, ss, v[201000], Q[201000], head, tail, Deg[201000], Nxt[201000], Mod = 1000000007, C[201000];\nint F[201000], InvF[201000];\nlong long D[201000];\nvector<int>T, G[201000];\nvoid DFS(int a){\n    T.push_back(a);\n    ss += E[a].size();\n    v[a] = 1;\n    for(int i=0;i<E[a].size();i++)if(!v[E[a][i]])DFS(E[a][i]);\n}\nvoid DP(int a){\n    int i;\n    int r = 1;\n    C[a] = 0;\n    for(i=0;i<G[a].size();i++){\n        DP(G[a][i]);\n        r = 1ll * r * D[G[a][i]] * InvF[C[G[a][i]]] % Mod;\n        C[a] += C[G[a][i]];\n    }\n    D[a] = 1ll * r * F[C[a]]%Mod;\n    C[a]++;\n}\nlong long Get(int st, int a){\n    Nxt[st] = a;\n    int pp = st, i;\n    while(a != st){\n        for(i=0;i<E[a].size();i++){\n            if(Deg[E[a][i]] > 1 && pp != E[a][i])break;\n        }\n        pp = a;\n        Nxt[a] = E[a][i];\n        a = E[a][i];\n    }\n    for(i=0;i<T.size();i++)G[T[i]].clear();\n    G[0].clear();\n    for(i=0;i<T.size();i++){\n        if(T[i] < Nxt[Nxt[T[i]]]) G[Nxt[T[i]]].push_back(T[i]);\n        else G[0].push_back(T[i]);\n    }\n    DP(0);\n    return D[0];\n}\nint Res = 1;\nvoid Calc(){\n    int i;\n    head = tail = 0;\n    for(i=0;i<T.size();i++){\n        if(Deg[T[i]] == 1)Q[++tail] = T[i];\n    }\n    int x;\n    while(head < tail){\n        x = Q[++head];\n        for(i=0;i<E[x].size();i++){\n            if(Deg[E[x][i]] > 1){\n                Nxt[x] = E[x][i];\n                Deg[E[x][i]]--;\n                if(Deg[E[x][i]] == 1)Q[++tail] = E[x][i];\n            }\n        }\n    }\n    for(i=0;i<T.size();i++){\n        if(Deg[T[i]] > 1)break;\n    }\n    x = T[i];\n    int t1 = -1, t2 = -1;\n    for(i=0;i<E[x].size();i++){\n        if(Deg[E[x][i]] > 1){\n            if(t1 == -1)t1 = E[x][i];\n            else t2 = E[x][i];\n        }\n    }\n    int s = 0;\n    s += Get(x, t1);\n    s += Get(x, t2);\n    Res = 1ll * Res * s % Mod * InvF[T.size()] % Mod;\n}\nint Pow(int a, int b){\n    int r = 1;\n    while(b){\n        if(b&1)r=1ll*r*a%Mod;\n        a=1ll*a*a%Mod;b>>=1;\n    }\n    return r;\n}\nint main(){\n    int i, x, y;\n    scanf(\"%d\",&n);\n    F[0] = 1;\n    for(i=1;i<=n+n;i++)F[i] = 1ll*F[i-1]*i%Mod;\n    InvF[n+n] = Pow(F[n+n], Mod-2);\n    for(i=n+n-1;i>=0;i--)InvF[i] = 1ll*InvF[i+1]*(i+1)%Mod;\n    for(i=1;i<=n+n;i++){\n        scanf(\"%d%d\",&x,&y);\n        E[x].push_back(n+y);\n        E[n+y].push_back(x);\n        Deg[x]++,Deg[n+y]++;\n    }\n    for(i=1;i<=n+n;i++){\n        if(!v[i]){\n            ss = 0;\n            T.clear();\n            DFS(i);\n            if(ss != T.size()*2){\n                printf(\"0\\n\");\n                return 0;\n            }\n            Calc();\n        }\n    }\n    Res = 1ll * Res * F[n+n]%Mod;\n    printf(\"%d\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctype.h>\n#include <algorithm>\n#include <queue>\n#define mp make_pair\n#define Debug(...) fprintf(stdout, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<int, LL> pil;\n\nconst int MAXN = 2e5 + 7;\nconst int MOD = 1e9 + 7;\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\nint fac[MAXN], ifac[MAXN], inv[MAXN];\n\ninline int C(int n, int m) {\n\tif(n < m) return 0;\n\treturn (LL) fac[n] * ifac[n - m] % MOD * ifac[m] % MOD;\n}\n\nint n, dn;\nint deg[MAXN];\nint dex, head[MAXN], to[MAXN << 1], nxt[MAXN << 1], w[MAXN << 1];\n\ninline void Link(int x, int y, int val) {\n\t++deg[x];\n\tnxt[++dex] = head[x]; to[dex] = y; w[head[x] = dex] = val;\n}\n\ninline void TopSort() {\n\tqueue<int> Q;\n\twhile(!Q.empty()) Q.pop();\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(deg[i] == 1) Q.push(i);\n\n\n\twhile(!Q.empty()) {\n\t\tint u = Q.front(); Q.pop(); deg[u] = 0;\n//\t\tprintf(\"GG %d \\n\", u);\n\t\tfor(int i = head[u]; i; i = nxt[i]) {\n\t\t\tint v = to[i];\n\t\t\tif(deg[v] > 0) {\n//\t\t\t\tprintf(\"FF %d | %d\\n\", v, deg[v]);\n\t\t\t\t--deg[v];\n\t\t\t\tif(deg[v] == 1) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(deg[i] > 2) {\n\t\t\tputs(\"0\");\n\t\t\texit(0);\n\t\t}\n\t}\n//\tfor(int i = 1; i <= n; ++i) printf(\"FF %d\\n\", deg[i]);\n//\texit(0);\n}\n\nint val[MAXN], edge[MAXN];\nint inc[MAXN], ctt;\nint ins[MAXN], stt;\n\nnamespace Graph {\n\n\tint deg[MAXN], dp[MAXN], siz[MAXN];\n\tint dex, head[MAXN], to[MAXN], nxt[MAXN];\n\n\tinline void Link(int x, int y) {\n\t\t++deg[y];\n\t\tnxt[++dex] = head[x]; to[dex] = y; head[x] = dex;\n\t}\n\n\tvoid dfs(int u) {\n\t\tdp[u] = 1; siz[u] = 0;\n//\t\tprintf(\"GG %d\\n\", u);\n\t\tfor(int i = head[u]; i; i = nxt[i]) {\n\t\t\tint v = to[i];\n\t\t\tdfs(v);\n//\t\t\tif(u == 3) printf(\"KK %d %d %d\\n\", dp[u], dp[v], siz[v]);\n\t\t\tdp[u] = (LL) dp[u] * dp[v] % MOD * ifac[siz[v]] % MOD;\n\t\t\tsiz[u] += siz[v];\n\t\t}\n//\t\tprintf(\"In %d %d\\n\", u, dp[u]);\n\t\tdp[u] = (LL) dp[u] * fac[siz[u]] % MOD;\n//\t\tif(u == 3) printf(\"FFFFF %d\\n\", fac[siz[u]]);\n\t\t++siz[u];\n\t}\n\n\tinline int solve() {\n\t\tint size = 0, res = 1;\n\t\tfor(int i = 1; i <= stt; ++i) {\n\t\t\tint &u = ins[i];\n\t\t\tif(deg[u] == 0) {\n\t\t\t\tdfs(u);\n\t\t\t\tres = (LL) res * C(siz[u] + size, siz[u]) % MOD * dp[u] % MOD;\n\t\t\t\tsize += siz[u];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tinline void clar() {\n\t\tfor(int i = 1; i <= stt; ++i) head[ins[i]] = 0;\n\t\tfor(int i = 1; i <= stt; ++i) deg[ins[i]] = 0;\n\t\tdex = 0;\n\t}\n}\n\nvoid predeal(int u, int f) {\n//\tprintf(\"GG %d\\n\", u);\n\tfor(int i = head[u], v; i; i = nxt[i]) if(deg[v = to[i]] > 0) {\n\t\tif(val[v] || v == f) continue;\n\t\tinc[++ctt] = v; edge[ctt] = w[i];\n\t\tval[v] = w[i];\n\t\tpredeal(v, u);\n\t}\n}\n\nvoid fixup(int u) {\n\tins[++stt] = u;\n\tfor(int i = head[u], v; i; i = nxt[i]) {\n\t\tif(val[v = to[i]]) continue;\n\t\tval[v] = w[i]; fixup(v);\n\t}\n}\n\nvoid maketree(int u, int f) {\n\tfor(int i = head[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tif(v == f || deg[v] > 0) continue;\n\t\tif(val[v] < val[u]) Graph::Link(u, v);\n\t\tmaketree(v, u);\n\t}\n}\n\ninline pii GetCir(int u) {\n\n\tint res = 0; ctt = stt = 0; predeal(u, 0);\n\n//\tcout << ctt << endl;\n\n\tfor(int i = 1; i <= ctt; ++i) fixup(inc[i]);\n//\tfor(int i = 1; i <= ctt; ++i) printf(\"GG %d\\n\", val[inc[i]]);\n\tfor(int i = 1; i <= ctt; ++i) maketree(inc[i], 0);\n\tfor(int i = 1; i < ctt; ++i) {\n\t\tif(edge[i + 1] < edge[i]) {\n\t\t\tGraph::Link(inc[i], inc[i + 1]);\n//\t\t\tprintf(\"%d -> %d\\n\", inc[i], inc[i + 1]);\n\t\t}\n\t}\n\tif(edge[1] < edge[ctt]) Graph::Link(inc[ctt], inc[1]);\n\tres = Graph::solve();\n//\tprintf(\"FF %d \\n\", res);\n\tGraph::clar();\n\n\tfor(int i = 1; i < ctt; ++i) val[inc[i]] = edge[i + 1];\n\tval[inc[ctt]] = edge[1];\n\tfor(int i = 1; i <= ctt; ++i) maketree(inc[i], 0);\n\tfor(int i = 2; i <= ctt; ++i)\n\t\tif(val[inc[i - 1]] < val[inc[i]]) Graph::Link(inc[i], inc[i - 1]);\n\tif(val[inc[ctt]] < val[inc[1]]) Graph::Link(inc[1], inc[ctt]);\n\n\tres += Graph::solve();\n\tGraph::clar();\n\n\tfor(int i = 1; i <= ctt; ++i) deg[inc[i]] = 0;\n\n\treturn mp(res, stt);\n}\n\ninline void init() {\n\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tfor(int i = 1; i < MAXN; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\tfor(int i = 2; i < MAXN; ++i) inv[i] = (LL) (MOD / i) * (MOD - inv[MOD % i]) % MOD;\n\tfor(int i = 1; i < MAXN; ++i) ifac[i] = (LL) ifac[i - 1] * inv[i] % MOD;\n//\tcout << ifac[1] << endl;\n\n\tn = read<int>(); dn = n << 1;\n\tfor(int i = 1; i <= dn; ++i) {\n\t\tint x = read<int>();\n\t\tint y = read<int>();\n\t\tLink(x, y + n, x + y);\n\t\tLink(y + n, x, x + y);\n\t}\n\tn = dn; TopSort();\n}\n\ninline void solve() {\n\tint size = 0, ans = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(deg[i] > 0) {\n\t\t\tpii x = GetCir(i);\n//\t\t\tcout << x.first << endl;\n//\t\t\texit(0);\n\t\t\tint res = x.first;\n\t\t\tint siz = x.second;\n\t\t\tans = (LL) ans * C(size + siz, siz) % MOD * res % MOD;\n\t\t\tsize += siz;\n\t\t}\n\t}\n//\texit(0);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\nconst int mod = 1e9 + 7;\n\ntypedef pair<int, int> ii;\n\nint n, res = 1;\nint prd[N], inv[N];\nint deg[N];\nint f[N], sz[N];\nint nxt[N];\nbool visit[N];\nbool in[N];\nvector<int> G[N], nG[N];\nvector<int> vec;\nvector<ii> edges;\n\nint pw(int x, int y) {\n\tif (!y) return 1; \n\tint ret = pw(x, y >> 1); ret = 1LL * ret * ret % mod;\n\tif (y & 1) ret = 1LL * ret * x % mod; return ret; \n}\n\nint C(int n, int k) {\n\tif (n < k) return 0;\n\treturn 1LL * prd[n] * inv[n - k] % mod * inv[k] % mod;\n}\n\nvoid preDfs(int u) {\n\tvisit[u] = 1, vec.push_back(u);\n\tfor (auto v : G[u]) if (!visit[v]) preDfs(v);\n}\n\nvoid dfs(int u) {\n\tsz[u] = 0;\n\tfor (auto v : nG[u]) {\n\t\tdfs(v), sz[u] += sz[v];\n\t}\n\tint cur = sz[u];\n\tf[u] = 1;\n\tfor (auto v : nG[u]) {\n\t\tf[u] = 1LL * f[u] * f[v] % mod * C(cur, sz[v]) % mod, cur -= sz[v];\n\t}\n\tsz[u]++;\n}\n\nint cal() {\n\t// reset\n\tnG[0].clear();\n\tfor (auto i : vec) nG[i].clear(), deg[i] = 0;\n\tfor (auto i : edges) nxt[i.first] = i.second;\n\t// creates edges\n\tfor (auto i : vec) {\n\t\tfor (auto j : G[i]) {\n\t\t\tif (j == nxt[i]) continue;\n\t\t\tif (j < nxt[i]) nG[i].push_back(j), deg[j]++;\n\t\t\t// j comes first\n\t\t}\n\t}\n\tfor (auto i : vec) {\n\t\t// connects components\n\t\tif (!deg[i]) nG[0].push_back(i);\n\t}\n\t// dfs + dp\n\tdfs(0); return f[0];\n}\n\nint solve(int r) {\n\tvec.clear(), preDfs(r);\n\t// bfs find circle\n\tqueue<int> qu;\n\tfor (auto i : vec) {\n\t\tif (deg[i] == 1) qu.push(i);\n\t}\n\tedges.clear();\n\twhile (qu.size()) {\n\t\tint u = qu.front(); qu.pop();\n\t\tfor (auto v : G[u]) {\n\t\t\tif (deg[v] > 1) {\n\t\t\t\tdeg[v]--, edges.push_back(ii(u, v));\n\t\t\t\tif (deg[v] == 1) qu.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (auto i : vec) {\n\t\tif (deg[i] != 2) continue;\n\t\t// creates circle\n\t\tvector<int> circle;\n\t\tint cur = i;\n\t\twhile (!in[cur]) {\n\t\t\tin[cur] = 1, circle.push_back(cur);\n\t\t\tfor (auto v : G[cur]) {\n\t\t\t\tif (!in[v] && deg[v] == 2) cur = v;\n\t\t\t}\n\t\t}\n\t\t// each circle has 2 ways\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tvector<ii> buffer = edges;\n\t\t\tint sz = circle.size();\n\t\t\tfor (int k = 0; k < sz; ++k) {\n\t\t\t\tedges.push_back(ii(circle[k], circle[(k + 1) % sz]));\n\t\t\t}\n\t\t\tres = (res + cal()) % mod;\n\t\t\tedges = buffer, reverse(circle.begin(), circle.end());\n\t\t}\n\t\treturn res;\n\t}\n}\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\t// for calculating nCk\n\tprd[0] = inv[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tprd[i] = 1LL * i * prd[i - 1] % mod;\n\t\tinv[i] = pw(prd[i], mod - 2);\n\t}\n\t// input\n\tcin >> n; n <<= 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\ty += n >> 1, deg[x]++, deg[y]++;\n\t\tG[x].push_back(y), G[y].push_back(x); \n\t}\n\t// 0 case\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (!G[i].size()) {\n\t\t\tcout << 0; return 0;\n\t\t}\n\t}\n\t// solve each component\n\tint cur = n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (visit[i]) continue;\n\t\tres = 1LL * res * solve(i) % mod * C(cur, vec.size()) % mod;\n\t\tcur -= vec.size();\n\t}\n\t// output\n\tcout << res;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"0\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=5e6+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\n\tconst int N=1e6+10;\n\t//------------------FIXED------------------\n\tvc<int> to[N];\n\tbool vis[N];stack<int> sta;vc<int> cir,pt;\n\tvoid findcir(int x,int fa)\n\t{\n\t\tvis[x]=1;sta.push(x);pt.PB(x);\n\t\tfor(auto y:to[x]) if(y!=fa)\n\t\t{\n\t\t\tif(!vis[y]) findcir(y,x);\n\t\t\telse if(!sz(cir)) { while(sta.top()!=y) cir.PB(sta.top()),sta.pop();cir.PB(y); }\n\t\t}if(!sz(cir)) sta.pop();\n\t}\n\tll ret;int siz[N];\n\tvoid dfs(int x,int fa){\n\t\tvis[x]=1,siz[x]=1;\n\t\tfor(auto y:to[x]) if(y!=fa)\n\t\t{\n\t\t\tif(!vis[y]) dfs(y,x);\n\t\t\tif(y<fa) siz[x]+=siz[y];\n\t\t}ret=ret*Inv[siz[x]]%MOD;\n\t}\n\tint solve(int rt)\n\t{\n\t\twhile(sz(sta)) sta.pop();pt.clear(),cir.clear();findcir(rt,0);if(!sz(cir)) GG();\n\t\tint mx=0;fo(t,1,sz(cir)-1) if(cir[t]>cir[mx]) mx=t;rt=cir[mx];//这样rt一定不需要贡献给其他人\n\t\tfor(auto x:pt) vis[x]=0;ret=1,dfs(rt,cir[(mx+1)%sz(cir)]);int ans=ret;//不可能有二元环\n\t\tfor(auto x:pt) vis[x]=0;ret=1,dfs(rt,cir[(mx+sz(cir)-1)%sz(cir)]);return mm(ans+ret);\n\t}\n\tvoid main()\n\t{\n\t\tPRE();\n\t\tint n=qread();fo(i,1,n+n){ int x=qread(),y=n+qread();to[x].PB(y),to[y].PB(x); }\n\t\tll ans=1;fo(i,1,n+n) if(!vis[i]) ans=ans*solve(i)%MOD;write(ans*fac[n+n]%MOD);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::main();\n\tdebug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\na#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int maxn=2e5+10;\nconst int mo=1e9+7;\n\nint n,root,Ans=1,tote=1;\nint fa[maxn],fw[maxn],tmp[maxn],fac[maxn],ifac[maxn];\nint FIR[maxn],TO[maxn<<1],NEXT[maxn<<1],W[maxn<<1];\nint vis[maxn];\nint q[maxn];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nvoid addedge(int u,int v,int w)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tW[tote]=w;\n\tFIR[u]=tote;\n}\n\nvoid dfs1(int u,int F)\n{\n\tif (vis[u]==1) {root=u; return;}\n\tvis[u]=1;\n\tq[++q[0]]=u;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (v==F) continue;\n\t\tdfs1(v,u);\n\t}\n}\n\nvoid dfs2(int u)\n{\n\tif (vis[u]==2) return;\n\tvis[u]=2;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (v==fa[u]) continue;\n\t\tfa[v]=u;\n\t\tfw[v]=w;\n\t\tdfs2(v);\n\t}\n}\n\nnamespace Tree{\n\tint n,fa[maxn],dp[maxn],sz[maxn];\n\tint tote,FIR[maxn],TO[maxn<<1],NEXT[maxn<<1];\n\n\tvoid addedge(int u,int v)\n\t{\n//\t\tprintf(\"%d----->%d\\n\",u,v);\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t\tfa[v]=u;\n\t}\n\n\tbool dfs(int u)\n\t{\n//\t\tprintf(\"u=%d\\n\",u);\n\t\tif (dp[u]) return 0;\n\t\tsz[u]=0;\n\t\tdp[u]=1;\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!dfs(v)) return 0;\n\t\t\tsz[u]+=sz[v];\n\t\t\tdp[u]=(LL)dp[u]*dp[v]%mo;\n\t\t\tdp[u]=(LL)dp[u]*ifac[sz[v]]%mo;\n\t\t}\n\t\tdp[u]=(LL)dp[u]*fac[sz[u]]%mo;\n\t\tsz[u]++;\n\t\treturn 1;\n\t}\n\n\tvoid solve(int &Ans)\n\t{\n\t\tint i,u;\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n\t\t\tif (!fa[u]) addedge(0,u);\n\t\t}\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n//\t\t\tprintf(\"%d : %d\\n\",u,fw[u]);\n\t\t}\n\n\t\tif (!dfs(0)) {Ans=0; return;}\n\t\t(Ans+=dp[0])%=mo;\n\n//\t\tprintf(\"Ans=%d\\nclear\\n\\n\\n\",Ans);\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t\tu=q[i],FIR[u]=fa[u]=dp[u]=sz[u]=0;\n\t\tFIR[0]=fa[0]=dp[0]=sz[0]=0;\n\t\ttote=0;\n\t}\n};\n\nvoid dfs3(int u)\n{\n\tif (vis[u]==3) return;\n\tvis[u]=3;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs3(v);\n\t}\n}\n\nvoid dfs4(int u)\n{\n\tif (vis[u]==4) return;\n\tvis[u]=4;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs4(v);\n\t}\n}\n\nint main()\n{\n\tint i,u,v;\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor (i=1;i<=n+n;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[n+n]=power(fac[n+n],mo-2);\n\tfor (i=n+n;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tfor (i=1;i<=n+n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,n+v,u+v);\n\t\taddedge(n+v,u,u+v);\n\t}\n\n\tfor (i=1;i<=n+n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tq[0]=0;\n\t\t\troot=0;\n\t\t\tdfs1(i,0);\n\t\t\tif (!root) {puts(\"0\"); return 0;}\n\t\t\tdfs2(root);\n\n\t\t\tint Sum=0;\n\n\t\t\tdfs3(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\ttmp[fa[u]]=fw[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\tfw[u]=tmp[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\n\t\t\tdfs4(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tAns=(LL)Ans*Sum%mo;\n//\t\t\tprintf(\"q0=%d\\n\",q[0]);\n\t\t\tAns=(LL)Ans*ifac[q[0]]%mo;\n\t\t}\n\tAns=(LL)Ans*fac[n+n]%mo;\n\tprintf(\"%d\\n\",Ans);\n}\n\nconst int maxn=2e5+10;\nconst int mo=1e9+7;\n\nint n,root,Ans=1,tote=1;\nint fa[maxn],fw[maxn],tmp[maxn],fac[maxn],ifac[maxn];\nint FIR[maxn],TO[maxn<<1],NEXT[maxn<<1],W[maxn<<1];\nint vis[maxn];\nint q[maxn];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nvoid addedge(int u,int v,int w)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tW[tote]=w;\n\tFIR[u]=tote;\n}\n\nvoid dfs1(int u,int F)\n{\n\tif (vis[u]) {root=u; return;}\n\tq[++q[0]]=u;\n\tvis[u]=1;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (v==F) continue;\n\t\tdfs1(v,u);\n\t}\n}\n\nvoid dfs2(int u)\n{\n\tif (vis[u]==2) return;\n\tvis[u]=2;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (v==fa[u]) continue;\n\t\tfa[v]=u;\n\t\tfw[v]=w;\n\t\tdfs2(v);\n\t}\n}\n\nnamespace Tree{\n\tint n,fa[maxn],dp[maxn],sz[maxn];\n\tint tote,FIR[maxn],TO[maxn<<1],NEXT[maxn<<1];\n\n\tvoid addedge(int u,int v)\n\t{\n//\t\tprintf(\"%d----->%d\\n\",u,v);\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t\tfa[v]=u;\n\t}\n\n\tvoid dfs(int u)\n\t{\n//\t\tprintf(\"u=%d\\n\",u);\n\t\tsz[u]=0;\n\t\tdp[u]=1;\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tdfs(v);\n\t\t\tsz[u]+=sz[v];\n\t\t\tdp[u]=(LL)dp[u]*dp[v]%mo;\n\t\t\tdp[u]=(LL)dp[u]*ifac[sz[v]]%mo;\n\t\t}\n\t\tdp[u]=(LL)dp[u]*fac[sz[u]]%mo;\n\t\tsz[u]++;\n\t}\n\n\tvoid solve(int &Ans)\n\t{\n\t\tint i,u;\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n\t\t\tif (!fa[u]) addedge(0,u);\n\t\t}\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t{\n\t\t\tu=q[i];\n//\t\t\tprintf(\"%d : %d\\n\",u,fw[u]);\n\t\t}\n\n\t\tdfs(0);\n\t\t(Ans+=dp[0])%=mo;\n\n//\t\tprintf(\"Ans=%d\\nclear\\n\\n\\n\",Ans);\n\n\t\tfor (i=1;i<=q[0];i++)\n\t\t\tu=q[i],FIR[u]=fa[u]=dp[u]=sz[u]=0;\n\t\tFIR[0]=fa[0]=dp[0]=sz[0]=0;\n\t\ttote=0;\n\t}\n};\n\nvoid dfs3(int u)\n{\n\tif (vis[u]==3) return;\n\tvis[u]=3;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs3(v);\n\t}\n}\n\nvoid dfs4(int u)\n{\n\tif (vis[u]==4) return;\n\tvis[u]=4;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p],w=W[p];\n\t\tif (w<fw[u]) Tree::addedge(u,v);\n\t\tdfs4(v);\n\t}\n}\n\nint main()\n{\n\tint i,u,v;\n\tscanf(\"%d\",&n);\n\tfac[0]=1;\n\tfor (i=1;i<=n+n;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[n+n]=power(fac[n+n],mo-2);\n\tfor (i=n+n;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tfor (i=1;i<=n+n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,n+v,u+v);\n\t\taddedge(n+v,u,u+v);\n\t}\n\n\tfor (i=1;i<=n+n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tq[0]=0;\n\t\t\troot=0;\n\t\t\tdfs1(i,0);\n\t\t\tif (!root) {puts(\"0\"); return 0;}\n\t\t\tdfs2(root);\n\n\t\t\tint Sum=0;\n\n\t\t\tdfs3(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\ttmp[fa[u]]=fw[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\t\t\tfor (u=root;;u=fa[u])\n\t\t\t{\n\t\t\t\tfw[u]=tmp[u];\n\t\t\t\tif (fa[u]==root) break;\n\t\t\t}\n\n\t\t\tdfs4(root);\n\t\t\tTree::solve(Sum);\n\n\t\t\tAns=(LL)Ans*Sum%mo;\n//\t\t\tprintf(\"q0=%d\\n\",q[0]);\n\t\t\tAns=(LL)Ans*ifac[q[0]]%mo;\n\t\t}\n\tAns=(LL)Ans*fac[n+n]%mo;\n\tprintf(\"%d\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n;\n\nint H(int x,int y){return x*n+y;}\n\nstruct side{\n  int y,next;\n}e[N*8+9];\nint lin[2][N*2+9],cs;\n\nvoid Ins(int id,int x,int y){e[++cs].y=y;e[cs].next=lin[id][x];lin[id][x]=cs;}\nvoid Ins2(int id,int x,int y){Ins(id,x,y);Ins(id,y,x);}\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n<<1;++i){\n\tint x,y;\n\tscanf(\"%d%d\",&x,&y);\n\tIns2(0,H(0,x),H(1,y));\n  }\n}\n\nint inv[N*2+9],fac[N*2+9],ifac[N*2+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n<<1;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint a[N*2+9],vis[N*2+9],ca;\nint st,td,ce;\n\nvoid Dfs_a(int k,int fa){\n  vis[a[++ca]=k]=1;\n  for (int i=lin[0][k];i;i=e[i].next){\n\t++ce;\n\tif (!vis[e[i].y]) Dfs_a(e[i].y,k);\n    else if (e[i].y^fa) st=k,td=e[i].y;\n  }\n}\n\nint pre[N*2+9];\n\nvoid Dfs_pre(int k,int fa){\n  for (int i=lin[0][k];i;i=e[i].next)\n\tif (e[i].y^fa&&e[i].y^st){\n\t  pre[e[i].y]=k;\n\t  Dfs_pre(e[i].y,k);\n\t}\n}\n\nint siz[N*2+9];\n\nvoid Dfs_siz(int k,int fa){\n  siz[k]=1;\n  for (int i=lin[1][k];i;i=e[i].next)\n\tif (e[i].y^fa){\n\t  Dfs_siz(e[i].y,k);\n\t  siz[k]+=siz[e[i].y];\n\t}\n}\n\nint deg[N*2+9];\n\nint Get_ans0(){\n  int res=fac[ca];\n  Dfs_pre(st,td);\n  pre[st]=td;\n  for (int i=1;i<=ca;++i) lin[1][a[i]]=0,deg[a[i]]=0;\n  for (int i=1;i<=ca;++i){\n\tint t=a[i];\n\tfor (int j=lin[0][t];j;j=e[j].next)\n\t  if (e[j].y<pre[t]) Ins(1,t,e[j].y),++deg[e[j].y];\n  }\n  for (int i=1;i<=ca;++i)\n\tif (!deg[a[i]]) Dfs_siz(a[i],0);\n  for (int i=1;i<=ca;++i) smul(res,inv[siz[a[i]]]);\n  return res;\n}\n\nint ans;\n\nvoid Get_ans(){\n  ans=fac[n<<1];\n  for (int i=1;i<=n<<1;++i)\n\tif (!vis[i]){\n\t  ca=ce=0;\n\t  Dfs_a(i,0);\n\t  if (ca<<1^ce) {ans=0;return;}\n\t  smul(ans,ifac[ca]);\n\t  int now=Get_ans0();\n\t  swap(st,td);\n\t  smul(ans,add(now,Get_ans0()));\n\t}\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=200010,O=1000000007;\ninline int fpow(int x,int n){\n\tint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\nint nlst[N],ns,ecnt;\nint fac[N],invfac[N];\ninline void gmath(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=(lint)fac[i-1]*i%O;\n\t}\n\tinvfac[n]=inv(fac[n]);\n\tfor(int i=n;i>=1;i--){\n\t\tinvfac[i-1]=(lint)invfac[i]*i%O;\n\t}\n}\nnamespace G{\n\tconst int E=N;\n\tint to[E],bro[E],head[N],e=0;\n\tint size[N],ringe;\n\tint edg[N];\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tvoid getring(int x){\n\t\tnlst[++ns]=x;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tecnt++;\n\t\t\tif((v=to[i])!=edg[x]){\n\t\t\t\tif(edg[v]){\n\t\t\t\t\tif(ringe==-1){\n\t\t\t\t\t\tringe=i;\n\t\t\t\t\t}else if(to[ringe]!=x){\n\t\t\t\t\t\tringe=-2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tedg[v]=x;\n\t\t\t\t\tgetring(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int x){\n\t\tsize[x]=1;\n\t\tlint ans=1;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tans=ans*dfs(v)%O;\n\t\t\t\tans=ans*invfac[size[v]]%O;\n\t\t\t\tsize[x]+=size[v];\n\t\t\t}\n\t\t}\n\t\treturn ans*fac[size[x]-1]%O;\n\t}\n}\nint deg[N];\ninline int work2(){\n\tusing namespace G;\n\tfor(int i=1;i<=ns;i++){\n\t\tint x=nlst[i];\n\t\tdeg[x]=0;\n\t}\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])<edg[x]){\n\t\t\t\tdeg[v]++;\n\t\t\t}\n\t\t}\n\t}\n\tlint ans=fac[ns];\n\tfor(int t=1;t<=ns;t++){\n\t\tint x=nlst[t];\n\t\tif(deg[x]==0){\n\t\t\tans=ans*dfs(x)%O;\n\t\t\tans=ans*invfac[size[x]]%O;\n\t\t}\n\t}\n\treturn ans;\n}\ninline int work(int x){//kind*invfac[n]\n\tusing namespace G;\n\tns=0,ecnt=0;\n\tringe=-1;\n\tedg[x]=-1;\n\tgetring(x);\n\tif(ringe<0)return 0;\n\tfor(int p=to[ringe],q=to[ringe^1];~p;swap(edg[p],q),swap(p,q));\n\tint ans=work2();\n\tfor(int p=to[ringe^1],q=to[ringe],tp=p;swap(edg[p],q),swap(p,q),p!=tp;);\n\treturn (lint)invfac[ns]*(ans+work2())%O;\n}\ninline int Main(){\n\tint n=ni,n2=n<<1;\n\tG::init();\n\tfor(int i=1;i<=n2;i++){\n\t\tG::add(ni,n+ni);\n\t}\n\tgmath(n<<1);\n\tlint ans=fac[n<<1];\n\tmemset(G::edg,0,sizeof(G::edg));\n\tmemset(G::size,0,sizeof(G::size));\n\tfor(int i=1;i<=n2;i++){\n\t\tif(G::edg[i]==0){\n\t\t\t(ans*=work(i))%=O;\n\t\t\tif(ans==0)return 0;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tprintf(\"%d\\n\",Main());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define M 400005\n#define mod 1000000007\n#define PB push_back\n#define MP std::make_pair\n#define FI first\n#define SE second\ntypedef long long ll;\nint n, X[M], Y[M], deg[M], bel[M], fa[M], size[M], V, E;\nstd::vector <int> Edge[M], vec, cir, tmp, Tree[M];\nstd::map <std::pair <int, int>, int> Map;\nstd::vector <std::pair <int, int> > row[M], col[M];\nbool vis[M];\nll fac[M], fac_inv[M], inv[M];\nint read() {\n\tchar c = getchar(); int ans = 0;\n\twhile (c < '0' || c > '9') c = getchar();\n\twhile (c >= '0' && c <= '9') ans = ans * 10 + c - '0', c = getchar();\n\treturn ans;\n}\nvoid Write(int x) {\n\tif (x < 10) putchar(x + '0');\n\telse Write(x / 10), putchar(x % 10 + '0');\n}\nll invs(ll x) {return x == 1 ? 1 : (mod - mod / x) * invs(mod % x) % mod;}\nvoid dfs1(int x) {\n\tvec.PB(x), vis[x] = 1, V++;\n\tfor (auto i : Edge[x]) {\n\t\tif (i != fa[x]) E++;\n\t\tif (!vis[i]) fa[i] = x, dfs1(i);\n\t}\n}\nvoid dfs2(int x) {\n\tfor (auto i : Edge[x]) {\n\t\tif (i == fa[x]) continue;\n\t\tif (fa[i] == x) dfs2(i);\n\t\telse if (cir.empty()) {\n\t\t\tfor (int j = x; j != i; j = fa[j]) cir.PB(j);\n\t\t\tcir.PB(i);\n\t\t}\n\t}\n}\nll dfs3(int x) {\n\tsize[x] = 1; ll ans = 1;\n\tfor (auto i : Tree[x]) ans = ans * dfs3(i) % mod, size[x] += size[i];\n\treturn ans * inv[size[x]] % mod;\n}\nll calc() {\n\tfor (auto i : tmp) Tree[i].clear(), deg[i] = 0; ll ans = 1;\n\tfor (auto i : tmp) {\n\t\tif (bel[i] <= n) {\n\t\t\tfor (auto j : row[bel[i]])\n\t\t\t\tif (j.SE == i) break;\n\t\t\t\telse Tree[i].PB(j.SE), deg[j.SE]++;\n\t\t}\n\t\telse {\n\t\t\tfor (auto j : col[bel[i] - n])\n\t\t\t\tif (j.SE == i) break;\n\t\t\t\telse Tree[i].PB(j.SE), deg[j.SE]++;\n\t\t}\n\t}\n\tfor (auto i : tmp)\n\t\tif (!deg[i]) ans = ans * dfs3(i) % mod;\n\treturn ans;\n}\nll calc(int rt) {\n\tvec.clear(), cir.clear(), tmp.clear(), V = E = 0, dfs1(rt);\n\tif (V != --E) return 0; dfs2(rt); std::queue <int> Q;\n\tfor (auto i : vec) deg[i] = 0;\n\tfor (auto i : vec)\n\t\tfor (auto j : Edge[i]) deg[j]++;\n\tfor (auto i : vec)\n\t\tif (deg[i] == 1) Q.push(i), deg[i] = 0;\n\twhile (!Q.empty()) {\n\t\tint now = Q.front(); Q.pop();\n\t\tfor (auto i : Edge[now])\n\t\t\tif (deg[i]) {\n\t\t\t\tdeg[i]--, bel[Map[MP(now, i)]] = now, tmp.PB(Map[MP(now, i)]);\n\t\t\t\tif (deg[i] == 1) deg[i] = 0, Q.push(i);\n\t\t\t}\n\t}\n\tll ans = 0;\n\tfor (int _ = 0; _ < 2; tmp.resize(tmp.size() - cir.size()), std::reverse(cir.begin(), cir.end()), _++) {\n\t\tfor (int j = 0; j < cir.size() - 1; j++) bel[Map[MP(cir[j], cir[j + 1])]] = cir[j], tmp.PB(Map[MP(cir[j], cir[j + 1])]);\n\t\tbel[Map[MP(cir.back(), cir[0])]] = cir.back(), tmp.PB(Map[MP(cir.back(), cir[0])]), ans += calc();\n\t}\n\treturn ans % mod;\n}\nint main() {\n\tn = read(); ll ans = 1; fac[0] = 1;\n\tfor (int i = 1; i <= n * 2; i++) fac[i] = fac[i - 1] * i % mod; fac_inv[n * 2] = invs(fac[n * 2]);\n\tfor (int i = n * 2; i; i--) fac_inv[i - 1] = fac_inv[i] * i % mod;\n\tfor (int i = 1; i <= n * 2; i++) inv[i] = fac_inv[i] * fac[i - 1] % mod;\n\tfor (int i = 1; i <= n * 2; i++)\n\t\tX[i] = read(), Y[i] = read(), row[X[i]].PB(MP(Y[i], i)), col[Y[i]].PB(MP(X[i], i)),\n\t\tEdge[X[i]].PB(Y[i] + n), Edge[Y[i] + n].PB(X[i]),\n\t\tMap[MP(X[i], Y[i] + n)] = Map[MP(Y[i] + n, X[i])] = i;\n\tfor (int i = 1; i <= n; i++) std::sort(row[i].begin(), row[i].end()), std::sort(col[i].begin(), col[i].end());\n\tfor (int i = 1; i <= n * 2; i++)\n\t\tif (!vis[i]) ans = ans * calc(i) % mod;\n\treturn Write(ans * fac[n * 2] % mod), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define mod 1000000007\n#define next nxt\n\nint n,x[N],y[N],z[N],next[N],p[N],h[N],q[N],f[N],g[N],s[N],cnt,cmt,cir;\nlong long fac[N],inv[N],ans;\nvector<int> v[N];\n\nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nvoid travel(int x,int pre){\n\th[x]=true;q[++cnt]=x;\n\tfor (int t=p[x];t;cmt++,t=next[t])\n\t\tif (!h[y[t]]) travel(y[t],t);\n\t\telse if (t/2!=pre/2) cir=t;\n}\n\nvoid build(int x){\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (y[t]!=g[x]){\n\t\t\tif (y[t]<g[x]) v[x].push_back(y[t]),f[y[t]]=true;\n\t\t\tif (t/2!=cir/2) g[y[t]]=x,build(y[t]);\n\t\t}\n}\n\nlong long solve(int x){\n\ts[x]=0;long long ans=1;\n\tfor (int i=0;i<(int)v[x].size();i++){\n\t\tans=ans*solve(v[x][i])%mod;\n\t\ts[x]+=s[v[x][i]];\n\t\tans=ans*C(s[x],s[v[x][i]])%mod;\n\t}\n\ts[x]++;return ans;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=2*n;i++){\n\t\tx[2*i]=y[2*i+1]=read();\n\t\ty[2*i]=x[2*i+1]=n+read();\n\t\tz[2*i]=z[2*i+1]=x[2*i]+y[2*i];\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t\tnext[2*i+1]=p[x[2*i+1]];p[x[2*i+1]]=2*i+1;\n\t}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tans=fac[2*n];\n\tfor (int i=1;i<=2*n;i++)\n\t\tif (!h[i]){\n\t\t\tcnt=cmt=0;travel(i,0);\n\t\t\tif (cmt!=cnt*2) {printf(\"0\\n\");return 0;}\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),g[q[i]]=0,f[q[i]]=false;\n\t\t\tg[x[cir]]=y[cir];build(x[cir]);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!f[q[i]]) v[0].push_back(q[i]);\n\t\t\tlong long tmp=solve(0);\n\t\t\t\n\t\t\tv[0].clear();\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tv[q[i]].clear(),g[q[i]]=0,f[q[i]]=false;\n\t\t\tg[y[cir]]=x[cir];build(y[cir]);\n\t\t\tfor (int i=1;i<=cnt;i++)\n\t\t\t\tif (!f[q[i]]) v[0].push_back(q[i]);\n\t\t\ttmp+=solve(0);\n\t\t\t\n\t\t\tans=ans*tmp%mod*inv[cnt]%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nconst int N = 5 * 100000 + 100;\nconst int MOD = 1000000007;\nconst int oo = 1e9;\n\nint n , x , y, take[N], in[N], sz[N];\nbool inStack[N], vis[N];\nll fact[N], inv[N];\n\nvector<int> g[N], tree[N], cycle, my;\nstack<int> st;\n\nvoid findCycle(int u , int p) {\n\tif (inStack[u]) {\n\t\twhile (1) {\n\t\t\tcycle.pb(st.top());\n\t\t\tst.pop();\n\t\t\tif (cycle.back() == u)break;\n\t\t}\n\t\tfor (int i = 0; i < cycle.size(); ++i) st.push(cycle[i]);\n\t\treturn;\n\t}\n\tif (vis[u])return;\n\tmy.pb(u);\n\ttake[u] = p;\n\tvis[u] = 1;\n\tinStack[u] = 1;\n\tst.push(u);\n\tfor (int i = 0; i < g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v == p)continue;\n\t\tfindCycle(v, u);\n\t}\n\tinStack[u] = 0;\n\tst.pop();\n}\nbool getType(int idx) {\n\treturn idx > n;\n}\nll fast(ll a , ll b) {\n\tif (!b)return 1ll;\n\tll res = fast(a, b / 2);\n\tres = (res * res) % MOD;\n\tif (b & 1)\n\t\treturn (res * a) % MOD;\n\treturn res;\n}\nll nCk(ll n , ll k) {\n\treturn ((fact[n] * inv[n - k]) % MOD * inv[k]) % MOD;\n}\nll calc(int u) {\n\tsz[u] = 0;\n\tll ans = 1;\n\tfor (int i = 0; i < tree[u].size(); ++i) {\n\t\tint v = tree[u][i];\n\t\tll ff = calc(v);\n\t\tans = (((ans * ff ) % MOD * nCk(sz[u] + sz[v], sz[v]))) % MOD;\n\t\tsz[u] += sz[v];\n\t}\n\tsz[u]++;\n\treturn ans;\n}\nint dsu[N], ed[N], fn[N];\n\nint find(int u) {\n\treturn dsu[u] == u ? u : dsu[u] = find(dsu[u]);\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1 ; i <= 2 * n; ++i) {\n\t\tdsu[i] = i;\n\t\tfn[i] = 1;\n\t}\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tg[x + n].pb(y);\n\t\tg[y].pb(x + n);\n\t\tif (find(x + n) != find(y)) {\n\t\t\tfn[find(y)] += fn[find(x + n)];\n\t\t\ted[find(y)] += ed[find(x + n)];\n\t\t\tdsu[find(x + n)] = find(y);\n\t\t}\n\t\ted[find(x + n)]++;\n\t}\n\tfor (int i = 1; i <= 2 * n; ++i) {\n\t\tif (find(i) == i && fn[i] !=  ed[i]) {\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfact[0] = 1;\n\tinv[0] = fast(fact[0], MOD - 2);\n\tfor (int i = 1 ; i <= 2 * n ; ++i) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv[i] = fast(fact[i], MOD - 2);\n\t}\n\tll ans = 1;\n\tint len = 0;\n\tfor (int node = 1 ; node <= 2 * n ; ++node) {\n\t\tif (vis[node])continue;\n\t\tcycle.clear();\n\t\tmy.clear();\n\t\tfindCycle(node, -1);\n\t\tif (cycle.size()) {\n\t\t\tfor (int i = 0; i < my.size(); ++i) {\n\t\t\t\tinStack[my[i]] = vis[my[i]] = 0;\n\t\t\t}\n\t\t\tint root = cycle[0];\n\t\t\tcycle.clear();\n\t\t\tmy.clear();\n\t\t\tfindCycle(root, -1);\n\t\t}\n\t\tll res = 0;\n\t\tfor (int it = 0; it < 2 ; ++it) {\n\t\t\tfor (int i = 0 ; i < my.size(); ++i) {\n\t\t\t\tin[my[i]] = 0;\n\t\t\t\ttree[my[i]].clear();\n\t\t\t}\n\t\t\ttree[0].clear();\n\t\t\tfor (int j = 0 ; j < cycle.size(); ++j) {\n\t\t\t\ttake[cycle[j]] = (it == 0 ? cycle[(j + 1) % cycle.size()] :  cycle[(j - 1 + cycle.size()) % cycle.size()]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size() ; ++i) {\n\t\t\t\tint f = my[i];\n\t\t\t\tfor (int j = 0 ; j < g[f].size(); ++j) {\n\t\t\t\t\tint v = g[f][j];\n\t\t\t\t\tif (getType(take[f]) == getType(v) && v < take[f]) {\n\t\t\t\t\t\ttree[f].pb(v);\n\t\t\t\t\t\tin[v]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < my.size(); ++i) {\n\t\t\t\tif (!in[my[i]]) {\n\t\t\t\t\ttree[0].push_back(my[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = (res + calc(0)) % MOD;\n\t\t}\n\n\t\tans = (ans * res ) % MOD;\n\t\tans = (ans * nCk(len + my.size(), my.size())) % MOD;\n\t\tlen += my.size();\n\t}\n\tprintf(\"%lld\\n\", ans );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lowbit(o) o&(-o)\n#define P 1000000007\n#define N 200005\n#define M 400005\n#define pb push_back\nusing namespace std;\nint i,j,k,l,s,r,n,m,jc[N],ny[N],fa[N],A[2][N],B[2][N],tot,T,vis[2][N],id[N],Si[2][N];\nint ans,Ans,si,G[N];\nvector<int>GT[2][N],V[2][N];\nvector<int>::iterator GTW;\nstruct orz {\n\tint x,y;\n}a[N],q[N],Q[N];\nstruct node {\n\tint tot,last[N],to[M],next[M];\n\tinline void add(int x,int y) {\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A1;\nstruct Node {\n\tint tot,chu[N],ru[N],l,r,last[N],next[M],to[M],f[N],si[N];\n\torz q[N];\n\tinline void add(int x,int y) {\n\t\tchu[x]++; ru[y]++;\n\t\tnext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n\t}\n}A2;\ninline bool cmp(int x,int y) {\n\treturn G[x]<G[y];\n}\ninline int findl(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=0;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]<x) s=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn s+1;\n}\ninline int findr(int x) {\n\tx=G[x];\n\tint l=1,r=2*n,s=2*n+1;\n\twhile (l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tif (G[id[mid]]>x) s=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn s-1;\n}\ninline int quick(int x,int y) {\n\tint s=1;\n\twhile (y) {\n\t\tif (y&1) s=1ll*s*x%P;\n\t\tx=1ll*x*x%P;\n\t\ty>>=1;\n\t}\n\treturn s;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\ninline int C(int x,int y) {\n\treturn 1ll*jc[x]*ny[y]%P*ny[x-y]%P;\n}\ninline int getans(int r) {\n\tT=s=0;\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].pb(q[i].y);\n\tint L=findl(get(q[1].x*n+q[1].y)),R=findr(get(q[1].x*n+q[1].y));\n\tfor (int i=L;i<=R;i++) {\n\t\ts++;\n\t\tQ[++T].x=(id[i]-1)/n,Q[T].y=(id[i]-1)%n+1;\n\t\tif (A[Q[T].x][Q[T].y]) {\n \t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>A[Q[T].x][Q[T].y]) continue;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (GTW=V[Q[T].x][Q[T].y].begin();GTW!=V[Q[T].x][Q[T].y].end();GTW++) {\n\t\t\t\tif ((*GTW)>B[Q[T].x][Q[T].y]) continue;\n\t\t\t\tA2.add((Q[T].x^1)*n+(*GTW),Q[T].x*n+Q[T].y);\n\t\t\t}\n\t\t}\n\t}\n\tA2.l=A2.r=0;\n\tA2.f[A2.si[0]=0]=1;\n\tfor (int i=1;i<=T;i++) A2.f[Q[i].x*n+Q[i].y]=1;\n\tfor (int i=1;i<=T;i++) if (!A2.chu[Q[i].x*n+Q[i].y]) A2.add(Q[i].x*n+Q[i].y,0);\n\tfor (int i=1;i<=T;i++) if (!A2.ru[Q[i].x*n+Q[i].y]) A2.q[++A2.r].x=Q[i].x,A2.q[A2.r].y=Q[i].y;\n\twhile (A2.l<A2.r) {\n\t\tA2.l++;\n\t\tA2.si[A2.q[A2.l].x*n+A2.q[A2.l].y]++;\n\t\tfor (int i=A2.last[A2.q[A2.l].x*n+A2.q[A2.l].y];i;i=A2.next[i]) {\n\t\t\tA2.ru[A2.to[i]]--;\n\t\t\tA2.si[A2.to[i]]+=A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y];\n\t\t\t(A2.f[A2.to[i]]=1ll*A2.f[A2.to[i]]*A2.f[A2.q[A2.l].x*n+A2.q[A2.l].y]%P*C(A2.si[A2.to[i]],A2.si[A2.q[A2.l].x*n+A2.q[A2.l].y])%P);\n\t\t\tif (!A2.ru[A2.to[i]]) A2.q[++A2.r].x=(A2.to[i]-1)/n,A2.q[A2.r].y=(A2.to[i]-1)%n+1;\n\t\t}\n\t}\n\tfor (int i=1;i<=r;i++) V[q[i].x^1][B[q[i].x][q[i].y]].pop_back();\n\tA2.tot=0;\n\tfor (int i=1;i<=A2.r;i++) A2.last[A2.q[i].x*n+A2.q[i].y]=0,A2.chu[A2.q[i].x*n+A2.q[i].y]=A2.ru[A2.q[i].x*n+A2.q[i].y]=0;\n\tfor (int i=1;i<=T;i++) A2.f[A2.q[i].x*n+A2.q[i].y]=A2.si[A2.q[i].x*n+A2.q[i].y]=0;\n\treturn A2.f[0];\n}\ninline void work(int x,int y) {\n\tvis[x][y]=1;\n\tint l=0,r=1; q[1].x=x,q[1].y=y;\n\twhile (l<r) {\n\t\t++l;\n\t\tfor (GTW=GT[q[l].x][q[l].y].begin();GTW!=GT[q[l].x][q[l].y].end();GTW++) if (!vis[q[l].x^1][(*GTW)]) q[++r].x=q[l].x^1,q[r].y=(*GTW),vis[q[r].x][q[r].y]=1;\n\t}\n\tfor (int i=1;i<=r;i++) \n\tfor (GTW=GT[q[i].x][q[i].y].begin();GTW!=GT[q[i].x][q[i].y].end();GTW++) A1.add(q[i].x*n+q[i].y,(*GTW));\n\tint xx=x,yy=y;\n\tB[xx][yy]=A1.to[A1.last[xx*n+yy]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) \n\t\tif (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tAns=getans(r);\n\t\n\tfor (int i=1;i<=r;i++) B[q[i].x][q[i].y]=0;\n\tB[xx][yy]=A1.to[A1.next[A1.last[xx*n+yy]]];\n\tyy=B[xx][yy],xx^=1;\n\twhile (xx!=x||yy!=y) {\n\t\tfor (int i=A1.last[xx*n+yy];i;i=A1.next[i]) if (B[xx^1][A1.to[i]]!=yy) {\n\t\t\tB[xx][yy]=A1.to[i],yy=B[xx][yy],xx^=1; break;\n\t\t}\n\t}\n\tA1.tot=0;\n\tfor (int i=1;i<=r;i++) A1.last[q[i].x*n+q[i].y]=0;\n\t(Ans+=getans(r))%=P;\n\tsi+=s;\n\t(ans=1ll*ans*Ans%P*C(si,s)%P);\n}\ninline void doit() {\n\tjc[0]=1;\n\tfor (int i=1;i<=200000;i++) jc[i]=1ll*jc[i-1]*i%P;\n\tny[200000]=quick(jc[200000],P-2);\n\tfor (int i=199999;i;i--) ny[i]=1ll*ny[i+1]*(i+1)%P;\n\tny[0]=1;\n}\nvoid R(int &x) {\n\tx=0;char ch=getchar();\n\twhile (ch<'0' || '9'<ch) ch=getchar();\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n}\nint main() {\n\tdoit();\n\tans=1; si=0;\n\tR(n);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) fa[i*n+j]=i*n+j;\n\tfor (i=1;i<=2*n;i++) {\n\t\tR(a[i].x),R(a[i].y);\n\t\tif (get(a[i].x)!=get(n+a[i].y)) fa[get(a[i].x)]=get(n+a[i].y);\n\t\tGT[0][a[i].x].pb(a[i].y);\n\t\tSi[0][a[i].x]++;\n\t\tSi[1][a[i].y]++;\n\t\tGT[1][a[i].y].pb(a[i].x);\n\t}\n\tfor (i=1;i<=2*n;i++) if (get(id[i]=i)==i) G[i]=++tot;\n\tfor (i=1;i<=2*n;i++) G[i]=G[get(i)];\n\ttot=0;\n\tsort(id+1,id+1+2*n,cmp);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!Si[i][j]) return puts(\"0\"),0;\n\telse if (Si[i][j]==1) q[++r].x=i,q[r].y=j;\n\twhile (l<r) {\n\t\t++l;\n\t\tif (!Si[q[l].x][q[l].y]) return puts(\"0\"),0;\n\t\tfor (GTW=GT[q[l].x][q[l].y].begin();GTW!=GT[q[l].x][q[l].y].end();GTW++) if (A[q[l].x^1][*GTW]!=q[l].y)\n\t\tA[q[l].x][q[l].y]=(*GTW);\n\t\tSi[q[l].x^1][A[q[l].x][q[l].y]]--;\n\t\tif (Si[q[l].x^1][A[q[l].x][q[l].y]]==1) q[++r].x=q[l].x^1,q[r].y=A[q[l].x][q[l].y];\n\t}\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) GT[i][j].clear();\n\tfor (i=1;i<=2*n;i++) if (A[0][a[i].x]!=a[i].y&&A[1][a[i].y]!=a[i].x) {\n\t\tGT[0][a[i].x].pb(a[i].y);\n\t\tGT[1][a[i].y].pb(a[i].x);\n\t}\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (A[i][j]) V[i^1][A[i][j]].pb(j);\n\tfor (i=0;i<=1;i++) for (j=1;j<=n;j++) if (!vis[i][j]&&GT[i][j].size()==2) \n\twork(i,j);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n\nconst int kN = 200000 + 5;\nconst int MOD = (int)1e9 + 7;\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a < 0) a += MOD;\n    else if (a >= MOD) a -= MOD;\n}\n\ninline int mul(int x)\n{\n    return x;\n}\n\ntemplate<typename... Args>\ninline int mul(int x, Args... args)\n{\n    return x * 1ll * mul(args...) % MOD;\n}\n\n\nint n;\nstd::vector<int> edges[kN], tree[kN];\nbool vis[kN], in[kN];\nstd::vector<int> vec;\nint F[kN], Finv[kN], Inv[kN];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return mul(F[a], Finv[b], Finv[a - b]);\n}\n\nvoid dfs(int u)\n{\n    vis[u] = true;\n    vec.emplace_back(u);\n    for (int v : edges[u]) if (!vis[v])\n        dfs(v);\n}\n\nbool find_cycle(int u, int fa, int &s, int &t)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != fa) {\n        if (vis[v]) {\n            s = u;\n            t = v;\n            return true;\n        } else if (find_cycle(v, u, s, t)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int u, int target)\n{\n    vis[u] = true;\n    for (int v : edges[u]) if (v != target) {\n        if (!vis[v])\n            dfs2(v, u);\n        // printf(\"(u, target): (%d, %d)\\n\", u, target);\n        if (v < target) {\n            tree[u].emplace_back(v);\n            // printf(\"%d->%d\\n\", u, v);\n            in[v] = true;\n        }\n    }\n}\n\nusing Val = std::pair<int, int>;\n\nVal combine(Val a, Val b)\n{\n    return Val(a.first + b.first, mul(a.second, b.second, binom(a.first + b.first, a.first)));\n}\n\nVal calc(int u)\n{\n    Val ret(0, 1);\n    for (int v : tree[u]) {\n        ret = combine(ret, calc(v));\n    }\n    ret.first ++;\n    // printf(\"u = %d, ret = (%d, %d)\\n\", u, ret.first, ret.second);\n    return ret;\n}\n\nstd::pair<int, int> solve(int u)\n{\n    vec.clear();\n    dfs(u);\n    int e = 0;\n    for (int v : vec)\n        e += edges[v].size();\n    if (e / 2 != vec.size() || vec.size() % 2) {\n        return std::make_pair(0, 0);\n    }\n\n    for (int v : vec) vis[v] = false;\n    int s, t;\n    find_cycle(u, -1, s, t);\n    int ways = 0;\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(s, t);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve0::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    for (int v : vec) vis[v] = false;\n    for (int v : vec) in[v] = false;\n    for (int v : vec) tree[v].clear();\n    dfs2(t, s);\n    // puts(\"fuck\");\n    {\n        Val val(0, 1);\n        for (int v : vec) if (!in[v]) {\n            val = combine(val, calc(v));\n            // printf(\"solve1::val = (%d, %d)\\n\", val.first, val.second);\n        }\n        add(ways, val.second);\n    }\n    return std::make_pair(vec.size(), ways);\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kN; ++ i)\n        Inv[i] = mul(MOD - MOD / i, Inv[MOD % i]);\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kN; ++ i) {\n        F[i] = mul(F[i - 1], i);\n        Finv[i] = mul(Finv[i - 1], Inv[i]);\n    }\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n * 2; ++ i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b); a --; b --;\n        edges[a].emplace_back(n + b);\n        edges[n + b].emplace_back(a);\n    }\n    Val val(0, 1);\n    for (int i = 0; i < n; ++ i) if (!vis[i]) {\n        val = combine(val, solve(i));\n    }\n    printf(\"%d\\n\", val.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\ntypedef long long ll;\nconst int mod=1000000007;\nint mul(int a,int b){return(ll)a*b%mod;}\nint pow(int a,int b){\n\tint s=1;\n\twhile(b){\n\t\tif(b&1)s=mul(s,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn s;\n}\nint fac[200010],rfac[200010],inv[200010],n;\nvoid pre(){\n\tint i;\n\tfac[0]=1;\n\tfor(i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\trfac[n]=pow(fac[n],mod-2);\n\tfor(i=n;i>0;i--)rfac[i-1]=mul(rfac[i],i);\n\tinv[1]=1;\n\tfor(i=2;i<=n;i++)inv[i]=-mul(mod/i,inv[mod%i]);\n}\nint C(int n,int k){return mul(fac[n],mul(rfac[k],rfac[n-k]));}\nint h[200010],nex[400010],to[400010],M;\nvoid add(int a,int b){\n\tM++;\n\tto[M]=b;\n\tnex[M]=h[a];\n\th[a]=M;\n}\nbool rg[200010],ins[200010],flag;\nint v[200010],p[200010],st[200010],tp,E;\nint cnt;\nvoid dfs(int fa,int x){\n\tint i,j;\n\tins[st[++tp]=x]=1;\n\tv[x]=1;\n\tp[++M]=x;\n\tfor(i=h[x];i;i=nex[i]){\n\t\tE++;\n\t\tif(to[i]!=fa){\n\t\t\tif(v[to[i]]){\n\t\t\t\tif(ins[to[i]]){\n\t\t\t\t\tif(flag)continue;\n\t\t\t\t\tfor(j=tp;j>0;j--){\n\t\t\t\t\t\trg[st[j]]=1;\n\t\t\t\t\t\tif(st[j]==to[i])break;\n\t\t\t\t\t}\n\t\t\t\t\tflag=1;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t\tdfs(x,to[i]);\n\t\t}\n\t}\n\ttp--;\n\tins[x]=0;\n}\nint fa[200010];\nvoid dfs(int x){\n\tv[x]=E;\n\tfor(int i=h[x];i;i=nex[i]){\n\t\tif(to[i]!=fa[x]&&v[to[i]]!=E){\n\t\t\tfa[to[i]]=x;\n\t\t\tdfs(to[i]);\n\t\t}\n\t}\n}\nint siz[200010];\nstruct tree{\n\tint h[200010],nex[200010],to[200010],M;\n\tvoid clear(int x){\n\t\tfor(int i=h[x];i;i=nex[i])clear(to[i]);\n\t\th[x]=0;\n\t}\n\tvoid clear(){\n\t\tM=0;\n\t\tclear(n+1);\n\t}\n\tvoid add(int a,int b){\n\t\tM++;\n\t\tto[M]=b;\n\t\tnex[M]=h[a];\n\t\th[a]=M;\n\t}\n\tvoid dfs(int x){\n\t\tsiz[x]=1;\n\t\tfor(int i=h[x];i;i=nex[i]){\n\t\t\tdfs(to[i]);\n\t\t\tsiz[x]+=siz[to[i]];\n\t\t}\n\t}\n}t;\nbool in[200010];\nint gao(){\n\tint i,j,x,s;\n\tt.clear();\n\tfor(j=1;j<=M;j++){\n\t\tx=p[j];\n\t\tfor(i=h[x];i;i=nex[i]){\n\t\t\tif(to[i]<fa[x]){\n\t\t\t\tin[to[i]]=1;\n\t\t\t\tt.add(x,to[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=M;i++){\n\t\tx=p[i];\n\t\tif(!in[x])t.add(n+1,x);\n\t}\n\tt.dfs(n+1);\n\ts=fac[M];\n\tfor(i=1;i<=M;i++)s=mul(s,inv[siz[p[i]]]);\n\tfor(j=1;j<=M;j++){\n\t\tx=p[j];\n\t\tfor(i=h[x];i;i=nex[i]){\n\t\t\tif(to[i]<fa[x])in[to[i]]=0;\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tint i,j,x,y,ans,siz,res;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n<<1;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y+n);\n\t\tadd(y+n,x);\n\t}\n\tn<<=1;\n\tpre();\n\tans=1;\n\tsiz=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(!v[i]){\n\t\t\tE=M=0;\n\t\t\tflag=0;\n\t\t\tdfs(0,i);\n\t\t\tE>>=1;\n\t\t\tif(E!=M){\n\t\t\t\tputchar('0');\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor(j=1;j<=M;j++){\n\t\t\t\tif(rg[p[j]]){\n\t\t\t\t\tx=p[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=h[x];j;j=nex[j]){\n\t\t\t\tif(rg[to[j]]){\n\t\t\t\t\ty=to[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=0;\n\t\t\tE=2;\n\t\t\tfa[y]=x;\n\t\t\tdfs(y);\n\t\t\tres+=gao();\n\t\t\tE=3;\n\t\t\tfa[x]=y;\n\t\t\tdfs(x);\n\t\t\tres+=gao();\n\t\t\tans=mul(mul(ans,res),C(siz+M,M));\n\t\t\tsiz+=M;\n\t\t}\n\t}\n\tprintf(\"%d\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nll pow_mod(ll x,int k) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n}\n\nll facd[200005],inv[200005];\n\nvoid pre(int n) {\n  facd[0]=1;\n  for(int i=1;i<=n;i++) facd[i]=facd[i-1]*i%MOD;\n  inv[1]=1;\n  for(int i=2;i<=n;i++) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;\n}\n\nstruct Edge {\n  int t,next;\n  Edge() {}\n  Edge(int a,int b):t(a),next(b) {}\n};\n\nEdge e[400005],e2[400005];\nint head[200005],head2[200005];\n\nint s1,s2;\nbool vis[200005];\n\nvoid dfs1(int x) {\n  vis[x]=1;\n  s1++;\n  for(int i=head[x];i;i=e[i].next) {\n  \tint u=e[i].t;\n  \ts2++;\n  \tif (!vis[u]) dfs1(u);\n  }\n}\n\nint cir[200005],cnt;\nint st[200005],top;\nbool hh[200005];\n\nbool dfs2(int x,int fa) {\n  st[++top]=x;\n  hh[x]=1;\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) {\n    \tint u=e[i].t;\n    \tif (!hh[u]) {\n\t\t  if (dfs2(u,x)) return 1;\n\t    }\n    \telse {\n    \t\tcnt=0;\n    \t\tint t;\n    \t\tdo {\n    \t\t\tt=st[top--];\n    \t\t\tcir[++cnt]=t;\n\t\t\t} while (t!=u);\n\t\t\treturn 1;\n\t\t}\n\t}\n  top--;\n  return 0;\n}\n\nbool in[200005];\nint p[200005],now[200005],ns;\n\nvoid dfs3(int x,int fa) {\n  now[++ns]=x;\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa&&!in[e[i].t]) {\n    \tint u=e[i].t;\n    \tp[u]=x;\n    \tdfs3(u,x);\n\t}\n}\n\nint size[200005];\n\nll dfs4(int x) {\n  size[x]=1;\n  ll s=1;\n  for(int i=head2[x];i;i=e2[i].next) {\n  \tint u=e2[i].t;\n    s=s*dfs4(u)%MOD;\n    size[x]+=size[u];\n  }\n  return s*inv[size[x]]%MOD;\n}\n\nbool rt[200005];\n\nll calc(int n) {\n  for(int i=1;i<=ns;i++) {\n    head2[now[i]]=0;\n    rt[now[i]]=1;\n  }\n  int tot=0;\n  for(int i=1;i<=ns;i++) {\n  \tint x=now[i];\n  \tfor(int j=head[x];j;j=e[j].next)\n  \t  if (e[j].t<p[x]) {\n  \t  \t  int u=e[j].t;\n  \t  \t  e2[++tot]=Edge(u,head2[x]);\n  \t  \t  head2[x]=tot;\n  \t  \t  rt[u]=0;\n\t\t}\n  }\n  ll s=1;\n  for(int i=1;i<=ns;i++)\n    if (rt[now[i]]) s=s*dfs4(now[i])%MOD;\n  return s;\n}\n\nll solve(int x) {\n  top=0;\n  dfs2(x,0);\n  for(int i=1;i<=cnt;i++) in[cir[i]]=1;\n  ns=0;\n  for(int i=1;i<=cnt;i++) dfs3(cir[i],0);\n  ll s=0;\n  p[cir[cnt]]=cir[1];\n  for(int i=cnt-1;i>0;i--) p[cir[i]]=cir[i+1];\n  s=(s+calc(cnt))%MOD;\n  p[cir[1]]=cir[cnt];\n  for(int i=2;i<=cnt;i++) p[cir[i]]=cir[i-1];\n  s=(s+calc(cnt))%MOD;\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  pre(2*n);\n  for(int i=1;i<=2*n;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[2*i-1]=Edge(n+y,head[x]);\n  \thead[x]=2*i-1;\n  \te[2*i]=Edge(x,head[n+y]);\n  \thead[n+y]=2*i;\n  }\n  ll ans=1;\n  for(int i=1;i<=2*n;i++)\n    if (!vis[i]) {\n    \ts1=s2=0;\n    \tdfs1(i);\n    \tif (s1*2!=s2) {\n    \t\tputs(\"0\");\n    \t\treturn 0;\n\t\t}\n\t\tans=ans*solve(i)%MOD;\n\t}\n  printf(\"%lld\\n\",ans*facd[2*n]%MOD);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        // assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            chain_t c = use_generic(i, true);\n            return c * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            chain_t c = use_generic(i, false);\n            return c * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        REP (y, n) acc = acc * go_row(y);\n        REP (x, n) acc = acc * go_col(x);\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n// debug_print();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n// debug_print();\n                assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Collecting Balls\n#include <algorithm>\n// #include <cassert>\n#include <cctype>\n// #include <cmath>\n#include <cstdio>\n// #include <cstdlib>\n#include <cstring>\n// #include <ctime>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#define fir first\n#define sec second\n#define pb push_back\n#define pch putchar\n#define rg register\n#define SZ(_) (int)_.size()\n#define LB(_, __) std::lower_bound(_.begin(), _.end(), __)\n#define UB(_, __) std::upper_bound(_.begin(), _.end(), __)\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\ntypedef std::pair<LL, int> Pli;\ntypedef std::pair<int, LL> Pil;\ntypedef std::pair<LL, LL> Pll;\ntypedef std::vector<int> Vi;\ntypedef std::vector<LL> Vl;\ntypedef std::map<int, int> Mii;\ntypedef std::map<LL, int> Mli;\ntypedef std::map<int, LL> Mil;\ntypedef std::map<LL, LL> Mll;\ntypedef std::set<int> Si;\ntypedef std::set<LL> Sl;\n\nconst int kInf = 0x3f3f3f3f, kMod = 1e9 + 7;\nconst LL kInf64 = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline\nvoid UMin(T & x, const T & y) { if (x > y) x = y; }\ntemplate <typename T> inline\nvoid UMax(T & x, const T & y) { if (x < y) x = y; }\ninline int Add(int a, int b) { return (a += b) >= kMod ? a - kMod : a; }\ninline int Sub(int a, int b) { return (a -= b) < 0 ? a + kMod : a; }\ninline int Mul(int a, int b) { return 1ll * a * b % kMod; }\nint FPow(int bs, int ex = kMod - 2) {\n\tint res = 1;\n\tfor (; ex; bs = Mul(bs, bs), ex >>= 1)\n\t\tif (ex & 1) res = Mul(res, bs);\n\treturn res;\n}\n\nconst int kMaxn = 2e5 + 5, kMaxm = kMaxn << 1;\n\ntypedef int IAr[kMaxm];\n\nint n, m, top, findcr;\nVi G[kMaxm], DT[kMaxm], T[kMaxm], cir, gt;\nIAr crw, vis, S, in, ideg, sz, onlp;\n\nint Dfs(int u);\nvoid Dfs(int u, int fa);\nvoid SCir(int u, int fa);\n\nint main() {\n\tscanf(\"%d\", &n);\n\tm = n << 1;\n\tfor (int i = 0, xi, yi; i < m; i++) {\n\t\tscanf(\"%d%d\", &xi, &yi);\n\t\tG[xi].pb(n + yi); G[n + yi].pb(xi);\n\t}\n\tint ans = 1;\n\tmemset(crw, 0xff, sizeof crw);\t// crw - circle way\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (vis[i]) continue;\n\t\tcir.clear(), gt.clear(), top = 0;\n\t\tSCir(i, findcr = 0);\n\t\tif (!findcr) { puts(\"0\"); return 0; }\n\t\tfor (auto u : cir) Dfs(u, 0);\n\t\t// printf(\" i = %d\\n\", i);\n\t\t// direction 1\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j]] = cir[j - 1]] = cir[j];\n\t\t//\tcir[j] -> cir[j - 1]\n\t\tin[crw[cir[0]] = *cir.rbegin()] = cir[0];\n\t\tfor (auto u : gt) {\n\t\t\tstd::sort(DT[u].begin(), DT[u].end());\n\t\t\tauto lim = UB(DT[u], in[u]);\n\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac1 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\t// printf(\"  subtree %d\\n\", u);\n\t\t\tfrac1 = Mul(frac1, Dfs(u));\n\t\t}\n\t\t// direction 2\n\t\tfor (int j = 1; j < SZ(cir); j++)\n\t\t\tin[crw[cir[j - 1]] = cir[j]] = cir[j - 1];\n\t\tin[crw[*cir.rbegin()] = cir[0]] = *cir.rbegin();\n\t\tfor (auto u : gt) ideg[u] = 0;\n\t\tfor (auto u : gt) {\n\t\t\tauto lim = UB(DT[u], in[u]); T[u].clear();\n\t\t\tfor (auto it = DT[u].begin(); it != lim; ++it) {\n\t\t\t\tT[u].pb(*it); ++ideg[*it];\n\t\t\t}\n\t\t\tif (~crw[u] && crw[u] < in[u]) {\n\t\t\t\tT[u].pb(crw[u]); ++ideg[crw[u]];\n\t\t\t}\n\t\t}\n\t\tint frac2 = 1;\n\t\tfor (auto u : gt) {\n\t\t\tif (ideg[u]) continue;\n\t\t\tfrac2 = Mul(frac2, Dfs(u));\n\t\t}\n\t\tans = Mul(ans, Add(FPow(frac1), FPow(frac2)));\n\t}\n\tint fac = 1;\n\tfor (int i = 2; i <= m; i++)\n\t\tfac = Mul(fac, i);\n\tprintf(\"%d\\n\", Mul(fac, ans));\n\treturn 0;\n}\n\nint Dfs(int u) {\n\tsz[u] = 1;\n\tint res = 1;\n\tfor (auto v : T[u]) {\n\t\tres = Mul(res, Dfs(v));\n\t\tsz[u] += sz[v];\n\t} return Mul(res, sz[u]);\n}\n\nvoid Dfs(int u, int fa) {\n\t// printf(\" Dfs side trees %d, fa %d\\n\", u, fa);\n\tvis[u] = 1; gt.pb(u);\n\tfor (auto v : G[u]) {\n\t\tif (v == fa || onlp[v]) continue;\n\t\tDT[u].pb(v); in[v] = u; Dfs(v, u);\n\t}\n}\n\nvoid SCir(int u, int fa) {\n\t// printf(\" Search for Loop at %d, fa %d\\n\", u, fa);\n\tvis[u] = 1, S[top++] = u;\n\tfor (auto v : G[u]) {\n\t\tif (v == fa) continue;\n\t\tif (vis[v]) {\t// find it!\n\t\t\twhile (top && S[top - 1] != v) {\n\t\t\t\tonlp[S[top - 1]] = 1; cir.pb(S[--top]);\n\t\t\t} onlp[v] = 1, cir.pb(v); --top;\n\t\t\tfindcr = 1;\n\t\t\treturn;\n\t\t}\n\t\tSCir(v, u);\n\t\tif (findcr) return;\n\t} if (S[top - 1] == u) --top;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 200000\nclass unionfind\n{\npublic:\n\tint par[SIZE];\n\tint ran[SIZE];\n\tint ren[SIZE];\n\tvoid init()\n\t{\n\t\tfor (int i = 0; i<SIZE; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t\tren[i] = 1;\n\t\t}\n\t}\n\tint find(int a)\n\t{\n\t\tif (a == par[a])return a;\n\t\telse return par[a] = find(par[a]);\n\t}\n\tvoid unite(int a, int b)\n\t{\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b)return;\n\t\tif (ran[a]>ran[b])\n\t\t{\n\t\t\tpar[b] = a;\n\t\t\tren[a] += ren[b];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[a] = b;\n\t\t\tren[b] += ren[a];\n\t\t}\n\t\tif (ran[a] == ran[b])ran[b]++;\n\t}\n};\nunionfind uf;\n#define SIZE 300000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nvector<int>pat[200000];\ntypedef pair<int, int>pii;\nbool flag[200000];\nvector<int>nowp;\nvector<int>nowcirc;\nvoid dfs(int node, int s, int p)\n{\n\tif (flag[node])\n\t{\n\t\tif (s == node)nowcirc = nowp;\n\t\treturn;\n\t}\n\tflag[node] = true;\n\tnowp.push_back(node);\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (pat[node][i] != p)dfs(pat[node][i], s, node);\n\t}\n\tnowp.pop_back();\n}\nvoid no()\n{\n\tprintf(\"0\\n\");\n\texit(0);\n}\nint pt = 0;\nvector<int>ko[1000000];\nint indeg[1000000];\nmap<pii, int>idx;\nvoid dfs2(int x, int y, int d, int p)\n{\n\tidx[make_pair(x, y)] = p;\n\t//printf(\"%d %d   %d %d\\n\", x/2 + 1, y/2 + 1, idx[make_pair(x, y)], d);\n\tif (d == 0)\n\t{\n\t\tfor (int i = 0; i < pat[x].size(); i++)\n\t\t{\n\t\t\tpii z = make_pair(x, pat[x][i]);\n\t\t\tif (idx.count(z) == 0)\n\t\t\t{\n\t\t\t\tpt++;\n\t\t\t\tidx[z] = pt;\n\t\t\t\tif (pat[x][i] < y)\n\t\t\t\t{\n\t\t\t\t\tko[p].push_back(pt);\n\t\t\t\t\tindeg[pt]++;\n\t\t\t\t}\n\t\t\t\tdfs2(x, pat[x][i], 1 ^ d, pt);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < pat[y].size(); i++)\n\t\t{\n\t\t\tpii z = make_pair(pat[y][i], y);\n\t\t\tif (idx.count(z) == 0)\n\t\t\t{\n\t\t\t\tpt++;\n\t\t\t\tidx[z] = pt;\n\t\t\t\tif (pat[y][i] < x)\n\t\t\t\t{\n\t\t\t\t\tko[p].push_back(pt);\n\t\t\t\t\tindeg[pt]++;\n\t\t\t\t}\n\t\t\t\tdfs2(pat[y][i], y, 1 ^ d, pt);\n\t\t\t}\n\t\t}\n\t}\n}\npair<ll, ll>dfs3(int node)\n{\n\tll x = 1;\n\tint sum = 0;\n\tfor (int i = 0; i < ko[node].size(); i++)\n\t{\n\t\tpair<ll, ll>t = dfs3(ko[node][i]);\n\t\tx = x*t.first%mod*com(sum + t.second, sum) % mod;\n\t\tsum += t.second;\n\t}\n\treturn make_pair(x, sum + 1);\n}\npair<ll, ll>solve(vector<int>circ, int mode)\n{\n\t//for (int i = 0; i < circ.size(); i++)printf(\"%d \", circ[i]); printf(\"\\n\");\n\tpii maxi = make_pair(-1, -1);\n\tfor (int i = 0; i < circ.size(); i++)\n\t{\n\t\tpii t;\n\t\tif (circ[i] % 2 == 0)t = make_pair(circ[i], circ[(i + 1) % circ.size()]);\n\t\telse t = make_pair(circ[(i + 1) % circ.size()], circ[i]);\n\t\tif (maxi < t)maxi = t;\n\t}\n\tpt++;\n\tint st = pt;\n\tdfs2(maxi.first, maxi.second, mode, pt);\n\tll ans = 1;\n\tint sum = 0;\n\tfor (int i = st; i <= pt; i++)\n\t{\n\t\tif (indeg[i] == 0)\n\t\t{\n\t\t\tpair<ll, ll>z = dfs3(i);\n\t\t\tans = ans*z.first%mod*com(sum + z.second, sum) % mod;\n\t\t\tsum += z.second;\n\t\t}\n\t}\n\treturn make_pair(ans, sum);\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tuf.init();\n\tinvinit();\n\tvector<pii>circe;\n\tfor (int i = 0; i < num + num; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tza *= 2, zb *= 2, zb++;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t\tif (uf.find(za) == uf.find(zb))circe.push_back(make_pair(za, zb));\n\t\tuf.unite(za, zb);\n\t}\n\tfor (int i = 0; i < num + num; i++)sort(pat[i].begin(), pat[i].end());\n\tvector<vector<int> >vec;\n\tfor (int i = 0; i < circe.size(); i++)\n\t{\n\t\tif (flag[circe[i].first])no();\n\t\tdfs(circe[i].first, circe[i].first, circe[i].second);\n\t\tvec.push_back(nowcirc);\n\t}\n\tfill(flag, flag + num + num, false);\n\tll ans = 1;\n\tint sum = 0;\n\tfor (int i = 0; i < vec.size(); i++)\n\t{\n\t\tidx.clear();\n\t\tpair<ll, ll>a = solve(vec[i], 0);\n\t\tidx.clear();\n\t\tpair<ll, ll>b = solve(vec[i], 1);\n\t\tans = ans*(a.first + b.first) % mod*com(sum + a.second, sum) % mod;\n\t\tsum += a.second;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define isNum(a) (a >= '0' && a <= '9')\n#define SP putchar(' ')\n#define EL putchar('\\n')\n#define File(a) freopen(a \".in\", \"r\", stdin), freopen(a \".out\", \"w\", stdout)\n\ntemplate <class T> void read(T &);\ntemplate <class T> void write(const T &);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef const long long &cll;\ntypedef const int &ci;\ntypedef std::pair<int, int> pii;\nconst int iinf = 2147483647;\nconst ll llinf = 9223372036854775807ll;\nusing std::abs;\nusing std::max;\nusing std::min;\n\nconst int N = 200005;\nconst int M = 400005;\nconst int Mod = 1000000007;\n\nint pow(int a, int b, int m);\nvoid add(int u, int v);\nvoid add2(int u, int v);\nvoid dfs1(int u, int fa);\nvoid dfs2(int u, int fa);\nvoid dfs3(int u, int fa);\nint solve();\n\nint hed[N], nxt[M], to[M], id;\nint hed2[N], nxt2[M], to2[M], id2;\nint fac[N], ifac[N], inv[N];\nint sta[N];\nbool vis[N];\nint deg[N];\nint sv, se;\nint nto[N];\nint siz[N];\nint X, Y;\nint n;\n\nint main() {\n  read(n);\n  for (int i = 1; i <= 2 * n; ++i) {\n    int x, y;\n    read(x), read(y);\n    y += n;\n    add(x, y), add(y, x);\n  }\n  n <<= 1;\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fac[i] = fac[i - 1] * 1ll * i % Mod;\n  }\n  ifac[n] = pow(fac[n], Mod - 2, Mod);\n  for (int i = n - 1; i >= 1; --i) {\n    ifac[i] = ifac[i + 1] * 1ll * (i + 1) % Mod;\n  }\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    inv[i] = (Mod - Mod / i) * 1ll * inv[Mod % i] % Mod;\n  }\n  int ans = fac[n];\n  for (int i = 1; i <= n; ++i) {\n    if (!vis[i]) {\n      sv = se = 0;\n      dfs1(i, 0);\n      if ((sv << 1) != se) {\n        puts(\"0\");\n        return 0;\n      }\n      ans = ans * 1ll * ifac[sv] % Mod;\n      int now = solve();\n      std::swap(X, Y);\n      now = (now + solve()) % Mod;\n      ans = ans * 1ll * now % Mod;\n    }\n  }\n  write(ans), EL;\n  return 0;\n}\n\ntemplate <class T> inline void read(T &Re) {\n  T k = 0;\n  char ch = getchar();\n  int flag = 1;\n  while (!isNum(ch)) {\n    if (ch == '-') {\n      flag = -1;\n    }\n    ch = getchar();\n  }\n  while (isNum(ch)) {\n    k = (k << 1) + (k << 3) + ch - '0';\n    ch = getchar();\n  }\n  Re = flag * k;\n}\ntemplate <class T> inline void write(const T &Wr) {\n  if (Wr < 0) {\n    putchar('-');\n    write(-Wr);\n  } else {\n    if (Wr < 10) {\n      putchar(Wr + '0');\n    } else {\n      write(Wr / 10);\n      putchar((Wr % 10) + '0');\n    }\n  }\n}\n\nint pow(int a, int b, int m) {\n  int ans = 1, now = a;\n  while (b) {\n    if (b & 1) {\n      ans = ans * 1ll * now % m;\n    }\n    now = now * 1ll * now % m;\n    b >>= 1;\n  }\n  return ans;\n}\nvoid add(int u, int v) {\n  nxt[++id] = hed[u];\n  hed[u] = id;\n  to[id] = v;\n}\nvoid add2(int u, int v) {\n  nxt2[++id2] = hed2[u];\n  hed2[u] = id2;\n  to2[id2] = v;\n}\nvoid dfs1(int u, int fa) {\n  vis[u] = true;\n  sta[++sv] = u;\n  for (int i = hed[u]; i; i = nxt[i], ++se) {\n    int v = to[i];\n    if (!vis[v]) {\n      dfs1(v, u);\n    } else {\n      if (v != fa) {\n        X = u, Y = v;\n      }\n    }\n  }\n}\nvoid dfs2(int u, int fa) {\n  for (int i = hed[u]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v != fa && v != X) {\n      nto[v] = u;\n      dfs2(v, u);\n    }\n  }\n}\nvoid dfs3(int u, int fa) {\n  siz[u] = 1;\n  for (int i = hed2[u]; i; i = nxt2[i]) {\n    int v = to2[i];\n    if (v != fa) {\n      dfs3(v, u);\n      siz[u] += siz[v];\n    }\n  }\n}\nint solve() {\n  dfs2(X, Y);\n  nto[X] = Y;\n  for (int i = 1; i <= sv; ++i) {\n    hed2[sta[i]] = deg[sta[i]] = 0;\n  }\n  for (int i = 1; i <= sv; ++i) {\n    for (int j = hed[sta[i]]; j; j = nxt[j]) {\n      int v = to[j];\n      if (v < nto[sta[i]]) {\n        add2(sta[i], v);\n        ++deg[v];\n      }\n    }\n  }\n  for (int i = 1; i <= sv; ++i) {\n    if (deg[sta[i]] == 0) {\n      dfs3(sta[i], 0);\n    }\n  }\n  int ans = fac[sv];\n  for (int i = 1; i <= sv; ++i) {\n    ans = ans * 1ll * inv[siz[sta[i]]] % Mod;\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\ntypedef long long ll;\n\nconst int N = 200005, P = 1000000007;\nint n, Ans = 1, Res;\nint Head[N], Next[N << 1], To[N << 1], Val[N << 1], En;\nint Vis[N], Sta[N], Top, w[N], f, a, b, c, s[N];\n\nll Inv(ll a, ll s = 1) { for (int b = P - 2; b; b >>= 1, a = a * a % P)if (b & 1)s = s * a % P; return s % P; }\ninline void Add(int x, int y, int z) { Next[++En] = Head[x], To[Head[x] = En] = y, Val[En] = z; }\n\nvoid DFS1(int x, int Fa)\n{\n\tVis[x] = 2, Sta[++Top] = x;\n\tfor (int i = Head[x], y; i; i = Next[i])\n\t\tif ((y = To[i]) != Fa)\n\t\t{\n\t\t\tif (Vis[y] == 2)\n\t\t\t{\n\t\t\t\ta = x, b = y, c = Val[i], ++f;\n\t\t\t\tint Ts = Top;\n\t\t\t\tdo if (w[--Ts] > c)a = Sta[Ts], b = Sta[Ts + 1], c = w[Ts];\n\t\t\t\twhile (Sta[Ts] != y);\n\t\t\t}\n\t\t\telse if (!Vis[y])w[Top] = Val[i], DFS1(y, x);\n\t\t}\n\tVis[x] = 1, --Top;\n}\n\nvoid DFS2(int x, int Fa, int w)\n{\n\ts[x] = 1;\n\tfor (int i = Head[x], y; i; i = Next[i])\n\t\tif ((y = To[i]) != Fa && y != a && (x != a || y != b))\n\t\t\tif (DFS2(y, x, Val[i]), Val[i] < w)\n\t\t\t\ts[x] += s[y];\n\tRes = Res * Inv(s[x]) % P;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n), n <<= 1;\n\tfor (int i = 1, x, y; i <= n; ++i)scanf(\"%d%d\", &x, &y), Add(x, y + n / 2, x + y), Add(y + n / 2, x, x + y);\n\tfor (int i = 1; i <= n; ++i)Ans = (ll)Ans * i % P;\n\tfor (int i = 1, Tmp; i <= n; ++i)\n\t\tif (!Vis[i])\n\t\t{\n\t\t\tf = 0, DFS1(i, 0);\n\t\t\tif (f != 1)return puts(\"0\"), 0;\n\t\t\tRes = 1, DFS2(a, 0, c);\n\t\t\tTmp = Res, std::swap(a, b);\n\t\t\tRes = 1, DFS2(a, 0, c);\n\t\t\tAns = Ans * ll(Tmp + Res) % P;\n\t\t}\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n#define int long long\nconst int N=2e5+10,p=1e9+7;\nint n,m,mp[N],fa[N],ln[N],dn[N];\nstruct P{int x,y,id;}o[N];\ninline bool cmpx(P u,P v){return u.x<v.x;}\ninline bool cmpy(P u,P v){return u.y<v.y;}\ninline bool cmpid(P u,P v){return u.id<v.id;}\nvector<int> g[N];\nint no,nosi,fac[N],inv[N];\ninline int ask(int x){\n\treturn fa[x]==x?x:fa[x]=ask(fa[x]);\n}\ninline int C(int x,int y){\n\treturn fac[x]*inv[x-y]%p*inv[y]%p;\n}\nset<int> se;\nqueue<int> q;\ninline void merge(int &x,int &six,int y,int siy){\n\tsix+=siy;\n\tx=x*y%p*C(six,siy)%p;\n}\nint rd[N],fx[N];\n//fx:0:×ó 1:ÏÂ \nvector<pair<int,int> > cb[N];\nvector<int> ip;\n\nint tot,fi[N],a[N<<2],ne[N<<2],si[N];\ninline void add(int x,int y){\n\ta[++tot]=y;ne[tot]=fi[x];fi[x]=tot;\n}\ninline int dfs(int x){\n\tsi[x]=0;int ans=1,t;\n\tfor (int i=fi[x];i;i=ne[i]) t=dfs(a[i]),merge(ans,si[x],t,si[a[i]]);\n\t++si[x];\n\treturn ans;\n}\nbool flag[N];\ninline int build(const vector<int> &g){\n\tint gs=g.size();\n\ttot=0;for (int i=0;i<gs;++i) flag[g[i]]=1,fi[g[i]]=si[g[i]]=0;\n\tfor (int i=0;i<gs;++i) \n\t\tif (fx[g[i]]==0){\n\t\t\tint t=ln[g[i]];\n\t\t\twhile (t){\n\t\t\t\tadd(g[i],t);flag[t]=0;\n\t\t\t\tif (fx[t]==0) break;\n\t\t\t\tt=ln[t];\n\t\t\t}\n\t\t}else{\n\t\t\tint t=dn[g[i]];\n\t\t\twhile (t){\n\t\t\t\tadd(g[i],t);flag[t]=0;\n\t\t\t\tif (fx[t]==1) break;\n\t\t\t\tt=dn[t];\n\t\t\t}\n\t\t\t\n\t\t}\n\tint ans=1,anssi=0,t;\n\tfor (int i=0;i<gs;++i) if (flag[g[i]]) t=dfs(g[i]),merge(ans,anssi,t,si[g[i]]);\n\treturn ans;\n}\ninline int solve(const vector<int> &g){\n\tint gs=g.size();\n\twhile (!q.empty()) q.pop();se.clear();\n\tfor (int i=0;i<gs;++i) se.insert(o[g[i]].x),se.insert(o[g[i]].y+n);\n\tfor (set<int>::iterator it=se.begin();it!=se.end();++it) if (rd[*it]==1) q.push(*it);\n\twhile (!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor (vector<pair<int,int> >::iterator it=cb[u].begin();it!=cb[u].end();++it)\n\t\tif (rd[it->first]>1){\n\t\t\tfx[it->second]=u<=n;\n\t\t\tif (--rd[it->first]==1) q.push(it->first);\n\t\t}\n\t}\n\tfor (set<int>::iterator it=se.begin();it!=se.end();++it) if (rd[*it]!=1&&rd[*it]!=2) return 0;\n\tint nt=-1;\n\tfor (set<int>::iterator it=se.begin();it!=se.end();++it) if (rd[*it]==2) {nt=*it;break;}\n\tif (nt==-1) return build(g);\n\tip.clear();\n\tint ntt=nt;\n\tok:;\n\tfor (vector<pair<int,int> >::iterator it=cb[nt].begin();it!=cb[nt].end();++it)\n\t\tif (rd[it->first]>1&&it->first!=ntt){\n\t\t\t--rd[it->first];\n\t\t\tip.push_back(it->second);\n\t\t\tfx[it->second]=nt<=n;\n\t\t\tnt=it->first;\n\t\t\tgoto ok;\n\t\t}\n\tfor (vector<pair<int,int> >::iterator it=cb[nt].begin();it!=cb[nt].end();++it)\n\t\tif (rd[it->first]>1){\n\t\t\t--rd[it->first];\n\t\t\tip.push_back(it->second);\n\t\t\tfx[it->second]=nt<=n;\n\t\t}\n\t\n\tint ans=build(g);\n\tfor (int i=0;i<ip.size();++i) fx[ip[i]]^=1;\n\treturn ans+build(g);\n}\nmain(){\n\tscanf(\"%lld\",&n);m=n<<1;\n\tfor (int i=1;i<=m;++i) \n\t\tscanf(\"%lld%lld\",&o[i].x,&o[i].y),o[i].id=i,\n\t\tcb[o[i].x].push_back(make_pair(o[i].y+n,i)),\n\t\tcb[o[i].y+n].push_back(make_pair(o[i].x,i)),\n\t\t++rd[o[i].x],++rd[o[i].y+n];\n\tsort(o+1,o+m+1,cmpx);\n\tfor (int i=1;i<=n;++i) mp[i]=0;\n\tfor (int i=1;i<=m;++i) ln[o[i].id]=mp[o[i].y],mp[o[i].y]=o[i].id;\n\tsort(o+1,o+m+1,cmpy);\n\tfor (int i=1;i<=n;++i) mp[i]=0;\n\tfor (int i=1;i<=m;++i) dn[o[i].id]=mp[o[i].x],mp[o[i].x]=o[i].id;\n\tsort(o+1,o+m+1,cmpid);\n\t\n\tfac[0]=1;for (int i=1;i<=m;++i) fac[i]=fac[i-1]*i%p;\n\tinv[0]=inv[1]=1;for (int i=2;i<=m;++i) inv[i]=inv[p%i]*(p-p/i)%p;\n\tfor (int i=2;i<=m;++i) inv[i]=inv[i]*inv[i-1]%p;\n\t\n\tfor (int i=1;i<=m;++i) fa[i]=i;\n\tfor (int i=1;i<=m;++i){\n\t\tif (dn[i]) fa[ask(i)]=ask(dn[i]);\n\t\tif (ln[i]) fa[ask(i)]=ask(ln[i]);\n\t}\n\tfor (int i=1;i<=m;++i) g[ask(i)].push_back(i);\n\tint ans=1,anssi=0;\n\tfor (int i=1;i<=m;++i) if (fa[i]==i) merge(ans,anssi,solve(g[i]),g[i].size()); \n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nint x[210000];\nint y[210000];\nint UF[210000];\nvector<int>g[210000];\nint FIND(int a){\n\tif(UF[a]<0)return a;return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint h[210000];\nint v[210000];\nvector<int>cy;\nvector<int>cur;\nint dfs(int a,int b){\n\tv[a]=-1;\n\t\n\tcur.push_back(a);\n\tint ret=-2;\n\t\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(g[a][i]==b)continue;\n\t\tif(v[g[a][i]]==-2){\n\t\t\tint val=dfs(g[a][i],a);\n\t\t\tif(val!=-2){\n\t\t\t\tcy.push_back(a);\n\t\t\t\tif(a==val)val=-2;\n\t\t\t}\n\t\t\tif(val!=-2) ret=val;\n\t\t}else if(v[g[a][i]]!=a){\n\t\t\tcy.push_back(a);\n\t\t\tret=g[a][i];\n\t\t}\n\t}\n\tv[a]=ret;\n\t// printf(\"%d %d: %d\\n\",a,b,ret);fflush(stdout);\n\treturn ret;\n}\nvector<int>g2[210000];\nint sz[210000];\nint ou[210000];\nlong long calc(int a){\n\tlong long ret=1;\n\tsz[a]=0;\n\tfor(int i=0;i<g2[a].size();i++){\n\t\tret=ret*calc(g2[a][i])%mod;\n\t\tret=ret*Comb(sz[a]+sz[g2[a][i]],sz[a])%mod;\n\t\tsz[a]+=sz[g2[a][i]];\n\t}\n\tsz[a]++;\n\t// printf(\"%d: %lld\\n\",a,ret);\n\treturn ret;\n}\nint tl[210000];\nint n;\nvoid dfs2(int a,int b){\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\t// printf(\"%d %d\\n\",a,g[a][i]);\n\t\ttl[g[a][i]]=a;\n\t\tif(g[a][i]==cy[0])continue;\n\t\tdfs2(g[a][i],a);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tfor(int i=0;i<a*2;i++)UF[i]=-1;\n\tfor(int i=0;i<a*2;i++)v[i]=-2;\n\tinit_C(410000);\n\tfor(int i=0;i<2*a;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tx[i]--;y[i]--;\n\t\tg[x[i]].push_back(y[i]+a);\n\t\tg[y[i]+a].push_back(x[i]);\n\t\tUNION(x[i],y[i]+a);\n\t}\n\tfor(int i=0;i<a*2;i++){\n\t\th[FIND(x[i])]++;\n\t}\n\tlong long ret=1;\n\tlong long ks=1;\n\tint tn=0;\n\tfor(int i=0;i<a*2;i++){\n\t\tif(UF[i]<0&&h[i]!=-UF[i]){\n\t\t\tprintf(\"0\\n\");return 0;\n\t\t}\n\t\tif(UF[i]<0){\n\t\t\tcur.clear();\n\t\t\tks=ks*Comb(tn+h[i],h[i])%mod;\n\t\t\ttn+=h[i];\n\t\t\tcy.clear();\n\t\t\tdfs(i,-1);\n\t\t\t// for(int j=0;j<cy.size();j++)printf(\"%d \",cy[j]);printf(\"\\n\");\n\t\t\tlong long tmp=0;\n\t\t\tfor(int k=0;k<2;k++){\n\n\t\t\t\tif(k==0)dfs2(cy[0],cy[1]);\n\t\t\t\telse dfs2(cy[0],cy[cy.size()-1]);\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tfor(int l=0;l<g[cur[j]].size();l++){\n\t\t\t\t\t\tint to=g[cur[j]][l];\n\t\t\t\t\t\tif(to<tl[cur[j]]){\n\t\t\t\t\t\t\tg2[cur[j]].push_back(to);\n\t\t\t\t\t\t\t// printf(\"%d %d\\n\",cur[j],to);\n\t\t\t\t\t\t\tou[to]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tif(!ou[cur[j]]){\n\t\t\t\t\t\tg2[a*2].push_back(cur[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp+=calc(a*2);\n\n\t\t\t\tfor(int j=0;j<cur.size();j++){\n\t\t\t\t\tg2[cur[j]].clear();\n\t\t\t\t\tou[cur[j]]=0;\n\t\t\t\t}\n\t\t\t\tg2[a*2].clear();\n\t\t\t}\n\t\t\ttmp%=mod;\n\t\t\t// printf(\"%d: %lld\\n\",i,tmp);\n\t\t\tret=ret*tmp%mod;\n\t\t}\n\t}\n\n\tret=ret*ks%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef long double ld; \ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<ll>::iterator sit;\ntypedef map<ll,ll>::iterator mit;\n\nstruct Combi\n{\n\tvector<ll> fact;\n\tvector<ll> ifact;\n\tvector<ll> inv;\n\tvector<ll> pow2;\n\tconst int MOD = 1e9 + 7;\n\tll add(ll a, ll b)\n\t{\n\t\ta+=b;\n\t\twhile(a>=MOD) a-=MOD;\n\t\treturn a;\n\t}\n\tll mult(ll a, ll b)\n\t{\n\t\treturn (a*b)%MOD;\n\t}\n\tll modpow(ll a, ll b)\n\t{\n\t\tll r=1;\n\t\twhile(b)\n\t\t{\n\t\t\tif(b&1) r=mult(r,a);\n\t\t\ta=mult(a,a);\n\t\t\tb>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tll choose(ll a, ll b)\n\t{\n\t\tif(a<b) return 0;\n\t\tif(b==0) return 1;\n\t\tif(a==b) return 1;\n\t\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n\t}\n\tll inverse(ll a)\n\t{\n\t\treturn modpow(a,MOD-2);\n\t}\n\tvoid init(int _n)\n\t{\n\t\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\t\tfact.resize(_n+1);\n\t\tifact.resize(_n+1);\n\t\tinv.resize(_n+1);\n\t\tpow2.resize(_n+1);\n\t\tpow2[0]=1;\n\t\tifact[0]=1;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<=_n;i++)\n\t\t{\n\t\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\t\tinv[i] = inverse(i);\n\t\t\tfact[i]=mult(fact[i-1],i);\n\t\t\tifact[i]=mult(ifact[i-1],inv[i]);\n\t\t}\n\t}\n};\n\n\nCombi combi;\nvi adj[211111];\nset<ii> S;\nset<ii> ad[211111];\nvector<vi> cyc;\nbool vis[211111];\n\nvoid dfscyc(int u)\n{\n\tvis[u]=1;\n\tcyc.back().pb(u);\n\tfor(auto it=ad[u].begin();it!=ad[u].end();it++)\n\t{\n\t\tint v=(*it).fi;\n\t\tif(!vis[v])\n\t\t{\n\t\t\tdfscyc(v);\n\t\t}\n\t}\n}\n\nmap<ii,int> ma;\nint n; \nint match[200011];\nint imatch[200011];\nvi comp[200011];\n\nvoid dfs(int u, int idx)\n{\n\tvis[u]=1;\n\tcomp[idx].pb(u);\n\t//////////cerr<<u<<'\\n';\n\tfor(int i=0;i<adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(vis[v]) continue;\n\t\tii cur = mp(u,v%n);\n\t\tif(u>=n) cur = mp(v,u%n);\n\t\tmatch[ma[cur]] = v;\n\t\timatch[v] = ma[cur];\n\t\tdfs(v,idx);\n\t}\n}\nconst int MOD=1e9+7;\n\nll add(ll &a, ll b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nvector<ii> pt;\nvi T[200001];\nint indeg[200001];\n\nll mult(ll a, ll b)\n{\n\treturn (a*b)%MOD;\n}\n\nii calctree(int u ,int p = -1)\n{\n\tll ans = 1;\n\tll siz=1;\n\tfor(int i=0;i<T[u].size();i++)\n\t{\n\t\tint v=T[u][i];\n\t\tii res = calctree(v,u);\n\t\tans = mult(ans,res.fi);\n\t\tans = mult(ans,combi.ifact[res.se]);\n\t\tsiz+=res.se;\n\t}\n\tans = mult(ans,combi.fact[siz-1]);\n\t//////cerr<<u<<' '<<p<<' '<<ans<<' '<<siz<<'\\n';\n\treturn mp(ans,siz);\n}\n\nint timer;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tint x, y; cin>>x>>y;\n\t\tx--; y--;\n\t\tadj[x].pb(y+n);\n\t\tadj[y+n].pb(x);\n\t\tad[x].insert(mp(y+n,++timer));\n\t\tad[y+n].insert(mp(x,timer));\n\t\tma[mp(x,y)] = i;\n\t\tpt.pb(mp(x,y));\n\t}\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tS.insert(mp(int(ad[i].size()),i));\n\t}\n\twhile(!S.empty())\n\t{\n\t\tii tmp = (*S.begin());\n\t\t//////cerr<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\tif(tmp.fi==0)\n\t\t{\n\t\t\tcout<<0<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t\telse if(tmp.fi==1)\n\t\t{\n\t\t\tint u = tmp.se;\n\t\t\tint v = (*ad[u].begin()).fi;\n\t\t\tS.erase(mp(ad[u].size(),u));\n\t\t\tS.erase(mp(ad[v].size(),v));\n\t\t\t//////cerr<<\"ERASE : \"<<v<<' '<<ad[v].size()<<'\\n';\n\t\t\tad[u].erase(ad[u].lower_bound(mp(v,-1)));\n\t\t\tad[v].erase(ad[v].lower_bound(mp(u,-1)));\n\t\t\t//////cerr<<\"ERASE : \"<<v<<' '<<ad[v].size()<<'\\n';\n\t\t\tS.insert(mp(ad[v].size(),v));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tvi vertices;\n\tfor(auto it = S.begin(); it != S.end(); it++)\n\t{\n\t\tif(!vis[it->se]) \n\t\t{\n\t\t\tcyc.pb(vi());\n\t\t\tdfscyc(it->se);\n\t\t}\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=0;i<cyc.size();i++) \n\t{\n\t\tfor(int j=0;j<cyc[i].size();j++)\n\t\t{\n\t\t\t////cerr<<cyc[i][j]<<' ';\n\t\t\tvis[cyc[i][j]]=1;\n\t\t}\n\t\t////cerr<<'\\n';\n\t}\n\tfor(int i=0;i<cyc.size();i++)\n\t{\n\t\tfor(int j=0;j<cyc[i].size();j++)\n\t\t{\n\t\t\tdfs(cyc[i][j],i);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tsort(adj[i].begin(),adj[i].end());\n\t}\n\tcombi.init(212121);\n\tvector<ll> results;\n\tll res = combi.fact[2*n];\n\tfor(int z=0;z<cyc.size();z++)\n\t{\n\t\tsort(comp[z].begin(),comp[z].end());\n\t\tres=mult(res,combi.ifact[comp[z].size()]);\n\t\tll ans=1;\n\t\tfor(int i=0;i<cyc[z].size();i++)\n\t\t{\n\t\t\tint u=cyc[z][i];\n\t\t\tint v=cyc[z][(i+1)%int(cyc[z].size())];\n\t\t\t//////////cerr<<u<<' '<<v<<'\\n';\n\t\t\tii cur = mp(u,v%n);\n\t\t\tif(u>=n) cur = mp(v,u%n);\n\t\t\tmatch[ma[cur]] = u;\n\t\t\timatch[u] = ma[cur];\n\t\t\t//////////cerr<<u<<' '<<ma[cur]<<'\\n';\n\t\t}\n\t\tvi FF;\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tint x = imatch[i];\n\t\t\tii V = pt[x];\n\t\t\tint cr = V.se + n;\n\t\t\tif(i>=n)\n\t\t\t{\n\t\t\t\tcr = V.fi;\n\t\t\t}\n\t\t\tif(i<n) FF.pb(ma[mp(i,cr-n)]);\n\t\t\telse FF.pb(ma[mp(cr,i-n)]);\n\t\t\tfor(int j=0;j<adj[i].size();j++)\n\t\t\t{\n\t\t\t\tint v=adj[i][j];\n\t\t\t\tif(v<cr)\n\t\t\t\t{\n\t\t\t\t\tif(i<n)\n\t\t\t\t\t{\n\t\t\t\t\t\t//////////cerr<<i<<' '<<v-n<<' '<<i<<' '<<cr-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(i,cr-n)]].pb(ma[mp(i,v-n)]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//////////cerr<<v<<' '<<i-n<<' '<<cr<<' '<<i-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(cr,i-n)]].pb(ma[mp(v,i-n)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(FF.begin(),FF.end());\n\t\tFF.erase(unique(FF.begin(),FF.end()),FF.end());\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tfor(int j=0;j<T[i].size();j++)\n\t\t\t{\n\t\t\t\t//cerr<<\"T1 : \"<<i<<' '<<T[i][j]<<'\\n';\n\t\t\t\tindeg[T[i][j]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi vec;\n\t\t\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tif(indeg[i]==0)\n\t\t\t{\n\t\t\t\tii tmp = calctree(i);\n\t\t\t\t////////cerr<<\"DEG : \"<<i<<' '<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\t\t\tans = mult(ans,tmp.fi);\n\t\t\t\t//////cerr<<i<<' '<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\t\t\tvec.pb(tmp.se);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll r=0;\n\t\tfor(int i=0;i<vec.size();i++)\n\t\t{\n\t\t\tr+=vec[i];\n\t\t\tans=mult(ans,combi.ifact[vec[i]]);\n\t\t}\n\t\tans=mult(ans,combi.fact[r]);\n\t\t//////////cerr<<ans<<'\\n';\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tT[i].clear();\n\t\t\tindeg[i]=0;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<cyc[z].size();i++)\n\t\t{\n\t\t\tint u=cyc[z][i];\n\t\t\tint v=cyc[z][(i+1)%int(cyc[z].size())];\n\t\t\tii cur = mp(u,v%n);\n\t\t\tif(u>=n) cur = mp(v,u%n);\n\t\t\tmatch[ma[cur]] = v;\n\t\t\timatch[v] = ma[cur];\n\t\t}\n\t\tFF.clear();\n\t\tfor(int f=0;f<comp[z].size();f++)\n\t\t{\n\t\t\tint i=comp[z][f];\n\t\t\tint x = imatch[i];\n\t\t\tii V = pt[x];\n\t\t\tint cr = V.se + n;\n\t\t\tif(i>=n)\n\t\t\t{\n\t\t\t\tcr = V.fi;\n\t\t\t}\n\t\t\tif(i<n) FF.pb(ma[mp(i,cr-n)]);\n\t\t\telse FF.pb(ma[mp(cr,i-n)]);\n\t\t\tfor(int j=0;j<adj[i].size();j++)\n\t\t\t{\n\t\t\t\tint v=adj[i][j];\n\t\t\t\tif(v<cr)\n\t\t\t\t{\n\t\t\t\t\tif(i<n)\n\t\t\t\t\t{\n\t\t\t\t\t\t//////////cerr<<i<<' '<<v-n<<' '<<i<<' '<<cr-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(i,cr-n)]].pb(ma[mp(i,v-n)]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//////////cerr<<v<<' '<<i-n<<' '<<cr<<' '<<i-n<<'\\n';\n\t\t\t\t\t\tT[ma[mp(cr,i-n)]].pb(ma[mp(v,i-n)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(FF.begin(),FF.end());\n\t\tFF.erase(unique(FF.begin(),FF.end()),FF.end());\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tfor(int j=0;j<T[i].size();j++)\n\t\t\t{\n\t\t\t\t//cerr<<\"T2 : \"<<i<<' '<<T[i][j]<<'\\n';\n\t\t\t\tindeg[T[i][j]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans2 = 1;\n\t\tvec.clear();\n\t\t\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tif(indeg[i]==0)\n\t\t\t{\n\t\t\t\tii tmp = calctree(i);\n\t\t\t\tans2 = mult(ans2,tmp.fi);\n\t\t\t\t//////cerr<<i<<' '<<tmp.fi<<' '<<tmp.se<<'\\n';\n\t\t\t\tvec.pb(tmp.se);\n\t\t\t}\n\t\t}\n\t\t\n\t\tr=0;\n\t\tfor(int i=0;i<vec.size();i++)\n\t\t{\n\t\t\tr+=vec[i];\n\t\t\tans2=mult(ans2,combi.ifact[vec[i]]);\n\t\t}\n\t\t\n\t\tans2=mult(ans2,combi.fact[r]);\n\t\n\t\tadd(ans,ans2);\n\t\tres = mult(res,ans);\n\t\tfor(int f=0;f<FF.size();f++)\n\t\t{\n\t\t\tint i=FF[f];\n\t\t\tT[i].clear();\n\t\t\tindeg[i]=0;\n\t\t}\n\t\t//cerr<<comp[z].size()<<' '<<ans<<'\\n';\n\t}\n\tcout<<res<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD = 1000000007;\nconst int MX = 200001;\n\nint N, par[MX], depth[MX], visit[MX], cyc[MX]; // parent, depth, visited, cycle\nint done[MX], sz[MX], num[MX];\nll fac[MX], in[MX], ans = 1;\nvi verts, edges, cy, adj1[MX];\nint nex = 1;\nvector<pii> cur, adj0[MX];\n\n// we need to create a separate tree for the edges relating to each other\n\n/////////// OK\nvoid dfs1(int ind, int pre) {\n    par[ind] = pre; visit[ind] = 1; verts.pb(ind);\n    for (pii i: adj0[ind]) if (!visit[i.f]) {\n        depth[i.f] = depth[ind]+1;\n        dfs1(i.f,ind);\n    }\n}\n\nvoid dfs2(int ind, int pre) {\n    int ii = 0; \n    while (adj0[ind][ii].f != pre) ii++;\n    //cout << \"HI \" << ind+1 << \" \" << pre+1 << \" \" << ii << \"\\n\";\n    for (pii x: adj0[ind]) if (x.f < pre) {\n        adj1[adj0[ind][ii].s].pb(x.s);\n        //cout << \"OH \" << x.f+1 << \" \" << ind+1 << \" \" << pre+1 << \"\\n\";\n    }\n    for (pii x: adj0[ind]) if (x.f != pre) dfs2(x.f,ind);\n}\n\n////////// OK\nll inv (ll b) {\n    ll p = MOD-2, ans = 1;\n    while (p) {\n        if (p&1) ans = (ans*b) % MOD;\n        b = (b*b) % MOD;\n        p /= 2;\n    }\n    return ans;\n}\n\n////////// OK\nll get(int x) {\n    if (done[x]) return sz[x];\n    sz[x] = done[x] = 1;\n    for (int i: adj1[x]) sz[x] += get(i);\n    return sz[x];\n}\n\nll process() {\n    ll ret = 1;\n    for (int i: edges) ret = (ret*in[get(i)]) % MOD;\n    return ret;\n}\n\n// account for a possible cycle?\n\nll test1() {\n    for (int i: edges) {\n        adj1[i].clear();\n        done[i] = 0;\n    }\n    F0R(i,cy.size()) {\n        int v = cy[i], ind = 0; \n        while (adj0[v][ind].f != cy[(i+1)%cy.size()]) ind++;\n        \n        for (pii j: adj0[v]) if (j.f < cy[(i+1)%cy.size()]) \n            adj1[adj0[v][ind].s].pb(j.s);\n            \n        for (pii j: adj0[v]) if (!cyc[j.f]) dfs2(j.f,v);\n    }\n    return process();\n}\n\nll test2() {\n    for (int i: edges) {\n        adj1[i].clear();\n        done[i] = 0;\n    }\n    F0R(i,cy.size()) {\n        int v = cy[i], ind = 0;\n        while (adj0[v][ind].f != cy[(i+cy.size()-1)%cy.size()]) ind++;\n        \n        for (pii j: adj0[v]) if (j.f < cy[(i+cy.size()-1)%cy.size()]) \n            adj1[adj0[v][ind].s].pb(j.s);\n        \n        for (pii j: adj0[v]) if (!cyc[j.f]) dfs2(j.f,v);\n    }\n    return process();\n}\n\n////////// OK\nvoid solve(int ind) {\n    cur.clear(), verts.clear(), edges.clear(), cy.clear(); \n    dfs1(ind,-1); \n    \n    for (int x: verts) for (pii y: adj0[x]) if (depth[x] < depth[y.f]) {\n        edges.pb(y.s);\n        if(par[y.f] != x) cur.pb({x,y.f});\n    }\n    \n    if (cur.size() != 1) { cout << 0; exit(0); }\n    while (cur[0].s != cur[0].f) { // elements of the cycle!\n        cy.pb(cur[0].s);\n        cyc[cur[0].s] = 1;\n        cur[0].s = par[cur[0].s];\n    }\n    cyc[cur[0].s] = 1;\n    cy.pb(cur[0].s);\n    \n    ll ret = (test2()+test1()) % MOD;\n    ans = (ans*ret) % MOD;\n}\n\n////////// OK\nvoid init() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin >> N;\n\tfac[0] = in[0] = 1;\n\tFOR(i,1,2*N+1) {\n\t    fac[i] = (i*fac[i-1]) % MOD;\n\t    in[i] = inv(i) % MOD;\n\t}\n\tans = fac[2*N];\n\tF0R(i,2*N) {\n\t    int x,y; cin >> x >> y; x--, y--;\n\t    adj0[x].pb({y+N,i});\n\t    adj0[y+N].pb({x,i});\n\t}\n}\n\n////////// OK\nint main() {\n    init();\n\tF0R(i,2*N) if (!visit[i]) solve(i);\n\tcout << ans;\n}\n\n// read!\n// ll vs. int!"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\n\nnamespace io {\n#define File(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n  const int SIZE = (1 << 21) + 1;\n  char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1;\n  inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);}\n  inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;}\n  inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();}\n  template<class T>\n  inline void read(T &x) {\n    char ch; int f = 1;\n    x = 0;\n    while(isspace(ch = getc()));\n    if(ch == '-') ch = getc(), f = -1;\n    do x = x * 10 + ch - '0'; while(isdigit(ch = getc()));\n    x *= f;\n  }\n  template<class T, class ...Args>\n  inline void read(T &x, Args&... args) {read(x); read(args...);}\n  template<class T>\n  inline void write(T x) {\n    static char stk[128];\n    int top = 0;\n    if(x == 0) {putc('0'); return;}\n    if(x < 0) putc('-'), x = -x;\n    while(x) stk[top++] = x % 10, x /= 10;\n    while(top) putc(stk[--top] + '0');\n  }\n  template<class T, class ...Args>\n  inline void write(T x, Args... args) {write(x); putc(' '); write(args...);}\n  inline void space() {putc(' ');}\n  inline void endl() {putc('\\n');}\n  struct _flush {~_flush() {flush();}} __flush;\n};\nusing io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc;\n\nconst int M = 1000000007;\ninline int add(int x, int y) {return x+y>=M ? x+y-M : x+y;}\ntemplate<class ...Args> inline int add(int x, int y, Args... args) {return add(add(x, y), args...);}\ninline int sub(int x, int y) {return x-y<0 ? x-y+M : x-y;}\ninline int mul(int x, int y) {return 1LL * x * y % M;}\ntemplate<class ...Args> inline int mul(int x, int y, Args... args) {return mul(mul(x, y), args...);}\ninline void inc(int &x, int y=1) {x += y; if(x >= M) x -= M;}\ninline void dec(int &x, int y=1) {x -= y; if(x < 0) x += M;}\ninline int power(int x, int y){\n  int res = 1;\n  for(; y; y>>=1, x = mul(x, x)) if(y & 1) res = mul(res, x);\n  return res;\n}\ninline int inv(int x){return power(x, M - 2);}\n\nconst int N = 400005;\nvector<int> G[N];\nint tfa[N];\nint indeg[N], siz[N];\nvector<int> circ, node;\n\nnamespace DSU {\nint fa[N], rk[N];\nbool circuit[N];\nint find(int x) {\n  if (!fa[x]) return x;\n  return fa[x] = find(fa[x]);\n}\nbool merge(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) {\n    if (circuit[x]) return false;\n    circuit[x] = true;\n    return true;\n  }\n  if (rk[x] < rk[y]) swap(x, y);\n  fa[y] = x, rk[x] += rk[x] == rk[y];\n  circuit[x] = circuit[x] || circuit[y];\n  return true;\n}\n}; // namespace DSU\n\nint fac[N];//, ifac[N];\nvoid pre(int n) {\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n//  ifac[n] = inv(fac[n]);\n//  for (int i = n - 1; i >= 0; --i) ifac[i] = mul(ifac[i + 1], i + 1);\n}\n\nbool vis[N];\nint from[N];\n\nvoid dfs(int x) {\n  vis[x] = true;\n  node.push_back(x);\n  for (int v : G[x]) {\n    if (v == from[x]) continue;\n    if (vis[v]) {\n      if (!circ.empty()) continue;\n      circ.push_back(v);\n      circ.push_back(x);\n      int t = from[x];\n      while (t != v) {\n        circ.push_back(t);\n        t = from[t];\n      }\n      continue;\n    }\n    from[v] = x;\n    dfs(v);\n  }\n}\nint fa[N];\nvoid dfs2(int x) {\n  for (int v : G[x]) {\n    if (fa[v]) continue;\n    fa[v] = x;\n    dfs2(v);\n  }\n}\nint topo_cnt() {\n  int res = 1;\n  queue<int> q;\n  for (int x : node) {\n    siz[x] = 1;\n    if (!indeg[x])\n      q.push(x);\n  }\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    res = mul(res, inv(siz[x]));\n    if (!tfa[x]) continue;\n    indeg[tfa[x]]--;\n    siz[tfa[x]] += siz[x];\n    if (indeg[tfa[x]] == 0)\n      q.push(tfa[x]);\n  }\n  return res;\n}\n\nint main() {\n//  File(\"4370\");\n  int n;\n  read(n);\n  pre(n * 2);\n  for (int i = 1; i <= n * 2; ++i) {\n    int x, y;\n    read(x, y);\n    G[x].push_back(n + y); G[n + y].push_back(x);\n    if (!DSU::merge(x, n + y)) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  for (int i = 1; i <= 2 * n; ++i)\n    sort(G[i].begin(), G[i].end());\n  int res = 1;\n  for (int i = 1; i <= n * 2; ++i) {\n    int now = 0;\n    if (!vis[i]) {\n      node.clear();\n      circ.clear();\n      dfs(i);\n      int L = circ.size();\n      fa[circ[0]] = circ[L - 1];\n      for (int i = 1; i < L; ++i)\n        fa[circ[i]] = circ[i - 1];\n      for (int x : circ)\n        dfs2(x);\n      for (int x : node) {\n        for (int v : G[x]) {\n          if (v < fa[x])\n            tfa[v] = x, ++indeg[x];\n          else break;\n        }\n      }\n      now += topo_cnt();\n      for (int x : node)\n        tfa[x] = 0, indeg[x] = 0;\n      fa[circ[L - 1]] = circ[0];\n      for (int i = 0; i < L - 1; ++i)\n        fa[circ[i]] = circ[i + 1];\n      for (int x : node) {\n        for (int v : G[x])\n          if (v < fa[x]) tfa[v] = x, ++indeg[x];\n          else break;\n      }\n      now += topo_cnt();\n      now %= M;\n//      printf(\"now = %d ways %d\\n\", now, mul(now, fac[node.size()]));\n      res = mul(res, mul(now, fac[node.size()]));\n    }\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\n#define iter(i, n) for (int i = 1; i <= n; ++i)\n#define iter_r(i, n) for (int i = n; i >= 1; --i)\n\nconst int mod = 1e9 + 7;\nconst int N = 2e5;\nconst int NR = N + 10;\n\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n\nvector<int> px[NR], py[NR], son[NR], e[NR], ring, all;\nbool ich[NR], vis[NR], inq[NR];\nint sz[NR], fac[NR],  inv[NR], x[NR], y[NR], V, E, n, fa[NR];\npii q[NR];\n\nint pr(int a, int z) {\n\tint s = 1;\n\twhile (z > 0) {\n\t\tif (z % 2 == 1) s = 1ll * s * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tz /= 2;\n\t}\n\treturn s;\n}\n\nint binom(int n, int k) {\n\tassert(n >= k);\n\treturn 1ll * fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nint calc(int x) {\n\tsz[x] = 0;\n\tint res = 1;\n\tfor (int v : son[x]) {\n\t\tint tmp = calc(v);\n\t\tres = 1ll * res * tmp % mod * binom(sz[x] + sz[v], sz[x]) % mod;\n\t\tsz[x] += sz[v];\n\t}\n\t++sz[x];\n\treturn res;\n}\n\nint solve(bool d) {\n//\tprintf(\"!Begin %d\\n\", d);\n\tfor (int i : all) ich[i] = 0, inq[i] = 0, son[i].clear();\n\n\tassert(!ring.empty());\n\tint cur = 0, h, t, res = 1;\n\tq[h = t = 1] = pii(ring[0], d); inq[ring[0]] = true;\n\twhile (h <= t) {\n\t\tpii tmp = q[h++]; int i = tmp.fi;// printf(\"d %d %d\\n\", i, tmp.se);\n\t\tif (tmp.se) {\n\t\t\tfor (int j : py[y[i]]) {\n\t\t\t\tif (!inq[j]) q[++t] = pii(j, 0); inq[j] = true;\n\t\t\t\tif (x[j] < x[i]) son[i].push_back(j), ich[j] = true;//, printf(\"t %d %d\\n\", j, i);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int j : px[x[i]]) {\n\t\t\t\tif (!inq[j]) q[++t] = pii(j, 1); inq[j] = true;\n\t\t\t\tif (y[j] < y[i]) son[i].push_back(j), ich[j] = true;//, printf(\"t %d %d\\n\", j, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i : all) if (!ich[i]) {\n\t\tint tmp = calc(i);\n\t\tres = 1ll * res * binom(cur + sz[i], cur) % mod * tmp % mod; cur += sz[i];\n\t//\tprintf(\"!!%d %d\\n\", i, sz[i]);\n\t}\n\n\t//printf(\"!End %d %d %d %d\\n\", d, res, cur, (int) all.size());\n\treturn res;\n}\n\nvoid dfs(int x) {\n\tvis[x] = true;\n\t++V;\n\tall.push_back(x);\n\tfor (int v : e[x]) {\n \t\t++E;\n\t\tif (!vis[v]) fa[v] = x, dfs(v);\n\t\telse if (v != fa[x] && ring.empty()) {\n\t\t\tfor (int _x = x; ; _x = fa[_x]) {\n\t\t\t\tring.push_back(_x);\n\n\t\t\t\t//printf(\"!%d %d\\n\", _x, v);\n\n\t\t\t\t//if (_x == 0) break;\n\n\t\t\t\tif (_x == v) break;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool cmpX(int i, int j) { return x[i] < x[j]; }\nbool cmpY(int i, int j) { return y[i] < y[j]; }\n\nint main() {\n\t//freopen(\"83F.in\", \"r\", stdin);\n\tscanf(\"%d\", &n); n *= 2; fac[0] = inv[0] = 1;\n\titer(i, N) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[N] = pr(fac[N], mod - 2);\n\titer_r(i, N - 1) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n\titer(i, n) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\tpx[x[i]].push_back(i);\n\t\tpy[y[i]].push_back(i);\n\t}\n\titer(i, n) {\n\t\tsort(px[i].begin(), px[i].end(), cmpY);\n\t\tint l = px[i].size();\n\t\tfor (int j = 0; j < l - 1; ++j) {\n\t\t\tint u = px[i][j], v = px[i][j + 1];\n\t\t\te[u].push_back(v); e[v].push_back(u);\n\t\t//\tprintf(\"e %d %d\\n\", u, v);\n\t\t}\n\t}\n\n\titer(i, n) {\n\t\tsort(py[i].begin(), py[i].end(), cmpX);\n\t\tint l = py[i].size();\n\t\tfor (int j = 0; j < l - 1; ++j) {\n\t\t\tint u = py[i][j], v = py[i][j + 1];\n\t\t\te[u].push_back(v); e[v].push_back(u);\n\t\t//\tprintf(\"e %d %d\\n\", u, v);\n\t\t}\n\t}\n\n\tint ans = 1, cur = 0;\n\n\titer(s, n) if (!vis[s]) {\n\t\tV = 0; E = 0; ring.clear(); all.clear();\n\t\tdfs(s);\n\t\tif (2 * V != E) { puts(\"0\"); return 0; }\n\t\tint tmp = (solve(0) + solve(1)) % mod, t = all.size();\n\t\tans = 1ll * ans * binom(cur + t, cur) % mod * tmp % mod;\n\t\tcur += t;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\nconstexpr int MOD = 1e9 + 7;\n\nstruct chain_t {\n    mint<MOD> cnt;\n    int size;\n    chain_t() : cnt(1), size(0) {}\n    chain_t(mint<MOD> cnt_, int size_) : cnt(cnt_), size(size_) {}\n    chain_t operator * (chain_t other) const {\n        int next_size = this->size + other.size;\n        mint<MOD> next_cnt = this->cnt * other.cnt * choose<MOD>(next_size, size);\n        return chain_t(next_cnt, next_size);\n    }\n};\n\nstruct unsat {};\n\nclass solver {\n    int n;\n    vector<int> xs, ys;\n\n    static constexpr char OPENED = 'O';\n    static constexpr char CLOSED = 'C';\n    vector<map<int, int> > row_none, col_none;  // : z -> (z -> i)\n    vector<map<int, int> > row_opened, col_opened;  // : z -> (z -> i)\n    vector<map<int, int> > row_closed, col_closed;  // : z -> (z -> i)\n    vector<int> row_used, col_used;  // : z -> i\n    vector<char> state;\n    vector<chain_t> chain;\n    vector<tuple<char, int, int> > history;  // only for use_generic()\n\npublic:\n    solver(int n_, vector<int> const & xs_, vector<int> const & ys_)\n             : n(n_), xs(xs_), ys(ys_) {\n        row_none.resize(n);\n        col_none.resize(n);\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        }\n        row_opened.resize(n);\n        col_opened.resize(n);\n        row_closed.resize(n);\n        col_closed.resize(n);\n        row_used.resize(n, -1);\n        col_used.resize(n, -1);\n        state.resize(2 * n);\n        chain.resize(2 * n);\n    }\n\nprivate:\n    void set_state(int i, char next_state) {\n        int y = ys[i];\n        int x = xs[i];\n        if (not state[i]) {\n            row_none[y].erase(x);\n            col_none[x].erase(y);\n        } else if (state[i] == OPENED) {\n            row_opened[y].erase(x);\n            col_opened[x].erase(y);\n        } else if (state[i] == CLOSED) {\n            row_closed[y].erase(x);\n            col_closed[x].erase(y);\n        } else {\n            assert (false);\n        }\n        state[i] = next_state;\n        if (not state[i]) {\n            row_none[y][x] = i;\n            col_none[x][y] = i;\n        } else if (state[i] == OPENED) {\n            row_opened[y][x] = i;\n            col_opened[x][y] = i;\n        } else if (state[i] == CLOSED) {\n            row_closed[y][x] = i;\n            col_closed[x][y] = i;\n        }\n    }\n\n    chain_t use_generic(int i, bool is_row) {\n        int y = ys[i];\n        int x = xs[i];\n\n// cerr << \"use \" << y << \" \" << x << \" \" << (is_row ? \"<\" : \"v\") << endl;\n\n        // change the state\n        int & used = (is_row ? row_used[y] : col_used[x]);\n        assert (used == -1);\n        history.emplace_back('u', i, is_row);\n        used = i;\n\n        // update the graph\n        assert (not state[i]);\n        history.emplace_back('s', i, state[i]);\n        set_state(i, OPENED);\n\n        // run dp\n        chain[i] = chain_t();\n        auto & opened = (is_row ? row_opened[y] : col_opened[x]);\n        auto last = opened.find(is_row ? x : y);\n        vector<int> indices;\n        for (auto it = opened.begin(); it != last; ++ it) {\n            indices.push_back(it->second);\n        }\n        for (int j : indices) {\n// cerr << \"j = \" << j << \" : y = \" << ys[j] << \", x = \" << xs[j] << \" : state = \" << state[j] << endl;\n            history.emplace_back('s', j, state[j]);\n            set_state(j, CLOSED);\n            chain[i] = chain[i] * chain[j];\n        }\n        chain[i].size += 1;\n\n        // return chain\n        chain_t acc = chain_t();\n        if (is_closable(i)) {\n            history.emplace_back('s', i, state[i]);\n            set_state(i, CLOSED);\n            acc = acc * chain[i];\n\n            auto & opened = (is_row ? col_opened[x] : row_opened[y]);\n            vector<int> indices;\n            for (auto it : opened) {\n                int j = it.second;\n                if (is_closable(j)) {\n                    indices.push_back(j);\n                }\n            }\n            for (int j : indices) {\n                history.emplace_back('s', j, state[j]);\n                set_state(j, CLOSED);\n                acc = acc * chain[j];\n            }\n        }\n        return acc;\n    }\n\n    bool is_closable(int i) {\n        assert (state[i] == OPENED);\n        int y = ys[i];\n        int x = xs[i];\n        return row_none[y].lower_bound(x) == row_none[y].end() and col_none[x].lower_bound(y) == col_none[x].end();\n    }\n\n    chain_t go_row(int y) {\n        if (row_used[y] != -1) return chain_t();\n        if (row_none[y].empty()) {\n            throw unsat {};\n        } else if (row_none[y].size() == 1) {\n            int x, i; tie(x, i) = *row_none[y].begin();\n            chain_t c = use_generic(i, true);\n            return c * go_col(x);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t go_col(int x) {\n        if (col_used[x] != -1) return chain_t();\n        if (col_none[x].empty()) {\n            throw unsat {};\n        } else if (col_none[x].size() == 1) {\n            int y, i; tie(y, i) = *col_none[x].begin();\n            chain_t c = use_generic(i, false);\n            return c * go_row(y);\n        } else {\n            return chain_t();  // nop\n        }\n    }\n\n    chain_t propagate_units() {\n        chain_t acc;\n        REP (y, n) acc = acc * go_row(y);\n        REP (x, n) acc = acc * go_col(x);\n        return acc;\n    }\n\n    vector<int> get_rects() {\n        vector<int> rects;\n        REP (i, 2 * n) {\n            int y = ys[i];\n            int x = xs[i];\n            if (row_used[y] == -1 and col_used[x] == -1) {\n                assert (not state[i]);\n                if (row_none[y].begin()->first == x and col_none[x].begin()->first == y) {\n                    rects.push_back(i);\n                }\n            }\n        }\n        return rects;\n    }\n\n    void save_history() {\n        history.clear();\n    }\n    void load_history() {\n        while (not history.empty()) {\n            char type; int i, arg; tie(type, i, arg) = history.back();\n            history.pop_back();\n            int y = ys[i];\n            int x = xs[i];\n\n            if (type == 'u') {\n                int & used = (arg ? row_used[y] : col_used[x]);\n                used = -1;\n            } else if (type == 's') {\n                set_state(i, arg);\n            } else {\n                assert (false);\n            }\n        }\n    }\n\n    void debug_print() const {\n        REP_R (y, n) {\n            REP (x, n) {\n                char c;\n                if (row_none[y].count(x)) {\n                    c = '*';\n                } else if (row_opened[y].count(x) or row_closed[y].count(x)) {\n                    c = '?';\n                    int i = row_used[y];\n                    if (i != -1 and y == ys[i] and x == xs[i]) {\n                        c = '<';\n                    }\n                    int j = col_used[x];\n                    if (j != -1 and y == ys[j] and x == xs[j]) {\n                        assert (c == '?');\n                        c = 'v';\n                    }\n                    assert (c != '?');\n                } else {\n                    c = '.';\n                }\n                cerr << c;\n            }\n            cerr << endl;\n        }\n        REP (is_row, 2) {\n            cerr << \"---\" << endl;\n            REP (z, n) {\n                int i = (is_row ? row_used : col_used)[z];\n                char c = (i == -1 ? '-' : state[i]);\n                cerr << (is_row ? 'y' : 'x') << \" = \" << z << \" : state = \" << c;\n                if (c == OPENED) cerr << \" : dp = \" << chain[i].cnt.value << \" : size = \" << chain[i].size;\n                cerr << endl;\n            }\n        }\n        cerr << endl;\n    }\n\npublic:\n    mint<MOD> operator () () {\n        try {\n            chain_t acc = chain_t();\n            acc = acc * propagate_units();\n// debug_print();\n            vector<int> rects = get_rects();\n            for (int i : rects) {\n                if (state[i]) continue;\n                int y = ys[i];\n                int x = xs[i];\n                assert (row_used[y] == -1 and col_used[x] == -1);\n\n                save_history();\n                chain_t c1 = use_generic(i, false);\n                c1 = c1 * propagate_units();\n                load_history();\n                chain_t c2 = use_generic(i, true);\n                c2 = c2 * propagate_units();\n                assert (c1.size == c2.size);\n                chain_t c(c1.cnt + c2.cnt, c1.size);\n                acc = acc * c;\n            }\n            return acc.cnt;\n        } catch (unsat e) {\n            return 0;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<int> x(2 * n), y(2 * n);\n    REP (i, 2 * n) {\n        cin >> x[i] >> y[i];\n        -- x[i]; -- y[i];\n    }\n    cout << solver(n, x, y)().value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ad(x) (((x - 1) ^ 1) + 1)\n\ntypedef long long ll;\nconst int N = 200054, M = N * 2, mod = 1000000007;\n\nint n, E = 0, chksum;\nint inv[N];\nint to[M], first[N], next[M], deg[N];\nint p[N], Cycu, Cycv;\nint cnt = 0, o[N], id[N];\nbool used[N];\n\nvoid init() {\n\tint i;\n\tfor (inv[1] = 1, i = 2; i < N; ++i) inv[i] = ll(mod - mod / i) * inv[mod % i] % mod;\n}\n\ninline void addedge(int u, int v) {\n\tto[++E] = v, next[E] = first[u], first[u] = E, ++deg[u];\n\tto[++E] = u, next[E] = first[v], first[v] = E, ++deg[v];\n}\n\ninline void __builtin_deledge(int u, int v) {\n\tif (to[first[u]] == v) first[u] = next[first[u]];\n\telse for (int i = first[u]; i; i = next[i])\n\t\tif (to[next[i]] == v) {next[i] = next[next[i]]; return;}\n}\n\ninline void deledge(int u, int v) {__builtin_deledge(u, v), __builtin_deledge(v, u);}\n\nvoid dfs(int x, int px = 0) {\n\tint i, y; used[x] = true, chksum += 2 - deg[x];\n\to[++cnt] = x, id[x] = cnt;\n\tfor (i = first[x]; i; i = next[i])\n\t\tif (!used[y = to[i]]) dfs(y, x);\n\t\telse if ((y = to[i]) != px) Cycu = x, Cycv = y;\n}\n\nvoid dfs2(int x) {\n\tint i, y;\n\tfor (i = first[x]; i; i = next[i])\n\t\tif ((y = to[i]) != p[x]) p[y] = x, dfs2(y);\n}\n\nnamespace Topo {\n\tint p[N], fc[N], nc[N], prod;\n\n\tinline void link(int x, int px) {\n\t\tp[x] = px, nc[x] = fc[px], fc[px] = x;\n\t}\n\n\tint dfs(int x) {\n\t\tint y, sz = 1;\n\t\tfor (y = fc[x]; y; y = nc[y]) sz += dfs(y);\n\t\treturn prod = (ll)prod * inv[sz] % mod, sz;\n\t}\n\n\tint main() {\n\t\tint i, _; prod = 1;\n\t\tfor (_ = 1; _ <= cnt; ++_) i = o[_], p[i] = fc[i] = 0;\n\t\tfor (_ = 1; _ <= cnt; ++_) if (i = o[_], ::p[::p[i]] > i) link(i, ::p[i]);\n\t\tfor (_ = 1; _ <= cnt; ++_) if (!p[i = o[_]]) dfs(i);\n\t\treturn prod;\n\t}\n}\n\nint main() {\n\tint i, u, v, ans = 1, cur; init();\n\tscanf(\"%d\", &n);\n\tfor (i = n *= 2; i > 1; --i) ans = (ll)ans * i % mod;\n\tfor (i = 0; i < n; ++i) scanf(\"%d%d\", &u, &v), addedge(u, v + n / 2);\n\tfor (i = 1; i <= n; ++i) if (!used[i]) {\n\t\tif (cnt = 0, dfs(i), chksum) return putchar(48), putchar(10), 0;\n\t\tdeledge(Cycu, Cycv);\n\t\tp[Cycu] = Cycv, dfs2(Cycu), cur = Topo::main();\n\t\tp[Cycv] = Cycu, dfs2(Cycv), cur += Topo::main();\n\t\tans = (ll)ans * cur % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MX=200005,md=1000000007;\nint n,f,a,b,c,s[MX],stk[MX],stc,w[MX],vis[MX];\nint ans=1,res;\nstruct edge{int t,nxt,w;}e[MX<<1];int hed[MX],ec;\nvoid ade(int x,int t,int w){e[++ec]=(edge){t,hed[x],w},hed[x]=ec;}\n#define FE(i,k) for(int i=hed[k];i;i=e[i].nxt)\n#define v e[i].t\ninline int pw(int x,int y){\n\tint a=1;\n\twhile(y){\n\t\tif(y&1)a=(LL)a*x%md;\n\t\tx=(LL)x*x%md,y>>=1;\n\t}\n\treturn a;\t\n}\n#define inv(x) pw(x,md-2)\nvoid dfs1(int k, int fa){\n\tvis[k]=2,stk[++stc]=k;\n\tFE(i,k)if(v!=fa){\n\t\tif(vis[v]==2){\n\t\t\ta=k,b=v,c=e[i].w;\n\t\t\tint t=stc;\n\t\t\tdo{\n\t\t\t\t--t;\n\t\t\t\tif(w[t]>c)a=stk[t],b=stk[t+1],c=w[t];\n\t\t\t}while(stk[t]!=v);\n\t\t\t++f;\n\t\t}else if(!vis[v])w[stc]=e[i].w,dfs1(v,k);\n\t}\n\tvis[k]=1,--stc;\n}\nvoid dfs2(int k,int fa,int w) {\n\ts[k]=1;\n\tFE(i,k)if(v!=fa&&v!=a&&(k!=a||v!=b)){\n\t\tdfs2(v,k,e[i].w);\n\t\tif(e[i].w<w)s[k]+=s[v];\n\t}\n\tres=(LL)res*inv(s[k])%md;\n}\nint main(){\n\tint i,x,y,k;\n\tcin>>n;\n\tfor(i=1;i<=n*2;i++)cin>>x>>y,ade(x,y+n,x+y),ade(y+n,x,x+y);\n\tn<<=1;\n\tfor(i=1;i<=n;i++)ans=(LL)ans*i%md;\n\tfor(i=1;i<=n;i++)if(!vis[i]){\n\t\tf=0,dfs1(i,0);\n\t\tif(f!=1){ans=0;break;}\n\t\tres=1,dfs2(a,0,c);\n\t\tk=res;\n\t\tswap(a,b);\n\t\tres=1,dfs2(a,0,c);\n\t\tans=(LL)ans*(k+res)%md;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,fa[SZ]; Edg\nll fac[SZ],rfac[SZ];\nconst int MOD=1e9+7;\nnamespace Topo\n{\nEdg\nbool ro[SZ];\nint sz[SZ];\nll wo(int x)\n{\n\tsz[x]=0; ll ans=1;\n\tfor esb(x,e,b)\n\t{\n\t\tans*=wo(b); ans%=MOD;\n\t\tsz[x]+=sz[b];\n\t\tans=ans*fac[sz[x]]%MOD*\n\t\trfac[sz[b]]%MOD*rfac[sz[x]-sz[b]]%MOD;\n\t}\n\t++sz[x]; return ans;\n}\n}\nbool vis[SZ];\nvector<int> cm,cyc;\nint edg=0,cx,cyy,ys[SZ];\nvoid dfs(int x)\n{\n\tvis[x]=1; cm.pb(x);\n\tfor esb(x,e,b) ++edg;\n\tfor esb(x,e,b) if(!vis[b])\n\t{\n\t\tfa[b]=x; dfs(b);\n\t}\n\telse\n\t{\n\t\tif(b!=fa[x]) cx=x,cyy=b;\n\t}\n}\nbool cy[SZ]; int ff[SZ];\nvoid d2(int x,int f=0)\n{\n\tfor esb(x,e,b) if(b!=f&&!cy[b])\n\t{\n\t\tff[b]=x; d2(b,x);\n\t}\n}\nint vv[SZ],pp=0;\nll qp(ll a,ll b)\n{\n\tll x=1;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<SZ;++i) fac[i]=fac[i-1]*i%MOD;\n\trfac[SZ-1]=qp(fac[SZ-1],MOD-2);\n\tfor(int i=SZ-1;i>=1;--i)\n\t\trfac[i-1]=rfac[i]*i%MOD;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n+n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadde(a,b+n);\n\t}\n\tll ans=1; int ss=0;\n\tfor(int i=1;i<=n+n;++i) if(!vis[i])\n\t{\n\t\tcm.clear(); cyc.clear(); fa[i]=0; edg=0; dfs(i);\n\t\tif(edg!=cm.size()*2)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\t++pp;\n\t\tfor(int a=cx;a;a=fa[a]) vv[a]=pp;\n\t\tint rs=0; vector<int> ts;\n\t\tfor(int a=cyy;a;a=fa[a])\n\t\t{\n\t\t\tts.pb(a);\n\t\t\tif(vv[a]==pp) {rs=a; break;}\n\t\t}\n\t\tfor(int a=cx;a!=rs;a=fa[a])\n\t\t\tcyc.pb(a);\n\t\tfor(int i=int(ts.size())-1;i>=0;--i)\n\t\t\tcyc.pb(ts[i]);\n\t\tfor(auto s:cyc) cy[s]=1;\n\t\tfor(auto s:cyc) d2(s);\n\t\tfor(auto g:cm) if(!cy[g])\n\t\t\tys[g]=ff[g];\n\t\tll a1=1,a2=1;\n\t\tfor(int i=0;i<cyc.size();++i)\n\t\t\tys[cyc[i]]=cyc[(i+1)%cyc.size()];\n\t\tfor(auto s:cm) Topo::fst[s]=0,Topo::ro[s]=1;\n\t\tfor(auto x:cm)\n\t\t\tfor esb(x,e,b) if(b<ys[x])\n\t\t\t\tTopo::ad_de(x,b),Topo::ro[b]=0;\n\t\tint sp;\n\t\tsp=0;\n\t\tfor(auto x:cm)\n\t\t\tif(Topo::ro[x])\n\t\t\t{\n\t\t\t\ta1=a1*Topo::wo(x)%MOD;\n\t\t\t\tint s=Topo::sz[x]; sp+=s;\n\t\t\t\ta1=a1*fac[sp]%MOD*rfac[s]%MOD\n\t\t\t\t*rfac[sp-s]%MOD;\n\t\t\t}\n\t\tfor(int i=0;i<cyc.size();++i)\n\t\t\tys[cyc[(i+1)%cyc.size()]]=cyc[i];\n\t\tfor(auto s:cm) Topo::fst[s]=0,Topo::ro[s]=1;\n\t\tfor(auto x:cm)\n\t\t\tfor esb(x,e,b) if(b<ys[x])\n\t\t\t\tTopo::ad_de(x,b),Topo::ro[b]=0;\n\t\tsp=0;\n\t\tfor(auto x:cm)\n\t\t\tif(Topo::ro[x])\n\t\t\t{\n\t\t\t\ta2=a2*Topo::wo(x)%MOD;\n\t\t\t\tint s=Topo::sz[x]; sp+=s;\n\t\t\t\ta2=a2*fac[sp]%MOD*rfac[s]%MOD\n\t\t\t\t*rfac[sp-s]%MOD;\n\t\t\t}\n\t\tans=ans*(a1+a2)%MOD;\n\t\tint cs=cm.size(); ss+=cs;\n\t\tans=ans*fac[ss]%MOD*rfac[cs]%MOD*rfac[ss-cs]%MOD;\n\t}\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define next nxt\nusing namespace std;\nint fac[200010],nifac[200010],e[200010];\nint first[200010],next[200010],des[200010],w[200010];\nint size[200010],ans,f[200010],vn,en,ed;\nbool vis[200010];\nint tt,n;\nint C(int n,int m){return (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;}\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nvoid dfs(int s,int pre)\n{\n\tvis[s]=true;vn++;\n\tfor (int k=first[s];k;k=next[k])\n\t{\n\t\ten++;\n\t\tif (!vis[des[k]]) {e[des[k]]=k^1;dfs(des[k],s);}\n\t\telse if (des[k]!=pre) ed=k;\n\t}\n}\nvoid dp(int s,int e)\n{\n\tf[s]=1;size[s]=0;\n\tfor (int k=first[s];k;k=next[k]) if (k/2!=ed/2&&(k^1^e))\n\t{\n\t\tdp(des[k],k);\n\t\tif (w[k]>w[e]) ans=(long long)ans*nifac[size[des[k]]]%mo*f[des[k]]%mo;\n\t\telse f[s]=(long long)f[s]*f[des[k]]%mo*C(size[s]+=size[des[k]],size[des[k]])%mo;\n\t}\n\tsize[s]++;\n}\nint main()\n{\n\ttt=1;scanf(\"%d\",&n);n<<=1;\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);v+=n/2;\n\t\tdes[++tt]=v;next[tt]=first[u];first[u]=tt;\n\t\tdes[++tt]=u;next[tt]=first[v];first[v]=tt;\n\t\tw[tt]=w[tt^1]=u+v;\n\t}\n \n\tint all=fac[n];\n\tfor (int s=1;s<=n;s++) if (!vis[s])\n\t{\n\t\tvn=en=ed=0;dfs(s,0);en>>=1;\n\t\tif (vn!=en) {puts(\"0\");return 0;}\n\t\tint u=des[ed],v=des[ed^1];\n\t\tfor (;u!=v;u=des[e[u]]) if (w[e[u]]>w[ed]) ed=e[u];\n\t\tans=1;dp(des[ed],ed);\n\t\tint p1=(long long)ans*nifac[size[des[ed]]]%mo*f[des[ed]]%mo;\n\t\tans=1;dp(des[ed^1],ed);\n\t\tint p2=(long long)ans*nifac[size[des[ed^1]]]%mo*f[des[ed^1]]%mo;\n\t\tall=(long long)all*(p1+p2)%mo;\n\t}\n\tprintf(\"%d\\n\",all);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x){\n    char ch=getchar(),ob=0;x=0;\n    while(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 201000;\nstruct Edge {int v, nxt;} a[N*4];\nint head[N], Head[N], indeg[N];\nint sz[N], pr[N];\nbool vis[N];\nint n, _;\n\ninline void add(int x, int y, int*arr) {\n    a[++_].v = y, a[_].nxt = arr[x], arr[x] = _;\n}\n\nconst int p = 1e9+7;\nint fac[N], ifac[N], inv[N];\n\nint st[N], tp;\n#define FID(i) for(int id=1,i;i=st[id],id<=tp;++id)\n\nint X, Y;\nint et, pt;\n\nvoid bfs(int x, int las) {\n    vis[st[++tp] = x] = true, ++pt;\n    for(int i=head[x];i;++et,i=a[i].nxt)\n        if(!vis[a[i].v]) bfs(a[i].v, x);\n        else if(a[i].v != las) X = x, Y = a[i].v;\n}\n\nvoid tfs(int x, int las) {\n    for(int i=head[x];i;i=a[i].nxt)\n        if(a[i].v != las and a[i].v != X)\n            pr[a[i].v] = x, tfs(a[i].v, x);\n}\n\nvoid dfs(int x, int las) {\n    sz[x] = 1;\n    for(int i=Head[x];i;i=a[i].nxt)\n        if(a[i].v != las)\n            dfs(a[i].v, x), sz[x] += sz[a[i].v];\n}\n\nint solve() {\n    tfs(X, Y);\n    pr[X] = Y;\n    FID(i) Head[i] = indeg[i] = 0;\n    FID(x) for(int i=head[x];i;i=a[i].nxt)\n        if(a[i].v < pr[x]) add(x, a[i].v, Head), ++indeg[a[i].v];\n    FID(i) if(!indeg[i]) dfs(i, i);\n    int Ans = fac[pt];\n    FID(i) Ans = (ll)Ans * inv[sz[i]]%p;\n    FID(i) printf(\"%d \", i);\n    puts(\"\");\n\t return Ans;\n}\n\nint main() {\n    read(n);\n    for(int i=1,x,y;i<=(n<<1);++i) {\n        read(x), read(y), y += n;\n        add(x, y, head), add(y, x, head);\n    }\n    \n    n <<= 1;\n    fac[0] = fac[1] = inv[0] = inv[1] = ifac[0] = ifac[1] = 1;\n    for(int i=2;i<=n;++i) {\n        fac[i] = (ll)fac[i-1] * i%p;\n        inv[i] = (ll)(p-p/i) * inv[p%i]%p;\n        ifac[i] = (ll)ifac[i-1] * inv[i]%p;\n    }\n    \n    int Ans = fac[n];\n    for(int i=1;i<=n;++i)\n        if(!vis[i]) {\n            tp = pt = et = 0;\n\t\t\t\tbfs(i, i);\n            Ans = (ll)Ans * ifac[pt]%p;\n            if((pt << 1) != et) return puts(\"0\"), 0;\n            X ^= Y, Y ^= X, X ^= Y;\n            int res = solve();\n            X ^= Y, Y ^= X, X ^= Y;\n            res += solve();\n            Ans = (ll)Ans * res%p;\n        }\n    printf(\"%d\\n\", Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nconst int mod=1e9+7;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint qpow(int a,int b) {\n\tint ret=1;\n\twhile(b) {\n\t\tif(b&1) ret=1ll*ret*a%mod;\n\t\ta=1ll*a*a%mod,b>>=1;\n\t}\n\treturn ret;\n}\n\nint n,to[N<<1],ww[N<<1],nxt[N<<1],tt=1,fac[N],ifac[N],h[N],V,E,st[N],tp=0,fe[N],p,f[N],sz[N],coef;\nbool vis[N];\n\nvoid dfs1(int u,int ff) {\n\tvis[u]=1;++V;fe[u]=ff;\n\tfor(int i=h[u],v;v=to[i],i;i=nxt[i]) {\n\t\t++E;if(i==(ff^1)) continue;\n\t\tif(!vis[v]) dfs1(v,i);\n\t\telse if(!tp) {\n\t\t\tint x=u;st[tp=1]=i;\n\t\t\twhile(x!=v) st[++tp]=fe[x],x=to[fe[x]^1];\n\t\t}\n\t}\n}\n\nint C(int n,int m) {\n\tif(m<0||n<m) return 0;\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nvoid dfs2(int u,int ff) {\n\tsz[u]=0;f[u]=1;\n\tfor(int i=h[u],v;v=to[i],i;i=nxt[i])\n\t\tif((i^ff^1)&&(i>>1)!=(p>>1)) {\n\t\t\tdfs2(v,i);\n\t\t\tif(ww[ff]<ww[i]) coef=1ll*coef*ifac[sz[v]]%mod*f[v]%mod;\n\t\t\telse sz[u]+=sz[v],f[u]=1ll*f[u]*f[v]%mod*C(sz[u],sz[v])%mod;\n\t\t}\n\t++sz[u];\n}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1,u,v;i<=n+n;i++) {\n\t\tu=gi(),v=gi()+n;\n\t\tto[++tt]=v,ww[tt]=u+v,nxt[tt]=h[u],h[u]=tt;\n\t\tto[++tt]=u,ww[tt]=u+v,nxt[tt]=h[v],h[v]=tt;\n\t}\n\tfac[0]=1;for(int i=1;i<N;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[N-1]=qpow(fac[N-1],mod-2);\n\tfor(int i=N-1;i;i--) ifac[i-1]=1ll*ifac[i]*i%mod;\n\tint ans=fac[n+n];\n\tfor(int i=1,sum;i<=n+n;i++)\n\t\tif(!vis[i]) {\n\t\t\tV=E=tp=p=sum=0,dfs1(i,0);\n\t\t\tif(E/2!=V) return cout<<0,0;\n\t\t\tfor(int j=1;j<=tp;j++) if((!p)||ww[st[j]]>ww[p]) p=st[j];\n\t\t\tcoef=1,dfs2(to[p],p),sum=(sum+1ll*coef*f[to[p]]%mod*ifac[sz[to[p]]])%mod;\n\t\t\tcoef=1,dfs2(to[p^1],p),sum=(sum+1ll*coef*f[to[p^1]]%mod*ifac[sz[to[p^1]]])%mod;\n\t\t\tans=1ll*ans*sum%mod;\n\t\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define P 1000000007\n\nint n;\nvector <int> ve[210000], ve2[210000], vv[210000], S;\nint ans = 1;\nint fac[210000];\nbool used[210000];\nint fa[210000], fa_val[210000], dp[210000], size[210000];\nint xx, yy, zz;\nint CC = 0;\n\nvoid dfs(int x) {\n\tused[x] = true;\n\tS.push_back(x);\n\tfor (int i = 0; i < (int) ve[x].size(); i++)\n\t\tif (!used[ve[x][i]])\n\t\t\tdfs(ve[x][i]);\n}\n\nvoid dfs2(int x, int fa) {\n\tused[x] = true;\n\tfor (int i = 0; i < (int) ve[x].size(); i++)\n\t\tif (used[ve[x][i]] && ve[x][i] != fa) {\n\t\t\txx = x;\n\t\t\tyy = ve[x][i];\n\t\t\tzz = ve2[x][i];\n\t\t}else if (!used[ve[x][i]]) {\n\t\t\tdfs2(ve[x][i], x);\n\t\t}\n}\n\nvoid dfs3(int x, int f, int val) {\n\tfa[x] = f;\n\tfa_val[x] = val;\n\tused[x] = true;\n\tfor (int i = 0; i < (int) ve[x].size(); i++) {\n\t\tif ((xx == x && ve[x][i] == yy) || (x == yy && ve[x][i] == xx))\n\t\t\tcontinue;\n\t\tif (!used[ve[x][i]]) {\n\t\t\tdfs3(ve[x][i], x, ve2[x][i]);\n\t\t}\n\t}\n}\n\nint Pow(int x, int y) {\n\tint ans = 1;\n\tfor (int i = 1; i <= y; i *= 2, x = 1LL * x * x % P)\n\t\tif (i & y)\n\t\t\tans = 1LL * ans * x % P;\n\treturn ans;\n}\n\nint C(int x, int y) {\n\treturn 1LL * fac[x] * Pow(1LL * fac[y] * fac[x - y] % P, P - 2) % P;\n}\n\nvoid dfs4(int x) {\n\tdp[x] = 1;\n\tsize[x] = 0;\n\tfor (int i = 0; i < (int) vv[x].size(); i++) {\n\t\t// printf(\"! %d %d\\n\", x, vv[x][i]);\n\t\tdfs4(vv[x][i]);\n\t\tdp[x] = 1LL * dp[x] * C(size[x] + size[vv[x][i]], size[vv[x][i]]) % P * dp[vv[x][i]] % P;\n\t\tsize[x] += size[vv[x][i]];\n\t}\n\tsize[x] += 1;\n}\n\nint calc(int x) {\n\tS.clear();\n\tdfs(x);\n\tint count = 0;\n\tfor (int i = 0; i < (int) S.size(); i++)\n\t\tcount += ve[S[i]].size();\n\tif (count != S.size() * 2)\n\t\treturn 0;\n\tint ans = 0;\n\tfor (int i = 0; i < (int) S.size(); i++)\n\t\tused[S[i]] = false;\n\tdfs2(x, 0);\n\n\tfor (int i = 0; i < (int) S.size(); i++) {\n\t\tused[S[i]] = false;\n\t\tvv[S[i]].clear();\n\t}\n\tvv[0].clear();\n\n\tdfs3(xx, yy, zz);\n\tfor (int i = 0; i < (int) S.size(); i++) {\n\t\tif (fa_val[fa[S[i]]] > fa_val[S[i]])\n\t\t\tvv[fa[S[i]]].push_back(S[i]);\n\t\telse\n\t\t\tvv[0].push_back(S[i]);\n\t}\n\n\tdfs4(0);\n\n\tans = (ans + dp[0]) % P;\n\n\tfor (int i = 0; i < (int) S.size(); i++) {\n\t\tused[S[i]] = false;\n\t\tvv[S[i]].clear();\n\t}\n\tvv[0].clear();\n\n\tdfs3(yy, xx, zz);\n\tfor (int i = 0; i < (int) S.size(); i++) {\n\t\tif (fa_val[fa[S[i]]] > fa_val[S[i]])\n\t\t\tvv[fa[S[i]]].push_back(S[i]);\n\t\telse\n\t\t\tvv[0].push_back(S[i]);\n\t}\n\tdfs4(0);\n\n\tans = (ans + dp[0]) % P;\n\n\tCC += S.size();\n\treturn ans;\n}\n\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= 200000; i++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % P;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n * 2; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tve[x].push_back(y + n);\n\t\tve2[x].push_back(x + y);\n\t\tve[y + n].push_back(x);\n\t\tve2[y + n].push_back(x + y);\n\t}\n\tn *= 2;\n\tint pre_count = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (!used[i]) {\n\t\t\tans = 1LL * ans * calc(i) % P * C(CC, pre_count) % P;\n\t\t\tpre_count = CC;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "8\n6 2\n5 1\n6 8\n7 8\n6 5\n5 7\n4 3\n1 4\n7 6\n8 3\n2 8\n3 6\n3 2\n8 5\n1 5\n5 8"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\nconst int MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v; };\n\nint f[300000], fi[300000];\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n>>=1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint inv_mod(int x, int p) {\n\treturn pow_mod(x, p - 2, p);\n}\n\nint C(int x, int y) {\n\treturn (ll)f[x] * fi[y] % MOD * fi[x - y] % MOD;\n}\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint prod;\n\nint dfs(int u, vector<vector<int> >& G) {\n\tint tot = 0;\n\tfor (int v: G[u]) {\n\t\tint sz = dfs(v, G);\n\t\ttot += sz;\n\t\tprod = (ll)prod * C(tot, sz) % MOD;\n\t}\n\treturn tot + 1;\n}\n\nint calc(int N, int M, vector<int> a, vector<int> b, vector<int> dir) {\n\trep(i, N + M) if (dir[i] == -1) return 0;\n\tvector<int> unko(N + M);\n\trep(i, N + M) {\n\t\tif (dir[i] == 0) unko[a[i]]++;\n\t\tif (dir[i] == 1) unko[N + b[i]]++;\n\t}\n\trep(u, N + M) if (unko[u] != 1) return 0;\n\tvector<vector<i_i> > xs(N), ys(M);\n\trep(i, N + M) xs[a[i]].pb(i_i(b[i], i));\n\trep(i, N + M) ys[b[i]].pb(i_i(a[i], i));\n\tvector<vector<int> > G(N + M);\n\tvector<bool> root(N + M, true);\n\trep(k, N) {\n\t\tsort(xs[k].begin(), xs[k].end());\n\t\trep(l, xs[k].size()) {\n\t\t\tint i = xs[k][l].second;\n\t\t\tif (dir[i] == 0)\n\t\t\t\trep(_l, l)\n\t\t\t\t\tG[i].pb(xs[k][_l].second);\n\t\t}\n\t}\n\trep(k, N) {\n\t\tsort(ys[k].begin(), ys[k].end());\n\t\trep(l, ys[k].size()) {\n\t\t\tint i = ys[k][l].second;\n\t\t\tif (dir[i] == 1)\n\t\t\t\trep(_l, l)\n\t\t\t\tG[i].pb(ys[k][_l].second);\n\t\t}\n\t}\n\trep(u, N + M) for (int v: G[u]) root[v] = false;\n\tvector<int> to;\n\trep(u, N + M) if (root[u]) to.pb(u);\n\tG.pb(to);\n\tprod = 1;\n\tdfs(N + M, G);\n\treturn prod;\n}\n\nint solve(int N, int M, vector<int> a, vector<int> b) {\n\tif (N + M != a.size()) return 0;\n\tvector<vector<edge> > G(N + M);\n\trep(i, N + M) G[a[i]].pb(edge{i, N + b[i]}), G[N + b[i]].pb(edge{i, a[i]});\n\tvector<int> d(N + M);\n\trep(u, N + M) d[u] = G[u].size();\n\tqueue<int> q;\n\trep(u, N + M) if (d[u] == 1) q.push(u);\n\tvector<bool> exist(N + M, true);\n\tvector<int> dir(N + M, -1);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\texist[u] = false;\n\t\tint i;\n\t\tfor (edge e: G[u]) if (exist[e.v]) {\n\t\t\ti = e.i;\n\t\t\td[e.v]--;\n\t\t\tif (d[e.v] == 1) q.push(e.v);\n\t\t}\n\t\tdir[i] = (u >= N);\n\t}\n\tint i0 = -1;\n\trep(i, N * 2) if (dir[i] == -1) i0 = i;\n\tif (i0 == -1) return calc(N, M, a, b, dir);\n\tvector<int> dir0 = dir;\n\tint ans = 0;\n\trep(t, 2) {\n\t\tdir = dir0;\n\t\tint s;\n\t\tif (t == 0) s = a[i0], dir[i0] = 0;\n\t\tif (t == 1) s = N + b[i0], dir[i0] = 1;\n\t\tvector<bool> vis(N + M); vis[s] = true;\n\t\tqueue<int> q; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (edge e: G[u]) if (dir[e.i] == -1) {\n\t\t\t\tdir[e.i] = (e.v >= N);\n\t\t\t\tif (!vis[e.v]) {\n\t\t\t\t\tvis[e.v] = true;\n\t\t\t\t\tq.push(e.v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (ans + calc(N, M, a, b, dir)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tf[0] = fi[0] = 1;\n\tfor (int x = 1; x < 300000; x++) {\n\t\tf[x] = (ll)f[x - 1] * x % MOD;\n\t\tfi[x] = (ll)fi[x - 1] * inv_mod(x, MOD) % MOD;\n\t}\n\tint N; cin >> N;\n\tvector<int> a(N * 2), b(N * 2);\n\trep(i, N * 2) scanf(\"%d%d\", &a[i], &b[i]), a[i]--, b[i]--;\n\tunion_find uf(N * 2);\n\trep(i, N * 2) uf.unite(a[i], b[i] + N);\n\tvector<vector<int> > vv(N * 2);\n\trep(i, N * 2) vv[uf.find(a[i])].pb(i);\n\tint ans = 1;\n\tfor (vector<int> v: vv) if (!v.empty()) {\n\t\tvector<int> _a, _b;\n\t\tfor (int i: v) _a.pb(a[i]), _b.pb(b[i]);\n\t\tvector<int> A = _a, B = _b;\n\t\tsort(A.begin(), A.end());\n\t\tsort(B.begin(), B.end());\n\t\tA.erase(unique(A.begin(), A.end()), A.end());\n\t\tB.erase(unique(B.begin(), B.end()), B.end());\n\t\tfor (int& u: _a) u = lower_bound(A.begin(), A.end(), u) - A.begin();\n\t\tfor (int& u: _b) u = lower_bound(B.begin(), B.end(), u) - B.begin();\n\t\tans = (ll)ans * solve(A.size(), B.size(), _a, _b) % MOD;\n\t}\n\tint tot = 0;\n\trep(u, N * 2) if (uf.root(u)) {\n\t\ttot += uf.size(u);\n\t\tans = (ll)ans * C(tot, uf.size(u)) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nstruct Edge { int p, v, w; } e[MAXN << 1];\nint n, V, E, ans, e_cnt = 1, f[MAXN], hed[MAXN], siz[MAXN], par[MAXN], fac[MAXN], inv[MAXN], vis[MAXN];\n\ninline void Addedge(int x, int y, int w)\n{\n\te[++ e_cnt] = {y, hed[x], w}; hed[x] = e_cnt;\n\te[++ e_cnt] = {x, hed[y], w}; hed[y] = e_cnt;\n}\n\ninline int C(int x, int y)\n{\n\treturn 1LL * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\ninline void Dfs(int x)\n{\n\tvis[x] = 1, V ++;\n\tfor (int i = hed[x]; i; i = e[i].v, E ++)\n\t\tif (!vis[e[i].p])\n\t\t\tDfs(e[i].p);\n}\n\ninline void Dfs(int x, int p)\n{\n\tvis[x] = -1;\n\tfor (int i = hed[x]; i; i = e[i].v)\n\t\tif (i ^ p ^ 1)\n\t\t\tif (~vis[e[i].p])\n\t\t\t\tpar[e[i].p] = i, Dfs(e[i].p, i);\n\t\t\telse if (!E)\n\t\t\t{\n\t\t\t\tE = i;\n\t\t\t\tfor (int cur = x; cur ^ e[i].p; cur = e[par[cur] ^ 1].p)\n\t\t\t\t\tif (e[par[cur]].w > e[E].w)\n\t\t\t\t\t\tE = par[cur];\n\t\t\t}\n}\n\ninline void Dp(int x, int p)\n{\n\tsiz[x] = f[x] = 1;\n\tfor (int i = hed[x]; i; i = e[i].v)\n\t\tif ((i ^ p ^ 1) && (i ^ E) && (i ^ E ^ 1))\n\t\t{\n\t\t\tint y = e[i].p;\n\t\t\tDp(y, i);\n\t\t\tif (e[i].w > e[p].w)\n\t\t\t\tans = 1LL * f[y] * inv[siz[y]] % mod * ans % mod;\n\t\t\telse\n\t\t\t\tsiz[x] += siz[y], f[x] = 1LL * f[x] * f[y] % mod * C(siz[x] - 1, siz[y]) % mod;\n\t\t}\n\tif (p == E)\n\t\tans = 1LL * f[x] * inv[siz[x]] % mod * ans % mod;\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read() << 1, fac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2; i <= n; i ++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod, inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n\tfor (int i = 2; i <= n; i ++)\n\t\tinv[i] = 1LL * inv[i - 1] * inv[i] % mod;\n\tfor (int i = 1, x, y; i <= n; i ++)\n\t\tx = Read(), y = Read(), Addedge(x, y + (n >> 1), x + y);\n\tint ret = fac[n], cur = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tV = E = 0;\n\t\t\tDfs(i);\n\t\t\tif (V << 1 ^ E)\n\t\t\t\treturn puts(\"0\"), 0;\n\t\t\tE = 0;\n\t\t\tDfs(i, 0);\n\t\t\tans = 1;\n\t\t\tDp(e[E].p, E);\n\t\t\tcur = ans;\n\t\t\tans = 1;\n\t\t\tDp(e[E ^ 1].p, E);\n\t\t\tret = 1LL * ret * (cur + ans) % mod;\n\t\t}\n\treturn printf(\"%d\\n\", ret), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nllint fact[200005], fact_inv[200005];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 200005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 200005; i++){\n\t\tfact_inv[i] = modpow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint n;\nllint x[200005], y[200005];\nvector<llint> G[200005];\nUnionFind uf(200005);\nmap<llint, vector<llint> > mp;\nvector<llint> cmp[200005];\n\nbool used[200005];\nbool cycled[200005];\nbool pointed[200005];\nvector<llint> g[200005], g2[200005];\n\nvector<llint> cycle;\nint cycledfs(int v, int pre)\n{\n\tif(used[v]) return v;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == pre) continue;\n\t\tint res = cycledfs(G[v][i], v);\n\t\tif(res){\n\t\t\tcycle.push_back(v);\n\t\t\tcycled[v] = true;\n\t\t\tif(res == v) return 0;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid treedfs(int v, int pre)\n{\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == pre) continue;\n\t\tif(cycled[G[v][i]]) continue;\n\t\tg[G[v][i]].push_back(v);\n\t\ttreedfs(G[v][i], v);\n\t}\n}\n\nllint merge(llint a, llint b)\n{\n\treturn comb(a+b, b);\n}\n\nP cntdfs(llint v)\n{\n\t//cout << \"& \" << v << endl;\n\tllint len = 0, ret = 1;\n\tfor(int i = 0; i < g2[v].size(); i++){\n\t\tP res = cntdfs(g2[v][i]);\n\t\tret *= res.first, ret %= mod;\n\t\t//cout << \"/\" << len << \" \" << res.second << \" \" << merge(len, res.second) << endl;\n\t\tret *= merge(len, res.second), ret %= mod;\n\t\tlen += res.second;\n\t}\n\tlen++;\n\t//cout << ret << \" \" << len << endl;\n\treturn make_pair(ret, len);\n}\n\nllint calc2(llint c)\n{\n\tfor(int i = 0; i < cmp[c].size(); i++) g2[cmp[c][i]].clear();\n\tfor(int i = 0; i < cmp[c].size(); i++){\n\t\tint v = cmp[c][i];\n\t\tif(g[g[v][0]][0] > v) g2[g[v][0]].push_back(v);\n\t}\n\t\n\tfor(int i = 0; i < cmp[c].size(); i++){\n\t\tint v = cmp[c][i];\n\t\tfor(int j = 0; j < g2[v].size(); j++){\n\t\t\tpointed[g2[v][j]] = true;\n\t\t}\n\t}\n\t\n\t/*cout << \"@\" << endl;\n\tfor(int i = 0; i < cmp[c].size(); i++){\n\t\tint v = cmp[c][i];\n\t\tcout << v << \" : \";\n\t\tfor(int j = 0; j < g2[v].size(); j++){\n\t\t\tcout << g2[v][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tllint len = 0, ret = 1;\n\tfor(int i = 0; i < cmp[c].size(); i++){\n\t\tif(!pointed[cmp[c][i]]){\n\t\t\t//cout << \"# \" << cmp[c][i] << endl;\n\t\t\tP res = cntdfs(cmp[c][i]);\n\t\t\t//cout << res.first << \" \" << res.second << endl;\n\t\t\tret *= res.first, ret %= mod;\n\t\t\tret *= merge(len, res.second), ret %= mod;\n\t\t\tlen += res.second;\n\t\t\t//cout << ret << \" \" << len << endl;\n\t\t}\n\t}\n\t//cout << ret << endl;\n\treturn ret;\n}\n\nllint calc(llint c)\n{\n\tcycle.clear();\n\tcycledfs(cmp[c][0], -1);\n\tfor(int i = 0; i < cycle.size(); i++) treedfs(cycle[i], -1);\n\t\n\t/*cout << \"cycle\" << endl;\n\tfor(int i = 0; i < cycle.size(); i++) cout << cycle[i] << \" \"; cout << endl;*/\n\t\n\tllint ret = 0;\n\tint C = cycle.size();\n\tfor(int i = 0; i < C; i++) g[cycle[i]].push_back(cycle[(i+1)%C]);\n\t\n\t/*for(int i = 0; i < cmp[c].size(); i++){\n\t\tint v = cmp[c][i];\n\t\tcout << v << \" : \";\n\t\tfor(int j = 0; j < g[v].size(); j++){\n\t\t\tcout << g[v][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tret += calc2(c), ret %= mod;\n\t\n\tfor(int i = 0; i < C; i++) g[cycle[i]].clear();\n\tfor(int i = 0; i < C; i++) g[cycle[i]].push_back(cycle[(i-1+C)%C]);\n\t\n\t/*for(int i = 0; i < cmp[c].size(); i++){\n\t\tint v = cmp[c][i];\n\t\tcout << v << \" : \";\n\t\tfor(int j = 0; j < g[v].size(); j++){\n\t\t\tcout << g[v][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tret += calc2(c), ret %= mod;\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tmake_fact();\n\t\n\tcin >> n;\n\tfor(int i = 1; i <= 2*n; i++) cin >> x[i] >> y[i];\n\tfor(int i = 1; i <= 2*n; i++){\n\t\tG[x[i]].push_back(y[i]+n);\n\t\tG[y[i]+n].push_back(x[i]);\n\t\tuf.unite(x[i], y[i]+n);\n\t}\n\t\n\tfor(int i = 1; i <= 2*n; i++) mp[uf.root(i)].push_back(i);\n\tllint id = 0;\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tfor(int i = 0; i < it->second.size(); i++){\n\t\t\tcmp[id].push_back(it->second[i]);\n\t\t}\n\t\tid++;\n\t}\n\t\n\tfor(int i = 0; i < id; i++){\n\t\tllint e = 0;\n\t\tfor(int j = 0; j < cmp[i].size(); j++) e += G[cmp[i][j]].size();\n\t\tif(e/2 != cmp[i].size()){\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tllint ans = 1, len = 0;\n\tfor(int i = 0; i < id; i++){\n\t\t//cout << \"cmp = \" << i << endl;\n\t\tllint tmp = calc(i);\n\t\tans *= tmp, ans %= mod;\n\t\tans *= merge(len, cmp[i].size()), ans %= mod;\n\t\tlen += cmp[i].size();\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define mod 1000000007\n#define next nxt\n\nint n,x[N],y[N],z[N],next[N],p[N],h[N],g[N],s[N],cnt,cmt,cir;\nlong long fac[N],inv[N],f[N],ans;\n\nlong long C(int x,int y){\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\n\nlong long solve(int x,int pre){\n\tf[x]=1;s[x]=0;long long ans=1;\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (t/2!=pre/2&&t/2!=cir/2){\n\t\t\tans=ans*solve(y[t],t)%mod;\n\t\t\tif (z[t]>z[pre]) ans=ans*inv[s[y[t]]]%mod*f[y[t]]%mod;\n\t\t\telse s[x]+=s[y[t]],f[x]=f[x]*f[y[t]]%mod*C(s[x],s[y[t]])%mod;\n\t\t}\n\ts[x]++;return ans;\n}\n\nvoid travel(int x,int pre){\n\th[x]=true;cnt++;\n\tfor (int t=p[x];t;t=next[t],cmt++)\n\t\tif (!h[y[t]]) g[y[t]]=t,travel(y[t],t);\n\t\telse if (t/2!=pre/2) cir=t;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=2*n;i++){\n\t\tx[2*i]=y[2*i+1]=read();\n\t\ty[2*i]=x[2*i+1]=n+read();\n\t\tz[2*i]=z[2*i+1]=x[2*i]+y[2*i];\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t\tnext[2*i+1]=p[x[2*i+1]];p[x[2*i+1]]=2*i+1;\n\t}\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tfor (int i=2;i<N;i++) inv[i]=-(mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<N;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tans=fac[2*n];\n\tfor (int i=1;i<=2*n;i++)\n\t\tif (!h[i]){\n\t\t\tcnt=cmt=0;travel(i,0);\n\t\t\tif (cmt!=cnt*2) {printf(\"0\\n\");return 0;}\n\t\t\tfor (int u=y[cir],v=x[cir];u!=v;u=x[g[u]])\n\t\t\t\tif (z[g[u]]>z[cir]) cir=g[u];\n\t\t\tlong long tmp1=solve(y[cir],cir)*inv[s[y[cir]]]%mod*f[y[cir]]%mod;\n\t\t\tlong long tmp2=solve(x[cir],cir)*inv[s[x[cir]]]%mod*f[x[cir]]%mod;\n\t\t\tans=ans*(tmp1+tmp2)%mod;\n\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=200010;\nconst int mod=1000000007;\nint n,first[maxn],nxt[maxn<<1],to[maxn<<1],dis[maxn<<1],e;\nvoid Add(int u,int v,int w) {\n\tto[++e]=v;dis[e]=w;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;dis[e]=w;nxt[e]=first[v];first[v]=e;\n}\nint pa[maxn],siz[maxn],es[maxn],vis[maxn];\nint findset(int x) {return x==pa[x]?x:pa[x]=findset(pa[x]);}\nvoid GG() {puts(\"0\");exit(0);}\nint sta[maxn],cir[maxn],left[maxn],right[maxn],col[maxn],clo,top;\nvector<int> s,all;\nvoid dfs(int x,int la) {\n\tvis[x]=++clo;sta[++top]=x;\n\tfor(int i=first[x];i;i=nxt[i]) if((i-1)!=(la-1^1)){\n\t\tif(!vis[to[i]]) dfs(to[i],i);\n\t\telse if(vis[to[i]]<vis[x]) {\n\t\t\twhile(top) {\n\t\t\t\tint y=sta[top--];\n\t\t\t\tcir[y]=1;s.pb(y);\n\t\t\t\tif(to[i]==y) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(top) top--;\n}\nvoid dfsout(int x,int fa) {\n\tall.pb(x);\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa&&!cir[to[i]]) {\n\t\tcol[to[i]]=dis[i];\n\t\tdfsout(to[i],x);\n\t}\n}\nint fac[maxn],ifac[maxn],size[maxn];\nint C(int a,int b) {return (ll)fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nvector<int> G[maxn];\nint deg[maxn],f[maxn];\nvoid dp(int x) {\n\tf[x]=1;size[x]=0;\n\trep(i,0,G[x].size()-1) {\n\t\tdp(G[x][i]);\n\t\tf[x]=(ll)f[x]*f[G[x][i]]%mod;\n\t\tf[x]=(ll)f[x]*ifac[size[G[x][i]]]%mod;\n\t\tsize[x]+=size[G[x][i]];\n\t}\n\tf[x]=(ll)f[x]*fac[size[x]]%mod;\n\tsize[x]++;\n}\nint work() {\n\trep(j,0,all.size()-1) G[all[j]].clear(),deg[all[j]]=0;\n\trep(j,0,all.size()-1) {\n\t\tint x=all[j];\n\t\tfor(int i=first[x];i;i=nxt[i]) if(dis[i]<col[x]) G[x].pb(to[i]),deg[to[i]]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,0,all.size()-1) if(!deg[all[i]]) {\n\t\tdp(all[i]);\n\t\tans=(ll)ans*C(cur+size[all[i]],cur)%mod;\n\t\tans=(ll)ans*f[all[i]]%mod;\n\t\tcur+=size[all[i]];\n\t}\n\treturn ans;\n}\nint main() {\n\tn=read();\n\tifac[0]=ifac[1]=fac[0]=1;\n\trep(i,2,n*2) ifac[i]=(ll)(mod-mod/i)*ifac[mod%i]%mod;\n\trep(i,1,n*2) fac[i]=(ll)fac[i-1]*i%mod,ifac[i]=(ll)ifac[i-1]*ifac[i]%mod;\n\trep(i,1,n*2) pa[i]=i,siz[i]=1;\n\trep(i,1,n*2) {\n\t\tint x=read(),y=read(),w=x+y;\n\t\tAdd(x,y+n,w);\n\t\tx=findset(x);y=findset(y+n);\n\t\tif(x!=y) {pa[x]=y;siz[y]+=siz[x];es[y]+=es[x];}\n\t\tes[y]++;\n\t}\n\tint ans=1,cur=0;\n\trep(i,1,n*2) if(i==findset(i)) {\n\t\tif(siz[i]!=es[i]) GG();\n\t\ts.clear();all.clear();dfs(i,0);\n\t\trep(i,0,s.size()-1) {\n\t\t\tdfsout(s[i],0);\n\t\t\tint prev=(!i?s[s.size()-1]:s[i-1]);\n\t\t\tint nxtv=(i==s.size()-1?s[0]:s[i+1]);\n\t\t\tfor(int j=first[s[i]];j;j=nxt[j]) {\n\t\t\t\tif(to[j]==prev) left[s[i]]=dis[j];\n\t\t\t\tif(to[j]==nxtv) right[s[i]]=dis[j];\n\t\t\t}\n\t\t}\n\t\tans=(ll)ans*C(cur+all.size(),cur)%mod;\n\t\tcur+=all.size();\n\t\tint tmp=0;\n\t\trep(i,0,s.size()-1) col[s[i]]=left[s[i]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\trep(i,0,s.size()-1) col[s[i]]=right[s[i]];\n\t\t(tmp+=(ll)work()*ans)%=mod;\n\t\tans=tmp;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nchar buf[1 << 20], *p1, *p2;\n#define getchar() ((p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)\n\ntemplate<typename T>\nvoid read(T &x) \n{\n\tx = 0;\n\tint f = 1; char c = getchar();\n\twhile (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }\n\twhile (isdigit(c)) { x = x * 10 + c - 48; c = getchar(); }\n\tx *= f;\n}\n\nconst int Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int sub(int a, int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a, int b) { return 1LL * a * b % Mod; }\ninline void updateA(int &a, int b) { a = add(a, b); }\ninline void updateM(int &a, int b) { a = mul(a, b); }\n\nconst int MAXN = 2e5 + 9;\n\nint fac[MAXN], inv[MAXN], ifac[MAXN];\n\nvoid Call(int n) \n{\n\tfac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n\tinv[1] = 1; for (int i = 2; i <= n; ++i) inv[i] = mul(sub(Mod, Mod / i), inv[Mod % i]);\n\tifac[0] = 1; for (int i = 1; i <= n; ++i) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\n\nint n;\n\nstruct Edge { int ver, nxt; } e[MAXN << 2];\nint head[MAXN], tot = 0, Head[MAXN];\n\ninline void Add(int x, int y) { e[++tot].ver = y, e[tot].nxt = head[x], head[x] = tot; }\ninline void Add_(int x, int y) { e[++tot].ver = y, e[tot].nxt = Head[x], Head[x] = tot; }\n\nint ans = 0;\n\nstd::vector<int> G;\nbool vis[MAXN];\nint edge = 0, s, t;\nvoid GetLoop(int x, int Fa) \n{\n\tG.push_back(x);\n\tvis[x] = true;\n\tfor (int i = head[x]; i; ++edge, i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (!vis[y]) GetLoop(y, x);\n\t\telse if (y != Fa)\n\t\t\ts = x, t = y;\n\t}\n}\n\nint pr[MAXN];\nvoid GetPr(int x) \n{\n\tfor (int i = head[x]; i; i = e[i].nxt) \n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x] || y == s) continue;\n\t\tpr[y] = x;\n\t\tGetPr(y);\n\t}\n}\n\nint deg[MAXN];\nvoid Build()\n{\n\tfor (auto x : G)\n\t\tfor (int i = head[x]; i; i = e[i].nxt) \t\n\t\t{\n\t\t\tint y = e[i].ver;\n\t\t\tif (y < pr[x]) Add_(x, y), ++deg[y];\n\t\t\t// 令每个点认领它的入边\n\t\t\t// 按照限制关系建边 \n\t\t}\n}\n\nint sz[MAXN];\nvoid Dfs(int x) \n{\n\tsz[x] = 1;\n\tfor (int i = Head[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].ver;\n\t\tif (y == pr[x]) continue;\n\t\tDfs(y);\n\t\tsz[x] += sz[y];\n\t}\n}\n\nint Calc() \n{\n\tfor (auto i : G)\n\t\tHead[i] = deg[i] = 0;\n\t\n\tint res = fac[G.size()];\n\t\n\tpr[s] = t;\n\tGetPr(s);\n\tBuild();\n\n\tfor (auto i : G)\n\t\tif (!deg[i])\n\t\t\tDfs(i);\n\tfor (auto i : G) \n\t\tupdateM(res, inv[sz[i]]);\n\t\t\n\treturn res;\n}\n\nint main() \n{\n\tread(n);\n\tfor (int i = 1; i <= n << 1; ++i)\n\t{\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tAdd(x, y + n), Add(y + n, x); \n\t}\n\n\tn <<= 1; \n\tCall(n);\n\n\tans = fac[n];\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (!vis[i])\n\t\t{\n\t\t\tGetLoop(i, 0);\n\t\t\tif (G.size() << 1 != edge) { ans = 0; break; } // 是否是基环树 \n\t\t\tupdateM(ans, ifac[G.size()]);\n\t\t\tint res = 0;\n\t\t\tupdateA(res, Calc());\n\t\t\tstd::swap(s, t); // 换个方向 \n\t\t\tupdateA(res, Calc());\n\t\t\tupdateM(ans, res);\n\t\n\t\t\tG.clear();\n\t\t\tedge = 0;\n\t\t}\n\n\tprintf(\"%d\\n\", ans);\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 200005, MOD = 1000000007;\ntypedef long long i64;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N << 1];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n  e[++cnt] = (Edge){head[v], u}, head[v] = cnt;\n}\n\nint N, vis[MAX_N], num_e, num_v, st[MAX_N];\nvoid dfs(int u, int v) {\n  static int tot;\n  st[++num_v] = u, vis[u] = ++tot;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v) {\n      if (!vis[e[i].to]) num_e++, dfs(e[i].to, u);\n      else if (vis[e[i].to] < vis[u]) num_e++;\n    }\n}\n\ni64 fac[MAX_N], ifac[MAX_N], inv[MAX_N];\ni64 binom(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nbool flag;\nint top, cir[MAX_N];\n\nvoid find_circle(int u, int v) {\n  if (flag) return;\n  static int ti[MAX_N], fa[MAX_N];\n  \n  fa[u] = v, ti[u] = 1;\n  \n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v) {\n      if (flag) return;\n      if (!ti[e[i].to]) find_circle(e[i].to, u);\n      else {\n\tint temp = u;\n\tdo {\n\t  cir[top++] = temp;\n\t  temp = fa[temp];\n\t} while (temp != e[i].to);\n\tcir[top++] = e[i].to;\n\tflag = 1;\n      }\n    }\n}\n\nint on[MAX_N], target[MAX_N], in[MAX_N];\n\nvoid dfs2(int u, int v) {\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v && !on[e[i].to]) {\n      target[e[i].to] = u;\n      dfs2(e[i].to, u);\n    }\n}\n\nint sz[MAX_N];\n\ni64 dfs3(int u, int v) {\n  sz[u] = 0;\n  i64 now = 1;\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to < target[u]) {\n      i64 temp = dfs3(e[i].to, u);\n      now = now * temp % MOD * binom(sz[u] + sz[e[i].to], sz[u]) % MOD;\n      sz[u] += sz[e[i].to];\n    }\n  sz[u]++;\n  // printf(\"%lld\\n\", now);\n  return now;\n}\n\ni64 calc() {\n  for (int i = 1; i <= num_v; ++i) in[st[i]] = 0;\n  for (int i = 1; i <= num_v; ++i) {\n    for (int j = head[st[i]]; j; j = e[j].nxt)\n      if (e[j].to < target[st[i]]) in[e[j].to]++;\n  }\n  i64 res = 1;\n  int size = 0;\n  for (int i = 1; i <= num_v; ++i)\n    if (in[st[i]] == 0) {\n      res = res * dfs3(st[i], 0) % MOD * binom(sz[st[i]] + size, size) % MOD;\n      size += sz[st[i]];\n    }\n  return res;\n}\n\ni64 work() {\n  flag = 0;\n  find_circle(st[1], 0);\n  for (int i = 0; i < top; ++i) on[cir[i]] = 1;\n  for (int i = 0; i < top; ++i)\n    dfs2(cir[i], 0);\n  i64 now = 0;\n  for (int i = 0; i < top; ++i) target[cir[i]] = cir[(i + 1) % top];\n  now = (now + calc()) % MOD;\n  for (int i = 0; i < top; ++i) target[cir[i]] = cir[(i - 1 + top) % top];\n  now = (now + calc()) % MOD;\n  return now;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1, x, y; i <= N << 1; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    addedge(x, y + N);\n  }\n\n  fac[0] = ifac[0] = inv[1] = 1;\n  for (int i = 1; i <= N << 1; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i <= N << 1; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i <= N << 1; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n  \n  i64 result = 1;\n  \n  for (int i = 1; i <= N << 1; ++i) \n    if (!vis[i]) {\n      num_e = 0, num_v = 0;\n      dfs(i, 0);\n      if (num_e != num_v) {\n\tputs(\"0\");\n\treturn 0;\n      }\n      result = result * work() % MOD;\n    }\n\n  printf(\"%lld\\n\", (result + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\nconst int MOD = 1000000007;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\n\nstruct Fp {\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n\tinline const bool operator == (const Fp &x);\n\tinline const bool operator != (const Fp &x);\n};\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\nbool operator == (Fp x, Fp y) { return mod(x.val, MOD) == mod(y.val, MOD); }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp power(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = power(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\ninline const bool Fp::operator == (const Fp &x) { return (this->val == x.val); }\ninline const bool Fp::operator != (const Fp &x) { return (this->val != x.val); }\n\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 510000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calc_fact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nFp com(vector<int> vec) {\n\tint sum = 0;\n\tfor (int i = 0; i < vec.size(); ++i) sum += vec[i];\n\tFp res = fact(sum);\n\tfor (int i = 0; i < vec.size(); ++i) {\n\t\tres /= fact(vec[i]);\n\t}\n\treturn res;\n}\n\n\n\ntypedef pair<int, int> pint;\nconst int MAX = 510000;\n\nint N;\nmap<pint, int> ma;\nvector<pint> points;\n\n\nvector<vector<int> > xtoy, ytox;\nvector<vector<int> > G;\nvector<vector<int> > nG[2];\n\n\nbool seen[2][MAX];\nbool visited[2][MAX];\nint xnum[2][MAX], ynum[2][MAX];\nint dir[2][MAX];\nbool xused[2][MAX], yused[2][MAX];\n\nvector<int> comp;\n\nbool stop = false;\n\nvoid dfs(int v, int p, int xfirst = 0) {\n\t//COUT(v);\n\tif (stop) return;\n\tint x = points[v].first;\n\tint y = points[v].second;\n\n\t// dfs\n\tbool detected = false;\n\tseen[xfirst][v] = true;\n\tfor (auto nv : G[v]) {\n\t\tif (visited[xfirst][nv]) continue;\n\t\tif (nv == p) continue;\n\t\tif (seen[xfirst][nv]) {\n\t\t\tdetected = true;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(nv, v, xfirst);\n\t}\n\n\tif (dir[xfirst][v] == -1 && xused[xfirst][x] && yused[xfirst][y]) {\n\t\tstop = true;\n\t\treturn;\n\t}\n\n\tif (!visited[xfirst][v]) {\n\t\t//cout << v << \": \" << detected << \"; \" << pint(xnum[xfirst][x], ynum[xfirst][y]) << \", \"\n\t\t//\t<< make_pair(xused[xfirst][x], yused[xfirst][y]) << \"; \";\n\n\n\t\t// finished condition\n\t\tif (xnum[xfirst][x] == 1 && !xused[xfirst][x]) {\n\t\t\tdir[xfirst][v] = 0;\n\t\t\txused[xfirst][x] = true;\n\t\t}\n\t\tif (ynum[xfirst][y] == 1 && !yused[xfirst][y]) {\n\t\t\tdir[xfirst][v] = 1;\n\t\t\tyused[xfirst][y] = true;\n\t\t}\n\n\t\t// alternative condition\n\t\tif (dir[xfirst][v] == -1) {\n\t\t\tif (yused[xfirst][y]) {\n\t\t\t\tdir[xfirst][v] = 0;\n\t\t\t\txused[xfirst][x] = true;\n\t\t\t}\n\t\t\telse if (xused[xfirst][x]) {\n\t\t\t\tdir[xfirst][v] = 1;\n\t\t\t\tyused[xfirst][y] = true;\n\t\t\t}\n\t\t}\n\n\t\t// cycle\n\t\tif (dir[xfirst][v] == -1) {\n\t\t\tdir[xfirst][v] = xfirst;\n\t\t\tif (xfirst == 0) xused[xfirst][x] = true;\n\t\t\telse yused[xfirst][y] = true;\n\t\t}\n\n\t\t//cout << dir[xfirst][v] << \";; \" << endl;\n\n\t\t--xnum[xfirst][x];\n\t\t--ynum[xfirst][y];\n\t\tcomp.push_back(v);\n\t\tvisited[xfirst][v] = true;\n\t}\n}\n\nvoid makeGraph(int xfirst = 0) {\n\tfor (auto v : comp) {\n\t\tint x = points[v].first;\n\t\tint y = points[v].second;\n\n\t\tif (dir[xfirst][v] == 0) {\n\t\t\tfor (auto ny : xtoy[x]) {\n\t\t\t\tif (ny >= y) break;\n\t\t\t\tint nv = ma[pint(x, ny)];\n\t\t\t\tnG[xfirst][v].push_back(nv);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (auto nx : ytox[y]) {\n\t\t\t\tif (nx >= x) break;\n\t\t\t\tint nv = ma[pint(nx, y)];\n\t\t\t\tnG[xfirst][v].push_back(nv);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool cmp(int a, int b) {\n\tint na = points[a].first + points[a].second;\n\tint nb = points[b].first + points[b].second;\n\treturn (na > nb);\n}\n\nFp dp[2][MAX];\nint num[2][MAX];\nFp rec(int v, int p, int xfirst = 0) {\n\tnum[xfirst][v] = 1;\n\tfor (auto nv : nG[xfirst][v]) {\n\t\tif (nv == p) continue;\n\t\trec(nv, v, xfirst);\n\t\tnum[xfirst][v] += num[xfirst][nv];\n\t}\n\tFp res = 1;\n\tFp div = fact(num[xfirst][v] - 1);\n\tfor (auto nv : nG[xfirst][v]) {\n\t\tif (nv == p) continue;\n\t\tdiv /= fact(num[xfirst][nv]);\n\t\tres *= dp[xfirst][nv];\n\t}\n\tres *= div;\n\treturn dp[xfirst][v] = res;\n}\n\nFp calc(int xfirst = 0) {\n\tFp res = 1;\n\tFp div = fact(comp.size());\n\tsort(comp.begin(), comp.end(), cmp);\n\tfor (auto v : comp) {\n\t\tif (dp[xfirst][v] != 0) continue;\n\t\tFp tmp = rec(v, -1, xfirst);\n\t\tres *= tmp;\n\t\tdiv /= fact(num[xfirst][v]);\n\n\t\t//cout << v << \": \" << tmp << endl;\n\t}\n\tres *= div;\n\treturn res;\n}\n\nvoid print(vector<vector<int> > G) {\n\tfor (int i = 0; i < G.size(); ++i) {\n\t\tcout << i << \" (\" << points[i] << \"): \";\n\t\tfor (auto v : G[i]) {\n\t\t\tcout << v << \", \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nFp solve() {\n\tFp div = fact(N * 2);\n\txtoy.clear();\n\tytox.clear();\n\txtoy = ytox = vector<vector<int> >(N);\n\tfor (int i = 0; i < N * 2; ++i) {\n\t\txtoy[points[i].first].push_back(points[i].second);\n\t\tytox[points[i].second].push_back(points[i].first);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tsort(xtoy[i].begin(), xtoy[i].end());\n\t\tsort(ytox[i].begin(), ytox[i].end());\n\t}\n\n\tG = nG[0] = nG[1] = vector<vector<int> >(N * 2);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < (int)xtoy[i].size() - 1; ++j) {\n\t\t\tint u = ma[pint(i, xtoy[i][j])];\n\t\t\tint v = ma[pint(i, xtoy[i][j + 1])];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tfor (int j = 0; j < (int)ytox[i].size() - 1; ++j) {\n\t\t\tint u = ma[pint(ytox[i][j], i)];\n\t\t\tint v = ma[pint(ytox[i][j + 1], i)];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n\n\t//print(G);\n\n\tmemset(seen, 0, sizeof(seen));\n\tmemset(visited, 0, sizeof(visited));\n\tmemset(xnum, 0, sizeof(xnum));\n\tmemset(ynum, 0, sizeof(ynum));\n\tmemset(dir, -1, sizeof(dir));\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(num, 0, sizeof(num));\n\tmemset(xused, 0, sizeof(xused));\n\tmemset(yused, 0, sizeof(yused));\n\tstop = false;\n\tfor (int i = 0; i < N; ++i) {\n\t\txnum[0][i] = xnum[1][i] = xtoy[i].size();\n\t\tynum[0][i] = ynum[1][i] = ytox[i].size();\n\t}\n\n\t//COUT(ma);\n\n\tFp res = 1;\n\tfor (int i = 0; i < N * 2; ++i) {\n\t\tif (visited[0][i]) continue;\n\t\tcomp.clear();\n\t\tdfs(i, -1, 0);\n\t\tif (stop) break;\n\t\tmakeGraph(0);\n\n\t\t/*\n\t\tCOUT(comp);\n\t\tCOUT(\"nG[0]\");\n\t\tfor (int i = 0; i < N * 2; ++i) {\n\t\t\tcout << i << \": dir \" << dir[0][i] << endl;\n\t\t}\n\t\tprint(nG[0]);\n\t\t*/\n\n\t\tFp val1 = calc(0);\n\n\n\n\t\tcomp.clear();\n\t\tdfs(i, -1, 1);\n\t\tmakeGraph(1);\n\n\t\t/*\n\t\tCOUT(\"nG[1]\");\n\t\tfor (int i = 0; i < N * 2; ++i) {\n\t\t\tcout << i << \": dir \" << dir[1][i] << endl;\n\t\t}\n\t\tprint(nG[1]);\n\t\t*/\n\t\tFp val2 = calc(1);\n\n\n\n\n\t\tFp val = val1 + val2;\n\t\tres *= val;\n\t\tdiv /= fact(comp.size());\n\n\n\n\n\t\t//COUT(val1);\n\t\t//COUT(val2);\n\t}\n\n\tif (stop) return 0;\n\n\tres *= div;\n\treturn res;\n}\n\nint main() {\n\tcalc_fact();\n\twhile (cin >> N) {\n\t\tma.clear(), points.clear();\n\t\tfor (int i = 0; i < N * 2; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t--x, --y;\n\t\t\tpoints.push_back(pint(x, y));\n\t\t\tma[pint(x, y)] = i;\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}\n"
  },
  {
    "language": "Text",
    "code": "0\n"
  },
  {
    "language": "Text",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nint n,cnt=0,num=0,B=0;\nvi x,y,ax,ay,vis,b,c,d,used;\nvl dp;\nvvi g,G;\nvvp X,Y;\n\nint dfs(int v,int w){\n\tb.push_back(v);\n\tvis[v]++;cnt++;\n\tif(!ax[x[v]]) num++,ax[x[v]]=1;\n\tif(!ay[y[v]]) num++,ay[y[v]]=1;\n\tint t=-1;\n\tfor(auto u:g[v]) if(u!=-1&&u!=w){\n\t\tif(vis[u]&&!B){\n\t\t\tint I=d.size()-1;\n\t\t\tpip p={{x[u],y[u]},u};\n\t\t\twhile(I>=0&&d[I]!=u){\n\t\t\t\tint u_=d[I--];\n\t\t\t\tp=min(p,{{x[u_],y[u_]},u_});\n\t\t\t}\n\t\t\tt=p.second;\n\t\t\tB=1;\n\t\t}\n\t\telse if(!vis[u]){\n\t\t\td.push_back(u);\n\t\t\tint t_=dfs(u,v);\n\t\t\tif(t_!=-1) t=t_;\n\t\t\td.pop_back();\n\t\t}\n\t}\n\treturn t;\n}\n\nvoid DFS(int v,int I){\n\tint u=g[v][I];\n\tif(u==-1||c[u]!=-1) return;\n\tc[u]=1-I%2;\n\tfor(int i=0;i<4;i++){\n\t\tint w=g[u][i];\n\t\tif(w!=-1&&c[w]==-1) DFS(u,i);\n\t}\n}\n\npll Rec(int v){\n\tll res=1,S=0;\n\tfor(auto u:G[v]){\n\t\tpll p=Rec(u);\n\t\tll T=p.second;\n\t\tres=Div(res*p.first%mod,F[T]);\n\t\tS+=T;\n\t}\n\t(res*=F[S])%=mod;\n\treturn {res,S+1};\n}\n\nll f(int v,int t){\n\tc[v]=t;\n\tfor(int i=0;i<4;i++) DFS(v,i%2*2+abs(i/2-t));\n\tfor(auto i:b){\n\t\tint u=g[i][c[i]];\n\t\twhile(u!=-1){\n\t\t\tG[i].push_back(u);\n\t\t\tused[u]=1;\n\t\t\tu=g[u][c[i]];\n\t\t}\n\t}\n\tfor(auto i:b) if(!used[i]) G[n].push_back(i);\n\tll res=Rec(n).first;\n\tfor(auto i:b){\n\t\tc[i]=-1;\n\t\tused[i]=0;\n\t\tG[i].clear();\n\t}\n\tG[n].clear();\n\treturn res;\n}\n\nint main(){\n\tInit();\n\tcin>>n;\n\tn*=2;\n\tx=y=ax=ay=vis=used=vi(n);\n\tc=vi(n,-1);\n\tX=Y=vvp(n);\n\tg=vvi(n,vi(4,-1));\n\tG=vvi(n+1);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tx[i]--;y[i]--;\n\t\tX[x[i]].push_back({y[i],i});\n\t\tY[y[i]].push_back({x[i],i});\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tsort(X[i].begin(),X[i].end());\n\t\tsort(Y[i].begin(),Y[i].end());\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=1;j<X[i].size();j++){\n\t\t\tint u=X[i][j-1].second,v=X[i][j].second;\n\t\t\tg[u][3]=v;g[v][1]=u;\n\t\t}\n\t\tfor(int j=1;j<Y[i].size();j++){\n\t\t\tint u=Y[i][j-1].second,v=Y[i][j].second;\n\t\t\tg[u][2]=v;g[v][0]=u;\n\t\t}\n\t}\n\tll res=F[n];\n\tfor(int i=0;i<n;i++) if(!vis[i]){\n\t\tcnt=0;num=0;B=0;\n\t\tb.clear();d.clear();\n\t\td.push_back(i);\n\t\tint v=dfs(i,-1);\n\t\td.pop_back();\n\t\tres=(cnt==num?Div((f(v,0)+f(v,1))%mod*res%mod,F[cnt]):0);\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n#define MD\t1000000007\n\nint vv[N * 2 + 1], ff[N * 2 + 1];\n\nvoid init() {\n\tint i;\n\n\tff[0] = 1;\n\tfor (i = 1; i <= N * 2; i++) {\n\t\tvv[i] = i == 1 ? 1 : (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n\t\tff[i] = (long long) ff[i - 1] * i % MD;\n\t}\n}\n\nint *oj[N * 2], oo[N * 2];\n\nvoid link(int i, int j) {\n\tint o = oo[i]++;\n\n\tif (o >= 2 && (o & o - 1) == 0)\n\t\toj[i] = (int *) realloc(oj[i], o * 2 * sizeof *oj[i]);\n\toj[i][o] = j;\n}\n\nint ta[N * 2], pp[N * 2], qu[N * 2], cnt, qu_[N * 2], cnt_;\n\nint dfs1(int p, int i) {\n\tstatic int time;\n\tint o;\n\n\tta[i] = ++time, pp[i] = p, qu[cnt++] = i;\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j != p) {\n\t\t\tif (!ta[j]) {\n\t\t\t\tif (!dfs1(i, j))\n\t\t\t\t\treturn 0;\n\t\t\t} else if (ta[j] < ta[i]) {\n\t\t\t\tint i_;\n\n\t\t\t\tif (cnt_ != 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tcnt_ = 0;\n\t\t\t\tfor (i_ = j; i_ != -1; i_ = pp[i_])\n\t\t\t\t\tqu_[cnt_++] = i_;\n\t\t\t\twhile (--cnt_)\n\t\t\t\t\tpp[qu_[cnt_]] = qu_[cnt_ - 1];\n\t\t\t\tpp[j] = i;\n\t\t\t\tfor (i_ = i; i_ != j; i_ = pp[i_])\n\t\t\t\t\tqu_[cnt_++] = i_;\n\t\t\t\tqu_[cnt_++] = j;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nchar visited[N]; int sz[N];\n\nvoid dfs2(int i) {\n\tint o;\n\n\tif (visited[i])\n\t\treturn;\n\tvisited[i] = 1;\n\tsz[i] = 1;\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j < pp[i]) {\n\t\t\tdfs2(j);\n\t\t\tsz[i] += sz[j];\n\t\t}\n\t}\n}\n\nint solve() {\n\tint h, x;\n\n\tfor (h = 0; h < cnt; h++)\n\t\tvisited[qu[h]] = 0;\n\tfor (h = 0; h < cnt; h++)\n\t\tif (!visited[qu[h]])\n\t\t\tdfs2(qu[h]);\n\tx = 1;\n\tfor (h = 0; h < cnt; h++)\n\t\tx = (long long) x * vv[sz[qu[h]]] % MD;\n\treturn x;\n}\n\nint main() {\n\tint n, h, i, j, ans;\n\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n * 2; i++)\n\t\toj[i] = (int *) malloc(2 * sizeof *oj[i]);\n\tfor (h = 0; h < n * 2; h++) {\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tlink(i, n + j), link(n + j, i);\n\t}\n\tans = ff[n * 2];\n\tfor (i = 0; i < n * 2; i++)\n\t\tif (!ta[i]) {\n\t\t\tint x, y;\n\n\t\t\tcnt = 0, cnt_ = 0;\n\t\t\tif (!dfs1(-1, i) || cnt_ == 0) {\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tx = solve();\n\t\t\tfor (h = 0; h < cnt_; h++)\n\t\t\t\tpp[qu_[h]] = qu_[(h - 1 + cnt_) % cnt_];\n\t\t\ty = solve();\n\t\t\tans = (long long) ans * (x + y) % MD;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n#define MD\t1000000007\n\nint vv[N * 2 + 1], ff[N * 2 + 1];\n\nvoid init() {\n\tint i;\n\n\tff[0] = 1;\n\tfor (i = 1; i <= N * 2; i++) {\n\t\tvv[i] = i == 1 ? 1 : (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n\t\tff[i] = (long long) ff[i - 1] * i % MD;\n\t}\n}\n\nint *oj[N * 2], oo[N * 2];\n\nvoid link(int i, int j) {\n\tint o = oo[i]++;\n\n\tif (o >= 2 && (o & o - 1) == 0)\n\t\toj[i] = (int *) realloc(oj[i], o * 2 * sizeof *oj[i]);\n\toj[i][o] = j;\n}\n\nint ta[N * 2], pp[N * 2], qu[N * 2], cnt, qu_[N * 2], cnt_;\n\nint dfs1(int p, int i) {\n\tstatic int time;\n\tint o;\n\n\tta[i] = ++time, pp[i] = p, qu[cnt++] = i;\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j != p) {\n\t\t\tif (!ta[j]) {\n\t\t\t\tif (!dfs1(i, j))\n\t\t\t\t\treturn 0;\n\t\t\t} else if (ta[j] < ta[i]) {\n\t\t\t\tint i_;\n\n\t\t\t\tif (cnt_ != 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tcnt_ = 0;\n\t\t\t\tfor (i_ = j; i_ != -1; i_ = pp[i_])\n\t\t\t\t\tqu_[cnt_++] = i_;\n\t\t\t\twhile (--cnt_)\n\t\t\t\t\tpp[qu_[cnt_]] = qu_[cnt_ - 1];\n\t\t\t\tpp[j] = i;\n\t\t\t\tfor (i_ = i; i_ != j; i_ = pp[i_])\n\t\t\t\t\tqu_[cnt_++] = i_;\n\t\t\t\tqu_[cnt_++] = j;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nchar visited[N * 2]; int sz[N * 2];\n\nvoid dfs2(int i) {\n\tint o;\n\n\tif (visited[i])\n\t\treturn;\n\tvisited[i] = 1;\n\tsz[i] = 1;\n\tfor (o = 0; o < oo[i]; o++) {\n\t\tint j = oj[i][o];\n\n\t\tif (j < pp[i]) {\n\t\t\tdfs2(j);\n\t\t\tsz[i] += sz[j];\n\t\t}\n\t}\n}\n\nint solve() {\n\tint h, x;\n\n\tfor (h = 0; h < cnt; h++)\n\t\tvisited[qu[h]] = 0;\n\tfor (h = 0; h < cnt; h++)\n\t\tif (!visited[qu[h]])\n\t\t\tdfs2(qu[h]);\n\tx = 1;\n\tfor (h = 0; h < cnt; h++)\n\t\tx = (long long) x * vv[sz[qu[h]]] % MD;\n\treturn x;\n}\n\nint main() {\n\tint n, h, i, j, ans;\n\n\tinit();\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n * 2; i++)\n\t\toj[i] = (int *) malloc(2 * sizeof *oj[i]);\n\tfor (h = 0; h < n * 2; h++) {\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tlink(i, n + j), link(n + j, i);\n\t}\n\tans = ff[n * 2];\n\tfor (i = 0; i < n * 2; i++)\n\t\tif (!ta[i]) {\n\t\t\tint x, y;\n\n\t\t\tcnt = 0, cnt_ = 0;\n\t\t\tif (!dfs1(-1, i) || cnt_ == 0) {\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tx = solve();\n\t\t\tfor (h = 0; h < cnt_; h++)\n\t\t\t\tpp[qu_[h]] = qu_[(h - 1 + cnt_) % cnt_];\n\t\t\ty = solve();\n\t\t\tans = (long long) ans * (x + y) % MD;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>(2);\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>(2);\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tint[] ord = new int[n];\n\t\tint[] low = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>(2);\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tint[] ord = new int[n];\n\t\tint[] low = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nimport org.omg.Messaging.SyncScopeHelper;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t// long t = System.currentTimeMillis();\n\t\tnew Main().run();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N];\n\tlong[] invfac = new long[2 * N];\n\tlong[] inv = new long[2 * N];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tboolean check(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\t\tint[] ord = new int[2 * n];\n\t\tArrays.fill(ord, -1);\n\t\tint p = 0;\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint j = ds.root(i);\n\t\t\tif (ord[j] == -1) {\n\t\t\t\tord[j] = p++;\n\t\t\t}\n\t\t\tif (ds.sz(j) != ds.e_sz[j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tArrayList<Integer> szs = new ArrayList<>();\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tszs.add((int) q[1]);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tforward[v].add(cur);\n\t\t\tbackward[cur].add(v);\n\t\t\tif (backward[v].size() == 0)\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\n\t\t\tint[] frm = new int[n];\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\tvis[j] = true;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t\tvis[j] = true;\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = (ret + ans) % MOD;\n\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tif (!check(n, x, y)) {\n\t\t\treturn 0;\n\t\t}\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tArrayList<Integer>[] g2;\n\tArrayList<Integer>[] forward;\n\tArrayList<Integer>[] backward;\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tg2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tforward = new ArrayList[n];\n\t\tbackward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tArrayList<Integer>[] g2;\n\tArrayList<Integer>[] forward;\n\tArrayList<Integer>[] backward;\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tg2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tforward = new ArrayList[n];\n\t\tbackward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tint[] ord = new int[n];\n\t\tint[] low = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tint[] ord = new int[n];\n\t\tint[] low = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low) {\n\t\tscc_pend.addLast(cur);\n\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tArrayList<Integer>[] g2;\n\tArrayList<Integer>[] forward;\n\tArrayList<Integer>[] backward;\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tg2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tforward = new ArrayList[n];\n\t\tbackward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n//\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n//\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tArrayList<Integer>[] g2;\n\tArrayList<Integer>[] forward;\n\tArrayList<Integer>[] backward;\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tg2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tforward = new ArrayList[n];\n\t\tbackward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tint[] ord = new int[n];\n\t\tint[] low = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, int[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v] = cur;\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v] = cur;\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>(2);\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tint[] forward = new int[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tif (v.get(b) < v.get(forward[i])) {\n\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tint[] nf = new int[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tint u = forward[i];\n\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\tnf[i] = u;\n\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\tnf[u] = i;\n\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tint n2 = 2 * n;\n\t\tDJSet ds = new DJSet(n2);\n\t\tArrayList<Integer>[] vv = new ArrayList[n2];\n\t\tArrayList<Integer>[][] gg = new ArrayList[n2][];\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tint vvi_size = vv[i].size();\n\t\t\tgg[i] = new ArrayList[vvi_size];\n\t\t\tfor (int j = 0; j < vvi_size; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint n2 = 2 * n;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g,  ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>(2);\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tint[] ord = new int[n];\n\t\tint[] low = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>(2);\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>(2);\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint n2 = 2 * n;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tArrayList<Integer>[] g2;\n\tArrayList<Integer>[] forward;\n\tArrayList<Integer>[] backward;\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tg2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tforward = new ArrayList[n];\n\t\tbackward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\t// long t = System.currentTimeMillis();\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, int[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v] = cur;\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v] = cur;\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>(2);\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tint[] forward = new int[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tif (v.get(b) < v.get(forward[i])) {\n\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tint[] nf = new int[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tint u = forward[i];\n\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\tnf[i] = u;\n\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\tnf[u] = i;\n\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tint n2 = 2 * n;\n\t\tDJSet ds = new DJSet(n2);\n\t\tArrayList<Integer>[] vv = new ArrayList[n2];\n\t\tArrayList<Integer>[][] gg = new ArrayList[n2][];\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tint vvi_size = vv[i].size();\n\t\t\tgg[i] = new ArrayList[vvi_size];\n\t\t\tfor (int j = 0; j < vvi_size; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint n2 = 2 * n;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\t// long t = System.currentTimeMillis();\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N];\n\tlong[] invfac = new long[2 * N];\n\tlong[] inv = new long[2 * N];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tboolean check(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\t\tint[] ord = new int[2 * n];\n\t\tArrays.fill(ord, -1);\n\t\tint p = 0;\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint j = ds.root(i);\n\t\t\tif (ord[j] == -1) {\n\t\t\t\tord[j] = p++;\n\t\t\t}\n\t\t\tif (ds.sz(j) != ds.e_sz[j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tif (!scc_pend.isEmpty())\n\t\t\tthrow new AssertionError();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tforward[v].add(cur);\n\t\t\tbackward[cur].add(v);\n\t\t\tif (backward[v].size() == 0)\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\n\t\t\tint[] frm = new int[n];\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = (ret + ans) % MOD;\n\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tlong t = System.currentTimeMillis();\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tint[] ord = new int[n];\n\t\tint[] low = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\t// long t = System.currentTimeMillis();\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N];\n\tlong[] invfac = new long[2 * N];\n\tlong[] inv = new long[2 * N];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tboolean check(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\t\tint[] ord = new int[2 * n];\n\t\tArrays.fill(ord, -1);\n\t\tint p = 0;\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint j = ds.root(i);\n\t\t\tif (ord[j] == -1) {\n\t\t\t\tord[j] = p++;\n\t\t\t}\n\t\t\tif (ds.sz(j) != ds.e_sz[j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tif (!scc_pend.isEmpty())\n\t\t\tthrow new AssertionError();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tforward[v].add(cur);\n\t\t\tbackward[cur].add(v);\n\t\t\tif (backward[v].size() == 0)\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\n\t\t\tint[] frm = new int[n];\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = (ret + ans) % MOD;\n\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tif (!check(n, x, y)) {\n\t\t\treturn 0;\n\t\t}\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\t// long t = System.currentTimeMillis();\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N];\n\tlong[] invfac = new long[2 * N];\n\tlong[] inv = new long[2 * N];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tif (!scc_pend.isEmpty())\n\t\t\tthrow new AssertionError();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\n\t\t\tint[] frm = new int[n];\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = (ret + ans) % MOD;\n\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "Fimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>(2);\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col = new int[200000];\n\tint[] col_sz = new int[200000];\n\tint[] ord = new int[200000];\n\tint[] low = new int[200000];\n\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>(2);\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>(2);\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tint n2 = 2 * n;\n\t\tDJSet ds = new DJSet(n2);\n\t\tArrayList<Integer>[] vv = new ArrayList[n2];\n\t\tArrayList<Integer>[][] gg = new ArrayList[n2][];\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint n2 = 2 * n;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>(2);\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>(2);\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tint n2 = 2 * n;\n\t\tDJSet ds = new DJSet(n2);\n\t\tArrayList<Integer>[] vv = new ArrayList[n2];\n\t\tArrayList<Integer>[][] gg = new ArrayList[n2][];\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tint vvi_size = vv[i].size();\n\t\t\tgg[i] = new ArrayList[vvi_size];\n\t\t\tfor (int j = 0; j < vvi_size; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint n2 = 2 * n;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\n\t\t\tint[] frm = new int[n];\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif(ret>=MOD)ret-=MOD;\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tlong t = System.currentTimeMillis();\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n//\t\tlong t = System.currentTimeMillis();\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n//\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>(2);\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>(2);\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n//\t\tlong t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n//\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\t// long t = System.currentTimeMillis();\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tif (!scc_pend.isEmpty())\n\t\t\tthrow new AssertionError();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\n\t\t\tint[] frm = new int[n];\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = (ret + ans) % MOD;\n\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\t// long t = System.currentTimeMillis();\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N];\n\tlong[] invfac = new long[2 * N];\n\tlong[] inv = new long[2 * N];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tboolean check(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\t\tint[] ord = new int[2 * n];\n\t\tArrays.fill(ord, -1);\n\t\tint p = 0;\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint j = ds.root(i);\n\t\t\tif (ord[j] == -1) {\n\t\t\t\tord[j] = p++;\n\t\t\t}\n\t\t\tif (ds.sz(j) != ds.e_sz[j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tArrayList<Integer> szs = new ArrayList<>();\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tszs.add((int) q[1]);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tforward[v].add(cur);\n\t\t\tbackward[cur].add(v);\n\t\t\tif (backward[v].size() == 0)\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\n\t\t\tint[] frm = new int[n];\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\tvis[j] = true;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t\tvis[j] = true;\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = (ret + ans) % MOD;\n\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tif (!check(n, x, y)) {\n\t\t\treturn 0;\n\t\t}\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tstatic final long MOD = 1_000_000_000 + 7;\n\tstatic final int N = 100000;\n\tstatic long[] fac = new long[2 * N + 1];\n\tstatic long[] invfac = new long[2 * N + 1];\n\tstatic long[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tstatic long c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tstatic class DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tstatic void scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcol[i] = -1;\n\t\t\tord[i] = -1;\n\t\t\tcol_sz[i] = 0;\n\t\t}\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, pend);\n\t\t}\n\t}\n\n\tstatic void scc_dfs(int cur, int par, ArrayList<Integer>[] g, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tstatic int[] col = new int[200000];\n\tstatic int[] col_sz = new int[200000];\n\tstatic int[] ord = new int[200000];\n\tstatic int[] low = new int[200000];\n\n\tstatic int color;\n\tstatic int order;\n\n\tstatic long[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tstatic void dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward,\n\t\t\tArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic long f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>(2);\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>(2);\n\t\t\tbackward[i] = new ArrayList<>(2);\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(ord, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tord[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (ord[j] != -1) {\n\t\t\t\t\tj = ord[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>(2);\n\t\t\t\t\tnb[i] = new ArrayList<>(2);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tstatic long solve(int n, int[] x, int[] y) {\n\t\tint n2 = 2 * n;\n\t\tDJSet ds = new DJSet(n2);\n\t\tArrayList<Integer>[] vv = new ArrayList[n2];\n\t\tArrayList<Integer>[][] gg = new ArrayList[n2][];\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tcol[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = col[x[i]];\n\t\t\tint v = col[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint n2 = 2 * n;\n\t\tfor (int i = 0; i < n2; ++i) {\n\t\t\tord[i] = ni();\n\t\t\tlow[i] = ni();\n\t\t\t--ord[i];\n\t\t\t--low[i];\n\t\t}\n\t\tout.println(solve(n, ord, low));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tArrayList<Integer>[] g2;\n\tArrayList<Integer>[] forward;\n\tArrayList<Integer>[] backward;\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tg2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tforward = new ArrayList[n];\n\t\tbackward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tint[] ord = new int[n];\n\t\tint[] low = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g, ord, low, pend);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g, int[] ord, int[] low, ArrayDeque<Integer> pend) {\n\t\tpend.addLast(cur);\n\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g, ord, low, pend);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint order;\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tArrayList<Integer>[] g2;\n\tArrayList<Integer>[] forward;\n\tArrayList<Integer>[] backward;\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tg2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tforward = new ArrayList[n];\n\t\tbackward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tif (t == 0) {\n\t\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t// long t = System.currentTimeMillis();\n\t\tint n = ni();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tout.println(solve(n, x, y));\n\t\tout.flush();\n\t\t// System.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tprivate static boolean eof() {\n\t\tif (lenbuf == -1)\n\t\t\treturn true;\n\t\tint lptr = ptrbuf;\n\t\twhile (lptr < lenbuf)\n\t\t\tif (!isSpaceChar(inbuf[lptr++]))\n\t\t\t\treturn false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!isSpaceChar(b)) {\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\t// private static boolean isSpaceChar(int c) { return !(c >= 32 && c <=\n\t// 126); }\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tfinal long MOD = 1_000_000_000 + 7;\n\tfinal int N = 100000;\n\tlong[] fac = new long[2 * N + 1];\n\tlong[] invfac = new long[2 * N + 1];\n\tlong[] inv = new long[2 * N + 1];\n\t{\n\t\tfac[0] = 1;\n\t\tinvfac[0] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i)\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = MOD - inv[(int) (MOD % i)] * (MOD / i) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < invfac.length; ++i) {\n\t\t\tinvfac[i] = invfac[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\n\tlong c(int n, int k) {\n\t\treturn fac[n] * invfac[k] % MOD * invfac[n - k] % MOD;\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\t\tint[] e_sz;\n\t\tint n;\n\n\t\tpublic DJSet(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\te_sz = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y) {\n\t\t\t\t++e_sz[x];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t\te_sz[y] += e_sz[x] + 1;\n\t\t\te_sz[x] = -1;\n\t\t}\n\n\t\tint sz(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\t}\n\n\tvoid scc(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tcol = new int[n];\n\t\tord = new int[n];\n\t\tlow = new int[n];\n\t\tcol_sz = new int[n];\n\t\tArrays.fill(col, -1);\n\t\tArrays.fill(ord, -1);\n\t\torder = 0;\n\t\tcolor = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col[i] == -1)\n\t\t\t\tscc_dfs(i, -1, g);\n\t\t}\n\t\tcol_sz = Arrays.copyOf(col_sz, color);\n\t}\n\n\tvoid scc_dfs(int cur, int par, ArrayList<Integer>[] g) {\n\t\tscc_pend.addLast(cur);\n\t\tord[cur] = order++;\n\t\tlow[cur] = ord[cur];\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == par || col[dst] != -1)\n\t\t\t\tcontinue;\n\t\t\tif (ord[dst] != -1) {\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t} else {\n\t\t\t\tscc_dfs(dst, cur, g);\n\t\t\t\tlow[cur] = Math.min(low[cur], low[dst]);\n\t\t\t}\n\t\t}\n\t\tif (ord[cur] == low[cur]) {\n\t\t\tint v = -1;\n\t\t\twhile (v != cur) {\n\t\t\t\tv = scc_pend.pollLast();\n\t\t\t\tcol[v] = color;\n\t\t\t\tcol_sz[color]++;\n\t\t\t}\n\t\t\t++color;\n\t\t}\n\t}\n\n\tint[] col;\n\tint[] col_sz;\n\tint color;\n\tint[] ord;\n\tint[] low;\n\tint order;\n\tArrayDeque<Integer> scc_pend = new ArrayDeque<>();\n\n\tlong[] dfs2(int cur, ArrayList<Integer>[] g, boolean[] vis) {\n\t\tlong pat = 1;\n\t\tint sz = 0;\n\t\tvis[cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tlong[] q = dfs2(dst, g, vis);\n\t\t\tsz += q[1];\n\t\t\tpat = pat * q[0] % MOD * c(sz, (int) q[1]) % MOD;\n\t\t}\n\t\tsz += 1;\n\t\treturn new long[] { pat, sz };\n\t}\n\n\tvoid dfs1(ArrayList<Integer>[] g, int cur, int par, ArrayList<Integer>[] forward, ArrayList<Integer>[] backward) {\n\t\tboolean update = false;\n\t\tfor (int v : g[cur]) {\n\t\t\tif (v == par)\n\t\t\t\tcontinue;\n\t\t\tif (backward[v].size() == 0) {\n\t\t\t\tif (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1) {\n\t\t\t\t\tif (update)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tdfs1(g, v, cur, forward, backward);\n\t\t\t} else if (col_sz[col[cur]] > 1 && col_sz[col[v]] > 1 && !update) {\n\t\t\t\tforward[v].add(cur);\n\t\t\t\tbackward[cur].add(v);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(ArrayList<Integer>[] g, ArrayList<Integer> v) {\n\n\t\tint n = g.length;\n\t\tArrayList<Integer>[] g2 = new ArrayList[n];\n\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\tg2[i] = new ArrayList<>();\n\n\t\tscc(g);\n\n\t\tlong ret = 0;\n\n\t\tArrayList<Integer>[] forward = new ArrayList[n];\n\t\tArrayList<Integer>[] backward = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tforward[i] = new ArrayList<>();\n\t\t\tbackward[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (col_sz[col[i]] > 1) {\n\t\t\t\tdfs1(g, i, -1, forward, backward);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint[] frm = new int[n];\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < g2.length; ++i)\n\t\t\t\tg2[i].clear();\n\t\t\tArrays.fill(frm, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int b : backward[i]) {\n\t\t\t\t\tfor (int f : forward[i]) {\n\t\t\t\t\t\tif (v.get(b) < v.get(f)) {\n\t\t\t\t\t\t\tg2[i].add(b);\n\t\t\t\t\t\t\tfrm[b] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sz = 0;\n\t\t\tlong ans = 1;\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (vis[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tint j = i;\n\t\t\t\twhile (frm[j] != -1) {\n\t\t\t\t\tj = frm[j];\n\t\t\t\t}\n\t\t\t\tlong[] q = dfs2(j, g2, vis);\n\t\t\t\tsz += q[1];\n\t\t\t\tans = ans * q[0] % MOD * c((int) sz, (int) q[1]) % MOD;\n\t\t\t}\n\t\t\tret = ret + ans;\n\t\t\tif (ret >= MOD)\n\t\t\t\tret -= MOD;\n\t\t\tArrayList<Integer>[] nf = new ArrayList[n];\n\t\t\tArrayList<Integer>[] nb = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tnf[i] = new ArrayList<>();\n\t\t\t\tnb[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tif (t == 0) {\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tfor (int u : forward[i]) {\n\t\t\t\t\t\tif (col_sz[col[i]] == 1) {\n\t\t\t\t\t\t\tnf[i].add(u);\n\t\t\t\t\t\t\tnb[u].add(i);\n\t\t\t\t\t\t} else if (col_sz[col[i]] > 1 && col_sz[col[u]] > 1) {\n\t\t\t\t\t\t\tnf[u].add(i);\n\t\t\t\t\t\t\tnb[i].add(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbackward = nb;\n\t\t\t\tforward = nf;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tlong solve(int n, int[] x, int[] y) {\n\t\tDJSet ds = new DJSet(2 * n);\n\t\tArrayList<Integer>[] vv = new ArrayList[2 * n];\n\t\tArrayList<Integer>[][] gg = new ArrayList[2 * n][];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tds.setUnion(x[i], y[i] + n);\n\t\t}\n\n\t\tint[] id = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tvv[ds.root(i)].add(i);\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tCollections.sort(vv[i]);\n\t\t\tfor (int v : vv[i])\n\t\t\t\tid[v] = Collections.binarySearch(vv[i], v);\n\t\t\tgg[i] = new ArrayList[vv[i].size()];\n\t\t\tfor (int j = 0; j < gg[i].length; ++j)\n\t\t\t\tgg[i][j] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tint r = ds.root(x[i]);\n\t\t\tint u = id[x[i]];\n\t\t\tint v = id[y[i] + n];\n\t\t\tgg[r][u].add(v);\n\t\t\tgg[r][v].add(u);\n\t\t}\n\t\tlong ans = 1;\n\t\tint tot = 0;\n\t\tfor (int i = 0; i < gg.length; ++i) {\n\t\t\tif (gg[i].length == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ds.sz(i) != ds.e_sz[ds.root(i)]) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ttot += gg[i].length;\n\t\t\tans = ans * f(gg[i], vv[i]) % MOD * c(tot, gg[i].length) % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic void run() {\n\t\tlong t = System.currentTimeMillis();\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[2 * n];\n\t\tint[] y = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\t--x[i];\n\t\t\t--y[i];\n\t\t}\n\t\tSystem.out.println(solve(n, x, y));\n\t\tSystem.err.println(System.currentTimeMillis() - t);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        setFact(300000);\n        int N = cin.nextInt();\n        int[] x = new int[2 * N];\n        int[] y = new int[2 * N];\n        for (int i = 0; i < 2 * N; i++)\n        {\n            x[i] = cin.nextInt() - 1;\n            y[i] = cin.nextInt() - 1;\n        }\n\n        List<int>[] X = new List<int>[N];\n        List<int>[] Y = new List<int>[N];\n        for (int i = 0; i < N; i++)\n        {\n            X[i] = new List<int>();\n            Y[i] = new List<int>();\n        }\n\n        int[] Xcnt = new int[N];\n        int[] Ycnt = new int[N];\n\n        for (int i = 0; i < 2 * N; i++)\n        {\n            X[x[i]].Add(i);\n            Y[y[i]].Add(i);\n            Xcnt[x[i]]++;\n            Ycnt[y[i]]++;\n        }\n        \n        for (int i = 0; i < N; i++)\n        {\n            if(X[i].Count == 0 || Y[i].Count == 0)\n            {\n                Console.WriteLine(0); return;\n            }\n        }\n\n        bool[] checkX = new bool[N];\n        bool[] checkY = new bool[N];\n\n        bool[] used = new bool[2 * N];\n        long ans = 1;\n        long mod = 1000000007;\n\n        int[] color = new int[2 * N];\n        List<int>[] es = new List<int>[2 * N];\n        List<int>[] esp = new List<int>[2 * N];\n        int[] escount = new int[2 * N];\n        long[] dp = new long[2 * N];\n        int[] dp2 = new int[2 * N];\n\n        int nowSum = 0;\n        for (int i = 0; i < x.Length; i++)\n        {\n            if (used[i]) continue;\n            Queue<int> q = new Queue<int>();\n            List<int> id = new List<int>();\n            id.Add(i);\n            q.Enqueue(i);\n            used[i] = true;\n            int checkXcnt = 0;\n            int checkYcnt = 0;\n\n            while (q.Count != 0)\n            {\n                int now = q.Dequeue();\n                if (!checkX[x[now]])\n                {\n                    checkX[x[now]] = true;\n                    checkXcnt++;\n                }\n                if (!checkY[y[now]])\n                {\n                    checkY[y[now]] = true;\n                    checkYcnt++;\n                }\n                foreach (var next in X[x[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n                foreach (var next in Y[y[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n            }\n\n            if(checkXcnt != checkYcnt)\n            {\n                Console.WriteLine(\"0123\"); return;\n            }\n            if(checkXcnt + checkYcnt != id.Count)\n            {\n                Console.WriteLine(\"0\"); return;\n            }\n\n            //ここから木DPを書きます\n\n            long TempAns = 0;\n\n            for (int turn = 0; turn < 2; turn++)\n            {\n                foreach (var now in id)\n                {\n                    Xcnt[x[now]] = X[x[now]].Count;\n                    Ycnt[y[now]] = Y[y[now]].Count;\n                    color[now] = -1;\n                    es[now] = new List<int>();\n                    esp[now] = new List<int>();\n                    escount[now] = 0;\n                    dp[now] = 1;\n                    dp2[now] = 0;\n                }\n                \n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    if (Xcnt[x[now]] == 1)\n                    {\n                        color[now] = 0;\n                        q.Enqueue(now);\n                    }\n                    else if(Ycnt[y[now]] == 1)\n                    {\n                        color[now] = 1;\n                        q.Enqueue(now);\n                    }\n                }\n                \n                bool flag = false;\n                for (int t = 0; t < 2; t++)\n                {\n                    while (q.Count != 0)\n                    {\n                        int now = q.Dequeue();\n                        Xcnt[x[now]]--;\n                        Ycnt[y[now]]--;\n                        if (color[now] == 0)\n                        {\n                            if (Ycnt[y[now]] == 1)\n                            {\n                                foreach (var next in Y[y[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 1;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n\n                        }\n                        else\n                        {\n                            if (Xcnt[x[now]] == 1)\n                            {\n                                foreach (var next in X[x[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 0;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (t == 1) break;\n                    foreach (var now in id)\n                    {\n                        if(color[now] == -1)\n                        {\n                            flag = true;\n                            color[now] = turn;\n                            q.Enqueue(now);\n                            break;\n                        }\n                    }\n                }\n                if (!flag && turn == 1) break;\n                \n                foreach (var now in id)\n                {\n                    if(color[now] == 0)\n                    {\n                        /*\n                        int near = -1;\n                        int nearID = -1;\n\n                        foreach (var next in X[x[now]])\n                        {\n                            if(y[now] > y[next] && color[now] == color[next] && y[next] > near)\n                            {\n                                near = y[next];\n                                nearID = next;\n                            }\n                        }\n\n                        if(nearID != -1)\n                        {\n                            es[now].Add(nearID);\n                            esp[nearID].Add(now);\n                            escount[now]++;\n                        }\n                        \n                        foreach (var next in X[x[now]])\n                        {\n                            if (y[now] > y[next] && color[now] != color[next] && y[next] > near)\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        */\n                        \n                        foreach (var next in X[x[now]])\n                        {\n                            if (y[now] > y[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        \n                    }\n                    else\n                    {\n                        /*\n                        int near = -1;\n                        int nearID = -1;\n\n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next] && color[now] == color[next] && x[now] > near)\n                            {\n                                near = x[next];\n                                nearID = next;\n                            }\n                        }\n\n                        if (nearID != -1)\n                        {\n                            es[now].Add(nearID);\n                            esp[nearID].Add(now);\n                            escount[now]++;\n                        }\n\n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next] && color[now] != color[next] && x[next] > near)\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        */\n\n                        \n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        \n                    }\n                }\n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    //Console.WriteLine($\"escount[{now}] = {escount[now]} color[{now}] = {color[now]}\");\n                    if (escount[now] == 0) q.Enqueue(now);\n                }\n\n                int nowCnt = 0;\n                long Tmp = 1;\n                while(q.Count != 0)\n                {\n                    int now = q.Dequeue();\n                    //Console.WriteLine(\"nowID: \" + now);\n                    \n                    foreach (var next in es[now])\n                    {\n                        dp[now] *= dp[next];\n                        dp[now] %= mod;\n                        dp2[now] += dp2[next];\n                        dp[now] *= getC(dp2[now], dp2[next]);\n                        dp[now] %= mod;\n                    }\n\n                    dp2[now]++;\n                    if (esp[now].Count == 0)\n                    {\n                        Tmp *= dp[now];\n                        Tmp %= mod;\n                        nowCnt += dp2[now];\n                        Tmp *= getC(nowCnt, dp2[now]);\n                        Tmp %= mod;\n                        //Console.WriteLine(Tmp);\n                    }\n                    else\n                    {\n                        foreach (var next in esp[now])\n                        {\n                            escount[next]--;\n                            if (escount[next] == 0) q.Enqueue(next);\n                        }\n                    }\n                }\n                TempAns += Tmp;\n                TempAns %= mod;\n                //Console.WriteLine(id.Count + \" \" + nowCnt + \" \" + Tmp);\n            }\n            ans *= TempAns;\n            ans %= mod;\n            nowSum += id.Count;\n            ans *= getC(nowSum, id.Count);\n            ans %= mod;\n            //Console.WriteLine(ans);\n        }\n        Console.WriteLine(ans);\n\n    }\n\n    long mod = 1000000007;\n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n\n    long[] fact; //階乗\n    long[] revFact; //階乗の逆元\n    void setFact(int N)\n    {\n        fact = new long[N];\n        revFact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= mod;\n        }\n        revFact[N - 1] = powmod(fact[N - 1], mod - 2);\n        for (int i = N - 2; i >= 0; i--)\n        {\n            revFact[i] = revFact[i + 1] * (i + 1);\n            revFact[i] %= mod;\n        }\n    }\n\n\n    long getC(int a, int b)\n    {\n        return (((fact[a] * revFact[b]) % mod) * revFact[a - b]) % mod;\n    }\n\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    List<int>[] G;\n    List<long>[] C;\n    List<int>[] G2;\n    List<int>[] G3;\n    long[] revE;\n    long[] regE;\n    int[] child2;\n    int[] child3;\n    long[] ways2;\n    long[] ways3;\n    bool[] us2;\n    bool[] us3;\n    long count;\n    Fact F;\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        long[] E = new long[2*N];\n        for(int i=0;i<2*N;i++){\n            E[i] = (re.l()-1) * N + re.i()-1;\n        }\n        Array.Sort(E);\n        G = new List<int>[2*N];\n        C = new List<long>[2*N];\n        for(int i=0;i<2*N;i++){\n            G[i] = new List<int>();\n            C[i] = new List<long>();\n        }\n        for(int i=0;i<2*N;i++){\n            int x = (int)(E[i] / N);\n            int y = (int)(E[i] % N);\n            G[x].Add(y+N);\n            G[y+N].Add(x);\n            C[x].Add(E[i]);\n            C[y+N].Add(E[i]);\n        }\n        regE = new long[2*N];\n        revE = new long[2*N];\n        int[] O = new int[2*N];\n        for(int i=0;i<2*N;i++){\n            O[i] = G[i].Count - 1;\n        }\n        int[] stack = new int[2*N];\n        int p = 0;\n        for(int i=0;i<2*N;i++){\n            if(O[i] == 0){\n                stack[p] = i;\n                p++;\n            }\n        }\n        while(p != 0){\n            int v = stack[p-1];\n            p--;\n            bool b = false;\n            for(int i=0;i<G[v].Count;i++){\n                int t = G[v][i];\n                if(O[t] != 0){\n                    O[t]--;\n                    regE[v] = C[v][i];\n                    revE[v] = C[v][i];\n                    b = true;\n                    if(O[t] == 0){\n                        stack[p] = t;\n                        p++;\n                    }\n                }\n            }\n            if(!b){\n                sb.Append(\"0\\n\");\n                return;\n            }\n        }\n        bool[] us = new bool[2*N];\n        bool[] us4 = new bool[2*N];\n        for(int i=0;i<2*N;i++){\n            if(O[i] != 0 && O[i] != 1){\n                sb.Append(\"0\\n\");\n                return;\n            }\n            else if(O[i] == 1 && !us[i]){\n                int v = i;\n                GetCycle(v,-1,O,us);\n                GetCycle2(v,-1,O,us4);\n            }\n        }\n        Compression Comp = new Compression(E);\n        long[] E2 = new long[2*N];\n        for(int i=0;i<2*N;i++){\n            E2[i] = E[i];\n        }\n        G2 = new List<int>[2*N];\n        G3 = new List<int>[2*N];\n        for(int i=0;i<2*N;i++){\n            G2[i] = new List<int>();\n            G3[i] = new List<int>();\n        }\n        Array.Sort(E2,(x,y)=>(x % N == y % N ? (int)((x - y)/N) : (int)((x % N) - (y % N))));\n        for(int i=0;i<N;i++){\n            int x = i;\n            int y = (int)(regE[i]%N);\n            int bf = 0;\n            int bl = 2*N-1;\n            while(bf != bl){\n                int bc = (bf+bl)/2;\n                if(E[bc]/N >= x){\n                    bl = bc;\n                }\n                else{\n                    bf = bc+1;\n                }\n            }\n            int v = Comp.ToPoint(regE[i]);\n            for(int j=bf;E[j]/N == x && E[j]%N < y;j++){\n                G2[v].Add(j);\n            }\n            x = i;\n            y = (int)(revE[i]%N);\n            bf = 0;\n            bl = 2*N-1;\n            while(bf != bl){\n                int bc = (bf+bl)/2;\n                if(E[bc]/N >= x){\n                    bl = bc;\n                }\n                else{\n                    bf = bc+1;\n                }\n            }\n            v = Comp.ToPoint(revE[i]);\n            for(int j=bf;E[j]/N == x && E[j]%N < y;j++){\n                G3[v].Add(j);\n            }\n            y = i;\n            x = (int)(regE[N+i]/N);\n            bf = 0;\n            bl = 2*N-1;\n            while(bf != bl){\n                int bc = (bf+bl)/2;\n                if(E2[bc] % N >= y){\n                    bl = bc;\n                }\n                else{\n                    bf = bc+1;\n                }\n            }\n            v = Comp.ToPoint(regE[N+i]);\n            for(int j=bf;E2[j]%N == y && E2[j]/N < x;j++){\n                G2[v].Add(Comp.ToPoint(E2[j]));\n            }\n            y = i;\n            x = (int)(revE[N+i]/N);\n            bf = 0;\n            bl = 2*N-1;\n            while(bf != bl){\n                int bc = (bf+bl)/2;\n                if(E2[bc] % N >= y){\n                    bl = bc;\n                }\n                else{\n                    bf = bc+1;\n                }\n            }\n            v = Comp.ToPoint(revE[N+i]);\n            for(int j=bf;E2[j]%N == y && E2[j]/N < x;j++){\n                G3[v].Add(Comp.ToPoint(E2[j]));\n            }\n        }\n        F = new Fact(2*N);\n        us2 = new bool[2*N];\n        us3 = new bool[2*N];\n        child2 = new int[2*N];\n        child3 = new int[2*N];\n        count = 1;\n        int D = 2*N;\n        ways2 = new long[2*N];\n        ways3 = new long[2*N];\n        for(int i=0;i<2*N;i++){\n            if(!us2[i]){\n                GetChild2(i);\n            }\n            if(!us3[i]){\n                GetChild3(i);\n            }\n        }\n        for(int i=0;i<2*N;i++){\n            us2[i] = false;\n            us3[i] = false;\n            us[i] = false;\n        }\n        for(int i=0;i<2*N;i++){\n            if(!us2[i]){\n                dfs2(i);\n            }\n            if(!us3[i]){\n                dfs3(i);\n            }\n        }\n        for(int i=0;i<2*N;i++){\n            if(!us[i]){\n                int pp = 1;\n                stack[0] = i;\n                us[i] = true;\n                for(int j=0;j<pp;j++){\n                    int v = stack[j];\n                    for(int k=0;k<G[v].Count;k++){\n                        int t = G[v][k];\n                        if(!us[t]){\n                            stack[pp] = t;\n                            pp++;\n                            us[t] = true;\n                        }\n                    }\n                }\n                count = count * F.GetConv(D,pp) % Define.mod;\n                D -= pp;\n                int d1 = pp;\n                int d2 = pp;\n                long count1 = 1;\n                long count2 = 1;\n                for(int j=0;j<pp;j++){\n                    int v2 = Comp.ToPoint(regE[stack[j]]);\n                    count1 = count1 * ways2[v2] % Define.mod * F.GetConv(d1,child2[v2]) % Define.mod;\n                    d1 -= child2[v2];\n                    int v3 = Comp.ToPoint(revE[stack[j]]);\n                    count2 = count2 * ways3[v3] % Define.mod * F.GetConv(d2,child3[v3]) % Define.mod;\n                    d2 -= child3[v3];\n                }\n                count = count * (count1+count2) % Define.mod;\n            }\n        }\n        sb.Append(count+\"\\n\");\n    }\n    \n    void GetCycle(int v,int f,int[] O,bool[] us4){\n        us4[v] = true;\n        for(int i=0;i<G[v].Count;i++){\n            int t = G[v][i];\n            if(O[t] == 1 && t != f){\n                regE[v] = C[v][i];\n                if(!us4[t]){\n                    GetCycle(t,v,O,us4);\n                }\n                break;\n            }\n        }\n    }\n    void GetCycle2(int v,int f,int[] O,bool[] us4){\n        us4[v] = true;\n        for(int i=G[v].Count-1;i>=0;i--){\n            int t = G[v][i];\n            if(O[t] == 1 && t != f){\n                revE[v] = C[v][i];\n                if(!us4[t]){\n                    GetCycle2(t,v,O,us4);\n                }\n                break;\n            }\n        }\n    }\n    void GetChild3(int v){\n        int c = 1;\n        us3[v] = true;\n        for(int i=0;i<G3[v].Count;i++){\n            int t = G3[v][i];\n            if(!us3[t]){\n                GetChild3(t);\n            }\n            c += child3[t];\n        }\n        child3[v] = c;\n    }\n    void GetChild2(int v){\n        int c = 1;\n        us2[v] = true;\n        for(int i=0;i<G2[v].Count;i++){\n            int t = G2[v][i];\n            if(!us2[t]){\n                GetChild2(t);\n            }\n            c += child2[t];\n        }\n        child2[v] = c;\n    }\n    void dfs2(int v){\n        long c = 1;\n        int d = child2[v]-1;\n        us2[v] = true;\n        for(int i=0;i<G2[v].Count;i++){\n            int t = G2[v][i];\n            if(!us2[t]){\n                dfs2(t);\n            }\n            c = c * F.GetConv(d,child2[t]) % Define.mod * ways2[t] % Define.mod;\n            d -= child2[t];\n            child2[t] = 0;\n            ways2[t] = 1;\n        }\n        ways2[v] = c;\n    }\n    void dfs3(int v){\n        long c = 1;\n        int d = child3[v]-1;\n        us3[v] = true;\n        for(int i=0;i<G3[v].Count;i++){\n            int t = G3[v][i];\n            if(!us3[t]){\n                dfs3(t);\n            }\n            c = c * F.GetConv(d,child3[t]) % Define.mod * ways3[t] % Define.mod;\n            d -= child3[t];\n            child3[t] = 0;\n            ways3[t] = 1;\n        }\n        ways3[v] = c;\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n}\nclass Compression{\n    public int size;\n    public long[] A;\n    public Compression(long[] a){\n        long[] b = new long[a.Length];\n        for(int i=0;i<a.Length;i++){\n            b[i] = a[i];\n        }\n        a = b;\n        Array.Sort(a);\n        List<long> AL = new List<long>();\n        AL.Add(a[0]);\n        for(int i=1;i<a.Length;i++){\n            if(a[i] != a[i-1]){\n                AL.Add(a[i]);\n            }\n        }\n        A = AL.ToArray();\n        size = A.Length;\n    }\n    public int ToPoint(long X){\n        int bf = 0;\n        int bl = size-1;\n        while(bf != bl){\n            int bc = (bf+bl)/2;\n            if(A[bc] >= X){\n                bl = bc;\n            }\n            else{\n                bf = bc+1;\n            }\n        }\n        return bf;\n    }\n    public long Value(int i){\n        return A[i];\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        setFact(300000);\n        int N = cin.nextInt();\n        int[] x = new int[2 * N];\n        int[] y = new int[2 * N];\n        for (int i = 0; i < 2 * N; i++)\n        {\n            x[i] = cin.nextInt() - 1;\n            y[i] = cin.nextInt() - 1;\n        }\n\n        List<int>[] X = new List<int>[N];\n        List<int>[] Y = new List<int>[N];\n        for (int i = 0; i < N; i++)\n        {\n            X[i] = new List<int>();\n            Y[i] = new List<int>();\n        }\n\n        int[] Xcnt = new int[N];\n        int[] Ycnt = new int[N];\n\n        for (int i = 0; i < 2 * N; i++)\n        {\n            X[x[i]].Add(i);\n            Y[y[i]].Add(i);\n            Xcnt[x[i]]++;\n            Ycnt[y[i]]++;\n        }\n        \n        for (int i = 0; i < N; i++)\n        {\n            if(X[i].Count == 0 || Y[i].Count == 0)\n            {\n                Console.WriteLine(0); return;\n            }\n        }\n\n        bool[] checkX = new bool[N];\n        bool[] checkY = new bool[N];\n\n        bool[] used = new bool[2 * N];\n        long ans = 1;\n        long mod = 1000000007;\n\n        int[] color = new int[2 * N];\n        List<int>[] es = new List<int>[2 * N];\n        List<int>[] esp = new List<int>[2 * N];\n        int[] escount = new int[2 * N];\n        long[] dp = new long[2 * N];\n        int[] dp2 = new int[2 * N];\n\n        int nowSum = 0;\n        for (int i = 0; i < x.Length; i++)\n        {\n            if (used[i]) continue;\n            Queue<int> q = new Queue<int>();\n            List<int> id = new List<int>();\n            id.Add(i);\n            q.Enqueue(i);\n            used[i] = true;\n            int checkXcnt = 0;\n            int checkYcnt = 0;\n\n            while (q.Count != 0)\n            {\n                int now = q.Dequeue();\n                if (!checkX[x[now]])\n                {\n                    checkX[x[now]] = true;\n                    checkXcnt++;\n                }\n                if (!checkY[y[now]])\n                {\n                    checkY[y[now]] = true;\n                    checkYcnt++;\n                }\n                foreach (var next in X[x[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n                foreach (var next in Y[y[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n            }\n\n            //if(checkXcnt != checkYcnt)\n            //{\n            //    Console.WriteLine(\"0\"); return;\n            //}\n            if(checkXcnt + checkYcnt != id.Count)\n            {\n                Console.WriteLine(\"0\"); return;\n            }\n\n            //ここから木DPを書きます\n\n            long TempAns = 0;\n\n            for (int turn = 0; turn < 2; turn++)\n            {\n                foreach (var now in id)\n                {\n                    Xcnt[x[now]] = X[x[now]].Count;\n                    Ycnt[y[now]] = Y[y[now]].Count;\n                    color[now] = -1;\n                    es[now] = new List<int>();\n                    esp[now] = new List<int>();\n                    escount[now] = 0;\n                    dp[now] = 1;\n                    dp2[now] = 0;\n                }\n                \n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    if (Xcnt[x[now]] == 1)\n                    {\n                        color[now] = 0;\n                        q.Enqueue(now);\n                    }\n                    else if(Ycnt[y[now]] == 1)\n                    {\n                        color[now] = 1;\n                        q.Enqueue(now);\n                    }\n                }\n                \n                bool flag = false;\n                for (int t = 0; t < 2; t++)\n                {\n                    while (q.Count != 0)\n                    {\n                        int now = q.Dequeue();\n                        Xcnt[x[now]]--;\n                        Ycnt[y[now]]--;\n                        if (color[now] == 0)\n                        {\n                            if (Ycnt[y[now]] == 1)\n                            {\n                                foreach (var next in Y[y[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 1;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n\n                        }\n                        else\n                        {\n                            if (Xcnt[x[now]] == 1)\n                            {\n                                foreach (var next in X[x[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 0;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (t == 1) break;\n                    foreach (var now in id)\n                    {\n                        if(color[now] == -1)\n                        {\n                            flag = true;\n                            color[now] = turn;\n                            q.Enqueue(now);\n                            break;\n                        }\n                    }\n                }\n                if (!flag && turn == 1) break;\n                \n                foreach (var now in id)\n                {\n                    if(color[now] == 0)\n                    {\n                        /*\n                        int near = -1;\n                        int nearID = -1;\n\n                        foreach (var next in X[x[now]])\n                        {\n                            if(y[now] > y[next] && color[now] == color[next] && y[next] > near)\n                            {\n                                near = y[next];\n                                nearID = next;\n                            }\n                        }\n\n                        if(nearID != -1)\n                        {\n                            es[now].Add(nearID);\n                            esp[nearID].Add(now);\n                            escount[now]++;\n                        }\n                        \n                        foreach (var next in X[x[now]])\n                        {\n                            if (y[now] > y[next] && color[now] != color[next] && y[next] > near)\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        */\n                        \n                        foreach (var next in X[x[now]])\n                        {\n                            if (y[now] > y[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        \n                    }\n                    else\n                    {\n                        /*\n                        int near = -1;\n                        int nearID = -1;\n\n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next] && color[now] == color[next] && x[now] > near)\n                            {\n                                near = x[next];\n                                nearID = next;\n                            }\n                        }\n\n                        if (nearID != -1)\n                        {\n                            es[now].Add(nearID);\n                            esp[nearID].Add(now);\n                            escount[now]++;\n                        }\n\n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next] && color[now] != color[next] && x[next] > near)\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        */\n\n                        \n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        \n                    }\n                }\n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    //Console.WriteLine($\"escount[{now}] = {escount[now]} color[{now}] = {color[now]}\");\n                    if (escount[now] == 0) q.Enqueue(now);\n                }\n\n                int nowCnt = 0;\n                long Tmp = 1;\n                while(q.Count != 0)\n                {\n                    int now = q.Dequeue();\n                    //Console.WriteLine(\"nowID: \" + now);\n                    \n                    foreach (var next in es[now])\n                    {\n                        dp[now] *= dp[next];\n                        dp[now] %= mod;\n                        dp2[now] += dp2[next];\n                        dp[now] *= getC(dp2[now], dp2[next]);\n                        dp[now] %= mod;\n                    }\n\n                    dp2[now]++;\n                    if (esp[now].Count == 0)\n                    {\n                        Tmp *= dp[now];\n                        Tmp %= mod;\n                        nowCnt += dp2[now];\n                        Tmp *= getC(nowCnt, dp2[now]);\n                        Tmp %= mod;\n                        //Console.WriteLine(Tmp);\n                    }\n                    else\n                    {\n                        foreach (var next in esp[now])\n                        {\n                            escount[next]--;\n                            if (escount[next] == 0) q.Enqueue(next);\n                        }\n                    }\n                }\n                TempAns += Tmp;\n                TempAns %= mod;\n                //Console.WriteLine(id.Count + \" \" + nowCnt + \" \" + Tmp);\n            }\n            ans *= TempAns;\n            ans %= mod;\n            nowSum += id.Count;\n            ans *= getC(nowSum, id.Count);\n            ans %= mod;\n            //Console.WriteLine(ans);\n        }\n        Console.WriteLine(ans);\n\n    }\n\n    long mod = 1000000007;\n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n\n    long[] fact; //階乗\n    long[] revFact; //階乗の逆元\n    void setFact(int N)\n    {\n        fact = new long[N];\n        revFact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= mod;\n        }\n        revFact[N - 1] = powmod(fact[N - 1], mod - 2);\n        for (int i = N - 2; i >= 0; i--)\n        {\n            revFact[i] = revFact[i + 1] * (i + 1);\n            revFact[i] %= mod;\n        }\n    }\n\n\n    long getC(int a, int b)\n    {\n        return (((fact[a] * revFact[b]) % mod) * revFact[a - b]) % mod;\n    }\n\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        setFact(300000);\n        int N = cin.nextInt();\n        int[] x = new int[2 * N];\n        int[] y = new int[2 * N];\n        for (int i = 0; i < 2 * N; i++)\n        {\n            x[i] = cin.nextInt() - 1;\n            y[i] = cin.nextInt() - 1;\n        }\n\n        List<int>[] X = new List<int>[N];\n        List<int>[] Y = new List<int>[N];\n        for (int i = 0; i < N; i++)\n        {\n            X[i] = new List<int>();\n            Y[i] = new List<int>();\n        }\n\n        int[] Xcnt = new int[N];\n        int[] Ycnt = new int[N];\n\n        for (int i = 0; i < 2 * N; i++)\n        {\n            X[x[i]].Add(i);\n            Y[y[i]].Add(i);\n            Xcnt[x[i]]++;\n            Ycnt[y[i]]++;\n        }\n        \n        for (int i = 0; i < N; i++)\n        {\n            if(X[i].Count == 0 || Y[i].Count == 0)\n            {\n                Console.WriteLine(0); return;\n            }\n        }\n\n        bool[] checkX = new bool[N];\n        bool[] checkY = new bool[N];\n\n        bool[] used = new bool[2 * N];\n        long ans = 1;\n        long mod = 1000000007;\n\n        int[] color = new int[2 * N];\n        List<int>[] es = new List<int>[2 * N];\n        List<int>[] esp = new List<int>[2 * N];\n        int[] escount = new int[2 * N];\n        long[] dp = new long[2 * N];\n        int[] dp2 = new int[2 * N];\n\n        int nowSum = 0;\n        for (int i = 0; i < x.Length; i++)\n        {\n            if (used[i]) continue;\n            Queue<int> q = new Queue<int>();\n            List<int> id = new List<int>();\n            id.Add(i);\n            q.Enqueue(i);\n            used[i] = true;\n            int checkXcnt = 0;\n            int checkYcnt = 0;\n\n            while (q.Count != 0)\n            {\n                int now = q.Dequeue();\n                if (!checkX[x[now]])\n                {\n                    checkX[x[now]] = true;\n                    checkXcnt++;\n                }\n                if (!checkY[y[now]])\n                {\n                    checkY[y[now]] = true;\n                    checkYcnt++;\n                }\n                foreach (var next in X[x[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n                foreach (var next in Y[y[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n            }\n\n            //if(checkXcnt != checkYcnt)\n            //{\n            //    Console.WriteLine(\"0123\"); return;\n            //}\n            if(checkXcnt + checkYcnt != id.Count)\n            {\n                Console.WriteLine(\"0\"); return;\n            }\n\n            //ここから木DPを書きます\n\n            long TempAns = 0;\n\n            for (int turn = 0; turn < 2; turn++)\n            {\n                foreach (var now in id)\n                {\n                    Xcnt[x[now]] = X[x[now]].Count;\n                    Ycnt[y[now]] = Y[y[now]].Count;\n                    color[now] = -1;\n                    es[now] = new List<int>();\n                    esp[now] = new List<int>();\n                    escount[now] = 0;\n                    dp[now] = 1;\n                    dp2[now] = 0;\n                }\n                \n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    if (Xcnt[x[now]] == 1)\n                    {\n                        color[now] = 0;\n                        q.Enqueue(now);\n                    }\n                    else if(Ycnt[y[now]] == 1)\n                    {\n                        color[now] = 1;\n                        q.Enqueue(now);\n                    }\n                }\n                \n                bool flag = false;\n                for (int t = 0; t < 2; t++)\n                {\n                    while (q.Count != 0)\n                    {\n                        int now = q.Dequeue();\n                        Xcnt[x[now]]--;\n                        Ycnt[y[now]]--;\n                        if (color[now] == 0)\n                        {\n                            if (Ycnt[y[now]] == 1)\n                            {\n                                foreach (var next in Y[y[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 1;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n\n                        }\n                        else\n                        {\n                            if (Xcnt[x[now]] == 1)\n                            {\n                                foreach (var next in X[x[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 0;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (t == 1) break;\n                    foreach (var now in id)\n                    {\n                        if(color[now] == -1)\n                        {\n                            flag = true;\n                            color[now] = turn;\n                            q.Enqueue(now);\n                            break;\n                        }\n                    }\n                }\n                if (!flag && turn == 1) break;\n\n                foreach (var now in id)\n                {\n                    if(color[now] == 0)\n                    {\n                        foreach (var next in X[x[now]])\n                        {\n                            if(y[now] > y[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                    }\n                }\n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    //Console.WriteLine($\"escount[{now}] = {escount[now]} color[{now}] = {color[now]}\");\n                    if (escount[now] == 0) q.Enqueue(now);\n                }\n\n                int nowCnt = 0;\n                long Tmp = 1;\n                while(q.Count != 0)\n                {\n                    int now = q.Dequeue();\n                    //Console.WriteLine(\"nowID: \" + now);\n\n                    int partsCnt = 0;\n                    foreach (var next in es[now])\n                    {\n                        dp[now] *= dp[next];\n                        dp[now] %= mod;\n                        dp2[now] += dp2[next];\n                        dp[now] *= getC(dp2[now], dp2[next]);\n                    }\n\n                    dp2[now]++;\n                    if (esp[now].Count == 0)\n                    {\n                        Tmp *= dp[now];\n                        Tmp %= mod;\n                        nowCnt += dp2[now];\n                        Tmp *= getC(nowCnt, dp2[now]);\n                        Tmp %= mod;\n                        //Console.WriteLine(Tmp);\n                    }\n                    else\n                    {\n                        foreach (var next in esp[now])\n                        {\n                            escount[next]--;\n                            if (escount[next] == 0) q.Enqueue(next);\n                        }\n                    }\n                }\n                TempAns += Tmp;\n                TempAns %= mod;\n                //Console.WriteLine(Tmp + \" \" + nowCnt);\n            }\n            ans *= TempAns;\n            ans %= mod;\n            nowSum += id.Count;\n            ans *= getC(nowSum, id.Count);\n            ans %= mod;\n            //Console.WriteLine(ans);\n        }\n        Console.WriteLine(ans);\n\n    }\n\n    long mod = 1000000007;\n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n\n    long[] fact; //階乗\n    long[] revFact; //階乗の逆元\n    void setFact(int N)\n    {\n        fact = new long[N];\n        revFact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= mod;\n        }\n        revFact[N - 1] = powmod(fact[N - 1], mod - 2);\n        for (int i = N - 2; i >= 0; i--)\n        {\n            revFact[i] = revFact[i + 1] * (i + 1);\n            revFact[i] %= mod;\n        }\n    }\n\n\n    long getC(int a, int b)\n    {\n        return (((fact[a] * revFact[b]) % mod) * revFact[a - b]) % mod;\n    }\n\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        setFact(300000);\n        int N = cin.nextInt();\n        int[] x = new int[2 * N];\n        int[] y = new int[2 * N];\n        for (int i = 0; i < 2 * N; i++)\n        {\n            x[i] = cin.nextInt() - 1;\n            y[i] = cin.nextInt() - 1;\n        }\n\n        List<int>[] X = new List<int>[N];\n        List<int>[] Y = new List<int>[N];\n        for (int i = 0; i < N; i++)\n        {\n            X[i] = new List<int>();\n            Y[i] = new List<int>();\n        }\n\n        int[] Xcnt = new int[N];\n        int[] Ycnt = new int[N];\n\n        for (int i = 0; i < 2 * N; i++)\n        {\n            X[x[i]].Add(i);\n            Y[y[i]].Add(i);\n            Xcnt[x[i]]++;\n            Ycnt[y[i]]++;\n        }\n        \n        for (int i = 0; i < N; i++)\n        {\n            if(X[i].Count == 0 || Y[i].Count == 0)\n            {\n                Console.WriteLine(0); return;\n            }\n        }\n\n        bool[] checkX = new bool[N];\n        bool[] checkY = new bool[N];\n\n        bool[] used = new bool[2 * N];\n        long ans = 1;\n        long mod = 1000000007;\n\n        int[] color = new int[2 * N];\n        List<int>[] es = new List<int>[2 * N];\n        List<int>[] esp = new List<int>[2 * N];\n        int[] escount = new int[2 * N];\n        long[] dp = new long[2 * N];\n        int[] dp2 = new int[2 * N];\n\n        int nowSum = 0;\n        for (int i = 0; i < x.Length; i++)\n        {\n            if (used[i]) continue;\n            Queue<int> q = new Queue<int>();\n            List<int> id = new List<int>();\n            id.Add(i);\n            q.Enqueue(i);\n            used[i] = true;\n            int checkXcnt = 0;\n            int checkYcnt = 0;\n\n            while (q.Count != 0)\n            {\n                int now = q.Dequeue();\n                if (!checkX[x[now]])\n                {\n                    checkX[x[now]] = true;\n                    checkXcnt++;\n                }\n                if (!checkY[y[now]])\n                {\n                    checkY[y[now]] = true;\n                    checkYcnt++;\n                }\n                foreach (var next in X[x[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n                foreach (var next in Y[y[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n            }\n\n            if(checkXcnt != checkYcnt)\n            {\n                Console.WriteLine(\"0\"); return;\n            }\n            if(checkXcnt + checkYcnt != id.Count)\n            {\n                Console.WriteLine(\"0\"); return;\n            }\n\n            //ここから木DPを書きます\n\n            long TempAns = 0;\n\n            for (int turn = 0; turn < 2; turn++)\n            {\n                foreach (var now in id)\n                {\n                    Xcnt[x[now]] = X[x[now]].Count;\n                    Ycnt[y[now]] = Y[y[now]].Count;\n                    color[now] = -1;\n                    es[now] = new List<int>();\n                    esp[now] = new List<int>();\n                    escount[now] = 0;\n                    dp[now] = 1;\n                    dp2[now] = 0;\n                }\n                \n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    if (Xcnt[x[now]] == 1)\n                    {\n                        color[now] = 0;\n                        q.Enqueue(now);\n                    }\n                    else if(Ycnt[y[now]] == 1)\n                    {\n                        color[now] = 1;\n                        q.Enqueue(now);\n                    }\n                }\n                \n                bool flag = false;\n                for (int t = 0; t < 2; t++)\n                {\n                    while (q.Count != 0)\n                    {\n                        int now = q.Dequeue();\n                        Xcnt[x[now]]--;\n                        Ycnt[y[now]]--;\n                        if (color[now] == 0)\n                        {\n                            if (Ycnt[y[now]] == 1)\n                            {\n                                foreach (var next in Y[y[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 1;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n\n                        }\n                        else\n                        {\n                            if (Xcnt[x[now]] == 1)\n                            {\n                                foreach (var next in X[x[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 0;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (t == 1) break;\n                    foreach (var now in id)\n                    {\n                        if(color[now] == -1)\n                        {\n                            flag = true;\n                            color[now] = turn;\n                            q.Enqueue(now);\n                            break;\n                        }\n                    }\n                }\n                if (!flag && turn == 1) break;\n                \n                foreach (var now in id)\n                {\n                    if(color[now] == 0)\n                    {\n                        /*\n                        int near = -1;\n                        int nearID = -1;\n\n                        foreach (var next in X[x[now]])\n                        {\n                            if(y[now] > y[next] && color[now] == color[next] && y[next] > near)\n                            {\n                                near = y[next];\n                                nearID = next;\n                            }\n                        }\n\n                        if(nearID != -1)\n                        {\n                            es[now].Add(nearID);\n                            esp[nearID].Add(now);\n                            escount[now]++;\n                        }\n                        \n                        foreach (var next in X[x[now]])\n                        {\n                            if (y[now] > y[next] && color[now] != color[next] && y[next] > near)\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        */\n                        \n                        foreach (var next in X[x[now]])\n                        {\n                            if (y[now] > y[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        \n                    }\n                    else\n                    {\n                        /*\n                        int near = -1;\n                        int nearID = -1;\n\n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next] && color[now] == color[next] && x[now] > near)\n                            {\n                                near = x[next];\n                                nearID = next;\n                            }\n                        }\n\n                        if (nearID != -1)\n                        {\n                            es[now].Add(nearID);\n                            esp[nearID].Add(now);\n                            escount[now]++;\n                        }\n\n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next] && color[now] != color[next] && x[next] > near)\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        */\n\n                        \n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                        \n                    }\n                }\n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    //Console.WriteLine($\"escount[{now}] = {escount[now]} color[{now}] = {color[now]}\");\n                    if (escount[now] == 0) q.Enqueue(now);\n                }\n\n                int nowCnt = 0;\n                long Tmp = 1;\n                while(q.Count != 0)\n                {\n                    int now = q.Dequeue();\n                    //Console.WriteLine(\"nowID: \" + now);\n                    \n                    foreach (var next in es[now])\n                    {\n                        dp[now] *= dp[next];\n                        dp[now] %= mod;\n                        dp2[now] += dp2[next];\n                        dp[now] *= getC(dp2[now], dp2[next]);\n                        dp[now] %= mod;\n                    }\n\n                    dp2[now]++;\n                    if (esp[now].Count == 0)\n                    {\n                        Tmp *= dp[now];\n                        Tmp %= mod;\n                        nowCnt += dp2[now];\n                        Tmp *= getC(nowCnt, dp2[now]);\n                        Tmp %= mod;\n                        //Console.WriteLine(Tmp);\n                    }\n                    else\n                    {\n                        foreach (var next in esp[now])\n                        {\n                            escount[next]--;\n                            if (escount[next] == 0) q.Enqueue(next);\n                        }\n                    }\n                }\n                TempAns += Tmp;\n                TempAns %= mod;\n                //Console.WriteLine(id.Count + \" \" + nowCnt + \" \" + Tmp);\n            }\n            ans *= TempAns;\n            ans %= mod;\n            nowSum += id.Count;\n            ans *= getC(nowSum, id.Count);\n            ans %= mod;\n            //Console.WriteLine(ans);\n        }\n        Console.WriteLine(ans);\n\n    }\n\n    long mod = 1000000007;\n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n\n    long[] fact; //階乗\n    long[] revFact; //階乗の逆元\n    void setFact(int N)\n    {\n        fact = new long[N];\n        revFact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= mod;\n        }\n        revFact[N - 1] = powmod(fact[N - 1], mod - 2);\n        for (int i = N - 2; i >= 0; i--)\n        {\n            revFact[i] = revFact[i + 1] * (i + 1);\n            revFact[i] %= mod;\n        }\n    }\n\n\n    long getC(int a, int b)\n    {\n        return (((fact[a] * revFact[b]) % mod) * revFact[a - b]) % mod;\n    }\n\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        setFact(300000);\n        int N = cin.nextInt();\n        int[] x = new int[2 * N];\n        int[] y = new int[2 * N];\n        for (int i = 0; i < 2 * N; i++)\n        {\n            x[i] = cin.nextInt() - 1;\n            y[i] = cin.nextInt() - 1;\n        }\n\n        List<int>[] X = new List<int>[N];\n        List<int>[] Y = new List<int>[N];\n        for (int i = 0; i < N; i++)\n        {\n            X[i] = new List<int>();\n            Y[i] = new List<int>();\n        }\n\n        int[] Xcnt = new int[N];\n        int[] Ycnt = new int[N];\n\n        for (int i = 0; i < 2 * N; i++)\n        {\n            X[x[i]].Add(i);\n            Y[y[i]].Add(i);\n            Xcnt[x[i]]++;\n            Ycnt[y[i]]++;\n        }\n        \n        for (int i = 0; i < N; i++)\n        {\n            if(X[i].Count == 0 || Y[i].Count == 0)\n            {\n                Console.WriteLine(0); return;\n            }\n        }\n\n        bool[] checkX = new bool[N];\n        bool[] checkY = new bool[N];\n\n        bool[] used = new bool[2 * N];\n        long ans = 1;\n        long mod = 1000000007;\n\n        int[] color = new int[2 * N];\n        List<int>[] es = new List<int>[2 * N];\n        List<int>[] esp = new List<int>[2 * N];\n        int[] escount = new int[2 * N];\n        long[] dp = new long[2 * N];\n        int[] dp2 = new int[2 * N];\n\n        int nowSum = 0;\n        for (int i = 0; i < x.Length; i++)\n        {\n            if (used[i]) continue;\n            Queue<int> q = new Queue<int>();\n            List<int> id = new List<int>();\n            id.Add(i);\n            q.Enqueue(i);\n            used[i] = true;\n            int checkXcnt = 0;\n            int checkYcnt = 0;\n\n            while (q.Count != 0)\n            {\n                int now = q.Dequeue();\n                if (!checkX[x[now]])\n                {\n                    checkX[x[now]] = true;\n                    checkXcnt++;\n                }\n                if (!checkY[y[now]])\n                {\n                    checkY[y[now]] = true;\n                    checkYcnt++;\n                }\n                foreach (var next in X[x[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n                foreach (var next in Y[y[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n            }\n\n            if(checkXcnt != checkYcnt)\n            {\n                Console.WriteLine(0); return;\n            }\n            if(checkXcnt * 2 != id.Count)\n            {\n                Console.WriteLine(0); return;\n            }\n\n            //ここから木DPを書きます\n\n            long TempAns = 0;\n\n            for (int turn = 0; turn < 2; turn++)\n            {\n                foreach (var now in id)\n                {\n                    Xcnt[x[now]] = X[x[now]].Count;\n                    Ycnt[y[now]] = Y[y[now]].Count;\n                    color[now] = -1;\n                    es[now] = new List<int>();\n                    esp[now] = new List<int>();\n                    escount[now] = 0;\n                    dp[now] = 1;\n                    dp2[now] = 0;\n                }\n                \n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    if (Xcnt[x[now]] == 1)\n                    {\n                        color[now] = 0;\n                        q.Enqueue(now);\n                    }\n                    else if(Ycnt[y[now]] == 1)\n                    {\n                        color[now] = 1;\n                        q.Enqueue(now);\n                    }\n                }\n\n                for (int t = 0; t < 2; t++)\n                {\n                    while (q.Count != 0)\n                    {\n                        int now = q.Dequeue();\n                        Xcnt[x[now]]--;\n                        Ycnt[y[now]]--;\n                        if (color[now] == 0)\n                        {\n                            if (Ycnt[y[now]] == 1)\n                            {\n                                foreach (var next in Y[y[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 1;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n\n                        }\n                        else\n                        {\n                            if (Xcnt[x[now]] == 1)\n                            {\n                                foreach (var next in X[x[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 0;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (t == 1) break;\n                    foreach (var now in id)\n                    {\n                        if(color[now] == -1)\n                        {\n                            color[now] = turn;\n                            q.Enqueue(now);\n                            break;\n                        }\n                    }\n                }\n\n                foreach (var now in id)\n                {\n                    if(color[now] == 0)\n                    {\n                        foreach (var next in X[x[now]])\n                        {\n                            if(y[now] > y[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                    }\n                }\n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    //Console.WriteLine($\"escount[{now}] = {escount[now]} color[{now}] = {color[now]}\");\n                    if (escount[now] == 0) q.Enqueue(now);\n                }\n\n                int nowCnt = 0;\n                long Tmp = 1;\n                while(q.Count != 0)\n                {\n                    int now = q.Dequeue();\n                    //Console.WriteLine(\"nowID: \" + now);\n\n                    int partsCnt = 0;\n                    foreach (var next in es[now])\n                    {\n                        dp[now] *= dp[next];\n                        dp[now] %= mod;\n                        dp2[now] += dp2[next];\n                        dp[now] *= getC(dp2[now], dp2[next]);\n                    }\n\n                    dp2[now]++;\n                    if (esp[now].Count == 0)\n                    {\n                        Tmp *= dp[now];\n                        Tmp %= mod;\n                        nowCnt += dp2[now];\n                        Tmp *= getC(nowCnt, dp2[now]);\n                        Tmp %= mod;\n                        //Console.WriteLine(Tmp);\n                    }\n                    else\n                    {\n                        foreach (var next in esp[now])\n                        {\n                            escount[next]--;\n                            if (escount[next] == 0) q.Enqueue(next);\n                        }\n                    }\n                }\n                TempAns += Tmp;\n                TempAns %= mod;\n                //Console.WriteLine(Tmp + \" \" + nowCnt);\n            }\n            ans *= TempAns;\n            ans %= mod;\n            nowSum += id.Count;\n            ans *= getC(nowSum, id.Count);\n            ans %= mod;\n            //Console.WriteLine(ans);\n        }\n        Console.WriteLine(ans);\n\n    }\n\n    long mod = 1000000007;\n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n\n    long[] fact; //階乗\n    long[] revFact; //階乗の逆元\n    void setFact(int N)\n    {\n        fact = new long[N];\n        revFact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= mod;\n        }\n        revFact[N - 1] = powmod(fact[N - 1], mod - 2);\n        for (int i = N - 2; i >= 0; i--)\n        {\n            revFact[i] = revFact[i + 1] * (i + 1);\n            revFact[i] %= mod;\n        }\n    }\n\n\n    long getC(int a, int b)\n    {\n        return (((fact[a] * revFact[b]) % mod) * revFact[a - b]) % mod;\n    }\n\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        setFact(300000);\n        int N = cin.nextInt();\n        int[] x = new int[2 * N];\n        int[] y = new int[2 * N];\n        for (int i = 0; i < 2 * N; i++)\n        {\n            x[i] = cin.nextInt() - 1;\n            y[i] = cin.nextInt() - 1;\n        }\n\n        List<int>[] X = new List<int>[N];\n        List<int>[] Y = new List<int>[N];\n        for (int i = 0; i < N; i++)\n        {\n            X[i] = new List<int>();\n            Y[i] = new List<int>();\n        }\n\n        int[] Xcnt = new int[N];\n        int[] Ycnt = new int[N];\n\n        for (int i = 0; i < 2 * N; i++)\n        {\n            X[x[i]].Add(i);\n            Y[y[i]].Add(i);\n            Xcnt[x[i]]++;\n            Ycnt[y[i]]++;\n        }\n        \n        for (int i = 0; i < N; i++)\n        {\n            if(X[i].Count == 0 || Y[i].Count == 0)\n            {\n                Console.WriteLine(0); return;\n            }\n        }\n\n        bool[] checkX = new bool[N];\n        bool[] checkY = new bool[N];\n\n        bool[] used = new bool[2 * N];\n        long ans = 1;\n        long mod = 1000000007;\n\n        int[] color = new int[2 * N];\n        List<int>[] es = new List<int>[2 * N];\n        List<int>[] esp = new List<int>[2 * N];\n        int[] escount = new int[2 * N];\n        long[] dp = new long[2 * N];\n        int[] dp2 = new int[2 * N];\n\n        int nowSum = 0;\n        for (int i = 0; i < x.Length; i++)\n        {\n            if (used[i]) continue;\n            Queue<int> q = new Queue<int>();\n            List<int> id = new List<int>();\n            id.Add(i);\n            q.Enqueue(i);\n            used[i] = true;\n            int checkXcnt = 0;\n            int checkYcnt = 0;\n\n            while (q.Count != 0)\n            {\n                int now = q.Dequeue();\n                if (!checkX[x[now]])\n                {\n                    checkX[x[now]] = true;\n                    checkXcnt++;\n                }\n                if (!checkY[y[now]])\n                {\n                    checkY[y[now]] = true;\n                    checkYcnt++;\n                }\n                foreach (var next in X[x[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n                foreach (var next in Y[y[now]])\n                {\n                    if (used[next]) continue;\n                    used[next] = true;\n                    q.Enqueue(next);\n                    id.Add(next);\n                    continue;\n                }\n            }\n\n            if(checkXcnt != checkYcnt)\n            {\n                Console.WriteLine(0); return;\n            }\n            if(checkXcnt * 2 != id.Count)\n            {\n                Console.WriteLine(0); return;\n            }\n\n            //ここから木DPを書きます\n\n            long TempAns = 0;\n\n            for (int turn = 0; turn < 2; turn++)\n            {\n                foreach (var now in id)\n                {\n                    Xcnt[x[now]] = X[x[now]].Count;\n                    Ycnt[y[now]] = Y[y[now]].Count;\n                    color[now] = -1;\n                    es[now] = new List<int>();\n                    esp[now] = new List<int>();\n                    escount[now] = 0;\n                    dp[now] = 1;\n                    dp2[now] = 0;\n                }\n                \n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    if (Xcnt[x[now]] == 1)\n                    {\n                        color[now] = 0;\n                        q.Enqueue(now);\n                    }\n                    else if(Ycnt[y[now]] == 1)\n                    {\n                        color[now] = 1;\n                        q.Enqueue(now);\n                    }\n                }\n                \n                bool flag = false;\n                for (int t = 0; t < 2; t++)\n                {\n                    while (q.Count != 0)\n                    {\n                        int now = q.Dequeue();\n                        Xcnt[x[now]]--;\n                        Ycnt[y[now]]--;\n                        if (color[now] == 0)\n                        {\n                            if (Ycnt[y[now]] == 1)\n                            {\n                                foreach (var next in Y[y[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 1;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n\n                        }\n                        else\n                        {\n                            if (Xcnt[x[now]] == 1)\n                            {\n                                foreach (var next in X[x[now]])\n                                {\n                                    if (color[next] == -1)\n                                    {\n                                        color[next] = 0;\n                                        q.Enqueue(next);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (t == 1) break;\n                    foreach (var now in id)\n                    {\n                        if(color[now] == -1)\n                        {\n                            flag = true;\n                            color[now] = turn;\n                            q.Enqueue(now);\n                            break;\n                        }\n                    }\n                }\n                if (!flag && turn == 1) break;\n\n                foreach (var now in id)\n                {\n                    if(color[now] == 0)\n                    {\n                        foreach (var next in X[x[now]])\n                        {\n                            if(y[now] > y[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        foreach (var next in Y[y[now]])\n                        {\n                            if (x[now] > x[next])\n                            {\n                                es[now].Add(next);\n                                esp[next].Add(now);\n                                escount[now]++;\n                            }\n                        }\n                    }\n                }\n\n                q = new Queue<int>();\n                foreach (var now in id)\n                {\n                    //Console.WriteLine($\"escount[{now}] = {escount[now]} color[{now}] = {color[now]}\");\n                    if (escount[now] == 0) q.Enqueue(now);\n                }\n\n                int nowCnt = 0;\n                long Tmp = 1;\n                while(q.Count != 0)\n                {\n                    int now = q.Dequeue();\n                    //Console.WriteLine(\"nowID: \" + now);\n\n                    int partsCnt = 0;\n                    foreach (var next in es[now])\n                    {\n                        dp[now] *= dp[next];\n                        dp[now] %= mod;\n                        dp2[now] += dp2[next];\n                        dp[now] *= getC(dp2[now], dp2[next]);\n                    }\n\n                    dp2[now]++;\n                    if (esp[now].Count == 0)\n                    {\n                        Tmp *= dp[now];\n                        Tmp %= mod;\n                        nowCnt += dp2[now];\n                        Tmp *= getC(nowCnt, dp2[now]);\n                        Tmp %= mod;\n                        //Console.WriteLine(Tmp);\n                    }\n                    else\n                    {\n                        foreach (var next in esp[now])\n                        {\n                            escount[next]--;\n                            if (escount[next] == 0) q.Enqueue(next);\n                        }\n                    }\n                }\n                TempAns += Tmp;\n                TempAns %= mod;\n                //Console.WriteLine(Tmp + \" \" + nowCnt);\n            }\n            ans *= TempAns;\n            ans %= mod;\n            nowSum += id.Count;\n            ans *= getC(nowSum, id.Count);\n            ans %= mod;\n            //Console.WriteLine(ans);\n        }\n        Console.WriteLine(ans);\n\n    }\n\n    long mod = 1000000007;\n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n\n    long[] fact; //階乗\n    long[] revFact; //階乗の逆元\n    void setFact(int N)\n    {\n        fact = new long[N];\n        revFact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= mod;\n        }\n        revFact[N - 1] = powmod(fact[N - 1], mod - 2);\n        for (int i = N - 2; i >= 0; i--)\n        {\n            revFact[i] = revFact[i + 1] * (i + 1);\n            revFact[i] %= mod;\n        }\n    }\n\n\n    long getC(int a, int b)\n    {\n        return (((fact[a] * revFact[b]) % mod) * revFact[a - b]) % mod;\n    }\n\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\nimport std.container.rbtree;\n// import dcomp.foundation, dcomp.scanner, dcomp.modint;\n// import dcomp.datastructure.unionfind;\n// import dcomp.container.deque;\n\nalias Mint = ModInt!(10^^9 + 7);\nint[] dec(int[] v) {\n    auto w = v.dup.sort!\"a<b\".uniq.array.assumeSorted;\n    return v.map!(x => w.lowerBound(x).length.to!int).array;\n}\n\n\nMint calc(int[] x, int[] y) {\n    int N = x.length.to!int;\n    int W = x.fold!\"max(a, b)\" + 1;\n    int H = y.fold!\"max(a, b)\" + 1;\n\n//    writeln(\"calc \", x, \" \", y);\n//    writeln(W, \" \", H, \" \", N);\n\n    if (W+H != N) return Mint(0);\n\n    int[] dx = (-1).repeat(W).array;\n    int[] dy = (-1).repeat(H).array;\n    Mint calc2() {\n\n//        writeln(\"calc2 \", dx, \" \", dy);\n        if (dx.count(-1)) return Mint(0);\n        if (dy.count(-1)) return Mint(0);\n        int[][] g = new int[][W+H];\n        bool[] leaf = new bool[W+H];\n        foreach (i; 0..N) {\n            assert((dx[x[i]] == y[i]) ^ (x[i] == dy[y[i]]));\n            if (dx[x[i]] == y[i] && dy[y[i]] > x[i]) {\n                g[y[i]+W] ~= x[i];\n                leaf[x[i]] = true;\n            }\n            if (x[i] == dy[y[i]] && dx[x[i]] > y[i]) {\n                g[x[i]] ~= y[i]+W;\n                leaf[y[i]+W] = true;\n            }\n        }\n\n        int[] sz = new int[N];\n        Mint[] D = new Mint[N];\n        void dfs(int p) {\n            sz[p] = 0;\n            D[p] = Mint(1);            \n            foreach (int d; g[p]) {\n                dfs(d);\n                sz[p] += sz[d];\n                D[p] *= C(sz[p], sz[d]) * D[d];\n            }\n            sz[p] += 1;\n        }\n        int M = N;\n        Mint sm = 1;\n        foreach (i; 0..N) {\n            if (leaf[i]) continue;\n            dfs(i);\n            sm *= C(M, sz[i]) * D[i];\n            M -= sz[i];\n        }\n        return sm;\n    }\n\n\n    auto cx = iota(W).map!(_ => redBlackTree!int()).array;\n    auto cy = iota(H).map!(_ => redBlackTree!int()).array;\n    foreach (i; 0..N) {\n        cx[x[i]].insert(i);\n        cy[y[i]].insert(i);\n    }\n    Deque!int q;\n    foreach (i; 0..W) {\n        if (cx[i].length == 0) return Mint(0);\n        if (cx[i].length == 1) q.insertBack(i);\n    }\n    foreach (i; 0..H) {\n        if (cy[i].length == 0) return Mint(0);\n        if (cy[i].length == 1) q.insertBack(W+i);\n    }\n    \n    bool[] used = new bool[N];\n    while (q.empty() == false) {\n        int id = q.back; q.removeBack;\n        int i;\n        if (id < W) {\n            //x\n            i = cx[id].front;\n            if (dx[x[i]] != -1) continue;\n            assert(dx[x[i]] == -1);\n            dx[x[i]] = y[i];\n        } else {\n            //y\n            id -= W;\n            i = cy[id].front;\n            if (dy[y[i]] != -1) continue;\n            assert(dy[y[i]] == -1);\n            dy[y[i]] = x[i];\n        }   \n        used[i] = true;\n        cx[x[i]].removeKey(i);\n        if (dx[x[i]] == -1) {\n            if (cx[x[i]].length == 0) return Mint(0);\n            if (cx[x[i]].length == 1) q.insertBack(x[i]);\n        }\n        cy[y[i]].removeKey(i);\n        if (dy[y[i]] == -1) {\n            if (cy[y[i]].length == 0) return Mint(0);\n            if (cy[y[i]].length == 1) q.insertBack(W+y[i]);\n        }\n    }\n\n//    writeln(cx.map!(t => t.length), \" \", cy.map!(t => t.length));\n//    writeln(dx, \" \", dy);\n\n    int[] p;\n    void dfs(int i, int d) {\n        if (used[i]) return;\n        p ~= i;\n        used[i] = true;\n        if (d == 0) {\n            assert(cx[x[i]].length == 2);\n            foreach (j; cx[x[i]]) {\n                if (i == j) continue;\n                dfs(j, 1-d);\n            }\n        } else {\n            assert(cy[y[i]].length == 2);\n            foreach (j; cy[y[i]]) {\n                if (i == j) continue;\n                dfs(j, 1-d);\n            }\n        }\n    }\n    foreach (i; 0..N) {\n        if (!used[i]) {\n            dfs(i, 0);\n            break;\n        }\n    }\n//    writeln(p);\n\n    Mint ans = 0;\n    foreach (c; 0..2) {\n        foreach (idx, i; p) {\n            if (idx % 2 == c) {\n                dx[x[i]] = y[i];\n            } else {\n                dy[y[i]] = x[i];\n            }\n        }\n        ans += calc2();\n    }\n    return ans;\n}\n\nMint solve() {\n    int n;\n    sc.read(n); n *= 2;\n    int[] x = new int[n], y = new int[n];\n    auto uf = UnionFind(n);\n    int[] xb = (-1).repeat(n/2).array;\n    int[] yb = (-1).repeat(n/2).array;\n    foreach (i; 0..n) {\n        sc.read(x[i], y[i]); x[i]--; y[i]--;\n        if (xb[x[i]] != -1) {\n            uf.merge(xb[x[i]], i);\n        }\n        xb[x[i]] = i;\n        if (yb[y[i]] != -1) {\n            uf.merge(yb[y[i]], i);\n        }\n        yb[y[i]] = i;\n    }\n\n    Mint ans = 1;\n    foreach (v; uf.groups) {\n        auto m = v.length.to!int;\n        if (m == 0) continue;\n        int[] nx = v.map!(i => x[i]).array.dec;\n        int[] ny = v.map!(i => y[i]).array.dec;\n        Mint u = calc(nx, ny);\n        ans *= C(n, m) * u;\n        n -= m;\n//        writeln(v);\n//        writeln(nx, \" \", ny);\n    }\n    return ans;\n}\n\nMint[] fact, iFac;\nstatic this() {\n    fact = factTable!Mint(1_000_000);\n    iFac = invFactTable!Mint(1_000_000);\n}\nMint C(int n, int k) {\n    if (n < 0 || n < k) return Mint(0);\n    return fact[n] * iFac[k] * iFac[n-k];\n}\n\nScanner sc;\nstatic this() {sc = new Scanner(stdin);}\nint main() {\n    writeln(solve());\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n) if (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U)(T x, U n, T e) if (isIntegral!U || is(U == BigInt)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/datastructure/unionfind.d */\n// module dcomp.datastructure.unionfind;\n\n \nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    int[] id;  \n    int[][] groups;  \n    int count;  \n     \n    this(int n) {\n        id = iota(n).array;\n        groups = iota(n).map!(a => [a]).array;\n        count = n;\n    }\n     \n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n     \n    int[] group(int i) {\n        return groups[id[i]];\n    }\n     \n    bool same(int a, int b) {\n        return id[a] == id[b];\n    }\n}\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(size_t(4), 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void clear() {\n            st = length = 0;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }\n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n    \n    Payload* p;\n    private void I() { if (mayNull && !p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (mayNull && !p) throw new RangeError();\n    }\n    static if (!mayNull) {\n        @disable this();\n    }\n     \n    private this(Payload* p) {\n        this.p = p;\n    }\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    static Deque make() { return Deque(new Payload()); }\n    @property bool havePayload() const { return (!mayNull || p); }\n     \n    @property bool empty() const { return (!havePayload || p.empty); }\n     \n    @property size_t length() const { return (havePayload ? p.length : 0); }\n     \n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n     \n    ref inout(T) front() inout {C; return (*p)[0]; }\n     \n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void clear() { if (p) p.clear(); }\n     \n    void insertFront(T v) {I; p.insertFront(v); }\n     \n    void insertBack(T v) {I; p.insertBack(v); }\n     \n    alias stableInsertBack = insertBack;\n     \n    void removeFront() {C; p.removeFront(); }\n     \n    void removeBack() {C; p.removeBack(); }\n     \n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\n\n \n\n \n\n \n\n \n\n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                     \n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\nversion (X86) static if (__VERSION__ < 2071) {\n    import core.bitop : bsf, bsr, popcnt;\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nalias Point = Tuple!(int, \"x\", int, \"y\");\nalias Edge = Tuple!(int, \"to\", int, \"x\", int, \"y\");\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto G = new Edge[][](2*N); // ロボットが頂点、ボールが辺\n    auto uf = new UnionFind(2*N);\n    auto balls = new Point[](2*N);\n    auto deg = new int[](2*N);\n    auto used = new bool[](2*N);\n    foreach (i; 0..2*N) {\n        auto s = readln.split.map!(to!int);\n        int x = s[0] - 1;\n        int y = s[1] - 1;\n        balls[i] = Point(x, y);\n        G[x] ~= Edge(y + N, x, y);\n        G[y + N] ~= Edge(x, x, y);\n        deg[x] += 1;\n        deg[y + N] += 1;\n        uf.unite(x, y + N);\n    }\n\n    long[] F = new long[](2*N+1);\n    F[0] = 1;\n    foreach (i; 0..2*N) F[i+1] = F[i] * (i + 1) % MOD;\n\n    foreach (i; 0..2*N) { // 各連結成分において 辺数 = 頂点数 が成り立ってないと駄目\n        if (uf.find(i) != i) {\n            continue;\n        }\n        if (uf.edges[i] != uf.group[i].length) {\n            writeln(0);\n            return;\n        }\n    }\n\n\n    long topological_count(const long[] len, const long[] num) {\n        long ret = F[len.sum];\n        foreach (i; 0..len.length) {\n            ret = ret * powmod(F[len[i]], MOD-2, MOD) % MOD;\n            ret = ret * num[i] % MOD;\n        }\n        return ret;\n    }\n\n    long calc(Tuple!(int, Edge)[] matching) {\n        int n = matching.length.to!int;\n        Tuple!(int, int)[][int] X; // [ロボがx軸にいるマッチングのy座標][ロボのx座標とマッチング番号]\n        Tuple!(int, int)[][int] Y; // [ロボがy軸にいるマッチングのx座標][ロボのy座標とマッチング番号]\n\n        auto tree = new int[][](n);\n        auto is_root = new bool[](n);\n        fill(is_root, true);\n\n        foreach (i; 0..n) {\n            if (matching[i][0] < N) {\n                X[matching[i][1].y] ~= tuple(matching[i][1].x, i);\n            } else {\n                Y[matching[i][1].x] ~= tuple(matching[i][1].y, i);\n            }\n        }\n\n        // ひとつのマッチングをひとつの頂点とみなして、マッチングの順序関係からDAGをつくる(必ず有向森になる)\n\n        foreach (i; 0..n) {\n            if (matching[i][0] < N) {\n                if (matching[i][1].x !in Y) {\n                    continue;\n                }\n                foreach (t; Y[matching[i][1].x]) {\n                    if (t[0] < matching[i][1].y) {\n                        tree[i] ~= t[1];\n                        is_root[t[1]] = false;\n                    }\n                }\n            } else {\n                if (matching[i][1].y !in X) {\n                    continue;\n                }\n                foreach (t; X[matching[i][1].y]) {\n                    if (t[0] < matching[i][1].x) {\n                        tree[i] ~= t[1];\n                        is_root[t[1]] = false;\n                    }\n                }\n            }\n        }\n\n        // つくった森をトポロジカルソートするやり方が何通りあるか数える\n\n        Tuple!(long, long) dfs(int n, int p) {\n            long[] len, num;\n            foreach (m; tree[n]) {\n                if (m == p) continue;\n                auto t = dfs(m, n);\n                len ~= t[0];\n                num ~= t[1];\n            }\n            return tuple(len.sum+1, topological_count(len, num));\n        }\n\n        long[] len, num;\n        foreach (i; 0..n) {\n            if (!is_root[i]) continue;\n            auto t = dfs(i, -1);\n            len ~= t[0];\n            num ~= t[1];\n        }\n\n\n        return topological_count(len, num);\n    }\n\n    long solve(const int[] nodes) {\n        int[] cycle_nodes;\n        Edge[] cycle_edges;\n        Tuple!(int, Edge)[] not_cycle;\n\n        auto stack = nodes.filter!(n => deg[n] == 1).array;\n        while (!stack.empty) {\n            int n = stack.back;\n            stack.popBack;\n            used[n] = true;\n            foreach (e; G[n]) {\n                if (used[e.to]) continue;\n                deg[e.to] -= 1;\n                if (deg[e.to] == 1) stack ~= e.to;\n                not_cycle ~= tuple(n, e);\n                break;\n            }\n        }\n\n        foreach (start; nodes) {\n            if (used[start]) continue;\n            int next = start;\n            while (cycle_nodes.empty || next != start) {\n                cycle_nodes ~= next;\n                int cur = next;\n                used[cur] = true;\n                foreach (e; G[cur]) {\n                    if (e.to == start && cycle_nodes.length == 2) continue;\n                    if (e.to != start && used[e.to]) continue;\n                    cycle_edges ~= e;\n                    next = e.to;\n                    break;\n                }\n            }\n            break;\n        }\n\n\n        Tuple!(int, Edge)[] cycle1; // サイクル順周り\n        Tuple!(int, Edge)[] cycle2; // サイクル逆周り\n        int cnt = cycle_nodes.length.to!int;\n\n        foreach (i; 0..cnt) {\n            cycle1 ~= tuple(cycle_nodes[i], cycle_edges[i]);\n        }\n        foreach (i; 0..cnt) {\n            cycle2 ~= tuple(cycle_nodes[(i+1)%cnt], Edge(cycle_nodes[i], cycle_edges[i].x, cycle_edges[i].y));\n        }\n\n        return (calc(cycle1 ~ not_cycle) + calc(cycle2 ~ not_cycle)) % MOD;\n    }\n\n\n    long[] len, num;\n\n    foreach (i; 0..2*N) {\n        if (uf.find(i) != i) {\n            continue;\n        }\n        len ~= uf.group[i].length.to!long;\n        num ~= solve(uf.group[i]);\n    }\n\n    long ans = topological_count(len, num);\n    ans.writeln;\n}\n\n\nclass UnionFind {\n    int N;\n    int[] table;\n    int[][] group;\n    int[] edges;\n\n    this(int n) {\n        N = n;\n        table = new int[](N);\n        fill(table, -1);\n        group = N.iota.map!(i => [i]).array;\n        edges = new int[](N);\n    }\n\n    int find(int x) {\n        return table[x] < 0 ? x : (table[x] = find(table[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            edges[x] += 1;\n            return;\n        }\n        if (table[x] > table[y]) swap(x, y);\n        table[x] += table[y];\n        table[y] = x;\n        group[x] ~= group[y].dup;\n        group[y] = [];\n        edges[x] += edges[y] + 1;\n    }\n}\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nalias Point = Tuple!(int, \"x\", int, \"y\");\nalias Edge = Tuple!(int, \"to\", int, \"x\", int, \"y\");\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto G = new Edge[][](2*N); // ロボットが頂点、ボールが辺\n    auto uf = new UnionFind(2*N);\n    auto balls = new Point[](2*N);\n    auto deg = new int[](2*N);\n    auto used = new bool[](2*N);\n    foreach (i; 0..2*N) {\n        auto s = readln.split.map!(to!int);\n        int x = s[0] - 1;\n        int y = s[1] - 1;\n        balls[i] = Point(x, y);\n        G[x] ~= Edge(y + N, x, y);\n        G[y + N] ~= Edge(x, x, y);\n        deg[x] += 1;\n        deg[y + N] += 1;\n        uf.unite(x, y + N);\n    }\n\n    long[] F = new long[](2*N+1);\n    F[0] = 1;\n    foreach (i; 0..2*N) F[i+1] = F[i] * (i + 1) % MOD;\n\n    foreach (i; 0..2*N) { // 各連結成分において 辺数 = 頂点数 が成り立ってないと駄目\n        if (uf.find(i) != i) {\n            continue;\n        }\n        if (uf.edges[i] != uf.group[i].length) {\n            writeln(0);\n            return;\n        }\n    }\n\n\n    long topological_count(const long[] len, const long[] num) {\n        long ret = F[len.sum];\n        foreach (i; 0..len.length) {\n            ret = ret * powmod(F[len[i]], MOD-2, MOD) % MOD;\n            ret = ret * num[i] % MOD;\n        }\n        return ret;\n    }\n\n    long calc(Tuple!(int, Edge)[] matching) {\n        int n = matching.length.to!int;\n        Tuple!(int, int)[][int] X; // [ロボがx軸にいるマッチングのy座標][ロボのx座標とマッチング番号]\n        Tuple!(int, int)[][int] Y; // [ロボがy軸にいるマッチングのx座標][ロボのy座標とマッチング番号]\n\n        auto tree = new int[][](n);\n        auto is_root = new bool[](n);\n        fill(is_root, true);\n\n        foreach (i; 0..n) {\n            if (matching[i][0] < N) {\n                X[matching[i][1].y] ~= tuple(matching[i][1].x, i);\n            } else {\n                Y[matching[i][1].x] ~= tuple(matching[i][1].y, i);\n            }\n        }\n\n        // ひとつのマッチングをひとつの頂点とみなして、マッチングの順序関係からDAGをつくる(必ず有向森になる)\n\n        foreach (i; 0..n) {\n            if (matching[i][0] < N) {\n                if (matching[i][1].x !in Y) {\n                    continue;\n                }\n                foreach (t; Y[matching[i][1].x]) {\n                    if (t[0] < matching[i][1].y) {\n                        tree[i] ~= t[1];\n                        is_root[t[1]] = false;\n                    }\n                }\n            } else {\n                if (matching[i][1].y !in X) {\n                    continue;\n                }\n                foreach (t; X[matching[i][1].y]) {\n                    if (t[0] < matching[i][1].x) {\n                        tree[i] ~= t[1];\n                        is_root[t[1]] = false;\n                    }\n                }\n            }\n        }\n\n        // つくった森をトポロジカルソートするやり方が何通りあるか数える\n\n        Tuple!(long, long) dfs(int n, int p) {\n            used[n] = true;\n            long[] len, num;\n            foreach (m; tree[n]) {\n                if (m == p) continue;\n                auto t = dfs(m, n);\n                len ~= t[0];\n                num ~= t[1];\n            }\n            return tuple(len.sum+1, topological_count(len, num));\n        }\n\n        long[] len, num;\n        foreach (i; 0..n) {\n            if (!is_root[i]) continue;\n            auto t = dfs(i, -1);\n            len ~= t[0];\n            num ~= t[1];\n        }\n\n\n        return topological_count(len, num);\n    }\n\n    long solve(const int[] nodes) {\n        int[] cycle_nodes;\n        Edge[] cycle_edges;\n        Tuple!(int, Edge)[] not_cycle;\n\n        auto stack = nodes.filter!(n => deg[n] == 1).array;\n        while (!stack.empty) {\n            int n = stack.back;\n            stack.popBack;\n            used[n] = true;\n            foreach (e; G[n]) {\n                if (used[e.to]) continue;\n                deg[e.to] -= 1;\n                if (deg[e.to] == 1) stack ~= e.to;\n                not_cycle ~= tuple(n, e);\n                break;\n            }\n        }\n\n        foreach (start; nodes) {\n            if (used[start]) continue;\n            int next = start;\n            while (cycle_nodes.empty || next != start) {\n                cycle_nodes ~= next;\n                int cur = next;\n                used[cur] = true;\n                foreach (e; G[cur]) {\n                    if (e.to == start && cycle_nodes.length == 2) continue;\n                    if (e.to != start && used[e.to]) continue;\n                    cycle_edges ~= e;\n                    next = e.to;\n                    break;\n                }\n            }\n            break;\n        }\n\n\n        Tuple!(int, Edge)[] cycle1; // サイクル順周り\n        Tuple!(int, Edge)[] cycle2; // サイクル逆周り\n        int cnt = cycle_nodes.length.to!int;\n\n        foreach (i; 0..cnt) {\n            cycle1 ~= tuple(cycle_nodes[i], cycle_edges[i]);\n        }\n        foreach (i; 0..cnt) {\n            cycle2 ~= tuple(cycle_nodes[(i+1)%cnt], Edge(cycle_nodes[i], cycle_edges[i].x, cycle_edges[i].y));\n        }\n\n        debug {\n            calc(cycle1 ~ not_cycle).writeln;\n            calc(cycle2 ~ not_cycle).writeln;\n        }\n\n        return (calc(cycle1 ~ not_cycle) + calc(cycle2 ~ not_cycle)) % MOD;\n    }\n\n\n    long[] len, num;\n\n    foreach (i; 0..2*N) {\n        if (uf.find(i) != i) {\n            continue;\n        }\n        len ~= uf.group[i].length.to!long;\n        num ~= solve(uf.group[i]);\n    }\n\n    long ans = topological_count(len, num);\n    ans.writeln;\n}\n\n\nclass UnionFind {\n    int N;\n    int[] table;\n    int[][] group;\n    int[] edges;\n\n    this(int n) {\n        N = n;\n        table = new int[](N);\n        fill(table, -1);\n        group = N.iota.map!(i => [i]).array;\n        edges = new int[](N);\n    }\n\n    int find(int x) {\n        return table[x] < 0 ? x : (table[x] = find(table[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            edges[x] += 1;\n            return;\n        }\n        if (table[x] > table[y]) swap(x, y);\n        table[x] += table[y];\n        table[y] = x;\n        group[x] ~= group[y].dup;\n        group[y] = [];\n        edges[x] += edges[y] + 1;\n    }\n}\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nalias Point = Tuple!(int, \"x\", int, \"y\");\nalias Edge = Tuple!(int, \"to\", int, \"x\", int, \"y\");\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto G = new Edge[][](2*N); // ロボットが頂点、ボールが辺\n    auto uf = new UnionFind(2*N);\n    auto balls = new Point[](2*N);\n    auto deg = new int[](2*N);\n    auto used = new bool[](2*N);\n    foreach (i; 0..2*N) {\n        auto s = readln.split.map!(to!int);\n        int x = s[0] - 1;\n        int y = s[1] - 1;\n        balls[i] = Point(x, y);\n        G[x] ~= Edge(y + N, x, y);\n        G[y + N] ~= Edge(x, x, y);\n        deg[x] += 1;\n        deg[y + N] += 1;\n        uf.unite(x, y + N);\n    }\n\n    long[] F = new long[](2*N+1);\n    F[0] = 1;\n    foreach (i; 0..2*N) F[i+1] = F[i] * (i + 1) % MOD;\n\n    foreach (i; 0..2*N) { // 各連結成分において 辺数 = 頂点数 が成り立ってないと駄目\n        if (uf.find(i) != i) {\n            continue;\n        }\n        if (uf.edges[i] != uf.group[i].length) {\n            writeln(0);\n            return;\n        }\n    }\n\n\n    long topological_count(const long[] len, const long[] num) {\n        long ret = F[len.sum];\n        foreach (i; 0..len.length) {\n            ret = ret * powmod(F[len[i]], MOD-2, MOD) % MOD;\n            ret = ret * num[i] % MOD;\n        }\n        return ret;\n    }\n\n    long calc(Tuple!(int, Edge)[] matching) {\n        int n = matching.length.to!int;\n\n        Tuple!(int, int)[int] X;\n        Tuple!(int, int)[int] Y;\n\n        auto tree = new int[][](n);\n        auto is_root = new bool[](n);\n        fill(is_root, true);\n\n        foreach (i; 0..n) {\n            if (matching[i][0] < N) {\n                X[matching[i][1].x] = tuple(matching[i][1].y, i);\n            } else {\n                Y[matching[i][1].y] = tuple(matching[i][1].x, i);\n            }\n        }\n\n        // ひとつのマッチングをひとつの頂点とみなして、マッチングの順序関係からDAGをつくる(必ず有向森になる)\n\n        foreach (i; 0..n) {\n            if (matching[i][0] < N) {\n                if (matching[i][1].y in Y && matching[i][1].x < Y[matching[i][1].y][0]) {\n                    tree[Y[matching[i][1].y][1]] ~= i;\n                    is_root[i] = false;\n                }\n            } else {\n                if (matching[i][1].x in X && matching[i][1].y < X[matching[i][1].x][0]) {\n                    tree[X[matching[i][1].x][1]] ~= i;\n                    is_root[i] = false;\n                }\n            }\n        }\n\n        // つくった森をトポロジカルソートするやり方が何通りあるか数える\n\n        Tuple!(long, long) dfs(int n, int p) {\n            long[] len, num;\n            foreach (m; tree[n]) {\n                if (m == p) continue;\n                auto t = dfs(m, n);\n                len ~= t[0];\n                num ~= t[1];\n            }\n            return tuple(len.sum+1, topological_count(len, num));\n        }\n\n        long[] len, num;\n        foreach (i; 0..n) {\n            if (!is_root[i]) continue;\n            auto t = dfs(i, -1);\n            len ~= t[0];\n            num ~= t[1];\n        }\n\n        return topological_count(len, num);\n    }\n\n    long solve(const int[] nodes) {\n        int[] cycle_nodes;\n        Edge[] cycle_edges;\n        Tuple!(int, Edge)[] not_cycle;\n\n        auto stack = nodes.filter!(n => deg[n] == 1).array;\n        while (!stack.empty) {\n            int n = stack.back;\n            stack.popBack;\n            used[n] = true;\n            foreach (e; G[n]) {\n                if (used[e.to]) continue;\n                deg[e.to] -= 1;\n                if (deg[e.to] == 1) stack ~= e.to;\n                not_cycle ~= tuple(n, e);\n                break;\n            }\n        }\n\n        foreach (start; nodes) {\n            if (used[start]) continue;\n            int next = start;\n            while (cycle_nodes.empty || next != start) {\n                cycle_nodes ~= next;\n                int cur = next;\n                used[cur] = true;\n                foreach (e; G[cur]) {\n                    if (e.to == start && cycle_nodes.length == 2) continue;\n                    if (e.to != start && used[e.to]) continue;\n                    cycle_edges ~= e;\n                    next = e.to;\n                    break;\n                }\n            }\n            break;\n        }\n\n\n        Tuple!(int, Edge)[] cycle1; // サイクル順周り\n        Tuple!(int, Edge)[] cycle2; // サイクル逆周り\n        int cnt = cycle_nodes.length.to!int;\n\n        foreach (i; 0..cnt) {\n            cycle1 ~= tuple(cycle_nodes[i], cycle_edges[i]);\n        }\n        foreach (i; 0..cnt) {\n            cycle2 ~= tuple(cycle_nodes[(i+1)%cnt], Edge(cycle_nodes[i], cycle_edges[i].x, cycle_edges[i].y));\n        }\n\n        return (calc(cycle1 ~ not_cycle) + calc(cycle2 ~ not_cycle)) % MOD;\n    }\n\n\n    long[] len, num;\n\n    foreach (i; 0..2*N) {\n        if (uf.find(i) != i) {\n            continue;\n        }\n        len ~= uf.group[i].length.to!long;\n        num ~= solve(uf.group[i]);\n    }\n\n    long ans = topological_count(len, num);\n    ans.writeln;\n}\n\n\nclass UnionFind {\n    int N;\n    int[] table;\n    int[][] group;\n    int[] edges;\n\n    this(int n) {\n        N = n;\n        table = new int[](N);\n        fill(table, -1);\n        group = N.iota.map!(i => [i]).array;\n        edges = new int[](N);\n    }\n\n    int find(int x) {\n        return table[x] < 0 ? x : (table[x] = find(table[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            edges[x] += 1;\n            return;\n        }\n        if (table[x] > table[y]) swap(x, y);\n        table[x] += table[y];\n        table[y] = x;\n        group[x] ~= group[y].dup;\n        group[y] = [];\n        edges[x] += edges[y] + 1;\n    }\n}\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nalias Point = Tuple!(int, \"x\", int, \"y\");\nalias Edge = Tuple!(int, \"to\", int, \"x\", int, \"y\");\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    auto G = new Edge[][](2*N); // ロボットが頂点、ボールが辺\n    auto uf = new UnionFind(2*N);\n    auto balls = new Point[](2*N);\n    auto deg = new int[](2*N);\n    auto used = new bool[](2*N);\n    auto stack = new int[](2*N);\n    foreach (i; 0..2*N) {\n        auto s = readln.split.map!(to!int);\n        int x = s[0] - 1;\n        int y = s[1] - 1;\n        balls[i] = Point(x, y);\n        G[x] ~= Edge(y + N, x, y);\n        G[y + N] ~= Edge(x, x, y);\n        deg[x] += 1;\n        deg[y + N] += 1;\n        uf.unite(x, y + N);\n    }\n\n    long[] F = new long[](2*N+1);\n    F[0] = 1;\n    foreach (i; 0..2*N) F[i+1] = F[i] * (i + 1) % MOD;\n\n    foreach (i; 0..2*N) { // 各連結成分において 辺数 = 頂点数 が成り立ってないと駄目\n        if (uf.find(i) != i) {\n            continue;\n        }\n        if (uf.edges[i] != uf.group[i].length) {\n            writeln(0);\n            return;\n        }\n    }\n\n\n    long topological_count(const long[] len, const long[] num) {\n        long ret = F[len.sum];\n        foreach (i; 0..len.length) {\n            ret = ret * powmod(F[len[i]], MOD-2, MOD) % MOD;\n            ret = ret * num[i] % MOD;\n        }\n        return ret;\n    }\n\n    long calc(Tuple!(int, Edge)[] matching) {\n        int n = matching.length.to!int;\n\n        Tuple!(int, int)[int] X;\n        Tuple!(int, int)[int] Y;\n\n        auto tree = new int[][](n);\n        auto is_root = new bool[](n);\n        fill(is_root, true);\n\n        foreach (i; 0..n) {\n            if (matching[i][0] < N) {\n                X[matching[i][1].x] = tuple(matching[i][1].y, i);\n            } else {\n                Y[matching[i][1].y] = tuple(matching[i][1].x, i);\n            }\n        }\n\n        // ひとつのマッチングをひとつの頂点とみなして、マッチングの順序関係からDAGをつくる(必ず有向森になる)\n\n        foreach (i; 0..n) {\n            if (matching[i][0] < N) {\n                if (matching[i][1].y in Y && matching[i][1].x < Y[matching[i][1].y][0]) {\n                    tree[Y[matching[i][1].y][1]] ~= i;\n                    is_root[i] = false;\n                }\n            } else {\n                if (matching[i][1].x in X && matching[i][1].y < X[matching[i][1].x][0]) {\n                    tree[X[matching[i][1].x][1]] ~= i;\n                    is_root[i] = false;\n                }\n            }\n        }\n\n        // つくった森をトポロジカルソートするやり方が何通りあるか数える\n\n        Tuple!(long, long) dfs(int n, int p) {\n            long[] len, num;\n            foreach (m; tree[n]) {\n                if (m == p) continue;\n                auto t = dfs(m, n);\n                len ~= t[0];\n                num ~= t[1];\n            }\n            return tuple(len.sum+1, topological_count(len, num));\n        }\n\n        long[] len, num;\n        foreach (i; 0..n) {\n            if (!is_root[i]) continue;\n            auto t = dfs(i, -1);\n            len ~= t[0];\n            num ~= t[1];\n        }\n\n        return topological_count(len, num);\n    }\n\n    long solve(const int[] nodes) {\n        int[] cycle_nodes;\n        Edge[] cycle_edges;\n        Tuple!(int, Edge)[] not_cycle;\n\n        int sp = -1;\n        foreach (n; nodes) if (deg[n] == 1) stack[++sp] = n;\n\n        while (sp >= 0) {\n            int n = stack[sp--];\n            used[n] = true;\n            foreach (e; G[n]) {\n                if (used[e.to]) continue;\n                deg[e.to] -= 1;\n                if (deg[e.to] == 1) stack[++sp] = e.to;\n                not_cycle ~= tuple(n, e);\n                break;\n            }\n        }\n\n        foreach (start; nodes) {\n            if (used[start]) continue;\n            int next = start;\n            while (cycle_nodes.empty || next != start) {\n                cycle_nodes ~= next;\n                int cur = next;\n                used[cur] = true;\n                foreach (e; G[cur]) {\n                    if (e.to == start && cycle_nodes.length == 2) continue;\n                    if (e.to != start && used[e.to]) continue;\n                    cycle_edges ~= e;\n                    next = e.to;\n                    break;\n                }\n            }\n            break;\n        }\n\n\n        Tuple!(int, Edge)[] cycle1; // サイクル順周り\n        Tuple!(int, Edge)[] cycle2; // サイクル逆周り\n        int cnt = cycle_nodes.length.to!int;\n\n        foreach (i; 0..cnt) {\n            cycle1 ~= tuple(cycle_nodes[i], cycle_edges[i]);\n        }\n        foreach (i; 0..cnt) {\n            cycle2 ~= tuple(cycle_nodes[(i+1)%cnt], Edge(cycle_nodes[i], cycle_edges[i].x, cycle_edges[i].y));\n        }\n\n        return (calc(cycle1 ~ not_cycle) + calc(cycle2 ~ not_cycle)) % MOD;\n    }\n\n\n    long[] len, num;\n\n    foreach (i; 0..2*N) {\n        if (uf.find(i) != i) {\n            continue;\n        }\n        len ~= uf.group[i].length.to!long;\n        num ~= solve(uf.group[i]);\n    }\n\n    long ans = topological_count(len, num);\n    ans.writeln;\n}\n\n\nclass UnionFind {\n    int N;\n    int[] table;\n    int[][] group;\n    int[] edges;\n\n    this(int n) {\n        N = n;\n        table = new int[](N);\n        fill(table, -1);\n        group = N.iota.map!(i => [i]).array;\n        edges = new int[](N);\n    }\n\n    int find(int x) {\n        return table[x] < 0 ? x : (table[x] = find(table[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            edges[x] += 1;\n            return;\n        }\n        if (table[x] > table[y]) swap(x, y);\n        table[x] += table[y];\n        table[y] = x;\n        group[x] ~= group[y].dup;\n        group[y] = [];\n        edges[x] += edges[y] + 1;\n    }\n}\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\nint read() {\n\tint x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) flag *= (ch == '-' ? -1 : 1);\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';\n\treturn flag * x;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 2e5 + 9, Mod = 1e9 + 7;\nnamespace Math {\n\tint fpm(int base, int tims) {\n\t\tint r = 1;\n\t\tfor (; tims; base = 1ll * base * base % Mod, tims >>= 1) \n\t\t\tif (tims & 1) r = 1ll * r * base % Mod;\n\t\treturn r;\n\t}\n\tint fac[Maxn], invFac[Maxn];\n\tvoid Init() {\n\t\tfac[0] = 1;\n\t\trep (i, 1, Maxn - 1) \n\t\t\tfac[i] = fac[i - 1] * 1ll * i % Mod;\n\t\tinvFac[Maxn - 1] = fpm(fac[Maxn - 1], Mod - 2);\n\t\tdrep (i, Maxn - 2, 0) invFac[i] = invFac[i + 1] * (i + 1ll) % Mod;\n\t}\n\tint C(int _n, int _m) {\n\t\tif (_n < _m) return 0;\n\t\treturn fac[_n] * 1ll * invFac[_n - _m] % Mod * invFac[_m] % Mod;\n\t}\n}\nusing namespace Math;\n\nstruct node { int u, v, w; };\nstruct edge { int to, nxt, w; }g[Maxn << 2], g1[Maxn << 2];\nint head[Maxn], e;\nint head1[Maxn], e1;\nvoid add(int u, int v, int w) { g[++e] = (edge){v, head[u], w}, head[u] = e; }\nvoid add1(int u, int v, int w = 0) { g1[++e1] = (edge){v, head1[u], w}, head1[u] = e1; }\n\nint vis[Maxn], inCir[Maxn], found, _top, delta, n;\nnode stk[Maxn];\nvector <node> cir;\nvector <int> cus, cun;\n\nvoid dfsCir(int u, int pa) {\n\tif (!vis[u]) ++delta, cun.push_back(u);\n\tvis[u] = 1; \n\t\t\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tif (!vis[v]) {\n\t\t\t\tstk[++_top] = (node){u, v, g[i].w};\n\t\t\t\tdfsCir(v, u);\n\t\t\t\t--_top;\n\t\t\t} else if (!found) {\n\t\t\t\tnode tmp; int bak = _top;\n\t\t\t\tdo {\n\t\t\t\t\ttmp = stk[bak--];\n\t\t\t\t\tcir.push_back(tmp);\n\t\t\t\t\tif (!inCir[tmp.u]) cus.push_back(tmp.u);\n\t\t\t\t\tif (!inCir[tmp.v]) cus.push_back(tmp.v);\n\t\t\t\t\tinCir[tmp.u] = inCir[tmp.v] = 1;\n\t\t\t\t} while (tmp.u != v);\n\t\t\t\tcir.push_back((node){u, v, g[i].w});\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint val[Maxn];\nvoid dfs1(int u, int pa) {\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (!inCir[v] && v != pa) val[v] = g[i].w, dfs1(v, u);\n\t}\n}\n\nint size[Maxn], dp[Maxn];\nvoid dfsDp(int u, int pa) {\n\tdp[u] = 1;\n\tint sum = 0;\n\tfor (int i = head1[u]; ~i; i = g1[i].nxt) {\n\t\tint v = g1[i].to;\n\t\tif (v != pa) {\n\t\t\tdfsDp(v, u);\n\t\t\tsize[u] += size[v];\n\t\t\tdp[u] = 1ll * dp[u] * dp[v] % Mod * C(size[u], sum) % Mod;\n\t\t\tsum += size[v];\n\t\t}\n\t}\n\t++size[u];\n}\nint deg[Maxn], toward[Maxn];\nint calc() {\n\te1 = 0;\n\trep (i, 0, cun.size() - 1) {\n\t\tint u = cun[i];\n\t\tsize[u] = dp[u] = deg[u] = 0;\n\t\thead1[u] = -1;\n\t}\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (g[i].w < val[u]) add1(u, v), ++deg[v];\n\t\t}\n\t}\n\tint res = 1, sum = 0;\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tif (!deg[u]) {\n\t\t\tdfsDp(u, 0);\n\t\t\tres = 1ll * res * dp[u] * C(sum + size[u], sum) % Mod;\n\t\t\tsum += size[u];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"robot.in\", \"r\", stdin);\n\tfreopen(\"robot.out\", \"w\", stdout);\n\n\tstatic int x[Maxn], y[Maxn], xjig[Maxn], amt = 0;\n\n\tclar (head, -1), e = 0;\n\tMath :: Init();\n\n\tn = read() << 1;\n\trep (i, 1, n) {\n\t\tx[i] = read(), y[i] = read();\n\t\tadd(x[i], y[i] + n / 2, x[i] + y[i]);\n\t\tadd(y[i] + n / 2, x[i], x[i] + y[i]);\n\t\tif (!xjig[x[i]]) ++amt, xjig[x[i]] = 1;\n\t\tif (!xjig[y[i] + n / 2]) ++amt, xjig[y[i] + n / 2] = 1;\n\t}\n\tif (amt != n) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tLL ans = 1, sum = 0;\n\trep (i, 1, n) \n\t\tif (!vis[i]) {\n\t\t\tint res = 0; _top = 0, cir.clear(), found = 0, delta = 0, cus.clear(), cun.clear();\n\t\t\tdfsCir(i, 0);\n\t\t\trep (j, 0, cus.size() - 1) dfs1(cus[j], 0);\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].u] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].v] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\n\t\t\tans = 1ll * ans * res % Mod * C(sum += delta, delta) % Mod;\n\t\t}\n\tprintf(\"%d\\n\", 1ll * ans * fpm(fac[n], Mod - 1) % Mod);\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\ntemplate <typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\nint read() {\n\tint x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) flag *= (ch == '-' ? -1 : 1);\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';\n\treturn flag * x;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int Maxn = 3e5 + 9, Mod = 1e9 + 7;\nnamespace Math {\n\tint fpm(int base, int tims) {\n\t\tint r = 1;\n\t\tfor (; tims; base = 1ll * base * base % Mod, tims >>= 1) \n\t\t\tif (tims & 1) r = 1ll * r * base % Mod;\n\t\treturn r;\n\t}\n\tint fac[Maxn], invFac[Maxn];\n\tvoid Init() {\n\t\tfac[0] = 1;\n\t\trep (i, 1, Maxn - 1) \n\t\t\tfac[i] = fac[i - 1] * 1ll * i % Mod;\n\t\tinvFac[Maxn - 1] = fpm(fac[Maxn - 1], Mod - 2);\n\t\tdrep (i, Maxn - 2, 0) invFac[i] = invFac[i + 1] * (i + 1ll) % Mod;\n\t}\n\tint C(int _n, int _m) {\n\t\tif (_n < _m) return 0;\n\t\treturn fac[_n] * 1ll * invFac[_n - _m] % Mod * invFac[_m] % Mod;\n\t}\n}\nusing namespace Math;\n\nstruct node { int u, v, w; };\nstruct edge { int to, nxt, w; }g[Maxn << 2], g1[Maxn << 2];\nint head[Maxn], e;\nint head1[Maxn], e1;\nvoid add(int u, int v, int w) { g[++e] = (edge){v, head[u], w}, head[u] = e; }\nvoid add1(int u, int v, int w = 0) { g1[++e1] = (edge){v, head1[u], w}, head1[u] = e1; }\n\nint vis[Maxn], inCir[Maxn], found, _top, delta, n;\nnode stk[Maxn];\nvector <node> cir;\nvector <int> cus, cun;\n\nvoid dfsCir(int u, int pa) {\n\tif (found) return ;\n\tvis[u] = 1; \n\t\t\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tif (!vis[v]) {\n\t\t\t\tstk[++_top] = (node){u, v, g[i].w};\n\t\t\t\tdfsCir(v, u);\n\t\t\t\t--_top;\n\t\t\t} else if (!found) {\n\t\t\t\tnode tmp; int bak = _top;\n\t\t\t\tdo {\n\t\t\t\t\ttmp = stk[bak--];\n\t\t\t\t\tcir.push_back(tmp);\n\t\t\t\t\tif (!inCir[tmp.u]) cus.push_back(tmp.u);\n\t\t\t\t\tif (!inCir[tmp.v]) cus.push_back(tmp.v);\n\t\t\t\t\tinCir[tmp.u] = inCir[tmp.v] = 1;\n\t\t\t\t} while (tmp.u != v);\n\t\t\t\tcir.push_back((node){u, v, g[i].w});\n\t\t\t\tfound = 1;\n\t\t\t\treturn;\n\t\t\t} \n\t\t}\n\t\tif (found) return;\n\t}\n}\n\nint val[Maxn], fa[Maxn];\nint find(int x) {\n\treturn fa[x] ^ x ? fa[x] = find(fa[x]) : x;\n}\nvoid dfs1(int u, int pa) {\n\tcun.push_back(u); ++delta;\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (!inCir[v] && v != pa) val[v] = g[i].w, dfs1(v, u);\n\t}\n}\n\nint size[Maxn], dp[Maxn];\nvoid dfsDp(int u, int pa) {\n\tdp[u] = 1;\n\tint sum = 0;\n\tfor (int i = head1[u]; ~i; i = g1[i].nxt) {\n\t\tint v = g1[i].to;\n\t\tif (v != pa) {\n\t\t\tdfsDp(v, u);\n\t\t\tsize[u] += size[v];\n\t\t\tdp[u] = 1ll * dp[u] * dp[v] % Mod * C(size[u], sum) % Mod;\n\t\t\tsum += size[v];\n\t\t}\n\t}\n\t++size[u];\n}\nint deg[Maxn];\nint calc() {\n\te1 = 0;\n\trep (i, 0, cun.size() - 1) {\n\t\tint u = cun[i];\n\t\tsize[u] = dp[u] = deg[u] = 0;\n\t\thead1[u] = -1;\n\t}\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (g[i].w < val[u]) {\n\t\t\t\tadd1(u, v), ++deg[v];\n\t\t\t\t//cout << u << \" \" << v << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 1, sum = 0;\n\trep (ct, 0, cun.size() - 1) {\n\t\tint u = cun[ct];\n\t\tif (!deg[u]) {\n\t\t\tdfsDp(u, 0);\n\t\t\tres = 1ll * res * dp[u] * C(sum + size[u], sum) % Mod;\n\t\t\tsum += size[u];\n\t\t}\n\t}\n\t//cout << res << endl;\n//\tputs(\"\");\n\treturn res;\n}\n\nint main() {\n//\tfreopen(\"robot.in\", \"r\", stdin);\n//\tfreopen(\"robot.out\", \"w\", stdout);\n\n\tstatic int x[Maxn], y[Maxn], xjig[Maxn], amt = 0;\n\n\tclar (head, -1), e = 0;\n\tMath :: Init();\n\n\tn = read() << 1;\n\trep (i, 1, n) fa[i] = i;\n\trep (i, 1, n) {\n\t\tx[i] = read(), y[i] = read();\n\t\tadd(x[i], y[i] + n / 2, x[i] + y[i]);\n\t\tadd(y[i] + n / 2, x[i], x[i] + y[i]);\n\t\tif (!xjig[x[i]]) ++amt, xjig[x[i]] = 1;\n\t\tif (!xjig[y[i] + n / 2]) ++amt, xjig[y[i] + n / 2] = 1;\n\t\tif (find(x[i]) != find(y[i] + n / 2)) fa[find(x[i])] = fa[find(y[i] + n / 2)];\n\t}\n\tif (amt != n) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tLL ans = 1, sum = 0;\n\trep (i, 1, n) \n\t\tif (fa[i] == i) {\n\t\t\tint res = 0; _top = 0, cir.clear(), found = 0, delta = 0, cus.clear(), cun.clear();\n\t\t\tdfsCir(i, 0);\n\t\t\tif (!found) {\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep (j, 0, cus.size() - 1) dfs1(cus[j], 0);\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].u] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\t\t\trep (j, 0, cir.size() - 1) val[cir[j].v] = cir[j].w;\n\t\t\tres += calc();\n\t\t\tif (res >= Mod) res -= Mod;\n\n\t\t\tans = 1ll * ans * res % Mod * C(sum += delta, delta) % Mod;\n\t\t}\n\tprintf(\"%d\\n\", 1ll * ans * fpm(fac[n], Mod - 1) % Mod);\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    E = []\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if y < z:\n                E.append((y,z))\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append((V,E))\n\ndef make_get_pattern(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[(x,y)] = 0\n        else:\n            get[(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[(x,y)] = 2\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[(x,y)] = 3\n        else:\n            get[(y,x)] = 2\n        x = y\n    return get\n\ndef F(V,E):\n    # V is connected\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    E.sort()\n    get = make_get_pattern(V)\n    den1,den2 = 1,1\n    dp1 = {x:0 for x in V}\n    dp2 = {x:0 for x in V}\n    for x,y in E:\n        if get[(x,y)] == 0:\n            k1 = dp1[x] + 1; k2 = dp2[x] + 1\n        elif get[(x,y)] == 1:\n            k1 = dp1[y] + 1; k2 = dp2[y] + 1\n        elif get[(x,y)] == 2:\n            k1 = dp1[x] + 1; k2 = dp2[y] + 1\n        else:\n            k1 = dp1[y] + 1; k2 = dp2[x] + 1\n        dp1[x] += k1; dp1[y] += k1\n        dp2[x] += k2; dp2[y] += k2\n        den1 *= k1; den2 *= k2\n        den1 %= MOD; den2 %= MOD\n    return sum(pow(x,MOD-2,MOD) for x in (den1,den2))\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    E = []\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if y < z:\n                E.append((y,z))\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append((V,E))\n\ndef make_get_pattern(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[(x,y)] = 0\n        else:\n            get[(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[(x,y)] = 2\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[(x,y)] = 3\n        else:\n            get[(y,x)] = 2\n        x = y\n    return get\n\ndef F(V,E):\n    # V is connected\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    E.sort()\n    get = make_get_pattern(V)\n    den1,den2 = 1,1\n    dp1 = {x:0 for x in V}\n    dp2 = {x:0 for x in V}\n    for x,y in E:\n        if get[(x,y)] == 0:\n            k1 = dp1[x] + 1; k2 = dp2[x] + 1\n        elif get[(x,y)] == 1:\n            k1 = dp1[y] + 1; k2 = dp2[y] + 1\n        elif get[(x,y)] == 2:\n            k1 = dp1[x] + 1; k2 = dp2[y] + 1\n        else:\n            k1 = dp1[y] + 1; k2 = dp2[x] + 1\n        dp1[x] += k1; dp1[y] += k1\n        dp2[x] += k2; dp2[y] += k2\n        den1 *= k1; den2 *= k2\n        den1 %= MOD; den2 %= MOD\n    return sum(pow(x,MOD-2,MOD) for x in (den1,den2))\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    E = []\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if y < z:\n                E.append((y,z))\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append((V,E))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append(V)\n\ndef make_get_patterns(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {},{}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        else:\n            pass\n            get[0][(y,x)] = 1; get[1][(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 0; get[1][(y,x)] = 1\n        x = y\n    return get\n\ndef F(V):\n    # V is connected\n    E = sorted((x,y) for x in V if x <= N for y in graph[x])\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    for get in make_get_patterns(V):\n        den = 1\n        dp = {x:0 for x in V}\n        for x,y in E:\n            if get[(x,y)] == 0:\n                k = dp[x] + 1\n            else:\n                k = dp[y] + 1\n            dp[x] += k\n            dp[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = set()\ncomponents = []\nfor x in range(1,N+N+1):\n    if x in visited:\n        continue\n    V = set([x])\n    q = [x]\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if z in V:\n                continue\n            V.add(z)\n            q.append(z)\n    visited |= V\n    components.append(V)\n\ndef make_get_patterns(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {},{}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        else:\n            pass\n            get[0][(y,x)] = 1; get[1][(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    while True:\n        if not graph[x]:\n            break\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 0; get[1][(y,x)] = 1\n        x = y\n    return get\n\ndef F(V):\n    # V is connected\n    E = sorted((x,y) for x in V if x <= N for y in graph[x])\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    for get in make_get_patterns(V):\n        den = 1\n        dp = {x:0 for x in V}\n        for x,y in E:\n            if get[(x,y)] == 0:\n                k = dp[x] + 1\n            else:\n                k = dp[y] + 1\n            dp[x] += k\n            dp[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append(V)\n\ndef make_get_patterns(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {},{}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        else:\n            pass\n            get[0][(y,x)] = 1; get[1][(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    while True:\n        if not graph[x]:\n            break\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 0; get[1][(y,x)] = 1\n        x = y\n    return get\n\ndef F(V):\n    # V is connected\n    E = sorted((x,y) for x in V if x <= N for y in graph[x])\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    for get in make_get_patterns(V):\n        den = 1\n        dp = {x:0 for x in V}\n        for x,y in E:\n            if get[(x,y)] == 0:\n                k = dp[x] + 1\n            else:\n                k = dp[y] + 1\n            dp[x] += k\n            dp[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nrow = []\ncol = []\nfor x,y in ball:\n    row.append(x)\n    col.append(y+N)\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nNcomp,comp = connected_components(csr_matrix(([1]*(N+N),(row,col)),(N+N+1,N+N+1)))\n\ncomponents = [[] for _ in range(Ncomp-1)]\nfor i,x in enumerate(comp[1:],1):\n    components[x-1].append(i)\n\ndef make_get_patterns(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {},{}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        else:\n            pass\n            get[0][(y,x)] = 1; get[1][(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 0; get[1][(y,x)] = 1\n        x = y\n    return get\n\ndef F(V):\n    # V is connected\n    E = sorted((x,y) for x in V if x <= N for y in graph[x])\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    for get in make_get_patterns(V):\n        den = 1\n        dp = {x:0 for x in V}\n        for x,y in E:\n            if get[(x,y)] == 0:\n                k = dp[x] + 1\n            else:\n                k = dp[y] + 1\n            dp[x] += k\n            dp[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\nU = N+N+10\nfact = [1] * (U+1); fact_inv = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\nX_to_Y = [[] for _ in range(N+1)]\nY_to_X = [[] for _ in range(N+1)]\nfor x,y in ball:\n    X_to_Y[x].append(y)\n    Y_to_X[y].append(x)\n\n# とりあえず連結成分に分けよう\nvisited_x = set()\nvisited_y = set()\ncomponents = []\nfor x,y in ball:\n    if x in visited_x:\n        continue\n    V = set()\n    V_x = set()\n    V_y = set()\n    q = [(x,y)]\n    while q:\n        x,y = q.pop()\n        V.add((x,y))\n        if x not in V_x:\n            V_x.add(x)\n            for t in X_to_Y[x]:\n                q.append((x,t))\n        if y not in V_y:\n            V_y.add(y)\n            for t in Y_to_X[y]:\n                q.append((t,y))\n        V_x.add(x)\n        V_y.add(y)\n    visited_x |= V_x\n    visited_y |= V_y\n    components.append((V,V_x,V_y))\n\ndef make_get_patterns(V_x,V_y):\n    rest_xy = {x:set(X_to_Y[x]) for x in V_x}\n    rest_yx = {y:set(Y_to_X[y]) for y in V_y}\n    deg1_x = set(x for x in V_x if len(rest_xy[x]) == 1)\n    deg1_y = set(y for y in V_y if len(rest_yx[y]) == 1)\n    get = {},{}\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.remove(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 1\n    for x in V_x:\n        if rest_xy[x]:\n            y = rest_xy[x].pop()\n            break\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    rest_yx[y].remove(x); deg1_y.add(y)\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 1\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.discard(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n    return get\n\ndef F(V,V_x,V_y):\n    # 連結成分上の順序がうまくいっている確率を返す\n    if len(V) != len(V_x) + len(V_y):\n        return 0\n    V = sorted(V)\n    ret = 0\n    for get in make_get_patterns(V_x,V_y):\n        den = 1\n        dp_x = {x:0 for x in V_x}\n        dp_y = {y:0 for y in V_y}\n        for x,y in V:\n            if get[(x,y)] == 0: # x軸でとる\n                k = dp_x[x] + 1\n            else:\n                k = dp_y[y] + 1\n            dp_x[x] += k\n            dp_y[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\nanswer = prob * fact[N+N] % MOD\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nclass UnionFind():\n    def __init__(self, size):\n        self.table = [-1] * size\n\n    def find(self, x):\n        while 0 <= self.table[x]:\n            x = self.table[x]\n        return x\n\n    def unite(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            dx = -self.table[rx]\n            dy = -self.table[ry]\n            if dx != dy:\n                if dx < dy:\n                    self.table[rx] = ry\n                else:\n                    self.table[ry] = rx\n            else:\n                self.table[rx] -= 1\n                self.table[ry] = rx\n        return\n\n\nM = 10 ** 9 + 7\nN = 0\nF = [0]\nedges = []\n\n\ndef solve(nodes):\n    global edges\n\n    pair_table = [0] * (2 * N)\n    for v in nodes:\n        if len(edges[v]) == 1:\n            nv = edges[v].pop()\n            pair_table[v] = nv\n            edges[nv].remove(v)\n            v, pv = nv, v\n            while len(edges[v]) == 1:\n                nv = edges[v].pop()\n                pair_table[v] = nv\n                edges[nv].remove(v)\n                v, pv = nv, v\n\n    v0 = 0\n    for v in nodes:\n        if len(edges[v]) != 0:\n            v0 = v\n            break\n    [v1, v2] = edges[v0]\n\n    r = 0\n    for nv0 in [v1, v2]:\n        nv, v = nv0, v0\n        pair_table[v] = nv\n        v, pv = nv, v\n        while v != v0:\n            [nv1, nv2] = edges[v]\n            nv = nv1 if nv1 != pv else nv2\n            pair_table[v] = nv\n            v, pv = nv, v\n        r += calc(nodes, pair_table)\n        r %= M\n\n    return r\n\n\ndef calc(nodes, pair_table):\n\n    is_root = [True] * (2 * N)\n    tree = [None] * (2 * N)\n    counts = [0] * (2 * N)\n    perms = [0] * (2 * N)\n\n    for v in nodes:\n        nv = pair_table[v]\n        nnv = pair_table[nv]\n        if v < nnv:\n            is_root[v] = False\n            if tree[nv] is None:\n                tree[nv] = []\n            tree[nv].append(v)\n\n    c = 0\n    for v in nodes:\n        if is_root[v]:\n            calc_node(v, tree, counts, perms)\n            c += counts[v]\n    p = F[c]\n    for v in nodes:\n        if is_root[v]:\n            p *= powmod(F[counts[v]], M - 2, M)\n            p %= M\n            p *= perms[v]\n            p %= M\n\n    return p\n\n\ndef calc_node(node, tree, counts, perms):\n\n    if tree[node] is None:\n        counts[node] = 1\n        perms[node] = 1\n    else:\n        c = 0\n        for child in tree[node]:\n            calc_node(child, tree, counts, perms)\n            c += counts[child]\n        counts[node] = c + 1\n        p = F[c]\n        for child in tree[node]:\n            p *= powmod(F[counts[child]], M - 2, M)\n            p %= M\n            p *= perms[child]\n            p %= M\n        perms[node] = p\n\ndef powmod(a, x, m):\n    y = 1\n    while 0 < x:\n        if x % 2 == 1:\n            y *= a\n            y %= m\n        x //= 2\n        a = a ** 2\n        a %= M\n\n    return y\n\n\ndef main():\n    global F\n    global N\n    global edges\n\n    N = int(input())\n    balls = []\n    for i in range(2 * N):\n        na = list(map(int, input().split()))\n        balls.append((na[0] - 1, N + na[1] - 1))\n\n    p = 1\n    for i in range(1, 2 * N + 1):\n        p *= i\n        p %= M\n        F.append(p)\n\n    uf = UnionFind(2 * N)\n    edges = []\n    for i in range(2 * N):\n        edges.append([])\n\n    for x, y in balls:\n        uf.unite(x, y)\n        edges[x].append(y)\n        edges[y].append(x)\n\n\n    ans = F[2 * N]\n\n    for i in range(2 * N):\n        if len(edges[i]) == 0:\n            print(0)\n            return\n\n    groups = []\n    for i in range(2 * N):\n        groups.append(uf.find(i))\n\n    for i in range(2 * N):\n        if groups[i] == i:\n            nodes = [v for v in range(2 * N) if groups[v] == i]\n            num_nodes = len(nodes)\n            edge_counts = [len(edges[v]) for v in nodes]\n            num_edges = sum(edge_counts) // 2\n            if num_nodes != num_edges:\n                print(0)\n                return\n            ans *= powmod(F[num_nodes], M - 2, M)\n            ans *= solve(nodes)\n            ans %= M\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    E = []\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if y < z:\n                E.append((y,z))\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append((V,E))\n\ndef make_get_patterns(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {},{}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        else:\n            pass\n            get[0][(y,x)] = 1; get[1][(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 0; get[1][(y,x)] = 1\n        x = y\n    return get\n\ndef F(V,E):\n    # V is connected\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    E.sort()\n    for get in make_get_patterns(V):\n        den = 1\n        dp = {x:0 for x in V}\n        for x,y in E:\n            if get[(x,y)] == 0:\n                k = dp[x] + 1\n            else:\n                k = dp[y] + 1\n            dp[x] += k\n            dp[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\nU = N+N+10\nfact = [1] * (U+1); fact_inv = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\nX_to_Y = [[] for _ in range(N+1)]\nY_to_X = [[] for _ in range(N+1)]\nfor x,y in ball:\n    X_to_Y[x].append(y)\n    Y_to_X[y].append(x)\n\n# とりあえず連結成分に分けよう\nvisited_x = set()\nvisited_y = set()\ncomponents = []\nfor x,y in ball:\n    if x in visited_x:\n        continue\n    V = set()\n    V_x = set()\n    V_y = set()\n    q = [(x,y)]\n    while q:\n        x,y = q.pop()\n        V.add((x,y))\n        if x not in V_x:\n            V_x.add(x)\n            for t in X_to_Y[x]:\n                q.append((x,t))\n        if y not in V_y:\n            V_y.add(y)\n            for t in Y_to_X[y]:\n                q.append((t,y))\n        V_x.add(x)\n        V_y.add(y)\n    visited_x |= V_x\n    visited_y |= V_y\n    components.append((V,V_x,V_y))\n\ndef make_get_patterns(V_x,V_y):\n    rest_xy = {x:set(X_to_Y[x]) for x in V_x}\n    rest_yx = {y:set(Y_to_X[y]) for y in V_y}\n    deg1_x = set(x for x in V_x if len(rest_xy[x]) == 1)\n    deg1_y = set(y for y in V_y if len(rest_yx[y]) == 1)\n    get = {},{}\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.remove(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 1\n    for x in V_x:\n        if rest_xy[x]:\n            y = rest_xy[x].pop()\n            break\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    rest_yx[y].remove(x); deg1_y.add(y)\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 1\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.discard(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n    return get\n\ndef F(V,V_x,V_y):\n    # 連結成分上の順序がうまくいっている確率を返す\n    if len(V) != len(V_x) + len(V_y):\n        return 0\n    V = sorted(V)\n    ret = 0\n    for get in make_get_patterns(V_x,V_y):\n        den = 1\n        dp_x = {x:0 for x in V_x}\n        dp_y = {y:0 for y in V_y}\n        for x,y in V:\n            if get[(x,y)] == 0: # x軸でとる\n                k = dp_x[x] + 1\n            else:\n                k = dp_y[y] + 1\n            dp_x[x] += k\n            dp_y[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\n    if prob == 0:\n        break\nanswer = prob * fact[N+N] % MOD\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\nU = N+N+10\nfact = [1] * (U+1); fact_inv = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\nX_to_Y = [[] for _ in range(N+1)]\nY_to_X = [[] for _ in range(N+1)]\nfor x,y in ball:\n    X_to_Y[x].append(y)\n    Y_to_X[y].append(x)\n\n# とりあえず連結成分に分けよう\nvisited_x = set()\nvisited_y = set()\ncomponents = []\nfor x,y in ball:\n    if x in visited_x:\n        continue\n    V = set()\n    V_x = set()\n    V_y = set()\n    q = [(x,y)]\n    while q:\n        x,y = q.pop()\n        V.add((x,y))\n        if x not in V_x:\n            V_x.add(x)\n            for t in X_to_Y[x]:\n                q.append((x,t))\n        if y not in V_y:\n            V_y.add(y)\n            for t in Y_to_X[y]:\n                q.append((t,y))\n        V_x.add(x)\n        V_y.add(y)\n    visited_x |= V_x\n    visited_y |= V_y\n    components.append((V,V_x,V_y))\n\ndef make_get_patterns(V_x,V_y):\n    assert len(V) == len(V_x) + len(V_y)\n    rest_xy = {x:set(X_to_Y[x]) for x in V_x}\n    rest_yx = {y:set(Y_to_X[y]) for y in V_y}\n    deg1_x = set(x for x in V_x if len(rest_xy[x]) == 1)\n    deg1_y = set(y for y in V_y if len(rest_yx[y]) == 1)\n    get = {},{}\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.remove(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 1\n    for x in V_x:\n        if rest_xy[x]:\n            y = rest_xy[x].pop()\n            break\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    rest_yx[y].remove(x); deg1_y.add(y)\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 1\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.discard(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n    return get\n\ndef F(V,V_x,V_y):\n    # 連結成分上の順序がうまくいっている確率を返す\n    if len(V) != len(V_x) + len(V_y):\n        return 0\n    V = sorted(V)\n    ret = 0\n    for get in make_get_patterns(V_x,V_y):\n        den = 1\n        dp_x = {x:0 for x in V_x}\n        dp_y = {y:0 for y in V_y}\n        for x,y in V:\n            if get[(x,y)] == 0: # x軸でとる\n                k = dp_x[x] + 1\n            else:\n                k = dp_y[y] + 1\n            dp_x[x] += k\n            dp_y[y] += k\n            den *= k\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\nanswer = prob * fact[N+N] % MOD\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    E = []\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if y < z:\n                E.append((y,z))\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append((V,E))\n\ndef make_get_pattern(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[(x,y)] = 0\n        else:\n            pass\n            get[(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[(x,y)] = 2\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[(x,y)] = 3\n        else:\n            get[(y,x)] = 2\n        x = y\n    return get\n\ndef F(V,E):\n    # V is connected\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    E.sort()\n    get = make_get_pattern(V)\n    den1,den2 = 1,1\n    dp1 = {x:0 for x in V}\n    dp2 = {x:0 for x in V}\n    for x,y in E:\n        if get[(x,y)] == 0:\n            k1 = dp1[x] + 1; k2 = dp2[x] + 1\n        elif get[(x,y)] == 1:\n            k1 = dp1[y] + 1; k2 = dp2[y] + 1\n        elif get[(x,y)] == 2:\n            k1 = dp1[x] + 1; k2 = dp2[y] + 1\n        else:\n            k1 = dp1[y] + 1; k2 = dp2[x] + 1\n        dp1[x] += k1; dp1[y] += k1\n        dp2[x] += k2; dp2[y] += k2\n        den1 *= k1; den2 *= k2\n        den1 %= MOD; den2 %= MOD\n    return sum(pow(x,MOD-2,MOD) for x in (den1,den2))\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\nU = N+N+10\nfact = [1] * (U+1); fact_inv = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\nX_to_Y = [[] for _ in range(N+1)]\nY_to_X = [[] for _ in range(N+1)]\nfor x,y in ball:\n    X_to_Y[x].append(y)\n    Y_to_X[y].append(x)\n\n# とりあえず連結成分に分けよう\nvisited_x = set()\nvisited_y = set()\ncomponents = []\nfor x,y in ball:\n    if x in visited_x:\n        continue\n    V = set()\n    V_x = set()\n    V_y = set()\n    q = [(x,y)]\n    while q:\n        x,y = q.pop()\n        V.add((x,y))\n        if x not in V_x:\n            V_x.add(x)\n            for t in X_to_Y[x]:\n                q.append((x,t))\n        if y not in V_y:\n            V_y.add(y)\n            for t in Y_to_X[y]:\n                q.append((t,y))\n        V_x.add(x)\n        V_y.add(y)\n    visited_x |= V_x\n    visited_y |= V_y\n    components.append((V,V_x,V_y))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = [x]\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if visited[z]:\n                continue\n            V.append(z)\n            visited[z] = True\n            q.append(z)\n    components.append(V)\n\ndef make_get_patterns(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {},{}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        else:\n            pass\n            get[0][(y,x)] = 1; get[1][(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    while True:\n        if not graph[x]:\n            break\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 0; get[1][(y,x)] = 1\n        x = y\n    return get\n\ndef F(V):\n    # V is connected\n    E = sorted((x,y) for x in V if x <= N for y in graph[x])\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    for get in make_get_patterns(V):\n        den = 1\n        dp = {x:0 for x in V}\n        for x,y in E:\n            if get[(x,y)] == 0:\n                k = dp[x] + 1\n            else:\n                k = dp[y] + 1\n            dp[x] += k\n            dp[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\nU = N+N+10\nfact = [1] * (U+1); fact_inv = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\nX_to_Y = [[] for _ in range(N+1)]\nY_to_X = [[] for _ in range(N+1)]\nfor x,y in ball:\n    X_to_Y[x].append(y)\n    Y_to_X[y].append(x)\n\n# とりあえず連結成分に分けよう\nvisited_x = set()\nvisited_y = set()\ncomponents = []\nfor x,y in ball:\n    if x in visited_x:\n        continue\n    V = set()\n    V_x = set()\n    V_y = set()\n    q = [(x,y)]\n    while q:\n        x,y = q.pop()\n        V.add((x,y))\n        if x not in V_x:\n            V_x.add(x)\n            for t in X_to_Y[x]:\n                q.append((x,t))\n        if y not in V_y:\n            V_y.add(y)\n            for t in Y_to_X[y]:\n                q.append((t,y))\n        V_x.add(x)\n        V_y.add(y)\n    visited_x |= V_x\n    visited_y |= V_y\n    components.append((V,V_x,V_y))\n\ndef make_get_patterns(V_x,V_y):\n    assert len(V) == len(V_x) + len(V_y)\n    rest_xy = {x:set(X_to_Y[x]) for x in V_x}\n    rest_yx = {y:set(Y_to_X[y]) for y in V_y}\n    deg1_x = set(x for x in V_x if len(rest_xy[x]) == 1)\n    deg1_y = set(y for y in V_y if len(rest_yx[y]) == 1)\n    get = {},{}\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.remove(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 1\n    for x in V_x:\n        if rest_xy[x]:\n            y = rest_xy[x].pop()\n            break\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    rest_yx[y].remove(x); deg1_y.add(y)\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 1\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.discard(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n    return get\n\ndef F(V,V_x,V_y):\n    # 連結成分上の順序がうまくいっている確率を返す\n    if len(V) != len(V_x) + len(V_y):\n        return 0\n    V = sorted(V)\n    ret = 0\n    for get in make_get_patterns(V_x,V_y):\n        den = 1\n        dp_x = {x:0 for x in V_x}\n        dp_y = {y:0 for y in V_y}\n        for x,y in V:\n            if get[(x,y)] == 0: # x軸でとる\n                k = dp_x[x] + 1\n            else:\n                k = dp_y[y] + 1\n            dp_x[x] += k\n            dp_y[y] += k\n            den *= k\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\nanswer = prob * fact[N+N] % MOD\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nclass UnionFind():\n    def __init__(self, size):\n        self.table = [-1] * size\n\n    def find(self, x):\n        while 0 <= self.table[x]:\n            x = self.table[x]\n        return x\n\n    def unite(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            dx = -self.table[rx]\n            dy = -self.table[ry]\n            if dx != dy:\n                if dx < dy:\n                    self.table[rx] = ry\n                else:\n                    self.table[ry] = rx\n            else:\n                self.table[rx] -= 1\n                self.table[ry] = rx\n        return\n\n\nM = 10 ** 9 + 7\nN = 0\nF = [0]\nedges = []\n\n\ndef solve(nodes):\n    global edges\n\n    pair_table = [0] * (2 * N)\n    for v in nodes:\n        if len(edges[v]) == 1:\n            nv = edges[v].pop()\n            pair_table[v] = nv\n            edges[nv].remove(v)\n            v, pv = nv, v\n            while len(edges[v]) == 1:\n                nv = edges[v].pop()\n                pair_table[v] = nv\n                edges[nv].remove(v)\n                v, pv = nv, v\n\n    v0 = 0\n    for v in nodes:\n        if len(edges[v]) != 0:\n            v0 = v\n            break\n    [v1, v2] = edges[v0]\n\n    r = 0\n    for nv0 in [v1, v2]:\n        nv, v = nv0, v0\n        pair_table[v] = nv\n        v, pv = nv, v\n        while v != v0:\n            [nv1, nv2] = edges[v]\n            nv = nv1 if nv1 != pv else nv2\n            pair_table[v] = nv\n            v, pv = nv, v\n        r += calc(nodes, pair_table)\n        r %= M\n\n    return r\n\n\ndef calc(nodes, pair_table):\n\n    is_root = [True] * (2 * N)\n    tree = [None] * (2 * N)\n    counts = [0] * (2 * N)\n    perms = [0] * (2 * N)\n\n    for v in nodes:\n        nv = pair_table[v]\n        nnv = pair_table[nv]\n        if v < nnv:\n            is_root[v] = False\n            if tree[nv] is None:\n                tree[nv] = []\n            tree[nv].append(v)\n\n    c = 0\n    for v in nodes:\n        if is_root[v]:\n            calc_node(v, tree, counts, perms)\n            c += counts[v]\n    p = F[c]\n    for v in nodes:\n        if is_root[v]:\n            p *= powmod(F[counts[v]], M - 2, M)\n            p %= M\n            p *= perms[v]\n            p %= M\n\n    return p\n\n\ndef calc_node(node, tree, counts, perms):\n\n    if tree[node] is None:\n        counts[node] = 1\n        perms[node] = 1\n    else:\n        c = 0\n        for child in tree[node]:\n            calc_node(child, tree, counts, perms)\n            c += counts[child]\n        counts[node] = c + 1\n        p = F[c]\n        for child in tree[node]:\n            p *= powmod(F[counts[child]], M - 2, M)\n            p %= M\n            p *= perms[child]\n            p %= M\n        perms[node] = p\n\ndef powmod(a, x, m):\n    y = 1\n    while 0 < x:\n        if x % 2 == 1:\n            y *= a\n            y %= m\n        x //= 2\n        a = a ** 2\n        a %= M\n\n    return y\n\n\ndef main():\n    global F\n    global N\n    global edges\n\n    N = int(input())\n    balls = []\n    for i in range(2 * N):\n        na = list(map(int, input().split()))\n        balls.append((na[0] - 1, N + na[1] - 1))\n\n    p = 1\n    for i in range(1, 2 * N + 1):\n        p *= i\n        p %= M\n        F.append(p)\n\n    uf = UnionFind(2 * N)\n    edges = []\n    for i in range(2 * N):\n        edges.append([])\n\n    for x, y in balls:\n        uf.unite(x, y)\n        edges[x].append(y)\n        edges[y].append(x)\n\n\n    ans = F[2 * N]\n\n    for i in range(2 * N):\n        if len(edges[i]) == 0:\n            print(0)\n            return\n\n    for i in range(2 * N):\n        if uf.find(i) == i:\n            nodes = [v for v in range(2 * N) if uf.find(v) == i]\n            num_nodes = len(nodes)\n            edge_counts = [len(edges[v]) for v in nodes]\n            num_edges = sum(edge_counts) // 2\n            if num_nodes != num_edges:\n                print(0)\n                return\n            ans *= powmod(F[num_nodes], M - 2, M)\n            ans *= solve(nodes)\n            ans %= M\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = set()\ncomponents = []\nfor x in range(1,N+N+1):\n    if x in visited:\n        continue\n    V = set([x])\n    q = [x]\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if z in V:\n                continue\n            V.add(z)\n            q.append(z)\n    visited |= V\n    components.append(V)\n\ndef make_get_patterns(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {},{}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        else:\n            pass\n            get[0][(y,x)] = 1; get[1][(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    while True:\n        if not graph[x]:\n            break\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 0; get[1][(y,x)] = 1\n        x = y\n    return get\n\ndef F(V):\n    # V is connected\n    E = sorted((x,y) for x in V if x <= N for y in graph[x])\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    for get in make_get_patterns(V):\n        den = 1\n        dp = {x:0 for x in V}\n        for x,y in E:\n            if get[(x,y)] == 0:\n                k = dp[x] + 1\n            else:\n                k = dp[y] + 1\n            dp[x] += k\n            dp[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\nimport time\nstart = time.time()\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    E = []\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if y < z:\n                E.append((y,z))\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append((V,E))\n\ndef make_get_pattern(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[(x,y)] = 0\n        else:\n            get[(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[(x,y)] = 2\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[(x,y)] = 3\n        else:\n            get[(y,x)] = 2\n        x = y\n    return get\n\ndef F(V,E):\n    # V is connected\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    E.sort()\n    get = make_get_pattern(V)\n    den1,den2 = 1,1\n    dp1 = {x:0 for x in V}\n    dp2 = {x:0 for x in V}\n    for x,y in E:\n        if get[(x,y)] == 0:\n            k1 = dp1[x] + 1; k2 = dp2[x] + 1\n        elif get[(x,y)] == 1:\n            k1 = dp1[y] + 1; k2 = dp2[y] + 1\n        elif get[(x,y)] == 2:\n            k1 = dp1[x] + 1; k2 = dp2[y] + 1\n        else:\n            k1 = dp1[y] + 1; k2 = dp2[x] + 1\n        dp1[x] += k1; dp1[y] += k1\n        dp2[x] += k2; dp2[y] += k2\n        den1 *= k1; den2 *= k2\n        den1 %= MOD; den2 %= MOD\n    return sum(pow(x,MOD-2,MOD) for x in (den1,den2))\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)\n\ntime.time()-start"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\n# x座標を1,2,...,N\n# y座標をN+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = set()\ncomponents = []\nfor x in range(1,N+N+1):\n    if x in visited:\n        continue\n    V = set([x])\n    q = [x]\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if z in V:\n                continue\n            V.add(z)\n            q.append(z)\n    visited |= V\n    components.append(V)\n\ndef make_get_patterns(V):\n    deg1 = set(x for x in V if len(graph[x]) == 1)\n    get = {},{}\n    while deg1:\n        x = deg1.pop()\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.add(y)\n        elif len(se) == 0: deg1.remove(y)\n        if x < y:\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 1; get[1][(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # 残りはサイクル\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    while True:\n        if not graph[x]:\n            break\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 0; get[1][(y,x)] = 1\n        x = y\n    return get\n\ndef F(V):\n    # V is connected\n    E = sorted((x,y) for x in V if x <= N for y in graph[x])\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    for get in make_get_patterns(V):\n        den = 1\n        dp = {x:0 for x in V}\n        for x,y in E:\n            if get[(x,y)] == 0:\n                k = dp[x] + 1\n            else:\n                k = dp[y] + 1\n            dp[x] += k\n            dp[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\nU = N+N+10\nfact = [1] * (U+1); fact_inv = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\nX_to_Y = [[] for _ in range(N+1)]\nY_to_X = [[] for _ in range(N+1)]\nfor x,y in ball:\n    X_to_Y[x].append(y)\n    Y_to_X[y].append(x)\n\n# とりあえず連結成分に分けよう\nvisited_x = set()\nvisited_y = set()\ncomponents = []\nfor x,y in ball:\n    if x in visited_x:\n        continue\n    V = set()\n    V_x = set()\n    V_y = set()\n    q = [(x,y)]\n    while q:\n        x,y = q.pop()\n        V.add((x,y))\n        if x not in V_x:\n            V_x.add(x)\n            for t in X_to_Y[x]:\n                q.append((x,t))\n        if y not in V_y:\n            V_y.add(y)\n            for t in Y_to_X[y]:\n                q.append((t,y))\n        V_x.add(x)\n        V_y.add(y)\n    visited_x |= V_x\n    visited_y |= V_y\n    components.append((V,V_x,V_y))\n\ndef make_get_patterns(V_x,V_y):\n    assert len(V) == len(V_x) + len(V_y)\n    rest_xy = {x:set(X_to_Y[x]) for x in V_x}\n    rest_yx = {y:set(Y_to_X[y]) for y in V_y}\n    deg1_x = set(x for x in V_x if len(rest_xy[x]) == 1)\n    deg1_y = set(y for y in V_y if len(rest_yx[y]) == 1)\n    get = {},{}\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.remove(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 1\n    for x in V_x:\n        if rest_xy[x]:\n            y = rest_xy[x].pop()\n            break\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    rest_yx[y].remove(x); deg1_y.add(y)\n    while deg1_x or deg1_y:\n        while deg1_x:\n            x = deg1_x.pop()\n            y = rest_xy[x].pop()\n            se = rest_yx[y]; se.remove(x)\n            if len(se) == 1: deg1_y.add(y)\n            elif len(se) == 0: deg1_y.remove(y)\n            get[0][(x,y)] = 0; get[1][(x,y)] = 1\n        while deg1_y:\n            y = deg1_y.pop()\n            x = rest_yx[y].pop()\n            se = rest_xy[x]; se.remove(y)\n            if len(se) == 1: deg1_x.add(x)\n            elif len(se) == 0: deg1_x.discard(x)\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n    return get\n\ndef F(V,V_x,V_y):\n    # 連結成分上の順序がうまくいっている確率を返す\n    if len(V) != len(V_x) + len(V_y):\n        return 0\n    V = sorted(V)\n    ret = 0\n    for get in make_get_patterns(V_x,V_y):\n        den = 1\n        dp_x = {x:0 for x in V_x}\n        dp_y = {y:0 for y in V_y}\n        for x,y in V:\n            if get[(x,y)] == 0: # x軸でとる\n                k = dp_x[x] + 1\n            else:\n                k = dp_y[y] + 1\n            dp_x[x] += k\n            dp_y[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\nanswer = prob * fact[N+N] % MOD\nprint(answer)\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 {\n            ans = ans * base % modulo;\n        }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 100100;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX + 1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe { FACTORIAL[n] }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 {\n        return 0;\n    }\n    init_fact();\n    unsafe { FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD }\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.src, self.dest).cmp(&(other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize) {\n    graph[src].push(Edge::new(*index, src, dest));\n    graph[dest].push(Edge::new(*index, dest, src));\n    *index += 1;\n}\n\nfn merge(lhs: (usize, usize), rhs: (usize, usize)) -> (usize, usize) {\n    let cnt = lhs.1 + rhs.1;\n    let v = lhs.0 as i64 * rhs.0 as i64 % MOD * combi(cnt, lhs.1) % MOD;\n    (v as usize, cnt)\n}\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        let n: usize = read();\n        let mut g = graph_new(2 * n);\n        let mut e = 0;\n        for _ in 0..n * 2 {\n            let x = read::<usize>() - 1;\n            let y = read::<usize>() - 1;\n            add_bi_edge(&mut g, &mut e, y, x + n);\n        }\n        Solver { n: n, g: g }\n    }\n    fn usable(&self, constraint: &Edge, edge: &Edge) -> bool {\n        edge.dest < constraint.dest\n    }\n    fn dfs1(&mut self, from: usize, connected: &mut HashSet<usize>) -> usize {\n        if connected.contains(&from) {\n            return 0;\n        }\n        let mut ret = self.g[from].len();\n        connected.insert(from);\n        for edge in self.g[from].clone().iter() {\n            ret += self.dfs1(edge.dest, connected);\n        }\n        ret\n    }\n    fn set_direction(&self, connected: &HashSet<usize>, dir: usize) -> HashMap<usize, Edge> {\n        let mut edge_cnt = HashMap::<usize, usize>::new();\n        let mut stack = vec![];\n        for &node in connected.iter() {\n            let cnt = self.g[node].len();\n            edge_cnt.insert(node, cnt);\n            if cnt == 1 {\n                stack.push(node);\n            }\n        }\n        let mut ret = HashMap::<usize, Edge>::new();\n        let mut used_edge = HashSet::<usize>::new();\n        let mut second_start = false;\n        for _ in 0..2 {\n            while let Some(from) = stack.pop() {\n                for edge in self.g[from].clone().iter() {\n                    // println!(\"{:?}\", edge);\n                    if used_edge.contains(&edge.index) {\n                        continue;\n                    }\n                    if second_start {\n                        second_start = false;\n                        continue;\n                    }\n                    used_edge.insert(edge.index);\n                    assert!(!ret.contains_key(&from));\n                    ret.insert(from, edge.clone());\n                    *edge_cnt.get_mut(&edge.dest).unwrap() -= 1;\n                    if edge_cnt[&edge.dest] == 1 {\n                        stack.push(edge.dest);\n                    }\n                    break;\n                }\n            }\n            if dir == 1 {\n                second_start = true;\n            }\n            // println!(\"{:?}\", ret);\n            for &node in connected.iter() {\n                if edge_cnt[&node] == 2 {\n                    stack.push(node);\n                    break;\n                }\n            }\n        }\n        ret\n    }\n    fn calc(&self, from: usize, matching: &HashMap<usize, Edge>) -> (usize, usize) {\n        let mut ret = (1, 0);\n        for edge in self.g[from].iter() {\n            if !self.usable(&matching[&from], edge) {\n                continue;\n            }\n            // println!(\"{:?} {:?}\", matching[&from], edge);\n            let nret = self.calc(edge.dest, matching);\n            ret = merge(ret, nret);\n        }\n        ret.1 += 1;\n        ret\n    }\n    fn solve(&mut self) {\n        let mut ans = (1, 0);\n        let mut visited = vec![false; 2 * self.n];\n        for node in 0..2 * self.n {\n            if visited[node] {\n                continue;\n            }\n            let mut connected = HashSet::<usize>::new();\n            let edge_cnt = self.dfs1(node, &mut connected) / 2;\n            if edge_cnt != connected.len() {\n                ans = (0, 0);\n                break;\n            }\n            for &node in connected.iter() {\n                visited[node] = true;\n            }\n            let mut sum = 0;\n            for dir in 0..2 {\n                // println!(\"calc connect: {} {}\", node, dir);\n                // let matching = self.set_direction(&connected, dir);\n                // assert!(matching.len() == connected.len());\n                // let mut lans = (1, 0);\n                // // println!(\"{:?}\", matching);\n                // for &node in connected.iter() {\n                //     let dest = matching[&node].dest;\n                //     if !self.usable(&matching[&dest], &Edge::new(0, dest, node)) {\n                //         let mut nret = self.calc(node, &matching);\n                //         // println!(\"{:?}\", nret);\n                //         lans = merge(lans, nret);\n                //     }\n                // }\n                // sum = (sum + lans.0) % MOD as usize;\n            }\n            ans = merge(ans, (sum, connected.len()));\n        }\n        println!(\"{}\", ans.0);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.solve();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 {\n            ans = ans * base % modulo;\n        }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 100100;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX + 1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe { FACTORIAL[n] }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 {\n        return 0;\n    }\n    init_fact();\n    unsafe { FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD }\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.src, self.dest).cmp(&(other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize) {\n    graph[src].push(Edge::new(*index, src, dest));\n    graph[dest].push(Edge::new(*index, dest, src));\n    *index += 1;\n}\n\nfn merge(lhs: (usize, usize), rhs: (usize, usize)) -> (usize, usize) {\n    let cnt = lhs.1 + rhs.1;\n    let v = lhs.0 as i64 * rhs.0 as i64 % MOD * combi(cnt, lhs.1) % MOD;\n    (v as usize, cnt)\n}\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        let n: usize = read();\n        let mut g = graph_new(2 * n);\n        let mut e = 0;\n        for _ in 0..n * 2 {\n            let x = read::<usize>() - 1;\n            let y = read::<usize>() - 1;\n            add_bi_edge(&mut g, &mut e, y, x + n);\n        }\n        Solver { n: n, g: g }\n    }\n    fn usable(&self, constraint: &Edge, edge: &Edge) -> bool {\n        edge.dest < constraint.dest\n    }\n    fn dfs1(&mut self, from: usize, connected: &mut HashSet<usize>) -> usize {\n        if connected.contains(&from) {\n            return 0;\n        }\n        let mut ret = self.g[from].len();\n        connected.insert(from);\n        for edge in self.g[from].clone().iter() {\n            ret += self.dfs1(edge.dest, connected);\n        }\n        ret\n    }\n    fn set_direction(&self, connected: &HashSet<usize>, dir: usize) -> HashMap<usize, Edge> {\n        let mut edge_cnt = HashMap::<usize, usize>::new();\n        let mut stack = vec![];\n        for &node in connected.iter() {\n            let cnt = self.g[node].len();\n            edge_cnt.insert(node, cnt);\n            if cnt == 1 {\n                stack.push(node);\n            }\n        }\n        let mut ret = HashMap::<usize, Edge>::new();\n        let mut used_edge = HashSet::<usize>::new();\n        let mut second_start = false;\n        for _ in 0..2 {\n            while let Some(from) = stack.pop() {\n                for edge in self.g[from].clone().iter() {\n                    // println!(\"{:?}\", edge);\n                    if used_edge.contains(&edge.index) {\n                        continue;\n                    }\n                    if second_start {\n                        second_start = false;\n                        continue;\n                    }\n                    used_edge.insert(edge.index);\n                    assert!(!ret.contains_key(&from));\n                    ret.insert(from, edge.clone());\n                    *edge_cnt.get_mut(&edge.dest).unwrap() -= 1;\n                    if edge_cnt[&edge.dest] == 1 {\n                        stack.push(edge.dest);\n                    }\n                    break;\n                }\n            }\n            if dir == 1 {\n                second_start = true;\n            }\n            // println!(\"{:?}\", ret);\n            for &node in connected.iter() {\n                if edge_cnt[&node] == 2 {\n                    stack.push(node);\n                    break;\n                }\n            }\n        }\n        ret\n    }\n    fn calc(&self, from: usize, matching: &HashMap<usize, Edge>) -> (usize, usize) {\n        let mut ret = (1, 0);\n        for edge in self.g[from].iter() {\n            if !self.usable(&matching[&from], edge) {\n                continue;\n            }\n            // println!(\"{:?} {:?}\", matching[&from], edge);\n            let nret = self.calc(edge.dest, matching);\n            ret = merge(ret, nret);\n        }\n        ret.1 += 1;\n        ret\n    }\n    fn solve(&mut self) {\n        let mut ans = (1, 0);\n        let mut visited = vec![false; 2 * self.n];\n        for node in 0..2 * self.n {\n            if visited[node] {\n                continue;\n            }\n            let mut connected = HashSet::<usize>::new();\n            let edge_cnt = self.dfs1(node, &mut connected) / 2;\n            if edge_cnt != connected.len() {\n                ans = (0, 0);\n                break;\n            }\n            for &node in connected.iter() {\n                visited[node] = true;\n            }\n            let mut sum = 0;\n            for dir in 0..2 {\n                // println!(\"calc connect: {} {}\", node, dir);\n                let matching = self.set_direction(&connected, dir);\n                assert!(matching.len() == connected.len());\n                let mut lans = (1, 0);\n                // println!(\"{:?}\", matching);\n                for &node in connected.iter() {\n                    let dest = matching[&node].dest;\n                    if !self.usable(&matching[&dest], &Edge::new(0, dest, node)) {\n                        let mut nret = self.calc(node, &matching);\n                        // println!(\"{:?}\", nret);\n                        lans = merge(lans, nret);\n                    }\n                }\n                sum = (sum + lans.0) % MOD as usize;\n            }\n            ans = merge(ans, (sum, connected.len()));\n        }\n        println!(\"{}\", ans.0);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.solve();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 {\n            ans = ans * base % modulo;\n        }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 100100;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX + 1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe { FACTORIAL[n] }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 {\n        return 0;\n    }\n    init_fact();\n    unsafe { FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD }\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.src, self.dest).cmp(&(other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize) {\n    graph[src].push(Edge::new(*index, src, dest));\n    graph[dest].push(Edge::new(*index, dest, src));\n    *index += 1;\n}\n\nfn merge(lhs: (usize, usize), rhs: (usize, usize)) -> (usize, usize) {\n    let cnt = lhs.1 + rhs.1;\n    let v = lhs.0 as i64 * rhs.0 as i64 % MOD * combi(cnt, lhs.1) % MOD;\n    (v as usize, cnt)\n}\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        let n: usize = read();\n        let mut g = graph_new(2 * n);\n        let mut e = 0;\n        for _ in 0..n * 2 {\n            let x = read::<usize>() - 1;\n            let y = read::<usize>() - 1;\n            add_bi_edge(&mut g, &mut e, y, x + n);\n        }\n        Solver { n: n, g: g }\n    }\n    fn usable(&self, constraint: &Edge, edge: &Edge) -> bool {\n        edge.dest < constraint.dest\n    }\n    fn dfs1(&mut self, from: usize, connected: &mut HashSet<usize>) -> usize {\n        if connected.contains(&from) {\n            return 0;\n        }\n        let mut ret = self.g[from].len();\n        connected.insert(from);\n        for edge in self.g[from].clone().iter() {\n            ret += self.dfs1(edge.dest, connected);\n        }\n        ret\n    }\n    fn set_direction(&self, connected: &HashSet<usize>, dir: usize) -> HashMap<usize, Edge> {\n        let mut edge_cnt = HashMap::<usize, usize>::new();\n        let mut stack = vec![];\n        for &node in connected.iter() {\n            let cnt = self.g[node].len();\n            edge_cnt.insert(node, cnt);\n            if cnt == 1 {\n                stack.push(node);\n            }\n        }\n        let mut ret = HashMap::<usize, Edge>::new();\n        let mut used_edge = HashSet::<usize>::new();\n        let mut second_start = false;\n        for _ in 0..2 {\n            while let Some(from) = stack.pop() {\n                for edge in self.g[from].clone().iter() {\n                    // println!(\"{:?}\", edge);\n                    if used_edge.contains(&edge.index) {\n                        continue;\n                    }\n                    if second_start {\n                        second_start = false;\n                        continue;\n                    }\n                    used_edge.insert(edge.index);\n                    assert!(!ret.contains_key(&from));\n                    ret.insert(from, edge.clone());\n                    *edge_cnt.get_mut(&edge.dest).unwrap() -= 1;\n                    if edge_cnt[&edge.dest] == 1 {\n                        stack.push(edge.dest);\n                    }\n                    break;\n                }\n            }\n            if dir == 1 {\n                second_start = true;\n            }\n            // println!(\"{:?}\", ret);\n            for &node in connected.iter() {\n                if edge_cnt[&node] == 2 {\n                    stack.push(node);\n                    break;\n                }\n            }\n        }\n        ret\n    }\n    fn calc(&self, from: usize, matching: &HashMap<usize, Edge>) -> (usize, usize) {\n        let mut ret = (1, 0);\n        for edge in self.g[from].iter() {\n            if !self.usable(&matching[&from], edge) {\n                continue;\n            }\n            // println!(\"{:?} {:?}\", matching[&from], edge);\n            let nret = self.calc(edge.dest, matching);\n            ret = merge(ret, nret);\n        }\n        ret.1 += 1;\n        ret\n    }\n    fn solve(&mut self) {\n        let mut ans = (1, 0);\n        let mut visited = vec![false; 2 * self.n];\n        for node in 0..2 * self.n {\n            if visited[node] {\n                continue;\n            }\n            let mut connected = HashSet::<usize>::new();\n            let edge_cnt = self.dfs1(node, &mut connected) / 2;\n            if edge_cnt != connected.len() {\n                ans = (0, 0);\n                break;\n            }\n            for &node in connected.iter() {\n                visited[node] = true;\n            }\n            let mut sum = 0;\n            for dir in 0..2 {\n                // println!(\"calc connect: {} {}\", node, dir);\n                // let matching = self.set_direction(&connected, dir);\n                // assert!(matching.len() == connected.len());\n                // let mut lans = (1, 0);\n                // // println!(\"{:?}\", matching);\n                // for &node in connected.iter() {\n                //     let dest = matching[&node].dest;\n                //     if !self.usable(&matching[&dest], &Edge::new(0, dest, node)) {\n                //         let mut nret = self.calc(node, &matching);\n                //         // println!(\"{:?}\", nret);\n                //         lans = merge(lans, nret);\n                //     }\n                // }\n                // sum = (sum + lans.0) % MOD as usize;\n            }\n            ans = merge(ans, (sum, connected.len()));\n        }\n        println!(\"{}\", ans.0);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.solve();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by: https://atcoder.jp/contests/pakencamp-2018-day3/submissions/3878249\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy + Clone { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<*const M> }\n    impl<M: Mod> ModInt<M> {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < M::m());\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt::new_internal(self.x * other.x % M::m())\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new_internal(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 { sum += cur; }\n                cur += cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod> Add for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod> Sub for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod> Mul for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self { self.mul_fast(other) }\n    }\n    impl<M: Mod> AddAssign for ModInt<M> {\n        fn add_assign(&mut self, other: Self) { *self = *self + other; }\n    }\n    impl<M: Mod> SubAssign for ModInt<M> {\n        fn sub_assign(&mut self, other: Self) { *self = *self - other; }\n    }\n    impl<M: Mod> MulAssign for ModInt<M> {\n        fn mul_assign(&mut self, other: Self) { *self = *self * other; }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998_244_353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    buf: Vec<usize>,\n}\n\nimpl BitSet {\n    // size should be a multiple of bit-size of usize.\n    fn new(size: usize) -> Self {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(size & (w - 1), 0);\n        let count = size / w;\n        BitSet {\n            size: size,\n            buf: vec![0; count],\n        }\n    }\n    fn set(&mut self, idx: usize, val: bool) {\n        debug_assert!(idx < self.size);\n        let w = 8 * std::mem::size_of::<usize>();\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        if val {\n            self.buf[idx0] |= 1 << idx1;\n        } else {\n            self.buf[idx0] &= !(1 << idx1);\n        }\n    }\n    fn shl(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i];\n            }\n        } else {\n            ans.buf[sh0] = self.buf[0] << sh1;\n            for i in 1 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i] << sh1\n                    | self.buf[i - 1] >> (w - sh1);\n            }\n        }\n        ans\n    }\n    fn shr(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i] = self.buf[i + sh0];\n            }\n        } else {\n            for i in 0 .. count - sh0 - 1 {\n                ans.buf[i] = self.buf[i + sh0] >> sh1\n                    | self.buf[i + sh0 + 1] << (w - sh1);\n            }\n            ans.buf[self.size - sh0 - 1] = self.buf[self.size - 1] >> sh1;\n        }\n        ans\n    }\n    fn msb(&self) -> Option<usize> {\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        for i in (0 .. count).rev() {\n            if self.buf[i] != 0 {\n                return Some(w * i + w - 1 - self.buf[i].leading_zeros() as usize);\n            }\n        }\n        None\n    }\n    fn get(&self, idx: usize) -> bool {\n        let w = 8 * std::mem::size_of::<usize>();\n        debug_assert!(idx < self.size);\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        (self.buf[idx0] >> idx1 & 1) == 1\n    }\n}\nimpl std::fmt::Display for BitSet {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        let size = match self.msb() {\n            None => return f.write_str(\"0\"),\n            Some(size) => size + 1,\n        };\n        for i in (0 .. size).rev() {\n            f.write_str(if self.get(i) { \"1\" } else { \"0\" })?\n        }\n        Ok(())\n    }\n}\nimpl std::fmt::Debug for BitSet {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        std::fmt::Display::fmt(&self, f)\n    }\n}\n\n// TODO reference is not allowed as rhs\nimpl<'a> std::ops::BitXorAssign for BitSet {\n    fn bitxor_assign(&mut self, other: BitSet) {\n        debug_assert_eq!(self.size, other.size);\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        for i in 0 .. count {\n            self.buf[i] ^= other.buf[i];\n        }\n    }\n}\n\nfn gcd(mut a: BitSet, mut b: BitSet) -> BitSet {\n    let (mut da, mut db) = match (a.msb(), b.msb()) {\n        (None, _) => return b,\n        (_, None) => return a,\n        (Some(da), Some(db)) => (da, db),\n    };\n    if da < db {\n        std::mem::swap(&mut da, &mut db);\n        std::mem::swap(&mut a, &mut b);\n    }\n\n    for i in (db .. da + 1).rev() {\n        if a.get(i) {\n            a ^= b.shl(i - db);\n        }\n    }\n    gcd(b, a)\n}\n\nconst W: usize = 4032;\nfn to_bitset(mut c: Vec<char>) -> BitSet {\n    let mut ans = BitSet::new(W);\n    c.reverse();\n    for i in 0 .. c.len() {\n        if c[i] == '1' {\n            ans.set(i, true);\n        }\n    }\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        x: chars,\n        a: [chars; n],\n    }\n    let x = to_bitset(x);\n    let a: Vec<BitSet> = a.into_iter().map(to_bitset).collect();\n    let mut g = to_bitset(vec!['0']);\n    for a in a { g = gcd(g, a); }\n    let hi = g.msb().unwrap();\n    let mut y = to_bitset(vec!['0']);\n    let mut r = x.clone();\n    // What is the largest multiple of g that is <= x?\n    for i in (hi .. W).rev() {\n        if r.get(i) {\n            r ^= g.shl(i - hi);\n            y.set(i - hi, true);\n        }\n    }\n    let mut z = x.clone();\n    z ^= r;\n    let mut lt = false;\n    for i in (0 .. W).rev() {\n        if x.get(i) != z.get(i) {\n            lt = x.get(i) < z.get(i);\n            break;\n        }\n    }\n    let mut tot = ModInt::new(0);\n    for i in (hi .. W).rev() {\n        tot += tot;\n        if z.get(i) {\n            tot += ModInt::new(1);\n        }\n    }\n    if !lt {\n        tot += ModInt::new(1);\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 {\n            ans = ans * base % modulo;\n        }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 100100;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX + 1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe { FACTORIAL[n] }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 {\n        return 0;\n    }\n    init_fact();\n    unsafe { FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD }\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.src, self.dest).cmp(&(other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize) {\n    graph[src].push(Edge::new(*index, src, dest));\n    graph[dest].push(Edge::new(*index, dest, src));\n    *index += 1;\n}\n\nfn merge(lhs: (usize, usize), rhs: (usize, usize)) -> (usize, usize) {\n    let cnt = lhs.1 + rhs.1;\n    let v = lhs.0 as i64 * rhs.0 as i64 % MOD * combi(cnt, lhs.1) % MOD;\n    (v as usize, cnt)\n}\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        let n: usize = read();\n        let mut g = graph_new(2 * n);\n        let mut e = 0;\n        for _ in 0..n * 2 {\n            let x = read::<usize>() - 1;\n            let y = read::<usize>() - 1;\n            add_bi_edge(&mut g, &mut e, y, x + n);\n        }\n        Solver { n: n, g: g }\n    }\n    fn usable(&self, constraint: &Edge, edge: &Edge) -> bool {\n        edge.dest < constraint.dest\n    }\n    fn dfs1(&mut self, from: usize, connected: &mut HashSet<usize>) -> usize {\n        if connected.contains(&from) {\n            return 0;\n        }\n        let mut ret = self.g[from].len();\n        connected.insert(from);\n        for edge in self.g[from].clone().iter() {\n            ret += self.dfs1(edge.dest, connected);\n        }\n        ret\n    }\n    fn set_direction(&self, connected: &HashSet<usize>, dir: usize) -> HashMap<usize, Edge> {\n        let mut edge_cnt = HashMap::<usize, usize>::new();\n        let mut stack = vec![];\n        for &node in connected.iter() {\n            let cnt = self.g[node].len();\n            edge_cnt.insert(node, cnt);\n            if cnt == 1 {\n                stack.push(node);\n            }\n        }\n        let mut ret = HashMap::<usize, Edge>::new();\n        let mut used_edge = HashSet::<usize>::new();\n        let mut second_start = false;\n        for _ in 0..2 {\n            while let Some(from) = stack.pop() {\n                for edge in self.g[from].clone().iter() {\n                    // println!(\"{:?}\", edge);\n                    if used_edge.contains(&edge.index) {\n                        continue;\n                    }\n                    if second_start {\n                        second_start = false;\n                        continue;\n                    }\n                    used_edge.insert(edge.index);\n                    assert!(!ret.contains_key(&from));\n                    ret.insert(from, edge.clone());\n                    *edge_cnt.get_mut(&edge.dest).unwrap() -= 1;\n                    if edge_cnt[&edge.dest] == 1 {\n                        stack.push(edge.dest);\n                    }\n                    break;\n                }\n            }\n            if dir == 1 {\n                second_start = true;\n            }\n            // println!(\"{:?}\", ret);\n            for &node in connected.iter() {\n                if edge_cnt[&node] == 2 {\n                    stack.push(node);\n                    break;\n                }\n            }\n        }\n        ret\n    }\n    fn calc(&self, from: usize, matching: &HashMap<usize, Edge>) -> (usize, usize) {\n        let mut ret = (1, 0);\n        for edge in self.g[from].iter() {\n            if !self.usable(&matching[&from], edge) {\n                continue;\n            }\n            // println!(\"{:?} {:?}\", matching[&from], edge);\n            let nret = self.calc(edge.dest, matching);\n            ret = merge(ret, nret);\n        }\n        ret.1 += 1;\n        ret\n    }\n    fn solve(&mut self) {\n        let mut ans = (1, 0);\n        let mut visited = vec![false; 2 * self.n];\n        for node in 0..2 * self.n {\n            if visited[node] {\n                continue;\n            }\n            let mut connected = HashSet::<usize>::new();\n            let edge_cnt = self.dfs1(node, &mut connected) / 2;\n            if edge_cnt != connected.len() {\n                ans = (0, 0);\n                break;\n            }\n            for &node in connected.iter() {\n                visited[node] = true;\n            }\n            let mut sum = 0;\n            for dir in 0..2 {\n                // println!(\"calc connect: {} {}\", node, dir);\n                let matching = self.set_direction(&connected, dir);\n                // assert!(matching.len() == connected.len());\n                // let mut lans = (1, 0);\n                // // println!(\"{:?}\", matching);\n                // for &node in connected.iter() {\n                //     let dest = matching[&node].dest;\n                //     if !self.usable(&matching[&dest], &Edge::new(0, dest, node)) {\n                //         let mut nret = self.calc(node, &matching);\n                //         // println!(\"{:?}\", nret);\n                //         lans = merge(lans, nret);\n                //     }\n                // }\n                // sum = (sum + lans.0) % MOD as usize;\n            }\n            ans = merge(ans, (sum, connected.len()));\n        }\n        println!(\"{}\", ans.0);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.solve();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 {\n            ans = ans * base % modulo;\n        }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 200100;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX + 1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe { FACTORIAL[n] }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 {\n        return 0;\n    }\n    init_fact();\n    unsafe { FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD }\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.src, self.dest).cmp(&(other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize) {\n    graph[src].push(Edge::new(*index, src, dest));\n    graph[dest].push(Edge::new(*index, dest, src));\n    *index += 1;\n}\n\nfn merge(lhs: (usize, usize), rhs: (usize, usize)) -> (usize, usize) {\n    let cnt = lhs.1 + rhs.1;\n    let v = lhs.0 as i64 * rhs.0 as i64 % MOD * combi(cnt, lhs.1) % MOD;\n    (v as usize, cnt)\n}\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        let n: usize = read();\n        let mut g = graph_new(2 * n);\n        let mut e = 0;\n        for _ in 0..n * 2 {\n            let x = read::<usize>() - 1;\n            let y = read::<usize>() - 1;\n            add_bi_edge(&mut g, &mut e, y, x + n);\n        }\n        Solver { n: n, g: g }\n    }\n    fn usable(&self, constraint: &Edge, edge: &Edge) -> bool {\n        edge.dest < constraint.dest\n    }\n    fn dfs1(&mut self, from: usize, connected: &mut HashSet<usize>) -> usize {\n        if connected.contains(&from) {\n            return 0;\n        }\n        let mut ret = self.g[from].len();\n        connected.insert(from);\n        for edge in self.g[from].clone().iter() {\n            ret += self.dfs1(edge.dest, connected);\n        }\n        ret\n    }\n    fn set_direction(&self, connected: &HashSet<usize>, dir: usize) -> HashMap<usize, Edge> {\n        let mut edge_cnt = HashMap::<usize, usize>::new();\n        let mut stack = vec![];\n        for &node in connected.iter() {\n            let cnt = self.g[node].len();\n            edge_cnt.insert(node, cnt);\n            if cnt == 1 {\n                stack.push(node);\n            }\n        }\n        let mut ret = HashMap::<usize, Edge>::new();\n        let mut used_edge = HashSet::<usize>::new();\n        let mut second_start = false;\n        for _ in 0..2 {\n            while let Some(from) = stack.pop() {\n                for edge in self.g[from].clone().iter() {\n                    // println!(\"{:?}\", edge);\n                    if used_edge.contains(&edge.index) {\n                        continue;\n                    }\n                    if second_start {\n                        second_start = false;\n                        continue;\n                    }\n                    used_edge.insert(edge.index);\n                    assert!(!ret.contains_key(&from));\n                    ret.insert(from, edge.clone());\n                    *edge_cnt.get_mut(&edge.dest).unwrap() -= 1;\n                    if edge_cnt[&edge.dest] == 1 {\n                        stack.push(edge.dest);\n                    }\n                    break;\n                }\n            }\n            if dir == 1 {\n                second_start = true;\n            }\n            // println!(\"{:?}\", ret);\n            for &node in connected.iter() {\n                if edge_cnt[&node] == 2 {\n                    stack.push(node);\n                    break;\n                }\n            }\n        }\n        ret\n    }\n    fn calc(&self, from: usize, matching: &HashMap<usize, Edge>) -> (usize, usize) {\n        let mut ret = (1, 0);\n        for edge in self.g[from].iter() {\n            if !self.usable(&matching[&from], edge) {\n                continue;\n            }\n            // println!(\"{:?} {:?}\", matching[&from], edge);\n            let nret = self.calc(edge.dest, matching);\n            ret = merge(ret, nret);\n        }\n        ret.1 += 1;\n        ret\n    }\n    fn solve(&mut self) {\n        let mut ans = (1, 0);\n        let mut visited = vec![false; 2 * self.n];\n        for node in 0..2 * self.n {\n            if visited[node] {\n                continue;\n            }\n            let mut connected = HashSet::<usize>::new();\n            let edge_cnt = self.dfs1(node, &mut connected) / 2;\n            if edge_cnt != connected.len() {\n                ans = (0, 0);\n                break;\n            }\n            for &node in connected.iter() {\n                visited[node] = true;\n            }\n            let mut sum = 0;\n            for dir in 0..2 {\n                // println!(\"calc connect: {} {}\", node, dir);\n                let matching = self.set_direction(&connected, dir);\n                assert!(matching.len() == connected.len());\n                let mut lans = (1, 0);\n                // println!(\"{:?}\", matching);\n                for &node in connected.iter() {\n                    let dest = matching[&node].dest;\n                    if !self.usable(&matching[&dest], &Edge::new(0, dest, node)) {\n                        let mut nret = self.calc(node, &matching);\n                        // println!(\"{:?}\", nret);\n                        lans = merge(lans, nret);\n                    }\n                }\n                sum = (sum + lans.0) % MOD as usize;\n            }\n            ans = merge(ans, (sum, connected.len()));\n        }\n        println!(\"{}\", ans.0);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.solve();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 {\n            ans = ans * base % modulo;\n        }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 100100;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX + 1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe { FACTORIAL[n] }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 {\n        return 0;\n    }\n    init_fact();\n    unsafe { FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD }\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.src, self.dest).cmp(&(other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize) {\n    graph[src].push(Edge::new(*index, src, dest));\n    graph[dest].push(Edge::new(*index, dest, src));\n    *index += 1;\n}\n\nfn merge(lhs: (usize, usize), rhs: (usize, usize)) -> (usize, usize) {\n    let cnt = lhs.1 + rhs.1;\n    let v = lhs.0 as i64 * rhs.0 as i64 % MOD * combi(cnt, lhs.1) % MOD;\n    (v as usize, cnt)\n}\n\nstruct Solver {\n    n: usize,\n    g: Graph,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        let n: usize = read();\n        let mut g = graph_new(2 * n);\n        let mut e = 0;\n        for _ in 0..n * 2 {\n            let x = read::<usize>() - 1;\n            let y = read::<usize>() - 1;\n            add_bi_edge(&mut g, &mut e, y, x + n);\n        }\n        Solver { n: n, g: g }\n    }\n    fn usable(&self, constraint: &Edge, edge: &Edge) -> bool {\n        edge.dest < constraint.dest\n    }\n    fn dfs1(&mut self, from: usize, connected: &mut HashSet<usize>) -> usize {\n        if connected.contains(&from) {\n            return 0;\n        }\n        let mut ret = self.g[from].len();\n        connected.insert(from);\n        for edge in self.g[from].clone().iter() {\n            ret += self.dfs1(edge.dest, connected);\n        }\n        ret\n    }\n    fn set_direction(&self, connected: &HashSet<usize>, dir: usize) -> HashMap<usize, Edge> {\n        let mut edge_cnt = HashMap::<usize, usize>::new();\n        let mut stack = vec![];\n        for &node in connected.iter() {\n            let cnt = self.g[node].len();\n            edge_cnt.insert(node, cnt);\n            if cnt == 1 {\n                stack.push(node);\n            }\n        }\n        let mut ret = HashMap::<usize, Edge>::new();\n        let mut used_edge = HashSet::<usize>::new();\n        let mut second_start = false;\n        for _ in 0..2 {\n            while let Some(from) = stack.pop() {\n                for edge in self.g[from].clone().iter() {\n                    // println!(\"{:?}\", edge);\n                    if used_edge.contains(&edge.index) {\n                        continue;\n                    }\n                    if second_start {\n                        second_start = false;\n                        continue;\n                    }\n                    used_edge.insert(edge.index);\n                    assert!(!ret.contains_key(&from));\n                    ret.insert(from, edge.clone());\n                    *edge_cnt.get_mut(&edge.dest).unwrap() -= 1;\n                    if edge_cnt[&edge.dest] == 1 {\n                        stack.push(edge.dest);\n                    }\n                    break;\n                }\n            }\n            if dir == 1 {\n                second_start = true;\n            }\n            // println!(\"{:?}\", ret);\n            for &node in connected.iter() {\n                if edge_cnt[&node] == 2 {\n                    stack.push(node);\n                    break;\n                }\n            }\n        }\n        ret\n    }\n    fn calc(&self, from: usize, matching: &HashMap<usize, Edge>) -> (usize, usize) {\n        let mut ret = (1, 0);\n        for edge in self.g[from].iter() {\n            if !self.usable(&matching[&from], edge) {\n                continue;\n            }\n            // println!(\"{:?} {:?}\", matching[&from], edge);\n            let nret = self.calc(edge.dest, matching);\n            ret = merge(ret, nret);\n        }\n        ret.1 += 1;\n        ret\n    }\n    fn solve(&mut self) {\n        let mut ans = (1, 0);\n        let mut visited = vec![false; 2 * self.n];\n        for node in 0..2 * self.n {\n            if visited[node] {\n                continue;\n            }\n            let mut connected = HashSet::<usize>::new();\n            let edge_cnt = self.dfs1(node, &mut connected) / 2;\n            if edge_cnt != connected.len() {\n                ans = (0, 0);\n                break;\n            }\n            for &node in connected.iter() {\n                visited[node] = true;\n            }\n            let mut sum = 0;\n            for dir in 0..2 {\n                // println!(\"calc connect: {} {}\", node, dir);\n                let matching = self.set_direction(&connected, dir);\n                assert!(matching.len() == connected.len());\n                // let mut lans = (1, 0);\n                // // println!(\"{:?}\", matching);\n                // for &node in connected.iter() {\n                //     let dest = matching[&node].dest;\n                //     if !self.usable(&matching[&dest], &Edge::new(0, dest, node)) {\n                //         let mut nret = self.calc(node, &matching);\n                //         // println!(\"{:?}\", nret);\n                //         lans = merge(lans, nret);\n                //     }\n                // }\n                // sum = (sum + lans.0) % MOD as usize;\n            }\n            ans = merge(ans, (sum, connected.len()));\n        }\n        println!(\"{}\", ans.0);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.solve();\n}\n"
  }
]