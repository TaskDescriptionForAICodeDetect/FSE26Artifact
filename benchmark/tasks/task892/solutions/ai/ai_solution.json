[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 200\n\nint dp[MAX_N * 2 + 1][MAX_N + 1][MAX_N + 1];\nint x_balls[MAX_N], y_balls[MAX_N];\n\nint solve(int idx, int x_rem, int y_rem) {\n    if (idx == 2 * x_rem + 2 * y_rem) return 1;\n    if (dp[idx][x_rem][y_rem] != -1) return dp[idx][x_rem][y_rem];\n\n    int result = 0;\n    if (x_rem > 0 && (x_balls[x_rem - 1] == 0 || \n        (y_rem == 0 || x_balls[x_rem - 1] < y_balls[y_rem - 1]))) {\n        x_balls[x_rem - 1] = 0;\n        result = (result + solve(idx + 1, x_rem - 1, y_rem)) % MOD;\n        x_balls[x_rem - 1] = 1;\n    }\n\n    if (y_rem > 0 && (y_balls[y_rem - 1] == 0 || \n        (x_rem == 0 || y_balls[y_rem - 1] < x_balls[x_rem - 1]))) {\n        y_balls[y_rem - 1] = 0;\n        result = (result + solve(idx + 1, x_rem, y_rem - 1)) % MOD;\n        y_balls[y_rem - 1] = 1;\n    }\n\n    return dp[idx][x_rem][y_rem] = result;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i < N; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        x_balls[i] = a;\n        y_balls[i] = b;\n    }\n\n    memset(dp, -1, sizeof(dp));\n    for (int i = 0; i < N; i++) x_balls[i] = 1;\n    for (int i = 0; i < N; i++) y_balls[i] = 1;\n\n    printf(\"%d\\n\", solve(0, N, N));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 200000\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compare_x(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->x != p2->x) return p1->x - p2->x;\n    return p1->y - p2->y;\n}\n\nint compare_y(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->y != p2->y) return p1->y - p2->y;\n    return p1->x - p2->x;\n}\n\nlong long fact[MAX_N * 2 + 1];\nlong long inv_fact[MAX_N * 2 + 1];\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid precompute_factorials(int max_n) {\n    fact[0] = 1;\n    for (int i = 1; i <= max_n; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    inv_fact[max_n] = power(fact[max_n], MOD - 2);\n    for (int i = max_n - 1; i >= 0; i--) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nlong long comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point points[2 * MAX_N];\n    for (int i = 0; i < 2 * N; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    precompute_factorials(2 * N);\n\n    qsort(points, 2 * N, sizeof(Point), compare_x);\n    Point *sorted_x = (Point *)malloc(2 * N * sizeof(Point));\n    memcpy(sorted_x, points, 2 * N * sizeof(Point));\n\n    qsort(points, 2 * N, sizeof(Point), compare_y);\n    Point *sorted_y = (Point *)malloc(2 * N * sizeof(Point));\n    memcpy(sorted_y, points, 2 * N * sizeof(Point));\n\n    int a_ptr = 0, b_ptr = 0;\n    int a_count = 0, b_count = 0;\n    long long res = 1;\n\n    while (a_ptr < 2 * N || b_ptr < 2 * N) {\n        if (a_ptr < 2 * N && (b_ptr >= 2 * N || sorted_x[a_ptr].x <= sorted_y[b_ptr].y)) {\n            if (sorted_x[a_ptr].y < sorted_y[b_ptr].y || b_ptr >= 2 * N) {\n                res = res * (b_count + 1) % MOD;\n                a_count++;\n            } else {\n                res = res * (a_count + b_count + 1) % MOD;\n                a_count++;\n                b_count++;\n            }\n            a_ptr++;\n        } else {\n            res = res * (a_count + 1) % MOD;\n            b_count++;\n            b_ptr++;\n        }\n    }\n\n    printf(\"%lld\\n\", res);\n    free(sorted_x);\n    free(sorted_y);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:15:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\nusing namespace std;\n\nconst int MOD = 1'000'000'007;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> balls;\n    for (int i = 0; i < 2 * N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        balls.emplace_back(x, y);\n    }\n\n    sort(balls.begin(), balls.end());\n\n    vector<int> x_robots(N + 1, 0);\n    vector<int> y_robots(N + 1, 0);\n    for (auto [x, y] : balls) {\n        x_robots[x]++;\n        y_robots[y]++;\n    }\n\n    vector<int> x_list, y_list;\n    for (int x = 1; x <= N; ++x) {\n        if (x_robots[x] > 0) x_list.push_back(x);\n    }\n    for (int y = 1; y <= N; ++y) {\n        if (y_robots[y] > 0) y_list.push_back(y);\n    }\n\n    sort(x_list.begin(), x_list.end());\n    sort(y_list.begin(), y_list.end());\n\n    int i = 0, j = 0;\n    int a = x_list.size(), b = y_list.size();\n    int res = 1;\n    int cnt = 0;\n\n    while (i < a || j < b) {\n        if (i < a && (j >= b || x_list[i] < y_list[j])) {\n            res = (long long)res * (cnt + 1) % MOD;\n            i++;\n        } else {\n            res = (long long)res * (cnt + 1) % MOD;\n            j++;\n        }\n        cnt++;\n    }\n\n    cout << res << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:16:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static int N;\n    static int[] x, y;\n    static boolean[] used;\n    static long[] fact, invFact;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        x = new int[2 * N];\n        y = new int[2 * N];\n        used = new boolean[2 * N];\n        for (int i = 0; i < 2 * N; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            x[i] = Integer.parseInt(st.nextToken());\n            y[i] = Integer.parseInt(st.nextToken());\n        }\n\n        precomputeFactorials(2 * N);\n\n        PriorityQueue<Integer> xRobots = new PriorityQueue<>();\n        PriorityQueue<Integer> yRobots = new PriorityQueue<>();\n        for (int i = 0; i < N; i++) {\n            xRobots.add(i + 1);\n            yRobots.add(i + 1);\n        }\n\n        List<Integer> ballsX = new ArrayList<>();\n        List<Integer> ballsY = new ArrayList<>();\n        for (int i = 0; i < 2 * N; i++) {\n            ballsX.add(x[i]);\n            ballsY.add(y[i]);\n        }\n        Collections.sort(ballsX);\n        Collections.sort(ballsY);\n\n        long result = 1;\n        int a = 0, b = 0;\n        int remaining = 2 * N;\n\n        while (remaining > 0) {\n            int minX = xRobots.isEmpty() ? Integer.MAX_VALUE : xRobots.peek();\n            int minY = yRobots.isEmpty() ? Integer.MAX_VALUE : yRobots.peek();\n            int ballMinX = ballsX.get(a);\n            int ballMinY = ballsY.get(b);\n\n            if (ballMinX < minX && ballMinY < minY) {\n                System.out.println(0);\n                return;\n            }\n\n            if (ballMinX < minX) {\n                result = result * b % MOD;\n                yRobots.poll();\n                b++;\n                remaining--;\n            } else if (ballMinY < minY) {\n                result = result * a % MOD;\n                xRobots.poll();\n                a++;\n                remaining--;\n            } else {\n                result = result * (a + b) % MOD;\n                if (ballMinX < ballMinY) {\n                    xRobots.poll();\n                    a++;\n                } else {\n                    yRobots.poll();\n                    b++;\n                }\n                remaining--;\n            }\n        }\n\n        System.out.println(result);\n    }\n\n    static void precomputeFactorials(int max) {\n        fact = new long[max + 1];\n        invFact = new long[max + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= max; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n        invFact[max] = modInverse(fact[max], MOD);\n        for (int i = max - 1; i >= 0; i--) {\n            invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n        }\n    }\n\n    static long modInverse(long a, int mod) {\n        return power(a, mod - 2, mod);\n    }\n\n    static long power(long a, long b, int mod) {\n        long res = 1;\n        a %= mod;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % mod;\n            }\n            a = a * a % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 23:16:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BallCollection {\n    static final int MOD = 1_000_000_007;\n    \n    public static int collectBalls(int N, int[] xCoords, int[] yCoords) {\n        List<Robot> xRobots = new ArrayList<>();\n        List<Robot> yRobots = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            xRobots.add(new Robot(xCoords[i], true));\n            yRobots.add(new Robot(yCoords[i], false));\n        }\n        \n        Collections.sort(xRobots);\n        Collections.sort(yRobots);\n        \n        return countActivationSequences(xRobots, yRobots, 0, 0, 0);\n    }\n    \n    static int countActivationSequences(List<Robot> xRobots, List<Robot> yRobots, \n                                         int xUsed, int yUsed, int collected) {\n        if (collected == 2 * xRobots.size()) {\n            return 1;\n        }\n        \n        int total = 0;\n        \n        if (xUsed < xRobots.size()) {\n            Robot xRobot = xRobots.get(xUsed);\n            if (!xRobot.used) {\n                xRobot.used = true;\n                total = (total + countActivationSequences(xRobots, yRobots, \n                                                          xUsed + 1, yUsed, collected + 1)) % MOD;\n                xRobot.used = false;\n            }\n        }\n        \n        if (yUsed < yRobots.size()) {\n            Robot yRobot = yRobots.get(yUsed);\n            if (!yRobot.used) {\n                yRobot.used = true;\n                total = (total + countActivationSequences(xRobots, yRobots, \n                                                          xUsed, yUsed + 1, collected + 1)) % MOD;\n                yRobot.used = false;\n            }\n        }\n        \n        return total;\n    }\n    \n    static class Robot implements Comparable<Robot> {\n        int coord;\n        boolean isX;\n        boolean used;\n        \n        Robot(int coord, boolean isX) {\n            this.coord = coord;\n            this.isX = isX;\n            this.used = false;\n        }\n        \n        @Override\n        public int compareTo(Robot other) {\n            return Integer.compare(this.coord, other.coord);\n        }\n    }\n    \n    public static void main(String[] args) {\n        int N = 2;\n        int[] xCoords = {1, 3};\n        int[] yCoords = {2, 4};\n        System.out.println(collectBalls(N, xCoords, yCoords));\n    }\n}",
    "timestamp": "2025-08-05 23:16:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int collectBalls(int N) {\n        vector<pair<int, int>> balls(2*N);\n        for (int i = 0; i < 2*N; i++) {\n            cin >> balls[i].first >> balls[i].second;\n        }\n        \n        vector<bool> xUsed(N+1, false);\n        vector<bool> yUsed(N+1, false);\n        \n        return dfs(N, balls, xUsed, yUsed, 0);\n    }\n    \nprivate:\n    int dfs(int N, vector<pair<int, int>>& balls, \n            vector<bool>& xUsed, vector<bool>& yUsed, int collected) {\n        if (collected == 2*N) return 1;\n        \n        int result = 0;\n        \n        // Try x-axis robot\n        for (int i = 0; i < 2*N; i++) {\n            if (!xUsed[balls[i].first] && !yUsed[balls[i].second]) {\n                int minX = INT_MAX;\n                bool canCollectX = true;\n                \n                for (int j = 0; j < 2*N; j++) {\n                    if (balls[j].first == balls[i].first) {\n                        if (balls[j].second < balls[i].second) {\n                            canCollectX = false;\n                            break;\n                        }\n                        minX = min(minX, balls[j].second);\n                    }\n                }\n                \n                if (canCollectX) {\n                    xUsed[balls[i].first] = true;\n                    yUsed[balls[i].second] = true;\n                    \n                    result = (result + dfs(N, balls, xUsed, yUsed, collected + 1)) % MOD;\n                    \n                    xUsed[balls[i].first] = false;\n                    yUsed[balls[i].second] = false;\n                }\n            }\n        }\n        \n        // Try y-axis robot\n        for (int i = 0; i < 2*N; i++) {\n            if (!yUsed[balls[i].second] && !xUsed[balls[i].first]) {\n                int minY = INT_MAX;\n                bool canCollectY = true;\n                \n                for (int j = 0; j < 2*N; j++) {\n                    if (balls[j].second == balls[i].second) {\n                        if (balls[j].first < balls[i].first) {\n                            canCollectY = false;\n                            break;\n                        }\n                        minY = min(minY, balls[j].first);\n                    }\n                }\n                \n                if (canCollectY) {\n                    xUsed[balls[i].first] = true;\n                    yUsed[balls[i].second] = true;\n                    \n                    result = (result + dfs(N, balls, xUsed, yUsed, collected + 1)) % MOD;\n                    \n                    xUsed[balls[i].first] = false;\n                    yUsed[balls[i].second] = false;\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    \n    Solution solution;\n    cout << solution.collectBalls(N) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 1000000007\n\ndef count_valid_sequences(n, balls):\n    balls.sort()\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    a_idx = 0\n    b_idx = 0\n    for _ in range(2 * n):\n        if a_idx < n and balls[a_idx][1] == 'A':\n            for j in range(n + 1):\n                if j > 0:\n                    dp[a_idx + 1][j] += dp[a_idx][j - 1]\n                    dp[a_idx + 1][j] %= MOD\n        if b_idx < n and balls[b_idx][1] == 'B':\n            for i in range(n + 1):\n                if i > 0:\n                    dp[i][b_idx + 1] += dp[i - 1][b_idx]\n                    dp[i][b_idx + 1] %= MOD\n        if a_idx < n and balls[a_idx][1] == 'A':\n            a_idx += 1\n        elif b_idx < n and balls[b_idx][1] == 'B':\n            b_idx += 1\n\n    return dp[n][n]\n\nn = int(input().strip())\nballs = []\nfor _ in range(2 * n):\n    x, y = map(int, input().strip().split())\n    balls.append((x, 'A'))\n    balls.append((y, 'B'))\n\nprint(count_valid_sequences(n, balls))",
    "timestamp": "2025-08-13 14:19:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class BallCollection {\n\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        int[] xCounts = new int[N + 1];\n        int[] yCounts = new int[N + 1];\n        for (int i = 0; i < 2 * N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            xCounts[x]++;\n            yCounts[y]++;\n        }\n\n        System.out.println(countActivationSequences(N, xCounts, yCounts));\n    }\n\n    private static long countActivationSequences(int N, int[] xCounts, int[] yCounts) {\n        long[] fact = new long[2 * N + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= 2 * N; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n\n        long[] dp = new long[N + 1];\n        Arrays.fill(dp, 0);\n        dp[0] = 1;\n\n        List<Integer> xPositions = new ArrayList<>();\n        List<Integer> yPositions = new ArrayList<>();\n        for (int i = 1; i <= N; i++) {\n            for (int j = 0; j < xCounts[i]; j++) {\n                xPositions.add(i);\n            }\n            for (int j = 0; j < yCounts[i]; j++) {\n                yPositions.add(i);\n            }\n        }\n\n        Collections.sort(xPositions);\n        Collections.sort(yPositions);\n\n        for (int i = N; i >= 0; i--) {\n            int xNeeded = Math.max(0, i - 1);\n            long newWays = dp[i];\n\n            if (xNeeded >= 0 && yPositions.size() >= N - xNeeded) {\n                newWays *= fact[N - xNeeded];\n                newWays %= MOD;\n                newWays *= inverseMod(fact[N - xNeeded - (N - i)]);\n                newWays %= MOD;\n            }\n\n            dp[i] = newWays;\n        }\n\n        long result = dp[N];\n        return result;\n    }\n\n    private static long inverseMod(long x) {\n        return powerMod(x, MOD - 2, MOD);\n    }\n\n    private static long powerMod(long base, long exp, long mod) {\n        long result = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = result * base % mod;\n            }\n            base = base * base % mod;\n            exp >>= 1;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 14:19:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\ntypedef struct {\n    int x, y;\n} Ball;\n\nint cmp_x(const void *a, const void *b) {\n    Ball *ballA = (Ball *)a;\n    Ball *ballB = (Ball *)b;\n    return ballA->x - ballB->x;\n}\n\nint cmp_y(const void *a, const void *b) {\n    Ball *ballA = (Ball *)a;\n    Ball *ballB = (Ball *)b;\n    return ballA->y - ballB->y;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int i;\n\n    Ball *balls = (Ball *)malloc(2 * N * sizeof(Ball));\n    for (i = 0; i < 2 * N; i++) {\n        scanf(\"%d %d\", &balls[i].x, &balls[i].y);\n    }\n\n    qsort(balls, 2 * N, sizeof(Ball), cmp_x);\n\n    int *y_min = (int *)calloc(N + 1, sizeof(int));\n    for (i = 0; i < 2 * N; i++) {\n        if (y_min[balls[i].x] == 0 || y_min[balls[i].x] > balls[i].y) {\n            y_min[balls[i].x] = balls[i].y;\n        }\n    }\n\n    qsort(balls, 2 * N, sizeof(Ball), cmp_y);\n\n    int *x_min = (int *)calloc(N + 1, sizeof(int));\n    for (i = 0; i < 2 * N; i++) {\n        if (x_min[balls[i].y] == 0 || x_min[balls[i].y] > balls[i].x) {\n            x_min[balls[i].y] = balls[i].x;\n        }\n    }\n\n    long long result = 1;\n    int x_count = 0, y_count = 0;\n\n    for (i = 0; i < 2 * N; i++) {\n        if (balls[i].x <= N) {\n            x_count++;\n            if (x_min[balls[i].y] == balls[i].x) {\n                result = (result * x_count) % MOD;\n                x_count--;\n            }\n        }\n        if (balls[i].y <= N) {\n            y_count++;\n            if (y_min[balls[i].x] == balls[i].y) {\n                result = (result * y_count) % MOD;\n                y_count--;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n\n    free(balls);\n    free(y_min);\n    free(x_min);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:19:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function mod(n, m) {\n    return ((n % m) + m) % m;\n}\n\nfunction factorial(n, modulus) {\n    let result = 1;\n    for (let i = 2; i <= n; i++) {\n        result = (result * i) % modulus;\n    }\n    return result;\n}\n\nfunction countSequences(N) {\n    const modulus = 1000000007;\n    const fact2N = factorial(2 * N, modulus);\n    \n    return mod(fact2N, modulus);\n}\n\n// Example usage\nconst N = 5;  // Example input\nconsole.log(countSequences(N));  // Output the number of valid activation orders",
    "timestamp": "2025-08-13 14:19:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Solution:\n    def collectBalls(self, N):\n        MOD = 10**9 + 7\n        \n        # Create sets to track ball coordinates\n        x_balls = set()\n        y_balls = set()\n        \n        # Helper function for recursion with memoization\n        def dfs(x_used, y_used):\n            # Base case: all balls collected\n            if len(x_used) == N and len(y_used) == N:\n                return 1\n            \n            # Memoization key\n            key = (tuple(sorted(x_used)), tuple(sorted(y_used)))\n            if key in memo:\n                return memo[key]\n            \n            total_ways = 0\n            \n            # Try collecting x-axis ball\n            if len(x_used) < N:\n                for x in range(1, N+1):\n                    if x not in x_used and x in x_balls:\n                        x_used.add(x)\n                        total_ways = (total_ways + dfs(x_used, y_used)) % MOD\n                        x_used.remove(x)\n            \n            # Try collecting y-axis ball\n            if len(y_used) < N:\n                for y in range(1, N+1):\n                    if y not in y_used and y in y_balls:\n                        y_used.add(y)\n                        total_ways = (total_ways + dfs(x_used, y_used)) % MOD\n                        y_used.remove(y)\n            \n            # Memoize result\n            memo[key] = total_ways\n            return total_ways\n        \n        # Store ball coordinates\n        memo = {}\n        x_balls = set(range(1, N+1))\n        y_balls = set(range(1, N+1))\n        \n        return dfs(set(), set())",
    "timestamp": "2025-08-13 14:19:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function ballCollection(N, balls) {\n    const MOD = 1000000007;\n    const xRobots = new Array(N).fill(0).map((_, i) => i + 1);\n    const yRobots = new Array(N).fill(0).map((_, i) => i + 1);\n    \n    const dp = new Map();\n    \n    function solve(remainX, remainY, collected) {\n        const key = `${remainX.join(',')}-${remainY.join(',')}-${collected}`;\n        \n        if (dp.has(key)) return dp.get(key);\n        \n        if (remainX.length === 0 && remainY.length === 0) {\n            return 1;\n        }\n        \n        let total = 0;\n        \n        // Try collecting from x-axis robots\n        for (let i = 0; i < remainX.length; i++) {\n            const closestBall = balls.filter(b => \n                b[0] === remainX[i] && \n                !collected.includes(`${b[0]},${b[1]}`)\n            ).sort((a, b) => a[1] - b[1])[0];\n            \n            if (closestBall) {\n                const newRemainX = [...remainX.slice(0, i), ...remainX.slice(i+1)];\n                const newCollected = [...collected, `${closestBall[0]},${closestBall[1]}`];\n                total = (total + solve(newRemainX, remainY, newCollected)) % MOD;\n            }\n        }\n        \n        // Try collecting from y-axis robots\n        for (let i = 0; i < remainY.length; i++) {\n            const closestBall = balls.filter(b => \n                b[1] === remainY[i] && \n                !collected.includes(`${b[0]},${b[1]}`)\n            ).sort((a, b) => a[0] - b[0])[0];\n            \n            if (closestBall) {\n                const newRemainY = [...remainY.slice(0, i), ...remainY.slice(i+1)];\n                const newCollected = [...collected, `${closestBall[0]},${closestBall[1]}`];\n                total = (total + solve(remainX, newRemainY, newCollected)) % MOD;\n            }\n        }\n        \n        dp.set(key, total);\n        return total;\n    }\n    \n    return solve(xRobots, yRobots, []);\n}",
    "timestamp": "2025-08-13 14:20:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N = int(sys.stdin.readline())\n    points = []\n    for _ in range(2 * N):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x, y))\n    \n    # Separate into x-axis and y-axis\n    x_robots = []\n    y_robots = []\n    for x, y in points:\n        if y == 0:\n            x_robots.append(x)\n        else:\n            y_robots.append(y)\n    \n    x_robots.sort()\n    y_robots.sort()\n    \n    # Precompute factorial, inverse factorial\n    max_n = 2 * N\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    # DP table: dp[i][j] = number of ways to choose i x-robots and j y-robots\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    res = 0\n    \n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i == 0 and j == 0:\n                continue\n            total = 0\n            if i > 0:\n                # Check if we can take the i-th x-robot (0-based)\n                # The x-robot is x_robots[i-1], and we need to have at least (i-1) + j balls with x <= x_robots[i-1] and y <= y_robots[j-1] if j >0\n                # The condition is: (i-1) + j <= x_robots[i-1] + (y_robots[j-1] if j>0 else 0)\n                # But actually, the condition is that the number of balls with x <= x_robots[i-1] and y <= (y_robots[j] if j>0 else 0) is >= i + j -1\n                # But it's easier to think in terms of the current x_robot[i-1] and y_robot[j-1]\n                # The condition is: x_robots[i-1] >= i and (if j >0, y_robots[j-1] >= j)\n                # But more accurately, the number of balls with x <= x_robots[i-1] and y <= (y_robots[j] if j>0 else 0) >= i + j\n                # But for the problem, the condition is that when you pick x_robot[i-1], the ball (x_robots[i-1], y) must have y > y_robots[j] (if j >0)\n                # Or something similar. The exact condition is complex.\n                # The correct condition is: x_robots[i-1] >= i and (if j >0, y_robots[j-1] >= j)\n                # But the actual condition is more about the number of balls with x <= x_robots[i-1] and y <= y_robots[j] (if j >0)\n                # To simplify, we can assume that the balls are such that x_robots and y_robots are in order, and the condition is that when you pick x_robot[i-1], the remaining balls must have x >= x_robots[i-1] or y >= y_robots[j] (if j >0)\n                # But this is getting too complicated. The problem's solution is to model it as a path in a grid where you can move right or down, but with certain constraints.\n                # The correct approach is to realize that the condition is that for all steps, the number of x-robots activated so far (i) and y-robots activated so far (j) must satisfy i <= x_robots[i-1] and j <= y_robots[j-1] (if applicable)\n                # But this is still not precise.\n                # The actual condition is that when you have activated i x-robots and j y-robots, the next robot to activate must have x_robots[i] >= i+1 (for x-robot) or y_robots[j] >= j+1 (for y-robot)\n                # So the DP can proceed by checking these conditions.\n                if i > 0 and (x_robots[i-1] >= i + j):\n                    total += dp[i-1][j]\n            if j > 0:\n                if j > 0 and (y_robots[j-1] >= i + j):\n                    total += dp[i][j-1]\n            dp[i][j] = total % MOD\n    \n    res = dp[N][N] * fact[N] % MOD * fact[N] % MOD\n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 14:20:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve() {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const N = parseInt(input[0], 10);\n    const balls = [];\n    const xSet = new Set();\n    const ySet = new Set();\n    \n    for (let i = 1; i <= 2 * N; i++) {\n        const [x, y] = input[i].split(' ').map(Number);\n        balls.push({ x, y });\n        xSet.add(x);\n        ySet.add(y);\n    }\n    \n    const xList = Array.from(xSet).sort((a, b) => a - b);\n    const yList = Array.from(ySet).sort((a, b) => a - b);\n    \n    const xToIdx = new Map();\n    const yToIdx = new Map();\n    xList.forEach((x, idx) => xToIdx.set(x, idx));\n    yList.forEach((y, idx) => yToIdx.set(y, idx));\n    \n    const xCount = new Array(N).fill(0);\n    const yCount = new Array(N).fill(0);\n    \n    balls.forEach(ball => {\n        const xIdx = xToIdx.get(ball.x);\n        const yIdx = yToIdx.get(ball.y);\n        xCount[xIdx]++;\n        yCount[yIdx]++;\n    });\n    \n    const fact = new Array(2 * N + 1).fill(1);\n    const invFact = new Array(2 * N + 1).fill(1);\n    \n    for (let i = 1; i <= 2 * N; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    \n    invFact[2 * N] = modInverse(fact[2 * N], MOD);\n    for (let i = 2 * N - 1; i >= 0; i--) {\n        invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n    }\n    \n    let res = fact[2 * N];\n    for (let i = 0; i < N; i++) {\n        res = res * invFact[xCount[i]] % MOD;\n        res = res * invFact[yCount[i]] % MOD;\n    }\n    \n    console.log(res);\n}\n\nfunction modInverse(a, mod) {\n    let b = mod;\n    let [x, y, u, v] = [0, 1, 1, 0];\n    while (a !== 0) {\n        const q = Math.floor(b / a);\n        [x, y, u, v] = [u, v, x - q * u, y - q * v];\n        [a, b] = [b % a, a];\n    }\n    return (x % mod + mod) % mod;\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:20:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\n// Helper function to solve the problem using dynamic programming approach\nint solve(vector<pair<int, int>>& balls, int N) {\n    sort(balls.begin(), balls.end());\n    \n    vector<int> typeA(N+1, 0), typeB(N+1, 0);\n    for (const auto& [x, y] : balls) {\n        typeA[x]++;\n        typeB[y]++;\n    }\n    \n    vector<vector<int>> dp(N+1, vector<int>(N+1, 0));\n    dp[0][0] = 1;\n    \n    for (int a = 0; a <= N; ++a) {\n        for (int b = 0; b <= N; ++b) {\n            if (a > 0) dp[a][b] = (dp[a][b] + (long long)dp[a-1][b] * typeA[a]) % MOD;\n            if (b > 0) dp[a][b] = (dp[a][b] + (long long)dp[a][b-1] * typeB[b]) % MOD;\n        }\n    }\n    \n    return dp[N][N];\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<pair<int, int>> balls(2 * N);\n    for (int i = 0; i < 2 * N; ++i) {\n        cin >> balls[i].first >> balls[i].second;\n    }\n\n    cout << solve(balls, N) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:43:11"
  }
]