[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[1000];\nbool dp[1000][1000];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 1000)rep(j, 1000) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\tfor (int j = 0; j + i < n; j++) {\n\t\t\t\tint lb = j, ub = j + i;\n\t\t\t\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\t\t\t\tif (i == 1)dp[lb][ub] = 1;\n\t\t\t\t\telse dp[lb][ub] |= dp[lb + 1][ub - 1];\n\t\t\t\t}\n\t\t\t\tFOR(mid, lb + 1, ub - 1) {\n\t\t\t\t\tdp[lb][ub] |= dp[lb][mid] && dp[mid + 1][ub];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, n) {\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tnum = max(num, j - i + 1);\n\t\t\t\t\tpos = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += num;\n\t\t\ti = pos;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<typename T> using V = std::vector<T>;\nusing Vi = V<int>;\nusing VVi = V<V<int>>;\nusing Vl = V<ll>;\nusing VVl = V<V<ll>>;\nusing Vs = V<string>;\n\ntemplate<typename T1, typename T2> using P = std::pair<T1, T2>;\nusing Pii = P<int, int>;\nusing Pll = P<ll, ll>;\nusing Pdd = P<double, double>;\n\ntemplate<typename T1, typename T2> using M = std::map<T1, T2>;\nusing Mii = M<int, int>;\nusing Msi = M<string, int>;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REP2(i,s,e) for(int i=(int)(s);i<(int)(e);++i)\n#define RREP(i,s,e) for(int i=(int)(s);i>=(int)(e);--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(),ie=(c).end();i!=ie;++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double PI = acos(-1);\nconst ll MOD = 1e9+7;\n\nint n;\nstring s;\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n\n        Vi w(n);\n        REP(i, n) cin >> w[i];\n\n        VVi dp(n+1, Vi(n+1, 0));\n        REP2(k, 2, n+1) {\n            REP(i, n-k+1) {\n                if (abs(w[i]-w[i+k-1]) < 2 && dp[i+1][i+k-1] == k-2) {\n                    dp[i][i+k] = k;\n                }\n                REP2(j, i, i+k) {\n                    dp[i][i+k] = max(dp[i][i+k], dp[i][j]+dp[j][i+k]);\n                }\n            }\n        }\n\n        std::cout << dp[0][n] << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nmain(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<n;i+=2)\n      for(int j=0;j<n-i;j++){\n        dp[j][j+i]=dp[j+1][j+i-1];\n        for(int k=1;k<i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=max(dp[j][j+i],i+1);\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nint N;\nvector<int> w;\n\nint solve() {\n    vector<vector<int>> dp(N+1, vector<int>(N+1, -N));\n    for (int i = 0; i <= N; ++i) {\n        dp[i][i] = 0;\n        if (i < N) dp[i][i+1] = 0;\n    }\n    for (int bet = 2; bet <= N; ++bet) {\n        for (int i = 0; i + bet <= N; ++i) {\n            int j = i + bet;\n            if (dp[i+1][j-1] == j-i-2) {\n                if (abs(w[i] - w[j-1]) <= 1) chmax(dp[i][j], j-i);;\n            }\n            for (int k = i+1; k <= j-1; ++k) {\n                chmax(dp[i][j], dp[i][k] + dp[k][j]);\n            }\n        }\n    }\n    return dp[0][N];\n}\n\nint main() {\n    while (cin >> N, N) {\n        w.resize(N);\n        for (int i = 0; i < N; ++i) cin >> w[i];\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    while (1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vi w(n);\n        rep(i, n) cin >> w[i];\n        vector<vi> dp(n, vi(n, 0));\n        for (int wi=2; wi<=n; ++wi) rep(l, n) {\n            int r = l + wi - 1;\n            if (r >= n) continue;\n            if (abs(w[l]-w[r])<=1&&dp[l+1][r-1]==wi-2) dp[l][r] = wi;\n            else {\n                for (int k=l+1; k<=r; ++k) {\n                    dp[l][r] = max(dp[l][r], dp[l][k-1]+dp[k][r]);\n                }\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<int> w(n+1);\n\t\tfor(int i=0; i<n; i++) cin >> w[i];\n\t\t\n\t\tvector<vector<int> > dp(n+1, vector<int>(n+1, 0));\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tfor(int j=0; j+i<=n; j++){\n\t\t\t\tfor(int k=1; k<i; k++){\n\t\t\t\t\tdp[j][i] = max(dp[j][i], dp[j][k] +dp[j+k][i-k]);\n\t\t\t\t}\n\t\t\t\tif(dp[j+1][i-2]==i-2 && abs(w[j]-w[j+i-1])<=1){\n\t\t\t\t\tdp[j][i] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t} \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint w[300];\nint can[310][310];\nint dp[310];\n\nint len(int l, int r) {\n\treturn r - l + 1;\n}\n\nint f(int l, int r) {\n\tif(can[l][r] != -1) return can[l][r];\n\tint L = len(l, r);\n\tif(L == 0) return 1;\n\tif(L == 2) return abs(w[l] - w[r]) <= 1;\n\tif(L % 2) return 0;\n\n\tif(abs(w[l] - w[r]) <= 1 && f(l + 1, r - 1)) {\n\t\tcan[l][r] = 1;\n\t\treturn 1;\n\t}\n\tfor(int i = l + 1; i < r; i++) {\n\t\tif(f(l, i) && f(i + 1, r)) {\n\t\t\tcan[l][r] = 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tcan[l][r] = 0;\n\treturn 0;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tmemset(can, -1, sizeof can);\n\t\tmemset(dp, 0, sizeof dp);\n\t\tfor(int l = 0; l < N; l++) {\n\t\t\tdp[l + 1] = max(dp[l + 1], dp[l]);\n\t\t\tfor(int r = l + 1; r < N; r++) {\n\t\t\t\tif(f(l, r)) {\n\t\t\t\t\tdp[r + 1] = max(dp[r + 1], dp[l] + len(l, r));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[N] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconstexpr int inf = 1e9;\nvector<int> w(300);\nint dp[1000][1000];\n\nint rec(int l,int r){\n    //既に計算済み？\n    if(dp[l][r] != -1) return dp[l][r];\n\n    //これ以上取り除けない？\n    if(abs(l - r) <= 1) return 0;\n\n    int res = 0;\n    //パターン1.\n    if(abs(w[l] - w[r - 1]) <= 1 && rec(l + 1,r - 1) == r - l - 2)\n    {\n        //[l , r)がはじき出せるので\n        res = r - l;\n    }\n\n    //パターン２.区間を分ける\n    for(int mid = l + 1;mid <= r - 1;mid++)\n    {\n        res = max(res , rec(l,mid) + rec(mid,r));\n    }\n    return dp[l][r] = res;\n};\n\nint main(){\n    int num;\n\n    while(cin >> num, num != 0){\n        memset(dp, -1,sizeof(dp));\n        for(int i = 0; i < num; i++){\n            cin >> w[i];\n        }\n        cout << rec(0, num) << endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);++(i))\n\nint main()\n{\n\tint n;\n\twhile(cin >> n , n)\n\t{\n\t\tvector<int> w(n,0);\n\t\tfor(int i = 0;i < n;i++)\n\t\t{\n\t\t\tcin >> w[i];\n\t\t}\n\t\t\n\t\tvector<vector<int>> dp(n + 1,vector<int>(n + 1,0));\n\n\t\tfor(int W = 2;W <= n;W++)\n\t\t{\n\t\t\t//left\n\t\t\tfor(int l = 0;l < n;l++)\n\t\t\t{\n\t\t\t\tint r = l + W - 1;\n\t\t\t\tif(r >= n) continue;\n\n\t\t\t\tif(dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r]) <= 1)\n\t\t\t\t\tdp[l][r] = W;\n\n\t\t\t\tfor(int mid = l;mid <= r;mid++)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r] = max(dp[l][r] , dp[l][mid] + dp[mid + 1][r]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nint dp[333][333];\n\nint rec(int l,int r,vector<int>& a){\n    if(dp[l][r]>=0)return dp[l][r];\n    if(l+1>=r)return dp[l][r]=0;int ans=0;\n    REP(i,l+1,r)ans=max(ans,rec(l,i,a)+rec(i,r,a));\n    if(rec(l+1,r-1,a)==r-l-2&&abs(a[l]-a[r-1])<=1)ans=r-l;\n    return dp[l][r]=ans;\n}\n\nint solve(int n){\n    vector<int> a(n);\n    rep(i,n)cin>>a[i];\n    rep(i,333)rep(j,333)dp[i][j]=-1;\n    return rec(0,n,a);\n}\nint main(){\n    int n;\n    while(cin>>n,n!=0){\n        cout<<solve(n)<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n\nint main() {\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n    int w[n];\n    rep(i, n) cin >> w[i];\n\n    vector<vector<int> > dp(n + 1, vector<int>(n + 1));\n    for (int W = 2; W <= n; ++W) {\n      rep(l, n) {\n        int r = l + W;\n        if (r > n)\n          continue;\n        if (dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r - 1]) <= 1) {\n          dp[l][r] = W;\n        }\n\n        for (int m = l; m <= r; ++m) {\n          dp[l][r] = max(dp[l][r], dp[l][m] + dp[m][r]);\n        }\n      }\n    }\n\n    cout << dp[0][n] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main(){\n    vector<int> ans;\n\n    while(true){\n        int n;\n        cin >> n;\n\n        if(n==0) break;\n\n        int w[n];\n        for(int i=0; i<n; i++){\n            cin >> w[i];\n        }\n\n        int dp[n][n];\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                dp[i][j] = 0;\n            }\n        }\n\n        for(int l=2; l<=n;l++){\n            for(int i=0; i<n; i++){\n                int j = i + l - 1;\n                if(j>=n) continue;\n                if(dp[i+1][j-1] == j-i-1 && abs(w[i]-w[j])<=1){\n                    dp[i][j] = j - i + 1;\n                }else{\n                    for(int k=0; k<n-1; k++){\n                        dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j]);\n                    }\n                }\n            }\n\n        }\n\n        ans.push_back(dp[0][n-1]);\n    }\n\n    for(auto it=ans.begin(); it != ans.end(); it++){\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) v.begin(), v.end()\n\nconst int MOD = (int)1e9 + 7;\n\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\n\nint n,w[301];\nint dp[301][301];\n\nint main(void){\n\n  while(1){\n    cin>>n;\n    if(n==0) break;\n    REP(i,n) cin>>w[i];\n\n    memset(dp, 0, sizeof(dp));\n\n    for(int i=n-1;i>=0;--i){\n      dp[i][i] = 0;\n      dp[i][i+1] = 0;\n      for(int j=i+1;j<=n;++j){\n\tif(i+1<j && abs(w[i]-w[j-1])<=1 && dp[i+1][j-1]==j-i-2){\n\t  dp[i][j] = j-i;\n\t}\n\tfor(int k=j+1;k<=n;k++){\n\t  amax(dp[i][k], dp[i][j] + dp[j][k]);\n\t}\n      }\n    }\n\n    cout<<dp[0][n]<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nint n, a[300], dp[300][300];\n\nint rec(int l, int r){\n    if(l >= r) return 0;\n    if(~dp[l][r]) return dp[l][r];\n    int ret = 0;\n    if(abs(a[l]-a[r]) <= 1 && rec(l+1, r-1) == r-l-1) ret = r-l+1;\n    for(int k = l; k < r; k++){\n        chmax(ret, rec(l, k) + rec(k+1, r));\n    }\n    return dp[l][r] = ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n    while(true){\n        cin >> n;\n        if(n == 0) break;\n        rep(i,n) cin >> a[i];\n        memset(dp, -1, sizeof(dp));\n        cout << rec(0, n-1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0; i<n; i++)\ntypedef long long ll;\ntypedef long long unsigned int llu;\nll MOD = 1000000007;\nll INF = 1000000009;\n\nll w[310];\nll dp[310][310];\nvector<ll> v;\n\nvoid solve(){\n\n    while(true){\n    ll n;\n    cin >> n;\n    if(n==0) break;\n    rep(i,n){\n        cin >> w[i];\n    }\n    rep(i,310){\n        rep(j,310){\n            dp[i][j]=0;\n        }\n    }\n\n    for(ll i=1; i<n; i++){\n        for(ll j=0; j<n-i; j++){\n            ll x=j;\n            ll y=i+j;\n            if(dp[x+1][y-1]==y-x-1&&abs(w[x]-w[y])<=1){\n                dp[x][y]=y-x+1;\n            }\n            else{\n                ll ans = 0;\n                rep(k,y-x){\n                    ans=max(ans, dp[x][x+k]+dp[x+k+1][y]);\n                }\n                dp[x][y]=ans;\n            }\n        }\n    }\n\n    /*\n    rep(i,n){\n        rep(j,n){\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n    v.emplace_back(dp[0][n-1]);\n\n\n    }\n\n    for(auto e:v){\n        cout << e << endl;\n    }\n\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint W[305];\nint dp[305][305];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0){break;}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&W[i]);\n\t\t}\n\t\tfor(int i=0;i<305;i++){\n\t\t\tfor(int j=0;j<305;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=N-2;i++){\n\t\t\tif(abs(W[i]-W[i+1])<=1){dp[i][2]=2;}\n\t\t}\n\t\tfor(int j=3;j<=N-1;j++){\n\t\t\tfor(int i=0;i+j<=N;i++){\n\t\t\t\t//[i,i+j)\n\t\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\t\tdp[i][j]=max(dp[i][k]+dp[i+k][j-k],dp[i][j]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+j-1])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-2]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int j=0;j<12;j++){\n\t\t\tfor(int i=0;i+j<=12;i++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t/*\n\t\tfor(int i=150;i>=0;i-=2){\n\t\tprintf(\"%d\\n\",dp[i][299-i]);\n\t\t}*/\n\t\tif(N%2==0){printf(\"%d\\n\",dp[0][N-1]);}\n\t\telse {printf(\"%d\\n\",max(dp[0][N-2],dp[1][N-2]));}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a) for(int i=0; i<(a); i++)\ntypedef long long ll;\nconst ll inf = 1LL<<60;\n\nint main()\n{\n  vector<ll> ans;\n\n  while(1) {\n    int n; cin >> n;\n    if (!n) break;\n    vector<ll> w(n, 0);\n    rep(i, n) cin >> w[i];\n    vector<vector<ll>> dp(n+1, vector<ll>(n+1, 0));\n    for (int len=2; len<=n; len++) {\n      for (int l=0; l+len<=n; l++) {\n        int r = l+len;\n        if (dp[l+1][r-1] == len-2 && abs(w[l]-w[r-1]) <= 1) {\n          dp[l][r] = len;\n        }\n        for (int m=l; m<=r; m++) {\n          dp[l][r] = max(dp[l][r], dp[l][m] + dp[m][r]);\n        }\n      }\n    }\n    ans.push_back(dp[0][n]);\n  }\n\n  for (auto v:ans) cout << v << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst ll LPLMT=10000000;//O(n)のloop上限\nconst ll NLGLMT=200000;//O(NlogN)のloop上限（これで指定されたfor文の中にO(logN)の処理を書く）\nconst ll N2LMT=3000;//O(n^2)のloop上限\nconst ll N3LMT=100;//O(n^3)のloop上限\nconst ll N4LMT=50;//O(n^4)のloop上限\nconst ll TNLMT=20;//O(2^n)のloop上限（実際この計算量になるのは全探索くらいなので，この値自体を使うことはなさそう）（オーダの参考程度に）\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n/*繰り返し*/\n#define rep1(n) for(ll i=0;i<n;++i)//n回repeat\n#define rep2(i,n) for(ll i=0;i<n;++i)//n回repeat（変数指定）\n#define rep3(i,a,b) for(ll i=a;i<b;++i)//a-bまでrepeat\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)//a-bまで公差cでrepeat（等差数列で使えそう）\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)//repeatまとめ\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)//逆repeatまとめ\n#define each1(i,a) for(auto&& i:a)\n#define each2(x,y,a) for(auto&& [x,y]:a)\n#define each3(x,y,z,a) for(auto&& [x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)//配列の各要素の読み出し\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)//vectorの始めと終わりの読み取り\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)//逆イテレータの取得(rbegin：末尾,rend：頭）\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)//vectorの合計(int形で受け付けてしまうので，小数で扱いたい場合はdsumを使う)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)//小数で扱う(long long doubleなど)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n/*標準入力*/\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)//int型標準入力受付，以下LDまで同様\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n/*vector操作*/\n#define Sort(a) sort(all(a))//昇順ソート\n#define RSort(vec) sort(vec.begin(), vec.end(), greater<ll>())//降順ソート\n#define Rev(a) reverse(all(a))//逆順\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)//type型vectorの定義\n#define VEC(type,name,size) vector<type> name(size);in(name)//type型vector(size指定)標準入力受付\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define IV(type,name,size) vector<pair<int, int>> name;for (int i = 0; i < size; i++) {int a_i;cin >> a_i; name.emplace_back(a_i,i);}//Indexつきvector（pair型Vector,(data,index)）\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }//cout<<t<<endl\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\n/*判定出力*/\nint first(bool i = true){ return out(i?\"first\":\"second\"); }//iがfirstか判断，以下同様\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n/*vector探索*/\n#define bSearch(v,k) binary_search(all(v),k)//ソートされた配列vの中の要素にkがあるか(boolean)\n#define lowB(v,k) lower_bound(all(v),k)//ソートされた配列vの中の要素のうちk以上かつ最小のイテレータ\n#define DLbetB(v,k) lowB(v,k)-v.begin()//先頭からの距離\n#define DLbetE(v,k) v.end()-lowB(v,k)//末尾からの距離\n#define uppB(v,k) upper_bound(all(v),k)//ソートされた配列vの中の要素のうちkより大きいかつ最小のイテレータ\n#define DUbetB(v,k) uppB(v,k)-v.begin()//先頭からの距離\n#define DUbetE(v,k) v.end()-uppB(v,k)//末尾からの距離\n#define Cnt(v,k) count(all(v),k)//配列vの中で要素kが何個あるかを返す(size_t)\n#define CntIf(v,l) count_if(all(v),l)//配列vの中で条件式(lambda式)を満たす個数を返す(ex.int num = count_if(v.begin(), v.end(), [](int i){return i % 3 == 0;});)\n#define Sort2D(myVec,i) sort(myVec.begin(),myVec.end(),[](const vector<ll> &alpha,const vector<ll> &beta){return alpha[i] < beta[i];});//i列めでソート\n/*最大公約数*/\ntemplate <class T>\nT vgcd(T m, T n) {\n  return gcd(m, n);\n}\n\ntemplate <class T, class... Args>\nT vgcd(T a, Args... args) {\n  return vgcd(a, vgcd(args...));\n}\n/*階乗*/\nll facctorialMethod(ll k){\n    ll sum = 1;\n    for (ll i = 1; i <= k; ++i)\n    {\n        sum *= i;\n        //sum%=MOD;//あまりを出力せよ問題の時はこれもやる\n    }\n    return sum;\n}\n/*組み合わせnCk*/\nll comb(const ll N,const ll K){\n  vector<vector<long long int> > v(N+1,vector<long long int>(N+1,0));\n  for(int i = 0;i <v.size(); i++){\n    v[i][0]=1;\n    v[i][i]=1;\n  }\n  for(int k = 1;k <v.size();k++){\n    for(int j = 1;j<k;j++){\n      v[k][j]=(v[k-1][j-1]+v[k-1][j]);\n    }\n  }\n  return v[N][K];\n}\n/*逆元　あまりの割り算をするときにこいつをかける(a/b→a*modinv(b))*/\n// mod. m での a の逆元 a^{-1} を計算する\nll modinv(ll a,ll m){\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n/*ダブリング*/\n/*\n参考：http://satanic0258.hatenablog.com/entry/2017/02/23/222647\n\n使える場所：1回遷移した先が明確にわかる時\n\n目的：\n・ある数XのQ乗を求める\n・根付き木において、ある頂点vのQ個上の親を知る\n・ある地点からQ回進んだ先を求める\n*/\n//int N; // 全体の要素数\n//int Q;//試行回数\nll doubling(const ll N,const ll Q,vector<ll> a){//cin>>N>>Q;//標準入力から要素数と試行回数を受け取る場合\nll LOG_Q = floor(log2(Q))+1;\n\n// next[k][i]で、i番目の要素の「2^k個次の要素」を指す\n// (なお、i番目の要素に対して「2^k個次の要素」が存在しないとき、\n//  next[k][i]が指し示す要素番号を-1とします)\nstd::vector<std::vector<ll>> next(LOG_Q + 1, std::vector<ll>(N));\n//ll a[N];//各要素の次の行き先\n\n// next[0]を計算\nfor (int i = 0; i < N; ++i){\n    next[0][i] = a[i];\n}\n\n// nextを計算\nfor (ll k = 0; k < LOG_Q; ++k){\n    for (int i = 0; i < N; ++i){\n        if (next[k][i] == -1) {\n            // 2^k個次に要素が無い時、当然2^(k+1)個次にも要素はありません\n            next[k + 1][i] = -1;\n        }\n        else {\n            // 「2^k個次の要素」の2^k個次の要素は、2^(k+1)個次の要素です\n            next[k + 1][i] = next[k][next[k][i]];\n        }\n    }\n}\n\n// ----ここまで準備----\n\n// p番目の要素の「Q個次の要素」を求めることを考えます\nll p=0;\nfor (ll k = LOG_Q - 1; k >= 0; --k){\n    if (p == -1) {\n        // pがすでに存在しない要素を指していたら、\n        // それ以降で存在する要素を指すことはないためループを抜けます\n        break;\n    }\n    if ((Q >> k) & 1) {//ex(Q=5)5=101(2)であり，2^2+2^0回進むことを表す\n        // Qを二進展開した際、k番目のビットが立っていたら、\n        // pの位置を2^kだけ次にずらします\n        p = next[k][p];\n    }\n}\nreturn p;//ここでのpが最終的な答えになる\n}\n/*素数判定*/\nbool IsPrime(ll num)\n{\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false; // 偶数はあらかじめ除く\n\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2)\n    {\n        if (num % i == 0)\n        {\n            // 素数ではない\n            return false;\n        }\n    }\n\n    // 素数である\n    return true;\n}\n\n\n/*ページのソースを表示->command+F->問題文　で問題文コピペする\n\n*/\n//ceil()//切り上げ\n//floor()//切り捨て\n//round()//四捨五入\n//deque<ll> deq;//両端キュー使う，先頭と末尾へのアクセスが早い\n//using std::map;\n//map<string,ll>memo;//<キー，その要素＞，キーの検索が早い，キーは昇順にソートされる\nstd::vector<ll> w(310);\nvector<vector<ll>> dp(310,std::vector<ll>(310,-1));\nll rec(ll l,ll r){\n  if(r-l<2)return dp[l][r]=0;\n  if(~dp[l][r])return dp[l][r];\n  ll res=0;\n  if(rec(l+1,r-1)==r-l-2&&abs(w[l]-w[r-1])<=1)return dp[l][r]=r-l;\n  rep(mid,l+1,r)chmax(res,rec(l,mid)+rec(mid,r));\n  return dp[l][r]=res;\n}\n\nsigned main(){\n    /*以下コード*/\n    rep(LPLMT){\n      LL(n);\n      if(!n)break;\n      rep(n){\n        LL(wi);\n        w[i]=wi;\n      }\n      out(rec(0,n));\n      rep(x,310)rep(y,310)dp[x][y]=-1;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\nint main(){\n    while(1){\n        int n;\n        std::cin >> n;\n        if(n == 0) break;\n        std::vector<int> w(n);\n        for(int i = 0; i < n; i++)std::cin >> w[i];\n        int dp[n + 1][n + 1];\n        for(int i = 0; i < n + 1; i++)for(int j = 0; j < n + 1; j++)dp[i][j] = 0;\n        for(int h = 2; h < n + 1; h+= 1){\n            for(int l = 0; l < n; l++){\n                int r = l + h;\n                if(r > n) break;\n                if(dp[l+1][r -1] == h - 2 && std::abs(w[l] - w[r - 1]) <= 1) dp[l][r] = h;\n                for(int mid = l + 1; mid < r; mid++){\n                    dp[l][r] = std::max(dp[l][r], dp[l][mid] + dp[mid][r]);\n                }\n            }\n        }\n        std::cout << dp[0][n] << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LLP;\n\n// const int INF = (1 << 30) - 1;\n// const ll LL_INF = (1LL << 62) - 1;\n// const ll MOD = 1e9 + 7;\n// const double PI = M_PI;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  while (true) {\n    int N;\n    cin >> N;\n    if (N == 0) {\n      break;\n    }\n    vector<int> w(N);\n    rep(i, N) { cin >> w[i]; }\n    int dp[N][N + 1]; // [l, r)\n    rep(i, N) { fill(dp[i], dp[i] + N + 1, 0); }\n\n    for (int W = 2; W <= N; W++) {\n      for (int l = 0; l < N; l++) {\n        int r = l + W;\n        if (r > N) {\n          continue;\n        }\n        if (dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r - 1]) <= 1) {\n          dp[l][r] = dp[l + 1][r - 1] + 2;\n        }\n        for (int k = l + 1; k < r; k++) {\n          dp[l][r] = max(dp[l][r], dp[l][k] + dp[k][r]);\n        }\n      }\n    }\n\n    cout << dp[0][N] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cstring>\n \nusing namespace std;\n \n#define rep(i,n) for(int i = 0; i<n ; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n \n#define RANGE(a,i,b) ((a)<=(i)&&(i)<=(b))\n \n#define pb push_back\n#define mp make_pair\n \n#define ALL(a) (a).begin(), (a).end()\n \n#define SET(a,c) memset(a,c,sizeof(a))\n#define CLR(a) memset(a,0,sizeof(a))\n \n#define INF 1001001001\n#define LLINF 1001001001001001001LL\n \ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n \n#define PQ priority_queue\n \n#define FST first\n#define SEC second\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n \n\n\nint dp[300][300];\n\nint w[300];\n//------------------HEAD---------------------\nint main(){\n    while(1){\n        int n;cin>>n;\n        if(n==0)break;\n        rep(i,n){\n            cin>>w[i];\n        }//cerr<<w[200]<<\" \"<<w[201]<<endl;\n        rep(i,n)rep(j,n){/*cerr<<w[200]<<\" \"<<w[201]<<endl;*/dp[i][j]=0;}\n        //cerr<<dp[0][n-1]<<endl;\n        //cerr<<w[200]<<\" \"<<w[201]<<endl;\n        FOR(i,1,n){\n            rep(j,n-i){\n                FOR(k,j,j+i){\n                    dp[j][j+i]=max(dp[j][j+i],dp[j][k]+dp[k+1][j+i]);\n                }\n                if(dp[j+1][j+i-1]==i-1&&abs(w[j]-w[j+i])<2){\n                    //cerr<<j<<\" \"<<j+i<<\" \"<<dp[j+1][j+i-1]<< \" \"<<w[j]<<\" \"<<w[j+i]<<\" \"<<w[j]-w[j+1]<<endl;\n                    dp[j][j+i]=i+1;\n                }\n            }\n        }\n        /*rep(i,n){\n            rep(j,n){\n                cout<<dp[i][j]<<\" \";\n            }cout<<endl;\n        }*/\n        cout<<dp[0][n-1]<<endl;\n\n    }\n\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1611&lang=jp\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    while(cin >> n, n)\n    {\n        int dp[305][305] = {};\n        vector<int> w(n);\n\n        for(auto& _w : w)\n        {\n            cin >> _w;\n        }\n\n        for(int b = 2; b <= n; b++)\n        for(int l = 0; l < n; l++)\n        {\n            int r = l + b - 1;\n                if( r >= n )break;\n\n                if( abs(w[l] - w[r]) <= 1 && dp[l + 1][r - 1] == r - l - 1)\n                {\n                    dp[l][r] = r - l + 1;\n                }\n                else\n                for(int k = l; k < r; k++)                \n                {\n                    dp[l][r] = max( dp[l][r], dp[l][k] + dp[k + 1][r] );\n                }\n        }\n        cout << dp[0][n - 1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint memo[302][302];\nint w[302];\n\nint rec(int i,int j){\n    if(i>=j) return 0;\n    if(i+1==j){\n        if(abs(w[i]-w[j]) <= 1) return 2;\n        else return 0;\n    }\n    if(memo[i][j]>=0) return memo[i][j];\n    int res=0;\n\n    if(abs(w[i]-w[j])<=1 and rec(i+1,j-1)==j-1-i){\n        return memo[i][j]=j-i+1;\n    }\n\n    for(int k=i;k<j;k++){\n        int L=rec(i,k);\n        int R=rec(k+1,j);\n        res=max(res,L+R);\n    }\n    return memo[i][j]=res;\n}\n\nvoid solve(int N){\n    rep(i,302) rep(j,302) memo[i][j]=-1;\n    rep(i,N) cin >> w[i];\n    cout << rec(0,N-1) << endl;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\nint DFS(vector<int> &w, vector<bool> f, int n, unordered_set<vector<bool>> &s) {\n  int max = 0;\n  for (int i = 0; i < n; i++) {\n    if (f[i]) {\n      for (int j = i + 1; j < n; j++) {\n\tif (f[j]) {\n\t  if (abs(w[i] - w[j]) <= 1) {\n\t    f[i] = f[j] = false;\n\t    if (s.find(f) == s.end()) {\n\t      s.emplace(f);\n\t      int ret = DFS(w, f, n, s) + 2;\n\t      if (ret > max) {\n\t\tmax = ret;\n\t      }\n\t    }\n\t    f[i] = f[j] = true;\n\t  }\n\t  break;\n\t}\n      }\n    }\n  }\n  return max;\n}\n\nint main() {\n  vector<int> w(300);\n\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    vector<bool> f(n);\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n      f[i] = true;\n    }\n\n    unordered_set<vector<bool>> s;\n    cout << DFS(w, f, n, s) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nvector<vector<int>> dp;  \nvector<int> w;\n\nint rec(int l,int r){\n  if(dp[l][r]!=-1)return dp[l][r];\n  if(abs(r-l)<=1)return 0;\n  int res=0;\n  if(abs(w[l]-w[r-1])<=1 && rec(l+1,r-1)==r-l-2)res=r-l;\n\n  for(int mid=l+1;mid<r;mid++){\n    res=max(res,rec(l,mid)+rec(mid,r));\n  }\n\n  return dp[l][r]=res;\n\n}\n\nint main(){\n\n  int n;\n  cin >> n;\n\n  while(n!=0){\n    w.resize(n);\n    for(int i=0;i<n;i++)cin >> w[i];\n\n    dp.resize(n+1);\n    for(int i=0;i<n+1;i++){\n      dp[i].resize(n+1);\n      for(int j=0;j<n+1;j++){\n        dp[i][j]=-1;\n      }\n    }\n\n    cout << rec(0,n) << endl;\n\n    cin >> n;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<int> w;\n\nint memo[301][301];\n\nbool rec(int l, int r) {\n  if (r == l) {\n    return (memo[l][r] = false);\n  }\n  if (r - l == 1) {\n    if (abs(w[l] - w[r]) <= 1) {\n      return (memo[l][r] = true);\n    } else {\n      return (memo[l][r] = false);\n    }\n  }\n\n  if (abs(w[l] - w[r]) <= 1) {\n    if (rec(l + 1, r - 1)) {\n      return (memo[l][r] = true);\n    }\n  }\n\n  if (abs(w[l] - w[l + 1]) <= 1) {\n    if (rec(l + 2, r)) {\n      return (memo[l][r] = true);\n    }\n  }\n\n  if (abs(w[r] - w[r - 1]) <= 1) {\n    if (rec(l, r - 2)) {\n      return (memo[l][r] = true);    \n    }\n  }\n\n  return (memo[l][r] = false);\n}\n\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    memset(memo, 0, sizeof(memo));\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        rec(i, j);        \n      }\n    }\n\n    \n    int ans = 0;\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (memo[i][j] > 0) {\n          ans = max(ans, j - i + 1);\n        }\n        for (int k = i + 1; k <= j; k++) {\n          for (int l = k + 1; l <= j; l++) {\n            if (memo[i][k] > 0 && memo[l][j] > 0) {\n              ans = max(ans, (k - i + 1) + (j - l + 1));\n            }\n          }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, w[300];\nint memo[300][300];\nint dp[303];\nbool check(int i, int j) {\n  if (abs(w[i] - w[j]) <= 1) return true;\n  return false;\n}\nint canRemove(int x, int y) { // 1 : can / 0 : no\n  if (memo[x][y] >= 0) return memo[x][y];\n  if (y == x + 1) {\n    if (check(x, y)) return memo[x][y] = 1;\n    return memo[x][y] = 0;\n  }\n  for (int i = x + 1; i < y; i += 2) {\n    if (canRemove(x, i) && canRemove(i + 1, y)) return memo[x][y] = 1;\n  }\n  for (int i = x + 3; i < y; i += 2) {\n    if (check(x, i) && canRemove(x + 1, i - 1) && canRemove(i + 1, y)) return memo[x][y] = 1;\n  }\n  if (check(x, y) && canRemove(x + 1, y - 1)) return memo[x][y] = 1;\n  return memo[x][y] = 0;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d\", &w[i]);\n    for (int i = 0; i < n ; i++)\n      for (int j = 0; j < n; j++) memo[i][j] = -1;\n    for (int i = 0; i <= n; i++) dp[i] = 0;\n    for (int i = 0; i < n; i++) {\n      if (i > 0) dp[i] = max(dp[i], dp[i - 1]);\n      for (int j = i + 1; j < n; j += 2) {\n        if (canRemove(i, j)) dp[j + 1] = max(dp[j + 1], dp[i] + j - i + 1);\n      }\n    }\n    /*\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j ++) {\n        printf(\"%d \", memo[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    */\n    int ans = 0;\n    for (int i = 0; i <= n; i++) ans = max(ans, dp[i]);\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nmain(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<n;i+=2)\n      for(int j=0;j<n-i;j++){\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=max(dp[j][j+i],i+1);\n        else for(int k=1;k<i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\n\n\nint main(){\n while(1){\n  ll n;\n  cin>>n;\n  if(n==0)break;\n  vector<ll> w(n);\n  for(ll i=0;i<n;i++){\n   cin>>w[i];\n  }\n  vector<vector<bool> > take( n , vector<bool>(n,false) );\n  for(ll i=0;i+1<n;i++){\n   if( abs(w[i]-w[i+1]) <= 1 ) take[i][i+1] = true;\n  }\n  \n  for(ll l=3;l<n;l+=2){\n   for(ll i=0;i+l<n;i++){\n    if( take[i+1][i+l-1] && abs(w[i]-w[i+l])<=1 ){\n     take[i][i+l] = true;\n    }\n     \n     for(ll j=i ; j+1<i+l;j++ ){\n      if( take[i][j] && take[j+1][i+l] ){\n       take[i][i+l] = true;\n       break;\n      }\n     }\n\n\n   }\n  }\n/*\n  for(ll i=0;i<n;i++){\n   for(ll j=i+1;j<n;j++)if(take[i][j])cout<<1<<' ';\n   else cout<<0<<' ';\n   cout<<endl;\n  }\n*/\n  vector<ll> dp(n,0);\n  for(ll i=0;i<n;i++){\n   if( take[0][i] ) dp[i] = i+1;\n  }\n  for(ll i=1;i<n;i++){\n   dp[i] = max(dp[i],dp[i-1]);\n   for(ll j=i;j>=1;j--){\n    if( take[j][i] ) dp[i] = max( dp[i] , dp[j-1] + i-j+1 );\n   }\n  }\n  cout<<dp[n-1]<<endl;\n\n }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\n//サイズが1のときだけ値を持っておくといいね．典型だねうれしいね\nint dp[301][301];\nint v[301][301];\nbool check[301][301];\nint n;\nint w[301];\n\nint DP(int l,int r){\n    if(check[l][r]){\n        return dp[l][r];\n    }\n    check[l][r]=true;\n    if(l==r){\n        v[l][r]=w[l];\n        return dp[l][r]=1;\n    }\n    \n    for(int i=l;i<r;i++){\n        auto x=DP(l,i),y=DP(i+1,r);\n        if(x==0 and y==1){\n            if(chmin(dp[l][r],x+y)) v[l][r]=v[i+1][r];\n        }\n        else if(x==1 and y==0){\n            if(chmin(dp[l][r],x+y)) v[l][r]=v[l][i];\n        }\n        else if(x==1 and y==1){\n            if(abs(v[l][i]-v[i+1][r])<2) dp[l][r]=0;\n            else chmin(dp[l][r],x+y);\n        }\n        else chmin(dp[l][r],x+y);\n    }\n    return dp[l][r];\n}\n\n\nvoid solve(){\n    rep(i,n) cin>>w[i];\n    rep(i,n)rep(j,n)check[i][j]=false,dp[i][j]=INF;\n    cout<<n-DP(0,n-1)<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(cin>>n,n){\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n//#define MAX 300\nint n;\nint* w;\nvector<pair<int*,int>> wmap;\n\nint* pop(int* w,int a) { //w???a????????¨a+1?????????????????????\n\tint *t;\n\tt = new int[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tif(i < a) t[i] = w[i];\n\t\telse t[i] = w[i + 2];\n\t}\n\tt[n - 2] = -1;\n\tt[n - 1] = -1;\n\treturn t;\n}\n\n\nint daruma(int* w) {\n\tfor (int i = 0; i < wmap.size(); i++) {\n\t\tif (memcmp(w, wmap[i].first, sizeof(w)) == 0) {\n\t\t\treturn wmap[i].second;\n\t\t}\n\t}\n\n\tint max = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (w[i] != -1 && w[i + 1] != -1 && abs(w[i]-w[i+1])<=1) {\n\t\t\tint tmp = daruma(pop(w, i))+2;\n\t\t\tif (tmp > max) max = tmp;\n\t\t}\n\t}\n\n\twmap.push_back(make_pair(w,max));\n\treturn max;\n}\n\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\tw = new int[n]();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << daruma(w) << endl;\n\n\n\t\tcin >> n;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nstruct Context {\n\tstd::vector<int>& blocks;\n\tstd::unordered_map<uint64_t, int> cache;\n};\n\nstruct State {\n\tuint64_t data;\n\n\tState() : data(0) {}\n\tState(uint64_t data) : data(data) {}\n\n\tState mark(int index) {\n\t\treturn data | (((uint64_t)1) << index);\n\t}\n\n\tbool is_marked(int index) {\n\t\treturn (data & (((uint64_t)1) << index)) != 0;\n\t}\n};\n\nint search(Context& ctx, State state, int count) {\n\tif (ctx.blocks.size() == 0) return count;\n\tauto& cache_iter = ctx.cache.find(state.data);\n\tif (cache_iter != ctx.cache.end()) return (*cache_iter).second;\n\n\tint max = count;\n\n\tfor (int i = 0; i < ctx.blocks.size() - 1; i++) {\n\t\tif (state.is_marked(i)) continue;\n\n\t\t// ?¬????????????????????????¢???\n\t\tfor (int j = i + 1; j < ctx.blocks.size(); j++) {\n\t\t\tif (state.is_marked(j)) continue;\n\t\t\tif (std::abs(ctx.blocks[i] - ctx.blocks[j]) > 1) break;\n\n\t\t\tint result = search(ctx, state.mark(i).mark(j), count + 2);\n\t\t\tif (result > max) max = result;\n\t\t}\n\t}\n\n\tctx.cache[state.data] = max;\n\treturn max;\n}\n\nint main()\n{\n\tstd::vector<int> blocks;\n\tblocks.reserve(300);\n\n\twhile (true) {\n\t\tint num_blocks;\n\t\tstd::cin >> num_blocks;\n\n\t\tif (num_blocks == 0) return 0;\n\n\t\tblocks.clear();\n\t\tfor (int i = 0; i < num_blocks; i++)\n\t\t{\n\t\t\tint w;\n\t\t\tstd::cin >> w;\n\t\t\tblocks.push_back(w);\n\t\t}\n\n\t\tContext ctx{ blocks, {} };\n\t\tstd::cout << search(ctx, {}, 0) << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, w[300];\nint can[300][300], dp[300];\n\nint rec(int l, int r){\n\tint &res = can[l][r];\n\tif(res >= 0) return res;\n\tif(l == r) return res = 1;\n\tif(l >= r - 1 || (r - l) % 2) return res = 0;\n\t\n\tif(abs(w[l] - w[r - 1]) < 2 && rec(l + 1, r - 1)) return res = 1;\n\tfor(int i = l + 2; i < r; i += 2) if(rec(l, i) && rec(i, r)) return res = 1;\n\treturn res = 0;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\twhile(cin >> n, n){\n\t\tmemset(can, -1, sizeof(can));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\trep(i, n) cin >> w[i];\n\t\trep(i, n){\n\t\t\tdp[i + 1] = max(dp[i + 1], dp[i]);\n\t\t\tfor(int j = i - 1; j >= 0; j -= 2) if(rec(j, i + 1))\n\t\t\t\tdp[i + 1] = max(dp[i + 1], dp[j] + i - j + 1);\n\t\t}\n\t\tcout << dp[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define trace1(a)                    cout<<#a<<\": \"<<a<<endl\n#define trace2(a,b)                  cout<<#a<<\": \"<<a<<\" | \", trace1(b)\n#define trace3(a,b,c)                cout<<#a<<\": \"<<a<<\" | \", trace2(b,c)\n#define trace4(a,b,c,d)              cout<<#a<<\": \"<<a<<\" | \", trace3(b,c,d)\n#define trace5(a,b,c,d,e)            cout<<#a<<\": \"<<a<<\" | \", trace4(b,c,d,e)\n#define trace6(a,b,c,d,e,f)          cout<<#a<<\": \"<<a<<\" | \", trace5(b,c,d,e,f)\n#define trace7(a,b,c,d,e,f,g)        cout<<#a<<\": \"<<a<<\" | \", trace6(b,c,d,e,f,g)\n#define trace8(a,b,c,d,e,f,g,h)      cout<<#a<<\": \"<<a<<\" | \", trace7(b,c,d,e,f,g,h)\n#define trace9(a,b,c,d,e,f,g,h,i)    cout<<#a<<\": \"<<a<<\" | \", trace8(b,c,d,e,f,g,h,i)\n#define trace10(a,b,c,d,e,f,g,h,i,j) cout<<#a<<\": \"<<a<<\" | \", trace9(b,c,d,e,f,g,h,i,j)\n#define rep(i,a,b)      for(int (i)=(int)(a);(i)<(int)(b); ++(i))\n#define reps(i,a,b,c)   for(int (i)=(int)(a);(i)<(int)(b); (i)+=(c))\n#define rrep(i,a,b)     for(int (i)=(int)(a);(i)>=(int)(b);--(i))\n#define rreps(i,a,b,c)  for(int (i)=(int)(a);(i)>=(int)(b);(i)-=(c))\n#define fore(x,a)       for(auto &x:a)\n#define foreach(i,a)    for(auto i=(a).begin(); i!=(a).end(); ++i)\n#define rforeach(i,a)   for(auto i=(a).rbegin();i!=(a).rend();++i)\n#define all(a)  (a).begin(), (a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define isin(i,a,b) ((a) <= (i) && (i) <= (b))\n#define uni(a) (a).erase(unique(all(a)),(a).end())\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(a) ((long long)(a).size())\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\nusing ll  = long long;          using vi  = vector<int>;\nusing ld  = long double;        using vl  = vector<ll>;\nusing unit= unsigned;           using vvi = vector<vi>;\nusing ull = unsigned long long; using vvl = vector<vl>;\nusing pii = pair<int,int>;      using vpii= vector<pii>;\nusing pil = pair<int,ll>;       using vpil= vector<pil>;\nusing pli = pair<ll,int>;       using vpli= vector<pli>;\nusing pll = pair<ll,ll>;        using vpll= vector<pll>;\nvoid _main(); int main(){ cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntemplate<class T>string join(const v(T)&v){ stringstream s; rep(i,0,sz(v))s<<' '<<v[i]; return s.str().substr(1); }\ntemplate<class T>istream &operator>>(istream&i, v(T)&v){ fore(x,v){ i >> v; } return i; }\ntemplate<class T>ostream &operator<<(ostream&o, const v(T)&v){ o<<\"[\"; fore(x,v)o<<x<<\",\"; o<<\"]\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const deque<T>&v){ o<<\"deq[\"; fore(x,v)o<<x<<\",\"; o<<\"]\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const set<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const unordered_set<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const multiset<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const unordered_multiset<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T1,class T2>ostream &operator<<(ostream &o, const pair<T1,T2>&p){ o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\"; return o; }\ntemplate<class TK,class TV>ostream &operator<<(ostream &o, const map<TK,TV>&m){ o<<\"{\"; fore(x,m)o<<x.fi<<\"=>\"<<x.se<<\",\"; o<<\"}\"; return o; }\ntemplate<class TK,class TV>ostream &operator<<(ostream &o, const unordered_map<TK,TV>&m){ o<<\"{\"; fore(x,m)o<<x.fi<<\"=>\"<<x.se<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>void YES(T c){ if(c) cout<<\"YES\"<<endl; else cout<<\"NO\"<<endl; }\ntemplate<class T>void Yes(T c){ if(c) cout<<\"Yes\"<< endl; else cout<<\"No\"<<endl; }\ntemplate<class T>void POSS(T c){ if(c) cout<<\"POSSIBLE\"<<endl; else cout<<\"IMPOSSIBLE\"<<endl; }\ntemplate<class T>void Poss(T c){ if(c) cout<<\"Possible\"<<endl; else cout<<\"Impossible\"<<endl; }\ntemplate<class T>bool chmax(T &a,const T &b){ return a<b?(a=b,true):false; }\ntemplate<class T>bool chmin(T &a,const T &b){ return a>b?(a=b,true):false; }\ntemplate<class T>T gcd(T a,T b){ return b?gcd(b,a%b):a; }\ntemplate<class T>T lcm(T a,T b){ return a/gcd(a,b)*b; }\nconst double  EPS = 1e-10;\nconst double  PI  = acos(-1.0);\nconst int     INF = 1001002003;\nconst ll      LINF= 1001002003004005006LL;\nconst int DX[] = { -1, 0, 1, 0 , -1,-1, 1, 1 };\nconst int DY[] = {  0, 1, 0,-1 , -1, 1,-1, 1 };\n\nint n;\nvi w;\nvvi dp;\n\nint f(int l=0, int r=n) {\n  if (r-l <= 1) return 0;\n  if (r-l == 2) {\n    if (abs(w[l]-w[l+1]) <= 1) return 2;\n    return 0;\n  }\n  int& ret = dp[l][r];\n  if (ret != -INF) return ret;\n  // 全部取り続ける\n  if (abs(w[l]-w[r-1]) <= 1 && f(l+1,r-1) == r-l-2) chmax(ret, r-l);\n  // 他の場合\n  for (int i=l+1; i <= r-1; ++i) chmax(ret, f(l,i) + f(i,r));\n  return ret;\n}\n\nvoid _main() {\n  vi ans;\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    w.resize(n);\n    fore(x,w) cin >> x;\n    dp.assign(n+2, vi(n+2, -INF));\n    ans.pb(f());\n  }\n  fore(x,ans) cout << x << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvi num(n);\n\t\tREP(i, n)\n\t\t\tcin >> num[i];\n\t\tvector<vector<bool>> able(n, vb(n, false));\n\t\tfor (int i = 2;i < n + 1;i += 2) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++) {\n\t\t\t\tif (i == 2) {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1)\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1 && able[j + 1][j + i - 2])\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t\tREP(k, i / 2 - 1)\n\t\t\t\t\t\tif (able[j][j + k * 2 + 1] && able[j + k * 2 + 2][j + i - 1])\n\t\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvi DP(n, vi(n, 0));\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tif (able[i][j])\n\t\t\t\tDP[i][j] = j - i + 1;\n\t\tfor (int i = 3;i < n + 1;i++) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++)\n\t\t\t\tREP(k, i)\n\t\t\t\tDP[j][j + i - 1] = max(DP[j][j + i - 1], DP[j][j + k] + DP[j + k][j + i - 1]);\n\t\t}\n\t\tcout << DP[0][n - 1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int>as;\nbool ok(int a,int b){\n  return abs(as[a]-as[b])<=1;\n}\n\nint main() {\n  while(1){\n    \n    int N;cin>>N;\n    if(!N)break;\n    as.resize(N);\n    vector<vector<int>>dp(N+1,vector<int>(N+1,-100000));\n    for(int i=0;i<N;++i){\n      int a;cin>>a;as[i]=a;\n    }\n    for(int i=0;i<=N;++i){\n      dp[i][i]=0;\n    }\n    for(int t=2;t<=N;++t){\n      for(int l=0;l<=N-t;++l){\n\tconst int r=l+t;\n\tdp[l][r]=max(dp[l+1][r],dp[l][r-1]);\n\tif(ok(l,l+1))dp[l][r]=max(dp[l+2][r]+2,dp[l][r]);\n\tif(ok(r-2,r-1))dp[l][r]=max(dp[l][r-2]+2,dp[l][r]);\n\tif(ok(l,r-1)){\n\t  if(dp[l+1][r-1]==(r-l-2)){\n\t    dp[l][r]=max(dp[l+1][r-1]+2,dp[l][r]);\n\t  }\n\t}\n      } \n    }\n\n    int ans=dp[0][N];\n    ans=max(0,ans);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  unsigned int N = 0;\n  vector<int> num;\n  int w = 0;\n\n  cin >> N;\n  while(N != 0) {\n    for(unsigned int i = 0; i < N; i++) {\n      cin >> w;\n      num.push_back(w);\n    }\n\n    while(true) {\n      unsigned int i;\n      for(i = num.size()-1; i > 0; i--)\n\tif(num.at(i)-num.at(i-1) >= -1 && num.at(i)-num.at(i-1) <= 1)\n\t  break;\n\n      if(i == 0)\n\tbreak;\n      num.erase(num.begin()+i);\n      num.erase(num.begin()+i-1);\n      \n      if(num.empty())\n\tbreak;\n    }\n\n    cout << N-num.size() << endl;\n\n    num.clear();\n\n    cin >> N;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nint main(void) {\n  int N;\n  while (cin >> N, N) {\n    vector<int> W(N);\n    for (int i = 0; i < N; i++) cin >> W[i];\n\n    int dp[300][300] = {};\n    for (int l = 0; l + 1 < N; l++) {\n      if (abs(W[l] - W[l+1]) > 1) continue;\n      dp[l][l+1] = 2;\n    }\n\n    for (int d = 3; d <= N; d++) {\n      for (int l = 0; l + d <= N; l++) {\n        int r = l + d - 1;\n        if (abs(W[l] - W[r]) <= 1 && dp[l+1][r-1] == r - l - 1)\n          dp[l][r] = dp[l+1][r-1] + 2;\n\n        for (int m = l + 1; m <= r - 1; m++) {\n          dp[l][r] = max(dp[l][r], dp[l][m] + dp[m+1][r]);\n        }\n      }\n    }\n\n    cout << dp[0][N-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w[400];\nint memo[400][400];\n\nint max(int i, int j){\n\tint max = 0;\n\tfor(int k = i ; k < j ; k++){\n\t\tint a = memo[i][k] + memo[k+1][j];\n\t\tif(a > max){\n\t\t\tmax = a;\n\t\t}\n\t}\n\tif((j - i) % 2 == 1){\n\t\tif(w[i] - w[j] <= 1 && w[j] - w[i] <= 1 && memo[i+1][j-1] == j - i - 1){\n//\t\t\tcout << \"hit!\\n\";\n\t\t\tmax += 2;\n \t\t}\n\t}\n\treturn max;\n}\n\nint main() {\n\tint n;\n\twhile(true){\n\t\tcin >> n;\n\n\t\tif(n == 0) break;\n\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\tcin >> w[k];\n//\t\t\tcout << \"w[\" << k << \"] = \" << w[k] << \"\\n\";\n\t\t}\n\n\t\tfor(int k = 0 ; k < n - 1; k++){\n\t\t\tmemo[k][k] = 0;\n//\t\t\tcout << \"memo[\" << k << \"][\" << k << \"] = \" << memo[k][k] << \"\\n\";\n\t\t}\n\n\t\tfor(int k = 0 ; k < n - 1; k++){\n\t\t\tmemo[k][k+1] = (w[k] - w[k+1] <= 1 && w[k+1] - w[k] <= 1) ? 2 : 0;\n//\t\t\tcout << \"memo[\" << k << \"][\" << k + 1 << \"] = \" << memo[k][k + 1] << \"\\n\";\n\t\t}\n\n\t\tfor(int b = 2 ; b < n ; b++){ //???\n\t\t\tfor(int k = 0 ; k < n - b ; k++){\n\t\t\t\tmemo[k][k + b] = max(k, k + b);\n//\t\t\t\tcout << \"memo[\" << k << \"][\" << k + b << \"] = \" << memo[k][k + b] << \"\\n\";\n\t\t\t}\n\t\t}\n//\t\tcout << \"memo[\" << 0 << \"][\" << n - 1 << \"] = \" << memo[0][n-1] << \"\\n\";\n\t\tcout << memo[0][n-1] << \"\\n\";\n\t}\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(vector<int> &data, vector<vector<int>> &dp, int l, int r) {\n    int ret = 0;\n    if(dp[l][r] != -1) return dp[l][r];\n    if(abs(r-l) <= 1) return 0;\n\n    if(abs(data[l]-data[r-1]) < 2 && calc(data, dp, l+1, r-1) == r-l-2) ret = r - l;\n\n    for(int mid=l+1; mid<r; mid++) {\n        ret = max(ret, calc(data, dp, l, mid)  + calc(data, dp, mid, r));\n    }\n\n    dp[l][r] = ret;\n    //cout<<\"dp[\"<<l<<\"][\"<<r<<\"] = \"<<dp[l][r]<<endl;\n    return ret;\n\n}\n\nint solve() {\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n\n    vector<vector<int>> dp;\n    dp.resize(n+1);\n    for(auto &item: dp) {\n        item.resize(n+1, -1);\n    }\n    vector<int> data;\n    data.resize(n);\n\n    for(int i=0; i<n; i++) {\n        cin >> data[i];\n    }\n\n\n    cout << calc(data, dp, 0, n) << endl;\n\n    return 1;\n}\n\nint main() {\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); i++)\n#define int long long\n#define DBG 1\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nvoid solve(int N) {\n  VI w(N);\n  rep(i, 0, N) { cin >> w[i]; }\n\n  VVI dp(N + 1, VI(N + 1, 0));\n\n  rep(d, 2, N + 1) {\n    rep(i, 0, N) {\n      int k = i + d;\n      if (k > N)\n        break;\n      rep(p, i, k) { dp[i][k] = max(dp[i][k], dp[i][p] + dp[p][k]); }\n      if (abs(w[i] - w[k - 1]) <= 1 and dp[i + 1][k - 1] == k - i - 2) {\n        dp[i][k] = max(dp[i][k], dp[i + 1][k - 1] + 2);\n      }\n    }\n  }\n  cout << dp[0][N] << endl;\n}\n\nsigned main(void) {\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<int> w(n); rep(i,n) cin >> w[i];\n    vector<vector<int>> dp(n+1,vector<int>(n+1));\n\n    // 区間DP\n    FOR(j,2,n+1){ // 区間長\n      for(int i = 0; i+j <= n; ++i){ // 区間左端 dp[i][i+j]を決定する\n\t//printf(\"[%d,%d)\\n\",i,i+j);\n\tFOR(k,2,j-1) // dp[i][i+k],dp[i+k][i+j]を元に計算\n\t  dp[i][i+j] = max(dp[i][i+j], dp[i][i+k]+dp[i+k][i+j]);\n\t\n\tif(abs(w[i] - w[i+j-1]) <= 1)\n\t  dp[i][i+j] = max(dp[i][i+j], dp[i+1][i+j-1] + 2);\n      }\n    }\n\n    cout << dp[0][n] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\n\nint n;\nvector<int> w;\nvector<vector<int>> dp;\n\nint solve(int l, int r){\n    if((r-l) <= 1) return 0;\n    if((r-l) == 2){\n        if(abs(w[l] - w[l+1]) <= 1) return 2;\n        else return 0;\n    }\n    if(dp[l][r] != -1) return dp[l][r];\n\n    if(abs(w[l] - w[r-1]) <= 1 && solve(l+1, r-1) == r-l-2) dp[l][r] = max(dp[l][r], r-l);\n    for(int i = l+1; i < r; ++i) dp[l][r] = max(dp[l][r], solve(l, i)+solve(i, r));\n\n    return dp[l][r];\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n\n        w.resize(n);\n        rep(i, n) cin >> w[i];\n\n        dp.assign(n+2, vector<int>(n+2, -1));\n\n        cout << solve(0, n) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n        vi a(n);\n        rep(i,n) cin >> a[i];\n        if(n%2){\n            a.push_back(INF);\n            n++;\n        }\n\n        int dp[300][300]={};\n\n        for(int k = 1; k < n; k += 2){\n            rep(i, n-k+1){\n                if(dp[i+1][i+k-1] == k-1){//間が全部消える\n                    dp[i][i+k] = dp[i+1][i+k-1] + (abs(a[i] - a[i+k]) <= 1) * 2;\n                }\n                for(j = i+1; j <= i+k-1; j += 2){\n                    dp[i][i+k] = max(dp[i][i+k], dp[i][j]+dp[j+1][i+k]);\n                }\n            }\n        }\n\n        cout << dp[0][n-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nvector<vector<int>> dp;\nvector<set<int>> edge;\n\nbool match(int p, int q){\n    return edge[p].count(q) > 0;\n}\n\n\nint search(const int l, const int r){\n    if(l >= r) return 0;\n    if(dp[l][r] > -1) return dp[l][r];\n    int cand = search(l+1, r);\n    for (auto &&u : edge[l]) {\n        if(u > r) continue;\n        int sc = search(l+1, u-1);\n        if(sc == u - l - 1){\n            cand = max(cand, sc + 2 + search(u+1, r));\n        }\n    } // end u\n//    for (int i = l+1; i < r-1; ++i) {\n//        cand = max(cand, search(l, i) + search(i+1, r));\n//    } // end i\n\n    return dp[l][r] = cand;\n}\n\n\nint main(){\n    while(cin) {\n        int n;\n        cin >> n;\n        if(n == 0) return 0;\n        vector<int> w(n);\n        for (auto &&i : w) {\n            cin >> i;\n        } // end i\n        edge.clear();\n        dp.clear();\n        edge.resize(n);\n        dp.resize(n, vector<int>(n, -1));\n\n        for (int i = 0; i < n; ++i) {\n            int p = w[i];\n            for (int j =i+1; j < n; j+=2) {\n                int q = w[j];\n                if(abs(p - q) <= 1){\n                    edge[i].insert(j);\n                }\n            } // end j\n        } // end i\n        cout << search(0, n-1) << endl;\n\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n \n#define rep(i, a) for (int i = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int i = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int i = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int i = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n#define TRUE__  \"Yes\"\n#define FALSE__ \"No\"\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define RS resize\n#define CINV(v, N) do {\\\n\tv.RS(N);\\\n\trep(i, N) cin >> v[i];\\\n} while (0);\n#define RCINV(v, N) do {\\\n\tv.RS(N);\\\n\trrep(i, N) cin >> v[i];\\\n} while (0);\n \n#define MOD 1000000007\nbool init();\nint solve();\n\nsigned main()\n{\n    while (init()) {\n    \tcout << solve() << endl;\n\t}\n}\n\nint N;\nvector<int> w;\n\nbool init()\n{\n\tcin >> N;\n\tif (N == 0) return false;\n\tw.RS(N);\n\trep(i, N) cin >> w[i];\n\treturn true;\n}\n\n\nint solve()\n{\n\tvector<vector<int> > dp;\n\tdp.RS(N, vector<int>(N, 0));\n\trep(i, N) rep(j, N) dp[i][j] = abs(j - i) + 1;\n\tfor (int i = 0; i + 1 < N; i++) {\n\t\tif (abs(w[i] - w[i+1]) <= 1) dp[i][i+1] = 0;\n\t}\n\n\tfor (int l = 3; l <= N; l++) {\n\t\tfor (int i = 0; i + l - 1 < N; i++) {\n\t\t\tint j = i + l - 1;\n\t\t\tint r = dp[i][j];\n\t\t\treps(k, i, j) {\n\t\t\t\tr = min(r, dp[i][k] + dp[k+1][j]);\n\t\t\t}\n\t\t\tif (abs(w[i] - w[j]) <= 1 && dp[i+1][j-1] == 0) {\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\tdp[i][j] = r;\n\t\t}\n\t}\n\treturn N - dp[0][N-1];\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nint d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nint dfs(int x,int y){\n  if(dp[x][y] != -1)return dp[x][y];\n  if(y - x <= 0)return dp[x][y] = 0;\n  int res = 0;\n  for(int i = x;i < y;i++){\n    res = max(res,dfs(x,i) + dfs(i + 1,y));\n  }\n  if(abs(d[x] - d[y]) <= 1){\n    if(dfs(x+1,y-1) == y - x - 1){\n      res = max(res,dfs(x+1,y-1)+2);\n    }\n  }\n  return dp[x][y] = res;\n}\n\nint main(){\n  while(1){\n    cin >> n;\n    if(n == 0)break;\n    clr(dp,-1);\n    rep(i,0,n)cin >> d[i];\n    print(dfs(0,n-1));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nint n;\nVI w(301);\nVI2 memo(301, VI(301));\n\nint dp(int l, int r) {\n    if(l == r) return 0;\n    if(r-l == 1) return (std::abs(w[l]-w[r]) <= 1) ? 2 : 0;\n    if(memo[l][r] != -1) return memo[l][r];\n\n    int ans = 0;\n    if(std::abs(w[l]-w[r]) <= 1) {\n        int res = dp(l+1, r-1);\n        if(res == r-l-1) {\n            ans = 2 + res;\n        }\n    }\n    for(int i=l; i<r; ++i) {\n        ans = std::max(ans, dp(l, i) + dp(i+1, r));\n    }\n    return memo[l][r] = ans;\n}\n\nint main() {\n    while(std::cin >> n, n != 0) {\n        REP(i, n) {\n            std::cin >> w[i];\n        }\n        memo.assign(301, VI(301, -1));\n        std::cout << dp(0, n-1) << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,data[301];\n\tbool** table = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tint** maximum = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tmaximum[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 1; k <= N; k++)maximum[i][k] = 0;\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1){\n\t\t\t\ttable[i][1] = true;\n\t\t\t\tmaximum[i][i+1] = 2;\n\t\t\t}\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t\tmaximum[left][left+length-1] = length; //????¨?????????§??????OK????????§?????¶????????§???????¨????\n\t\t\t\t}else{\n\t\t\t\t\t//maximum[left][left+length-1]?????´??°????????°????????????\n\t\t\t\t\tfor(int div = 0; left+div <= left+length-2;div++){ //????´¢?§????????????????\n\t\t\t\t\t\tfor(int i = 2; left+div+i-1 <= left+length-1; i+= 2){ //????´¢?§?????????????????????´?????????????????§????????¢?????????\n\t\t\t\t\t\t\tmaximum[left][left+length-1] = max(maximum[left][left+length-1],maximum[left+div][left+div+i-1]+maximum[min(left+length-1,left+div+i)][left+length-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"maximum[%d][%d]:%d\\n\",left,left+length-1,maximum[left][left+length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(N%2 == 0)printf(\"%d\\n\",maximum[1][N]);\n\t\telse{\n\t\t\tprintf(\"%d\\n\",max(maximum[1][N-1],maximum[2][N]));\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nconst int MAX_N = 1001;\nbool dp[MAX_N][MAX_N];\nint dp2[MAX_N];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N) {\n        vector<int> W(N);\n        rep(i, N) cin >> W[i];\n\n        memset(dp, 0, sizeof(dp));\n        memset(dp2, 0, sizeof(dp2));\n\n        for (int i=0; i<N-1; i++) {\n            if (abs(W[i] - W[i+1]) <= 1) {\n                dp[i][i+1] = true;\n            }\n        }\n\n        for (int len=2; len<=N; len += 2) {\n            for (int l=0; l<=N-len; l++) {\n                int r = l + len - 1;\n\n                for (int k=2; k<=len-2; k+=2) {\n                    if (dp[l][l+k-1] && dp[l+k][r]) dp[l][r] = true;\n                }\n\n\n                if (!dp[l][r]) continue;\n                if (0 <= l-1 && r+1 < N && abs(W[l-1] - W[r+1]) <= 1) {\n                    dp[l-1][r+1] = true;\n                }\n            }\n        }\n\n#ifdef DEBUG\n        rep(i, N) {\n            rep(j, N) {\n                cerr << \"xo\"[dp[i][j]] << \" \";\n            }\n            cerr << endl;\n        }\n#endif\n\n        for (int r=1; r<=N; r++) {\n            dp2[r] = max(dp2[r], dp2[r-1]);\n            for (int l=0; l<r; l++) {\n                if (dp[l][r-1]) {\n                    int len = r - l;\n                    dp2[r] = max(dp2[r], dp2[l] + len);\n                }\n            }\n        }\n\n#ifdef DEBUG\n        rep(i, N+1) cerr << dp2[i] << \" \";\n        cerr << endl;\n#endif\n\n        cout << dp2[N] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18 + 1;\nconst ll dx[] = {1, -1, 0, 0};\nconst ll dy[] = {0, 0, 1, -1};\n\nll n;\nVL w;\n\nll secdp(ll n) {\n    vector<VL> dp(n, VL(n, 0));\n    REP(i, n - 1) if(abs(w[i] - w[i + 1]) <= 1) { dp[i][i + 1] = 2; }\n    FOR(i, 2, n) REP(l, n - i) {\n        ll r = l + i;\n        if(abs(w[l] - w[r]) <= 1 && dp[l + 1][r - 1] == i - 1) {\n            dp[l][r] = i + 1;\n        }\n        FOR(k, l + 1, r + 1) {\n            dp[l][r] = max(dp[l][r], dp[l][k - 1] + dp[k][r]);\n        }\n    }\n    return dp[0][n - 1];\n}\n\nsigned main() {\n    while(cin >> n) {\n        if(n == 0) break;\n        REP(i, n) w.emplace_back(IN());\n        cout << secdp(n) << \"\\n\";\n        w.clear();\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\nint w[N],mem[N][N],used[N][N];\n\nint dfs(int l,int r){\n  if(l==r) return 0;\n  if(r-l==1) return 2*(abs(w[l]-w[r])<=1);\n  if(used[l][r]++) return mem[l][r];\n  \n  int res=0;\n  if(abs(w[l]-w[r])<=1&&dfs(l+1,r-1)==r-l-1)res=2+dfs(l+1,r-1);\n  \n  for(int i=l;i<r;i++) res=max(res,dfs(l,i)+dfs(i+1,r));\n  return mem[l][r]=res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>w[i];\n    memset(used,0,sizeof(used));\n    cout<<dfs(0,n-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\n\nint main(){\n    int n,a[500]={};\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    bool j[500][500]={};\n    for(int i=2;i<=n;i+=2){\n        for(int t=0;t<=n-i;t++){\n            if(abs(a[t]-a[t+i-1])<=1 && (j[t+1][t+i-2] || i==2)){j[t][t+i-1]=true; continue;}\n            for(int h=t+1;h<t+i-1;h++){\n                if(j[t][h] && j[h+1][t+i-1]){j[t][t+i-1]=true; break;}\n            }\n        }\n    }\n    int dp[500];\n    fill(dp,dp+500,INT_MAX/2);\n    dp[0]=0;\n    for(int i=0;i<n;i++){\n        if(i!=0){dp[i]=min(dp[i],dp[i-1]+1);}\n        for(int t=i;t<n;t++){\n            if(j[i][t]){dp[t+1]=min(dp[t+1],dp[i]);}\n        }\n    }\n    \n    /*\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            cout<<(j[i][t]?\"1\":\"0\")<<\" \";\n        }\n        cout<<endl;\n    }\n    */\n\n        cout<<n-dp[n-1]-1<<endl;\n\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n\nint n; \nint w[310];\nint memo[310][310];\n\nint dfs(int l, int r){ \n  \n  if( memo[l][r] != -1 ){ return memo[l][r];}\n \n  int len = r-l+1;\n  if( len <= 2 ){ \n    if( len == 1 ){ return 0;}\n    if( len == 2 ){ \n      if(abs(w[l]-w[r]) <= 1 ){ return 2;}\n      else{ return 0;}\n    }\n  }\n  \n  int val = 0;\n  \n  int judge = r-l-1;\n  if( judge == dfs(l+1,r-1) && abs(w[l]-w[r]) <= 1 ){ val = r-l+1;}\n  //この範囲は全部取り除ける\n  else{\n    //全部は取り除けない→左右に分割可能(必ず融合しないため)\n    for(int k = l; k < r; k++){\n      val = max(val, dfs(l,k)+dfs(k+1,r));\n    }\n    \n  }\n    \n  return memo[l][r] = val;\n}\n\nsigned main(void){ \n while(cin>>n){\n   \n   if( n == 0 ){ return 0;}\n   \n   for(int i = 0; i < n; i++){ cin >> w[i];}\n   \n   for(int i = 0; i < 310; i++){\n     for(int j = 0; j < 310; j++){\n       memo[i][j] = -1;\n     }\n   }\n   \n   cout << dfs(0,n-1) << endl;\n   \n }\n  \n  return 0;\n}\n     \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tvector<int> v(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tvector<vector<int> > dp(n,vector<int>(n,0));\n\t\tint ans=0;\n\t\tint mx=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tfor(int j=0;j<=n-i;j++){\n\t\t\t\tif(i==2){\n\t\t\t\t\tif(v[j]<=v[j+1]+1&&v[j]>=v[j+1]-1){\n\t\t\t\t\t\tdp[j][j+1] = 2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(dp[j+1][j+i-2]==i-2&&v[j]<=v[j+i-1]+1&&v[j]>=v[j+i-1]-1){\n\t\t\t\t\t\tdp[j][j+i-1]=i;\n\t\t\t\t\t}\n\t\t\t\t\tmx = dp[j][j+i-1];\n\t\t\t\t\tfor(int k=1;k<=i-2;k++){\n\t\t\t\t\t\tmx = max(mx,dp[j][j+k]+dp[j+k+1][j+i-1]);\n\t\t\t\t\t\tdp[j][j+i-1] = mx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[0][n-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    int w[n],i,j,k=0;\n    for(i=0;i<n;i++) cin>>w[i];\n    bool p[n][n];\n    memset(p,0,sizeof(p));\n    for(j=0;j+1<n;j++) if(abs(w[j+1]-w[j])<2) p[j][j+1]=1;\n    for(i=3;i<n;i+=2)\n      for(j=0;j+i<n;j++)\n\tif((p[j+1][j+i-1]&&abs(w[j+i]-w[j])<2)||\n\t   (p[j][j+i-2]&&abs(w[j+i]-w[j+i-1])<2)||\n\t   (p[j+2][j+i]&&abs(w[j+1]-w[j])<2)) p[j][j+i]=1;\n    int dp[n+1];\n    memset(dp,0,sizeof(dp));\n    for(i=0;i<n;i++)\n      for(j=0;i+j<=n;j++)\n\tdp[i+j+1]=max(dp[i+j+1],dp[i]+p[i][i+j]*(j+1));\n    cout<<dp[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    while(true){\n        int n;\n        cin >> n;\n\n        if(n == 0){\n            break;\n        }\n\n        vector<int> a(n);\n        rep(i, n) cin >> a[i];\n\n        vector<vector<bool>> able(n, vector<bool>(n, false));\n        rep(i, n-1){\n            if(abs(a[i] - a[i+1]) < 2){\n                able[i][i+1] = true;\n            }\n        }\n        for(int d = 3; d < n; d += 2){\n            rep(i, n){\n                if(i + d >= n){\n                    continue;\n                }\n\n                if(i + 1 < i + d - 1 && able[i+1][i+d-1] && abs(a[i] - a[i+d]) < 2){\n                    able[i][i+d] = true;\n                    continue;\n                }\n\n                for(int k = i+1; k < i + d - 1; k++){\n                    if(able[i][k] && able[k+1][i+d]){\n                        able[i][i+d] = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        vector<vector<int>> dp(n, vector<int>(n));\n        rep(i, n){\n            rep(j, n){\n                if(able[i][j]){\n                    dp[i][j] = j - i + 1;\n                }\n            }\n        }\n\n        rep(i, n){\n            for(int j = i+1; j < n; j++){\n                for(int k = i; k < j; k++){\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n                }\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconstexpr int MAX = 334;\nconstexpr int INF = (1 << 29);\n \nint memo[MAX][MAX];\nvector<int> w;\n \nint rec(int L, int R)\n{\n    int &res = memo[L][R];\n    if (res != -1) return res;\n    if (L >= R) return (res = 0);\n     \n    res = -INF;\n     \n    if (abs(w[L] - w[R]) <= 1) {\n        int r = rec(L + 1, R - 1);\n        if (r == (R - 1) - (L + 1) + 1) {\n            res = max(res, r + 2);\n        }\n    }\n     \n    for (int i = L; i <= R; i++) {\n        res = max(res, rec(L, i) + rec(i+1, R));\n    }   \n    return res;\n}\n \nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        w.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> w[i];\n        }\n         \n        memset(memo, -1, sizeof(memo));\n        cout << rec(0, N - 1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, w[300];\nint can[301][301], dp[301];\n\nint rec(int l, int r){\n\tint &res = can[l][r];\n\tif(res >= 0) return res;\n\tif(l == r) return res = 1;\n\tif(l >= r - 1 || (r - l) % 2) return res = 0;\n\t\n\tif(abs(w[l] - w[r - 1]) < 2 && rec(l + 1, r - 1)) return res = 1;\n\tfor(int i = l + 2; i < r; i += 2) if(rec(l, i) && rec(i, r)) return res = 1;\n\treturn res = 0;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\twhile(cin >> n, n){\n\t\tmemset(can, -1, sizeof(can));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\trep(i, n) cin >> w[i];\n\t\trep(i, n){\n\t\t\tdp[i + 1] = max(dp[i + 1], dp[i]);\n\t\t\tfor(int j = i - 1; j >= 0; j -= 2) if(rec(j, i + 1))\n\t\t\t\tdp[i + 1] = max(dp[i + 1], dp[j] + i - j + 1);\n\t\t}\n\t\tcout << dp[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint w[300];\nint memo[300][300]; //[l,r]\nint solve(int l, int r) {\n\tif (l >= r) return 0;\n\tif (memo[l][r] != -1) return memo[l][r];\n\tint ans = 0;\n\tfor (int i = l; i <= r; i++) {\n\t\tfor (int j = i + 1; j <= r; j++) {\n\t\t\tint sum = 0;\n\t\t\tsum += solve(l, i-1);\n\t\t\tsum += solve(j + 1, r);\n\t\t\tint add = solve(i + 1, j - 1);\n\t\t\tsum += add;\n\t\t\tif (add == (j - i - 1) && abs(w[i]-w[j]) <= 1) {\n\t\t\t\tsum += 2;\n\t\t\t}\n\t\t\tans = max(ans, sum);\n\t\t}\n\t}\n\treturn memo[l][r] = ans;\n}\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\", &w[i]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) memo[i][j] = -1;\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0, n - 1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst int INF=1<<17;\n\nint dp[300][300]; //dp[i][j]:=[i,j)で取り除けるブロックの最大値\nvector<int> W;\n\nint rec(int l,int r){ //[r,l)\n    if(~dp[l][r]) return dp[l][r];\n    if(r-l==0) return dp[l][r]=0;\n    else if(r-l==1) return dp[l][r]=0;\n    else if(r-l==2){\n        if(abs(W[r-1]-W[l])<=1) return dp[l][r]=2;\n        else dp[l][r]=0;\n    }\n    int ret=0;\n    for(int i=l;i<r;i++){\n        for(int j=i+1;j<r;j++){\n            if(rec(i+1,j)==j-i-1&&abs(W[i]-W[j])<=1&&i+1<j) ret=max(ret,rec(i+1,j)+2);\n            else ret=max(ret,rec(i,j)+rec(j,r));\n        }\n    }\n    return dp[l][r]=ret;\n}\n\n\nint main(){\n    int n;\n    while(cin >> n){\n        if(!n) break; \n        W.clear();\n        for(int i=0;i<n;i++){\n            int w;\n            cin >> w;\n            W.push_back(w);\n        }\n        memset(dp,-1,sizeof(dp));\n        cout << rec(0,n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma warning(disable: 4244) // 最悪をします\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <map> \n#include <set>\n#include <string>\n#include <functional>\n#include <list>\n#include <random>\n#include <time.h>\n#include <iomanip>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#define BIT(nr) (1UL << (nr))\n#define int long long\n//#define ll long long\n#define double long double\n#define mod 1000000007\n#define MAXN (int)1e+5 * 2+1\n#define LL_MAX 9223372036854775807\t//ない環境用\n#define LL_HALFMAX 9223372036854775807 / 2\t//ない環境用\n#define MIN -(9223372036854775807 / 2)\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define mp make_pair\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\n\n\nusing namespace std;\n\n//デバッグ用カッコの有無\n#ifdef DEBUG\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\to << \"{\"; for (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \", \" : \"\") << v[i]; o << \"}\"; return o;\n}\n#endif // DEBUG\n\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\tfor (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \" \" : \"\") << v[i]; return o;\n}\n\nint dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位\nint dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位\n\nint dxp[4] = { 0, 1 }; // x軸方向への変位(正のみ)\nint dyp[4] = { 1, 0 }; // y軸方向への変位(負のみ)\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\n\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\tint rev;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph& g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nbool solve() {\n\tint n;\n\tcin >> n;\n\tif (n == 0) {\n\t\treturn false;\n\t}\n\n\tvector<int> w(n);\n\trep(i, n) cin >> w[i];\n\n\tvector<vector<int>> dp(n+1, vector<int>(n+1, -1));\n\n\tfunction<int(int, int)> rec = [&](int l, int r) -> int {\n\t\tif (dp[l][r] != -1) {\n\t\t\treturn dp[l][r];\n\t\t}\n\t\t\n\t\tif (r - l == 2) {\n\t\t\tif (abs(w[r - 1] - w[l]) <= 1) {\n\t\t\t\treturn dp[l][r] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn dp[l][r] = 0;\n\t\t\t}\n\t\t}\n\t\tif (r - l <= 1) {\n\t\t\treturn dp[l][r] = 0;\n\t\t}\n\n\t\tint cand = -1;\n\n\t\tREP(m, l + 1, r - 1) {\n\t\t\tchmax(cand, rec(l, m) + rec(m, r));\n\t\t}\n\n\t\tif (rec(l + 1, r - 1) == r - l - 2) {\n\t\t\tif (abs(w[r - 1] - w[l]) <= 1) {\n\t\t\t\tchmax(cand, r - l);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchmax(cand, r - l - 2);\n\t\t\t}\n\t\t}\n\n\t\treturn dp[l][r] = cand;\n\t};\n\n\tcout << rec(0, n) << \"\\n\";\n\treturn true;\n}\n\nsigned main() {\n\twhile(solve()){}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n;\nll w[301];\nll dp[301][301];\nbool f[301][301];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 301)rep(j, 301) {\n\t\t\tdp[i][j] = 0;\n\t\t\tf[i][j] = 0;\n\t\t}\n\t\trep(i, n)cin >> w[i];\n\t\tfor (int wid = 1; wid < n; wid += 2) {\n\t\t\trep(i, n) {\n\t\t\t\tif (i + wid >= n)continue;\n\t\t\t\tif (wid == 1) {\n\t\t\t\t\tif (abs(w[i] - w[i + wid]) <= 1) {\n\t\t\t\t\t\tdp[i][i + wid] = 2;\n\t\t\t\t\t\tf[i][i + wid] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (abs(w[i] - w[i + wid]) <= 1) {\n\t\t\t\t\t\tif (f[i + 1][i + wid - 1]) {\n\t\t\t\t\t\t\tdp[i][i + wid] = dp[i + 1][i + wid - 1] + 2;\n\t\t\t\t\t\t\tf[i][i + wid] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < i + wid; j += 2) {\n\t\t\t\t\t\tdp[i][i + wid] = max(dp[i][i + wid], (dp[i][j] + dp[j + 1][i + wid]));\n\t\t\t\t\t\tf[i][i + wid] |= (f[i][j] && f[j + 1][i + wid]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\trep(i, n) {\n\t\t\t//ll sum = 0;\n\t\t\tFOR(j, i + 1, n) {\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t\t//if (dp[i][j])sum += max(ans, (ll)(j - i + 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nint n;\nvector<int> w;\nint memo[300][300];\n\n// [l, r]\nint rec(int l, int r) {\n    auto& MEMO = memo[l][r];\n    if (MEMO != INF) return MEMO;\n    if (r <= l) return 0;\n    \n    int ret = 0;\n    if (abs(w[l] - w[r]) <= 1 && rec(l + 1, r - 1) == (r - 1) - (l + 1) + 1) {\n        chmax(ret, r - l + 1);\n    }\n    REPF(i, l, r) {\n        chmax(ret, rec(l, i) + rec(i + 1, r));\n    }\n    return MEMO = ret;\n}\n\nsigned main() {\n    while (1) {\n        cin >> n;\n        if (n == 0) break;\n        REP(i, 300) REP(j, 300) memo[i][j] = INF;\n        w.resize(n);\n        cin >> w;\n        cout << rec(0, n - 1) << endl;\n    }\n    return (0^_^0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\nint xcomp(vector<LL>& a, vector<LL>& b) {\n\treturn a[0] < b[0];\n}\n\n#define XSORT(c) sort((c).begin(),(c).end(),xcomp)\n\n#define ALL(x) (x).begin(),(x).end()\nLL mod = 1000000007;\n\nbool hantei(LL a, LL b) {\n\tif (a + 1 == b) {\n\t\treturn true;\n\t}\n\telse\n\t\tif (a == b) {\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tif (a == b + 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n}\n\nint main() {\n\twhile (true)\n\t{\n\t\tLL  n;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<LL> num(n, 0);\n\t\tvector<LL> v(n, -9999);\n\n\t\tREP(i, n) {\n\t\t\tcin >> v[i];\n\t\t}\n\t\tREP(i, n - 1) {\n\t\t\tif (hantei(v[i], v[i + 1])) {\n\t\t\t\tnum[i] = 2;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\n\t\twhile (flag) {\n\t\t\tflag = false;\n\n\t\t\tREP(i, n) {\n\t\t\t\tLL hoge = num[i];\n\t\t\t\tif (i + num[i]<n) {\n\t\t\t\t\tif (hoge < num[i] + num[i + num[i]]) {\n\t\t\t\t\t\thoge = num[i] + num[i + num[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i + 1<n) {\n\t\t\t\t\tif (i + num[i + 1] + 1<n) {\n\t\t\t\t\t\tif (hantei(v[i], v[i + num[i + 1] + 1])) {\n\t\t\t\t\t\t\tif (hoge < num[i + 1] + 2) {\n\t\t\t\t\t\t\t\thoge = num[i + 1] + 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hoge != num[i]) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tnum[i] = hoge;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tvector<LL> fuga(n * 3, 0);\n\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tfuga[i] = max(fuga[i + 1], num[i] + fuga[i + num[i]]);\n\t\t}\n\n\t\tcout << fuga[0] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint n;\nvi w;\nint dp[333][333];\nvector<vector<bool>> del;\n\nint del_all(int left, int right)\n{\n\tif (dp[left][right] >= 0) return dp[left][right];\n\tint res = 0;\n\tif (left > right) res = 0;\n\telse if (left == right) res = 1;\n\telse\n\t{\n\t\tFOR(i, left + 1, right)\n\t\t{\n\t\t\tif (del_all(left, i) && del_all(i, right)) res = 1;\n\t\t\tif (abs(w[left] - w[right - 1]) <= 1 && del_all(left + 1, right - 1)) res = 1;\n\t\t}\n\t}\n\treturn dp[left][right] = res;\n}\n\nint dp2[333];\n\nint solve(int p)\n{\n\tif (dp2[p] >= 0) return dp2[p];\n\tif (p == n) return 0;\n\tint res = 0;\n\tchmax(res, solve(p + 1));\n\tFOR(i, 1, n + 1)\n\t{\n\t\tif (del[p][i])\n\t\t{\n\t\t\tchmax(res, i - p + solve(i));\n\t\t}\n\t}\n\treturn dp2[p] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n, n)\n\t{\n\t\tMS(dp, -1);\n\t\tMS(dp2, -1);\n\t\tw.resize(n);\n\t\tREP(i, n) cin >> w[i];\n\t\tint ans = 0;\n\t\tdel.clear();\n\t\tdel.resize(n + 1, vector<bool>(n + 1));\n\t\tREP(i, n + 1)REP(j, i)\n\t\t{\n\t\t\tif (del_all(j, i))\n\t\t\t{\n\t\t\t\tdel[j][i] = true;\n\t\t\t}\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while (cin >> n, n) {\n        vector<ll> a(n); cin >> a;\n        vector<vector<ll>> dp(n, vector<ll>(n+1, 0));\n        auto check = [&](const ll idx1, const ll idx2) {\n            return abs(a[idx1] - a[idx2]) <= 1;\n        };\n        rep(i, n-1) {\n            if (check(i, i+1)) dp[i][i+2] = 2;\n        }\n        rep(w, 3, n+1) rep(l, n) {\n            ll r = l + w;\n            if (r > n) break;\n            rep(m, l+1, r) {\n                chmax(dp[l][r], dp[l][m] + dp[m][r]);\n            }\n            if (check(l, r-1) && dp[l+1][r-1] == r-l-2) {\n                chmax(dp[l][r], dp[l+1][r-1]+2);\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <math.h>\nusing namespace std;\n\nint n, w[310];\nint dp[310][310];\n\nint maxx(int i, int j) {\n    if (i > j) return i;\n    else return j;\n}\n\nbool solve(int i, int j) {\n    if (dp[i][j] >= 0) return dp[i][j];\n    else {\n        if (i >= j || (j - i) % 2 == 0 || i >= n || j >= n) {\n            dp[i][j] = 0;\n            return dp[i][j];\n        }\n        if (j - i == 1) {\n            if (abs(w[i] - w[j]) <= 1) dp[i][j] = 1;\n            else dp[i][j] = 0;\n            return dp[i][j];\n        }\n        \n        if (solve(i + 1, j - 1) == 1) {\n            if (abs(w[i] - w[j]) <= 1) dp[i][j] = 1;\n            else dp[i][j] = 0;\n        }\n        \n        for (int k = 2; j - k > 0; k += 2) {\n            for (int l = 2; i + l < j; l += 2) {\n                if (solve(i, j - k) == 1 && solve(i + l, j) == 1 && k + l == j - i + 1) {\n                    dp[i][j] = 1;\n                    return dp[i][j];\n                }\n            }\n        }\n        \n        \n        if (dp[i][j] == -1) dp[i][j] = 0;\n        \n        return dp[i][j];\n    }\n}\n    \nint main(void){\n    while (1) {\n        cin >> n;\n        if (n == 0) return 0;\n        for (int i = 0; i < n; i++) cin >> w[i];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) dp[i][j] = -1;\n        }\n        \n        \n        int min = 0, max = 0, ans = 0;\n        int min2 = 0, max2 = 0, ans2 = 0;\n        int min3 = 0, max3 = 0, ans3 = 0;\n        for (int i = 0; i < n; i++) {\n            bool mmm = true, mmm2 = true, mmm3 = true;\n            if (min > i) mmm = false;\n            if (min2 > i) mmm2 = false;\n            if (min3 > i) mmm3 = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if (!mmm && !mmm2 && mmm3 && solve(i, j) == 1 && solve(i, j + 2) != 1 && min3 <= i) {\n                        max3 = j;\n                        mmm3 = false;\n                    //cout << \"m3 \" << max2 << endl;\n                }\n                if (!mmm && mmm2 && solve(i, j) == 1 && solve(i, j + 2) != 1 && min2 <= i) {\n                        max2 = j;\n                        mmm2 = false;\n                    //cout << \"m2 \" << max2 << endl;\n                }\n                if (mmm && solve(i, j) == 1 && min <= i) {\n                    max = j;\n                    mmm = false;\n                }\n            }\n            /*\n            if (!mmm2 && mmm3) {\n                max3 = max2;\n                mmm3 = false;\n            }\n            */\n            if (max > min) {\n                ans += (max - i) + 1;\n                min = max + 1;\n                max = min;\n            }\n            else {\n                min = maxx(min, i);\n                max = min;\n            }\n            \n            if (max2 > min2) {\n                ans2 += (max2 - i) + 1;\n                min2 = max2 + 1;\n                max2 = min2;\n            }\n            else {\n                min2 = maxx(min2, i);\n                max2 = min2;\n            }\n            \n            if (max3 > min3) {\n                ans3 += (max3 - i) + 1;\n                min3 = max3 + 1;\n                max3 = min3;\n            }\n            else {\n                min3 = maxx(min3, i);\n                max3 = min3;\n            }\n            \n            if (max == max2 && max2 == max3) {\n                ans = maxx(ans, ans2);\n                ans = maxx(ans, ans3);\n                ans2 = ans;\n                ans3 = ans;\n                //cout << \"equal\" << endl;\n            }\n            \n            else if (max2 == max3 + 1) {\n                ans2 = maxx(ans2, ans3);\n                ans3 = ans2;\n                //cout << \"equalf\" << endl;\n            }\n            \n            \n            //cout << \"min \" << min << \" max \" << max \n           //    << \" min2 \" << min2 << \" max2 \" << max2 \n            //    <<  \" min3 \" << min3 << \" max3 \" << max3 << endl; \n            \n        }\n        \n        \n        \n        cout << ans << endl;\n        \n        /*\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cout << solve(i, j) << \" \";\n            }\n            cout << endl;\n        }\n        */\n        \n    }\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, w[1004];\n\twhile(cin >> n, n){\n\n\t\trep(i,n) cin >> w[i];\n\n\t\tbool dp1[305][305]={};\n\t\tvector<pii> v;\n\t\trep(i,n-1) if( abs(w[i] - w[i+1]) < 2 ){\n\t\t\tdp1[i][i+1] = true;\n\t\t\tv.emplace_back(i, i+1);\n\t\t}\n\t\trep(k,n) rep(i,n){\n\t\t\tif( i+k >= n ) break;\n\t\t\tif( dp1[i][i+k] && 0 < i && i+k+1 < n ){\n\t\t\t\tif( abs(w[i-1] - w[i+k+1]) < 2 ){\n\t\t\t\t\tdp1[i-1][i+k+1] = true;\n\t\t\t\t\tv.emplace_back(i-1, i+k+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,k+2){\n\t\t\t\tif( i+k+j >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && dp1[i+k+1][i+k+j] ){\n\t\t\t\t\tdp1[i][i+k+j] = true;\n\t\t\t\t\tv.emplace_back(i, i+k+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(auto t: v) cout << t.X << \",\" << t.Y << \" \"; cout << endl;\n\t\tsort( v.begin(), v.end() );\n\t\tint dp[900005] = {}, pos=0;\n\t\trep(i,n*n){\n\t\t\twhile( pos < v.size() && v[pos].first == i ){\n\t\t\t\tint d  = v[pos].X;\n\t\t\t\tint nx = v[pos].Y + 1;\n\t\t\t\t//cout << d << \",\" << nx << endl;\n\t\t\t\tdp[nx] = max( dp[nx], dp[i] + nx - d );\n\t\t\t\t//cout << \"i=\" << i << \" dp[\" << nx << \"] = \" << dp[nx] << endl;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n\t\t}\n\t\tcout << dp[n*n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define For(i,a,b) for(int i = (int)(a); i < (int)(b); i++)\n#define Rep(i,n) For(i,0,n)\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\n#define MAX_N 300+1\n#define MAX_W 1000+1\n\nint N;\nint w[MAX_N];\nint dp[MAX_N][MAX_N];\n\nint main(int argc, char const *argv[])\n{\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tRep(i,N){\n\t\t\tscanf(\"%d\", &w[i]);\n\t\t}\n\t\tRep(i,MAX_N)Rep(j,MAX_N) dp[i][j] = 0;\n\t\tRep(l,N){\n\t\t\tfor(int s = 0, e = l; e < N; s++,e++){\n\t\t\t\tFor(i,s,e){\n\t\t\t\t\tdp[s][e] = max(dp[s][e], dp[s][i]+dp[i+1][e]);\n\t\t\t\t}\n\t\t\t\tif((e-s-1)%2 == 0 && (e-s-1)/2 == dp[s+1][e-1] && abs(w[e]-w[s]) <= 1) dp[s][e] = max(dp[s][e], dp[s+1][e-1]+1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][N-1]*2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Daruma Otoshi*/\n\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n\nint dp[311][311];\n\nint main() {\n\tint n, w[311];\n\twhile(1) {\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0)break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d\", w + i);\n\t\t}\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor(int i=n-1; i>=0; i--) {\n\t\t\tdp[i][i] = dp[i][i+1] = 0;\n\t\t\tfor(int j=i+1; j<=n; j++) {\n\t\t\t\tif(i + 1 < j && abs(w[i] - w[j-1]) <= 1 && dp[i+1][j-1] == j-i-2)\n\t\t\t\t\tdp[i][j] = j - i;\n\n\t\t\t\tfor(int k=j+1; k<=n; k++)\n\t\t\t\t\tif(dp[i][k]<dp[i][j] + dp[j][k]) dp[i][k]=dp[i][j] + dp[j][k];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][n]);\n\t}//endwhile\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint dp[301][301];\nint n;\nint a[301];\n\nbool dfs(int l, int r) {\n\tif (r - l <= 0) return dp[l][r] = true;\n\tif ((r - l) % 2) return dp[l][r] = false;\n\tif (dp[l][r] != -1) return dp[l][r];\n\t\n\tbool ret = false;\n\tif (abs(a[l] - a[r - 1]) <= 1) { ret |= dfs(l + 1, r - 1); }\n\tfor (int i = l + 1; i < r; i++) {\n\t\tif (ret) { break; }\n\t\tret |= (dfs(l, i) && dfs(i, r));\n\t}\n\treturn (dp[l][r] = ret);\n}\n\nint dp2[301];\n\nint main() {\n\tint i, j;\n\t\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\tfor (i = 0; i < n; i++) cin >> a[i];\n\t\tfor (i = 0; i < n; i++) for (j = 0; j <= n; j++) dp[i][j] = -1;\n\t\tfor (i = 0; i < n; i++) for (j = i; j <= n; j++) dfs(i, j);\n\t\t\n\t\tfor (i = 0; i <= n; i++) dp2[i] = 114514;\n\t\tdp2[0] = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdp2[i + 1] = min(dp2[i + 1], dp2[i] + 1);\n\t\t\tfor (j = i + 1; j <= n; j++) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tdp2[j] = min(dp2[j], dp2[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << n - dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint DP[301][301];\n\nint main()\n{\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (n == 0)break;\n\t\tvector<int>A(n);\n\t\tfor (int i = 0; i < n; i++)cin >> A[i];\n\n\t\trep(i, 301)rep(j, 301)DP[i][j] = 0;\n\n\t\tfor (int i = n-2; i >= 0; i--) {\n\t\t\tfor (int j = i + 1; j <= n - 1; j++) {\n\t\t\t\tfor (int k = j + 1; k <= n; k++) {\n\t\t\t\t\tif (abs(A[i]-A[k-1])<=1 && DP[i + 1][k - 1] == k - i - 2)DP[i][k] = k - i;\n\t\t\t\t\tDP[i][k] = max(DP[i][k], DP[i][j] + DP[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << DP[0][n] << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <set>\n#include <algorithm>\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst long long INF = 1LL<<60;\nconst double PI=3.14159265358979323846;\nconst int NMAX=100005;\nusing namespace std;\n\n\nvector<ll> a(6001);\nll dp[6001][6001];\n\n\nvoid solve(int n){\n    vector<ll> w(n);\n    for(int i = 0; i < n; i++){\n        cin >> w[i];\n    }\n    ll dp[n+1][n+1];\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            dp[i][j] = 0;\n        }\n    }\n\n    for(int len = 1; len <= n; len++){\n        for(int l = 0; l < n; l++){\n            int r = l+len;\n            if(r > n) break;\n            if(r-1 != l && dp[l+1][r-1] == len-2 &&abs(w[r-1]-w[l]) <= 1){\n                dp[l][r] = dp[l+1][r-1]+2;\n            }\n            for(int mid = l; mid <= r; mid++){\n                dp[l][r] = max(dp[l][r],dp[l][mid]+dp[mid][r]);\n            }\n        }\n    }\n\n    cout << dp[0][n] << endl;\n}\n\nint main(){\n    int n;\n    while(true){\n        cin >> n;\n        if(n == 0) break;\n        solve(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint n;\nint w[302];\nbool can[302][302];\nint main() {\n    //cout.precision(10);\n    while(true) {\n        cin >> n;\n        if(n == 0) break;\n        for(int i = 1; i <= n; i++) {\n            cin >> w[i];\n        }\n        for(int i = 0; i <= n + 1; i++) {\n            for(int j = 0; j <= n + 1; j++) {\n                can[i][j] = false;\n            }\n            can[i][i] = true;\n        }\n        for(int delta = 2; delta <= n; delta++) {\n            for(int from = 1; from + delta <= n + 1; from++) {\n                int to = from + delta;\n                for(int mid = from; mid <= to; mid++) {\n                    if(can[from][mid] && can[mid][to]) can[from][to] = true;\n                }\n                if(can[from + 1][to - 1]) {\n                    if(abs(w[from] - w[to - 1]) <= 1) can[from][to] = true;\n                }\n                //if(can[from][to]) cout << from << \" \" << to << endl;\n            }\n        }\n        int dp[305];\n        for(int i = 0; i <= 304; i++) {\n            dp[i] = 0;\n        }\n        for(int now = 1; now <= n; now++) {\n            dp[now] = dp[now - 1];\n            for(int from = 1; from <= now; from++) {\n                if(can[from][now + 1]) {\n                    dp[now] = max(dp[now], dp[from - 1] + (now + 1 - from));\n                }\n            }\n            //cout << now << \" \" << dp[now] << endl;\n        }\n        cout << max(dp[n], dp[n - 1]) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n\nint n;\n\n//[l,r)\n\t\tfunction<int(int,int)> rec = [&](int l,int r){\n\t\t\tif(dp[l][r] != -1) return dp[l][r];\n\n\t\t\tif(abs(l - r) <= 1) return 0;\n\n\t\t\tint res = 0;\n\t\t\t//l [able] r ?\n\t\t\tif(abs(w[l] - w[r - 1]) <= 1 && rec(l + 1,r - 1) == r - l - 2)\n\t\t\t{\n\t\t\t\tres = r - l;\n\t\t\t}\n\n\t\t\t//[l any] [any r]\n\t\t\tfor(int mid = l + 1;mid <= r - 1;mid++)\n\t\t\t{\n\t\t\t\tres = max(res , rec(l,mid) + rec(mid,r));\n\t\t\t}\n\t\t\treturn dp[l][r] = res;\n\t\t};\n\nint main()\n{\n\twhile(cin >> n , n)\n\t{\n\t\tvector<int> w(n,0);\n\t\tfor(int i = 0;i < n;i++) cin >> w[i];\n\n\t\tvector<vector<int>> dp(n + 1,vector<int>(n + 1,-1));\n\n\t\t\n\n\t\tcout << rec(0,n) << endl;\n\t}\n}\n\t\t\t\t\n\n\n\t\t\t\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        vector<int> v(N);\n        for (auto& i : v) cin >> i;\n\n        vector<vector<int>> dp(N+1, vector<int>(N));\n        for (int i = 0; i < N; i++) {\n            if (abs(v[i] - v[i+1]) < 2) {\n                dp[2][i] = 1;\n            }\n        }\n        for (int i = 4; i <= N; i += 2) {\n            for (int j = 0; j + i <= N; j++) {\n                if (dp[i-2][j+1] && abs(v[j] - v[j + i - 1]) < 2) {\n                    dp[i][j] = 1;\n                } else {\n                    for (int k = 2; j + k < j + i; k += 2) {\n                        if (dp[k][j] && dp[i - k][j + k]) {\n                            dp[i][j] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        vector<int> sum(N+1);\n        for (int i = 0; i < N; i++) {\n            if (i) sum[i] = max(sum[i], sum[i-1]);\n            for (int j = 2; j <= N; j += 2) {\n                if (dp[j][i]) {\n                    sum[i+j] = max(sum[i+j], sum[i] + j);\n                }\n            }\n        }\n\n        cout << max(sum[N-1], sum[N]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, S, E) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 2099999999LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\n\nvoid solve()\n{\n\twhile (true){\n\t\tll n;  cin >> n;\n\t\tif (n==0) break;\n\n\t\tvector<ll> w = cinv<ll>(n);\n\n\t\tvvll dp(n, vll(n,0));\n\t\tauto Dp = [&](ll i, ll j)->ll&{\n\t\t\treturn dp[i][j];\n\t\t};\n\n\t\trep(i, 0, n-2){\n\t\t\tif (abs(w[i]-w[i+1])<=1) Dp(i, i+1) = 2;\n\t\t}\n\n\t\trep(len, 3, n){\n\t\t\trep(l, 0, n-1){\n\t\t\t\tll r = l+len-1;\n\t\t\t\tif (r>=n) break;\n\n\t\t\t\trep(m, l, r-1){\n\t\t\t\t\tchmax(Dp(l, r), Dp(l, m)+Dp(m+1, r));\n\t\t\t\t}\n\t\t\t\tif (Dp(l+1, r-1) == len-2 && abs(w[l]-w[r])<=1){\n\t\t\t\t\tDp(l, r) = len;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << Dp(0,n-1) << '\\n';\n\t}\n\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<int> w;\n\nint memo[301][301];\n\nint rec(int l, int r) {\n  if (r == l) {\n    return (memo[l][r] = 1);\n  }\n  if (memo[l][r] != 0) {\n    return memo[l][r];\n  }\n  if (r - l == 1) {\n    if (abs(w[l] - w[r]) <= 1) {\n      return (memo[l][r] = 2);\n    } else {\n      return (memo[l][r] = 1);\n    }\n  }\n\n  if (abs(w[l] - w[r]) <= 1) {\n    if (rec(l + 1, r - 1) == 2) {\n      return (memo[l][r] = 2);\n    }\n  }\n\n  if (abs(w[l] - w[l + 1]) <= 1) {\n    if (rec(l + 2, r) == 2) {\n      return (memo[l][r] = 2);\n    }\n  }\n\n  if (abs(w[r] - w[r - 1]) <= 1) {\n    if (rec(l, r - 2) == 2) {\n      return (memo[l][r] = 2);    \n    }\n  }\n\n  return (memo[l][r] = 1);\n}\n\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    memset(memo, 0, sizeof(memo));\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if ((j - i) % 2 == 0) {\n          continue;\n        }\n        rec(i, j);        \n      }\n    }\n\n    \n    int ans = 0;\n\n    int dp[301] = {0};\n\n    for (int i = 2; i < n; i++) {\n      dp[i] = dp[i - 1];\n      for (int j = 0; j < i; j++) {\n        if (memo[j][i] == 2) {\n          dp[i] = max(dp[i], dp[j - 1] + (i - j + 1));\n        }\n      }\n    }\n\n    ans = dp[n - 1];\n\n    /*\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (memo[i][j] == 2) {\n          ans = max(ans, j - i + 1);\n        }\n        for (int k = i + 1; k <= j; k++) {\n          for (int l = k + 1; l < j; l++) {\n            if (memo[i][k] == 2 && memo[l][j] == 2) {\n              ans = max(ans, (k - i + 1) + (j - l + 1));\n            }\n          }\n        }\n      }\n      }*/\n\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[310][310]; //dp[i][j] は区間[i, j)で叩き出せる数\nvector<int> w;\n\nint rec(int l, int m){ //区間DP\n    if(dp[l][m] != -1) return dp[l][m];\n    \n    if(abs(l - m) <= 1) return 0;\n    \n    int res = 0;\n    \n    if(abs(w[l] - w[m - 1]) <= 1 && rec(l + 1,m - 1) == m - l - 2) res = m - l;\n    \n    for(int mid = l + 1; mid < m; mid++){\n        res = max(res, rec(l, mid) + rec(mid, m));\n    }\n    return dp[l][m] = res;\n}\n\nint main(){\n    while(true){\n        int k; cin >> k;\n        if(k == 0) break;\n        w.resize(k);\n        for(int i = 0; i < k; i++){\n            cin >> w[i];\n        }\n        memset(dp, -1, sizeof(dp));\n        cout << rec(0, k) << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\ntypedef pair<int, int> pii;\n\nconstexpr int MAX_N = 305;\nconstexpr int INF = 1LL << 60;\n\nint n, mem[MAX_N][MAX_N], w[MAX_N];\n\nint solve(int l, int r) {\n    if (r - l <= 1) {\n        return 0;\n    }\n    if (mem[l][r] != -1) {\n        return mem[l][r];\n    }\n\n    int res = 0;\n    for (int i = l + 1; i < r; ++i) {\n        res = max(res, solve(l, i) + solve(i, r));\n    }\n    for (int i = r - 1; l + 1 <= i; --i) {\n        res = max(res, solve(l, i) + solve(i, r));\n    }\n\n    if (abs(w[l] - w[l + 1]) <= 1) {\n        res = max(res, solve(l + 2, r) + 2);\n    }\n    if (abs(w[r - 1] - w[r - 2]) <= 1) {\n        res = max(res, solve(l, r - 2) + 2);\n    }\n    if (abs(w[l] - w[r - 1]) <= 1) {\n        int tmp = solve(l + 1, r - 1);\n        if (tmp == r - l - 2) {\n            res = max(res, tmp + 2);\n        }\n    }\n\n    return mem[l][r] = res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while(1) {\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n        memset(mem[0], -1, sizeof(mem));\n\n        for (int i = 0; i < n; ++i) {\n            cin >> w[i];\n        }\n\n        cout << solve(0, n) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi a(n);\n\t\trep(i,n)cin>>a[i];\n\t\tvvi dp(n+1,vi(n+1,0));\n\t\trep(i,n-1) if(abs(a[i]-a[i+1])<=1) dp[2][i]=1;\n\t\tfor(int l=4;l<=n;l+=2)rep(i,n-l+1){\n\t\t    dp[l][i]|=(dp[l-2][i+1] and abs(a[i]-a[i+l-1])<=1);\n\t\t    for(int k=2;k<l;k+=2){\n\t\t        dp[l][i]|=(dp[k][i] and dp[l-k][i+k]);\n\t\t    }\n\t\t}\n\t\tvi ans(n+1,INF);\n\t\tdeque<pii> d({{0,0}});\n\t\twhile(ans[n]==INF){\n\t\t    int p,c;\n\t\t    tie(p,c)=d.front();\n\t\t    d.pop_front();\n\t\t    if(ans[p]!=INF) continue;\n\t\t    //cout<<\"頂点\"<<p<<\", コスト\"<<c<<endl;\n\t\t    ans[p]=c;\n\t\t    d.emplace_back(p+1,c+1);\n\t\t    for(int l=2;l<=n;l+=2){\n\t\t        if(dp[l][p] and ans[p+l]==INF) d.emplace_front(p+l,c);\n\t\t    }\n\t\t}\n\t\tcout<<n-ans[n]<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n#define EQ(a,b) (abs(a - b) < 1e-10)\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<LL> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<bool> VB;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\nint n;\nvector<int> w;\ntypedef bitset<300> bit;\nstruct Comp {\n\tbool operator() (const bit &a,const bit &b) {\n\t\treturn a.to_ullong() < b.to_ullong();\n\t}\n};\nmap<bit,int,Comp> memo;\nint dfs(bit state) {\n\tif (IN(state,memo)) return memo[state];\n\tint num = 0,fi;\n\tREP(i,n-1) {\n\t\tif ((!state[i])) {\n\t\t\tfi = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFOR(i,fi+1,n) {\n\t\tif (!state[i]){\n\t\t\tif (abs(w[i] - w[fi]) <= 1) {\n\t\t\t\tbit next = (state | bit(1<<i) | bit(1<<(fi)));\n\t\t\t\tnum = max(dfs(next)+2,num);\n\t\t\t}\n\t\t\tfi = i;\n\t\t}\n\t}\n\treturn memo[state] = num;\n}\n\nint main(void) {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tw.resize(n);\n\t\tREP(i,n) cin >> w[i];\n\t\tcout << dfs(bit(0)) << endl;\n\t\tmemo.clear();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)  return 0;\n        vector<int> w(n);\n        for(int i = 0; i < n; ++i)  cin >> w[i];\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\n        auto MemoRec = [&](auto&& self, int l, int r) -> int {\n            if(dp[l][r] != -1)  return dp[l][r];\n            if(r - l <= 1)  return dp[l][r] = 0;\n            if(r - l == 2){\n                if(abs(w[l] - w[r - 1]) <= 1)   return dp[l][r] = 2;\n                else    return dp[l][r] = 0;\n            }\n            if(abs(w[l] - w[r - 1]) <= 1 && self(self, l + 1, r - 1) == r - l - 2){\n                return dp[l][r] = r - l;\n            }\n            int res = 0;\n            for(int m = l + 1; m < r; ++m){\n                chmax(res, self(self, l, m) + self(self, m, r));\n            }\n            return dp[l][r] = res;\n        };\n        cout << MemoRec(MemoRec, 0, n) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tloc = div = 0;\n\t}\n\tint loc,div;\n};\n\nint N,maximum;\n\nvoid recursive(int table[],int num,int SIZE){\n\n\tmaximum = max(maximum,2*num);\n\n\tint max_chain = 0,tmp_chain,next_index = 0;\n\tInfo nextTable[SIZE];\n\n\tfor(int i = 1; i <= SIZE-1; i++){\n\t\tif(abs(table[i] - table[i-1]) <= 1){\n\t\t\tif(i == SIZE-1){\n\t\t\t\tif(max_chain == 0){\n\t\t\t\t\tnextTable[next_index].loc = SIZE-1;\n\t\t\t\t\tnextTable[next_index++].div = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttmp_chain = 0;\n\t\t\t\tfor(int k = 1;(i-1)-k>=0 && i+k <= SIZE-1;k++){\n\t\t\t\t\tif(abs(table[(i-1)-k] - table[i+k]) <= 1){\n\t\t\t\t\t\ttmp_chain++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp_chain > max_chain){\n\t\t\t\t\tmax_chain = tmp_chain;\n\t\t\t\t\tnext_index = 0;\n\t\t\t\t\tnextTable[next_index].loc = i;\n\t\t\t\t\tnextTable[next_index++].div = tmp_chain;\n\t\t\t\t}else if(tmp_chain == max_chain){\n\t\t\t\t\tnextTable[next_index].loc = i;\n\t\t\t\t\tnextTable[next_index++].div = tmp_chain;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(next_index == 0)return;\n\n\tfor(int i = 0; i < next_index;i++){ //?????????????????¨???????????¨???????????????????????????\n\t\tint work[SIZE],new_table[SIZE],next_size = 0;\n\t\tfor(int k = 0; k < SIZE; k++)work[k] = table[k];\n\t\twork[nextTable[i].loc-1] = -1;\n\t\twork[nextTable[i].loc] = -1;\n\n\t\tfor(int k = 1; k <= nextTable[i].div; k++){\n\t\t\twork[nextTable[i].loc-1-k] = -1;\n\t\t\twork[nextTable[i].loc + k] = -1;\n\t\t}\n\n\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\tif(work[k] != -1){\n\t\t\t\tnew_table[next_size++] = work[k];\n\t\t\t}\n\t\t}\n\t\trecursive(new_table,num+nextTable[i].div+1,next_size);\n\t\tbreak; //??????1??????????????????\n\t}\n}\n\nvoid func(){\n\n\tint first[N];\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&first[i]);\n\n\tif(N == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}else if(N == 2){\n\t\tif(abs(first[0] - first[1] <= 1)){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\trecursive(first,0,N);\n\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\t\tmaximum = 0;\n\n\t\tfunc();\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF0 static_cast<int>(10e6)\n#define INF1 static_cast<int>(10e7)\n\nusing namespace std;\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\nusing vvi = vector<vector<int>>;\nusing vi = vector<int>;\n\nint n;\nint w_[304];\nint *w = &w_[2];\nvpii ss;\n// vi ss_[304];\n// int *ss = &ss[2]; // 閉区間\n\nbool ok(int a, int b) {\n    return abs(w[a] - w[b]) <= 1;\n}\n\nint dp(int, int);\n\nint main() {\n    while (cin >> n, n) {\n        ss.clear();\n        w[-2] = INF0;\n        w[-1] = INF1;\n        for (int i = 0; i < n; i++) {\n            cin >> w[i];\n        }\n        w[n]   = INF0;\n        w[n+1] = INF1;\n\n        // make sections\n        queue<pii> que;\n        for (int i = 0; i < n; i++) {\n            if (ok(i, i+1)) {\n                ss.emplace_back(make_pair(i, i+1));\n                que.push(make_pair(i, i+1));\n            }\n        }\n\n        while (!que.empty()) {\n            auto q = que.front();\n            que.pop();\n            int b = q.first, e = q.second;\n            // 1ずつのばす\n            if (ok(b - 1, e + 1)) {\n                ss.push_back(make_pair(b-1, e+1));\n                que.push(make_pair(b-1, e+1));\n            }\n            // 上に2\n            if (ok(e + 1, e + 2)) {\n                ss.push_back(make_pair(b, e+2));\n                que.push(make_pair(b, e+2));\n            }\n            // 下に2\n            if (ok(b - 2, b - 1)) {\n                ss.push_back(make_pair(b-2, e));\n                que.push(make_pair(b-2, e));\n            }\n        }\n        sort(ss.begin(), ss.end());\n        unique(ss.begin(), ss.end());\n        // for (auto &x: ss) {\n        //     cout << \"[\" << x.first+1 << \", \" << x.second+1 << \"]\" << \" \";\n        // }\n        cout << dp(0, -1) << endl;\n    }\n    return 0;\n}\n\nint dp(int i, int pre) {\n    int res;\n    if (i == ss.size()) {\n        res = 0;\n    }\n    else if (ss[i].first > pre) {\n        res = max(dp(i+1, ss[i].second) + (ss[i].second - ss[i].first + 1), dp(i+1, pre));\n    }\n    else {\n        res = dp(i + 1, pre);\n    }\n    return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main() {\n    for(;;) {\n        int n;\n        std::cin >> n;\n        if (n == 0) {\n            break;\n        }\n        std::vector<int> xs(n);\n        for(int i = 0; i < n; ++i) {\n            std::cin >> xs[i];\n        }\n        int dp[310][310] = {{}};\n        for(int w = 2; w <= n; ++w) {\n            for(int l = 0; l <= n-w; ++l) {\n                int r = l + w;\n                // sep\n                for(int k = l+1; k < r; ++k) {\n                    dp[l][r] = std::max(dp[l][r], dp[l][k] + dp[k][r]);\n                }\n                // 2\n                if (std::abs(xs[l] - xs[r-1]) <= 1 && dp[l+1][r-1] == r-l-2) {\n                    dp[l][r] = std::max(dp[l][r], dp[l+1][r-1] + 2);\n                }\n            }\n        }\n        printf(\"%d\\n\", dp[0][n]);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint w[301];\nint dp[301][301];\n\nint func(int l,int r){\n\tif(dp[l][r]!=-1)return dp[l][r];\n\tif(l+1>=r)return 0;\n\tif(l+2==r){\n\t\tif(abs(w[l]-w[l+1])<=1)return 2;\n\t\telse return 0;\n\t}\n\tint res=0;\n\tres=max(res,func(l+1,r));\n\tres=max(res,func(l+2,r)+(abs(w[l]-w[l+1])<=1?2:0));\n\tres=max(res,func(l,r-1));\n\tres=max(res,func(l,r-2)+(abs(w[r-1]-w[r-2])<=1?2:0));\n\tif(abs(w[l]-w[r-1])<=1){\n\t\tint v=func(l+1,r-1);\n\t\tif(v==(r-1)-(l+1)){\n\t\t\tres=r-l;\n\t\t}\n\t}\n\treturn (dp[l][r]=res);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&w[i]);\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tprintf(\"%d\\n\",func(0,n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i,a,b) for(ll i=a;i<=b;i++)\n#define FORD(i,a,b) for(int i=a;i>=b;i--)\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define sqr(x) ((x) * (x))\n#define bit(n) (1LL<<(n))\n#define pcnt(x) __builtin_popcountll(x)\n#define PB push_back\n#define MP make_pair\n#define endl \"\\n\"\nusing Edge = pair<int,int>;\nusing Graph = vector<vector<Edge>>;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\n// ll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nbool cantake[310][310];\nint dp[310][310];\n\nint main() {\n  while(1){\n    int n; cin >> n;\n    if(n==0) break;\n    int w[n+2];\n    MEMSET(cantake,false);\n    MEMSET(dp,0);\n    w[0] = 1001001001;\n    w[n+1] = 1001001001;\n    FOR(i,1,n) cin >> w[i];\n\n    FOR(wid,2,n+1){\n      FOR(i,1,n){\n        int j = i+wid-1;\n        if(j>=n+1) continue;\n\n        if(dp[i+1][j-1]==wid-2 && abs(w[i]-w[j])<=1) dp[i][j]=wid;\n        FOR(k,i,j){\n          chmax(dp[i][j], dp[i][k] + dp[k+1][j]);\n        }\n      }\n    }\n    cout << dp[1][n] << \"\\n\";\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\nint n;\nint a[300];\n\nbool used[300][300];\nint ans[300][300];\nint can(int l, int r) {\n\tif (l > r)return 0;\n\tif (used[l][r])return ans[l][r];\n\tused[l][r] = true;\n\tint ret = 0;\n\tif (abs(a[l] - a[r]) <= 1) {\n\t\tret = can(l + 1, r - 1);\n\t\tif (ret == r - l - 1) {\n\t\t\tret += 2;\n\t\t}\n\t}\n\tret = max(ret, can(l + 1, r));\n\tRep1(i, l + 1, r - 1) {\n\t\tif (abs(a[i] - a[l]) > 1)continue;\n\t\tint le = can(l + 1, i - 1);\n\t\tif (le == i - l - 1)le += 2;\n\t\tint ri = can(i + 1, r);\n\t\tret = max(ret, le + ri);\n\t}\n\treturn ans[l][r] = ret;\n}\nvoid solve() {\n\twhile (cin >> n, n) {\n\t\trep(i, n) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tused[i][j] = false;\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcout << can(0, n - 1) << endl;\n\t}\n\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define debug(x) cerr << #x << \" = \" << (x) << endl\n#define SIZE 302\n\nusing namespace std;\n\nint dp[SIZE][SIZE], w[SIZE];\n\nint f(int j, int k) {\n\tint maxf = -1;\n\tif (dp[j][k] >= 0) return dp[j][k];\n\t// printf(\"f(%d, %d)\\n\", j, k);\n\tif (k - j <= 0) return dp[j][k] = 0;\n\tif (k - j == 1) {\n\t\tdp[j][k] = ((abs(w[j] - w[k])) <= 1 ? 2 : 0);\n\t\t/*if (abs(w[j] - w[k]) <= 1) {\n\t\t\tdebug(j);\n\t\t\tdebug(k);\n\t\t}*/\n\t\t/*debug(j);\n\t\tdebug(k);\n\t\tdebug(dp[j][k]);*/\n\t\treturn dp[j][k];\n\t}\n\tif (k - j == 2) {\n\t\tdp[j][k] = max(f(j + 1, k), f(j, k - 1));\n\t\treturn dp[j][k];\n\t}\n\tfor (int i = j + 1; i + 1 < k; i++) {\n\t\tmaxf = max(maxf, f(j, i) + f(i + 1, k));\n\t\t// debug(i);\n\t\t// debug(maxf);\n\t}\n\tdp[j][k] = max(f(j + 1, k - 1) + ((abs(w[j] - w[k]) <= 1 && f(j+1, k-1)==k-j-1) ? 2 : 0), maxf);\n\t/*if (abs(w[j] - w[k]) <= 1) {\n\t\tdebug(j);\n\t\tdebug(k);\n\t\tdebug(dp[j][k]);\n\t}*/\n\treturn dp[j][k];\n}\n\nint main() {\n\twhile (1) {\n\t\tint n;\n\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tREP(i, n) cin >> w[i];\n\t\tREP(j, n) { REP(k, n) dp[j][k] = -1; }\n\n\t\t cout << f(0, n - 1) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n \n#define rep(i, a) for (int i = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int i = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int i = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int i = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n#define TRUE__  \"Yes\"\n#define FALSE__ \"No\"\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define RS resize\n#define CINV(v, N) do {\\\n\tv.RS(N);\\\n\trep(i, N) cin >> v[i];\\\n} while (0);\n#define RCINV(v, N) do {\\\n\tv.RS(N);\\\n\trrep(i, N) cin >> v[i];\\\n} while (0);\n \n#define MOD 1000000007\nbool init();\nint solve();\n\nsigned main()\n{\n    while (init()) {\n    \tcout << solve() << endl;\n\t}\n}\n\nint N;\nvector<int> w;\n\nbool init()\n{\n\tcin >> N;\n\tif (N == 0) return false;\n\tw.RS(N);\n\trep(i, N) cin >> w[i];\n\treturn true;\n}\n\n\nint solve()\n{\n\tvector<vector<bool> > dp;\n\tvector<ll> imos;\n\tdp.RS(N, vector<bool>(N, false));\n\timos.RS(N+1);\n\tfor (int i = 0; i + 1 < N; i++) {\n\t\tif (abs(w[i] - w[i+1]) <= 1) {\n\t\t\tdp[i][i+1] = true;\n\t\t\timos[i]++;\n\t\t\timos[i+2]--;\n\t\t}\n\t}\n\tfor (int l = 4; l <= N; l += 2) {\n\t\tfor (int i = 0; i + l - 1 < N; i++) {\n\t\t\tint j = i + l - 1;\n\t\t\tif ((abs(w[i] - w[j]) <= 1 && dp[i+1][j-1]) || (dp[i][j-2] && dp[j-1][j])) {\n\t\t\t\tdp[i][j] = true;\n\t\t\t\timos[i]++;\n\t\t\t\timos[j+1]--;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tint cnt = 0;\n\trep(i, N) {\n\t\tif (imos[i] > 0) {\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tres += cnt - (cnt % 2);\n\t\t\tcnt = 0;\n\t\t}\n\t\timos[i+1] += imos[i];\n\t}\n\tres += cnt - (cnt % 2);\n\treturn res;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <stdio.h>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <time.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> Pii;\ntypedef pair<int, ll> Pil;\ntypedef pair<ll, ll> Pll;\ntypedef pair<ll, int> Pli;\n\n#define fi first\n#define se second\n#define mp make_pair\n \nconst ll MOD = 1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll INF = 1ll << 60;\nconst double PI = 2 * asin(1);\n\nvoid yes() {printf(\"yes\\n\");}\nvoid no() {printf(\"no\\n\");}\nvoid Yes() {printf(\"Yes\\n\");}\nvoid No() {printf(\"No\\n\");}\nvoid YES() {printf(\"YES\\n\");}\nvoid NO() {printf(\"NO\\n\");}\n\nint N, W[305], DP[305][305];\n\nint DFS(int L, int R){\n  if (DP[L][R] != -1) return DP[L][R];\n\n  if (L + 1 == R) return DP[L][R] = 0;\n  if (L + 2 == R){\n    if (abs(W[L] - W[L + 1]) <= 1) return DP[L][R] = 2;\n    else return DP[L][R] = 0;\n  }\n\n  int ans = 0;\n  if (DFS(L + 1, R - 1) == (R - 1) - (L + 1)){\n    ans = DFS(L + 1, R - 1);\n    if (abs(W[L] - W[R - 1]) <= 1) ans += 2;\n  }\n\n  for (int i = L + 1; i < R; i++){\n    ans = max(ans, DFS(L, i) + DFS(i, R));\n  }\n  return DP[L][R] = ans;\n}\n\nint Solve(){\n  fill((int*)DP, (int*)(DP + N), -1);\n  for (int i = 0; i < N; i++) cin >> W[i];\n  cout << DFS(0, N) << endl;\n  return 0;\n}\n\nint main(){\n  while (cin >> N){\n    if (N == 0) return 0;\n    Solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tint a[300],dp2[301] = {};\n\t\tbool dp1[301][301] = {};\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> a[i];\n\t\t\tdp1[i][i] = true;\n\t\t}\n\t\tfor(int i = 2;i <= n;i += 2){\n\t\t\tfor(int j = 0;j + i <= n;j++){\n\t\t\t\tfor(int k = 0;k <= i;k++){\n\t\t\t\t\tif(dp1[j][j + k] && dp1[j + k][j + i]) dp1[j][j + i] = true;\n\t\t\t\t}\n\t\t\t\tif(dp1[j + 1][j + i - 1] && abs(a[j] - a[j + i - 1]) <= 1) dp1[j][j + i] = true;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdp2[i] = dp2[i - 1] + 1;\n\t\t\tfor(int j = 0;j <= i;j++){\n\t\t\t\tif(dp1[j][i]) dp2[i] = min(dp2[i],dp2[j]);\n\t\t\t}\n\t\t}\n\t\tcout << n - dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n#define EQ(a,b) (abs(a - b) < 1e-10)\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<LL> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<bool> VB;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\nint n;\nvector<int> w;\ntypedef bitset<301> bit;\nstruct Comp {\n\tbool operator() (const bit &a,const bit &b) {\n\t\treturn a.to_ullong() < b.to_ullong();\n\t}\n};\nmap<bit,int,Comp> memo;\nint dfs(bit state) {\n\tif (IN(state,memo)) return memo[state];\n\tint num = 0,fi;\n\tREP(i,n-1) {\n\t\tif ((!state[i])) {\n\t\t\tfi = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFOR(i,fi+1,n) {\n\t\tif (!state[i]){\n\t\t\tif (abs(w[i] - w[fi]) <= 1) {\n\t\t\t\tbit next = (state | bit(1<<i) | bit(1<<(fi)));\n\t\t\t\tnum = max(dfs(next)+2,num);\n\t\t\t}\n\t\t\tfi = i;\n\t\t}\n\t}\n\treturn memo[state] = num;\n}\n\nint main(void) {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tw.resize(n);\n\t\tREP(i,n) cin >> w[i];\n\t\tcout << dfs(bit(0)) << endl;\n\t\tmemo.clear();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n;\nvi in;\nint dp[310][310];\nint f(int l,int r){\n\tif(dp[l][r]+inf)return dp[l][r];\n\tif(r-l<2)return dp[l][r]=0;\n\tint out=-inf;\n\tloop(i,l,r-1)if(abs(in[i]-in[i+1])<2){\n\t\tout=max(out,f(l,i)+2+f(i+2,r));\n\t}\n\tint t=f(l+1,r-1);\n\tif(t==r-l-2){\n\t\tif(abs(in[l]-in[r-1])<2)out=max(out,r-l);\n\t}\n\tout=max(out,f(l+1,r));\n\tout=max(out,f(l,r-1));\n//\tcout<<l<<\" \"<<r<<\" \"<<out<<endl;\n\treturn dp[l][r]=out;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vi(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,310)rep(j,310)dp[i][j]=-inf;\n\t\tcout<<f(0,n)<<endl;;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define rep1(i,n) for(int i = 1; i <= (n); i++)\n#define rrep1(i,n) for(int i = (n); i > 0; i--)\n\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n\n#define MOD 1000000007\n#define INF 1000000000000000LL\n\nusing namespace std;\n\n#define MAXN 301\nint n;\n\nvector<int> w(MAXN);\nint dp[MAXN][MAXN];\n\nbool isin(int i, int j){\n  return 0<=i && j<n;\n}\n\nbool bashable(int i, int j){\n  return abs(w[i]-w[j])<=1;\n}\n\nint solve(){\n  rep(i, n-1)dp[i][i+1] = bashable(i, i+1) ? 2 : 0;\n  for(int len=4; len<=n; len++){\n    rep(from, n-len+1){\n      int to = from+len-1;\n\n      int inner = from+1<to-1 ? dp[from+1][to-1] : 0;\n      if(inner==len-2 && bashable(from, to))inner += 2;\n      dp[from][to] = inner;\n\n      for(int m=from; m<=to;m++){\n        dp[from][to] = max(dp[from][to], dp[from][m]+dp[m+1][to]);\n      }\n\n      // rep(i, n){rep(j, n)cout<<dp[i][j]<<' ';cout<<endl;}cout<<endl;\n\n    }\n  }\n\n  return dp[0][n-1];\n}\n\nint main(){\n  while(cin>>n){\n    if(!n) break;\n\n    rep(i, MAXN)w[i]=0;\n    rep(i, MAXN)rep(j, MAXN)dp[i][j]=0;\n    rep(i, n)cin>>w[i];\n    int result = solve();\n    cout<<result<<endl;\n\n// rep(i, n){rep(j, n)cout<<dp[i][j]<<' ';cout<<endl;}cout<<endl;\n\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing P = pair<int, int>;\nusing Graph = vector<vector<int>>;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nint n; \nvector<int> w;\nvector<vector<int>> dp;\n\nint rec(int l = 0, int r = n){\n    //[l,r)をみる\n    if((r - l) <= 1) return 0;\n    if((r - l) == 2){\n        if(abs(w[l] - w[l+1])<=1) return 2;\n        else return 0;\n    }\n    int &res = dp[l][r];\n    if(res != -1) return res;\n    if(abs(w[l] - w[r-1]) <= 1 && rec(l+1, r-1) == r - l - 2) chmax(res, r - l);//全部取り除ける時\n    for(int i = l+1; i <= r-1; i++){\n        chmax(res, rec(l,i) + rec(i, r));\n    }\n    return res;\n}\n\nint main(){\n    vector<int> ans;\n    while(true){\n        cin >> n;\n        if(n == 0) break;\n        w.resize(n);\n        for(int i = 0; i < n; i++){\n            cin >> w[i];\n        }\n        dp.assign(n+1,vector<int>(n+1, -1));\n        ans.push_back(rec());\n    }\n    for(auto i : ans) cout << i << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<int>v(n);\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\n        for(int i=0;i<n;++i){\n            cin>>v[i];\n        }\n        for(int i=0;i<n-1;++i){\n            if(abs(v[i]-v[i+1])<2)dp[i][i+2]=2;\n        }\n        for(int i=n-2;i>=0;--i){\n            for(int j=i+2;j<n+1;++j){\n                if(abs(v[i]-v[j-1])<2 && dp[i+1][j-1]==j-i-2)dp[i][j]=j-i;\n                for(int k=j;k<n+1;++k){\n                    dp[i][k]=max(dp[i][k],dp[i][j]+dp[j][k]);\n                }\n            }\n        }\n        cout<<dp[0][n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <regex>\n#include <climits>\n\n#define FOR(i, f, n) for(int (i) = (f), TMPend = (n); (i) < TMPend; (i)++)\n#define RFOR(i, f, n) for(int (i) = (f), TMPend = (n); (i) >= TMPend; (i)--)\n#define REP(i, n) for(int (i) = 0, TMPend = (n); (i) < TMPend; (i)++)\n#define RREP(i, n) for(int (i) = (n); (i) >= 0; (i)--)\n#define rep(i, n) for(int (i) = 0, TMPend = (n); (i) < TMPend; (i)++)\n#define rrep(i, n) for(int (i) = (n); (i) >= 0; (i)--)\n#define forin(i, a) for(auto i: (a))\n#define p(...) printf(__VA_ARGS__); cout << endl;\n#define in(...) __VA_ARGS__; input__(__VA_ARGS__);\n#define input(...) in(__VA_ARGS__)\n#define out(...) output__(__VA_ARGS__);\n#define output(...) out(__VA_ARGS__)\n#define list_input(x, n) x[(n)]; for(int (i) = 0; (i) < (n); (i)++) cin >> x[i];\n#define lambda(a, b, c) [](auto const &a, auto const &b){ return c ;}\n#define key(t, x, compare) [](const t &a, const t &b){ return a x compare b x ;}\n#define unless(a) if(!(a))\n\nusing namespace std;\n\nusing pii = pair<int, int>;\n\ntemplate <class... T>\nvoid input__(T &...a) {\n  for(auto v: {&a...}) {\n    cin >> *v;\n  }\n}\n\nvoid output__(){\n  cout << endl;\n}\n\ntemplate <class Head, class... T>\nvoid output__(Head const &v, T const &...a) {\n  if(sizeof...(a) == 0) {\n    cout << v;\n  } else {\n    cout << v << \" \";\n  }\n  output__(a...);\n}\n\nint a[300];\nbool take[301][301];\nbool check[301][301];\nint dp[301][301];\n\nbool take_dfs(int i, int j) {\n  if (i == j) return false;\n  if (check[i][j]) {\n    return take[i][j];\n  }\n  bool isok;\n  if (j - i <= 1) {\n    isok = abs(a[i] - a[j]) <= 1;\n    take[i][j] = isok;\n    if (isok) dp[i][j] = j - i + 1;\n    check[i][j] = true;\n    return isok;\n  }\n\n  isok = abs(a[i] - a[j]) <= 1 && take_dfs(i + 1, j - 1);\n  FOR(k, i + 1, j) {\n    if (isok) break;\n    isok = take_dfs(i, k) && take_dfs(k + 1, j);\n  }\n\n  take[i][j] = isok;\n  if (isok) dp[i][j] = j - i + 1;\n  check[i][j] = true;\n  return isok;\n}\n\nbool f(){\n  int input(n);\n  if (n == 0) return true;\n  memset(a, 0, sizeof(a));\n  memset(take, 0, sizeof(take));\n  memset(check, 0, sizeof(check));\n  memset(dp, 0, sizeof(dp));\n\n  rep(i, n) cin >> a[i];\n  rep(i, n - 1) take_dfs(i, n - 1);\n  /* rep(left, n - 1) rep(right, n - 1) { */\n  /*   , */\n  /* } */\n\n  rep(w, n) rep(i, n - w) FOR(k, i, i + w) {\n    dp[i][i + w] = max(dp[i][i + w], dp[i][k] + dp[k + 1][i + w]);\n  }\n  cout << dp[0][n - 1] << endl;\n\n  /* rep(i, n + 1) { */\n  /*   rep(j, n + 1) { */\n  /*     cout << take[i][j] << \" \"; */\n  /*   } */\n  /*   cout << endl; */\n  /* } */\n  return false;\n}\n\nint main() {\n  while(1) {\n    if(f()) break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<int>v(n);\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\n        for(int i=0;i<n;++i){\n            cin>>v[i];\n        }\n        for(int i=n-2;i>=0;--i){\n            for(int j=i+2;j<n+1;++j){\n                if(abs(v[i]-v[j-1])<2 && dp[i+1][j-1]==j-i-2)dp[i][j]=j-i;\n                for(int k=j;k<n+1;++k){\n                    dp[i][k]=max(dp[i][k],dp[i][j]+dp[j][k]);\n                }\n            }\n        }\n        cout<<dp[0][n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0}; \n\nint n;\nint data[300];\nint dp[300][301]; // hankai\nint score[300][301];\n\nvoid make(int st, int en)\n{\nif (dp[st][en]) return;\ndp[st][en] = 1;\nif (0 <= st - 2 && abs(data[st-2] - data[st-1] ) < 2 ) {\nmake(st-2, en);\n}\nif (0 <= st - 1 && en < n && abs(data[st-1] - data[en]) < 2) {\nmake(st-1, en+1);\n}\nif (en + 1 < n && abs(data[en] - data[en+1]) < 2) {\nmake(st, en+2);\n}\n}\n\nint solve(int st, int en)\n{\nif ( dp[st][en] ) return 0; \nif ( score[st][en] ) return score[st][en];\nif (en - st < 2) return en - st;\nint ret = en - st;\nfor (int i = st+2; i < en; i++) {\nif (dp[st][i]) {\nret = min(solve(i-1, en), ret)\n}\n}\nreturn score[st][en] = min(ret, 1+solve(st+1, en));\n}\n\nsigned main() \n{ \nstd::ios::sync_with_stdio(false); \nstd::cin.tie(0); \n\ncin >> n;\nwhile ( n ) {\nmemset(data, 0, sizeof(data))\nmemset(dp, 0, sizeof(dp));\nrep(i, n) cin >> data[i];\nrep(i, n-1) if ( abs(data[i] - data[i+1]) < 2 )\nmake(i, i+2);\ncout << n - solve(0, n) <<endl;\ncin >> n;\n}\n\nreturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define INF 1e9\n#define LINF 1e18\n#define fi first\n#define se second\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pi;\ntypedef pair<P, P> PP;\n\nconst int MOD = 1e9 + 7;\nconst int dy[] = { 0, 0, 1, -1 };\nconst int dx[] = { 1, -1, 0, 0 };\n\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\n\nint dp[301][301];\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin >> n, n) {\n        int w[n];\n        rep(i, n) cin >> w[i];\n        memset(dp, 0, sizeof(dp));\n        for(int i = n - 1; i >= 0; --i) {\n            FOR(j, i + 1, n + 1) {\n                if(i + 1 < j && abs(w[i] - w[j - 1]) <= 1 && dp[i + 1][j - 1] == j - i - 2) {\n                    dp[i][j] = j - i;\n                }\n                FOR(k, j + 1, n + 1) {\n                    chmax(dp[i][k], dp[i][j] + dp[j][k]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int abs(int a, int b)\n{\n    return a<b ? b-a : a-b;\n}\n\nint w[301];\nbool rm[301][301];\nint rmct[301][301];\n\nint main()\n{\n    int n;\n    while(cin >> n, n)\n    {\n        for(int i=0; i<n; i++) cin >> w[i];\n        for(int i=0; i<=n; i++)\n            for(int j=0; j<=n; j++)\n                rm[i][j] = i==j;\n        for(int r=2; r<=n; r+=2)\n        {\n            for(int i=0; i+r<=n; i++)\n            {\n                for(int s=2; s<r; s+=2)\n                {\n                    if(rm[i][i+s] && rm[i+s][i+r]) rm[i][i+r] = true;\n                }\n                if(!rm[i][i+r] && rm[i+1][i+r-1] && abs(w[i], w[i+r-1])<=1)\n                    rm[i][i+r] = true;\n            }\n        }\n        /*\n        int rmw = -1;\n        for(int rmr = n / 2 * 2; rmw==-1 && rmr >= 0; rmr-=2)\n        {\n            for(int i=0; i+rmr<=n; i++)\n            {\n                if(rm[i][i+rmr])\n                {\n                    rmw = rmr;\n                    break;\n                }\n            }\n        }\n        */\n        for(int y=0; y<=n; y++)\n            for(int x=0; x<=n; x++)\n                rmct[y][x] = rm[y][x] ? x - y : 0;\n        for(int r=1; r<=n; r++)\n        {\n            for(int i=0; i<=n; i++)\n            {\n                for(int s=1; s<r; s++)\n                {\n                    rmct[i][i+r] = max(rmct[i][i+r], rmct[i][i+s]+rmct[i+s][i+r]);\n                }\n            }\n        }\n        cout << rmct[0][n] << endl;\n        // XXX DEBUG\n        /*\n        printf(\"i\\\\j \");\n        for(int x=0; x<=n; x++) printf(\"%3d \", x);\n        cout << endl;\n        for(int y=0; y<=n; y++)\n        {\n            printf(\"%3d \", y);\n            for(int x=0; x<=n; x++)\n            {\n                printf(\"%3d \", rm[y][x]);\n            }\n            cout << endl;\n        }\n        */\n        // XXX DEBUG\n        //cout << rmw << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    int w[n];\n    for(int i = 0; i < n; ++i)\n      cin >> w[i];\n    \n    int dp[n][n];\n    for(int i = 0; i < n; ++i){\n      fill(dp[i],dp[i]+n,0);\n    }\n    \n    for(int i = 0; i < n-1; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(j+i+1 > n-1) break;\n\tif(dp[j+1][j+i] == i && abs(w[j]-w[j+i+1]) < 2){\n\t  dp[j][j+i+1] = dp[j+1][j+i] + 2;\n\t}else{\n\t  for(int k = 0; k < i; ++k){\n\t    dp[j][j+i+1] = max(dp[j][j+i+1],dp[j][j+k]+dp[j+k+1][j+i+1]);\n\t  }\n\t}\n      }\n    }\n    /*\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n      cout << dp[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n    cout << dp[0][n-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\n\nint main() {\n    int n;\n    \n    while(cin >> n, n != 0){\n        vector<int> w(n);\n        REP(i, n){\n            cin >> w[i];\n        }\n        \n        bool dp[305][305] = {};\n        REP(i, n - 1){\n            if(abs(w[i] - w[i + 1]) <= 1){\n                dp[i][i + 1] = true;\n            }\n        }\n        \n        for(int len = 3; len <= n; len++){\n            for(int l = 0; l < n; l++){\n                int r = l + len - 1;\n                if(r >= n)continue;\n\n                for(int c = l + 1; c < r - 1; c++){\n                    if(dp[l][c] && dp[c + 1][r]){\n                        dp[l][r] = true;\n                    }\n                }\n                \n                if(dp[l + 1][r - 1] && abs(w[l] - w[r]) <= 1){\n                    dp[l][r] = true;\n                }\n            }\n        }\n        \n        int dp2[305] = {};\n        for(int r = 1; r < n; r++){\n            dp2[r] = max(dp2[r], dp2[r - 1]);\n            REP(l, r){\n                if(dp[l][r]){\n                    if(l == 0){\n                        dp2[r] = max(dp2[r], r - l + 1);\n                    }\n                    else{\n                        dp2[r] = max(dp2[r], dp2[l - 1] + r - l + 1);\n                    }\n                }\n            }\n        }\n        cout << dp2[n - 1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint w[301];\nint dp[301][301];\n\nint func(int l,int r){\n\tif(dp[l][r]!=-1)return dp[l][r];\n\tif(l+1>=r)return 0;\n\tif(l+2==r){\n\t\tif(abs(w[l]-w[l+1])<=1)return (dp[l][r]=2);\n\t\telse return (dp[l][r]=0);\n\t}\n\tint res=0;\n\tres=max(res,func(l+1,r));\n\tres=max(res,func(l+2,r)+((abs(w[l]-w[l+1])<=1)?2:0));\n\tres=max(res,func(l,r-1));\n\tres=max(res,func(l,r-2)+((abs(w[r-1]-w[r-2])<=1)?2:0));\n\tif(abs(w[l]-w[r-1])<=1){\n\t\tint v=func(l+1,r-1);\n\t\tif(v==((r-1)-(l+1))){\n\t\t\tres=r-l;\n\t\t}\n\t}\n\treturn (dp[l][r]=res);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&w[i]);\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tprintf(\"%d\\n\",func(0,n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> w(n);\n        for (int i = 0; i < n; i++) {\n            cin >> w[i];\n        }\n\n        vector<vector<bool>> ok(n, vector<bool>(n, false));  // [i,j]?????¨????????¨?????????\n        for (int d = 1; d < n; d += 2) {\n            for (int i = 0; i + d < n; i++) {\n                if (d == 1) {\n                    if (abs(w[i] - w[i + d]) <= 1) {\n                        ok[i][i + d] = true;\n                    }\n                } else {\n                    if (ok[i + 1][i + d - 1] and abs(w[i] - w[i + d]) <= 1) {\n                        ok[i][i + d] = true;\n                    } else if (ok[i + 2][i + d] and abs(w[i] - w[i + 1]) <= 1) {\n                        ok[i][i + d] = true;\n                    }\n                }\n            }\n        }\n        vector<pair<int, int>> interval;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (ok[i][j]) {\n                    interval.push_back(make_pair(i + 1, j + 1));\n                }\n            }\n        }\n        const int size = interval.size();\n        vector<vector<int>> dp(size + 1, vector<int>(n + 1, 0));\n        for (int i = 0; i < size; i++) {\n            for (int j = 0; j <= n; j++) {\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n                if (j < interval[i].first) {\n                    dp[i + 1][interval[i].second] = max(dp[i + 1][interval[i].second], dp[i][j] + (interval[i].second - interval[i].first + 1));\n                }\n            }\n        }\n\n        int maxi = 0;\n        for (int i = 0; i <= n; i++) {\n            maxi = max(maxi, dp[size][i]);\n        }\n        cout << maxi << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//using Graph = vector<vector<edge>>;\nusing dou =long double;\nstring yes=\"yes\";\nstring Yes=\"Yes\";\nstring YES=\"YES\";\nstring no=\"no\";\nstring No=\"No\";\nstring NO=\"NO\";\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n#define rep(i, n)         for(int i = 0; i < (int)(n); i++)\n#define brep(n)           for(int bit=0;bit<(1<<n);bit++)\n#define erep(i,container) for (auto i : container)\n#define irep(i, n)        for(int i = n-1; i >= (int)0; i--)\n#define rrep(i,m,n) for(ll i = m; i < (ll)(n); i++)\n#define reprep(i,j,h,w) rep(i,h)rep(j,w)\n#define all(x) (x).begin(),(x).end()\n#define VEC(type,name,n) std::vector<type> name(n);rep(i,n)std::cin >> name[i];\n#define pb push_back\n#define pf push_front\n#define query int qq;std::cin >> qq;rep(qqq,qq)\n#define lb lower_bound\n#define ub upper_bound\n#define fi first\n#define se second\n#define itn int\n#define mp make_pair\n#define sum(a) accumulate(all(a),0ll)\n#define keta fixed<<setprecision\n#define vvector(name,typ,m,n,a)vector<vector<typ> > name(m,vector<typ> (n,a))\n#define vvvector(name,t,l,m,n,a) vector<vector<vector<t> > > name(l, vector<vector<t> >(m, vector<t>(n,a)));\n#define vvvvector(name,t,k,l,m,n,a) vector<vector<vector<vector<t> > > > name(k,vector<vector<vector<t> > >(l, vector<vector<t> >(m, vector<t>(n,a)) ));\n#define case std::cout <<\"Case #\" <<qqq+1<<\": \"\n#define res resize\n#define as assign\n#define ffor for(;;)\n#define ppri(a,b) std::cout << a<<\" \"<<b << std::endl\n#define pppri(a,b,c) std::cout << a<<\" \"<<b <<\" \"<< c<<std::endl\n#define aall(x,n) (x).begin(),(x).begin()+(n)\n#define ssum(a) accumulate(a,0ll) \n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n//typedef long long T;\nconst int INF = 2000000000;\nconst ll INF64 = 922337203685477580ll;\nconst ll MOD = 1000000007ll;\nconst dou pi=3.141592653589793;\nint main(){\n    ffor{\n        int n;\n        std::cin >> n;\n        if(n==0)break;\n        \n        VEC(int,a,n);\n        \n        \n        vvector(dp,int,n+1,n+1,0);\n        for (int ii = 0; ii < n+1; ii++) {\n            rep(i,n+1-ii){\n                for(int jj=0;jj<=ii;jj++){\n                    chmax(dp[i][ii+i],dp[i][i+jj]+dp[i+jj][ii+i]);\n                    \n                }\n                if(i!=0&&i+ii!=n){\n                    if(dp[i][i+ii]==ii&&abs(a[i-1]-a[i+ii])<=1)chmax(dp[i-1][i+ii+1],dp[i][i+ii]+2);\n                }\n            }\n        }\n        int ans=0;\n        reprep(i,j,n+1,n+1){\n           // pppri(i,j,dp[i][j]);\n            chmax(ans,dp[i][j]);\n        }\n        std::cout << ans << std::endl;\n        \n        \n        /*\n        vvector(dp,bool,n+1,n+1,0);\n        rep(i,n+1)dp[i][i]=1;\n        \n        for (int ii = 0; ii < n+1; ii+=2) {\n            rep(i,n+1-ii){\n                for(int jj=0;jj<=ii;jj+=2){\n                    if(dp[i][i+jj]&&dp[i+jj][ii+i])dp[i][ii+i]=1;\n                    \n                }\n                if(i!=0&&i+ii!=n){\n                        if(dp[i][i+ii]&&abs(a[i-1]-a[i+ii])<=1)dp[i-1][i+ii+1]=1;\n                }\n            }\n        }\n        */\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 62;\n\nint mod = 1000000007;\n\nint dp[301][301];\n\nint main(void){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector<int> ans;\n    while(true){\n        int N; cin >> N; if(N == 0) break;\n        vector<int> W(N); rep(i, N) cin >> W[i];\n        memset(dp, 0, sizeof(dp));\n        for(int haba = 1; haba <= N; haba++){\n            for(int left = 0; left + haba <= N; left++){\n                int res = 0;\n                int right = left + haba;\n                if(right-left >= 2){\n                    if(abs(W[left]-W[right-1]) <= 1 && dp[left+1][right-1] == right-left-2) res = dp[left+1][right-1]+2;\n                    else res = dp[left+1][right-1];\n                }\n                for(int boarder = left+1; boarder < right; boarder++){\n                    res = max(res, dp[left][boarder] + dp[boarder][right]);\n                }\n                dp[left][right] = res;\n            }\n        }\n        ans.push_back(dp[0][N]);\n    }\n    rep(i, ans.size()) cout << ans[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst int INF=1<<17;\n\nint dp[300][300]; //dp[i][j]:=[i,j)で取り除けるブロックの最大値\nvector<int> W;\n\nint rec(int l,int r){ //[r,l)\n    if(~dp[l][r]) return dp[l][r];\n    if(r-l<=1) return dp[l][r]=0;\n    else if(r-l==2){\n        if(abs(W[r-1]-W[l])<=1) return dp[l][r]=2;\n        else dp[l][r]=0;\n    }\n    int ret=0;\n    if(l+1<r-1&&abs(W[l]-W[r-1])<=1&&rec(l+1,r-1)==r-l-2){\n        ret=max(ret,rec(l+1,r-1)+2);\n        return dp[l][r]=ret;\n    }\n    for(int i=l+1;i<r;i++){\n        ret=max(ret,rec(l,i)+rec(i,r));\n    }\n    return dp[l][r]=ret;\n}\n\n\nint main(){\n    int n;\n    while(cin >> n){\n        if(!n) break; \n        W.clear();\n        for(int i=0;i<n;i++){\n            int w;\n            cin >> w;\n            W.push_back(w);\n        }\n        memset(dp,-1,sizeof(dp));\n        cout << rec(0,n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nint rec(int l, int r, VI &a) {\n  if (r - l <= 1) return 0;\n  if (r - l == 2) {\n    if (abs(a[l + 1] - a[l]) <= 1) return 2;\n    return 0;\n  }\n  int res = rec(l + 1, r, a);\n  for (int i = l + 1; i < r; i++) {\n    if (abs(a[i] - a[l]) <= 1 and rec(l + 1, i, a) == i - (l + 1)) {\n      res = max(res, i + 1 - l + rec(i + 1, r, a));\n    }\n  }\n  return res;\n}\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (n == 0) break;\n    VI a(n); for (int i = 0; i < n; i++) cin >> a[i];\n    cout << rec(0, n, a) << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <set>\n#include <math.h>\n#include <random>\n#define PI 3.14159265359\n#define ll long long\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define Rep(i, k, n) for(int i = k; i < (int)n; i++)\nusing namespace std;\n\nint main(){\n  while(true){\n    int n;\n    cin >> n;\n    if (n == 0){break;}\n    int w[n];\n    rep(i, n){\n      cin >> w[i];\n    }\n    int dp2[n][n];\n    rep(i,n){\n      rep(j,n){\n        dp2[i][j] = 0;\n      }    \n    }\n    \n    Rep(i, 1, n) {\n      rep(j, n-i) {\n        if (dp2[j+1][j+i-1] == i-1 && abs(w[j]-w[j+i]) <= 1) {\n          dp2[j][j+i] = dp2[j+1][j+i-1]+2;\n        }\n        rep(k, i) {\n          dp2[j][j+i] = max(dp2[j][j+i], dp2[j][j+k] + dp2[j+k+1][j+i]);\n        }\n      }\n    }\n    cout << dp2[0][n-1] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n\nint main(void){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0){ break; }\n\n    vector<int> w(n);\n    for(int i = 0; i < n; i++){ cin >> w[i]; }\n\n    vector<vector<int> > dp(n, vector<int>(n + 1, 0));\n    for(int k = 2; k <= n; k++){\n      for(int i = 0; i < n; i++){\n        if(i + k <= n){\n          for(int j = 1; j < k; j++)\n            dp[i][i + k] = max(dp[i][i + k], dp[i][i + j] + dp[i + j][i + k]);\n          if(dp[i + 1][i + k - 1] == k - 2 && abs(w[i] - w[i + k - 1]) <= 1)\n            dp[i][i + k] = dp[i + 1][i + k - 1] + 2;\n        }\n      }\n    }\n\n    cout << dp[0][n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint w[301];\nint dp[301][301];\n\nint func(int l,int r){\n\tif(dp[l][r]!=-1)return dp[l][r];\n\tif(l+1>=r)return 0;\n\tif(l+2==r){\n\t\tif(abs(w[l]-w[l+1])<=1)return (dp[l][r]=2);\n\t\telse return (dp[l][r]=0);\n\t}\n\tint res=0;\n\tfor(int i=l+1;i<r;i++){\n\t\tres=max(res,func(l,i)+func(i,r));\n\t}\n\tres=max(res,func(l+1,r));\n\tres=max(res,func(l+2,r)+((abs(w[l]-w[l+1])<=1)?2:0));\n\tres=max(res,func(l,r-1));\n\tres=max(res,func(l,r-2)+((abs(w[r-1]-w[r-2])<=1)?2:0));\n\tif(abs(w[l]-w[r-1])<=1){\n\t\tint v=func(l+1,r-1);\n\t\tif(v==((r-1)-(l+1))){\n\t\t\tres=r-l;\n\t\t}\n\t}\n\treturn (dp[l][r]=res);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&w[i]);\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tprintf(\"%d\\n\",func(0,n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nvector<tuple<int, int, int>>vec; int n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; vec.clear(); for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; } for (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { vec.push_back(make_tuple(j - i, i, j)); } }\n\t\tsort(vec.begin(), vec.end());\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tint a1 = get<1>(vec[i]), a2 = get<2>(vec[i]);\n\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 0; i < n; i++) { for (int j = i; j < n; j++) { for (int k = j; k < n; k++) { dp[i][k] = max(dp[i][k], dp[i][j - 1] + dp[j][k]); } } }\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  unsigned int N = 0;\n  vector<int> num;\n  int w = 0;\n\n  cin >> N;\n  while(N != 0) {\n    for(unsigned int i = 0; i < N; i++) {\n      cin >> w;\n      num.push_back(w);\n    }\n\n    while(true) {\n      unsigned int i;\n      for(i = num.size()-1; i > 0; i--)\n\tif(num.at(i)-num.at(i-1) >= -1 && num.at(i)-num.at(i-1) <= 1)\n\t  break;\n\n      if(i == 0)\n\tbreak;\n      num.erase(num.begin()+i);\n      num.erase(num.begin()+i-1);\n      \n      if(num.empty())\n\tbreak;\n    }\n\n    cout << N-num.size() << endl;\n\n    num.clear();\n\n    cin >> N;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include<vector>\n#include<algorithm>\n#include<map>\n#include<iomanip>\n#include<set>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<sstream>\n#include<cmath>\n#include<tuple>\n#include<bitset>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define req(i,n) for(ll i = 1;i <=  n; i++)\n#define rrep(i,n) for(ll i = n -1;i >= 0;i--)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(a) rbegin(a),rend(a)\ntypedef long long int ll;\ntypedef long double ld;\nconst ll INF = 1e18;\nconst double eps = 1e-8;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T & val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}int n, m, s, t, r, Q, b, c; vector<int> w;\nint dp[310][310];\nint rec(int l, int r) {\n    if (dp[l][r] != -1) return dp[l][r];\n    if (abs(l - r) <= 1) return 0;\n    int res = 0;\n    if (abs(w[l] - w[r - 1]) <= 1 && rec(l + 1, r - 1) == r - l - 2)\n        res = r - l;\n    for (int mid = l + 1; mid < r; mid++)\n        res = max(res, rec(l, mid) + rec(mid, r));\n    return dp[l][r] = res;\n}\nint main(void) {\n    while (cin >> n, n) {\n        w.resize(n); Fill(dp, -1);\n        rep(i, n) cin >> w[i];\n        cout << rec(0, n) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint solve(){\n    int n; cin>>n; \n    if(n==0) return -1;\n    vector<int> v(n); \n    for(int i=0;i<n;i++){cin>>v[i];}\n    vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n    for(int W = 2; W <= n; W++){ //区間の大きさ\n        for(int l = 0; l < n; l++){\n            int r = l + W;\n            if(r > n) continue;\n            if(W==2){\n                if(abs(v[l]-v[r-1]) <= 1){dp[l][r]=2;}\n                else dp[l][r] =0;\n            }else{\n                if(dp[l+1][r-1]==W-2 && abs(v[l]-v[r-1]) <= 1) dp[l][r] = W; //遷移1\n                for(int m = l+1; m < r;m++) //遷移2\n                dp[l][r] = max(dp[l][r],dp[l][m]+dp[m][r]);\n            }\n        }\n    }\n    return dp[0][n];\n}\n \nint main(){\n    while(1){\n        int ans=solve();\n        if(ans==-1) break;\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n \nusing namespace std;\n \n#define PB push_back\n#define MP make_pair\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n \nconst int MOD = 1e9+7;\nconst int INF = 1e9;\n \nint main() {\n  while (true) {\n    int n, ans = 0;\n    bool canDrop[310][310];\n    int dp[310][310];\n    cin >> n;\n    if (n == 0) break;\n    vi c;\n    for (int i = 0; i < n; i++) {\n      int tmp;\n      cin >> tmp;\n      c.PB(tmp);\n    }\n    for (int i = 0; i <= 300; i++) {\n      for (int j = 0; j <= 300; j++) {\n        canDrop[i][j] = false;\n        dp[i][j] = 0;\n      }\n    }\n    for (int len = 2; len <= n; len+=2) {\n      for (int left = 0; left+len-1 < n; left++) {\n        int right = left + len - 1;\n        if (abs(c[left]-c[right])<=1) {\n          if (len==2) {\n            canDrop[left][right] = true;\n            // cout << len << \": \" << left << \"_a_\" << right << endl;\n            continue;\n          } else {\n            if (canDrop[left+1][right-1]) {\n              canDrop[left][right] = true;\n              // cout << len << \": \" << left << \"_b_\" << right << endl;\n              continue;\n            }\n          }\n        }\n        for (int pos = left+1; pos < right; pos+=2) {\n          if (canDrop[left][pos] && canDrop[pos+1][right]) {\n            canDrop[left][right] = true;\n            // cout << len << \": \" << left << \"_c_\" << right << endl;\n            break;\n          }\n        }\n      }\n    }\n    for (int len = 2; len <= n; len++) {\n      for (int left = 0; left+len-1 < n; left++) {\n        int right = left + len;\n        if (canDrop[left][right-1]) {\n          dp[left][right] = len;\n        }\n        for (int pos = left+1; pos < right; pos++) {\n          dp[left][right] = max(dp[left][right], dp[left][pos]+dp[pos][right]);\n        }\n        dp[0][n] = max(dp[0][n], dp[0][left]+dp[left][right]+dp[right][n]);\n      }\n    }\n    cout << dp[0][n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\nint N;\nint W[300];\n//-----------------------------------------------------------------\nint dp1[300][300];\nint dp2[300];\nint sol() {\n\t// clear\n\trep(i, 0, 300) rep(j, 0, 300) dp1[i][j] = false;\n\trep(i, 0, 300) dp2[i] = 0;\n\n\t// dp1\n\trep(L, 0, N - 1) {\n\t\tint R = L + 1;\n\t\tif (abs(W[L] - W[R]) <= 1) dp1[L][R] = true;\n\t}\n\tfor (int len = 4; len <= N; len += 2) rep(L, 0, N) {\n\t\tint R = L + len - 1;\n\t\tif (N <= R) break;\n\n\t\t// ok + ok\n\t\tfor (int C = L + 2; C < R; C += 2) if (dp1[L][C - 1] && dp1[C][R]) dp1[L][R] = true;\n\t\t// ? + ok + ?\n\t\tif (dp1[L + 1][R - 1]) if (abs(W[L] - W[R]) <= 1) dp1[L][R] = true;\n\t}\n\n\t// dp2\n\trep(R, 1, N) {\n\t\tdp2[R] = max(dp2[R], dp2[R - 1]);\n\t\trep(L, 0, R) {\n\t\t\tif (dp1[L][R]) {\n\t\t\t\tif (L == 0)\n\t\t\t\t\tdp2[R] = max(dp2[R], R - L + 1);\n\t\t\t\telse\n\t\t\t\t\tdp2[R] = max(dp2[R], dp2[L - 1] + R - L + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp2[N - 1];\n}\n//-----------------------------------------------------------------\nint main() {\n\twhile (cin >> N) {\n\t\tif (N == 0) return 0;\n\t\trep(i, 0, N) scanf(\"%d\", &W[i]);\n\t\tcout << sol() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define veci vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n\n\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\n//template<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\n//template<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x:vec) is >> x;\n    return is;\n}\nconst ll INF=1e9+7;\n\nll dp[305][305];\n\nint main()\n{\n    while(true){\n        ll n;\n        cin >> n;\n        if(n==0) break;\n        vector<ll> w(n);\n        rep(i,n) cin >> w[i];\n        rep(i,305){\n            rep(j,305){\n                dp[i][j]=0;\n            }\n        }\n        for(ll W=2;W<=n;W++){\n            rep(l,n){\n                ll r=l+W;\n                if(r>n) continue;\n                if(dp[l+1][r-1]==W-2 && abs(w[l]-w[r-1])<=1){\n                    dp[l][r]=W;\n                }\n                for(ll mid=l;mid<=r;mid++){\n                    dp[l][r]=max(dp[l][mid]+dp[mid][r],dp[l][r]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dp[310][310];\nint n;\nvector<int> node;\n\nint dfs(int l,int r)\n{\n\tif(l > r)return 0;\n\tif(l == r)return 0;\n\tif(dp[l][r] != -1)return dp[l][r];\n\tif(r - l == 1)return (abs(node[l]-node[r])<2)?2:0;\n\t\n\tint ret = 0;\n\t\n\tif(dfs(l+1,r-1)==r-l-1&&(abs(node[l]-node[r])<2))\n\t{\n\t\treturn r-l+1;\n\t}\n\t\n\tfor(int i=0;i < r-l;i++)\n\t{\n\t\tret = max(ret,dfs(l,l+i)+dfs(l+i+1,r));\n\t}\n\t\n\treturn dp[l][r] = ret;\n}\n\nint main()\n{\n\twhile(cin >> n,n)\n\t{\n\t\t\n\t\tREP(i,310)REP(j,310)dp[i][j] = -1;\n\t\tnode.clear();\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tint tmp;cin >> tmp;\n\t\t\tnode.PB(tmp);\n\t\t}\n\t\t\n\t\tcout << dfs(0,n-1) << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid solve(int n){\n    int w[n];\n    for(int i=0;i<n;i++)scanf(\"%d\",&w[i]);\n    vector<vector<int>> dp(n,vector<int>(n));\n    for(int i=0;i<n-1;i++)dp[i][i+1]=(abs(w[i]-w[i+1])<=1)*2;\n    for(int k=2;k<n;k++){\n        for(int i=0;i<n-k;i++){\n            int j=i+k;\n            if(dp[i+1][j-1]==j-i-1 and abs(w[i]-w[j])<=1)dp[i][j]=j-i+1;\n            else{\n                for(int l=i;l<j;l++)dp[i][j]=max(dp[i][j],dp[i][l]+dp[l+1][j]);\n            }\n        }\n    }\n    printf(\"%d\\n\",dp[0][n-1]);\n}\nint main(){\n    while(true){\n        int n;scanf(\"%d\",&n);\n        if(!n)break;\n        solve(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nint n;\nvector<int> w;\n\nint dp[333][333];\n\nint rec(int l, int r)\n{\n  if(l == r) return 0;\n  if(l + 1 == r) return abs(w[r] - w[l]) <= 1 ? 2 : 0;\n\n  int& ret = dp[l][r];\n  if(~ret) return ret;\n  ret = 0;\n\n  if(abs(w[r] - w[l]) <= 1) {\n    int temp = rec(l+1, r-1);\n    if(temp == r-l-1) ret += temp + 2;\n  }\n\n  for(int i = l; i < r; i++) {\n    ret = max(ret, rec(l, i) + rec(i+1, r));\n  }\n  \n  return ret;\n}\n\nsigned main()\n{\n  while(cin >> n, n) {\n    w.resize(n);\n    for(int i = 0; i < n; i++) cin >> w[i];\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, n-1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1611\n#include <bits/stdc++.h>\n#define endl \"\\n\"\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define SZ(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ipair;\ntypedef pair<ll,ll> lpair;\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v) //vectorの中身を見る\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nint solve(int n){\n    vector<int> w(n+10);\n    vector<vector<int>> dp(n+10,vector<int>(n+10,0));\n    rep(i,n) cin>>w[i+1];\n    //cout<<w<<endl;\n    for(int i=1;i<=n-1;i++) if(abs(w[i]-w[i+1])<=1) dp[i][i+1]=2;\n    for(int L=3;L<=n;L++){\n        for(int i=1;i<=n-2;i++){\n            int j=i+L-1;\n            if(n<j) break;\n            for(int k=i;k<=j-1;k++){\n                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);\n                if(abs(w[i]-w[j])<=1 && dp[i+1][j-1]==L-2) dp[i][j]=L;\n            }\n        }\n    }\n    return dp[1][n];\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n    \n    int x;\n    while(cin>>x){\n        if(x==0) break;\n        cout<<solve(x)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nint n, a[1010];\nint dp[1010][1010], dp2[1010] = {};\n\nint ok(int l, int r){\n    int &res = dp[l][r];\n    if(res != -1) return res;\n    res = false;\n    if(l+0 == r) res = true;\n    for(int i = l+2; i < r; i += 2) if(ok(l,i) && ok(i,r)) res = true;\n    if(abs(a[l] - a[r-1]) <= 1 && ok(l+1, r-1)) res = true;\n    return res;\n}\n\nint main(){\n    while(cin >> n && n){\n        rep(i, n) cin >> a[i];\n        memset(dp, -1, sizeof dp);\n        memset(dp2, 0, sizeof dp2);\n        dp2[0] = 0;\n        rep(i, n){\n            dp2[i+1] = max(dp2[i+1], dp2[i]);\n            for(int j = i + 2; j <= n; j += 2){\n                if(ok(i, j)) dp2[j] = max(dp2[j], dp2[i] + j - i);\n            }\n        }\n        cout << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[1000];\nint dp[300][300];\nint ans[300];\n\nint C(int lb, int ub) {\n\tif (dp[lb][ub] != -1)return dp[lb][ub];\n\tif (ub - lb <= 0)return dp[ub][lb] = 0;\n\telse if (ub - lb == 1) {\n\t\tif (abs(x[lb] - x[ub]) <= 1)return dp[lb][ub] = 2;\n\t\treturn dp[lb][ub] = 0;\n\t}\n\tint res = 0;\n\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\tif (C(lb + 1, ub - 1) == ub - lb - 1) {\n\t\t\tres = C(lb + 1, ub - 1) + 2;\n\t\t}\n\t}\n\tFOR(mid, lb, ub) {\n\t\tres = max(res, C(lb, mid) + C(mid + 1, ub));\n\t}\n\treturn dp[lb][ub] = res;\n}\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 300)rep(j, 300) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tcout << C(0, n - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst int INF = 1LL << 29;\n\nint main() {\n    int N, w[300];\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        for (int j = 0; j < N; ++j) cin >> w[j];\n\n        int dp[305][305];\n        for (int j = 0; j < N; ++j) {\n            fill(dp[j], dp[j]+N+1, 0);\n        }\n\n        for (int j = 0; j+1 < N; ++j) {\n            if (abs(w[j] - w[j+1]) <= 1) {\n                dp[j][j+2] = 2;\n            }\n        }\n\n        for (int d = 3; d <= N; ++d) {\n            for (int j = 0; j + d <= N; ++j) {\n                for (int k = 1; j+k < j+d; ++k) {\n                    dp[j][j+d] = max(dp[j][j+d], dp[j][j+k] + dp[j+k][j+d]);\n                }\n\n                if (dp[j+1][j+d-1] == d-2 && abs(w[j] - w[j+d-1]) <= 1) {\n                    dp[j][j+d] = d;\n                }\n            }\n        }\n\n        cout << dp[0][N] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, e) for (int i = (int)(s); i <= (int)(e); i++)\n#define printYesNo(is_ok) puts(is_ok ? \"Yes\" : \"No\");\n#define SORT(v) sort(v.begin(), v.end());\n#define RSORT(v) sort(v.rbegin(), v.rend());\n#define REVERSE(v) reverse(v.begin(), v.end());\n\nint solve(int N)\n{\n  vector<long long> daruma(N);\n  rep(i, N)\n  {\n    cin >> daruma[i];\n  }\n  vector<vector<long long>> dp(N, vector<long long>(N, 0));\n  for(int step = 1; step < N; step++)\n  {\n    rep(l, N)\n    {\n      int r = l + step;\n      if(r > N - 1)\n        continue;\n\n      if(dp[l + 1][r - 1] == r - l - 1 && abs(daruma[l] - daruma[r]) < 2)\n        dp[l][r] = r - l + 1;\n\n      for(int k = l; k < r; k++)\n      {\n        dp[l][r] = max(dp[l][r], dp[l][k] + dp[k + 1][r]);\n      }\n    }\n  }\n  \n  long long dst = 0;\n  rep(l, N) rep(r, N)\n  {\n    dst = max(dst, dp[l][r]);\n  }\n  return dst;\n}\n\nint main()\n{\n  while(true)\n  {\n    int N;\n    cin >> N;\n    if(N != 0)\n      cout << solve(N) << endl;\n    else\n      break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <math.h>\n\nusing namespace std;\n\ntemplate<typename T>\nlong long modpow(const T n,const T p,const T mod);\ntemplate<typename T>\nlong long modinv(const T n,const T mod);\ntemplate<typename T>\nbool chmax(T &a,const T &b);\ntemplate<typename T>\nbool chmin(T &a,const T &b);\n\nlong long inf=1000000007;\nlong long n;\nvector<long long> v;\nvector<vector<long long>> dp;\n\nlong long solve(long long l,long long r){\n\tif(r-l<=1) return 0;\n\tif(r-l==2){\n\t\tif(abs(v.at(l)-v.at(l+1))<=1) return 2;\n\t\telse return 0;\n\t}\n\n\tlong long &ret=dp.at(l).at(r);\n\tif(ret!=-1) return ret;\n\n\tif(abs(v.at(l)-v.at(r-1))<=1 && solve(l+1,r-1)==r-l-2) chmax(ret,r-l);\n\telse{\n\t\tfor(long long i=l+1;i<=r-1;i++){\n\t\t\tchmax(ret,solve(l,i)+solve(i,r));\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\tcin>>n;\n\twhile(n!=0){\n\t\tv.resize(n);\n\t\tfor(long long i=0;i<n;i++) cin>>v.at(i);\n\t\tdp.assign(n+1,vector<long long>(n+1,-1));\n\n\t\tcout<<solve(0,n)<<endl;\n\n\t\tcin>>n;\n\t}\n\n\treturn 0;\n}\n\ntemplate<typename T>\nlong long modpow(const T n,const T p,const T mod){\n\tif(p==0) return 1;\n\tif(p%2==0){\n\t\tlong long a=modpow(n,p/2,mod);\n\t\treturn a*a%mod;\n\t}\n\tif(p%2==1) return (modpow(n,p-1,mod)*n)%mod;\n\tcerr<<\"ERROR\"<<endl;\n\treturn 1;\n}\n\ntemplate<typename T>\nlong long modinv(const T n,const T mod){\n\treturn modpow(n,mod-2,mod);\n}\n\ntemplate<typename T>\nbool chmax(T &a,const T &b){\n\tif(a<b){\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<typename T>\nbool chmin(T &a,const T &b){\n\tif(a>b){\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\nwhile(1){\n  int n; cin >> n;\n  if(n == 0) break;\n  vector<int> w(n);\n  for(int i = 0; i < n; i++){\n    cin >> w[i];\n  }\n\n  vector< vector<int> > dp(301,vector<int> (301,-1));\n  function< int(int,int) > rec =\n  [&](int l,int r){\n    if(dp[l][r] != -1) return dp[l][r];\n\n    if(abs(l-r) <= 1) return 0LL;\n\n    int res = 0;\n    if(abs(w[l] - w[r-1]) <= 1 && rec(l+1,r-1) == (r-1)-(l+1)){\n      res = r - l;\n    }\n    for(int mid = l+1; mid < r; mid++){\n      res = max(res,rec(l,mid) + rec(mid,r));\n    }\n    return dp[l][r] = res;\n  };\n  cout << rec(0,n) << endl;\n}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n#define rep(i,a,b) for(int i = (a); i < (b); i++)\n \nbool take[310][310];\nint dp[310][310];\n \nsigned main() {\n    int n;\n    while(cin >> n, n) {\n        int w[310];\n        rep(i,0,n) cin >> w[i];\n        memset(take, false, sizeof(take));\n        memset(dp, 0, sizeof(dp));\n \n        rep(i,0,n) {\n            rep(j,0,n-i) {\n                int len = i+1;\n                int s = j, t = j+i;\n                rep(k,s,t) {\n                    if(take[s][k] && take[k+1][t]) take[s][t] = true;\n                }\n                if(len == 2) {\n                    if(abs(w[s] - w[t]) < 2) {\n                        take[s][t] = true;\n                    }\n                }\n                if(take[s][t]) {\n                    int x = s-1, y = t+1;\n                    while(1) {\n                        if(x < 0 || x >= n || y < 0 || y >= n) break;\n                        if(abs(w[x] - w[y]) >= 2) break;\n                        take[x][y] = true;\n                        x--; y++;\n                    }\n                }\n            }\n        }\n \n        rep(i,0,n) rep(j,i+1,n) {\n            if(take[i][j]) dp[i][j] = j-i+1;\n        }\n \n        rep(i,0,n) rep(j,i,n) rep(k,i,j) {\n            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    int w[n];\n    for(int i = 0; i < n; ++i)\n      cin >> w[i];\n    \n    int dp[n][n];\n    for(int i = 0; i < n; ++i){\n      fill(dp[i],dp[i]+n,0);\n    }\n    \n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(j+i+1 > n-1) break;\n\tif(dp[j+1][j+i] == i && abs(w[j]-w[j+i+1]) < 2){\n\t  dp[j][j+i+1] = dp[j+1][j+i] + 2;\n\t}else{\n\t  for(int k = 0; k <= i; ++k){\n\t    dp[j][j+i+1] = max(dp[j][j+i+1],dp[j][j+k]+dp[j+k+1][j+i+1]);\n\t  }\n\t}\n      }\n    }\n    //Debug\n    /*\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n      cout << dp[i][j] << \" \";\n      }\n      cout << endl;\n    }\n\n    */\n    cout << dp[0][n-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i,n,N) for(int i=(n); i<(N); i++)\n#define RREP(i,n,N) for(ll i=(N-1); i>=n; i--)\n#define CK(n,a,b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(),(v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define v2(T) vector<vector<T>>\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1e9+7;\nconst int inf=1e9;\n\nint dp[310][310];\nint n;\nint w[310];\nint main() {\n    while(cin>>n, n){\n        REP(i,0,n) REP(j,0,n) dp[i][j] = 0;\n        REP(i,0,n) cin>>w[i];\n        for(int k=1;k<n;k++){\n            REP(L,0,n-k){\n                int R = L + k;\n                if(dp[L+1][R-1] == k-1) dp[L][R] = max(dp[L][R], dp[L+1][R-1] + (abs(w[L]-w[R]) <= 1)*2);\n                dp[L][R] = max({dp[L][R], dp[L][L+1] + dp[L+2][R], dp[L][R-2] + dp[R-1][R]});\n            }\n        }\n        p(dp[0][n-1]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> w;\nvector<vector<int>> dp;\n\nint rec(int l, int r)\n{\n  if (~dp.at(l).at(r))\n  {\n    return dp.at(l).at(r);\n  }\n  if (l == r)\n  {\n    return dp.at(l).at(r) = 0;\n  }\n  if (l + 1 == r)\n  {\n    if (abs(w.at(l) - w.at(r)) <= 1)\n    {\n      return dp.at(l).at(r) = 2;\n    }\n    return dp.at(l).at(r) = 0;\n  }\n  int tmp = 0;\n  if (abs(w.at(l) - w.at(r)) <= 1 && rec(l + 1, r - 1) == r - l - 1)\n  {\n    tmp = r - l + 1;\n  }\n  for (int m = l; m < r; m++)\n  {\n    tmp = max(tmp, rec(l, m) + rec(m + 1, r));\n  }\n  return dp.at(l).at(r) = tmp;\n}\n\nint main()\n{\n  vector<int> ans;\n  while (1)\n  {\n    cin >> n;\n    if (!n)\n    {\n      break;\n    }\n    w.resize(n);\n    for (int i = 0; i < n; i++)\n    {\n      cin >> w.at(i);\n    }\n    dp.resize(n, vector<int>(n));\n    dp.assign(n, vector<int>(n, -1));\n    ans.push_back(rec(0, n - 1));\n  }\n  for (int i = 0; i < ans.size(); i++)\n  {\n    cout << ans.at(i) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n\n        if (n == 0) {\n            return 0;\n        }\n        vector<int> v;\n        for (int i = 0; i < n; ++i) {\n            int w;\n            cin >> w;\n            v.push_back(w);\n        }\n\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n        for (int l = 2; l <= n; ++l) {\n            for (int i = 0; i < n - l + 1; ++i) {\n                int j = i + l - 1;\n                if (dp[i + 1][j - 1] == j - i - 1 && abs(v[i] - v[j]) <= 1) {\n                    dp[i][j] = j - i + 1;\n                }\n                else {\n                    for (int k = i; k < j; ++k) {\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                    }\n                }\n            }\n        }\n        cout << dp[0][n - 1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\nint DFS(vector<int> &w, vector<bool> f, int n, unordered_set<vector<bool>> &s) {\n  int max = 0;\n  for (int i = 0; i < n; i++) {\n    if (f[i]) {\n      for (int j = i + 1; j < n; j++) {\n\tif (f[j]) {\n\t  if (abs(w[i] - w[j]) <= 1) {\n\t    f[i] = f[j] = false;\n\t    if (s.find(f) == s.end()) {\n\t      s.emplace(f);\n\t      int ret = DFS(w, f, n, s) + 2;\n\t      if (ret > max) {\n\t\tmax = ret;\n\t      }\n\t    }\n\t    f[i] = f[j] = true;\n\t  }\n\t  break;\n\t}\n      }\n    }\n  }\n  return max;\n}\n\nint main() {\n  vector<int> w(300);\n\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    vector<bool> f(n);\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n      f[i] = true;\n    }\n\n    unordered_set<vector<bool>> s;\n    cout << DFS(w, f, n, s) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing vpll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define debug(x) cerr << #x << \": \" << x << endl;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nll dp[330][330];\n\nint main() {\n    ll n;\n    while(cin >> n) {\n        if (n == 0) continue;\n\n        vll w(n);\n        rep(i, n) cin >> w[i];\n\n        rep(i, n) rep(j, n) dp[i][j] = 0;\n\n        for(ll len = 1; len < n; len++) {\n            rep(i, n) {\n                ll j = i + len;\n                if(j >= n) continue;\n\n                if(dp[i+1][j-1] == len-1 && abs(w[i] - w[j]) <= 1) dp[i][j] = len + 1;\n                for(ll k = i; k < j; k++) chmax(dp[i][j], dp[i][k] + dp[k+1][j]);\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<long double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n#define INF 1LL<<60\n\nint main() {\n    while(true) {\n        int N;\n        cin >> N;\n        if(N == 0) break;\n        vector<int> w(N);\n        REP(i, N) cin >> w[i];\n        vector< vector<int> > dp(N+5, vector<int>(N+5));\n\n        int ans = 0;\n        FOR(len, 1, N-1) {\n            // if(len%2==0) continue;\n            REP(i, N - len) {\n                if(i + len >= N) continue; \n                if(abs(w[i] - w[i+len]) <= 1 && (dp[i+1][i+len-1] == len - 1))\n                    dp[i][i+len] = max(dp[i][i+len], dp[i+1][i+len-1] + 2);\n                FOR(j, i, i+len) {\n                    // if((j-i)%2 == 1 && (i+len - (j+1)) % 2 == 1)\n                        dp[i][i+len] = max(dp[i][i+len], dp[i][j] + dp[j+1][i+len]);\n                }\n            }\n        }\n        ans = dp[0][N-1];\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dfs(int w[300],int n){\n  int b[300],maxx=0,a;\n /* for(int i=0;i<n;i++)\n    cout<<w[i]<<\" \";\n  cout<<endl;*/\n  if(n<2)\n    return 0;\n  if(n==2&&w[0]-w[1]<=1&&w[0]-w[1]>=-1)\n    return 2;\n  for(int i=0;i<n-1;i++){\n    if(w[i]-w[i+1]<=1&&w[i]-w[i+1]>=-1){\n      for(int j=0;j<n;j++){\n        if(j<i)\n          b[j]=w[j];\n        else if(j>i+1)\n          b[j-2]=w[j];\n      }\n      a=dfs(b,n-2)+2;\n      if(maxx<a)\n        maxx=a;\n    }\n  }\n  return maxx;\n}\n\nint main(){\n  int n,w[300],maxx;\n  cin>>n;\n  while(n!=0){\n    for(int i=0;i<n;i++)\n      cin>>w[i];\n    maxx=dfs(w,n);\n    cout << maxx<<endl;\n    cin>>n;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <cassert>\n#include <fstream>\n#include <iomanip>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll mod = 1e9 + 7;\n\nvector<string> g;\n\nvector<vector<ll>> dp;\n\nll search(ll i, ll j, const vector<ll>& w)\n{\n    if (i > w.size() - 1 || j > w.size() - 1)\n    {\n        return 0;\n    }\n    if (dp[i][j] > -1)\n    {\n        return dp[i][j];\n    }\n    if (i >= j)\n    {\n        return 0;\n    }\n    dp[i][j] = 0;\n    if (j - i == 1)\n    {\n        if (abs(w[i] - w[j]) <= 1)\n        {\n            dp[i][j] = 1;\n            return 1;\n        }\n    }\n    ll ret = max(search(i + 1, j, w), search(i, j - 1, w));\n    if (abs(w[i] - w[j]) <= 1 && (j - i) % 2)\n    {\n        ll cur = search(i + 1, j - 1, w);\n        if (2 * cur == j - i - 1)\n        {\n            ret = max(ret, cur + 1);\n        }\n    }\n    for (ll k = i + 1; k < j; ++k)\n    {\n        ret = max(ret, search(i, k, w) + search(k + 1, j, w));\n    }\n    dp[i][j] = ret;\n    return ret;\n}\n\n\nint main() {\n    \n    \n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n\n    while (1)\n    {\n        ll n;\n        cin >> n;\n        if (n == 0)\n        {\n            break;\n        }\n        vector<ll> w(n);\n        for (int i = 0; i < n; ++i)\n        {\n            cin >> w[i];\n        }\n        \n        dp = vector<vector<ll>>(n, vector<ll>(n, -1));\n        \n        ll ret = search(0, n - 1, w);\n        \n        cout << ret * 2 << endl;\n    }\n    \n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n#define DUMP(x) cout << #x << \": \" << x << endl\n\nint n;\nint memo[310][310] = { 0 };\nvector<int> w(n);\n\nint rec(int l, int r) {\n  if (r - 1 == l) {\n    return 0;\n  }\n  \n  if (r - l  - 1 == 1) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      return 2;\n    }\n  }\n\n  int ret = 0;\n  bool isOK = false;\n  \n  if (abs(w[l] - w[r - 1]) <= 1) {\n    isOK = true;\n  }\n\n\n  for (int t = l + 1; t < r - 1; t++) {\n    for (int k = t + 1; k < r; k++) {\n      int temp = rec(t, k) + rec(k, r);\n      ret = max(ret, ((isOK && temp == r - l - 2)? 2 : 0) + temp);   \n    }\n  }\n\n  for (int t = l + 1; t < r - 1; t++) {\n    int temp = rec(l, t) + rec(t, r);\n    ret = max(ret, ((isOK && temp == r - l)? 2 : 0) + temp);\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    w.clear();\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    cout << rec(0, n) << endl;\n\n  }\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tloc = div = 0;\n\t}\n\tint loc,div;\n};\n\nint N,maximum;\n\nvoid recursive(int table[],int num,int SIZE){\n\n\tmaximum = max(maximum,2*num);\n\n\tint max_chain = 0,tmp_chain,next_index = 0;\n\tInfo nextTable[SIZE];\n\n\tfor(int i = 1; i <= SIZE-1; i++){\n\t\tif(abs(table[i] - table[i-1]) <= 1){\n\t\t\tif(i == SIZE-1){\n\t\t\t\tif(max_chain == 0){\n\t\t\t\t\tnextTable[next_index].loc = SIZE-1;\n\t\t\t\t\tnextTable[next_index++].div = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttmp_chain = 0;\n\t\t\t\tfor(int k = 1;(i-1)-k>=0 && i+k <= SIZE-1;k++){\n\t\t\t\t\tif(abs(table[(i-1)-k] - table[i+k]) <= 1){\n\t\t\t\t\t\ttmp_chain++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp_chain > max_chain){\n\t\t\t\t\tmax_chain = tmp_chain;\n\t\t\t\t\tnext_index = 0;\n\t\t\t\t\tnextTable[next_index].loc = i;\n\t\t\t\t\tnextTable[next_index++].div = tmp_chain;\n\t\t\t\t}else if(tmp_chain == max_chain){\n\t\t\t\t\tnextTable[next_index].loc = i;\n\t\t\t\t\tnextTable[next_index++].div = tmp_chain;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(next_index == 0)return;\n\n\tfor(int i = 0; i < next_index;i++){ //?????????????????¨???????????¨???????????????????????????\n\t\tint work[SIZE],new_table[SIZE],next_size = 0;\n\t\tfor(int k = 0; k < SIZE; k++)work[k] = table[k];\n\t\twork[nextTable[i].loc-1] = -1;\n\t\twork[nextTable[i].loc] = -1;\n\n\t\tfor(int k = 1; k <= nextTable[i].div; k++){\n\t\t\twork[nextTable[i].loc-1-k] = -1;\n\t\t\twork[nextTable[i].loc + k] = -1;\n\t\t}\n\n\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\tif(work[k] != -1){\n\t\t\t\tnew_table[next_size++] = work[k];\n\t\t\t}\n\t\t}\n\t\trecursive(new_table,num+nextTable[i].div+1,next_size);\n\t}\n}\n\nvoid func(){\n\n\tint first[N];\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&first[i]);\n\n\tif(N == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}else if(N == 2){\n\t\tif(abs(first[0] - first[1] <= 1)){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\trecursive(first,0,N);\n\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\t\tmaximum = 0;\n\n\t\tfunc();\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[300][300];\nint w[300];\nint rec(int s,int t){\n  if(dp[s][t]!=-1)return dp[s][t];\n  if(s==t)return 0;\n  //if((t-s+1)%2)return max(rec(s,t-1),rec(s+1,t));\n  int ans=rec(s+1,t-1);\n  if(ans==t-s-1&&abs(w[s]-w[t])<=1)return dp[s][t]=ans+2;\n  for(int i=s;i<t;i++){\n    ans=max(ans,rec(s,i)+rec(i+1,t));\n  }\n  return dp[s][t]=ans;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    memset(w,0,sizeof(w));\n    for(int i=0;i<n;i++)cin>>w[i];\n    memset(dp,-1,sizeof(dp));\n    for(int i=1;i<n;i++)\n      dp[i-1][i]=(abs(w[i-1]-w[i])<=1?2:0);\n    cout<<rec(0,n-1)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint dp[301][301];\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        memset(dp, 0, sizeof(dp));\n        vector<int> v(n);\n        for(int i = 0; i < n; i++)  cin >> v[i];\n        for(int w = 2; w <= n; w++){\n            for(int i = 0; i < n; i++){\n                int j = i+w-1;\n                if(j >= n)  continue;\n                if(dp[i+1][j-1] == w-2 && abs(v[i]-v[j]) <= 1)  dp[i][j] = dp[i+1][j-1]+2;\n                for(int k = i; k < j; k++){\n                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j]);\n                }\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint main(){\n\n    while(1){\n\n        int n; cin >> n;\n        if(!n) break;\n        vector<int> w(n);\n        for(int i = 0; i < n; i++){\n            cin >> w[i];\n        }\n\n        vector<vector<bool> > take(n, vector<bool> (n, false));        //take[i][j] := 区間[i][j]を全消しできるかどうか\n\n        for(int k = 1; k < n; k++){\n            for(int i = 0; i + k < n; i++){\n                if(k == 1){\n                    take[i][i + k] = (abs(w[i] - w[i + k]) <= 1);\n                }else{\n                    take[i][i + k] = (take[i + 1][i + k - 1] && abs(w[i] - w[i + k]) <= 1);\n                \n                    for(int l = i + 1; l < i + k; l++){\n                        if(take[i][i + k]) break;\n                        take[i][i + k] = (take[i][l] && take[l][i + k]);\n                    }\n                }\n            }\n        }\n\n        vector<vector<int> > dp(n, vector<int> (n, 0));               //dp[i][j] := 区間 [i, j] において被覆できる頂点数の最大値\n\n        //初期化\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(take[i][j]) dp[i][j] = j - i + 1;\n            }   \n        }\n\n\n        for(int k = 2; k < n; k++){\n            for(int i = 0; i + k < n; i++){\n                for(int l = i + 1; l < i + k; l++){\n                    dp[i][i + k] = max(dp[i][i + k], dp[i][l] + dp[l + 1][i + k]);\n                }  \n            }\n        }\n\n        cout << dp[0][n - 1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\nconstexpr int MOD = 1000000007;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nconstexpr int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\nconstexpr int dy[] = {0, -1, 0, 1, 1, -1, -1, 1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){os << \"[\"; for (const auto &v : vec) {os << v << \",\"; } os << \"]\"; return os; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\n\nint dp[301][301];\n\nint solve(vector<int> &W) {\n    int N = W.size();\n    for(int i = 0; i < 301; i++) {\n        for(int j = 0; j < 301; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i <= N - 2; i++) {\n        dp[i][i + 2] = 2 * (abs(W[i] - W[i + 1]) <= 1);\n    }\n    for(int d = 3; d <= N; d++) {\n        for(int i = 0; i + d <= N; i++) {\n            int j = i + d;\n            int ma = (abs(W[i] - W[j - 1]) <= 1 && dp[i + 1][j - 1] == j - i - 2) ? j - i : 0;\n            for(int k = i + 1; k < j; k++) {\n                ma = max(ma, dp[i][k] + dp[k][j]);\n            }\n            dp[i][j] = ma;\n        }\n    }\n    return dp[0][N];\n}\n\nvoid solve() {\n    int N;\n    while(cin >> N, N) {\n        vector<int> W(N);\n        for(int i = 0; i < N; i++) cin >> W[i];\n        cout << solve(W) << endl;\n    }\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <random>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n\nusing namespace std;\nusing ll = long long;\n\nconst ll mod = 1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nconst int MAX_N = 350;\n\nint dp[MAX_N][MAX_N];\nbool enable[MAX_N][MAX_N];\n\nvoid solve(int& n) {\n  memset(dp, 0, sizeof(dp));\n  memset(enable, 0, sizeof(enable));\n  int w[MAX_N];\n  for(int i = 0; i < n; i++) cin >> w[i];\n\n  for(int width = 2; width <= n; width++) {\n    for(int left = 0; left < n; left++) {\n      int right = left + width;\n      if(n < right) continue;\n      if(dp[left + 1][right - 1] == width - 2 && abs(w[left] - w[right - 1]) <= 1) dp[left][right] = width;\n      for(int mid = left; mid <= right; mid++) {\n\tdp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid][right]);\n      }\n    }\n  }\n  cout << dp[0][n] << endl;\n  return ;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n) {\n    solve(n);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,b,e) for(int i=(b);i<(e);++i)\n#define rep(i,e) for(int i=0;i<(e);++i)\n\nint n, u, v;\nint w[310];\nint dp[310][310];\n\nint main() {\n  while(true){\n    cin>>n;\n    if(n==0) break;\n    rep(i,n)w[i]=0;\n    rep(i,n) cin>>w[i];\n\n    rep(i,310)rep(j,310)dp[i][j] = 0;\n    rep(i,n-1){\n      if(abs(w[i+1]-w[i])<=1) dp[i][i+1]=2;\n    }\n    REP(k,3,n+1){\n      rep(i,n-k+1){\n        if(dp[i+1][i+k-1]>1 && abs(w[i]-w[i+k])<=1) dp[i][i+k]=k+1;\n        rep(j,k){\n          if(dp[i][i+j]>1 && dp[i+j+1][i+k]>1){\n            dp[i][i+k]=k+1;\n          }\n        }\n      }\n    }\n    rep(i,n)REP(j,i+1,n)REP(k,i,j){\n      dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j]);\n    }\n    cout<<dp[0][n-1]<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 305;\n\nint dp[MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        vector<int> vec(n);\n        rep(i,n){\n            cin >> vec[i];\n        }\n        rep(i,n){\n            rep(j,n+1){\n                dp[i][j] = 0;\n            }\n        }\n        for(int i=2;i<=n;i++){\n            rep(j,n-i+1){\n                if(dp[j+1][j+i-1] == i-2 && abs(vec[j]-vec[j+i-1]) <= 1){\n                    dp[j][j+i] = i;\n                }\n                for(int k=j+1;k<j+i;k++){\n                    dp[j][j+i] = max(dp[j][j+i],dp[j][k]+dp[k][j+i]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef long long LL;\ntypedef priority_queue<int> PQ_DESC;\ntypedef priority_queue<int, vector<int>, greater<int>> PQ_ASC;\ntypedef priority_queue<PII> PQ_DESC_PII;\ntypedef priority_queue<PII, vector<PII>, greater<PII>> PQ_ASC_PII;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVLL> VVVLL;\n\n#define SORT_ASC(c) sort((c).begin(), (c).end())\n#define SORT_DESC(c) sort((c).begin(), (c).end(), greater<typeof((c).begin())>())\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define FORL(i,a,b) for(LL i=(a);i<(b);++i)\n#define REPL(i,n)  FORL(i,0,n)\n#define SIZE(a) int((a).size())\n#define ALL(a) (a).begin(),(a).end()\n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n //debug func\ntemplate<typename T>\nvoid vprint(vector<T> v) {\n    for(auto x : v) {\n        cerr << x << \" \";\n    }\n    cerr << endl;\n}\n \ntemplate<typename T>\nvoid vvprint(vector<vector<T>> vv) {\n    REP(i, SIZE(vv)) {\n        REP(j, SIZE(vv[i])) {\n            cerr << vv[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n}\n\ntemplate <typename Iterator>\ninline bool next_combination(const Iterator first, Iterator k, const Iterator last)\n{\n   /* Credits: Thomas Draper */\n   if ((first == last) || (first == k) || (last == k))\n      return false;\n   Iterator itr1 = first;\n   Iterator itr2 = last;\n   ++itr1;\n   if (last == itr1)\n      return false;\n   itr1 = last;\n   --itr1;\n   itr1 = k;\n   --itr2;\n   while (first != itr1)\n   {\n      if (*--itr1 < *itr2)\n      {\n         Iterator j = k;\n         while (!(*itr1 < *j)) ++j;\n         iter_swap(itr1,j);\n         ++itr1;\n         ++j;\n         itr2 = k;\n         rotate(itr1,j,last);\n         while (last != j)\n         {\n            ++j;\n            ++itr2;\n         }\n         rotate(k,itr2,last);\n         return true;\n      }\n   }\n   rotate(first,k,last);\n   return false;\n}\n\ninline double get_time_sec(void){\n    return static_cast<double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count())/1000000000;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    if(a > b) swap(a, b);\n    if(a == 0) return b;\n    else return gcd(b%a, a);\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return (a / gcd(a, b)) * b;\n}\n\ntemplate<typename T>\nmap<T, T> prime_list(T n) {\n    map<T, T> ret;\n    for(T i = 2; i*i <= n; i++) {\n        if(n % i == 0) {\n            ret[i] = 0;\n            while(n % i == 0) {\n                n /= i;\n                ret[i]++;\n            }\n        }\n    }\n    if(n != 1) ret[n]++;\n    return ret;\n}\n\n#define MOD 1000000007\n\nLL mypow(LL a, LL n) {\n    if(n == 1) return a % MOD;\n    if(n % 2 == 1) return (a * mypow(a, n-1)) % MOD;\n    LL t = mypow(a, n/2);\n    return (t * t) % MOD; \n}\n\nLL mycomb(LL n, LL k) {\n    if(n == 0 || n == k) return 1;\n    LL x = 1, y = 1;\n    REP(i, k) {\n        x = x * (n-i) % MOD;\n        y = y * (i+1) % MOD;\n    }\n    return x * mypow(y, MOD - 2) % MOD;\n}\n\nint main(void) {\n    while(1) {\n        int n;\n        cin >> n;\n        if(n == 0) return 0;\n        VI w(n);\n        REP(i, n) cin >> w[i];\n        VVI dp(n, VI(n, 0));\n        FOR(i, 1, n) {\n            REP(l, n) {\n                int r = l + i;\n                if(r >= n) continue;\n                if(i == 1) {\n                    if(abs(w[l] - w[r]) <= 1) dp[l][r] = 2;\n                } else {\n                    if(dp[l+1][r-1] == i - 1 && abs(w[l] - w[r]) <= 1) {\n                        dp[l][r] = i+1;\n                    } else {\n                        FOR(mid, l, r) {\n                            dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid+1][r]);\n                        }\n                    }\n                }\n\n            }\n        }\n        // vvprint(dp);\n        cout << dp[0][n-1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(a)  (a).begin(),(a).end()\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<long long, long long> Pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long>> vvll;\ntemplate <typename T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1LL << 30;\n\nll n;\nvll w(300);\nvvll dp(350, vll(350, -1));\nvll result(0);\n\nvoid reset(){\n  for(int i = 0; i < 350; i++){\n    for(int j = 0; j < 350; j++){\n      dp.at(i).at(j) = -1;\n    }\n  }\n}\n\nll func(ll a, ll b){ //[a, b)間で叩き出せる上限\n  if(dp.at(a).at(b) != -1) return dp.at(a).at(b);\n  if(b-a == 1) return dp.at(a).at(b) = 0;\n  if(b-a == 2){\n    if(abs(w.at(a)-w.at(b-1)) <= 1) return dp.at(a).at(b) = 2;\n    return 0;\n  }\n\n  if(func(a+1, b-1) == b-a-2 && abs(w.at(a)-w.at(b-1)) <= 1) return dp.at(a).at(b) = b-a;\n\n  ll ans = 0;\n  for(int i = a+1; i < b; i++){\n    chmax(ans, func(a, i) + func(i, b));\n  }\n  return dp.at(a).at(b) = ans;\n}\n\nint main(){\nwhile(true){\n  cin >> n;\n  if(n == 0) break;\n\n  reset();\n\n  for(int i = 0; i < n; i++){\n    cin >> w.at(i);\n  }\n\n  result.push_back(func(0, n));\n\n}\n\nfor(auto x: result) cout << x << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid daruma(pair<int, vector<int>> dataset)\n{\n  int n;\n  vector<int> w;\n  tie(n, w) = dataset;\n  vector<vector<int>> dp(n, vector<int>(n, 0));\n  for (int W = 2; W <= n; W++)\n  {\n    for (int l = 0; l < n; l++)\n    {\n      int r = l + W - 1;\n      if (r >= n)\n        continue;\n\n      if (dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r]) <= 1) {\n        dp[l][r] = W;\n      } else {\n        for (int mid = l; mid < r; mid++)\n        {\n          dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid + 1][r]);\n        }\n      }\n    }\n  }\n  cout << dp[0][n - 1] << endl;\n}\n\nint main()\n{\n  vector<pair<int, vector<int>>> dataset;\n  while (1)\n  {\n    int n;\n    cin >> n;\n    if (n < 1)\n      break;\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i)\n    {\n      cin >> w[i];\n    }\n    dataset.push_back(make_pair(n, w));\n  }\n  for (int i = 0; i < dataset.size(); ++i)\n  {\n    daruma(dataset.at(i));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\nusing namespace std;\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-10;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n\n\n//ここから編集\nint dp[310][310];\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n; \n  while(cin >> n, n){\n    vector<ll> w(n);\n    REP(i,n) cin >> w[i];\n\n    vector<vector<bool>> ok(n+1, vector<bool>(n+1, false)); //開区間 [i~j)消せますよの意\n    \n    vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\n\n\n    for(int i=2; i<=n; i++){\n      for(int j=0; j<n; j++){\n        if(j+i > n) break;\n        \n        if(dp[j+1][j+i-1] == i-2&& abs(w[j] - w[j+i-1]) <= 1) dp[j][j+i] = i;\n\n        for(int k=j+1; k<i+j; k++){\n          dp[j][i+j] = max(dp[j][i+j], dp[j][k] + dp[k][i+j]);\n        }\n      }\n    }\n    \n    cout << dp[0][n] << endl;\n  } \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\nusing namespace std;\ntypedef long long LL;\nconst int INF = 999999999;\n\nint dp[334][334];\nint w[334];\n\nint rec(int l, int r){\n    assert(l < r);\n    if(dp[l][r] >= 0) return dp[l][r];\n    if(r-l == 1) return dp[l][r] = 0;\n    int rm = (abs(w[r-1]-w[l]) <= 1 ? 2 : 0);\n    if(r-l == 2) return dp[l][r] = rm;\n    int ret = rec(l+1, r-1);\n    if(ret == r-l-2) ret += rm;\n    for(int mid=l+1; mid<r; mid++) {\n        ret = max(ret, rec(l, mid)+rec(mid, r));\n    }\n    return dp[l][r] = ret;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    while(n > 0){\n        memset(dp, -1, sizeof(dp));\n        rep(i, n) cin >> w[i];\n        cout << rec(0, n) << endl;\n\n        // rep(i, n+1){\n        //     rep(j, n+1) cout << dp[i][j] << \" \";\n        //     cout << endl;\n        // }\n        cin >> n;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n \nint main(){\n     \n    int n;\n    int w[500];\n    while(true){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n         \n        for(int i = 0; i < n; i++){\n            cin >> w[i];\n        }\n         \n        int DP[500][500] = {};\n         \n        for(int i = 2; i <= n; i += 2){\n            for(int j = 0; j <= n - i; j++){\n                DP[j][j + i - 1] = DP[j + 1][j + i - 2];\n                if((w[j] - w[j + i - 1]) * (w[j] - w[j + i - 1]) <= 1 && DP[j + 1][j + i - 2] == (i - 2) / 2){\n                    DP[j][j + i - 1]++;\n                }\n                for(int k = j + 1; k < j + i - 1; k += 2){\n                    DP[j][j + i - 1] = max(DP[j][j + i - 1], DP[j][k] + DP[k + 1][j + i - 1]);\n                }\n            }\n        }\n         \n        if(n % 2 == 1){\n            cout << max(DP[0][n - 2], DP[1][n - 1]) * 2 << endl;\n        }else{\n            cout << DP[0][n - 1] * 2 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename TYPE>\nvoid print_vec(const vector<TYPE>& v){\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n}\n\ntemplate <typename TYPE>\nvoid print_vec2(const vector<vector<TYPE>>& v){\n  cout << endl; cout << \"       \";\n  for(int i=0; i<v[0].size(); i++) cout << i << \"   \"; \n  cout << endl;\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << \"i=\" << i << \":   \";\n\t\tfor(int j=0; j<v[i].size(); j++){\n\t\t\tif(v[i][j] == 0) cout << \"\\x1B[0m\" << v[i][j] << \"   \";\n      else cout << \"\\x1B[31m\" << v[i][j] << \"   \";//https://stackoverrun.com/ja/q/12618775\n\t\t}\n\t\tcout << \"\\x1B[0m\" << endl;\n\t}\n}\n \nint chmax(int &a, int b) {return a = max(a, b);}\n\nint solve(int n){\n\tvector<int> block(n);\n\tfor(int i=0; i<n; i++) cin >> block[i];\n\n\t//dp[l][r]: 区間[l, r]考えた時，取り除けるブロックの最大個数\n\t//http://kutimoti.hatenablog.com/entry/2018/03/10/220819\n\tvector<vector<int>> dp(n+1, vector<int>(n+1, 0));\n\t//初期化は0でよい\n\n\n\tfor(int w=2; w<=n; w++){\n\t\tfor(int l=0; l+w<=n; l++){\n\t\t\tint r = l+w;\n\t\t\tif(dp[l+1][r-1]==w-2 && abs(block[l]-block[r-1])<=1) dp[l][r] = w;\n\t\t\tfor(int mid=l; mid<r; mid++){\n\t\t\t\tchmax(dp[l][r], dp[l][mid]+dp[mid][r]);\n\t\t\t}\n\t\t}\n\t}\n\t// cout << \" block: \"; print_vec(block);\n\t// print_vec2(dp);\n\treturn dp[0][n];\n}\n\nint main(){\n\t\n\tvector<int> ans;\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tans.push_back(solve(n));\n\t}\n\tfor(int i=0; i<ans.size(); i++) cout << ans[i] << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1000000007\n#define MAX 200000\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rept(i,k,n) for(int i = (k); i < (int)(n); i++)\n\nint main(){\n    while(1){\n        int n;cin>>n;\n        if(!n) return 0;\n        vector<int> w(n);\n        rep(i,n) cin>>w[i];\n        vector<vector<int> > dp(n,vector<int> (n,0));\n        rept(d,1,n){\n            rep(i,n-d){\n                int j=i+d;\n                if(dp[i+1][j-1] == d-1 && abs(w[i] - w[j]) <= 1) dp[i][j] = d+1;\n                else rept(k,i,j) dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nint N,maximum;\n\nvoid recursive(int table[],int num,int SIZE){\n\n\tmaximum = max(maximum,2*num);\n\n\tint max_chain = 0,tmp_chain,nextTable[SIZE/2],next_index = 0;\n\n\tfor(int i = 1; i <= SIZE-1; i++){\n\t\tif(abs(table[i] - table[i-1]) <= 1){\n\t\t\tif(i == SIZE-1){\n\t\t\t\tif(max_chain == 0){\n\t\t\t\t\tnextTable[next_index++] = SIZE-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttmp_chain = 0;\n\t\t\t\tfor(int k = 1;(i-1)-k>=0 && i+k <= SIZE-1;k++){\n\t\t\t\t\tif(abs(table[(i-1)-k] - table[i+k]) <= 1){\n\t\t\t\t\t\ttmp_chain++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp_chain > max_chain){\n\t\t\t\t\tmax_chain = tmp_chain;\n\t\t\t\t\tnext_index = 0;\n\t\t\t\t\tnextTable[next_index++] = i;\n\t\t\t\t}else if(tmp_chain == max_chain){\n\t\t\t\t\tnextTable[next_index++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(next_index == 0)return;\n\n\tfor(int i = 0; i < next_index;i++){\n\t\tint new_table[SIZE-2],next_size = 0;\n\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\tif(k != nextTable[i] && k != nextTable[i]-1){\n\t\t\t\tnew_table[next_size++] = table[k];\n\t\t\t}\n\t\t}\n\t\trecursive(new_table,num+1,next_size);\n\t}\n}\n\nvoid func(){\n\n\tint first[N];\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&first[i]);\n\n\tif(N == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}else if(N == 2){\n\t\tif(abs(first[0] - first[1] <= 1)){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\trecursive(first,0,N);\n\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\t\tmaximum = 0;\n\n\t\tfunc();\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint N, W[300], dp[300][300];\n \nint rec(int l, int r)\n{\n  if(l >= r) return (0);\n  if(~dp[l][r]) return (dp[l][r]);\n  int ret = 0;\n  if(abs(W[l] - W[r]) <= 1 && rec(l + 1, r - 1) == r - l - 1) ret = r - l + 1;\n  for(int m = l; m < r; m++) ret = max(ret, rec(l, m) + rec(m + 1, r));\n  return (dp[l][r] = ret);\n}\n \nint main()\n{\n  while(scanf(\"%d\", &N), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d\", &W[i]);\n    }\n    memset(dp, -1, sizeof(dp));\n    printf(\"%d\\n\", rec(0, N - 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// ref. http://tsutaj.hatenablog.com/entry/2017/03/07/173127\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\nll n;\nvector<ll> a;\n\nvoid solve() {\n  // dp[l][r] = dp[l+1][r-1] + 2 if dp[l+1][r-1] == d-2 && abs(a[l]-a[r]) <= 1\n  vector<vector<ll>> dp(n, vector<ll>(n));\n  vector<vector<ll>> take(n, vector<ll>(n));\n\n  for (ll d = 2; d <= n; ++d) { // dist\n    rep(l,n) {\n      ll r = l+d-1; // we consider [l,r]\n      if (r >= n) { continue; }\n      if (dp[l+1][r-1] == d-2 && abs(a[l]-a[r]) <= 1) {\n        chmax(dp[l][r], d);\n      }\n      for (ll k = l; k < r; ++k) {\n        chmax(dp[l][r], dp[l][k] + dp[k+1][r]);\n      }\n    }\n  }\n  cout << dp[0][n-1] << endl;\n}\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  while (true) {\n    cin >> n;\n    if (n == 0) { break; } // exit\n    a.resize(n);\n    rep(i,n) {\n      cin >> a[i];\n    }\n    solve();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <stdio.h>\nusing namespace std;\nint func(vector<int> w){\n    int s = w.size();\n    if(s>1){\n        int temp;\n        int min = s;\n        for(int i=0;i<s-1;i++){\n            vector<int> remain;\n            for(int j=0;j<s;j++){\n                if(j==i){j+=2;}\n                if(j>=s)break;\n                remain.push_back(w[j]);\n            }\n            if(!(abs(w[i]-w[i+1])>1)){\n                temp = func(remain);\n                min = min > temp ? temp : min;\n            }\n        }\n        return min;\n    } else {\n        return s;\n    }\n}\nvoid q_daruma(int n){\n    vector<int> w;\n    int t;\n    for(int i=0;i<n;i++){cin>>t;w.push_back(t);}\n    cout << w.size()-func(w) << \"\\n\";\n}\nint main(){\n    int n;\n    while(cin >> n, n!=0){\n        q_daruma(n);\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n;\nll w[301];\nll dp[301][301];\nbool f[301][301];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 301)rep(j, 301) {\n\t\t\tdp[i][j] = 0;\n\t\t\tf[i][j] = 0;\n\t\t}\n\t\trep(i, n)cin >> w[i];\n\t\tfor (int wid = 1; wid < n; wid += 2) {\n\t\t\trep(i, n) {\n\t\t\t\tif (i + wid >= n)continue;\n\t\t\t\tif (wid == 1) {\n\t\t\t\t\tif (abs(w[i] - w[i + wid]) <= 1) {\n\t\t\t\t\t\tdp[i][i + wid] = 2;\n\t\t\t\t\t\tf[i][i + wid] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (abs(w[i] - w[i + wid]) <= 1) {\n\t\t\t\t\t\tif (f[i + 1][i + wid - 1]) {\n\t\t\t\t\t\t\tdp[i][i + wid] = dp[i + 1][i + wid - 1] + 2;\n\t\t\t\t\t\t\tf[i][i + wid] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < i + wid; j += 2) {\n\t\t\t\t\t\tdp[i][i + wid] = max(dp[i][i + wid], (dp[i][j] + dp[j + 1][i + wid]));\n\t\t\t\t\t\tf[i][i + wid] |= (f[i][j] && f[j + 1][i + wid]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\trep(i, n) {\n\t\t\t//ll sum = 0;\n\t\t\tFOR(j, i + 1, n) {\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t\t//if (dp[i][j])sum += max(ans, (ll)(j - i + 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bits/stdc++.h>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(X, S, E) for (int(X) = (S); (X) < (E); ++(X))\n#define rrep(X, S, E) for (int(X) = (E)-1; (X) >= (S); --(X))\n#define arep(X, Y) for (auto(X) : Y)\n#define all(X) (X).begin(), (X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\n#define print(x) cout << x << endl\n#define printDouble(x) cout << fixed << setprecision(13) << x << endl\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing decendingQueue = priority_queue<ll, vl>;              //降順\nusing ascendingQueue = priority_queue<ll, vl, greater<ll>>; //昇順\n\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst int INT_INF = 1e9;\nconst ll LL_INF = 1e18;\nconst int mod = 1000000007;\n\ntemplate <class T> void mySort(vector<T> &X, bool isAscending) {\n  // 昇順\n  if (isAscending) {\n    sort(all(X));\n  } else {\n    // 降順\n    sort(all(X), greater<T>());\n  }\n}\n\nlong long gcd(long long m, long long n) {\n  if (m < n)\n    return gcd(n, m);\n  if (n == 0)\n    return m;\n  return gcd(n, m % n);\n}\n\nlong long lcm(long long m, long long n) {\n  // m * nでlong型のオーバフローを発生させないため、先に割り算から行う\n  return m * (n / gcd(m, n));\n}\n\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x = 0) : x((x % mod + mod) % mod) {}\n  mint &operator+=(const mint a) {\n    if ((x += a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator-=(const mint a) {\n    if ((x += mod - a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res += a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res -= a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const {\n    if (!t)\n      return 1;\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1)\n      a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod - 2); }\n  mint &operator/=(const mint a) { return (*this) *= a.inv(); }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res /= a;\n  }\n};\n\n// combination mod prime\n// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n) : fact(n + 1), ifact(n + 1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i)\n      ifact[i - 1] = ifact[i] * i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n)\n      return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n  }\n};\n\nvector<long long> SieveOfEratosthenes(int max) {\n  vector<long long> sieve;\n  vector<long long> primes;\n\n  for (int i = 1; i < max + 1; ++i) {\n    sieve.push_back(i);\n  }\n\n  sieve[0] = 0;\n  for (int i = 2; i < max + 1; ++i) {\n    if (sieve[i - 1] != 0) {\n      primes.push_back(sieve[i - 1]);\n      for (int j = 2 * sieve[i - 1]; j < max + 1; j += sieve[i - 1]) {\n        sieve[j - 1] = 0;\n      }\n    }\n  }\n  return primes;\n}\n\nclass UnionFindTree {\nprivate:\n  vector<int> par;\n  vector<int> rnk;\n  vector<int> siz;\n\npublic:\n  UnionFindTree(int n) {\n    par.assign(n, -1);\n    rnk.assign(n, -1);\n    siz.assign(n, -1);\n\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rnk[i] = 0;\n      siz[i] = 1;\n    }\n  }\n\n  int find(int x) {\n    if (par[x] == x)\n      return x;\n    else\n      return par[x] = find(par[x]);\n  }\n\n  bool same(int x, int y) { return find(x) == find(y); }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return;\n    if (rnk[x] < rnk[y]) {\n      par[x] = y;\n      siz[y] += siz[x];\n    } else {\n      par[y] = x;\n      siz[x] += siz[y];\n      if (rnk[x] == rnk[y])\n        ++rnk[x];\n    }\n  }\n\n  int size(int x) {\n    x = find(x);\n    return siz[x];\n  }\n};\n\nclass Edge {\npublic:\n  ll from;\n  ll to;\n  ll cost;\n\n  Edge() {}\n  Edge(ll from, ll to, ll cost) {\n    this->from = from;\n    this->to = to;\n    this->cost = cost;\n  }\n\n  bool operator<(const Edge &edge) const {\n    return cost < edge.cost; //昇順\n  }\n};\n\nclass Graph {\npublic:\n  ll nodes; // ノード数\n  vector<Edge> edges;\n\n  Graph() {}\n  Graph(ll nodes) { this->nodes = nodes; }\n  void addEdge(ll from, ll to, ll cost) {\n    this->edges.push_back(Edge(from, to, cost));\n  }\n};\n\n// クラスカル法\n// 連結グラフの最小全域木を求める\nclass Kruskal {\nprivate:\n  Graph graph;\n  vector<Edge> MinimumSpanningTree;\n  ll minimumCost;\n  void searchMinimumSpanningTree() {\n    UnionFindTree uf(graph.nodes);\n    sort(all(graph.edges));\n    for (auto edge : graph.edges) {\n      if (!uf.same(edge.from, edge.to)) {\n        uf.unite(edge.from, edge.to);\n        MinimumSpanningTree.push_back(edge);\n      }\n    }\n  }\n\npublic:\n  Kruskal(Graph graph) { this->graph = graph; }\n  ll getMinimumSpanningTreeCost() {\n    searchMinimumSpanningTree();\n    ll cost = 0;\n    for (auto tr : MinimumSpanningTree) {\n      cost += tr.cost;\n    }\n    return cost;\n  }\n};\n\n// ダイクストラ法 O((E+V)logV)\n// 最小経路問題を解くためのアルゴリズム。辺の重みに負数を含む場合は利用不可\n// 無向グラフの場合はコメントアウト箇所をコメントイン\nclass Dijkstra {\nprivate:\n  Graph graph;\n  map<ll, vector<Edge>> fromPaths;\n  vl distances;\n  vl srcs;\n\npublic:\n  Dijkstra(Graph graph) {\n    this->graph = graph;\n    for (auto edge : graph.edges) {\n      fromPaths[edge.from].push_back(edge);\n      // fromPaths[edge->to].push_back(Edge(edge->to, edge->from, edge->cost));\n    }\n  }\n  void searchMinimumPathFrom(ll src) {\n    // 複数回呼ばれる度に計算する\n    distances = vl(graph.nodes + 1, LL_INF);\n    srcs = vl(graph.nodes + 1, LL_INF);\n\n    // 距離が近い順番に捜査していく\n    priority_queue<pll, vector<pll>, greater<pll>> pq;\n    distances[src] = 0;\n    srcs[src] = -1;\n\n    pq.push(mp(0ll, src));\n    while (!pq.empty()) {\n      int u = pq.top().second;\n      double uw = pq.top().first;\n      pq.pop();\n\n      if (distances[u] < uw) {\n        continue;\n      };\n\n      for (auto edge : fromPaths[u]) {\n        int v = edge.to;\n        ll w = edge.cost;\n        if (distances[v] > distances[u] + w) {\n          distances[v] = distances[u] + w;\n          srcs[v] = u;\n          pq.push(mp(distances[v], v));\n        }\n      }\n    }\n  };\n  ll getDistance(ll n) { return distances[n]; }\n  ll getFrom(ll n) { return srcs[n]; }\n};\n\n// ベルマンフォード O(|V||E|)\n// 負コストが含まれていても最短経路問題を解くためのアルゴリズム。閉路の検出も可能\n// 有向グラフ\nclass BellmanFord {\nprivate:\n  Graph graph;\n  // 閉路が含まれるかは個々のノードごとに管理する必要あり\n  vector<bool> hasNegativeCycles;\n  vector<ll> distances;\n  vl srcs;\n\npublic:\n  BellmanFord(Graph graph) {\n    ll nodes = graph.nodes + 1;\n\n    this->graph = graph;\n    distances = vector<ll>(nodes, LL_INF);\n    hasNegativeCycles = vector<bool>(nodes, false);\n  }\n  void searchMinimumPathFrom(ll src) {\n    distances[src] = 0;\n\n    for (ll i = 0; i < graph.nodes - 1; i++) {\n      for (auto edge : graph.edges) {\n        ll u = edge.from;\n        ll v = edge.to;\n        ll w = edge.cost;\n        if (distances[u] != LL_INF) {\n          chmin(distances[v], distances[u] + w);\n        }\n      }\n    }\n\n    for (auto edge : graph.edges) {\n      ll u = edge.from;\n      ll v = edge.to;\n      ll w = edge.cost;\n      if (distances[u] == LL_INF) {\n        continue;\n      }\n      if (distances[u] + w < distances[v]) {\n        hasNegativeCycles[v] = true;\n      }\n    }\n\n    for (ll i = 0; i < graph.nodes; i++) {\n      for (auto edge : graph.edges) {\n        ll u = edge.from;\n        ll v = edge.to;\n        ll w = edge.cost;\n        if (distances[u] == LL_INF) {\n          continue;\n        }\n        chmin(distances[v], distances[u] + w);\n        if (hasNegativeCycles[u] == true) {\n          hasNegativeCycles[v] = true;\n        }\n      }\n    }\n  }\n  ll getDistance(ll n) { return distances[n]; }\n  bool hasNegativeCycle(ll n) { return hasNegativeCycles[n]; }\n  ll getFrom(ll n) { return srcs[n]; }\n};\n\n// O(V^3) 有向グラフ\nclass WarshallFloyd {\nprivate:\n  Graph graph;\n  int nodes = this->graph.nodes + 1;\n  vector<vector<ll>> distances;\n\npublic:\n  WarshallFloyd(Graph graph) {\n    this->graph = graph;\n    nodes = this->graph.nodes + 1;\n    this->distances = vector<vector<ll>>(nodes, vector<ll>(nodes, LL_INF));\n    for (auto edge : graph.edges) {\n      int from = edge.from;\n      int to = edge.to;\n      int cost = edge.cost;\n      distances[from][to] = cost;\n    }\n  }\n  void searchMinimumPath() {\n    for (int k = 0; k < nodes; k++) {\n      for (int i = 0; i < nodes; i++) {\n        for (int j = 0; j < nodes; j++) {\n          if (distances[i][k] == LL_INF || distances[k][j] == LL_INF) {\n            continue;\n          }\n          if (distances[i][k] + distances[k][j] < distances[i][j]) {\n            distances[i][j] = distances[i][k] + distances[k][j];\n          }\n        }\n      }\n    }\n  }\n  ll getDistance(int from, int to) { return distances[from][to]; }\n};\n\ntemplate <typename T> class SegmentTree {\n  int n = 1; // 最下段のノード数. ただし、2の冪乗\n  vector<T> data;\n\n  T init;                      // 初期値\n  function<T(T, T)> mergeFunc; // 子ノードのmerge方法\n\npublic:\n  SegmentTree(int N, function<T(T, T)> _mergeFunc, T _init) {\n    mergeFunc = _mergeFunc;\n    init = _init;\n\n    while (n < N) {\n      n *= 2;\n    }\n\n    data = vector<T>(n * 2 - 1, _init); // 2の冪乗で確保が必要\n  }\n\n  // i番目の値(0-indexed)をxに変更\n  // O(logN)\n  void update(int i, T v) {\n    // 葉のノード\n    i += n - 1;\n    data[i] = v;\n\n    // 親も更新\n    while (i > 0) {\n      i = (i - 1) / 2; //親のindex\n      data[i] =\n          mergeFunc(data[i * 2 + 1], data[i * 2 + 2]); //親から見た子のindex\n    }\n  }\n\n  // i番目の値を返却\n  T get(int i) { return data[i + n - 1]; }\n\n  // [a, b)のmergeFuncを求めるクエリ\n  // ノードk（空間[l, r)が担当）が答える. ノード0の根から探索する\n  // 呼び出しはquery(a, b). その他の引数は再帰処理のため\n  // O(logN)\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    // 最初の呼び出し\n    if (r < 0) {\n      return query(a, b, k, l, n);\n    }\n\n    // 区間が被らない場合\n    if (r <= a || b <= l) {\n      return init;\n    }\n\n    // 完全に含む場合\n    if (a <= l && r <= b) {\n      return data[k];\n    }\n\n    // 部分的に含む場合. 子ノードに聞く\n    T left = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T right = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n    return mergeFunc(left, right);\n  }\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    vi w(n);\n    if (n == 0) {\n      return 0;\n    }\n    rep(i, 0, n) { cin >> w[i]; }\n\n    // [i, j]までのブロックで取り除ける最大のブロック数\n    vector<vi> dp(n, vi(n, 0));\n    rep(d, 2, n + 1) { // 幅：小さい順番に\n      rep(l, 0, n) {\n        int r = l + d - 1;\n        if (r >= n) {\n          break;\n        }\n\n        if (l + 1 < n && (dp[l + 1][r - 1] == d - 2) && abs(w[l] - w[r]) <= 1) {\n          dp[l][r] = d;\n        }\n        rep(m, l, r) { chmax(dp[l][r], dp[l][m] + dp[m + 1][r]); }\n      }\n    }\n    print(dp[0][n - 1]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n#define DUMP(x) cout << #x << \": \" << x << endl\n\nint n;\nint memo[310][310] = { false };\nvector<int> w(n);\n\nint rec(int l, int r) {\n  if (r - l == 0) {\n    return memo[l][r] = 2;\n  }\n  if (r - l == 1) {\n    return memo[l][r] = 1;\n  }\n  \n  if (r - l  - 1 == 1) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      return memo[l][r] = 2;\n    }\n  }\n  if (memo[l][r]) {\n    return memo[l][r];\n  }\n\n  for (int t = l + 1; t < r; t++) {\n    int temp  = rec(l, t);\n    int temp2 = rec(t, r);\n    int temp3 = rec(l + 1, t);\n    int temp4 = rec(t, r - 1);\n    \n    if (temp == 2 && temp2 == 2) {\n      return memo[l][r] = 2;\n    }\n    if (abs(w[l] - w[r - 1]) <= 1 && temp3 == 2 && temp4 == 2) {\n      return memo[l][r] = 2;\n    }\n  }\n\n  return memo[l][r] = 1;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    w.clear();\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n    memset(memo, 0, sizeof(memo));\n\n    cerr << \" \" << rec(0, n) << endl;\n\n    int dp[310] = { 0 };\n    dp[0] = 0;\n\n    for (int r = 0; r <= n; r++) {\n      dp[r] = dp[r - 1];\n      for (int l = 0; l < r; l++) {\n        if (memo[l][r] == 2) {\n          dp[r] = max(dp[r], dp[l] + (r - l));\n        }\n      }\n    }\n    \n\n    cout << dp[n] << endl;\n\n  }\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\twhile (N) {\n\t\tvector<int>num(N);\n\t\tfor (int i = 0; i < N; i++)cin >> num[i];\n\t\tvector<vector<int>>dp(N, vector<int>(N,0));\n\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\tif (abs(num[i] - num[i + 1]) < 2)dp[i][i + 1] = 2;\n\t\t}\n\t\tfor (int i = 4; i <= N; i += 2) {\n\t\t\tfor (int j = 0; i + j <= N; j++) {\n\t\t\t\tif (dp[j][i + j - 3] && dp[i + j - 2][i + j - 1]) {\n\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t}\n\t\t\t\tif (dp[j + 1][i + j - 2] && abs(num[j] - num[i + j - 1]) < 2) {\n\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t}\n\t\t\t\t//cout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t}\n\t\t}\n\t\tvector<int>ret(N,0);\n\t\tret[1] = dp[0][1];\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tret[i] = dp[0][i];\n\t\t\tfor (int j = i - 1; j >= 1; j--) {\n\t\t\t\tret[i] = max(ret[i], ret[j - 1] + dp[j][i]);\n\t\t\t}\n\t\t}\n\t\tcout << ret[N - 1] << endl;\n\t\tcin >> N;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\tfor(auto &e:u) fill_v<T>(e,v...);\n}\n\nauto dp = make_v<int>(1, 1);\nvector<int> w;\n\nint dfs(int l, int r) {\n  if (~dp[l][r]) return dp[l][r];\n  if (r - l <= 1) return 0;\n\n  int &res = dp[l][r];\n  res = 0;\n  for (int i = l; i <= r; i++) {\n    res = max(res, dfs(l, i) + dfs(i, r));\n  }\n  if (abs(w[l] - w[r-1]) <= 1 and dfs(l+1, r-1) == r - l - 2)\n    res = max(res, r-l);\n\n  return res;\n}\n\nint main() {\n  int n;\n  while (cin >> n && n) {\n    w = vector<int>(n);\n    REP(i, n) cin >> w[i];\n\n    dp = make_v<int>(n+1, n+1);\n    fill_v<int>(dp, -1);\n\n    cout << dfs(0, n) << endl;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<int> w(n);\n        for(int i=0;i<n;i++) cin>>w[i];\n        vector<vector<int> > dp(400,vector<int>(400,0));//dp[i][j]:=i~j??????????????????\n        vector<vector<int> > res(400,vector<int>(400,0));\n        for(int i=0;i<n-1;i++) if(abs(w[i]-w[i+1])<=1){\n            dp[i][i+1]=1;\n        }\n        for(int i=4;i<=n;i+=2){\n            for(int j=0;j+i<=n;j++){\n                if(dp[j+1][j+i-2] && abs(w[j]-w[j+i-1])<=1){\n                    dp[j][j+i-1]=1;\n                    continue;\n                }\n                for(int k=2;k<i;k+=2){\n                    if(dp[j][j+k-1] && dp[j+k][j+i-1]){\n                        dp[j][j+i-1]=1;\n                        break;\n                    }\n                }\n            }        \n        }\n        for(int i=0;i<n;i++)for(int j=0;j<n;j++)if(dp[i][j]){\n            res[i][j]=j-i+1;\n        }\n        for(int k=0;k<n-1;k++){\n            for(int i=0;i<=k;i++){\n                for(int j=k+1;j<n;j++){\n                    res[i][j]=max(res[i][j],res[i][k]+res[k+1][j]);\n                }\n            }\n        }\n        cout<<res[0][n-1]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nsigned main(){\n    // cout << fixed << setprecision(10) << flush;\n\n    vector<int> ans;\n    int n;\n    cin >> n;\n    while(n != 0){\n        vector<int> w(n);\n        for(int i=0; i<n; i++){\n            cin >> w[i];\n        }\n    \n\n        // 閉区間 [i, j] じゃなくて半開区間 [i, j) の方が便利そう？\n        // dp[i][i] = 0, dp[i][i+1] = 1\n        // 場合分け\n        // どこかで二分割できて、それぞれの和になっている\n        // dp[i][j] = min_{i+1 <= k <= j-1} (dp[i][k] + dp[k][j])\n        // 真ん中がすっぽ抜けて、一番上と一番下が打ち消しあう\n        // if(dp[i+1][j-1] == 0 && abs(w[i] - w[j-1])){\n        //     dp[i][j] = 0;\n        // }\n\n        int INF = 1<<30;\n        // dp[i][j] は [i, j) で残る個数の最小\n        vector<vector<int>> dp(n+1, vector<int>(n+1, INF));\n        for(int i=0; i<n; i++){\n            dp[i][i] = 0;\n            dp[i][i+1] = 1;\n        }\n        dp[n][n] = 0;\n\n        for(int width=2; width<=n; width++){\n            for(int i=0; i+width<=n; i++){\n                int j = i + width;\n                if(dp[i+1][j-1] == 0 && abs(w[i] - w[j-1]) <= 1){\n                    dp[i][j] = 0;\n                }\n                else{\n                    for(int k=i+1; k<=j-1; k++){\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n                    }\n                }\n            }\n        }\n\n        ans.push_back(n - dp[0][n]);\n    \n        cin >> n;\n    }\n\n    for(int i=0; i<ans.size(); i++){\n        cout << ans[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[100];\nint dp[300][300];\n//int ans[300];\n\n//bool C(int lb, int ub) {\n//\t//cout << lb << \" \" << ub /*<< dp[lb][ub]*/ << endl;\n//\tif (dp[lb][ub] != -1)return dp[lb][ub];\n//\tif (ub - lb <= 0)return dp[ub][lb] = 0;\n//\telse if (ub - lb == 1) {\n//\t\tif (abs(x[lb] - x[ub]) <= 1)return dp[lb][ub] = 1;\n//\t}\n//\tdp[lb][ub] = 0;\n//\tif (abs(x[lb] - x[ub]) <= 1) {\n//\t\tdp[lb][ub] |= C(lb + 1, ub - 1);\n//\t}\n//\tFOR(mid, lb, ub) {\n//\t\t//cout << \"!\" << lb << \" \" << mid << endl;\n//\t\t//cout << \"!\" << mid << \" \" << ub << endl;\n//\t\tbool f = C(lb, mid);\n//\t\tf &= C(mid + 1, ub);\n//\t\tdp[lb][ub] |= f;\n//\t}\n//\treturn dp[lb][ub];\n//}\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 300)rep(j, 300) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\trep(j, n) {\n\t\t\t\tint lb = j, ub = j + i;\n\t\t\t\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\t\t\t\tif (i == 1)dp[lb][ub] = 1;\n\t\t\t\t\telse dp[lb][ub] |= dp[lb + 1][ub - 1];\n\t\t\t\t}\n\t\t\t\tFOR(mid, lb + 1, ub - 1) {\n\t\t\t\t\tdp[lb][ub] |= dp[lb][mid] && dp[mid + 1][ub];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << dp[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tint ans = 0;\n\t\trep(i, n) {\n\t\t\t//if (i >= 1)ans[i] = ans[i - 1];\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tnum = max(num, j - i + 1);\n\t\t\t\t\tpos = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += num;\n\t\t\ti = pos;\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << ans[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll ,P> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nint n;\nint dp[500][500];\nvector<int> w;\n\n// [l,r)\nint rec(int l, int r){\n    if(dp[l][r] >= 0) return dp[l][r];\n    if(r-l<2) return 0;\n\n    int res = 0;\n    res = max(res, rec(l,r-2)+(abs(w[r-2]-w[r-1])<=1?2:0));\n    res = max(res, rec(l+2,r)+(abs(w[l]-w[l+1])<=1?2:0));\n    if(rec(l+1,r-1) == r-l-2){\n        res = max(res, r-l-2+(abs(w[l]-w[r-1])<=1?2:0));\n    }\n    else{\n        res = max(res, rec(l+1,r-1));\n    }\n    for(int i=1;i<r-l;i++){\n        res = max(res, rec(l,l+i)+rec(l+i,r));\n    }\n    return dp[l][r] = res;\n}\n\nint main() {\n    while(cin >> n, n){\n        w.resize(n);\n        REP(i,n){\n            cin >> w[i];\n        }\n        REP(i,n+1) fill(dp[i],dp[i]+n+1,-1);\n        cout << rec(0,n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\n//const int dx[] = {-1, 0, 1, 0};\n//const int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\n//vector<T> DIVISOR(T n) {\n//    vector<T> v;\n//    for (int i = 1; i * i <= n; ++i) {\n//        if (n % i == 0) {\n//            v.push_back(i);\n//            if (i != n / i) {\n//                v.push_back(n / i);\n//            }\n//        }\n//    }\n//    sort(v.begin(), v.end());\n//    return v;\n//}\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\nint main() {\n\n\n\n    while (true) {\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        vector<int> w(N);\n        for (int i = 0; i < N; i++) cin >> w[i];\n\n        //take[i][j]区間i~jが取れるかどうか\n        //i-1番目とj+1番目の差が1以下ならtake[i-1][j+1]もとれる\n        //take[i][k] take[k+1][j]がtrueならtake[i][j]もtrue\n        vector<vector<bool>> take(310, vector<bool>(310, false));\n\n\n        //dp[i][j]\n        //区間[i,j]において、被覆できる頂点数の最大値\n        vector<vector<int>> dp(310, vector<int>(310, 0));\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N - i; j++) {\n                int len = i + 1;\n                int s = j;\n                int t = j + i;\n\n\n                for (int k = s; k < t; k++) {\n                    if (take[s][k] && take[k + 1][t]) take[s][t] = true;\n                }\n\n                if (len == 2) {\n                    if (ABS(w[s] - w[t]) < 2) {\n                        take[s][t] = true;\n                    }\n                }\n\n                if (take[s][t]) {\n                    int x = s - 1;\n                    int y = t + 1;\n                    while (true)\n                    {\n                        if (x < 0 || x >= N || y < 0 || y >= N) break;\n                        if (ABS(w[x] - w[y]) >= 2) break;\n                        take[x][y] = true;\n                        x--;\n                        y++;\n                    }\n                }\n\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (take[i][j]) {\n                    dp[i][j] = j - i + 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < N-2; i++) {\n            for (int j = i; j < N; j++) {\n                for (int k = i; k < j; k++) {\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                }\n            }\n        }\n\n        cout << dp[0][N - 1] << endl;\n\n    }\n    return 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nbool ok(int a, int b) {\n\treturn abs(a - b) <= 1;\n}\n\nvector<vector<int>>memo(1000, vector<int>(1000,-1));\n\nint solve(const int l,const int r, vector<int>&v) {\n\tif (memo[l][r] != -1)return memo[l][r];\n\tif (l == r)return 0;\n\telse {\n\t\tif (l + 1 == r)return 0;\n\t\telse if (l + 2 == r) {\n\t\t\tif (ok(v[l],v[l+1]))return 2;\n\t\t\telse return 0;\n\t\t}\n\t\telse {\n\t\t\tint ans = 0;\n\t\t\tfor (int k = l + 1; k < r - 1; ++k) {\n\t\t\t\tans = max(ans, solve(l, k, v) + solve(k, r, v));\n\t\t\t}\n\t\t\tif (ok(v[l], v[r - 1]) && solve(l + 1, r - 1, v) == (r - l - 2)) {\n\t\t\t\tans = r - l;\n\t\t\t}\n\t\t\treturn memo[l][r]=ans;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tmemo = vector<vector<int>>(1000, vector<int>(1000, -1));\n\t\tint N; cin >> N;\n\t\tvector<int>v(N);\n\t\tfor (int i = 0; i < N; ++i)cin >> v[i];\n\t\tif (!N)break;\n\t\tint ans = solve(0, N, v);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define rep(i, a, n) for(int i = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int i = (int)(a);(i) <= (int)(n);++(i))\n#define repif(i, a, x) for(int i = (int)(a);(x);++(i))\n#define repr(i, a, n) for(int i = ((int)(a)-1);(i) >= (int)(n);--(i))\n#define reper(i, a, n) for(int i = (int)(a);(i) >= (int)(n);--(i))\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define CEIL(x) ((int)ceil(((double)x)))\n#define POW(x, y) ((int)pow(x, y))\n#define UNIQUE(x) (x).erase(unique(ALL((x))), end(x))\n#define gcd(x, y) __gcd(x, y)\n#define lcm(x, y) ((x)/gcd(x,y)*(y))\n#define isin(x, l, r) ((l) <= (x) and (x) < (r))\n#define fcout(n) cout << fixed << setprecision(n)\n#define rcout(n) cout << right << setw(n)\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define PI (acosl(-1))\n#define EPS (1e-10)\n#define INF LLONG_MAX\n#define INF32 INT32_MAX\n#define MOD 1000000007LL\nusing namespace std;\nusing VI = vector<int>;\nusing VVI = vector<vector<int>>;\nusing PII = pair<int, int>;\nusing TIII = tuple<int, int, int>;\nusing VPII = vector<pair<int, int>>;\nusing VTIII = vector<tuple<int, int, int>>;\nusing Complex = complex<double>;\ntemplate<typename T, template<typename> typename C = less> using PQ = priority_queue<T, vector<T>, C<T>>;\ntemplate<typename T> inline bool chmax(T& a, const T& b, bool t = false){ if(a<b or (t and a == b)){ a=b; return true; } return false; }\ntemplate<typename T> inline bool chmin(T& a, const T& b, bool t = false){ if(a>b or (t and a == b)){ a=b; return true; } return false; }\n\n\nint rec(int l, int r, VVI& mem, const VI& w){\n    if(r-l <= 1) return 0;\n    int& res = mem[l][r];\n    if(res != -1) return res;\n    rep(i, l+1, r) chmax(res, rec(l, i, mem, w)+rec(i, r, mem, w));\n    if(rec(l+1, r-1, mem, w) == r-1-l-1){\n        if(abs(w[l]-w[r-1]) < 2) chmax(res, rec(l+1, r-1, mem, w)+2);\n        else chmax(res, rec(l+1, r-1, mem, w));\n    }\n    return res;\n}\n\n\nsigned main(){\n    int n;\n    while(cin >> n, n){\n        VI w(n);\n        rep(i, 0, n) cin >> w[i];\n        VVI mem(n+1, VI(n+1, -1));\n        cout << rec(0, n, mem, w) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<int>v(n);\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\n        for(int i=0;i<n;++i){\n            cin>>v[i];\n        }\n        for(int l=2;l<=n;++l){\n            for(int i=0;i+l<n+1;++i){\n                if(abs(v[i]-v[i+l-1]) < 2 && dp[i+1][i+l-1]==l-2)dp[i][i+l]=l;\n                for(int j=1;j<l;++j){\n                    dp[i][i+l]=max(dp[i][i+j]+dp[i+j][i+l],dp[i][i+l]);\n                }\n            }\n        }\n        cout<<dp[0][n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n;\n    while (cin >> n && n){\n        VI a(n);\n        REP(i,n) cin >> a[i];\n        VVI dp(n, VI(n+1));\n        REP(i,n-1) if (abs(a[i] - a[i+1]) <= 1) dp[i][i+2] = 1;\n        for (int d = 4; d <= n; d += 2){\n            REP(i,n+1-d){\n                FOR(j,i,i+d-1) if (dp[i][j] && dp[j][i+d]) dp[i][i+d] = 1;\n                if (dp[i+1][i+d-1] && abs(a[i]-a[i+d-1]) <= 1) dp[i][i+d] = 1;\n            }\n        }\n        \n        VI dp2(n+1);\n        REP(i,n){\n            int ma = 0;\n            REP(j,n+1){\n                if (dp[i][j]) ma = max(ma, j - i);\n                dp2[j] = max(dp2[j], dp2[i] + ma);\n            }\n        }\n        int ans = 0;\n        REP(i,n+1) ans = max(ans, dp2[i]);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nbool** table;\nint** dp;\nint N;\n\nint recursive(int left,int right){\n\n\tif(dp[left][right] != -1)return dp[left][right]; //?????¢???????????´???\n\tif((right-left+1)%2 == 1){ //??????????\\???°?????´???\n\t\treturn dp[left][right] = max(recursive(left,right-1),recursive(left+1,right));\n\t}\n\t//if(table[left][(right-left+1)/2] == true)return dp[left][right] = right-left+1; //left???right?????¨????¶?????????´???\n\t//if(right == left+1 && table[left][1] == false)return dp[left][right] = 0;\n\n\tfor(int i = left+1; i <= right-2; i++){\n\t\tdp[left][right] = max(dp[left][right],recursive(left,i)+recursive(i+1,right));\n\t}\n\treturn dp[left][right];\n}\n\nint main(){\n\n\tint data[301];\n\ttable = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tdp = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= N; k++){\n\t\t\t\tif(i == k)dp[i][k] = 0;\n\t\t\t\telse{\n\t\t\t\t\tdp[i][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1){\n\t\t\t\ttable[i][1] = true;\n\t\t\t\tdp[i][i+1] = 2;\n\t\t\t}else{\n\t\t\t\tdp[i][i+1] = 0;\n\t\t\t}\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t\tdp[left][left+length-1] = length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",recursive(1,N));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<deque>\n#include<map>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, n) for(int i = 0;i < (n);i++)\n#define repr(i, n) for(int i = (n);i >= 0;i--)\n#define repf(i, m, n) for(int i = (m);i < (n);i++)\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1;} return 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1;} return 0;}\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n//////////////////////////////////////////////////\n\nll dp[310][310];\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) break;\n        vector<int> w(n);\n        rep(i,n) cin >> w[i];\n        memset(dp, 0, sizeof(dp));\n\n        repf(width, 2, n+1) rep(left,n) {\n            int right = left + width - 1;\n            if (right >= n) continue;\n\n            if (dp[left+1][right-1] == width-2 && abs(w[left]-w[right]) <= 1) {\n                dp[left][right] = width;\n            }\n\n            repf(mid, left, right) {\n                chmax(dp[left][right], dp[left][mid]+dp[mid+1][right]);\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nint n;\nint w[MAX];\nint done[305][305];\nint dp[305][305];\n\nvoid print_dp() {\n    rep(i, n) {\n        rep(j, n+1) {\n            cout << setw(3) << dp[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint ans(int l, int r) {\n    if (done[l][r]) {\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    if (r - l == 0) return 0;\n    if (r - l == 1) return 0; \n    if (l > r) return -INF;\n    if (r > n) return -INF;\n    if (r - l == 2) {\n        done[l][r] = true;\n        int res = 0;\n        if (abs(w[l] - w[l+1]) < 2) res = 2;\n        else res = 0;\n        dp[l][r] = res;\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    int res = 0;\n    rep(width, n) {\n        if (l + width > r)\n            break;\n        rep2(i, l, r)\n        {\n            if (i + width  > n)\n                break;\n            if (i + width > r)\n                break;\n            if (i  == l && i + width == r)\n                continue;\n            if (i + width == l)\n                continue;\n            int cnt = 0;\n            int tmp = 0;\n            if (ans(i, i + width) == width)\n            {\n                rep(j, n)\n                {\n                    cnt = j;\n                    if (i-1-j < l) break;\n                    if (i+width+j >= r) break;\n                    if (abs(w[i - 1 - j] - w[i + width + j]) < 2)\n                    {\n                        tmp += 2;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            tmp +=\n                ans(l, i - cnt)\n                 + ans(i, i + width) \n                 + ans(i + width + cnt, r);\n            res = max(res, tmp);\n        }\n    }\n\n\n    done[l][r] = true;\n    dp[l][r] = res;\n    // if (test) {\n    //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n    // }\n    return dp[l][r];\n}\n\nvoid solve() {\n    rep(i, 305) rep(j, 305) done[i][j] = false;\n    rep(i, 305) rep(j, 305) dp[i][j] = 0;\n    cin >> n;\n    if (n == 0) exit(0);\n    rep(i, n) cin >> w[i];\n    cout << -1 << endl;\n    // cout << ans(0, n) << endl;\n    // if (test) print_dp();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> inline bool chmax(T& a,T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmin(T& a,T b) { if (a > b) { a = b; return true; } return false; }\nconst int MAX_N = 330;\n\nvoid solve (int n) {\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    vector<vector<int>> dp(MAX_N, vector<int>(MAX_N, 0));\n    for (int s = 2; s <= n; s++) for (int l = 0; l < n; l++) {\n        int r = l + s;\n        if (n < r) continue;\n        if (dp[l+1][r-1] == s-2 && abs(a[l]-a[r-1]) < 2) dp[l][r] = s;\n        for (int m = l; m <= r; m++) chmax(dp[l][r], dp[l][m] + dp[m][r]);\n    }\n    cout << dp[0][n] << endl;\n    return;\n}\n\nint main() {\n    int n;\n    while (cin >> n) if (n) solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#pragma region Debug\ntemplate <typename T>\nvoid view(const std::vector<T> &v)\n{\n    for (const auto &e : v)\n    {\n        std::cout << e << \" \";\n    }\n    std::cout << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv)\n{\n    for (const auto &v : vv)\n    {\n        view(v);\n    }\n}\n#pragma endregion\n#pragma region chminmax\ntemplate <typename T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <typename T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#pragma endregion\n\nvoid sol(int n, vector<int> &w)\n{\n    vector<vector<int>> dp(n, vector<int>(n + 1));\n\n    rep(i, n - 1)\n    {\n        if (abs(w[i] - w[i + 1]) < 2)\n        {\n            dp[i][i + 2] = 2;\n        }\n    }\n\n    for (int h = 2; h <= n; h++)\n    {\n        for (int l = 0; l <= n - h; l++)\n        {\n            int r = l + h;\n            if (dp[l + 1][r - 1] == r - l - 2 && abs(w[l] - w[r - 1]) < 2)\n            {\n                chmax(dp[l][r], 2 + dp[l + 1][r - 1]);\n            }\n            for (int m = l; m < r; m++)\n            {\n                chmax(dp[l][r], dp[l][m] + dp[m][r]);\n            }\n        }\n    }\n\n    cout << dp[0][n] << endl;\n}\n\nint main()\n{\n    while (true)\n    {\n        int n;\n        cin >> n;\n        if (!n)\n            break;\n        vector<int> w(n);\n        rep(i, n) cin >> w[i];\n        sol(n, w);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\twhile (N) {\n\t\tvector<int>num(N);\n\t\tfor (int i = 0; i < N; i++)cin >> num[i];\n\t\tvector<vector<int>>dp(N, vector<int>(N,0));\n\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\tif (abs(num[i] - num[i + 1]) < 2)dp[i][i + 1] = 2;\n\t\t}\n\t\tfor (int i = 4; i <= N; i += 2) {\n\t\t\tfor (int j = 0; i + j <= N; j++) {\n\t\t\t\tfor (int k = j; k < i + j - 1; k+=2) {\n\t\t\t\t\tfor (int l = k + 1; l <= i + j - 1; l+=2) {\n\t\t\t\t\t\tif (!k) {\n\t\t\t\t\t\t\tif (dp[k + 1][l - 1] == l - k - 1) {\n\t\t\t\t\t\t\t\tif (l == N - 1) {\n\t\t\t\t\t\t\t\t\tif (abs(num[k] - num[l]) < 2) {\n\t\t\t\t\t\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t\t\t\t\t//\t\tcout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(dp[l + 1][i + j - 1] == i + j - 1 - l&&abs(num[k] - num[l]) < 2) {\n\t\t\t\t\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t\t\t\t\t//\tcout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dp[j][k - 1] == k - j) {\n\t\t\t\t\t\t\tif (dp[k + 1][l - 1] == l - k - 1) {\n\t\t\t\t\t\t\t\tif (l == N - 1) {\n\t\t\t\t\t\t\t\t\tif (abs(num[k] - num[l]) < 2) {\n\t\t\t\t\t\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t\t\t\t\t\t//\tcout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dp[l + 1][i + j - 1] == i + j - 1 - l&&abs(num[k] - num[l]) < 2) {\n\t\t\t\t\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t\t\t\t\t\t//cout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>ret(N,0);\n\t\tret[1] = dp[0][1];\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tret[i] = dp[0][i];\n\t\t\tfor (int j = i - 1; j >= 1; j--) {\n\t\t\t\tret[i] = max(ret[i], ret[j - 1] + dp[j][i]);\n\t\t\t}\n\t\t}\n\t\tcout << ret[N - 1] << endl;\n\t\tcin >> N;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 10000000;\n\nvector<vector<int>> mem;\nvector<int> bs;\n\nint rec(int l, int r) {\n  if(mem[l][r] >= 0) return mem[l][r];\n  if(l >= r) {\n    mem[l][r] = 0;\n  } else {\n    int d = r - l + 1;\n    if(rec(l+1, r-1) == d - 2 && abs(bs[l] - bs[r]) <= 1) {\n      mem[l][r] = d;\n    } else {\n      int ans = 0;\n      for(int k = l; k < r; k++) {\n        ans = max(ans, rec(l, k) + rec(k+1, r));\n      }\n      mem[l][r] = ans;\n    }\n  }\n  return mem[l][r];\n}\n\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    int m;\n    cin >> m;\n    if(m == 0) break;\n    bs.clear();\n    for(int i = 0; i < m; i++) {\n      int b;\n      cin >> b;\n      bs.push_back(b);\n    }\n    mem = vector<vector<int>>(m, vector<int>(m, -1));\n    int ans = rec(0, m-1);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n\n/*\n\n  f(i, j) : bs[i..j] ??????????????§?????°\n\n f(i,j) =\n    0          ... i >= j ?????¨??????????????????\n    j - i + 1  ... if bs[i] ??¨ bs[j] ????????? 1 ??\\?????§???i+1??????j-1???????????????????????????????????????????????????????????????????????????\n    f(i, k) + f(k + 1, j) ... ???????????§?????£????????????\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nvector<int> a;         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<int> > ok;\n//vector<vector<int> > doteki;\nint n;\nint sec(int p,int q);\nvoid pr();\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    a.assign(n,0);\n    ok.assign(n,a);\n    //doteki.assign(n,a);\n    for(int t=0;t<n;t++){\n      scanf (\"%d\",&a[t]);\n    }\n    for(int s=0;(s+1)<n;++s){\n      ok[s][s+1]=sec(s,s+1);\n    }\n    for(int t=3;t<n;t=t+2){\n      for(int s=0;(s+t)<n;++s){\n        if((ok[s][s+1]&&ok[s+2][s+t])||(sec(s,s+t)&&ok[s+1][s+t-1])||(ok[s][s+t-2]&&ok[s+t-1][s+t])){\n          ok[s][s+t]=t+1;\n        }\n      }\n    }\n    \n    \n    for(int x=1;x<n;++x){\n      for(int y=0;y+x<n;++y){\n        for(int z=y;z<y+x;++z){\n          ok[y][y+x]=max(ok[y][y+x],ok[y][z]+ok[z+1][y+x]);\n        }\n        //pr();\n      }\n    }\n    printf(\"%d\\n\",ok[0][n-1]);\n    scanf (\"%d\",&n);\n  }\n}\n\n\n\n//変化したところだけ見る\n\n\n\nint sec(int p,int q){\n  if(-1<=(a[p]-a[q])&&(a[p]-a[q])<=1){\n    return 2;\n    //ok[p][q]=1;\n  }\n  else{\n    return 0;\n    //ok[p][q]=0;\n  }\n}\n\nvoid pr(){\n  for(int x=0;x<n;++x){\n    for(int y=0;y<n-1;++y){\n      printf(\"%d \",ok[x][y]);\n    }\n    printf(\"%d\\n\",ok[x][n-1]);\n  }\n  printf(\"\\n\");\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 40\n#define INF 1000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint w[300];\nbool dp[300][300];\nint ddp[301];\n\nvoid solve(){\n    memset(dp,0,sizeof(dp));\n    rep(i,n) cin >> w[i];\n    for(int i = 1; i < n; i+= 2){\n        for(int j = 0; j < n-i; j++){\n            if(abs(w[j]-w[j+i]) <= 1){\n                if(i == 1 || dp[j+1][j+i-1] == true){\n                    dp[j][j+i] = true;\n                }\n            }\n            for(int k = j+1; k <= j+i-2; k += 2){\n                if(dp[j][k] == true && dp[k+1][j+i] == true){\n                    dp[j][j+i] = true;\n                }\n            }\n        }\n    }\n    rep(i,n) ddp[i] = 0;\n    for(int i = 1; i < n; i += 2) if(dp[0][i]) ddp[i] = i+1;\n    for(int i = 1; i < n; i++){\n        ddp[i] = max(ddp[i],ddp[i-1]);\n        for(int j = 1; j < n-i; j += 2){\n            if(dp[i][i+j]) ddp[i+j] = max(ddp[i+j],ddp[i-1]+j+1);\n        }\n    }\n    cout << ddp[n-1] << endl;\n}\n\nint main(){\n    while(cin >> n){\n        if(n == 0) break;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e17+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//  17:50-\n//A 17:54 AC\n//B 17:58 AC\n//C 18:05 AC\nbool solve(void){\n\tint n,m,i,j,k;cin>>n;\n\tif(n==0){return false;}\n\tvector<int>w(n);\n\tstatic bool can[300][300];\n\tfor(i=0;i<n;i++){cin>>w[i];}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){can[i][j]=false;}\n\t\tif(i>0){can[i][i-1]=true;}\n\t}\n\tfor(i=2;i<=n;i++){\n\t\tfor(j=0;j<=n-i;j++){\n\t\t\tint L=j,R=j+i-1;\n\t\t\tfor(k=2;k<i;k+=2){\n\t\t\t\tint Lm=j+k-1,Rm=j+k;\n\t\t\t\tif(can[L][Lm]&&can[Rm][R]){can[L][R]=true;break;}\n\t\t\t}\n\t\t\tif(can[L+1][R-1]&&abs(w[L]-w[R])<=1){can[L][R]=true;}\n\t\t}\n\t}\n\tvector<int>dp(n+1,0);\n\tdp[0]=0;\n\tfor(i=0;i<n;i++){\n\t\tmaxeq(dp[i+1],dp[i]);\n\t\tfor(j=i+1;j<n;j+=2){\n\t\t\tif(can[i][j]){maxeq(dp[j+1],dp[i]+j-i+1);}\n\t\t}\n\t}\n\tcout<<dp[n]<<endl;\n\treturn true;\n}\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,o,n) for(long long i = o;i<n;i++)\n#define oneforall ios::sync_with_stdio(false);cin.tie(0);\n#define all(v) (v).begin(),(v).end()\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define int long long \nconst long long inf=1e18;\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef long long ll;\ntypedef vector<pair<long, long > > vpll;\ntypedef vector<pair<int, int > > vpii;\n#define FORR(x,arr) for(auto& x:arr)\n#define ZERO(a) memset(a,0,sizeof(a))\n\n\n\n\n\n//3111111111111111111111111111111\n\t\n\tint dp[3100][3100];\n\n\t\n\tvoid solve(){\n\n\n\t\twhile(1){\n\t\tini(n);\n\t\tif(n == 0)return;\n\n\t\tFOR(i,0,n+1)FOR(i1,0,n+1)dp[i][i1] = 0;\n\t\tvi morty(n);\n\t\tFOR(i,0,n){\n\t\t\tin(morty[i]);\n\t\t}\n\t\tFOR(i,2,n+1){\n\t\t\tFOR(i1,0,n){\n\t\t\t\tint l = i1;\n\t\t\t\tint r = i1+i;\n\t\t\t\tif(r>n)continue;\n\t\t\t\t\n\t\t\t\tif(abs(morty[l]-morty[r-1])<=1 and r-l-2 == dp[l+1][r-1])dp[l][r] = dp[l+1][r-1]+2;\n\n\t\t\t\telse{\n\t\t\t\t\tFOR(x,l+1,r){\n\t\t\t\t\t\tdp[l][r] = max(dp[l][r],dp[l][x]+dp[x][r]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout(dp[0][n]);\n\t\t}\n\t\t\n\n\t\t\n\n\n\t\t\n\t\t\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint32_t main() {\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall\n\toneforall \n\toneforall\n\n\tsolve();\n\t\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing ll = long long;\n\nusing namespace std;\n#define int ll\n\n//0 -> a-1\n#define rep(i, a) for (int i = 0; (i) < (int)(a); (i)++)\n//a -> b-1\n#define reps(i, a, b) for (int i = (int)(a); (i) < (int)(b); (i)++)\n//a-1 -> 0\n#define rrep(i, a) for (int i = (int)a - 1; (i) >= 0; (i)--)\n//a-1 -> b\n#define rreps(i, a, b) for (int i = (int)(a)-1; (i) >= (int)(b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n//next_permutation(all(v))\n#define PERM(v) next_permutation(all(v))\n/*sort(all(v));\n(v).erase(unique(all(v)), v.end())*/\n#define UNIQUE(v) \\\n\tsort(all(v)); \\\n\t(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) \\\n\ttype x;          \\\n\tcin >> x\n#define YES(f) if ((f)) {cout << \"YES\" << endl;} else {cout << \"NO\" << endl;}\n#define Yes(f) if ((f)) {cout << \"Yes\" << endl;} else {cout << \"No\" << endl;}\n#define MINV(v) min_element(all(v))\n#define MAXV(v) max_element(all(v))\n#define MIN3(a, b, c) min(min(a, b), c)\n#define MIN4(a, b, c, d) min(MIN3(a, b, c), d)\n#define MIN5(a, b, c, d, e) min(MIN4(a, b, c, d), e)\n#define MIN6(a, b, c, d, e, f) min(MIN5(a, b, c, d, e), f)\n#define MAX3(a, b, c) max(max(a, b), c)\n#define MAX4(a, b, c, d) max(MAX3(a, b, c), d)\n#define MAX5(a, b, c, d, e) max(MAX4(a, b, c, d), e)\n#define MAX6(a, b, c, d, e, f) max(MAX5(a, b, c, d, e), f)\n//b is [a, c)\n#define RANGE(a, b, c) ((a) <= (b) && (b) < (c))\n//c is [a, e) && d is [b, f)\n#define RANGE2D(a, b, c, d, e, f) (RANGE((a), (c), (e)) && RANGE((b), (d), (f)))\n#define chmin(a, b) a = min(a, (b))\n#define chmin3(a, b, c) a = MIN3(a, (b), (c))\n#define chmin4(a, b, c, d) a = MIN4(a, (b), (c), (d))\n#define chmin5(a, b, c, d, e) a = MIN5(a, (b), (c), (d), (e))\n#define chmin6(a, b, c, d, e, f) a = MIN6(a, (b), (c), (d), (e), (f))\n#define chmax(a, b) a = max(a, (b))\n#define chmax3(a, b, c) a = MAX3(a, (b), (c))\n#define chmax4(a, b, c, d) a = MAX4(a, (b), (c), (d))\n#define chmax5(a, b, c, d, e) a = MAX5(a, (b), (c), (d), (e))\n#define chmax6(a, b, c, d, e, f) a = MAX6(a, (b), (c), (d), (e), (f))\n#define fcout cout << fixed << setprecision(12)\n#define RS resize\n#define CINV(v, N)             \\\n\tdo                         \\\n\t{                          \\\n\t\tv.RS(N);               \\\n\t\trep(i, N) cin >> v[i]; \\\n\t} while (0);\n\n#define RCINV(v, N)             \\\n\tdo                          \\\n\t{                           \\\n\t\tv.RS(N);                \\\n\t\trrep(i, N) cin >> v[i]; \\\n\t} while (0);\n#define MOD 1000000007\n\ntemplate <class T>\ninline T GET()\n{\n\tT x;\n\tcin >> x;\n\treturn x;\n}\n\nbool init();\nvoid solve();\n\nsigned main()\n{\n\twhile(init());\n\tsolve();\n}\n\ntemplate<class T, char d='\\n'>\nstruct Vector {\n\tvector<T> v;\n\tVector(int sz) : v(sz) {}\n\tVector(int sz, T t) : v(sz, t) {}\n\tVector() : v(0) {}\n\tVector(vector<T> t) : v(t) {}\n\tinline auto begin() {return v.begin();}\n\tinline auto end() {return v.end();}\n\tinline auto rbegin() {return v.rbegin();}\n\tinline auto rend() {return v.rend();}\n\tinline int size() {return v.size();}\n\tinline auto resize(int sz) {v.resize(sz);}\n\tinline auto resize(int sz, T t) {v.resize(sz, t);}\n\tinline auto empty() {v.empty();}\n\tinline auto reserve(int sz) {v.reserve(sz);}\n\tinline auto push_back(T t) {v.push_back(t);}\n\tinline auto pop_back() {v.pop_back();}\n\tinline auto assign(int sz, const T& t) {v.assign(sz, t);}\n\tinline auto& front() {return v.front();}\n\tinline auto& back() {return v.back();}\n\tinline auto insert(const auto p, const T& t) {v.insert(p, t);}\n\tinline auto insert(const auto p, auto f, auto l) {v.insert(p, f, l);}\n\tinline auto erase(const auto p) {v.erase(p);}\n\tinline auto erase(const auto f, const auto s) {v.erase(f, s);}\n\tinline auto emplace_back(auto t) {v.emplace_back(t);}\n\tinline auto swap(auto& f) {v.swap(f.v);}\n\tinline auto clear() {v.clear();}\n\tinline auto& operator[](size_t pos) {return v[pos];}\n\tinline auto operator<(const auto& a) {return v < a.v;}\n\tinline auto operator>(const auto& a) {return a < (*this);}\n\tinline auto operator>=(const auto& a) {return !((*this) < a);}\n\tinline auto operator<=(const auto& a) {return !(a < (*this));}\n\tinline auto operator==(const auto& a) {return !(a < (*this)) && !((*this) < a);}\n\tinline friend istream& operator>>(istream& lhs, Vector& rhs) {\n\t\tfor (auto& x : rhs) lhs >> x;\n\t\treturn lhs;\n\t}\n\tinline friend ostream& operator<<(ostream& lhs, Vector& rhs) {\n\t\tfor (int i = 0; i + 1 < rhs.size(); i++) lhs << rhs[i] << d;\n\t\tif (rhs.size()) lhs << rhs.back();\n\t\treturn lhs;\n\t}\n\tinline auto make_accumulate_sum(T init) {\n\t\tVector<T> res;\n\t\tres.push_back(init);\n\t\tfor (auto x : v) {\n\t\t\tauto y = res.back();\n\t\t\tres.push_back(y + x);\n\t\t}\n\t\treturn res;\n\t}\n};\n\nVector<int> a;\nvector<vector<int>> dp;\n\nint dfs(int l, int r)\n{\n\tint& res = dp[l][r];\n\tif (res != -1) return res;\n\tres = 0;\n\tif (r - l == 1) return res;\n\tif (r - l == 2) return res = 2 * (a[r-1] <= a[l] + 1 && a[r-1] >= a[l] - 1);\n\tif (dfs(l+1, r-1) == r - l - 2 && (a[r-1] <= a[l] + 1 && a[r-1] >= a[l] - 1)) {\n\t\treturn res = r - l;\n\t}\n\treps(i, l+1, r) {\n\t\tchmax(res, dfs(l, i) + dfs(i, r));\n\t}\n\treturn res;\n}\n\nbool init()\n{\n\tint N;\n\tcin >> N;\n\tif (N == 0) return false;\n\ta.clear();\n\tdp.clear();\n\ta.resize(N);\n\tcin >> a;\n\tdp.resize(N+1, vector<int>(N+1, -1));\n\trep(i, N+1) {\n\t\treps(j, i+1, N+1) {\n//\t\t\tcout << dfs(i, j) << \" \";\n\t\t}\n//\t\tcout << endl;\n\t}\n\tcout << dfs(0, N) << endl;\n\treturn true;\n}\n\nvoid solve()\n{\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n;\nvi in;\nint dp[310][310];\nint f(int l,int r){\n\tif(dp[l][r]+inf)return dp[l][r];\n\tif(r-l<2)return dp[l][r]=0;\n\tint out=-inf;\n\tloop(i,l,r-1)if(abs(in[i]-in[i+1])<2){\n\t\tout=max(out,f(l,i)+2+f(i+2,r));\n\t}\n\tint t=f(l+1,r-1);\n\tif(t==r-l-2){\n\t\tif(abs(in[l]-in[r-1])<2)out=max(out,r-l);\n\t}\n\tout=max(out,f(l+1,r));\n\tout=max(out,f(l,r-1));\n//\tcout<<l<<\" \"<<r<<\" \"<<out<<endl;\n\treturn dp[l][r]=out;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vi(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,310)rep(j,310)dp[i][j]=-inf;\n\t\tcout<<f(0,n)<<endl;;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 40\n#define INF 1000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint w[300];\nbool dp[300][300];\nint ddp[301];\n\nvoid solve(){\n    memset(dp,0,sizeof(dp));\n    rep(i,n) cin >> w[i];\n    for(int i = 1; i < n; i+= 2){\n        for(int j = 0; j < n-i; j++){\n            if(abs(w[j]-w[j+i]) <= 1){\n                if(i == 1 || dp[j+1][j+i-1] == true){\n                    dp[j][j+i] = true;\n                }\n            }\n            for(int k = j+1; k <= j+i-2; k += 2){\n                if(dp[j][k] == true && dp[k+1][j+i] == true){\n                    dp[j][j+i] = true;\n                }\n            }\n        }\n    }\n    rep(i,n) ddp[i] = 0;\n    for(int i = 1; i < n; i += 2) if(dp[0][i]) ddp[i] = i+1;\n    for(int i = 1; i < n; i++){\n        ddp[i] = max(ddp[i],ddp[i-1]);\n        for(int j = 1; j < n-i; j += 2){\n            if(dp[i][i+j]) ddp[i+j] = max(ddp[i+j],ddp[i-1]+j+1);\n        }\n    }\n    cout << ddp[n-1] << endl;\n}\n\nint main(){\n    while(cin >> n){\n        if(n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC diagnostic ignored \"-Wunused-variable\" \n#include <bits/stdc++.h>\nusing namespace std;\n\n//#define BOOST\n#ifdef BOOST\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/range/adaptor/reversed.hpp>\nusing namespace boost;\nusing ml = boost::multiprecision::cpp_int;\nusing md = boost::multiprecision::cpp_dec_float_100;\n#define forir(i, ...) if(ll i=(ll)v.size())for(__VA_ARGS__)if(i--,1)\n#define eachr(i, e, c) forir(i, auto &&e: adaptors::reverse(c))\n#endif\n\n/***** type *****/\nusing ll = long long;\nusing ld = long double;\nusing pll = pair<long long, long long>;\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\ntemplate <class T> using vvvt = vector<vector<vector<T>>>;\n/***** define *****/\n#define all(c) (c).begin(), (c).end()            // begin to end\n#define coutd cout << fixed << setprecision(10)  // cout double\n#define output(x) do { cout << x << endl; return 0; } while(0)\n#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat\n#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse\n#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)\n#define each(i, e, c) fori (i, auto&& e: c)      // for each\n/***** const value *****/\n#define llong_max 9223372036854775807            // 9 * 10^18\n#define ldbl_max 1.79769e+308                    // 1.7 * 10^308\n#define pi 3.1415926535897932                    // 3.14 ...\n/***** lambda *****/\nauto Ceil = [] // if (a % b != 0) return a / b + 1;\n(auto x) { return (ll)ceil(x); };\nauto Count = [] // long long count value\n(auto b, auto e, auto x) { return (ll)count(b, e, x); };\nauto CtoL = [] // char to number\n(auto c) { return (ll)c - (ll)'0'; };\nauto LtoC = [] // number to char\n(auto n) { return (char)('0' + n); };\nauto Pow = [] // long long pow\n(auto a, auto b) { return (ll)pow(a, b); };\nauto Pow2 = [] // long long pow2\n(auto n) { return (1LL << n); };\nauto Pow10 = [] // long long pow10\n(auto n) { return (ll)pow(10, n); };\nauto Size = []  // long long collection size\n(auto& c) { return (ll)(c).size(); };\nauto Sum = [] // long long accumulate\n(auto b, auto e) { return accumulate(b, e, 0LL); };\n\n/***** template *****/\ntemplate <class T> void MakeVVT\n(ll ys, ll xs, vvt<T>& v, T fill = T())\n{\t// vector<vector<T>> resize + fill\n\tv.resize(ys); rep(y, 0, ys) v[y].resize(xs, fill);\n}\ntemplate <class T> void MakeVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fill = T())\n{\t// vector<vector<vector<T>>> resize + fill\n\tv.resize(zs); rep(z, 0, zs) MakeVVT(ys, xs, v[z], fill);\n}\ntemplate <class T> void InputVVT\n(ll ys, ll xs, vvt<T>& v, T fix = T())\n{\t// input vector<vector<T>> (T != struct) + fix\n\tMakeVVT(ys, xs, v, fix);\n\trep(y, 0, ys) rep(x, 0, xs) { cin >> v[y][x]; v[y][x] += fix; }\n}\ntemplate <class T> void InputVVVT\n(ll zs, ll ys, ll xs, vvvt<T>& v, T fix = T())\n{\t// input vector<vector<vector<T>>> (T != struct) + fix\n\tv.resize(zs); rep(z, 0, zs) InputVVT(ys, xs, v[z], fix);\n}\n\n/**************************************/\n/********** BEGIN OF NYA LIB **********/\n/**************************************/\n\nnamespace NyaGadget {}\n\n/**************************************/\n/*********** END OF NYA LIB ***********/\n/**************************************/\n\nusing namespace NyaGadget;\n//using mll = NT_ModLL< 1000000007 >;\n//using mll = NT_ModLL< 998244353 >;\n\nint main(void)\n{\n\tvt<ll> ans;\n\twhile(1)\n\t{\n\t\tll n; cin >> n;\n\t\tif (n == 0) break;\n\n\t\tvt<ll> w(n); each(i, e, w) cin >> e;\n\t\tvvt<ll> dp; MakeVVT(n, n, dp);\n\t\trep(range, 2, n + 1)\n\t\t{\n\t\t\trep(l, 0, n - 1)\n\t\t\t{\n\t\t\t\tll r = l + range - 1;\n\t\t\t\tif (n <= r) continue;\n\t\t\t\tif (dp[l+1][r-1] == range - 2 && abs(w[l] - w[r]) <= 1) dp[l][r] = range;\n\t\t\t\trep(k, l, r) dp[l][r] = max(dp[l][r], dp[l][k] + dp[k + 1][r]);\n\t\t\t}\n\t\t}\n\t\tans.push_back(dp[0][n - 1]);\n\t}\n\n\teach(i, e, ans) cout << e << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n\nint blocks[300];\nint8_t strike_range[300][300];\nint score_in_range[300][300];\n\nconst int8_t STRIKE_RANGE_UNDEF = 0;\nconst int8_t STRIKE_RANGE_NO = 1;\nconst int8_t STRIKE_RANGE_YES = 2;\n\nbool can_strike(int x, int y) {\n\treturn std::abs(blocks[x] - blocks[y]) <= 1;\n}\n\nint8_t search_range(int start, int end) {\n\tif (start >= end) return STRIKE_RANGE_UNDEF;\n\tif ((end - start + 1) % 2 != 0) return STRIKE_RANGE_NO;\n\n\tint8_t* p = &strike_range[start][end];\n\tif (*p != STRIKE_RANGE_UNDEF) return *p;\n\n\tif (start + 1 == end)\n\t\treturn *p = can_strike(start, end) ? STRIKE_RANGE_YES : STRIKE_RANGE_NO;\n\n\tfor (int i = start + 1; i < end - 1; i++) {\n\t\tif (search_range(start, i) == STRIKE_RANGE_YES\n\t\t\t&& search_range(i + 1, end) == STRIKE_RANGE_YES)\n\t\t{\n\t\t\treturn *p = STRIKE_RANGE_YES;\n\t\t}\n\t}\n\n\tauto result = search_range(start + 1, end - 1);\n\treturn *p = result == STRIKE_RANGE_YES && can_strike(start, end)\n\t\t? STRIKE_RANGE_YES : STRIKE_RANGE_NO;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\tif (n == 0) return 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint w;\n\t\t\tstd::cin >> w;\n\t\t\tblocks[i] = w;\n\t\t}\n\n\t\tstd::memset(strike_range, 0, sizeof(strike_range));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tscore_in_range[i][j] = search_range(i, j) == STRIKE_RANGE_YES ? j - i + 1 : 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tscore_in_range[0][i] = std::max(\n\t\t\t\t\tscore_in_range[0][i],\n\t\t\t\t\tscore_in_range[0][j] + score_in_range[j + 1][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << score_in_range[0][n - 1] << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint dp[302][302];\nint main() {\n    int n;\n    while(cin >> n, n){\n        for (int i = 0; i <= n; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                dp[i][j] = -INF<int>;\n            }\n            dp[i][i] = 0;\n        }\n        vector<int> v(n);\n        for (auto &&i : v) scanf(\"%d\", &i);\n        for (int len = 2; len <= n; len += 2) {\n            for (int i = 0; i+len <= n; ++i) {\n                int j = i+len;\n                if(abs(v[j-1]-v[i]) <= 1){\n                    dp[i][j] = max(dp[i][j], dp[i+1][j-1]+2);\n                }\n                for (int k = i; k <= j; ++k) {\n                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k][j]);\n                }\n            }\n        }\n        for (int i = 0; i <= n; ++i) {\n            dp[i][i+1] = 0;\n        }\n        for (int len = 1; len <= n; ++len) {\n            for (int i = 0; i+len <= n; ++i) {\n                int j = i+len;\n                for (int k = i; k <= j; ++k) {\n                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k][j]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                ans = max(ans, dp[i][j]);\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nint n;\nint w[400];\nint dp[400][400];\n\n// the maximum number of block can be removed\nint cnt(int b, int t) {\n    if (dp[b][t] >= 0) return dp[b][t];\n\n    if (abs(w[t]-w[b])<=1 && cnt(b+1, t-1) == t-(b-1)-2) {\n        return dp[b][t] = t-(b-1);\n    }\n\n    int output = 0;\n    for(int i=b; i<=t-1; i++) {\n        output = max(output, cnt(b, i)+cnt(i+1, t));\n    }\n    return dp[b][t] = output;\n}\n\nint main() {\n    while(true) {\n        cin >> n;\n        if (n==0) break;\n\n        REP(i, n) {\n            cin >> w[i];\n        }\n\n        REP(i, n) {\n            REP(j, n) {\n                if (i==j) {\n                    dp[i][j] = 0;\n                } else if (j-i == 1){\n                    if (abs(w[i] - w[j]) <= 1) {\n                        dp[i][j] = 2;\n                    } else {\n                        dp[i][j] = 0;\n                    }\n                } else {\n                    dp[i][j] = -1;\n                }\n            }\n        }\n\n        cout << cnt(0, n-1) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint w[305], dp[305][305];\nsigned main(void)\n{\n\twhile(true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tREP(i, n) cin >> w[i];\n\t\tREP(i, 305) REP(j, 305) dp[i][j] = 0;\n\n\t\tFOR(W, 2, n+1) {\n\t\t\tREP(i, n) {\n\t\t\t\tint j = i+W-1;\n\t\t\t\t//cout << i << \" \" << j << endl;\n\n\t\t\t\tif(dp[i+1][j-1] == W-2 && abs(w[i] - w[j]) <= 1) dp[i][j] = W;\n\t\t\t\tFOR(k, i, j) {\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n\t\t\t\t\t//cout << dp[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*REP(i, n) {\n\t\t\tcout << i << \":\";\n\t\t\tREP(j, n) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << dp[0][n-1] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define Repr(i, n, a) for (int i = (n); i >= (a); i--)\n#define rep(i, n) Rep(i, 0, n)\n#define repr(i, n) Repr(i, n, 0)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    while (1)\n    {\n        cin >> n;\n        if (n == 0)\n            break;\n        vector<int> w(n);\n        rep(i, n) cin >> w[i];\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n        for (int b = 2; b <= n; b++)\n        {\n            for (int l = 0; l + b <= n; l++)\n            {\n                int r = l + b - 1;\n                if (abs(w[r] - w[l]) <= 1 && dp[l + 1][r - 1] == b - 2)\n                    dp[l][r] = b;\n                for (int m = l; m < r; m++)\n                    dp[l][r] = max(dp[l][r], dp[l][m] + dp[m + 1][r]);\n            }\n        }\n        cout << dp[0][n - 1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint n;\nint a[301];\nint dp[301][301];\n\nint dfs(int l, int r) {\n    if (l >= r) return 0;\n    int &ret = dp[l][r];\n    if (ret != -1) return ret;\n    ret = 0;\n    rep2(i, l + 1, r) {\n        chmax(ret, dfs(l, i) + dfs(i, r));\n    }\n    if (l < r - 1 && abs(a[l] - a[r - 1]) <= 1 && dfs(l + 1, r - 1) == (r - 1) - (l + 1)) {\n        chmax(ret, r - l);\n    }\n    return ret;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> n, n) {\n        rep(i, n) cin >> a[i];\n        rep(i, n + 1) rep(j, n + 1) dp[i][j] = -1;\n        cout << dfs(0, n) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(long long i=0;i<n;i++)\n#define REP1(i,n) for(long long i=1;i<=n;i++)\n#define PER(i,n) for(long long i=((n)-1);i>=0;i--)\n#define PER1(i,n) for(long long i=(n);i>0;i--)\n#define REP2D(i,j,w,h) for(long long i=0;i<h;i++) for(long long j=0;j<w;j++)\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define FORE(i,a,b) for(long long i=(a);i<=(b);i++)\n#define ITE(arr) for(auto ite=(arr).begin();ite!=(arr).end();++ite)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define YNPRT(b) cout<<((b)?\"Yes\":\"No\")<<endl\n#define REV(arr) reverse(ALL(arr))\n#define PRT(a) cout<<a<<endl;\n#define PRTLST(arr,num) REP(_i,num) cout<<_i<<\" - \"<<arr[_i]<<endl;\n#define PRTLST2(arr2,d1,d2) REP(_i,d1) REP(_j,d2) cout<<_i<<\",\"<<_j<<\" : \"<<arr2[_i][_j]<<endl;\n#define PRTLST2D(arr2,d1,d2) do{cout<<\"L\\t\";REP(_i,d2) cout<<_i<<\"\\t\"; cout<<endl; REP(_i,d1){cout<<_i<<\"\\t\";REP(_j,d2){cout<<arr2[_i][_j]<<\"\\t\";}cout<<endl;}}while(0);\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF_INT = 2147483647;\nconst ll INF_LL = 9223372036854775807LL;\nconst ull INF_ULL = 18446744073709551615Ull;\nconst ll P = 92540646808111039LL;\nconst int Move[4][2] = {-1,0,1,0,0,1,0,-1};\nconst int Move_[8][2] = {-1,-1,-1,0,-1,1,0,-1,0,1,1,-1,1,0,1,1};\n\n//---------------------\n#define MAXN 300\n//---------------------\n\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {os<<\"{\"; ITE(v) os << *ite << \" \";os<<\"}\";return os;}\n\nll n,w[MAXN];\nll dpmem[MAXN][MAXN];\nvector<ll> idtomove[MAXN];\n\n\nbool init(){\n\tn=0;\n\tZERO(w);\n\tMINUS(dpmem);\n\tREP(i,MAXN) idtomove[i].clear();\n\tcin>>n;\n\tif(n<=0) return false;\n\tREP2D(i,j,n,n) if(i>=j) dpmem[i][j]=0;\n\tREP(i,n) cin>>w[i];\n\tREP(i,n){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(abs(w[j]-w[i])<=1.1) idtomove[i].push_back(j);\n\t\t}\n\t}\n\treturn true;\n}\n\nbool canberemoved(ll a,ll b){\n\treturn abs(w[a]-w[b])<=1.1;\n}\n\nll dp(ll l,ll r){\n  \tif(l>=n || r>=n || l<0 || r<0) return 0;\n  \tif(dpmem[l][r]>=0) return dpmem[l][r];\n  \tll ret=-1;\n\tif(r-l==1){\n\t\tif(canberemoved(l,r)) ret=dpmem[l][r]=2;\n\t\telse ret=0;\n\t}\n\telse{\n\t\tITE(idtomove[l]) if(*ite<=r && dp(l+1,(*ite)-1)==((*ite)-l-1)) ret=max(ret,(*ite)-l+1+dp((*ite)+1,r));\n\t\tret=max(ret,dp(l+1,r));\n\t}\n\treturn dpmem[l][r]=ret;\n}\n\nint main(){\n\twhile(init()){\n\t\tcout<<dp(0,n-1)<<endl;\n\t\t//PRTLST2D(dpmem,n,n);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main(){\n  int N;\n  while(cin >> N, N){\n    vector<int> a(N);\n    vector<vector<int> > dp(N, vector<int> (N, 0));\n    for(int i = 0; i < N; i++) cin >> a[i];\n    for(int i = 1; i < N; i++){\n      for(int j = 0; j + i < N; j++){\n        for(int k = j; k < i + j; k++){\n          dp[j][j + i] = max(dp[j][j + i], dp[j][k] + dp[k + 1][j + i]);\n        }\n        if(dp[j + 1][j + i - 1] == i - 1 && abs(a[j] - a[j + i]) <= 1){\n          dp[j][j + i] = i + 1;\n        }\n      }\n    }\n    cout << dp[0][N - 1] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n// #define DEBUG\n\nconst int MAX_N = 300;\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N) {\n        vector<int> W(N);\n        rep(i, N) cin >> W[i];\n\n        bool dp[MAX_N][MAX_N] = {};\n        rep(i, MAX_N) {\n            dp[i][i] = true;\n        }\n\n        for (int len=2; len<=N; len+=2) {\n            for (int l=0; l<=N-len; l++) {\n                {\n                    int inner_len = len - 2;\n                    if (!(inner_len > 0 && !dp[l + 1][l + inner_len]) && abs(W[l] - W[l+ (len - 1)]) <= 1) {\n                        dp[l][l + (len - 1)] = true;\n                    }\n                }\n                if (len >= 4) {\n                    bool ok = true;\n                    for (int l2=l; l2<l+len; l2+=2) {\n                        if (!dp[l2][l2+1]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        dp[l][l + (len - 1)] = true;\n                    }\n                }\n            }\n        }\n\n        int dp2[MAX_N + 1] = {};\n        rep(r, N) {\n            if (r > 0) dp2[r] = dp2[r-1];\n            for (int len=2; len<=r+1; len+=2) {\n                int l = r - len + 1;\n#ifdef DEBUG\n                // DUMP(len);\n                // DUMP2(l, r);\n#endif\n                if (dp[l][r]) {\n                    if (l-1 >= 0) {\n                        dp2[r] = max(dp2[r], dp2[l-1] + len);\n                    } else {\n                        dp2[r] = max(dp2[r], len);\n                    }\n                }\n            } \n        }\n\n#ifdef DEBUG\n        rep(l, N) {\n            rep(r, N) cerr << dp[l][r] << \" \";\n            cerr << endl;\n        }\n        cerr << \"-----------------------------\" << endl;\n        rep(i, N) cerr << dp2[i] << \" \";\n        cerr << endl;\n#endif\n\n        cout << dp2[N-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15);\n  }\n} initializer;\n\ntemplate<typename T> istream& operator>>(istream &s, vector<T> &v) {\n  for (T &t : v) s >> t;\n  return s;\n}\n\ntemplate<typename T> ostream& operator<<(ostream &s, const vector<T> &v) {\n  for (const T &t : v) s << t << endl;\n  return s;\n}\n\ntemplate<typename T> T min(vector<T>& v) {return *min_element(v.begin(), v.end());}\n\ntemplate<typename T> T max(vector<T>& v) {return *max_element(v.begin(), v.end());}\n\ntemplate<typename T> int min_element(vector<T>& v) {return min_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> int max_element(vector<T>& v) {return max_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> void sort(vector<T>& v) {sort(v.begin(), v.end());}\n\ntemplate<typename T, typename Function> void sort(vector<T>& v, Function func) {sort(v.begin(), v.end(), func);}\n\ntemplate<typename T> void rsort(vector<T>& v) {sort(v.rbegin(), v.rend());}\n\ntemplate<typename T> void reverse(vector<T>& v) {reverse(v.begin(), v.end());}\n\ntemplate<typename T> void unique(vector<T>& v) {v.erase(unique(v.begin(), v.end()), v.end());}\n\ntemplate<typename T> void nth_element(vector<T>& v, int n) {nth_element(v.begin(), v.begin() + n, v.end());}\n\ntemplate<typename T> bool next_permutation(vector<T>& v) {return next_permutation(v.begin(), v.end());}\n\ntemplate<typename T> int find(vector<T>& v, T t) {return find(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int in(vector<T> v, T t) {return find(v, t) != int(v.size());}\n\ntemplate<typename T> int lower_bound(vector<T>& v, T t) {return lower_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int upper_bound(vector<T>& v, T t) {return upper_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> T accumulate(const vector<T>& v, function<T(T, T)> func = plus<T>()) {return accumulate(v.begin(), v.end(), T(), func);}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v) {adjacent_difference(v.begin(), v.end(), v.begin());}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v, vector<T>& u) {adjacent_difference(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> void partial_sum(vector<T>& v, vector<T>& u) {partial_sum(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> T inner_product(vector<T>& v, vector<T>& u) {return inner_product(v.begin(), v.end(), u.begin(), T(0));}\n\ntemplate<typename T> int count(const vector<T>& v, T t) {return count(v.begin(), v.end(), t);}\n\ntemplate<typename T, typename Function> int count_if(const vector<T>& v, Function func) {return count_if(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> void remove_if(vector<T>& v, Function func) {v.erase(remove_if(v.begin(), v.end(), func), v.end());}\n\ntemplate<typename T, typename Function> bool all_of(vector<T> v, Function func) {return all_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool any_of(vector<T> v, Function func) {return any_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool none_of(vector<T> v, Function func) {return none_of(v.begin(), v.end(), func);}\n\ntemplate<typename T> vector<T> subvector(vector<T>& v, int a, int b) {return vector<T>(v.begin() + a, v.begin() + b);}\n\ntemplate<typename T> int kinds(const vector<T>& v) {return set<T>(v.begin(), v.end()).size();}\n\ntemplate<typename T> void iota(vector<T>& v, T t = 0) {iota(v.begin(), v.end(), t);}\n\ntemplate<typename T> bool is_sorted(const vector<T>& v) {return is_sorted(v.begin(), v.end());}\n\nclass Solver {\nprivate:\n  vector<int> w;\n  map<pair<int, int>, int> mem;\n\npublic:\n  Solver(const vector<int>& w) : w(w) {}\n\n  int solve(int a, int b) {\n    if (b - a < 2) return 0;\n    if (mem.count(make_pair(a, b))) return mem[make_pair(a, b)];\n    int x = solve(a + 2, b) + (abs(w[a] - w[a + 1]) <= 1 ? 2 : 0);\n    int y = solve(a, b - 2) + (abs(w[b - 2] - w[b - 1]) <= 1 ? 2 : 0);\n    int z = solve(a + 1, b - 1);\n    if (z == b - a - 2 && abs(w[a] - w[b - 1]) <= 1) z += 2;\n    return mem[make_pair(a, b)] = max({x, y, z});\n  }\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<int> w(n);\n    cin >> w;\n    Solver solver(w);\n    cout << solver.solve(0, n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0}; \n\nint n;\nint data[300];\nint dp[300][301]; // hankai\nint score[300][301];\n\nvoid make(int st, int en)\n{\nif (dp[st][en]) return;\ndp[st][en] = 1;\nif (0 <= st - 2 && abs(data[st-2] - data[st-1] ) < 2 ) {\nmake(st-2, en);\n}\nif (0 <= st - 1 && en < n && abs(data[st-1] - data[en]) < 2) {\nmake(st-1, en+1);\n}\nif (en + 1 < n && abs(data[en] - data[en+1]) < 2) {\nmake(st, en+2);\n}\n}\n\nint solve(int st, int en)\n{\nif ( dp[st][en] ) return 0; \nif ( score[st][en] ) return score[st][en];\nif (en - st < 2) return en - st;\nint ret = en - st;\nfor (int i = st+2; i < en; i++) {\nif (dp[st][i]) {\nret = min(solve(i-1, en), ret);\n}\n}\nreturn score[st][en] = min(ret, 1+solve(st+1, en));\n}\n\nsigned main() \n{ \nstd::ios::sync_with_stdio(false); \nstd::cin.tie(0); \n\ncin >> n;\nwhile ( n ) {\nmemset(data, 0, sizeof(data))\nmemset(dp, 0, sizeof(dp));\nrep(i, n) cin >> data[i];\nrep(i, n-1) if ( abs(data[i] - data[i+1]) < 2 )\nmake(i, i+2);\ncout << n - solve(0, n) <<endl;\ncin >> n;\n}\n\nreturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define ASC(vec) vec.begin(), vec.end()\t\t// 昇順ソート 例：sort(ASC(vec));\n#define DESC(vec) vec.rbegin(), vec.rend()\t// 降順ソート 例:sort(DESC(vec));\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define Rep(i, n) for(int i = 1; i < n; i++)\n\nconst int mod = 1000000007;\nconst int inf = (int)1e9 + 7;\nconst long long INF = 1LL << 60;\n\nusing ii = pair<int, int>;\nusing ll = long long;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vvb = vector<vector<bool>>;\nusing vii = vector<pair<int, int>>;\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\nll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nll LCM(ll a, ll b) { return (a * b) / GCD(a, b); }\nint round_int(int a, int b) { return (a + (b - 1)) / b; }\n\n// 素因数分解; 返り値は(素数, 乗数)のvector配列\nvector<pair<ll, int>> factorize(ll n) {\n\tvector<pair<ll, int>> res;\n\tfor (ll i = 2; i * i <= n; ++i) {\n\t\tif (n % i) continue;\n\t\tres.emplace_back(i, 0);\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\tres.back().second++;\n\t\t}\n\t}\n\tif (n != 1) res.emplace_back(n, 1);\n\treturn res;\n}\n\nconstexpr array<int, 9> dx = { 0, 1, 0, -1, -1, 1, 1, -1, 0 };\nconstexpr array<int, 9> dy = { 1, 0, -1, 0, 1, 1, -1, -1, 0 };\n//constexpr auto MAX = 100000;\n\n// ──────────────────────────────────────────────────────────────────\n\nint n, dp[1010][1010];\nvi w;\n\nint rec(int l, int r) {\n\tif (dp[l][r] != -1) return dp[l][r];\n\tif (abs(l - r) <= 1) return 0;\n\n\tint res = 0;\n\n\tif (abs(w[l] - w[r - 1]) <= 1 && rec(l + 1, r - 1) == r - l - 2) {\n\t\tres = r - l;\n\t}\n\n\tfor (int mid = l + 1; mid <= r - 1; ++mid) {\n\t\tres = max(res, rec(l, mid) + rec(mid, r));\n\t}\n\treturn dp[l][r] = res;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\n\t\tif (!n) break;\n\n\t\tw.resize(n);\n\t\trep(i, n) cin >> w[i];\n\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tcout << rec(0, n) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nvector<tuple<int, int, int>>vec; int n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; vec.clear(); for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { vec.push_back(make_tuple(j - i, i, j)); } }\n\t\tsort(vec.begin(), vec.end());\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tint a1 = get<1>(vec[i]), a2 = get<2>(vec[i]);\n\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = n - 1; j >= i + 1; j--) {\n\t\t\t\tfor (int k = n - 1; k >= j; k--) {\n\t\t\t\t\tdp[i][k] = max(dp[i][k], dp[i][j - 1] + dp[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n-1){\n            if(!k || i+k>n-1)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n                    cmax(dp[i][i+k],dp[i+1][i+k-1]+2);\n                }\n                for(int j = i+1; j<i+k-1;j++){\n                    if(dp[i][j] && dp[j+1][i+k])cmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int s = 0;s < n;s++){\n            int temp = 0;\n            for(int i = s; i<n;i++){\n                for(int j = n-1; j >= 0;--j){\n                    if(dp[i][j]){\n                        temp += j-i+1;\n                        i = j;\n                    }\n                }\n                cmax(ans, temp);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include <unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n#include<type_traits>\n\nusing namespace std;\n\n\n#define YES cout<<\"YES\"<<endl\n#define NO cout<<\"NO\"<<endl\n#define Yes cout<<\"Yes\"<<endl\n#define No cout<<\"No\"<<endl\n#define yes cout<<\"yes\"<<endl\n#define no cout<<\"no\"<<endl\n\n#define Tof(x) (x) ? Yes : No\n#define TOF(x) (x) ? YES : NO\n#define tof(x) (x) ? yes : no\n\nusing ll = long long;\n\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1050000000;\nconstexpr long long LONGINF = 1005000000000000000;\n\n\n\n/*for文でx,yを上下左右確認するやつだよ。正直使いづらいよ。\n\nint dy[] = { 0, 1, 0, -1 };\nint dx[] = { 1, 0, -1, 0 };\n\n\nfor (int i = 0; i < 4; i++) {\n\tint ny = y + dy[i];\n\tint nx = x + dx[i];\n}\n\n*/\n\n\n/*繰り返し二乗法だよ。modもとってくれるよ。n^kをmodで割った余りでやってくれるよ。\n\nll POW_MOD(ll n, ll k, ll mod) {\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\n\n*/\n\n\n\n/*まだ使えないテクニックのメモだよ。\n\nfor (int bit = 0; bit < (1<<n); ++bit)//bit全探索用のfor文だよ\n\n*/\n\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 1);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nint GCD(int a, int b) {\n\twhile (b) {\n\t\tint tmp = a % b;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\treturn a;\n}\n\nint main() {\n\tint dp[310][310];\n\tbool take[310][310];\n\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tint w[310];\n\t\tif (n == 0) { return 0; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tmemset(take, false,sizeof(take));\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\t\tint len = i + 1;\n\t\t\t\tint s = j;\n\t\t\t\tint t = j + i;\n\t\t\t\tfor (int k = s; k < t; k++) {\n\t\t\t\t\tif (take[s][k] && take[k + 1][t]) { take[s][t] = true; }\n\t\t\t\t}\n\t\t\t\tif (len == 2) {\n\t\t\t\t\tif (abs(w[s] - w[t]) < 2) { take[s][t] = true; }\n\t\t\t\t}\n\t\t\t\tif (take[s][t]) {\n\t\t\t\t\tint x = s - 1;\n\t\t\t\t\tint y = t + 1;\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tif (x < 0 || x >= n || y < 0 || y >= n) { break; }\n\t\t\t\t\t\tif (abs(w[x] - w[y]) >= 2) { break; }\n\t\t\t\t\t\ttake[x][y] = true;\n\t\t\t\t\t\tx--; y++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (take[i][j]) { dp[i][j] = j - i + 1; }\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[0][n - 1] << endl;\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 400\n\n\nint main() {\n\tint a[N];\n\tf(i, N)a[i] = 0;\n\tint dp[N][N];\n\tint n, k;\n\tint x, y, z;\n\tint s, ans;\n\tbool v = true;\n\twhile (true) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\tf(i, N) {\n\t\t\tf(j, N)dp[i][j] = 0;\n\t\t\ta[i] = 0;\n\t\t}\n\t\tf(i, n) {\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t}\n\t\tf(j, n+1) {\n\t\t\tfor(int i=j-1;i>=0;i--){\n\t\t\t\tdp[i][j] = dp[i][j - 1];\n\t\t\t\tk = 2;\n\t\t\t\twhile ((j - k) >= i) {\n\t\t\t\t\tif (dp[j - k + 1][j - 1] == (k - 2) && abs(a[j - k] - a[j - 1]) <= 1) {\n\t\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][j - k] + k);\n\t\t\t\t\t}\n\t\t\t\t\tk += 2;\n\t\t\t\t}\n}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][n]);\n\t}\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint main(){\n\n    while(1){\n\n        int n; cin >> n;\n        if(!n) break;\n        vector<int> w(n);\n        for(int i = 0; i < n; i++){\n            cin >> w[i];\n        }\n\n        vector<vector<bool> > take(n, vector<bool> (n, false));        //take[i][j] := 区間[i][j]を全消しできるかどうか\n\n        for(int k = 1; k < n; k++){\n            for(int i = 0; i + k < n; i++){\n                if(k == 1){\n                    take[i][i + k] = (abs(w[i] - w[i + k]) <= 1);\n                }else{\n                    take[i][i + k] = (take[i + 1][i + k - 1] && abs(w[i] - w[i + k]) <= 1);\n                \n                    for(int l = i + 1; l < i + k; l++){\n                        if(take[i][i + k]) break;\n                        take[i][i + k] = (take[i][l] && take[l][i + k]);\n                    }\n                }\n            }\n        }\n\n        vector<vector<int> > dp(n, vector<int> (n, 0));               //dp[i][j] := 区間 [i, j] において被覆できる頂点数の最大値\n\n        //初期化\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(take[i][j]) dp[i][j] = j - i + 1;\n            }   \n        }\n\n\n        for(int k = 2; k < n; k++){\n            for(int i = 0; i + k < n; i++){\n                for(int l = i + 1; l < i + k; l++){\n                    dp[i][i + k] = max(dp[i][i + k], dp[i][l] + dp[l + 1][i + k]);\n                }  \n            }\n        }\n\n        cout << dp[0][n - 1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> Pi;\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\n#define fi first\n#define se second\n#define endl \"\\n\"\n\ntemplate<typename T> inline bool chmax(T &a, T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T> ostream& operator<<(ostream& s,const complex<T>& d) {return s<<\"(\"<<d.real()<<\", \"<<d.imag()<< \")\";}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const pair<T1,T2>& d) {return s<<\"(\"<<d.first<<\", \"<<d.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d){\n\tint len=d.size();\n\trep(i,len){\n\t\ts<<d[i];if(i<len-1) s<<\" \";\n\t}\n\treturn s;\n}\ntemplate<typename T> ostream& operator<<(ostream& s,const vector<vector<T>>& d){\n\tint len=d.size();\n\trep(i,len){\n\t\ts<<d[i]<<endl;\n\t}\n\treturn s;\n}\ntemplate<typename T> ostream& operator<<(ostream& s,const set<T>& v){\n\ts<<\"{ \";\n\tfor(auto itr=v.begin();itr!=v.end();++itr) {\n\t\tif (itr!=v.begin()) {s<< \", \";}\n\t\ts<<(*itr);\n\t}\n\ts<<\" }\";\n\treturn s;\n}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const map<T1,T2>& m){\n\ts<<\"{\"<<endl;\n\tfor(auto itr=m.begin();itr!=m.end();++itr){\n\t\ts<<\" \"<<(*itr).first<<\" : \"<<(*itr).second<<endl;\n\t}\n\ts<<\"}\"<<endl;\n\treturn s;\n}\n\nconst ll mod=1e9+7;\nconst ll inf=1e17;\nconst int INF=1e9;\nconst double PI=acos(-1);\nconst double EPS=1e-10;\n\nint n;\nvector<int> a(400);\nvector<vector<int>> dp(400,vector<int>(400,-1));\n\nint dfs(int l,int r){\n\tif(dp[l][r]!=-1) return dp[l][r];\n\tif(r-l==1){\n\t\tdp[l][r]=1;\n\t\treturn dp[l][r];\n\t}\n\tif(r-l==2){\n\t\tif(abs(a[l]-a[l+1])<=1) dp[l][r]=0;\n\t\telse dp[l][r]=2;\n\t\treturn dp[l][r];\n\t}\n\tint ret=INF;\n\tFOR(k,l+1,r){\n\t\tchmin(ret,dfs(l,k)+dfs(k,r));\n\t}\n\tif(dp[l+1][r-1]==0){\n\t\tif(abs(a[l]-a[r-1])<=1){\n\t\t\tchmin(ret,0);\n\t\t}else{\n\t\t\tchmin(ret,2);\n\t\t}\n\t}\n\treturn dp[l][r]=ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(true){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\trep(i,n){\n\t\t\tcin>>a[i];\n\t\t}\n\t\trep(i,400)rep(j,400) dp[i][j]=-1;\n\t\tcout<<n-dfs(0,n)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nlong long dp[330][330];\nvector<long long> w(330, 0);\nint n;\n\nlong long rec(int l, int r) {\n    long long res = 0;\n    if(dp[l][r] != -1) return dp[l][r];\n    if(abs(l-r) <= 1) return 0;\n    if(abs(w.at(l)-w.at(r-1)) <= 1 && rec(l+1, r-1) == r-l-2) {\n        res = r-l;\n    }\n    for(int mid = l+1; mid <= r-1; ++mid) {\n        chmax(res, rec(l, mid)+rec(mid, r));\n    }\n    return dp[l][r] = res;\n}\n\nint main() {\n    while(1) {\n        cin >> n;\n        if(n == 0) break;\n        for(int i = 0; i < n; ++i) cin >> w.at(i);\n        for(int i = 0; i <= n; ++i) {\n            for(int j = 0; j <= n; ++j) {\n                dp[i][j] = -1;\n            }\n        }\n        cout << rec(0, n) << endl;\n    }    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    vector<int> w(n);\n    for(int i=0;i<n;++i) {\n      cin >> w[i];\n    }\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for(int i=0;i<n-1;++i) {\n      if(abs(w[i] - w[i+1]) <= 1) {\n        dp[i][i+1] = 2;\n      }\n    }\n    for(int i=2;i<n;++i) {\n      for(int l=0;l<n-i;++l) {\n        int r = l + i;\n        if(dp[l+1][r-1] == r - l - 1 && abs(w[l] - w[r]) <= 1) {\n          dp[l][r] = r - l + 1;\n        }\n        for(int k=l;k<=r-1;++k) {\n          dp[l][r] = max(dp[l][r], dp[l][k] + dp[k+1][r]);\n        }\n      }\n    }\n    cout << dp[0][n-1] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n// #define DEBUG\n\nconst int MAX_N = 300;\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N) {\n        vector<int> W(N);\n        rep(i, N) cin >> W[i];\n\n        bool dp[MAX_N][MAX_N] = {};\n        rep(i, MAX_N) {\n            dp[i][i] = true;\n        }\n\n        for (int len=2; len<=N; len+=2) {\n            for (int l=0; l<=N-len; l++) {\n                {\n                    int inner_len = len - 2;\n                    if (!(inner_len > 0 && !dp[l + 1][l + inner_len]) && abs(W[l] - W[l+ (len - 1)]) <= 1) {\n                        dp[l][l + (len - 1)] = true;\n                    }\n                }\n                if (len > 2) {\n                    int len2 = len - 2;\n                    if ((dp[l][l+1] && dp[l+2][l+2+len2-1]) ||\n                        (dp[l][l+len2-1] && dp[l+len2][l+len2+1])) {\n                        dp[l][l+len-1] = true;\n                    }\n                }\n            }\n        }\n\n        int dp2[MAX_N + 1] = {};\n        rep(r, N) {\n            if (r > 0) dp2[r] = dp2[r-1];\n            for (int len=2; len<=r+1; len+=2) {\n                int l = r - len + 1;\n#ifdef DEBUG\n                // DUMP(len);\n                // DUMP2(l, r);\n#endif\n                if (dp[l][r]) {\n                    if (l-1 >= 0) {\n                        dp2[r] = max(dp2[r], dp2[l-1] + len);\n                    } else {\n                        dp2[r] = max(dp2[r], len);\n                    }\n                }\n            } \n        }\n\n#ifdef DEBUG\n        rep(l, N) {\n            rep(r, N) cerr << dp[l][r] << \" \";\n            cerr << endl;\n        }\n        cerr << \"-----------------------------\" << endl;\n        rep(i, N) cerr << dp2[i] << \" \";\n        cerr << endl;\n#endif\n\n        cout << dp2[N-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nint main(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<=n;i+=2)\n      for(int j=0;j<n-i;j++){\ndp[j][j+i]=dp[j+1][j+i-1];\n        for(int k=1;k<i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=max(dp[j][j+i],i+1);\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nvector<tuple<int, int, int>>vec; int n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; vec.clear(); for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { vec.push_back(make_tuple(j - i, i, j)); } }\n\t\tsort(vec.begin(), vec.end());\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tint a1 = get<1>(vec[i]), a2 = get<2>(vec[i]);\n\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tint a1 = k, a2 = k + i, a3 = k + i + j; if (a3 > n)continue;\n\t\t\t\t\tdp[a1][a3 - 1] = max(dp[a1][a3 - 1], dp[a1][a2 - 1] + dp[a2][a3 - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep1(i,n) for(ll i=1;i<=(ll)(n);i++)\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(ll i=(ll)(n);i>0;i--)\n#define REP(i,a,b) for(ll i=(ll)a;i<(ll)b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 2e18;\nconst ll MOD = 1000000007;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n\nvii dp(310, vi(310));\nvi w(310);\n\nint calc(int l, int r) {\n  if (dp[l][r] >= 0) {\n    return dp[l][r];\n  }\n  if (r - l == 1) {\n    dp[l][r] = 0;\n    return 0;\n  }\n  if (r - l == 2) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      dp[l][r] = 2;\n    }\n    else {\n      dp[l][r] = 0;\n    }\n    return dp[l][r];\n  }\n  int res = calc(l + 1, r - 1);\n  if (res == (r - 1) - (l + 1) && abs(w[r - 1] - w[l]) <= 1) {\n    res += 2;\n    dp[l][r] = res;\n    return res;\n  }\n  for (int i = l + 1; i < r; i++) {\n    res = max(res, calc(l, i) + calc(i, r));\n  }\n  dp[l][r] = res;\n  return res;\n                                         \n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (!n) {\n      return 0;\n    }\n    rep (i, n) {\n      cin >> w[i];\n    }\n    rep (i, n + 3) {\n      rep (j, n + 3) {\n        dp[i][j] = -1;\n      }\n    }\n    cout << calc(0, n) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nusing usize = ::std::size_t;\n//using u64 = ::std::uint_least64_t;\ntypedef long long u64;\n//static constexpr u64 Inf = ::std::numeric_limits<u64>::max() / 2;\n\nu64 N;\nu64 dp[4010][4010], A[4010];\n\nu64 dfs(int l , int r){\n    if (~dp[l][r]) return dp[l][r];\n    if (r == l + 1) {\n        if (A[l] - A[r] > 1 || A[r] - A[l] > 1) {\n            return dp[l][r] = 0LL;\n        }\n        return dp[l][r] = 2LL;\n    } else if (r == l) {\n        return dp[l][r] = 0LL;\n    }\n    bool valid = false;\n    if (l + 1 < r - 1) {\n        int i = l + 1, j = r - 1;\n        dp[i][j] = dfs(i, j);\n        if (j - i + 1 > 2) {\n            for (int k = i; k < j; k++) {\n                if (dp[i][j] <= dfs(i, k) + dfs(k + 1, j)) {\n                    dp[i][j] = dp[i][k] + dp[k + 1][j];\n                }\n            }\n        }\n        \n        if (dp[i][j] == r - l - 1 && (A[l] - A[r] <= 1 && A[r] - A[l] <= 1)) {\n            valid = true;\n            if (dp[l][r] <= dp[i][j] + 2) {\n                dp[l][r] = dp[i][j] + 2;\n            }\n        }\n        \n    }\n    \n    if (!valid) {\n        for (int k = l; k < r; k++) {\n            if (dp[l][r] <= dfs(l, k) + dfs(k + 1, r)) {\n                dp[l][r] = dp[l][k] + dp[k + 1][r];\n            }\n        }\n    }\n    \n        \n    \n    \n    return dp[l][r];\n    \n}\n\nint main(int argc, char *argv[])\n{\n   \n \n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while (cin >> N, N != 0) {\n        for (int i = 0; i < N; i++) {\n            cin >> A[i];\n        }\n        \n        \n        memset(dp, -1, sizeof(dp));\n        dfs(0, N - 1);\n        \n        cout << dp[0][N - 1] << endl;\n        \n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n && n!=0){\n        int a[n];\n        for(int i=0;i<n;i++){\n            cin>>a[i];\n        }\n        bool ok[n][n]={};\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++) ok[i][i]=true;\n        for(int i=0;i<n-1;i++){\n            if(abs(a[i]-a[i+1])<=1) ok[i][i+1]=true;\n        }\n\n        for(int len=1;len<n;len+=2){\n            for(int i=0;i<n-len;i++){\n                for(int k=1;k<i+len;k++){\n                    if(ok[i][i+k] && ok[i+k+1][i+len]) ok[i][i+len]=true;\n                }\n                if(abs(a[i]-a[i+len])<=1 && ok[i+1][i+len-1]) ok[i][i+len]=true;\n                \n                if(ok[i][i+len]) mp[i+len].push_back(len+1);\n            }\n        }\n        \n        int dp[n]={};\n        for(int i=1;i<n;i++){\n            dp[i]=dp[i-1];\n            for(auto j:mp[i]){\n                if(i-j>=0) dp[i]=max(dp[i],dp[i-j]+j);\n                if(i-j==-1) dp[i]=max(dp[i],j);\n            }\n        }\n        cout<<dp[n-1]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, w[1004];\n\twhile(cin >> n, n){\n\n\t\trep(i,n) cin >> w[i];\n\n\t\tbool dp1[305][305]={};\n\t\tvector<pii> v;\n\t\trep(i,n-1) if( abs(w[i] - w[i+1]) < 2 ){\n\t\t\tdp1[i][i+1] = true;\n\t\t\tv.emplace_back(i, i+1);\n\t\t}\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\tif( i+k >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && 0 < i && i+k+1 < n ){\n\t\t\t\t\tif( abs(w[i-1] - w[i+k+1]) < 2 ){\n\t\t\t\t\t\tdp1[i-1][i+k+1] = true;\n\t\t\t\t\t\tv.emplace_back(i-1, i+k+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n) rep(i,n){\n\t\t\t\tif( i+k+j >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && dp1[i+k+1][i+k+j] ){\n\t\t\t\t\tdp1[i][i+k+j] = true;\n\t\t\t\t\tv.emplace_back(i, i+k+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for(auto t: v) cout << t.X << \",\" << t.Y << \" \"; cout << endl;\n\t\tsort( v.begin(), v.end() );\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\n\t\tint dp[900005] = {}, pos=0;\n\t\trep(i,n) rep(k,n){\n\t\t\tif( i+k >= n ) break;\n\t\t\tif( dp1[i][i+k] ){\n\t\t\t\tdp[i+k+1] = max( dp[i+k+1], dp[i] + k+1 );\n\t\t\t}\n\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n\t\t}\n\t\tcout << dp[n] << endl;\n//\t\trep(i,900002){\n//\t\t\twhile( pos < v.size() && v[pos].first == i ){\n//\t\t\t\tint d  = v[pos].X;\n//\t\t\t\tint nx = v[pos].Y + 1;\n//\t\t\t\tdp[nx] = max( dp[nx], dp[i] + nx - d );\n//\t\t\t\tpos++;\n//\t\t\t}\n//\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n//\t\t}\n//\t\tcout << dp[900002] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\n#define int long long\n#define double long double\n\n#define REP(i, b) for(int i = 0; i < (b); i++)\n#define REPS(i, b) for(int i = 1; i <= (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\nusing pi = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vpi = vector<pi>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while(true)\n    {\n        int n; cin >> n;\n        if(n == 0) break;\n\n        vi w(n); REP(i, n) cin >> w[i];\n        vvi dp(n, vi(n, 0)); \n        REP(i, n-1) if(abs(w[i] - w[i+1]) <= 1) dp[i][i+1] = 2;\n\n        for(int length = 3; length <= n; length++)\n        {\n            for(int l = 0; l + length <= n; l++)\n            {\n                int r = l + length - 1;\n                if(abs(w[l]-w[r]) <= 1 && dp[l+1][r-1] == length-2) dp[l][r] = length;\n                for(int k = l; k < r; k++) chmax(dp[l][r], dp[l][k]+dp[k+1][r]);\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    int a[n];\n    for(int i=0; i<n; i++) cin >> a[i];\n    int dp[n][n];\n    memset(dp,0,sizeof(dp));\n    for(int i=0; i<n-1; i++) {\n      if(abs(a[i]-a[i+1])<=1) dp[i][i+1]=1;\n    }\n    for(int i=0; i<n-1; i+=2) {\n      for(int l=0; l<n; l++) {\n        int r=l+i+1;\n        if(r>=n) break;\n        if(dp[l+1][r-1]&&abs(a[l]-a[r])<=1) dp[l][r]=1;\n      }\n      for(int l=0; l<n; l++) {\n        for(int r=l+1; r<n; r++) {\n          if(dp[l][r]) {\n            int x=l-i-2;\n            if(x>=0) {\n              if(dp[x][l-1]) dp[x][r]=1;\n            }\n            x=r+i+2;\n            if(x<n) {\n              if(dp[r+1][x]) dp[l][x]=1;\n            }\n          }\n        }\n      }\n    }\n    int d[n+1];\n    memset(d,-1,sizeof(d));\n    d[0]=0;\n    int ans=0;\n    for(int i=0; i<n; i++) {\n      d[i+1]=max(d[i+1],d[i]);\n      if(d[i]==-1) continue;\n      for(int j=i+1; j<n; j++) {\n        if(dp[i][j]) d[j+1]=max(d[j+1],d[i]+j-i+1);\n      }\n    }\n    for(int i=0; i<=n; i++) ans=max(ans,d[i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n && n!=0){\n\t\tvector<int> v(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tvector<vector<int> > dp(n,vector<int>(n,0));\n\t\tint ans=0;\n\t\tint mx=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tfor(int j=0;j<=n-i;j++){\n\t\t\t\tif(i==2){\n\t\t\t\t\tif(v[j]<=v[j+1]+1&&v[j]>=v[j+1]-1){\n\t\t\t\t\t\tdp[j][j+1] = 2;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(dp[j+1][j+i-2]==i-2&&v[j]<=v[j+i-1]+1&&v[j]>=v[j+i-1]-1){\n\t\t\t\t\t\tdp[j][j+i-1]=i;\n\t\t\t\t\t}\n\t\t\t\t\tmx = dp[j][j+i-1];\n\t\t\t\t\tfor(int k=0;k<=i-2;k++){\n\t\t\t\t\t\tmx = max(mx,dp[j][j+k]+dp[j+k+1][j+i-1]);\n\t\t\t\t\t\tdp[j][j+i-1] = mx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[0][n-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,w[300];\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>w[i];\n    int dp[300][300]={};\n    for(int i=1;i<n;i++)\n      for(int j=0;j+i<n;j++){\n\tfor(int k=j;k<j+i;k++)\n\t  dp[j][j+i]=max(dp[j][j+i],dp[j][k]+dp[k+1][j+i]);\n\tif(dp[j+1][j+i-1]==i-1&&abs(w[j]-w[j+i])<2)dp[j][j+i]=i+1;\n      }\n    cout<<dp[0][n-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nint d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nint dfs(int x,int y){\n  if(dp[x][y] != -1)return dp[x][y];\n  if(y - x <= 0)return dp[x][y] = 0;\n  int res = 0;\n  for(int i = x + 1;i < y;i++){\n    res = max(res,dfs(x,i) + dfs(i + 1,y));\n  }\n  if(abs(d[x] - d[y]) <= 1){\n    if(dfs(x+1,y-1) == y - x - 1){\n      res = max(res,dfs(x+1,y-1)+2);\n    }\n  }\n  return dp[x][y] = res;\n}\n\nint main(){\n  while(1){\n    clr(dp,-1);\n    cin >> n;\n    if(n == 0)break;\n    rep(i,0,n)cin >> d[i];\n    print(dfs(0,n-1));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//----***やべーやつら***----\nusing namespace std;\n#define int long long\n\n//----***型定義***----\nusing ll = long long;\nusing P = pair<int,int>;\n\n//----***Like a Pythonista***----\n#define REP(ii,jj,nn) for (ll ii=jj;ii<(nn);ii++)\n#define RREP(ii,nn,jj) for (ll ii = nn; jj<ii;ii--)\n#define each(i,...) for (auto&& i:__VA_ARGS__)\n#define ALL(vec) (vec).begin(),(vec).end()\n#define sum(...) accumulate(ALL(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(ALL(__VA_ARGS__),0.0)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\ntemplate<class T> inline auto max(const T& a){ return *max_element(ALL(a)); }\ntemplate<class T> inline auto min(const T& a){ return *min_element(ALL(a)); }\ninline ll gcd(ll a,ll b){if(b == 0) return a;return  gcd(b,a%b);}\ninline ll lcm(ll a,ll b){ll g = gcd(a,b);return a / g * b;}\n\n//----***定数***----\n#define MOD 1000000007\n#define INF 100000000000000000\n#define EPS 1e-9\nconst vector<vector<int>> DXY={{-1,0},{1,0},{0,-1},{0,1}};\n\n//----***パーツ***----\n#define fr first\n#define se second\n#define pb push_back\n\n//----***入出力***---\n#define print(out) cout<< out  << \"\\n\";\n#define debug(var)  do{std::cerr << #var << \" ↓ \"<<\"\\n\";view(var);}while(0);\n#define dbg cerr<<\"🥺🥺🥺🥺🥺🥺\"<<endl;\ntemplate<typename T> void view(T e){std::cout << e << std::endl;}\ntemplate<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cout << e << \" \"; } std::cout << std::endl;}\ntemplate<typename T> void view(const std::vector<std::vector<T> >& vv){ for(const auto& v : vv){ view(v); } }\n\n//----***初期時読み込み***----\nstruct initial{initial(){cin.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(15);};}initial_;\n\nsigned main(){\n  int N;\n  while(cin>>N,N){\n    vector<int> A(N);\n    REP(i,0,N)cin>>A[i];\n    vector<vector<int>>dp0(N,vector<int>(N,0));\n    REP(i,0,N-1){\n      if(abs(A[i]-A[i+1])<=1){\n        dp0[i][i+1]=2;\n      }\n    }\n    REP(w,1,N)REP(i,0,N-w){\n      REP(k,i+1,i+w+1){\n        dp0[i][i+w]=max(dp0[i][i+w],dp0[i][k-1]+dp0[k][i+w]);\n      }\n      if(dp0[i][i+w]==w+1&&i>0&&i+w<N-1&&abs(A[i-1]-A[i+w+1])<=1){\n        dp0[i-1][i+w+1]=dp0[i][i+w]+2;\n      }\n\n    }\n    print(dp0[0][N-1])\n\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<int> w(n); rep(i,n) cin >> w[i];\n    vector<vector<int>> dp(n+1,vector<int>(n+1));\n\n    // 区間DP\n    FOR(j,2,n+1){ // 区間長\n      for(int i = 0; i+j <= n; ++i){ // 区間左端 dp[i][i+j]を決定する\n\t//printf(\"[%d,%d)\\n\",i,i+j);\n\tFOR(k,2,j-1) // dp[i][i+k],dp[i+k][i+j]を元に計算\n\t  dp[i][i+j] = max(dp[i][i+j], dp[i][i+k]+dp[i+k][i+j]);\n\t\n\tif(abs(w[i] - w[i+j-1]) <= 1)\n\t  dp[i][i+j] = max(dp[i][i+j], dp[i+1][i+j-1] + 2);\n      }\n    }\n\n    cout << dp[0][n] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nconstexpr int NUM = 300;\nint w[NUM] = { 0 };\nbool dp[NUM] = {false}; //[???][???] = ?????¨??????????????????\n\nbool isDropedBetween(int a, int b) {\n\tif ((b - a) <= 1) return true;\n\tfor (int i = a + 1; i < b; i++) if (!dp[i]) return false;\n\treturn true;\n}\n\nbool isDroped(int a, int b) {\n\tfor (int i = a; i <= b; i++) if (!dp[i]) return false;\n\treturn true;\n}\n\nint main() {\n\tint n;\n\twhile (std::cin >> n && n) {\n\t\tstd::memset(dp, 0, sizeof(bool) * NUM);\n\t\tfor (int i = 0; i < n; i++) std::cin >> w[i];\n\n\t\tfor (int d = 1; d < n; d += 2) { //?????¨?????????\n\t\t\tfor (int i = 0; i < n - d; i++) { //?????¨?????´???\n\t\t\t\tbool mightDrop = false;\n\t\t\t\tif (isDropedBetween(i, i + d)) mightDrop = true; //???????????????????????¨????????¨??????\n\t\t\t\tif (isDroped(i, i + d) || (mightDrop && std::abs(w[i] - w[i + d]) <= 1)) {\n\t\t\t\t\tfor (int j = 0; j <= d; j++) dp[i + j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count[2] = {0};\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (dp[i]) count[1]++;\n\t\t\telse {\n\t\t\t\tcount[0] += count[1] / 2 * 2;\n\t\t\t\tcount[1] = 0;\n\t\t\t}\n\t\t}\n\t\tstd::cout << count[0] << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tint a[300],dp2[301] = {};\n\t\tbool dp1[301][301] = {};\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> a[i];\n\t\t\tdp1[i][i] = true;\n\t\t}\n\t\tfor(int i = 2;i <= n;i += 2){\n\t\t\tfor(int j = 0;j + i <= n;j++){\n\t\t\t\tfor(int k = 0;k <= i;k++){\n\t\t\t\t\tif(dp1[j][j + k] && dp1[j + k][j + i]) dp1[j][j + i] = true;\n\t\t\t\t}\n\t\t\t\tif(dp1[j + 1][j + i - 1] && abs(a[j] - a[j + i - 1]) <= 1) dp1[j][j + i] = true;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tdp2[i] = dp2[i - 1] + 1;\n\t\t\tfor(int j = 0;j <= i;j++){\n\t\t\t\tif(dp1[j][i]) dp2[i] = min(dp2[i],dp2[j]);\n\t\t\t}\n\t\t}\n\t\tcout << n - dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nvector<int> W;\nvector<vector<int>> dp;\n\nbool rec(int L, int R) {\n    auto& ret = dp[L][R];\n    if (ret >= 0) return ret;\n\n    if (L == R) return ret = 1;\n    if ((R - L) & 1) return ret = 0;\n\n    for (int i = L + 1; i < R; i += 2) {\n        if (abs(W[L] - W[i]) > 1) continue;\n        if (rec(L + 1, i) && rec(i + 1, R)) return ret = 1;\n    }\n    return ret = 0;\n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n\n    W.resize(N);\n    for (auto& w : W) cin >> w;\n\n    dp = vector<vector<int>>(N + 1, vector<int>(N + 1, -1));\n\n    vector<int> ans(N + 1, 0);\n    for (int i = 0; i < N; ++i) {\n        ans[i + 1] = max(ans[i], ans[i + 1]);\n        for (int len = 2; i + len <= N; ++len) {\n            if (rec(i, i + len)) {\n                ans[i + len] = max(ans[i + len], ans[i] + len);\n            }\n        }\n    }\n\n    cout << ans[N] << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\n#define INFI 1e9;\n\nint main() {\n\tint n;\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\t\tint* w = new int[n];\n\t\tfor (int i = 0;i < n;i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tint** dp = new int*[n];\n\t\tfor (int i = 0;i < n;i++) {\n\t\t\tdp[i] = new int[n - i];\n\t\t\tdp[i][0] = 1;\n\t\t\tif (i != n - 1) {\n\t\t\t\tif (abs(w[i] - w[i + 1]) <= 1) {\n\t\t\t\t\tdp[i][1] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][1] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\tfor (int i = 2;i < n;i++) {\n\t\t\tfor (int j = 0;j < n - i;j++) {\n\t\t\t\tif (dp[j + 1][i - 2] == 0 && abs(w[j] - w[j + i]) <= 1) {\n\t\t\t\t\tdp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = INFI;\n\t\t\t\t\tfor (int k = 0;k < i;k++) {\n\t\t\t\t\t\tdp[j][i] = min(dp[j][i], dp[j][k] + dp[j + k + 1][i - k - 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<n - dp[0][n - 1] << endl;\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e17;\n \n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\n\n\nint dp[303][303],N,a[303];\nint f(int i,int j){\n\tif(i>=j)return 0;\n\tif(dp[i][j]!=-1)return dp[i][j];\n\tif(i+1==j)return dp[i][j] = (abs(a[i]-a[i+1]) <= 1) * 2;\n\tif(f(i+1,j-1)==j-i-1&&abs(a[i]-a[j])<=1)return dp[i][j] = j-i+1;\n\tdp[i][j] = 0;\n\trep(mid,i+1,j+1){\n\t\tchmax(dp[i][j],f(i,mid-1)+f(mid,j));\n\t}\n\treturn dp[i][j];\n}\n\nsigned main()\n{\n\t//IOS();\n\tvector<int>ans;\n\twhile(1){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(!N)break;\n\t\trep(i,0,N)cin>>a[i];\n\t\trep(i,0,303)rep(j,0,303)dp[i][j] = -1;\n\t\tans.push_back(f(0,N-1));\n\t}\n\tfor(auto e:ans)cout<<e<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tint w[310];\n\t\tint dp[310][310]={};\n\t\tREP(i,0,n) cin>>w[i];\n\t\tfor(int k=1;k<n;k++){\n\t\t\tfor(int i=0;i+k<=n;i++){\n\t\t\t\tif(dp[i+1][i+k-1]==k-1)\n\t\t\t\t\tdp[i][i+k]=dp[i+1][i+k-1]+(abs(w[i]-w[i+k])<=1 ? 2 : 0);\n\t\t\t\tfor(int j=i+1;j<i+k;j++)\n\t\t\t\t\tdp[i][i+k]=max(dp[i][i+k],dp[i][j]+dp[j+1][i+k]);\n\t\t\t}\n\t\t}\n\t\tp(dp[0][n-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\nusing namespace std;\n#define REP(i,j,n) for(int i = j; i < (n); i++)\n\nvoid sol(int n) {\n    vector<int> a(n);\n    REP(i,0,n) cin >> a[i];\n\n    int dp[n+1][n+1];\n    REP(i,0,n+1) REP(j,0,n+1) dp[i][j] = 0;\n    REP(j,1,n+1){\n        REP(i,0,j){\n            dp[i][j] = dp[i][j-1];\n            if(i <= j-2) dp[i][j] = max(dp[i][j],dp[i][j-2]+(abs(a[j-1]-a[j-2])<=1)*2);\n            REP(k,i,j){\n                dp[i][j] = max(dp[i][j],dp[i][k]+dp[k+1][j-1]+(j-1 != k && (j-1)-(k+1) == dp[k+1][j-1] && abs(a[j-1]-a[k])<=1)*2);\n            }\n        }\n    }\n\n    cout << dp[0][n] << endl;\n\n    return;\n}\n\nint main() {\n    int n;\n    \n    while(cin >> n , n){\n        sol(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w[301];\nint dp[301][301];\nint daruma(int n, int i, int j){\n    if(dp[i][j]!=-1)    return dp[i][j];\n    if(n==1){\n        dp[i][j]=0;\n    }\n    else if(n==2){\n        if(abs(w[i]-w[i-1])<=1)   dp[i][j]=2;\n        else dp[i][j]=0;\n    }\n    else{\n        int max=0;\n        if(n>=4){\n            max=daruma(n-2, i-1, j+1);\n            if(max==n-2){\n                if(abs(w[i]-w[j])<=1)   max+=2;\n                else max+=0;\n            }\n            else max+=0;\n        }\n        for(int k=j+1; k<i; k++){\n            int sum=daruma(k-j+1, k, j)+daruma(i-k, i, k+1);\n            if(max<sum) max=sum;\n        }\n        dp[i][j]=max;\n    }\n    return dp[i][j];\n    \n}\n\nint main(void){\n    int N;\n    while(cin>>N){\n        if(N==0)    break;\n        for(int i=0; i<N; i++){\n            cin>>w[i];\n            for(int j=0; j<N; j++){\n                dp[i][j]=-1;\n            }\n        }\n        cout << daruma(N, N-1, 0)<<\"\\n\";\n        \n    }\n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\nint dfs(vvi &dp, vi &v, int i, int j) {\n\tif (dp[i][j] != -1)return dp[i][j];\n\tint ret = 0;\n\tchmax(ret, dfs(dp, v, i + 1, j));\n\tFOR(k, i + 1, j) {\n\t\tif (abs(v[k] - v[i]) <= 1 && dfs(dp, v, i + 1, k) == k - (i + 1)) {\n\t\t\tchmax(ret, (int)k - (i + 1) + 2 + dfs(dp, v, k + 1, j));\n\t\t}\n\t}\n\treturn dp[i][j] = ret;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvi v(n);\n\t\tREP(i, n)cin >> v[i];\n\t\tvvi dp(n + 1, vi(n + 1, -1));\n\t\tREP(i, n + 1)dp[i][i] = 0;\n\t\tcout << dfs(dp, v, 0, n) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tvector<int> ress;\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif (n == 0) { break; }\n\n\t\tvector<long long> w(n + 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tvector<vector<int>> dp(n + 1, vector<int>(n + 1));\n\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n - 1; i++) {\n\t\t\tif (abs(w[i] - w[i + 1]) <= 1) {\n\t\t\t\tdp[i][i + 1] = 1;\n\t\t\t\tres = 2;\n\t\t\t}\n\t\t}\n\n\t\tif (res == 0) { ress.push_back(0);  continue; }\n\t\tif (n <= 3) { ress.push_back(res); continue; }\n\n\t\tfor (int i = 1; i <= n - 3; i++) {\n\t\t\tif ((dp[i + 1][i + 2] == 1 && abs(w[i] - w[i + 3]) <= 1)\n\t\t\t\t|| (dp[i][i + 1] == 1 && dp[i + 2][i + 3] == 1)\n\t\t\t\t) {\n\t\t\t\tdp[i][i + 3] = 1;\n\t\t\t\tres = 4;\n\t\t\t}\n\t\t}\n//\t\tif (res == 2) { ress.push_back(2);  continue; }\n\t\tif (n <= 5) { ress.push_back(res); continue; }\n\n\t\tfor (int i = 5; i <= n - 1; i = i + 2) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (j + i > n) { continue; }\n\n\t\t\t\tbool okflg = false;\n\n\t\t\t\tfor (int length = 2; length <= i - 1; length = length + 2) {\n\n\t\t\t\t\tif (dp[j][j +length-1] == 1 && dp[j + length][j + i] == 1) { \n\t\t\t\t\t\tokflg = true; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (okflg) { \n\t\t\t\t\tdp[j][j + i] = 1;\n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\n\t\t\t\tif (abs(w[j] - w[j + i]) <= 1) {\n\n\t\t\t\t\tif (dp[j + 1][j + i - 1] == 1) { okflg = true; }\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int length = 2; length <= i - 3; length = length + 2) {\n\t\t\t\t\t\t\tif (dp[j + 1][j +1+ length - 1] == 1\n\t\t\t\t\t\t\t\t&& dp[j + 1+length][j + i - 1] == 1\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tokflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (okflg == true) {\n\t\t\t\t\tdp[j][j + i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres = 0;\n\t\tint i = 1;\n\t\twhile (i < n) {\n\t\t\tfor (int j = n; j >= i + 1; j--) {\n\t\t\t\tif (dp[i][j] == 1) {\n\t\t\t\t\tres += j - i + 1;\n\t\t\t\t\ti = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tint res2 = 0;\n\t\ti = n;\n\t\twhile (i >1) {\n\t\t\tfor (int j = 1; j <=n- 1; j++) {\n\t\t\t\tif (dp[j][i] == 1) {\n\t\t\t\t\tres2 += i-j + 1;\n\t\t\t\t\ti = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\n\t\tres = max(res, res2);\n\n\t\tress.push_back(res);\n\t}\n\tfor (int i = 0; i < ress.size(); i++) {\n\t\tcout << ress[i] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, s, n) for(int i = s; i < n; i++)\nusing namespace std;\n\nll n;\nll block[301];\nll dp[301][301];\nll f(ll under, ll top){\n  if (dp[under][top] != -1) return dp[under][top];\n  if (top-under <= 1) return 0;\n  ll res = 0;\n  if (abs(block[under] - block[top-1]) <= 1 && f(under+1, top-1) == top-under-2){\n    res = top - under;\n  }\n  rep2(middle, under+1, top){\n    res = max(res, f(under, middle) + f(middle, top) );\n  }\n  return dp[under][top] = res;\n}\n\nint main(){\n  while(1){\n    cin >> n;\n    if (n == 0) break;\n    rep(i, n) cin >> block[i];\n    memset(dp, -1, sizeof(dp));\n    cout << f(0, n) << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nvector<int> a;         //命令 a[1]-a[n] 1-n ->0-9,u\nvector<vector<int> > ok;\n//vector<vector<int> > doteki;\nint n;\nint sec(int p,int q);\nvoid pr();\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    int f=0;\n    a.assign(n,0);\n    ok.assign(n,a);\n    //doteki.assign(n,a);\n    for(int t=0;t<n;t++){\n      scanf (\"%d\",&a[t]);\n    }\n    for(int s=0;(s+1)<n;++s){\n      ok[s][s+1]=sec(s,s+1);\n    }\n    for(int t=3;t<n;t=t+2){\n      for(int s=0;(s+t)<n;++s){\n        f=0;\n        for(int u=1;u<t-1;u=u+2){\n          if(ok[s][s+u]&&ok[s+u+1][s+t]){\n            f=1;\n          }\n        }\n        if(f==1||(sec(s,s+t)&&ok[s+1][s+t-1])){\n          ok[s][s+t]=t+1;\n        }\n      }\n    }\n\n\n    for(int x=1;x<n;++x){\n      for(int y=0;y+x<n;++y){\n        for(int z=y;z<y+x;++z){\n          ok[y][y+x]=max(ok[y][y+x],ok[y][z]+ok[z+1][y+x]);\n        }\n        //pr();\n      }\n    }\n    printf(\"%d\\n\",ok[0][n-1]);\n    scanf (\"%d\",&n);\n  }\n}\n\n\n\n//変化したところだけ見る\n\n\n\nint sec(int p,int q){\n  if(-1<=(a[p]-a[q])&&(a[p]-a[q])<=1){\n    return 2;\n    //ok[p][q]=1;\n  }\n  else{\n    return 0;\n    //ok[p][q]=0;\n  }\n}\n\nvoid pr(){\n  for(int x=0;x<n;++x){\n    for(int y=0;y<n-1;++y){\n      printf(\"%d \",ok[x][y]);\n    }\n    printf(\"%d\\n\",ok[x][n-1]);\n  }\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,data[301];\n\tbool** table = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tint** maximum = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tmaximum[i] = new int[301];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 1; k <= N; k++)maximum[i][k] = 0;\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1){\n\t\t\t\ttable[i][1] = true;\n\t\t\t\tmaximum[i][i+1] = 2;\n\t\t\t}\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tif((table[left][1] == true && table[left+2][(length-2)/2] == true) || //????????¨?????£???????¶????????????????????????????2????????£??????length-2??????????¶?????????´???\n\t\t\t\t\t(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)){ //??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t\tmaximum[left][left+length-1] = length; //????¨?????????§??????OK????????§?????¶????????§???????¨????\n\t\t\t\t}else{\n\t\t\t\t\t//maximum[left][left+length-1]?????´??°????????°????????????\n\t\t\t\t\tfor(int i = 2; i <= length-2; i+= 2){\n\t\t\t\t\t\tmaximum[left][left+length-1] = max(maximum[left][left+length-1],maximum[left][left+i-1]+maximum[left+i][left+length-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(N%2 == 0)printf(\"%d\\n\",maximum[1][N]);\n\t\telse{\n\t\t\tprintf(\"%d\\n\",max(maximum[1][N-1],maximum[2][N]));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint a[300];\nint dp1[300][301]; // [l, r)\nint dp2[301];\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) scanf(\"%d\", a + i);\n\t\t\n\t\tmemset(dp1, 0, sizeof(dp1));\n\t\tREP(i, N - 1) if (abs(a[i] - a[i + 1]) <= 1) dp1[i][i + 2] = 2;\n\t\tFOR(w, 4, N + 1) {\n\t\t\tREP(i, N - w + 1) {\n\t\t\t\tint l = i, r = i + w; // [l, r)\n\t\t\t\tFOR(k, l + 1, r) { // [l, k), [k, r)\n\t\t\t\t\tif (dp1[l][k] && dp1[k][r]) dp1[l][r] = w;\n\t\t\t\t}\n\t\t\t\tif (abs(a[l] - a[r - 1]) <= 1 && dp1[l+1][r-1]) dp1[l][r] = w;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(dp2, 0, sizeof(dp2));\n\t\tREP(i, N) {\n\t\t\tFOR(j, i + 1, N + 1) chmax(dp2[j], dp2[i] + dp1[i][j]);\n\t\t\tchmax(dp2[i + 1], dp2[i]);\n\t\t}\n\t\t\n\t\tif (debug) printf(\"@ \");\n\t\tcout << dp2[N] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nconst double EPS = 1e-8;\n\ntemplate<typename T> T chmax(T& a, const T& b){return a = (a > b ? a : b);}\ntemplate<typename T> T chmin(T& a, const T& b){return a = (a < b ? a : b);}\n\nvi w;\n\nvector<vi> dp;\n\nint calc(int l, int r) {\n    if(dp[l][r] >= 0) return dp[l][r];\n    auto& ret = dp[l][r];\n    if(r - l == 1) return ret = 0;\n    if(r - l == 2) {\n        if(abs(w[l] - w[l+1]) <= 1) return ret = 2;\n        else return ret = 0;\n    }\n    if(abs(w[l] - w[r-1]) <= 1) {\n        int tmp = calc(l+1, r-1);\n        if(tmp == r - l - 2) chmax(ret, tmp + 2);\n    }\n    for(int m = l + 1; m < r; ++m) {\n        chmax(ret, calc(l, m) + calc(m, r));\n    }\n    return ret;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    if(n == 0) exit(0);\n    w.resize(n);\n    rep(i, n) cin >> w[i];\n    dp = vector<vi>(n+1, vi(n+1, -1));\n    cout << calc(0, n) << endl;\n}\n\nint main(){\n    while(1) solve();    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tint w[301];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> w[i];\n\t\t}\n\t\tvector<vector<bool> > canerase(n + 1, vector<bool>(n + 1, false));\n\t\t// canerase[i][j] = i番目のやつから数えてj個(i番目を含む)を落とせるか\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tcanerase[i][2] = (abs(w[i] - w[i + 1]) <= 1);\n\t\t}\n\t\tfor(int i = 4; i <= n; i++){\n\t\t\tfor(int j = 0; i + j <= n; j++){\n\t\t\t\tcanerase[j][i] = (abs(w[j] - w[i + j - 1]) <= 1) && canerase[j + 1][i - 2];\n\t\t\t\tfor(int k = 2; k <= i; k++){\n\t\t\t\t\tcanerase[j][i] = canerase[j][i] || (canerase[j][k] && canerase[j + k][i - k]);\n\t\t\t\t\t// cout << canerase[j][i] << endl;\n\t\t\t\t}\n\t\t\t\t// cout << j << \" \" << i << \" \" << (canerase[j][i]?1:2) << endl;\n\t\t\t}\n\t\t}\n\t\tint maxnum[301][301] = {};\n\t\tint ans = 0;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tfor(int j = 0; i + j <= n; j++){\n\t\t\t\tif(canerase[j][i]) maxnum[j][i] = i;\n\t\t\t\tfor(int k = 2; k <= i; k++){\n\t\t\t\t\tmaxnum[j][i] = max(maxnum[j][i], maxnum[j][k] + maxnum[j + k][i - k]);\n\t\t\t\t}\n\t\t\t\tans = max(ans, maxnum[j][i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvi num(n);\n\t\tREP(i, n)\n\t\t\tcin >> num[i];\n\t\tvector<vector<bool>> able(n, vb(n, false));\n\t\tfor (int i = 2;i < n + 1;i += 2) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++) {\n\t\t\t\tif (i == 2) {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1)\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1 && able[j + 1][j + i - 2])\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t\tREP(k, i / 2 - 1)\n\t\t\t\t\t\tif (able[j][j + k * 2 + 1] && able[j + k * 2 + 2][j + i - 1])\n\t\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvi DP(n, vi(n, 0));\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tif (able[i][j])\n\t\t\t\tDP[i][j] = j - i + 1;\n\t\tfor (int i = 3;i < n + 1;i++) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++)\n\t\t\t\tREP(k, i)\n\t\t\t\tDP[j][j + i - 1] = max(DP[j][j + i - 1], DP[j][j + k] + DP[j + k+1][j + i - 1]);\n\t\t}\n\t\tcout << DP[0][n - 1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\nint main(){\n    while(1){\n        int N;cin >> N;\n        if(N != 0){\n            vector<int> vec;\n            for(int a = 0;a < N;a++){\n                int b;cin >> b;\n                vec.push_back(b);\n            }\n            int dp[N+1][N+1];\n            for(int a = 0;a <= N;a++){\n                for(int b = 0;b <= N;b++){\n                    dp[a][b] = -1;\n                }\n            }\n            std::function<int(int,int)> calc = [&](int l, int r){\n                if(dp[l][r] != -1)return dp[l][r];\n\n                if(abs(l - r) <= 1)return 0;\n\n                int ins = 0;\n\n                if(abs(vec.at(l) - vec.at(r-1)) <= 1 && calc(l+1,r-1) == r - l -2){\n                    ins = r - 1;\n                }\n                for(int mid = l + 1 ;mid <= r -1 ;mid++){\n                    ins = max(ins, calc(l,mid) + calc(mid, r));\n                }\n                return dp[l][r] = ins;\n            };\n            calc(0,N);\n            cout<<dp[0][N]<<endl;\n        }else{\n            return 0;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 2; } }\n\t\tfor (int h = 0; h < 10; h++) {\n\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tint a1 = j, a2 = i + j - 1; if (a2 >= n)continue;\n\t\t\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = i + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\tint a1 = j, a3 = i + j; if (a3 >= n)continue;\n\t\t\t\t\tfor (int k = a1 + 1; k <= a3; k++) {\n\t\t\t\t\t\tint a2 = k;\n\t\t\t\t\t\tdp[a1][a3] = max(dp[a1][a3], dp[a1][a2 - 1] + dp[a2][a3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0}; \n\nint n;\nint data[300];\nint dp[300][301]; // hankai\nint score[300][301];\n\nvoid make(int st, int en)\n{\n    if (dp[st][en]) return;\n    dp[st][en] = 1;\n    if (0 <= st - 2 && abs(data[st-2] - data[st-1] ) < 2 ) {\n        make(st-2, en);\n    }\n    if (0 <= st - 1 && en < n && abs(data[st-1] - data[en]) < 2) {\n        make(st-1, en+1);\n    }\n    if (en + 1 < n && abs(data[en] - data[en+1]) < 2) {\n        make(st, en+2);\n    }\n}\n\nint solve(int st, int en)\n{\n    //cout << \"call : \" << st << \" \" << en << endl;;\n    if ( dp[st][en] ) {\n        //cout << \" ret1 : 0\" << endl;\n        return score[st][en] = dp[st][en] = 0;\n    }\n    if ( score[st][en] ) {\n        //cout << \" ret2 : \" << score[st][en] << endl;\n        return score[st][en];\n    }\n    if (en - st < 2) {\n        //cout << \" ret3 : \" << en - st << endl;\n        return score[st][en] = en - st;\n    }\n    int ret = en - st;\n    for (int i = st+2; i < en; i++) {\n        if (dp[st][i]) {\n            ret = min(solve(i, en), ret);\n        }\n    }\n    return score[st][en] = min(ret, 1+solve(st+1, en));\n    //score[st][en] = min(ret, 1+solve(st+1, en));\n    //cout << score[st][en] << endl;\n    //return score[st][en];\n}\n\nsigned main() \n{ \n    std::ios::sync_with_stdio(false); \n    std::cin.tie(0); \n\n    cin >> n;\n    while ( n ) {\n        memset(data, 0, sizeof(data));\n        memset(dp, 0, sizeof(dp));\n        memset(score, 0, sizeof(score));\n        rep(i, n) cin >> data[i];\n        rep(i, n-1) if ( abs(data[i] - data[i+1]) < 2 )\n            make(i, i+2);\n        cout << n - solve(0, n) <<endl;\n        cin >> n;\n    }\n\n    return 0; \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\nint main() {\n\twhile (true) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tvi a(N);\n\t\trep(i, N)cin >> a[i];\n\t\tvvi dp(N, vi(N + 1, 0));\n\t\trepl(w, 1, N + 1) {\n\t\t\trep(i, N) {\n\t\t\t\tint j = i + w;\n\t\t\t\tif (j > N)continue;\n\t\t\t\tif (w >= 2 && dp[i + 1][j - 1] == (w - 2) && abs(a[i] - a[j - 1]) <= 1) {\n\t\t\t\t\tdp[i][j] = w;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trepl(k, i + 1, j) {\n\t\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i, N) {\n\t\t\trepl(j, 1, N + 1) {\n\t\t\t\tcout << dp[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << dp[0][N] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nint w[300], dp[301][301];\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    if(!n)break;\n\n    rep(i, n)scanf(\"%d\", w+i);\n    rep(i, n + 1)rep(j, n + 1)dp[i][j] = 0;\n\n    rep(i, n - 1)dp[i][i + 2] = (abs(w[i + 1] - w[i]) <= 1) * 2;\n\n    rep(i, n + 1)rep(j, i){\n      for(int k = j;k < i;++k)dp[j][i] = max(dp[j][i], dp[j][k] + dp[k][i]);\n      if(i - j >= 2 && abs(w[i - 1] - w[j]) <= 1 && dp[j + 1][i - 1] == i - j - 2)\n      dp[j][i] = i - j;\n    }\n    //rep(i, n + 1)rep(j, n + 1)if(dp[i][j] > 0)pri3(i, j, dp[i][j]);\n    pri(dp[0][n]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void){\n    while(1){\n        int n;\n        cin>>n;\n        if(n==0){\n            break;\n        }\n        int w[310];\n        for(int i=0;i<n;i++){\n            cin>>w[i];\n        }\n        int dp[310][310];\n        int dp2[310][310];\n        //dp[i][j] range(i,j)\n        //0<=i<=j<=n\n        for(int i=0;i<=n;i++){\n            for(int j=0;j<=n;j++){\n                dp[i][j]=0;\n                dp2[i][j]=0;\n            }\n        }\n        for(int a=0;a<=n;a++){\n            for(int b=0;b+a<=n;b++){\n                int i,j;\n                i=b;j=b+a;\n                if (a==0){\n                    dp[i][j]=1;\n                }\n                for(int k=i;k<=j;k++){\n                    if (dp[i][k]==1 && dp[k][j]==1){\n                        dp[i][j]=1;\n                    }\n                }\n                if(dp[i][j]==1){\n                    if (i-2>=0 && abs(w[i-2]-w[i-1])<=1){\n                        dp[i-2][j]=1;\n                    }\n                    if (j+2<=n && abs(w[j]-w[j+1])<=1){\n                        dp[i][j+2]=1;\n                    }\n                    if (i-1>=0 && j+1<=n && abs(w[i-1]-w[j])<=1){\n                        dp[i-1][j+1]=1;\n                    }\n                }\n                //cout<<dp[i][j]<<\" \";\n            }\n            //cout<<endl;\n        }\n        for(int a=0;a<=n;a++){\n            for(int b=0;b+a<=n;b++){\n                int i,j;\n                i=b;j=b+a;\n                if (dp[i][j]==1){\n                    dp2[i][j]=j-i;\n                }\n                for(int k=i;k<=j;k++){\n                    dp2[i][j]=max(dp2[i][j],dp2[i][k]+dp2[k][j]);\n                }\n                //cout<<dp2[i][j]<<\" \";\n            }\n            //cout<<endl;\n        }\n        cout<<dp2[0][n]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        int w[n];\n        for (auto &wi:w) cin >> wi;\n        bool erase[n][n];\n        fill(erase[0], erase[n], false);\n        for (int d=1; d<n; d++) {\n            for (int i=0; i+d<n; i++) {\n                if ((d == 1 || erase[i+1][i+d-1]) && abs(w[i] - w[i+d]) <= 1)\n                    erase[i][i+d] = true;\n                for (int j=i+1; j+1<i+d; j++) {\n                    if (erase[i][j] && erase[j+1][i+d]) erase[i][i+d] = true;\n                }\n            }\n        }\n        int dp[n+1];\n        fill(dp, dp+n+1, 0);\n        for (int i=0; i<n; i++) {\n            for (int j=i+1; j<n; j++) {\n                if (erase[i][j]) {\n                    dp[j+1] = max(dp[j+1], dp[i] + j - i + 1);\n                }\n            }\n            dp[i+1] = max(dp[i+1], dp[i]);\n        }\n        cout << dp[n] << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nint ans;\nvoid next(int z,int r,int y,vector<int> b);\nint n;\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    ans=n;\n    a.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d\",&a[t]);\n    }\n    for(int t=0;t<n-1;t++){\n      if(-1<=(a[t]-a[t+1])&&(a[t]-a[t+1])<=1){\n        next(t,t+1,n,a);\n      }\n    }\n\n    ans=n-ans;\n    printf(\"%d\\n\",ans);\n    scanf (\"%d\",&n);\n  }\n}\n\n\n\nvoid next(int z,int r,int y,vector<int> b){\n  b[z]=0;\n  b[r]=0;\n  y=y-2;\n  //printf(\"%ld\\n\",b.size());\n  if(y<ans){\n    ans=y;\n  }\n  int s;\n  int u;\n  for(s=0;b[s]==0&&s<n-1;s++){}\n  if(s==n-1) return;\n  for(;s<n-1;s++){\n    for(u=s+1;b[u]==0&&u<n;u++){}\n    if(u==n) continue;\n    if(-1<=(b[s]-b[u])&&(b[s]-b[u])<=1){\n      next(s,u,y,b);\n    }\n  }\n}\n\n\n//変化したところだけ見る\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint dp[301][301];\nint w[301];\nint main(){\n    int n;\n    while(cin>>n,n){\n        rep(i,n)cin>>w[i];\n        memset(dp,0,sizeof(dp));\n        FOR(d,2,n+1){\n            rep(i,n-d+1){\n                int l=i,r=i+d-1;\n                if(abs(w[l]-w[r])<2&&dp[l+1][r-1]==d-2) dp[l][r]=dp[l+1][r-1]+2;\n                else{\n                    int mx=0;\n                    FOR(j,l,r) mx=max(mx,dp[l][j]+dp[j+1][r]);\n                    dp[l][r]=max(mx,dp[l][r]);\n                }\n            }\n        }\n        cout<<dp[0][n-1]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nbool used[310][310];\nbool dp[310][310];\nvi w;\n\nint dp2[310][310];\ntemplate<typename T> T chmax(T& a, const T& b){return a = max(a, b);}\ntemplate<typename T> T chmin(T& a, const T& b){return a = min(a, b);}\n//[l, r) de tatakeruka\nbool calc(int l, int r) {\n\tif(r - l <= 1) return false;\n\tif(used[l][r]) return dp[l][r];\n\tused[l][r] = true;\n\tif(r - l == 2) {\n\t\treturn dp[l][r] = (abs(w[l] - w[r-1]) <= 1);\n\t}\n\tfor(int m = l + 1; m < r; m++) {\n\t\tbool f = true;\n\t\tf &= calc(l, m);\n\t\tf &= calc(m, r);\n\t\tdp[l][r] |= f;\n\t}\n\tif(abs(w[l]-w[r-1]) <= 1) dp[l][r] |= calc(l+1, r-1);\n\treturn dp[l][r];\n}\n\nint calc2(int l, int r) {\n\tif(dp2[l][r] != -1) return dp2[l][r];\n\tif(r - l <= 1) return dp2[l][r] = 0;\n\tif(dp[l][r]) return dp2[l][r] = r - l;\n\tint ret = 0;\n\tfor(int m = l + 1; m < r; m++) {\n\t\tchmax(ret, calc2(l, m)+calc2(m, r));\n\t}\n\treturn dp2[l][r] = ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n) {\n\t\tw.clear();\n\t\tw.resize(n);\n\t\trep(i, n) cin >> w[i];\n\t\trep(i, 310) rep(j, 310) dp[i][j] = used[i][j] = false, dp2[i][j] = -1;\n\t\tREP(r, 1, n+1) rep(l, r) calc(l, r);\n\t\tcout << calc2(0, n) << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define INF 1e9\ntypedef long long ll;\n\n\n\n\nint main() {\n    while(1){\n        int n;\n        cin >> n;\n        if (n == 0)break;\n\n        vector<int> w(n);\n        REP(i,n) cin >> w[i];\n\n        vector<vector<int>> dp(n,vector<int>(n,0));\n\n        for(int width=2; width<=n; width++){//もらうDP\n            FOR(left,0,n-width+1){\n                int right = left+width-1;\n                if(width%2==0 && dp[left+1][right-1]==width-2){//内側の区間が適切に処理でき、\n                    if(abs(w[left] - w[right])<=1){//端の差が1以下なら\n                        dp[left][right] = width;\n                    }\n                }\n\n                for(int mid=left; mid<right; mid++){\n                    dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid+1][right]);\n                }\n                \n            }\n        }\n\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n\ntypedef pair<int, int> P;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint n, w[305];\nint dp[305][305];\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tREP(i, n) cin >> w[i];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tdp[i][i] = 0;\n\t\t\tdp[i][i + 1] = 0;\n\t\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\t\tif (i + 1 < j && abs(w[i] - w[j - 1]) <= 1 && dp[i + 1][j - 1] == j - i - 2) {\n\t\t\t\t\tdp[i][j] = j - i;\n\t\t\t\t}\n\t\t\t\tfor (int k = j + 1; k <= n; ++k) {\n\t\t\t\t\tchmax(dp[i][k], dp[i][j] + dp[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dp[0][n] << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n#define EQ(a,b) (abs(a - b) < 1e-10)\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<LL> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<bool> VB;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\nint n;\nVI w;\ntypedef bitset<300> bit;\nstruct Comp {\n\tbool operator() (const bit &a,const bit &b) {\n\t\treturn a.to_ullong() < b.to_ullong();\n\t}\n};\nmap<bit,int,Comp> memo;\nint dfs(bit state) {\n\tif (IN(state,memo)) return memo[state];\n\tint num = 0,fi;\n\tREP(i,n-1) {\n\t\tif ((!state[i])) {\n\t\t\tfi = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFOR(i,fi+1,n) {\n\t\tif (!state[i]){\n\t\t\tif (abs(w[i] - w[fi]) <= 1) {\n\t\t\t\tbit next = (state | bit(1<<i) | bit(1<<(fi)));\n\t\t\t\tnum = max(dfs(next)+2,num);\n\t\t\t}\n\t\t\tfi = i;\n\t\t}\n\t}\n\treturn memo[state] = num;\n}\n\nint main(void) {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tw.resize(n);\n\t\tREP(i,n) cin >> w[i];\n\t\tcout << dfs(bit(0)) << endl;\n\t\tmemo.clear();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nstruct Context {\n\tstd::vector<int>& blocks;\n\tstd::unordered_map<uint64_t, int> cache;\n};\n\nstruct State {\n\tuint64_t data;\n\n\tState() : data(0) {}\n\tState(uint64_t data) : data(data) {}\n\n\tState mark(int index) {\n\t\treturn data | (((uint64_t)1) << index);\n\t}\n\n\tbool is_marked(int index) {\n\t\treturn (data & (((uint64_t)1) << index)) != 0;\n\t}\n};\n\nint search(Context& ctx, State state, int count) {\n\tif (ctx.blocks.size() == 0) return count;\n\tauto cache_iter = ctx.cache.find(state.data);\n\tif (cache_iter != ctx.cache.end()) return (*cache_iter).second;\n\n\tint max = count;\n\n\tfor (int i = 0; i < ctx.blocks.size() - 1; i++) {\n\t\tif (state.is_marked(i)) continue;\n\n\t\t// ?¬????????????????????????¢???\n\t\tfor (int j = i + 1; j < ctx.blocks.size(); j++) {\n\t\t\tif (state.is_marked(j)) continue;\n\t\t\tif (std::abs(ctx.blocks[i] - ctx.blocks[j]) > 1) break;\n\n\t\t\tint result = search(ctx, state.mark(i).mark(j), count + 2);\n\t\t\tif (result > max) max = result;\n\t\t}\n\t}\n\n\tctx.cache[state.data] = max;\n\treturn max;\n}\n\nint main()\n{\n\tstd::vector<int> blocks;\n\tblocks.reserve(300);\n\n\twhile (true) {\n\t\tint num_blocks;\n\t\tstd::cin >> num_blocks;\n\n\t\tif (num_blocks == 0) return 0;\n\n\t\tblocks.clear();\n\t\tfor (int i = 0; i < num_blocks; i++)\n\t\t{\n\t\t\tint w;\n\t\t\tstd::cin >> w;\n\t\t\tblocks.push_back(w);\n\t\t}\n\n\t\tContext ctx{ blocks, {} };\n\t\tstd::cout << search(ctx, {}, 0) << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n#define SAY_YES cout << \"YES\" << endl;\n#define SAY_Yes cout << \"Yes\" << endl;\n#define SAY_NO cout << \"NO\" << endl;\n#define SAY_No cout << \"No\" << endl;\n#define IFYES(TRUE_OR_FALSE)   \\\n    if (TRUE_OR_FALSE)         \\\n    {                          \\\n        cout << \"YES\" << endl; \\\n    }                          \\\n    else                       \\\n    {                          \\\n        cout << \"NO\" << endl;  \\\n    }\n#define IFYes(TRUE_OR_FALSE)   \\\n    if (TRUE_OR_FALSE)         \\\n    {                          \\\n        cout << \"Yes\" << endl; \\\n    }                          \\\n    else                       \\\n    {                          \\\n        cout << \"No\" << endl;  \\\n    }\n#define IFyes(TRUE_OR_FALSE)   \\\n    if (TRUE_OR_FALSE)         \\\n    {                          \\\n        cout << \"yes\" << endl; \\\n    }                          \\\n    else                       \\\n    {                          \\\n        cout << \"no\" << endl;  \\\n    }\n#define DEBUG_OUTPUT_ARRAY(XXX, ONE)                            \\\n    for (int i = 0; i < (ONE); i++)                             \\\n    {                                                           \\\n        cout << \"DEBUG: i = \" << i << \" -> \" << XXX[i] << endl; \\\n    }\n#define DEBUG_OUTPUT_ARRAY2(XXX, ONE, TWO)                             \\\n    for (int i = 0; i < (ONE); i++)                                    \\\n    {                                                                  \\\n        cout << \"<<< i = \" << i << \" >>>\" << endl;                     \\\n        for (int j = 0; j < (TWO); j++)                                \\\n        {                                                              \\\n            cout << \"DEBUG: j = \" << j << \" -> \" << XXX[i][j] << endl; \\\n        }                                                              \\\n    }\n#define DEBUG_OUTPUT_ARRAY2_BOX(XXX, ONE, TWO) \\\n    for (int i = 0; i < (ONE); i++)            \\\n    {                                          \\\n        cout << i << \"  \";                     \\\n        for (int j = 0; j < (TWO); j++)        \\\n        {                                      \\\n            cout << XXX[i][j] << \" \";          \\\n        }                                      \\\n        cout << endl;                          \\\n    }\n\ntypedef pair<long long int, long long int> pll;\n\n\nconst long long int mod = 1000000007;\nconst long long int INF = 19999999999999;\n\nlong long int N,w[305],dp[305][305]={};\nint main()\n{\n    cout << fixed << setprecision(18);\n    \n    cin>>N;\n    while(N!=0){\n        for(long long int i = 1; i <= N; i++){\n            cin>>w[i];\n        }\n        for(long long int i = 0; i <= N+1; i++){\n            for(long long int j = 0; j <= N+1; j++){\n                dp[i][j]=0;\n            }\n        }\n        for(long long int i = 2; i <= N; i+=2){\n            if(i==2){\n                for(long long int j = 1; j < N; j++){\n                    if(abs(w[j]-w[j+1])<=1){\n                        dp[j][j+2]=2;\n                    }else{\n                        dp[j][j+2]=0;\n                    }\n                }\n            }else{\n                for(long long int j = 1; j < N-i+2; j++){\n                    if(dp[j+1][j+i-1]==i-2){\n                        if(abs(w[j]-w[j+i-1])<=1){\n                            dp[j][j+i]=max(dp[j][j+i],i);\n                        }else{\n                            \n                            dp[j][j+i]=max(dp[j][j+i],i-2);\n                        }\n                    }\n                    for(long long int k = 0; k < i; k+=2){\n                        dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k][j+i]);\n                    }\n                    \n                }\n            }\n        }\n        long long int res=0;\n        if(N%2==1){\n            res=max(dp[1][N],dp[2][N+1]);\n        }else{\n            res=dp[1][N+1];\n        }\n        cout<<res<<endl;\n        cin>>N;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, w[1004];\n\twhile(cin >> n, n){\n\n\t\trep(i,n) cin >> w[i];\n\n\t\tbool dp1[305][305]={};\n\t\tvector<pii> v;\n\t\trep(i,n-1) if( abs(w[i] - w[i+1]) < 2 ){\n\t\t\tdp1[i][i+1] = true;\n\t\t\tv.emplace_back(i, i+1);\n\t\t}\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\tif( i+k >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && 0 < i && i+k+1 < n ){\n\t\t\t\t\tif( abs(w[i-1] - w[i+k+1]) < 2 ){\n\t\t\t\t\t\tdp1[i-1][i+k+1] = true;\n\t\t\t\t\t\tv.emplace_back(i-1, i+k+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n) rep(i,n){\n\t\t\t\tif( i+k+j >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && dp1[i+k+1][i+k+j] ){\n\t\t\t\t\tdp1[i][i+k+j] = true;\n\t\t\t\t\tv.emplace_back(i, i+k+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for(auto t: v) cout << t.X << \",\" << t.Y << \" \"; cout << endl;\n\t\tsort( v.begin(), v.end() );\n\n\t\tint dp[900005] = {}, pos=0;\n\t\trep(i,900002){\n\t\t\twhile( pos < v.size() && v[pos].first == i ){\n\t\t\t\tint d  = v[pos].X;\n\t\t\t\tint nx = v[pos].Y + 1;\n\t\t\t\tdp[nx] = max( dp[nx], dp[i] + nx - d );\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n\t\t}\n\t\tcout << dp[900002] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1611&lang=jp\n// references : http://ferin-tech.hatenablog.com/entry/2017/05/17/123005\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<int> w(n);\n\t\tfor (int i = 0; i < n;i++)cin >> w[i];\n\t\tvector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n\n\t\tfor (int W = 2; W <= n; W++) {\n\t\t\tfor (int l = 0; l < n;l++) {\n\t\t\t\tint r = l + W - 1;\n\t\t\t\tif (r >= n) continue;\n\n\t\t\t\t/* \n\t\t\t\t   l+1         r-1\n\t\t\t\t   [] [] [] [] [] = W - 2 ( = (r - l - 1) - 2)\n\t\t\t\tl                  r\n\t\t\t\t{} [] [] [] [] [] {}      w[r] - w[l] <= 1  ==>   dp[l][r] = W\n\t\t\t\t*/\n\t\t\t\tif (dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r]) <= 1) dp[l][r] = W;\n\n\n\t\t\t\tfor (int k = l; k < r;k++) {\n\t\t\t\t\tdp[l][r] = max(dp[l][r], dp[l][k] + dp[k + 1][r]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nint main()\n{\n  std::vector<int> ns;\n  std::vector<std::vector<int>> data;\n  while(true){\n    int n;\n    std::cin>>n;\n    if(n==0) break;\n    std::vector<int> d(n);\n    for (int i = 0; i < n; i++){\n      std::cin>>d[i];\n    }\n    ns.push_back(n);\n    data.push_back(d);\n  }\n\n  for (int loop = 0; loop < ns.size(); loop++){\n    std::vector<std::vector<int>> dp(ns[loop]+3, std::vector<int>(ns[loop]+3, 0)); // dp[l][r] [l,r)で削除できるブロックの最大値\n    const int n = ns[loop];\n    const std::vector<int> d = data[loop];\n    for (int w = 2; w <= n; w++){\n      for (int l = 0; l < n; l++){\n        const int r = l + w;\n        if(r > n) continue;\n        if(dp[l+1][r-1] == w-2 && std::abs(d[l] - d[r-1]) <= 1){\n          dp[l][r] = w;\n        }\n\n        for (int mid = l+1; mid < r; mid++){\n          dp[l][r] = std::max(dp[l][r], dp[l][mid] + dp[mid][r]);\n        }\n      }\n    }\n    std::cout << dp[0][n] << std::endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\ntypedef priority_queue<int> PQ;\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n//vector<vector<int> > dp;\n//vector<vector<vector<int> > > vvvi;\n//dp=vector<vector<int> >(N, vector<int>(M,0));\n//vector<pair<int,int> > v;\n//v.push_back(make_pair(x,y));\n//priority_queue<int,vector<int>, greater<int> > q2;\n\n\n\nsigned main(){\ncin.tie(0);\nios::sync_with_stdio(false);\n\t\n\tint N;\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (!N)break;\n\t\tVI w(N);\n\t\tint dp[310][310];\n\t\tREP(i, 310)REP(j, 310)dp[i][j] = 0;\n\t\tREP(i, N) cin >> w[i];\n\n\t\teFOR(W, 2, N) {\n\n\t\t\tREP(i, N) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint r = i + W;\n\t\t\t\tif (r > N)continue;\n\t\t\t\tif (dp[i + 1][r - 1] == W - 2 && abs(w[i] - w[r - 1]) <= 1)\n\t\t\t\t\tdp[i][r] = W;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\teFOR(mid, i, r) {\n\t\t\t\t\tdp[i][r] = max(dp[i][r], dp[i][mid] + dp[mid][r]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\teREP(i, N) {\n\t\t\teREP(j, N)cout << dp[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << dp[0][N] << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<int> w(n+1);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> w[i];\n\t\t}\n\t\tif(n%2!=0){\n\t\t\tw[n]=-1;\n\t\t\tn++;\n\t\t}\n\t\t\n\t\tvector<vector<int> > dp(n+1, vector<int>(n+1, 0));\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tfor(int j=0; j+i<=n; j++){\n\t\t\t\tfor(int k=2; k<i-1; k++){\n\t\t\t\t\tdp[j][i] = max(dp[j][i], dp[j][k] +dp[j+k][i-k]);\n\t\t\t\t}\n\t\t\t\tif(dp[j+1][i-2]==i-2 && abs(w[j]-w[j+i-1])<=1){\n\t\t\t\t\tdp[j][i] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t} \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nint dp[300][300];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N; cin >> N;\n    if (not N) break;\n    vector<int> W(N); REP(i, N) cin >> W[i];\n    memset(dp, 0, sizeof(dp));\n    FOR(w, 2, N + 1) REP(left, N - w + 1) {\n      // [left, right]\n      int right = left + w - 1;\n      if (dp[left + 1][right - 1] == w - 2 and abs(W[left] - W[right]) <= 1) {\n        dp[left][right] = w;\n      } else {\n        FOR(mid, left + 1, right) {\n          dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid + 1][right]);\n        }\n      }\n    }\n    cout << dp[0][N - 1] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<n;++i)\n#define rep2(i,a,b) for (ll i=a;i<b;++i)\nconst ll MOD=1e9+7;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){\n        a=b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nint n;\nvector<int> w(310);\n\nint main(){\n    int n;\n    while (cin >> n,n){\n        rep(i,n) cin >> w[i];\n        vector<vector<int>> dp(n,vector<int>(n,0));\n        rep(j,n){\n            for (int i=0;i+j<n;i++){\n                rep(k,j) chmax(dp[i][i+j],dp[i][i+k]+dp[i+k+1][i+j]);\n                if (j!=0&&abs(w[i]-w[i+j])<=1&&(j==1||dp[i+1][i+j-1]==j-1)){\n                    chmax(dp[i][i+j],dp[i+1][i+j]+2);\n                }\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define reps(i,j,k) for(int i = j; i < k;++i)\n#define rep(i,j) reps(i,0,j)\n#define mk make_pair\nint N,w[310];\npair<int, pair<int, int> > memo[310][310];\nint cnt = 0;\n\npair<int,pair<int,int> > solve(int t, int b) {\n\t//cout << t << \" \" << b << endl;\n\tif(memo[t][b].first != -1 && memo[t][b].second.first != -2 && memo[t][b].second.second != -2){\n\t\treturn memo[t][b];\n\t}\n\tif(t == b){\n\t\treturn memo[t][b] = mk(0,mk(t,t));\n\t}\n\tif(t+1 == b){\n\t\tif(abs(w[t] - w[b]) <= 1){\n\t\t\treturn memo[t][b] = mk(2,mk(-1,-1));\n\t\t}\n\t\treturn memo[t][b] = mk(0,mk(t,b));\n\t}\n\tpair<int,pair<int,int> > ans = mk(0,mk(-1,-1));\n\treps(i,t,b){\n\t\tint bns = 0;\n\t\tint top_idx = solve(t,i).second.second;\n\t\tint bottom_idx = solve(i+1,b).second.first;\n\t\tint ret = solve(t,i).first + solve(i+1,b).first;\n\t\t\n\t\tif(top_idx == -1 && bottom_idx == -1){\n\t\t\tif(ans.first <= ret){\n\t\t\t\tans = mk(ret, mk(-1,-1));\n\t\t\t}\n\t\t}\n\t\telse if(top_idx == -1){\n\t\t\tif(ans.first <= ret){\n\t\t\t\tans = mk(ret, mk(bottom_idx, solve(i+1,b).second.second));\n\t\t\t}\n\t\t}\n\t\telse if(bottom_idx == -1){\n\t\t\tif(ans.first <= ret){\n\t\t\t\tans = mk(ret, mk(solve(t,i).second.first, top_idx));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(abs(w[top_idx]-w[bottom_idx]) <= 1){\n\t\t\t\tbns = 2;\n\t\t\t}\n\t\t\tif(ans.first < ret + bns) {\n\t\t\t\tans = mk(ret+bns, mk(solve(t,i).second.first, solve(i+1,b).second.second));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn memo[t][b] = ans;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> N;\n\t\tif(N == 0){\n\t\t\tbreak;\n\t\t}\n\t\trep(i,310){\n\t\t\trep(j,310){\n\t\t\t\tmemo[i][j] = mk(-1,mk(-2,-2));\t\n\t\t\t}\n\t\t}\n\t\trep(i,N){\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << solve(0,N-1).first << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint memo[1000][1000];\nint w[1000];\n\nusing namespace std;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *) array, (T *) (array + N), val);\n}\n\nint search(const int _n, int l, int r) {\n    int m = r - l;\n    if (m < 1)return 0;\n    if (memo[l][r] >= 0)return memo[l][r];\n    int sa = abs(w[l] - w[r]);\n    if (m == 1) {\n        return (sa < 2) ? 2 : 0;\n    } else {\n        int s = search(_n, l + 1, r - 1);\n        s += (sa < 2 && s == (m - 1)) ? 2 : 0;\n        for (int i = l + 1; i < r; i++) s = max(search(_n, l, i) + search(_n, i + 1, r), s);\n        return memo[l][r] = s;\n    }\n}\n\nint main() {\n    int n;\n    while (true) {\n        Fill(memo, -1);\n        cin >> n;\n        if (n == 0)break;\n        for (int i = 0; i < n; i++) cin >> w[i];\n        cout << search(n, 0, n - 1) << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing namespace std;\n\n#define INF ((1<<30)-1)\n#define LLINF (1LL<<60)\n#define EPS (1e-10)\n\nbool flag[501][501];\nint dp[501][501];\n\nint main() {\n\n    int n;\n    while (cin >> n and n) {\n        vector<int> v(n);\n        rep(i, n) cin >> v[i];\n\n        fill(flag[0], flag[350], false);\n        fill(dp[0], dp[350], 0);\n\n        // [i, j) という区間がどうなのかを見たい\n        for (int len = 1; len <= n; ++len) {\n            for (int i = 0; i + len <= n; ++i) {\n                int j = i + len;\n\n                if (dp[i+1][j-1] == (j-1) - (i+1) and abs(v[i] - v[j-1]) <= 1) {\n                    dp[i][j] = max(dp[i][j], dp[i+1][j-1] + 2);\n                }\n\n                for (int k = i; k <= j; ++k) {\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j]);\n                }\n            }\n        }\n\n        cout << dp[0][n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nint rec(int l, int r, VI &a, VVI &memo) {\n  if (memo[l][r] != -1) return memo[l][r];\n  if (r - l <= 1) return memo[l][r] = 0;\n  if (r - l == 2) {\n    if (abs(a[l + 1] - a[l]) <= 1) return memo[l][r] = 2;\n    return memo[l][r] = 0;\n  }\n  int res = rec(l + 1, r, a, memo);\n  for (int i = l + 1; i < r; i++) {\n    if (abs(a[i] - a[l]) <= 1 and rec(l + 1, i, a, memo) == i - (l + 1)) {\n      res = max(res, i + 1 - l + rec(i + 1, r, a, memo));\n    }\n  }\n  return memo[l][r] = res;\n}\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (n == 0) break;\n    VI a(n); for (int i = 0; i < n; i++) cin >> a[i];\n    VVI memo(n + 1, VI(n + 1, -1));\n    cout << rec(0, n, a, memo) << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        vector<int> v(N);\n        for (auto& i : v) cin >> i;\n\n        vector<vector<int>> dp(N+1, vector<int>(N));\n        for (int i = 0; i < N; i++) {\n            if (abs(v[i] - v[i+1]) < 2) {\n                dp[2][i] = 1;\n            }\n        }\n        for (int i = 4; i <= N; i += 2) {\n            for (int j = 0; j + i <= N; j++) {\n                if (dp[i-2][j+1] && abs(v[j] - v[j + i - 1]) < 2) {\n                    dp[i][j] = 1;\n                } else {\n                    vector<int> flag(i+1);\n                    for (int k = 2; j + k < j + i; k += 2) {\n                        if (dp[k][j] && dp[i - k][j + k]) {\n                            dp[i][j] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        vector<int> sum(N+1);\n        for (int i = 0; i < N; i++) {\n            if (i) sum[i] = max(sum[i], sum[i-1]);\n            for (int j = 2; j <= N; j += 2) {\n                if (dp[j][i]) {\n                    sum[i+j] = max(sum[i+j], sum[i] + j);\n                }\n            }\n        }\n\n        cout << max(sum[N-1], sum[N]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w[400];\nint memo[400][400];\n\nint max(int i, int j){\n\tint max = 0;\n\tfor(int k = i ; k < j ; k++){\n\t\tint a = memo[i][k] + memo[k+1][j];\n\t\tif(a > max){\n\t\t\tmax = a;\n\t\t}\n\t}\n//\tif((j - i) % 2 == 0){\n\t\tif(w[i] - w[j] <= 1 && w[j] - w[i] <= 1 && memo[i+1][j-1] == j - i - 1){\n\t\t\tmax = j - i + 1;\n//\t\t\tmax += 2;\n// \t\t}\n\t}\n\treturn max;\n}\n\nint main() {\n\tint n;\n\twhile(true){\n\t\tcin >> n;\n\n\t\tif(n == 0) break;\n\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\tcin >> w[k];\n//\t\t\tcout << \"w[\" << k << \"] = \" << w[k] << \"\\n\";\n\t\t}\n\n\t\tfor(int k = 0 ; k < n - 1; k++){\n\t\t\tmemo[k][k] = 0;\n//\t\t\tcout << \"memo[\" << k << \"][\" << k << \"] = \" << memo[k][k] << \"\\n\";\n\t\t}\n\n\t\tfor(int k = 0 ; k < n - 1; k++){\n\t\t\tmemo[k][k+1] = (w[k] - w[k+1] <= 1 && w[k+1] - w[k] <= 1) ? 2 : 0;\n//\t\t\tcout << \"memo[\" << k << \"][\" << k + 1 << \"] = \" << memo[k][k + 1] << \"\\n\";\n\t\t}\n\n\t\tfor(int b = 2 ; b < n ; b++){ //???\n\t\t\tfor(int k = 0 ; k < n - b ; k++){\n\t\t\t\tmemo[k][k + b] = max(k, k + b);\n//\t\t\t\tcout << \"memo[\" << k << \"][\" << k + b << \"] = \" << memo[k][k + b] << \"\\n\";\n\t\t\t}\n\t\t}\n//\t\tcout << \"memo[\" << 0 << \"][\" << n - 1 << \"] = \" << memo[0][n-1] << \"\\n\";\n\t\tcout << memo[0][n-1] << \"\\n\";\n\t}\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvi num(n);\n\t\tREP(i, n)\n\t\t\tcin >> num[i];\n\t\tvector<vector<bool>> able(n, vb(n, false));\n\t\tfor (int i = 2;i < n + 1;i += 2) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++) {\n\t\t\t\tif (i == 2) {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1)\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1 && able[j + 1][j + i - 2])\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t\tREP(k, i / 2 - 1)\n\t\t\t\t\t\tif (able[j][j + k * 2 + 1] && able[j + k * 2 + 2][j + i - 1])\n\t\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvi DP(n, vi(n, 0));\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tif (able[i][j])\n\t\t\t\tDP[i][j] = j - i + 1;\n\t\tfor (int i = 3;i < n + 1;i++) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++)\n\t\t\t\tREP(k, i-1)\n\t\t\t\tDP[j][j + i - 1] = max(DP[j][j + i - 1], DP[j][j + k] + DP[j + k+1][j + i - 1]);\n\t\t}\n\t\tcout << DP[0][n - 1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1611&lang=jp\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    while(cin >> n, n)\n    {\n        int dp[305][305] = {};\n        vector<int> w(n);\n\n        for(auto& _w : w)\n        {\n            cin >> _w;\n        }\n\n        for(int b = 2; b <= n; b++)\n        for(int l = 0; l < n; l++)\n        {\n            int r = l + b - 1;\n                if( r >= n )break;\n\n                if( abs(w[l] - w[r]) <= 1 && dp[l + 1][r - 1] == r - l - 1)\n                {\n                    dp[l][r] = r - l + 1;\n                }\n                else\n                for(int k = l; k < r; k++)                \n                {\n                    dp[l][r] = max( dp[l][r], dp[l][k] + dp[k + 1][r] );\n                }\n        }\n        cout << dp[0][n - 1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[300];\nint dp[301][301];\n\nint main(){\n  while(cin>>n&&n){\n    for(int i=0;i<n;i++)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int k=2;k<=n;k++){\n      for(int i=0;i+k<=n;i++){\n        dp[i][i+k]=dp[i+1][i+k];\n        for(int j=0;j<k-1;j++){\n          if(abs(a[i]-a[i+1+j])<=1&&dp[i+1][i+1+j]==(i+1+j)-(i+1)){\n            dp[i][i+k]=max(dp[i][i+k],dp[i+1][i+1+j]+dp[i+1+j+1][i+k]+2);\n          }\n        }\n      }\n    }\n    cout<<dp[0][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n  \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\nint N, W[300], dp[300][300];\n  \nint rec(int l,int r){\n\tif(l>=r)return 0;\n\tif(dp[l][r]!=-1)return(dp[l][r]);\n  \tint ret = 0;\n  \tif(abs(W[l]-W[r])<=1&&rec(l+1,r-1)==r-l-1)ret=r-l+1;\n  \tfor(int m=l;m<r;m++)ret=max(ret,rec(l,m)+rec(m+1,r));\n  \treturn (dp[l][r]=ret);\n}\n  \nint main(){\n  \twhile(1){\n\t\tcin>>N;\n    \tfor(int i=0;i<N;i++)cin>>W[i];\n    \tmemset(dp,-1,sizeof(dp));\n\t\tcout<<rec(0,N-1)<<endl;\n  \t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<int> w(n);\n        for(int i = 0; i < n; ++i) {\n            cin >> w[i];\n        }\n        vector<vector<int>> dp(n, vector<int>(n, -1));\n        function<int(int, int)> solve = [&] (int l, int r) {\n            if(l >= r) return 0;\n            int& res = dp[l][r];\n            if(res != -1) return res;\n            for(int i = l; i < r; ++i) {\n                res = max(res, solve(l, i) + solve(i + 1, r));\n            }\n            if(abs(w[l] - w[r]) <= 1) {\n                if(solve(l + 1, r - 1) == max(0, r - l - 1)) {\n                    res = r - l + 1;\n                }\n            }\n            return res;\n        };\n        cout << solve(0, n - 1) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nbool** table;\nint** dp;\nint N;\n\nint recursive(int left,int right){\n\n\tif(left == right)return dp[left][right] = 0;\n\tif(dp[left][right] != -1)return dp[left][right];\n\tif((right-left+1)%2 == 1){\n\t\treturn dp[left][right] = max(recursive(left,right-1),recursive(left+1,right));\n\t}\n\tif(table[left][(right-left+1)/2] == true)return dp[left][right] = right-left+1;\n\tif(right == left+1 && table[left][1] == false)return 0;\n\n\tint ans = 0;\n\tfor(int i = left+1; i <= right-2; i++){\n\t\tans = max(ans,recursive(left,i)+recursive(i+1,right));\n\t}\n\treturn dp[left][right] = ans;\n}\n\nint main(){\n\n\tint data[301];\n\ttable = new bool*[301];\n\tdp = new int*[301];\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i <= 300; i++){\n\t\t\tfor(int k = 0; k <= 150; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= 300; k++){\n\t\t\t\tdp[i][k] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1)table[i][1] = true;\n\n\t\t}\n\n\t\tfor(int length = 4; length <= N; length += 2){\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",recursive(1,N));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N, w[1000];\nbool dp[1000][1000];\n\nbool rec(int left, int right) {\n    if(dp[left][right]) return true;\n    if(left >= right) return false;\n\n    bool ret = false;\n    if(!(abs(left - right) % 2)) {\n        rec(left + 1, right), rec(left, right - 1);\n    } else {\n        for(int i = left + 1; i < right; i += 2) {\n            ret |= rec(left, i) & rec(i + 1, right);\n        }\n        ret |= rec(left + 1, right - 1) & (abs(w[left] - w[right]) <= 1);\n    }\n    return dp[left][right] = ret;\n}\n\nint calc(int idx) {\n    if(idx > N) return 0;\n\n    int ret = 0;\n    ret = calc(idx + 1);\n    for(int i = idx + 1; i < N; i += 2) {\n        if(dp[idx][i]) {\n            ret = max(calc(i + 1) + (i - idx + 1), ret);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    while(cin >> N, N) {\n        for(int i = 0; i < N; i++) {\n            cin >> w[i];\n        }\n\n        fill_n(*dp, 1000*1000, false);\n        for(int i = 0; i < N - 1; i++) {\n            if(abs(w[i] - w[i + 1]) <= 1) {\n                dp[i][i + 1] = true;\n            }\n        }\n        rec(0, N - 1);\n        cout << calc(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n#define EQ(a,b) (abs(a - b) < 1e-10)\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<LL> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<bool> VB;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\nint n;\nvector<int> w;\ntypedef bitset<301> bit;\nstruct Comp {\n\tbool operator() (const bit &a,const bit &b) {\n\t\tfor (int i = 300-1; i >= 0; i--) {\n        \tif (a[i] ^ b[i]) return b[i];\n    \t}\n    \treturn false;\n\t}\n};\nmap<bit,int,Comp> memo;\nint dfs(bit &state) {\n\tif (IN(state,memo)) return memo[state];\n\tint num = 0,fi;\n\tREP(i,n-1) {\n\t\tif ((!state[i])) {\n\t\t\tfi = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFOR(i,fi+1,n) {\n\t\tif (!state[i]){\n\t\t\tif (abs(w[i] - w[fi]) <= 1) {\n\t\t\t\tstate.set(i);state.set(fi);\n\t\t\t\tnum = max(dfs(state)+2,num);\n\t\t\t\tstate.reset(i);state.reset(fi);\n\n\t\t\t}\n\t\t\tfi = i;\n\t\t}\n\t}\n\treturn memo[state] = num;\n}\n\nint main(void) {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tw.resize(n);\n\t\tREP(i,n) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tbit state(0);\n\t\tcout << dfs(state) << endl;\n\t\tmemo.clear();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, to) for (int i = 0; i < (to); i++)\n#define rrep(i, to) for (int i = (to) - 1; i >= 0; i--)\n#define repf(i, from, to) for (int i = (from); i < (to); i++)\n#define all(v) v.begin(), v.end()\n#define unless(cond) if (!(cond))\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\n\nint main() {\n  while(true) {\n    int n;\n    cin >> n;\n\n    if(n == 0) {\n      break;\n    }\n\n    V<int> a(n);\n\n    rep(i, n) {\n      cin >> a[i];\n    }\n\n    V<V<int>> dp(n, V<int>(n));\n    rep(i, n) {\n      dp[i][i] = 0;\n      int j = i + 1;\n    }\n\n    int len = 2;\n    for(int i = 0; i + len <= n; i++)  {\n      int j = i + len - 1;\n\n      if(abs(a[i] - a[j]) <= 1) {\n        dp[i][j] = 2;\n      } else {\n        dp[i][j] = 0;\n      }\n    }\n\n    for(len = 3; len <= n; len++) {\n      for(int i = 0; i + len <= n; i++) {\n        int j = i + len - 1;\n\n        int cand1 = 0;\n        if(dp[i + 1][j - 1] == len - 2) {\n          cand1 = len - 2;\n\n          if(abs(a[i] - a[j]) <= 1) {\n            cand1 += 2;\n          }\n        }\n\n\n        int cand2 = 0;\n        repf(k, i, j) {\n          cand2 = max(cand2, dp[i][k] + dp[k + 1][j]);\n        }\n\n        dp[i][j] = max(cand1, cand2);\n      }\n    }\n    cout << dp[0][n - 1] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n) ; i++)\n#define rrep(i,n) for(int i = n-1; i >= 0 ; i--)\nconstexpr auto INF = 2147483647;\ntypedef long long ll;\n\nvoid DebugGrid(int row, int column, auto table){\n  cout << endl;\n  rep(i,row){\n    rep(j,column) cout << table[i][j] << \" \";\n    cout << endl;\n  }\n}\n\nint blocks[300];\nint DP[301][301];\n\n\nint main(){\n\n  int n;\n  while(true){\n    cin >> n;\n    if(n==0)break;\n    rep(i,n) cin >> blocks[i];\n    rep(i,n)rep(j,n) {\n      DP[i][j] = 0;\n      }\n\n    for(int k = 0; k<n; k++){\n      for(int i = 0; i<n-k; i++){\n        if(k==0)continue;\n        if(k==1 && abs(blocks[i]-blocks[i+1])<2) DP[i][i+1] = 2;\n        else if(k>1){\n          if(DP[i+1][i+k-1]==k-1 && abs(blocks[i]-blocks[i+k])<2) DP[i][i+k] = DP[i+1][i+k-1] +2;\n          for(int j=i; j<i+k; j++){\n            DP[i][i+k] = max(DP[i][i+k],DP[i][j]+DP[j+1][i+k]);\n          }\n        }\n      }\n    }\n    // DebugGrid(n,n,DP);\n    cout << DP[0][n-1] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout <<\"DEBUG\"<<\" \"<< #x << \":\" << x << '\\n'\n\n// n回繰り返し\n#define rep(i,n) for(int i = 0; i < ((int)(n)); i++)   // 0-indexed昇順\n#define rep1(i,n) for(int i = 1; i <= ((int)(n)); i++) // 1-indexed昇順\n#define rrep(i,n) for(int i = ((int)(n)-1); i >= 0; i--)  // 0-indexed降順\n#define rrep1(i,n) for(int i = ((int)(n)); i >= 1; i--)   // 1-indexed降順\n#define all(x) (x).begin(),(x).end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;  // 2次元配列\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef pair<int, int> PII;\n\ntemplate<typename T>\nusing vec = vector<T>;\ntemplate<class T>\nusing maxheap = std::priority_queue<T>;\ntemplate<class T>\nusing minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate<class T,class U> inline bool chmax(T &a, const U &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T,class U> inline bool chmin(T &a, const U &b){if(a>b){a=b;return 1;}return 0;}\n\nconst ld Pi = std::acos(-1.0L);\nconst ll infll = (1LL<<62)-1;\nconst int inf = (1<<30)-1;\nconst int mod = 1000000007;\n// const int mod = 998244353;\n\nvii dp;\nvi w;\n/*FUNCs=================================================*/\n\n\n/*MAIN==================================================*/\nsigned main(){\n    int _StartTime_ = clock();\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);   //cin cout 高速化\n    // cout << fixed << setprecision(15);\n\n\n    vii dp_init(310, vi(310));\n    vi w_init(310);\n    int n, p;\n    while(cin >> n) {\n        if(n==0) break;\n        dp = dp_init;\n        w = w_init;\n        rep1(i,n) cin >> w[i];\n\n        for(int l = 2; l <= n; ++l) {\n            for(int i = 0; i+l <= n; ++i) {\n                int j = i + l;\n                if(dp[i+1][j-1] == (j-1)-(i+1)) {\n                    if(abs(w[i+1]-w[j]) <= 1) chmax(dp[i][j], dp[i+1][j-1] + 2);\n                }\n                for(int k = i+1; k < j; ++k) {\n                    chmax(dp[i][j], dp[i][k] + dp[k][j]);\n                }\n            }\n        }\n        cout << dp[0][n] << '\\n';\n    }\n\n    // printf(\"ExecutionTime: %d /ms\\n\",1000*(int)((clock()-_StartTime_)/CLOCKS_PER_SEC));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint n;\nvector<int> w;\n\nenum MEMO {\n  NOT_CHECKED,\n  TRUE,\n  FALSE\n};\n\n\nMEMO memo[301][301];\n\nMEMO rec(int l, int r) {\n  if (r == l) {\n    return TRUE;\n  }\n  if (r - l - 1 == 1) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      return memo[l][r] = TRUE;\n    } else {\n      return memo[l][r] = FALSE;\n    }\n  }\n\n  if (r - 1 == l) {\n    return memo[l][r] = FALSE;\n  }\n\n  if (memo[l][r] != NOT_CHECKED) {\n    return memo[l][r];\n  }\n\n  if (abs(w[l] - w[r - 1]) <= 1) {\n    for (int i = l + 1; i < r; i++) {\n      int temp1 = rec(l + 1, i);\n      int temp2 = rec(i, r - 1);\n      if (temp1 == TRUE && temp2 == TRUE) {\n        return memo[l][r] = TRUE;\n      }\n    }\n  }\n\n  for (int i = l + 1; i < r; i++) {\n    int temp1 = rec(l, i);\n    int temp2 = rec(i, r);\n    if (temp1 == TRUE && temp2 == TRUE) {\n      return memo[l][r] = TRUE;\n    }\n  }\n\n  return memo[l][r] = FALSE;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= n; j++) {\n        memo[i][j] = NOT_CHECKED;\n      }\n    }\n\n    rec(0, n);\n\n    int dp[301] = { 0 };\n    for (int r = 1; r <= n; r++) {\n      dp[r] = dp[r - 1];\n      for (int l = 0; l < r; l++) {\n        if (memo[l][r] == TRUE) {\n          dp[r] = max(dp[r], dp[l] + (r - l));\n        }\n      }\n    }\n\n    int ans = dp[n];\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n#define rep(i,a,b) for(int i = (a); i < (b); i++)\n\nbool take[310][310];\nint dp[310][310];\n\nsigned main() {\n    int n;\n    while(cin >> n, n) {\n        int w[310];\n        rep(i,0,n) cin >> w[i];\n        memset(take, false, sizeof(take));\n        memset(dp, 0, sizeof(dp));\n\n        rep(i,0,n) {\n            rep(j,0,n-i) {\n                int len = i+1;\n                int s = j, t = j+i;\n                rep(k,s,t) {\n                    if(take[s][k] && take[k+1][t]) take[s][t] = true;\n                }\n                if(len == 2) {\n                    if(abs(w[s] - w[t]) < 2) {\n                        take[s][t] = true;\n                    }\n                }\n                if(take[s][t]) {\n                    int x = s-1, y = t+1;\n                    while(1) {\n                        if(x < 0 || x >= n || y < 0 || y >= n) break;\n                        if(abs(w[x] - w[y]) >= 2) break;\n                        take[x][y] = true;\n                        x--; y++;\n                    }\n                }\n            }\n        }\n\n        rep(i,0,n) rep(j,i+1,n) {\n            if(take[i][j]) dp[i][j] = j-i+1;\n        }\n\n        rep(i,0,n) rep(j,i,n) rep(k,i,j) {\n            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, w[300];\nint memo[303];\nint dp[303];\nbool check(int i, int j) {\n  if (j == i + 1) return true;\n  if (i == j + 1) return true;\n  if (i == j) return true;\n  return false;\n}\nint getMax(int i) { // i - 消せる最大\n  if (i >= n - 1) return 0;\n  if (memo[i] >= 0) return memo[i];\n  int ans = 0;\n  if (check(w[i], w[i+1])) ans = 2 + getMax(i+2);\n  int t = getMax(i+1);\n  if (i + t + 1 < n && t > 0 && check(w[i], w[i + t + 1])) ans = max(ans, t+2+getMax(i+t+2));\n  memo[i] = ans;\n  return ans;\n}\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) scanf(\"%d\", &w[i]);\n    for (int i = 0; i <= n + 2; i++) memo[i] = -1, dp[i] = 0;\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      if (i == 2) dp[i] = max(dp[i], dp[i-2]);\n      if (i >= 3) dp[i] = max(dp[i], max(dp[i-2], dp[i-3]));\n      int t = getMax(i);\n      if (i + t + 1 <= n + 2) dp[i + t + 1] = max(dp[i + t + 1], dp[i] + t);\n      ans = max(ans, dp[i]);\n    }\n    ans = max(ans, dp[n]);\n    ans = max(ans, dp[n + 1]);\n    ans = max(ans, dp[n + 2]);\n    printf(\"%d\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool okay(int x, int y) { return abs(x-y)<=1; }\nint main() {\n    for (;;) {\n        int N; cin >> N;\n        if (N == 0) break;\n        vector<int> W(N); for (auto &w : W) cin >> w;\n        vector<vector<bool>> dp(N, vector<bool>(N));\n        for (int c = 2; c <= N; c += 2) {\n            for (int i = 0; i < N; i++) {\n                int j = i + c - 1;\n                if (j >= N) break;\n                if (c == 2) {\n                    dp[i][j] = okay(W[i], W[j]);\n                } else {\n                    if (okay(W[i], W[j]) && dp[i+1][j-1]) {\n                        dp[i][j] = true;\n                    }\n                    for (int k = i + 2; k < j; k += 2) {\n                        if (dp[i][k-1] && dp[k][j]) dp[i][j] = true;\n                    }\n                }\n            }\n        }\n        vector<int> dp2(N);\n        for (int j = 0; j < N; j++) {\n            if (j > 0) dp2[j] = dp2[j-1];\n            for (int i = 0; i < j; i++) {\n                if (dp[i][j]) dp2[j] = max(dp2[j], (i==0?0:dp2[i-1]) + j-i+1);\n            }\n        }\n        cout << dp2[N-1] << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint dp[300][300];//dp[l][r] [l,r]でだるまを落としたときの落とした個数\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\t\n\t\tint da[300];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>da[i];\n\t\tfill(dp[0],dp[300],0);\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint dif=da[i]-da[i-1];\n\t\t\tif(dif<2 && dif>-2)\n\t\t\t\tdp[i-1][i]=2;\n\t\t\telse\n\t\t\t\tdp[i-1][i]=0;\n\t\t}\n\t\t//ここからdp\n\t\tfor(int k=2;k<n;k++)\n\t\t{\n\t\t\tfor(int i=0;i<n-k;i++)\n\t\t\t{\n\t\t\t\t//分割して調べる\n\t\t\t\tfor(int j=i;j<i+k-1;j++)\n\t\t\t\t\tdp[i][i+k]=max(dp[i][i+k],dp[i][j]+dp[j+1][i+k]);\n\t\t\t\t//真ん中が全部消える場合も調べる\n\t\t\t\tint dif=da[i]-da[i+k];\n\t\t\t\tif(dp[i+1][i+k-1]==k-1 && dif<2 && dif>-2)\n\t\t\t\t\tdp[i][i+k]=k+1;\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][n-1]<<endl;\n\t}\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[100];\nint dp[300][300];\nint ans[300];\n\nint C(int lb, int ub) {\n\tif (dp[lb][ub] != -1)return dp[lb][ub];\n\tif (ub - lb <= 0)return dp[ub][lb] = 0;\n\telse if (ub - lb == 1) {\n\t\tif (abs(x[lb] - x[ub]) <= 1)return dp[lb][ub] = 2;\n\t\treturn dp[lb][ub] = 0;\n\t}\n\tint res = 0;\n\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\tif (C(lb + 1, ub - 1) == ub - lb - 1) {\n\t\t\tres = C(lb + 1, ub - 1) + 2;\n\t\t}\n\t}\n\tFOR(mid, lb, ub) {\n\t\tres = max(res, C(lb, mid) + C(mid + 1, ub));\n\t}\n\treturn dp[lb][ub] = res;\n}\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 300)rep(j, 300) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tcout << C(0, n - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int n,w[300],dp[300][300];\n    scanf(\"%d\",&n);\n    while(n){\n        for(int i=0;i<n;i++){\n            scanf(\"%d\",&w[i]);\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                dp[i][j]=0;\n            }\n        }\n        for(int k=1;k<n;k++){\n            for(int i=0;i+k<n;i++){\n                if(dp[i+1][i+k-1]==k-1&&max(w[i],w[i+k])-min(w[i],w[i+k])<=1){\n                    dp[i][i+k]=k+1;\n                }\n                else{\n                    for(int j=i;j<i+k;j++){\n                        dp[i][i+k]=max(dp[i][i+k],dp[i][j]+dp[j+1][i+k]);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[0][n-1]);\n        scanf(\"%d\",&n);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> w(n);\n        for (int i = 0; i < n; i++) {\n            cin >> w[i];\n        }\n\n        vector<vector<bool>> ok(n, vector<bool>(n, false));  // [i,j]?????¨????????¨?????????\n        for (int d = 1; d < n; d += 2) {\n            for (int i = 0; i + d < n; i++) {\n                if (d == 1) {\n                    if (abs(w[i] - w[i + d]) <= 1) {\n                        ok[i][i + d] = true;\n                    }\n                } else {\n                    if (ok[i + 1][i + d - 1] and abs(w[i] - w[i + d]) <= 1) {\n                        ok[i][i + d] = true;\n                    } else {\n                        for (int j = i + 1; j < i + d; j += 2) {\n                            if (ok[i][j] and ok[j + 1][i + d]) {\n                                ok[i][i + d] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        vector<pair<int, int>> interval;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (ok[i][j]) {\n                    interval.push_back(make_pair(i + 1, j + 1));\n                }\n            }\n        }\n        const int size = interval.size();\n        vector<vector<int>> dp(size + 1, vector<int>(n + 1, 0));\n        for (int i = 0; i < size; i++) {\n            for (int j = 0; j <= n; j++) {\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);\n                if (j < interval[i].first) {\n                    dp[i + 1][interval[i].second] = max(dp[i + 1][interval[i].second], dp[i][j] + (interval[i].second - interval[i].first + 1));\n                }\n            }\n        }\n\n        int maxi = 0;\n        for (int i = 0; i <= n; i++) {\n            maxi = max(maxi, dp[size][i]);\n        }\n        cout << maxi << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint w[305];\nbool d[305][305];\nint dp[305];\nint main(void){\n    while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<300;i++)for(int j=0;j<300;j++)d[i][j]=false;\n    for(int i=0;i<=300;i++)dp[i]=0;\n    for(int i=0;i<n;i++)cin>>w[i];\n    for(int i=0;i<n-1;i++){\n        if(abs(w[i]-w[i+1])<=1)d[i][i+1]=true;\n    }\n    for(int i=3;i<n;i++){\n        for(int j=0;j+i<n;j++){\n            int l=j,r=j+i;\n            if(d[l+1][r-1]&&abs(w[l]-w[r])<=1)d[l][r]=true;\n            for(int k=l+1;k+1<r;k++){\n                if(d[l][k]&&d[k+1][r])d[l][r]=true;\n            }\n        }\n    }\n    for(int i=0;i<n;i++){\n        dp[i+1]=max(dp[i+1],dp[i]);\n        for(int j=i+1;j<n;j++)if(d[i][j])dp[j+1]=max(dp[j+1],dp[i]+j-i+1);\n    }\n    cout<<dp[n]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define _for(i,j,N) for(int i = (j);i < (N);i++)\n#define _rep(i,j,N) for(int i = (j);i <= (N);i++)\n#define ALL(x) x.begin(),x.end()\n#define pb push_back\n#define mk make_pair\n\ntypedef long long LL;\ntypedef pair<int,int> Interval;\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {\n    _for(i,0,v.size()) os << v[i] << \" \";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& v){\n    for(typename set<T>::iterator it = v.begin();it != v.end();it++)\n    os << *it <<\" \";\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& v){\n    os << v.first <<\" \"<<v.second<<endl;\n    return os;\n}\n\nconst int maxn = 300+5;\nint mem[maxn];\nint d[maxn][maxn];\nvector<int> A[maxn];\nint n;\n\nint dp(int l,int r){\n    int &ans = d[l][r];\n    if(ans >= 0) return ans;\n    if(r-l <= 0){\n        ans = 0;\n        return ans;\n    }\n\n    ans = dp(l+1,r);\n    for(auto a:A[l]){\n        if(a > r) break;\n        int dd = dp(l+1,a-1);\n        int nex = dp(a+1,r);\n        if(dd == a-l-1) nex = dd + nex + 2;\n        else nex = nex + dd;\n        ans = max(ans,nex);\n    }\n    return ans;\n}\n\nint main()\n{\n    while(1)\n    {\n        scanf(\"%d\", &n);\n        memset(d,-1,sizeof(d));\n        if(!n) break;\n        memset(mem, 0, sizeof(mem));\n        _for(i,0,maxn) A[i].clear();\n\n        for(int i = 0; i < n; i++)\n        {\n            scanf(\"%d\", &mem[i]);\n        }\n\n        for(int i = 0; i < n; i++){\n          for(int j = i+1; j < n; j++)\n          {\n              if(abs(mem[i]- mem[j])<=1)\n              {\n                  A[i].push_back(j);\n              }\n          }\n        }\n        cout << dp(0,n-1) << endl;\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n // C\n #ifndef _GLIBCXX_NO_ASSERT\n #include <cassert>\n #endif\n #include <cctype>\n #include <cerrno>\n #include <cfloat>\n #include <ciso646>\n #include <climits>\n #include <clocale>\n #include <cmath>\n #include <csetjmp>\n #include <csignal>\n #include <cstdarg>\n #include <cstddef>\n #include <cstdio>\n #include <cstdlib>\n #include <cstring>\n #include <ctime> \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <ccomplex>\n #include <cfenv>\n #include <cinttypes>\n #include <cstdbool>\n #include <cstdint>\n #include <ctgmath>\n #include <cwchar>\n #include <cwctype>\n #endif\n \n // C++\n #include <algorithm>\n #include <bitset>\n #include <complex>\n #include <deque>\n #include <exception>\n #include <fstream>\n #include <functional>\n #include <iomanip>\n #include <ios>\n #include <iosfwd>\n #include <iostream>\n #include <istream>\n #include <iterator>\n #include <limits>\n #include <list>\n #include <locale>\n #include <map>\n #include <memory>\n #include <new>\n #include <numeric>\n #include <ostream>\n #include <queue>\n #include <set>\n #include <sstream>\n #include <stack>\n #include <stdexcept>\n #include <streambuf>\n #include <string>\n #include <typeinfo>\n #include <utility>\n #include <valarray>\n #include <vector> \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <array>\n #include <atomic>\n #include <chrono>\n #include <condition_variable>\n #include <forward_list>\n #include <future>\n #include <initializer_list>\n #include <mutex>\n #include <random>\n #include <ratio>\n #include <regex>\n #include <system_error>\n #include <thread>\n #include <tuple>\n #include <typeindex>\n #include <type_traits>\n #include <unordered_map>\n #include <unordered_set>\n #endif\nusing namespace std;\nint dp[310][310];\n\nint main(){\n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        vector<int> w(n);\n        for(int i=0;i<n;++i) cin >> w[i];\n        for(int i=0;i<n;++i){\n            for(int j=0;j<n;++j){\n                dp[i][j] = 0;\n            }\n        }\n        //for(int i=0;i<n;++i) dp[i][i] = 0;\n\n        for(long long W=2;W<=n;++W){\n            for(int i=0;i<n;++i){\n                int j = i+W-1;\n                if(j>=n) continue;\n                if(dp[i+1][j-1]==W-2 && abs(w[j] - w[i])<=1){\n                    dp[i][j] = W;\n                }\n                for(int k=i;k<j;++k){\n                    dp[i][j] = max(dp[i][k] + dp[k+1][j],dp[i][j]);\n                }\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <map>\n#include <complex>\n#define fir first\n#define sec second\n#define sz(s) (s).size()\n#define pb push_back\n#define get(n) scanf(\"%d\",&n);\n#define gets(s) string s;cin >> (s);\n#define prfi(n) printf(\"%d\", &n);\n#define prfd(n) printf(\"%lf\", &n);\n#define All(s) (s).begin(), (s).end()\n#define rep(i,j) for(int (i)=0;(i)<(j);(i)++)\n#define For(i,j,k) for(int (i)=(j);(i)<(k);(i)++)\n#define drep(i,j) for(int (i)=(j);(i)>=0;(i)--)\n#define Ford(i,j,k) for(int (i)=(j);i>=(k);i--)\n#define fore(c,v) for(auto (c): (v))\n#define lp for(int __=0;__<n;i++)\n#define mem(a,b) memset(a,b,sizeof(a));\n#define dump(x)  std::cout << #x << \" = \" << (x) << std::endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing ull = unsigned long long int;\nusing ll = long long;\nusing ld = long double;\nusing pii = std::pair<int,int>;\nusing pll = std::pair<ll, ll>;\nusing vi = std::vector<int> ;\nusing vvi = std::vector<vi> ;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vd = std::vector<double> ;\nusing vvd = std::vector<vd> ;\nusing qi = std::queue<int> ;\nusing vpii = std::vector<std::pair<int, int> >;\nusing vpll = std::vector<pll>;\nusing namespace std;\n\nconst int Mod = (1e9) + 7;\nconst int INF = 1e9 + 19;\nconst ll INFL = 1e18 + 19;\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\nconst int dx2[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nconst int dy2[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\nconst double EPS = 1e-10;\n//_____________________________________Templates_________________________________________//\n\ntemplate<class T1, class T2> inline void chmin(T1 &a, T2 b){if(a > b) a = b;}\ntemplate<class T1, class T2> inline void chmax(T1 &a, T2 b){if(a < b) a = b;}\ntemplate<class T> inline void pri(T a){cout << a << endl;}\ntemplate<class Z> using vec = vector<Z>;\ntemplate<class T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n//mainly use for dynamic prog\ntemplate<class T1, class T2>\nvoid update(T1 &a, T2 b){\n  a += b;\n  if(a > Mod) a %= Mod;\n}\n\ninline void IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ninline void OUT(void){\n  cout << \"\\n\";\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\nbool pairsort(pll pl, pll pr){\n  if(pl.first == pr.first)return pl.second > pr.second;\n  return pl.first < pr.first;\n}\n\nint cntbit(ll a,int n,int j){int res = 0;For(i,j,n){if(a>>i & 1){res++;}}return res;}\nvector<int> make_bit(int a){vector<int> res; for(int i=31;i>=0;i--)if(a&(1<<i))res.pb(i);return res;}\nbool stdbit(int a, int b){return a&(1 << b); }\nint GCD(int a, int b){if(b > a)return GCD(b,a);if(a%b == 0)return b;else return GCD(b, a%b);}\nint LCM(int a, int b){return a*b/GCD(a,b);}\nint roundup(int a, int b){if(a % b == 0)return a/b;else return (a+b)/b;}\nint rounddown(int a, int b){if(a%b == 0)return a/b;else {return (a-b)/b;}}\nll pow(ll a, ll n){ll res = 1;while(n > 0){if(n&1)res *= a; a *= a; n = n >> 1;}return res;}\nll GetDiviserCount(ll N)//約数の個数\n{\n  ll res = 1;\n  For(i,2,sqrt(N)+1)\n  {\n    ll cnt = 0;\n    while(N%i == 0)\n    {\n      cnt++;\n      N /= i;\n    }\n    res *= (cnt + 1);\n    if(N == 1)break;\n  }\n  if(N != 1)res *= 2;\n  return res;\n}\nvll GetDivisor(ll N)//約数列挙\n{\n  vll res;\n  for(ll i = 1;i*i <= N;i++)\n  {\n    if(N%i == 0)\n    {\n      res.pb(i);\n      if(i*i != N)res.pb(N/i);\n    }\n  }\n  sort(All(res));\n  return res;\n}\n\n\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%Mod+Mod)%Mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= Mod) x -= Mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += Mod-a.x) >= Mod) x -= Mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= Mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n \n  // for prime mod\n  mint inv() const {\n    return pow(Mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n  friend ostream& operator<<(ostream& os, const mint& a);\n};\nostream& operator<<(ostream& os, const mint& a)\n{\n  os << a.x;\n  return os;\n}\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < Mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n \ntemplate<class Z>\nstruct MyMatrix\n{\n  using mat = MyMatrix<Z>;\n  vector<vector<Z>> m_dat;\n  int m_h;\n  int m_w;\n  MyMatrix(int h, int w) : m_h(h), m_w(w) ,m_dat(h,vector<Z>(w)) {}\n  vector<Z> &operator[] (int idx)\n  {\n    return m_dat[idx];\n  }\n  mat Multiple(mat &a)\n  {\n    mat C(m_h, a.m_w);\n    for(int i=0;i<m_h;i++)\n    {\n      for(int j=0;j<a.m_w;j++)\n      {\n        for(int k=0;k<m_w;k++)\n        {\n         C[i][j] += m_dat[i][k] * a[k][j];\n        }\n      }\n    }\n    return C;\n  }\n  mat Pow(ll x)\n  {\n    mat B(m_h,m_w);\n    for(int i=0;i<m_h;i++)\n    {\n      B[i][i] = 1;\n    }\n    mat A = *this;\n    while(x > 0)\n    {\n      if(x&1)B = B.Multiple(A);\n      A = A.Multiple(A);\n      x = x >> 1;\n    }\n    return B;\n  }\n  //friend ostream& operator<<(ostream &os, const mat &A);\n};\n/*\ntemplate<class Z>\nostream& operator<<(ostream &os, Matrix<Z>& A)\n{\n  for(int i=0;i<A.m_h;i++)\n  {\n    for(int j=0;j<A.m_w;j++)\n    {\n      os << A[i][j] << \" \";\n    }\n    os << endl;\n  }\n  return os;\n}\n*/\ntemplate<class T>\nusing mat = MyMatrix<T>;\n//_____________________　following sorce code_________________________//\nconst int max_n = 3 * (1e5) + 1;\nconst int max_m = 83 * (1e5) + 1;\n\nint n,m,k;\nll N;\nint h,w;\nstring S;\nint a,b,c;\nvi v;\nint ans;\ndouble x,y,z;\nvector<int> G[1010101];\nvi W;\n\nsigned main (int argc, char* argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(true)\n  {\n    IN(n);\n    if(n == 0)break;\n    W = vi(n);\n    rep(i,n)IN(W[i]);\n    vvi dp(n+1,vi(n+1));\n    For(len,2,n+1)\n    {\n      for(int i = 0;i+len <= n; i++)\n      {\n        int r = i + len;\n        For(pos,i+1,r)\n        {\n          if(dp[i][pos] and dp[pos][r])dp[i][r] = 1;\n        }\n        //dump(W[i]);\n        //dump(W[r-1]);\n        if(abs(W[i]-W[r-1]) <= 1)\n        {\n          if(dp[i+1][r-1])dp[i][r] = 1;\n          if(len == 2)dp[i][r] = 1;\n        }\n        //cout << \"dp[\" << i << \"][\" << r << \"] = \" << dp[i][r] << endl;\n      }\n    }\n\n    vi ndp(n+1);\n    drep(i,n-1)\n    {\n      ndp[i] = ndp[i+1];\n      For(j,i,n+1)\n      {\n        if(dp[i][j])\n        {\n          chmax(ndp[i],ndp[j] + j-i);\n        }\n      }\n    }\n    ans = ndp[0];\n    cout << ans << endl;\n    \n}\n  //for(auto c : ans){cout << c << endl;}\n  //cout << fixed << setprecision(15) << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> w;\nint solve(){\n    vector<vector<int>> dp(N+1, vector<int>(N+1, -1));\n    for (int i = 0; i <= N; i++)\n    {\n        dp[i][i] = 0;\n        if(i < N) dp[i][i+1] = 0;\n    }\n\n    for (int bet = 2; bet <= N; bet++)\n    {\n        for (int l = 0; l + bet <= N; l++)\n        {\n            int r = l + bet;\n            if(dp[l+1][r-1] == bet - 2){\n                if(abs(w[l] - w[r-1]) <= 1) dp[l][r] = bet;\n                else dp[l][r] = bet - 2;\n            }\n            for (int mid = l+1; mid < r-1; mid++)\n            {\n                dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid][r]);\n            }\n        }\n    }\n    return dp[0][N];\n}\n\nint main() {\n    while (cin >> N, N)\n    {\n        w.resize(N);\n        for (int i = 0; i < N; i++) cin >> w[i];\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;using pll = pair<ll, ll>;using pdd = pair<double, double>;using pss = pair<string, string>;using pbb = pair<bool, bool>;\nusing ti3 = tuple<int, int, int>;using tl3 = tuple<ll, ll, ll>;using td3 = tuple<double, double, double>;using ts3 = tuple<string, string, string>;using tb3 = tuple<bool, bool, bool>;\nusing ti4 = tuple<int, int, int, int>;using tl4 = tuple<ll, ll, ll, ll>;using td4 = tuple<double, double, double, double>;using ts4 = tuple<string, string, string, string>;using tb4 = tuple<bool, bool, bool, bool>;\nusing vi = vector<int>;using vl = vector<ll>;using vd = vector<double>;using vs = vector<string>;using vb = vector<bool>;\nusing vvi = vector<vi>;using vvl = vector<vl>;using vvd = vector<vd>;using vvs = vector<vs>;using vvb = vector<vb>;\nusing v3i = vector<vvi>;using v3l = vector<vvl>;using v3d = vector<vvd>;using v3s = vector<vvs>;using v3b = vector<vvb>;\nusing vpii = vector<pii>;using vpll = vector<pll>;using vpdd = vector<pdd>;using vpss = vector<pss>;using vpbb = vector<pbb>;\nusing vti3 = vector<ti3>;using vtl3 = vector<tl3>;using vtd3 = vector<td3>;using vts3 = vector<ts3>;using vtb3 = vector<tb3>;\nusing mii = map<int, int>;using mll = map<ll, ll>;using mci = map<char, int>;using msi = map<string, int>;\nusing si = set<int>;using sl = set<ll>;using sd = set<double>;using ss = set<string>;using sb = set<bool>;\nusing spii = set<pii>;using spll = set<pll>;using spdd = set<pdd>;using spss = set<pss>;using spbb = set<pbb>;\nusing sti3 = set<ti3>;using stl3 = set<tl3>;using std3 = set<td3>;using sts3 = set<ts3>;using stb3 = set<tb3>;\n#define rep0(TIMES) for (int CNT = 0; CNT < (int)(TIMES); CNT++)\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT < (ll)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (ll CNT = (ll)(START); CNT > (ll)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\n#define fr1(CONT) next(begin(CONT)), end(CONT)\n#define itrep(ITR, CONT) for (auto ITR = begin(CONT); ITR != end(CONT); ITR++)\n#define itrep1(ITR, CONT) for (auto ITR = next(begin(CONT)); ITR != end(CONT); ITR++)\n#define maxel(CONT) *max_element(all(CONT))\n#define minel(CONT) *min_element(all(CONT))\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (a > b) {\ta = b; return true;\t}\treturn false; }\ntemplate <typename T> T sum(const vector<T> &VEC) { return accumulate(all(VEC), 0.0); }\ntemplate <typename T> vector<T> acm(const vector<T> &VEC) { vector<T> RES(VEC.size() + 1); rep(CNT, VEC.size()) RES[CNT + 1] = RES[CNT] + VEC[CNT];\treturn RES; }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM, const T &VAL) { VEC.assign(NUM, VAL); }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM) { VEC.assign(NUM, 0.0); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM, const T &VAL) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM, VAL); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM) { fil(VV, RNUM, vector<T>()); }\nvoid prec(const int &DIG) { cerr << fixed << setprecision(DIG); cout << fixed << setprecision(DIG); }\ntemplate <typename T> void COUT(const T &ELEM) { cout << ELEM; }\ntemplate <typename T> void pout(const T &ELEM) { COUT(ELEM); cout << \" \"; }\ntemplate <typename T, typename ...Ts> void pout(const T &FIRST, const Ts &...REST) { pout(FIRST); pout(REST...); }\ntemplate <typename T> void print(T ELEM) { COUT(ELEM); cout << \"\\n\"; }\ntemplate <typename T, typename ...Ts> void print(const T &FIRST, const Ts &...REST) { print(FIRST); print(REST...); }\nvoid CERR() { cerr << \"\\n\"; }\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\ntemplate <typename T1, typename T2> void CERR(const pair<T1, T2> &PAIR) { cerr << \"(\"; CERR(PAIR.first); cerr << \", \"; CERR(PAIR.second); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3> void CERR(const tuple<T1, T2, T3> &TUP3) { cerr << \"(\"; CERR(get<0>(TUP3)); cerr << \", \"; CERR(get<1>(TUP3)); cerr << \", \"; CERR(get<2>(TUP3)); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3, typename T4> void CERR(const tuple<T1, T2, T3, T4> &TUP4) { cerr << \"(\"; CERR(get<0>(TUP4)); cerr << \", \"; CERR(get<1>(TUP4)); cerr << \", \"; CERR(get<2>(TUP4)); cerr << \", \"; CERR(get<3>(TUP4)); cerr << \")\"; }\ntemplate <typename T> void CERR(const vector<T> &VEC) { cerr << \"{ \"; itrep(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR1(const vector<T> &VEC) { cerr << \"{ \"; itrep1(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR(const set<T> &SET) { cerr << \"{ \"; itrep(ITR, SET) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T1, typename T2> void CERR(const map<T1, T2> &MAP) { cerr << \"{ \"; itrep(ITR, MAP) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\n#define db(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \", \"\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\n#define db1(OBJ) cerr << #OBJ << \": \"; CERR1(OBJ); cerr << \"\\n\"\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#define dbvv(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db01(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db10(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db11(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define YN(f) cout << (f ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(f) cout << (f ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(f) cout << (f ? \"yes\" : \"no\") << \"\\n\"\n#define pcase(NUM) cout << \"Case #\" << NUM << \":\" << \" \"\n#define pcasel(NUM) cout << \"Case #\" << NUM << \":\" << \"\\n\"\n// db\n\nint n;\nvi w;\nvvi dp; // dp[i][j]:[i,r)で落とせる個数の最大値\n\nint rec(int i, int j) {\n\tassert(i <= j);\n\tif (dp[i][j] != -1) return dp[i][j];\n\t// dbs(i, j);\n\tint res = 0;\n\tif (i + 2 <= j and rec(i + 1, j - 1) == j - i - 2 and abs(w[i] - w[j - 1]) <= 1) res = j - i;\n\telse rep2(k, i + 1, j) {\t\t\n\t\tchmax(res, rec(i, k) + rec(k, j));\n\t\t// dbs(i, k, j); dbs(dp[i][k], dp[k][j]);\n\t}\n\t// dbvv(dp);\n\treturn dp[i][j] = res;\n}\n\nvoid solve() {\n\t// 0-ind\n\tfil(w, n); rep(i, n) cin >> w[i]; // w[0]~w[n-1]\n\tfil(dp, n, n + 1, -1); // dp[0][0]=dp[n-1][n]\n\trep(i, n) { // i:0~n-1\n\t\tdp[i][i] = dp[i][i + 1] = 0; // dp[0][0]~dp[n-1][n-1],dp[0][1]~dp[n-1][n]\t\t\n\t\tif (i < n - 1) { // dp[0][2]~dp[n-2][n]\n\t\t\tdp[i][i + 2] = abs(w[i] - w[i + 1]) <= 1 ? 2 : 0;\n\t\t}\n\t}\n\t// dbl(w); dbvv(dp);\n\tprint(rec(0, n));\n\t// dbvv(dp);\n}\n\nint main() {\t\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n) solve();\n\t\telse break;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll solve(ll n){\n    ll res = 0;\n    vector<ll> w(n); for(auto &in:w) cin >> in;\n    vector<vector<ll>> dp(n+1,vector<ll>(n+1,0));\n    for(int i = 2; i <= n;i++){\n        for(int j = 0; j < n;j++){\n            int k = j + i -1;\n            if(k >= n) continue;\n            \n            if(dp[j+1][k-1] == i-2 && abs(w[j] - w[k]) <= 1) dp[j][k] = i;\n            for(int l = j; l < k;l++){\n                dp[j][k] = max(dp[j][k],dp[j][l] + dp[l+1][k]);\n            }\n        }\n    }\n    res = dp[0][n-1];\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll n;\n    while(cin >> n,n){\n        cout << solve(n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n//#define MAX 300\nint n;\nint* w;\nmap<vector<int*>,int> wmap;\n\nint* pop(int* w,int a) { //w???a????????¨a+1?????????????????????\n\tint *t;\n\tt = new int[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tif(i < a) t[i] = w[i];\n\t\telse t[i] = w[i + 2];\n\t}\n\tt[n - 2] = -1;\n\tt[n - 1] = -1;\n\treturn t;\n}\n\n\nint daruma(int* w) {\n\tint max = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (w[i] != -1 && w[i + 1] != -1 && abs(w[i]-w[i+1])<=1) {\n\t\t\tint tmp = daruma(pop(w, i))+2;\n\t\t\tif (tmp > max) max = tmp;\n\t\t}\n\t}\n\treturn max;\n}\n\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\tw = new int[n]();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << daruma(w) << endl;\n\n\n\t\tcin >> n;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tlist<int>res;\n\tcin >> N;\n\twhile (N) {\n\t\tvector<int>num(N);\n\t\tfor (int i = 0; i < N; i++)cin >> num[i];\n\t\tvector<vector<int>>dp(N, vector<int>(N,0));\n\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\tif (abs(num[i] - num[i + 1]) < 2)dp[i][i + 1] = 2;\n\t\t}\n\t\tfor (int i = 4; i <= N; i += 2) {\n\t\t\tfor (int j = 0; i + j <= N; j++) {\n\t\t\t\tif (dp[j][i + j - 3] && dp[i + j - 2][i + j - 1]) {\n\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t}\n\t\t\t\tif (dp[j + 1][i + j - 2] && abs(num[j] - num[i + j - 1]) < 2) {\n\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>ret(N,0);\n\t\tret[1] = dp[0][1];\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tret[i] = dp[0][i];\n\t\t\tfor (int j = i - 1; j >= 1; j--) {\n\t\t\t\tret[i] = max(ret[i], ret[j - 1] + dp[j][i]);\n\t\t\t}\n\t\t}\n\t\tres.push_back(ret[N - 1]);\n\t\tcin >> N;\n\t}\n\tfor (auto i : res)cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**Function Template**/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pint;\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define Rep(i, n) for(ll i = 1; i < (n); i++)\n#define ALL(a)  (a).begin(),(a).end()\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define PI 3.14159265358979323846\n#define ifYN(x) cout<<(x?\"Yes\":\"No\")<<\"\\n\" \nll fac[MAX], finv[MAX], inv[MAX];\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nbool palindrome(string s){\n  bool flag=true;\n  rep(i,s.size()) if(s[i]!=s[s.size()-1-i]) flag=false;\n  return flag;\n}\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n\n}\nll Len(ll n) {\n  ll s=0;\n  while(n!=0) s++, n/=10;\n  return s;\n}\n\n\nll Sint(ll n) {\n  ll m=0,s=0,a=n;\n  while(a!=0) s++, a/=10;\n  for(ll i=s-1;i>=0;i--) m+=n/((ll)pow(10,i))-(n/((ll)pow(10,i+1)))*10;\n  return m;\n}\n\n\nll Svec(vector<ll> v){\n  ll n=0;\n  for(ll i=0;i<v.size();i++) n+=v[i];\n  return n;\n}\n\n\nll GCD(ll a,ll b) {\n  return b ? GCD(b,a%b) : a;\n}\n\n\nll LCM(ll a,ll b){\n  return a/GCD(a,b)*b;\n}\n\n\nll Factorial(ll n){\n  ll m=1;\n  while(n>=1) m*=n,n--;\n  return m;\n}\n\nvoid runlength(string s,vector<pair<char,ll>> &p){\n  ll x=1;\n  if(s.size()==1){\n    p.push_back(pair<char,ll>(s[0],1));\n  }\n  for(ll i=0;i<s.size()-1;i++){\n    if(s[i]==s[i+1]){\n      x++;\n      if(i==s.size()-2){\n        p.push_back(pair<char,ll>(s[i],x));\n      }\n    }else{\n      p.push_back(pair<char,ll>(s[i],x));\n      x=1;\n      if(i==s.size()-2){\n        p.push_back(pair<char,ll>(s[s.size()-1],x));\n      }\n    }\n  }\n}\n\nll COM(ll n,ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nstring Toupper(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('a'<=s[i] && s[i]<='z') ans+=(char)s[i]-32;\n    else ans+=s[i];\n  }\n  return ans;\n}\nstring Tolower(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('A'<=s[i] && s[i]<='Z') ans+=(char)s[i]+32;\n    else ans+=s[i];\n  }\n  return ans;\n}\n\n\nconst int MAX_N=100010;\nvector<bool> sieve_of_eratosthenes(){\n  vector<bool> isPrime(MAX_N+1,true);\n  /* isPrime[1]=false; */\n  for(int i=2;i<=MAX_N;i++){\n    if(isPrime[i]){\n      for(int j=2*i;j<=MAX_N;j+=i){\n        isPrime[j]=false;\n      }\n    }\n  }\n  return isPrime;\n}\n\nvector<pint> prime_factorize(ll n){\n  vector<pint> ans;\n  for(ll p=2;p<=sqrt(n);p++){\n    if(n%p!=0) continue;\n    ll cnt=0;\n    while(n%p==0){\n      n/=p;\n      cnt++;\n    }\n    ans.push_back(make_pair(p,cnt));\n  }\n  if(n!=1) ans.push_back(make_pair(n,1));\n  return ans;\n}\n\n/*bool cmp(pint a, pint b) { return a.second < b.second; }*/\nll n;\nvector<ll> v;\nvector<vector<ll>> dp;\n\nll rec(ll l,ll r){\n  if(r-l<=1) return 0;\n  else if(r-l==2){\n    if(abs(v[l]-v[l+1])<=1) return 2;\n    else return 0;\n  }\n  if(dp[l][r]!=-1) return dp[l][r];\n  if(abs(v[l]-v[r-1])<=1 && rec(l+1,r-1)==r-l-2) chmax(dp[l][r],r-l);\n  for(ll i=l+1;i<=r-1;i++) chmax(dp[l][r],rec(l,i)+rec(i,r));\n  return dp[l][r];\n}\n\n/*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/\nint main() {\n  IOS;\n  while(1){\n    cin>>n;\n    if(n==0) return 0;\n    v.resize(n);\n    rep(i,n) cin>>v[i];\n    dp.assign(n+1,vector<ll>(n+1,-1));\n    cout<<rec(0,n)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing vtp = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\n// 参考: https://drken1215.hatenablog.com/entry/2020/03/10/160500\n\nll n;\nvll a;\n\nll solve(){\n  vvll dp(n+1, vll(n+1, -n));\n  for(ll i=0; i<=n; i++){\n    dp[i][i]=0;\n    if(i<n) dp[i][i+1]=0;\n  }\n  \n  for(ll len=2; len<=n; len++){\n    for(ll i=0; i+len<=n; i++){\n      ll j=i+len; // 右端\n      \n      // dpの遷移は以下の2パターンが考えられる\n      \n      // 1) [i,j-1]の両端以外が消せて、両端が残るパターン\n      // この場合は残った両端で消せるなら全消し、無理なら2個残る状態となる\n      if(dp[i+1][j-1]==j-i-2){\n        if(abs(a[i]-a[j-1])<=1) dp[i][j]=j-i;\n        else chmax(dp[i][j],dp[i+1][j-1]);\n      }\n      \n      // 2) あるkが存在して、[i,k), [k,j)を独立に操作して回数の最大値を求める場合\n      // 2つの区間に分けてそれぞれが全消しできるパターンも当然存在する\n      for(ll k=i+1; k<j-1; k++){\n        chmax(dp[i][j], dp[i][k]+dp[k][j]);\n      }\n    }\n  }\n  \n  return dp[0][n];\n}\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  \n  while(cin>>n, n){\n    a.resize(n);\n    rep(i,n) cin>>a[i];\n    cout<<solve()<<endl;\n  }\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\n#define int long long\n#define dotimes(i, n) for (int i : range(n))\n\nusing namespace std;\n\nclass range {\n  class iterator {\n    int i, s;\n  public:\n    iterator(int i, int s): i(i), s(s) {}\n    int& operator*() {\n      return i;\n    }\n    void operator++() {\n      i += s;\n    }\n    bool operator!=(iterator const& that) {\n      return i < that.i;\n    }\n  };\n  iterator b, e;\npublic:\n  range(int e): b({0, 1}), e({e, 1}) {}\n  range(int b, int e): b({b, 1}), e({e, 1}) {}\n  range(int b, int e, int s): b({b, s}), e({e, s}) {}\n  iterator begin() {\n    return b;\n  }\n  iterator end() {\n    return e;\n  }\n};\n\nint rint() {\n  int n;\n  scanf(\"%lld\", &n);\n  return n;\n}\n\nvoid wint(int n) {\n  printf(\"%lld\\n\", n);\n}\n\ntemplate<typename T>\ninline int size(T container) {\n  return static_cast<int>(container.size());\n}\n\ntemplate<typename T>\ninline bool maxs(T& a, T const& b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T>\ninline bool mins(T& a, T const& b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nsigned main() {\n  for (;;) {\n    int n = rint();\n    if (!n)\n      break;\n    int w[n];\n    dotimes(i, n)\n      w[i] = rint();\n    bool dp[n/2+1][n] = {};\n    dotimes(i, n)\n      dp[0][i] = true;\n    for (int i : range(1, n/2+1))\n      dotimes(j, n-2*i+1)\n        if (abs(w[j] - w[j+2*i-1]) <= 1 && dp[i-1][j+1])\n          dp[i][j] = true;\n        else\n          for (int k : range(1, i))\n            if (dp[k][j] && dp[i-k][j+2*k]) {\n              dp[i][j] = true;\n              break;\n            }\n    int ls[n+1] = {};\n    for (int i = n - 1; i >= 0; i--) {\n      ls[i] = ls[i+1];\n      dotimes(j, (n-i)/2)\n        if (dp[j+1][i])\n          maxs(ls[i], 2*(j+1) + ls[i+2*(j+1)]);\n    }\n    wint(ls[0]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <stdlib.h>\n#include <string.h>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <stdio.h>\n#include <tuple>\n#include <bitset>\n#include <cfloat>\n#include <fstream>\n#include <limits.h>\n#include <list>\n#include <math.h>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <cassert>\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nusing namespace std;\n#define int long long\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define P pair<ll, ll>\n#define sz(x) (ll)x.size()\n#define ALL(x) (x).begin(),(x).end()\n#define ALLR(x) (x).rbegin(),(x).rend()\n#define VE vector<ll>\n#define COUT(x) cout<<(x)<<endl\n#define MA map<ll,ll>\n#define SE set<ll>\n#define PQ priority_queue<ll>\n#define PQR priority_queue<ll,VE,greater<ll>>\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n#define EPS (1e-14)\n#define pb push_back\nlong long MOD = 1000000007;\n//const long long MOD = 998244353;\nconst long long INF = 1LL << 60;\nconst double PI = acos(-1.0);\nusing Graph = vector<VE>;\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x%MOD + MOD) % MOD) {}\n\tmint operator-() const { return mint(-x); }\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nstruct combination {\n\tvector<mint> fact, ifact;\n\tcombination(int n) :fact(n + 1), ifact(n + 1) {\n\t\tassert(n < MOD);\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n\t\tifact[n] = fact[n].inv();\n\t\tfor (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n\t}\n\tmint operator()(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn fact[n] * ifact[k] * ifact[n - k];\n\t}\n}com(10);\nstruct Sieve {\n\tint n;\n\tvector<int> f, primes;\n\t\n\tSieve(int n = 1) :n(n), f(n + 1) {\n\t\tf[0] = f[1] = -1;\n\t\tfor (ll i = 2; i <= n; ++i) {\n\t\t\tif (f[i]) continue;\n\t\t\tprimes.push_back(i);\n\t\t\tf[i] = i;\n\t\t\tfor (ll j = i * i; j <= n; j += i) {\n\t\t\t\tif (!f[j]) f[j] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool isPrime(int x) { return f[x] == x; }\n\t\n\tvector<int> factorList(int x) {\n\t\tvector<int> res;\n\t\twhile (x != 1) {\n\t\t\tres.push_back(f[x]);\n\t\t\tx /= f[x];\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<P> factor(int x) {\n\t\tvector<int> fl = factorList(x);\n\t\tif (fl.size() == 0) return {};\n\t\tvector<P> res(1, P(fl[0], 0));\n\t\tfor (int p : fl) {\n\t\t\tif (res.back().first == p) {\n\t\t\t\tres.back().second++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.emplace_back(p, 1);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nclass UnionFind {\npublic:\n\tvector <ll> par; \n\tvector <ll> siz; \n\n\t// Constructor\n\tUnionFind(ll sz_) : par(sz_), siz(sz_, 1) {\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; \n\t}\n\tvoid init(ll sz_) {\n\t\tpar.resize(sz_);\n\t\tsiz.resize(sz_, 1);\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; \n\t}\n\n\t// Member Function\n\t// Find\n\tll root(ll x) { \n\t\twhile (par[x] != x) {\n\t\t\tx = par[x] = par[par[x]]; \n\t\t}\n\t\treturn x;\n\t}\n\n\t// Union(Unite, Merge)\n\tbool merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\t\t\n\t\tif (siz[x] < siz[y]) swap(x, y);\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\n\tbool issame(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tll size(ll x) {\n\t\treturn siz[root(x)];\n\t}\n};\ntemplate<class t> t gcd(t a, t b) { return b != 0 ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) {\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool prime(ll n) {\n\tfor (ll i = 2; i <= sqrt(n); i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn n != 1;\n}\nmap<ll, ll> prime_factor(ll n) {\n\tmap<ll, ll> ret;\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tret[i]++;\n\t\t\tn /= i;\n\t\t}\n\t}\n\tif (n != 1) ret[n] = 1;\n\treturn ret;\n}\nll modinv(ll a, ll m) {\n\tll b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvector<pair<char, int>> RunLength(string s) {\n\tif (s.size() == 0)return {};\n\tvector<pair<char, int>>res(1, pair<char, int>(s[0], 0));\n\tfor (char p : s) {\n\t\tif (res.back().first == p) {\n\t\t\tres.back().second++;\n\t\t}\n\t\telse {\n\t\t\tres.emplace_back(p, 1);\n\t\t}\n\t}\n\treturn res;\n}\n// Digit Count\nint GetDigit(int num) {\n\treturn log10(num) + 1;\n}\n// bit calculation[how many \"1\"] (= __builtin_popcount())\nint bit_count(int n) {\n\tint cnt = 0;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1)cnt++;\n\t\tn /= 2;\n\t}\n\treturn cnt;\n}\n\nconst ll dx[4] = { 1,0,-1,0 };\nconst ll dy[4] = { 0,1,0,-1 };\nstruct edge { ll to, cost; };\ntypedef long double ld;\n\nint n;\nVE w;\nvector<VE>dp;\n\nint rec(int l = 0, int r = n) {\n\tif (r - l <= 1)return 0;\n\tif (r - l <= 2) {\n\t\tif (abs(w[l] - w[l + 1]) <= 1)return 2;\n\t\telse return 0;\n\t}\n\tif (dp[l][r] != -1)return dp[l][r];\n\tif (abs(w[l] - w[r - 1]) <= 1 && rec(l + 1, r - 1) == r - l - 2)chmax(dp[l][r], r - l);\n\tfor (int i = l + 1; i < r; i++) {\n\t\tchmax(dp[l][r], rec(l, i) + rec(i, r));\n\t}\n\treturn dp[l][r];\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//cout << fixed << setprecision(15);\n\tVE ans;\n\twhile (cin >> n) {\n\t\tif (n == 0)break;\n\t\tw.resize(n);\n\t\trep(i, n)cin >> w[i];\n\t\tdp.assign(n + 2, VE(n + 2, -1));\n\t\tans.push_back(rec());\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nvector<tuple<int, int, int>>vec; int n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; vec.clear(); for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { vec.push_back(make_tuple(j - i, i, j)); } }\n\t\tsort(vec.begin(), vec.end());\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tint a1 = get<1>(vec[i]), a2 = get<2>(vec[i]);\n\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 2; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tint a1 = k, a2 = k + i, a3 = k + i + j;\n\t\t\t\t\tdp[a1][a3 - 1] = max(dp[a1][a3 - 1], dp[a1][a2 - 1] + dp[a2][a3 - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[1000];\nbool dp[1000][1000];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 1000)rep(j, 1000) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\tfor (int j = 0; j + i < n; j++) {\n\t\t\t\tint lb = j, ub = j + i;\n\t\t\t\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\t\t\t\tif (i == 1)dp[lb][ub] = 1;\n\t\t\t\t\telse dp[lb][ub] |= dp[lb + 1][ub - 1];\n\t\t\t\t}\n\t\t\t\tFOR(mid, lb, ub) {\n\t\t\t\t\tdp[lb][ub] |= dp[lb][mid] && dp[mid + 1][ub];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, n) {\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tnum = max(num, j - i + 1);\n\t\t\t\t\tpos = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += num;\n\t\t\ti = pos;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,data[301];\n\tbool** table = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tint** maximum = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tmaximum[i] = new int[301];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 1; k <= N; k++)maximum[i][k] = 0;\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1){\n\t\t\t\ttable[i][1] = true;\n\t\t\t\tmaximum[i][i+1] = 2;\n\t\t\t}\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tif((table[left][1] == true && table[left+2][(length-2)/2] == true) || //????????¨?????£???????¶????????????????????????????2????????£??????length-2??????????¶?????????´???\n\t\t\t\t\t(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)){ //??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t\tmaximum[left][left+length-1] = length; //????¨?????????§??????OK????????§?????¶????????§???????¨????\n\t\t\t\t}else{\n\t\t\t\t\t//maximum[left][left+length-1]?????´??°????????°????????????\n\t\t\t\t\tfor(int i = 2; i <= length-2; i+= 2){\n\t\t\t\t\t\tmaximum[left][left+length-1] = max(maximum[left][left+length-1],maximum[left][left+i-1]+maximum[left+i][left+length-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max(maximum[1][N-1],maximum[1][N]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nint N;\nbool ok[1001][1001];\nint dp[1001][1001];\nint ans[1001];\nint main(){\n    while(cin>>N,N){\n       vector<int>v(N);\n       REP(i,N)cin>>v[i];\n       REP(i,1001)REP(j,1001){ok[i][j]=false;dp[i][j]=0;}\n       //ok????????????\n       /*REP(i,N){\n           for(int j=i+1;j<N;j++){\n               if(j-i==1&&abs(v[i]-v[j])<=1){ok[i][j]=true;dp[i][j]=2;continue;}\n               if(j-i==2){ok[i][j]=false;dp[i][j]=0;continue;}\n               for(int k=i+1;k+1<j;k++){\n                   if(abs(v[i]-v[j])>1)continue;\n                   if(ok[i][k]==false)continue;\n                   if(ok[k+1][j]==false)continue;\n                   ok[i][j]=true;\n                   dp[i][j]=j-i+1;\n               }\n           }\n       }*/\n       for(int k=1;k<=N-1;k++){\n          REP(i,N){\n              if(i+k>=N)continue;\n              if(k==1&&abs(v[i]-v[i+1])<=1){ok[i][i+1]=true;dp[i][i+1]=2;continue;}\n              if(k==1)continue;\n              if(k==2){ok[i][i+2]=false;dp[i][i+2]=0;continue;}\n              if(abs(v[i]-v[i+k])<=1&&ok[i+1][i+k-1]==true){ok[i][i+k]=true;dp[i][i+k]=k+1;}\n              for(int j=1;j<=k;j++){\n                  if(ok[i][i+j]&&ok[i+j+1][i+k]){ok[i][i+k]=true;dp[i][i+k]=k+1;}\n                  if(abs(v[i]-v[i+j]>1))continue;\n                  if(ok[i][i+j-1]==false)continue;\n                  if(ok[i+j+1][i+k]==false)continue;\n                  ok[i][i+k]=true;\n                  dp[i][i+k]=k+1;\n              }\n          }\n       }\n       REP(i,1001){\n           ans[i]=0;\n       }\n       for(int i=1;i<N;i++){\n           ans[i]=max(ans[i],ans[i-1]);\n           ans[i]=max(ans[i],dp[0][i]);\n           for(int j=1;j<i;j++){\n               ans[i]=max(ans[i],ans[j]+dp[j+1][i]);\n           }\n       }\n       //REP(i,N){REP(j,N)cout<<dp[i][j]<<\" \";cout<<endl;}\n       //REP(i,N)cout<<ans[i]<<endl;\n       cout<<ans[N-1]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define MAX 300\nint n;\nint w[MAX];\nmap<string, int> wmap;\n\nstring nToStr(int n) {\n\tstring tmp = \"\";\n\tfor (int i = 0; i < n; i++) {\n\t\ttmp += \"1\";\n\t}\n\treturn tmp;\n}\n\nint next(string s, int now) {\n\tfor (int i = now+1; i < n; i++) {\n\t\tif (s[i] == '1') return i;\n\t}\n\treturn n;\n}\n\nstring pop(string s,int a,int b) { //w???a????????¨b?????????????????????\n\tstring t =s;\n\tt[a] = '0';\n\tt[b] = '0';\n\treturn t;\n}\n\nint daruma(string s) {\n\tif (wmap.find(s) != wmap.end())\n\t{\n\t\t return wmap[s];\n\t}\n\n\tint max = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (s[i] == '1') {\n\t\t\tif (next(s, i) != n) {\n\t\t\t\tif (abs(w[i] - w[next(s, i)]) <= 1) {\n\t\t\t\t\tint tmp = daruma(pop(s, i, next(s, i))) + 2;\n\t\t\t\t\tif (tmp > max) max = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twmap.insert(map<string, int>::value_type(s, max));\n\treturn max;\n}\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\twmap.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tcout << daruma(nToStr(n)) << endl;\n\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #Sazaの1日1AC\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 10000;\nconst long long INF = 9e18;\nconst double PI = 3.14159265358979323846;\n\n//マクロ\n//型エイリアス\nusing ll = long long;\nusing P = pair<long long, long long>;\nusing vl = vector<long long>;\nusing vvl = vector<vector<long long>>;\nusing vP = vector<pair<long long, long long>>;\n//ショートカット\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define rep2(i, k, n) for (int i = k; i < n; i++) //半開区間\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define pb push_back\n#define mkp make_pair\n//入力\n#define vin(v, N) for (long long i = 0; i < N; i++) cin >> v.at(i)\n#define lin(n)long long n;cin >> n\n#define chin(x)char x;cin >> x;\n#define sin(s)string s;cin >> s;\n#define vlin(v, N)vector<long long> v(N);for (long long i = 0; i < N; i++)cin >> v.at(i)\n#define max(a, b) max((ll)a, (ll)b)\n#define min(a, b) min((ll)a, (ll)b)\n\n//関数\n//最大公約数\nlong long gcd(long long m, long long n){\n  long long a = max(m, n);\n  long long b = min(m, n);\n  long long r = a % b;\n  while (r != 0){\n    a = b;\n    b = r;\n    r = a % b;\n  }\n  return b;\n}\n// 最小公倍数\nlong long lcd(long long m, long long n){\n  return m * n / gcd(m, n);\n}\n//xのn乗\nlong long power(long long x, long long N){\n  long long ret = 1;\n  for (long long i = 0; i < N; i++)\n    ret *= x;\n  return ret;\n}\n//繰り返し二乗法\nlong long repeat_squaring(long long x, long long n){\n  if (n == 0)\n    return 1;\n  else if (n % 2 == 0)\n  {\n    long long t = repeat_squaring(x, n / 2);\n    return t * t % mod;\n  }\n  else\n    return x * repeat_squaring(x, n - 1);\n}\n//素因数分解(mapで返す)\nmap<long long, long long> factor(long long p){\n  ll p1 = p;\n  map<long long, long long> ret;\n  for (long long i = 2; i * i <= p1; i++)\n  {\n    while (p % i == 0)\n    {\n      ret[i]++;\n      p /= i;\n    }\n  }\n  if (p != 1)\n    ret[p]++;\n  return ret;\n}\n//素数判定\nbool is_prime(long long N){\n  for (long long i = 2; i * i <= N; i++)\n  {\n    if (N % i == 0)\n      return false;\n  }\n  return true;\n}\n//最大値更新\nvoid chmax(long long &a, long long b){\n  a = max(a, b);\n}\n//最小値更新\nvoid chmin(long long &a, long long b){\n  a = min(a, b);\n}\n\n//構造体\n//Union-Find木\nstruct UnionFind\n{\n  //メンバ変数\n  vector<long long> par; //par[i]:=頂点iの親\n  vector<long long> s;   //s[i]:=頂点iが属する集合の個数(iが根のとき)\n\n  //コンストラクタ\n  UnionFind(long long N) : par(N), s(N){\n    for (long long i = 0; i < N; i++)\n    {\n      par[i] = i; //最初はすべてが根として初期化\n      s[i] = 1;\n    }\n  }\n  //メンバ関数\n  //root(i):=頂点iの根\n  long long root(long long i){\n    if (par[i] == i)\n      return i;\n    par[i] = root(par[i]); //経路圧縮\n    return root(par[i]);   //再帰\n  }\n  //size[i]:=iが属する集合の個数\n  long long size(long long i){\n    return s[root(i)];\n  }\n  //same(x,y) xとyが同じ根を持つか(同じ集合に含まれるか)\n  bool same(long long x, long long y){\n    return root(x) == root(y);\n  }\n  //unite(x,y) xの根をyの根に繋げる(集合を合併)\n  void unite(long long x, long long y){\n    if (!same(x, y)){\n      long long rx = root(x);\n      long long ry = root(y);\n      par[rx] = par[ry];\n      s[ry] = s[rx] + s[ry];\n    }\n  }\n};\n//Binary Indexed Tree\nstruct BIT{\n  vector<long long> bit;\n  long long N;\n\n  BIT(long long n){\n    N = n;\n    bit.resize(N + 1);\n  }\n\n  void add(long long i, long long w){\n    for (long long x = i; x <= N; x += x & -x){\n      bit[x] += w;\n    }\n  }\n  long long sum(long long i){\n    long long ret = 0;\n    for (long long x = i; x > 0; x -= x & -x){\n      ret += bit[x];\n    }\n    return ret;\n  }\n};\n/////////////////⊂('ω'⊂ )))Σ≡GO!/////////////////\nvvl dp(305,vl(305,-1));\nvl a;\n\nll rec(ll l, ll r){\n  if(dp[l][r] != -1) return dp[l][r];\n  if(abs(l - r) <= 1) return 0;\n\n  ll ret = 0;\n  if(abs(a[l] - a[r-1]) <= 1 && rec(l+1, r-1) == r - l -2) ret = r - l;\n\n  for(ll mid = l + 1; mid <= r - 1; mid++) chmax(ret, rec(l, mid) + rec(mid, r));\n\n  dp[l][r] = ret;\n  return ret;\n}\n\n\n\nint main(){\n  //doubleの桁数\n  cout << fixed << setprecision(10);\n\n  while(true){\n    lin(N);\n    if(N == 0) break;\n\n    a.resize(N);\n    rep(i,N) cin >> a[i];\n    rep(i,305) rep(j,305) dp[i][j] = -1;\n\n    cout << rec(0,N) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n \nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);++(i))\n \nint main()\n{\n    int n;\n    while(cin >> n , n)\n    {\n        vector<int> w(n,0);\n        for(int i = 0;i < n;i++)\n        {\n            cin >> w[i];\n        }\n         \n        vector<vector<int>> dp(n + 1,vector<int>(n + 1,0));\n \n        for(int W = 2;W <= n;W++)\n        {\n            //left\n            for(int l = 0;l < n;l++)\n            {\n                int r = l + W - 1;\n                if(r > n) continue;\n \n                if(dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r - 1]) <= 1)\n                    dp[l][r] = W;\n \n                for(int mid = l;mid <= r;mid++)\n                {\n                    dp[l][r] = max(dp[l][r] , dp[l][mid] + dp[mid][r]);\n                }\n \n            }\n \n        }\n \n        cout << dp[0][n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconst int INF = (int)1e9;\nint N, W[300];\nint dp[300][300];\n// [i,j]\nbool solve(int i, int j) {\n  assert(0 <= i && i < N && 0 <= j && j < N);\n  assert(i <= j);\n  int &res = dp[i][j];\n  if(res != -1) return res;\n  res = false;\n  if(i + 1 == j) if(abs(W[i] - W[j]) <= 1) res = true;\n  if(i + 2 <= j) {\n    if(abs(W[i] - W[j]) <= 1 && solve(i + 1, j - 1)) {\n      res = true;\n    }\n  }\n  for(int k = i; k < j; ++k) {\n    if(solve(i, k) && solve(k + 1, j)) res = true;\n  }\n  return res;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> N;\n    if(N == 0) break;\n    REP(i,N) cin >> W[i];\n    memset(dp, -1, sizeof(dp));\n    REP(i,N) for(int j = i + 1; j < N; ++j) {\n      solve(i, j);\n      // cerr << \"[\" << i << \",\" << j << \"] = \" << (solve(i, j) ? \"yes\" : \"no\") << endl;\n    }\n    vector<int> cost(N + 1, INF);\n    cost[0] = 0;\n    REP(i,N) {\n      cost[i + 1] = min(cost[i + 1], cost[i] + 1);\n      for(int j = N - 1; j > i; --j) {\n        if(solve(i, j)) {\n          cost[j + 1] = min(cost[j + 1], cost[i]);\n        }\n      }\n    }\n    // REP(i,N+1) {\n    //   cerr << \" \" << cost[i];\n    // }\n    // cerr << endl;\n    cout << N - cost[N] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nbool ok(int a, int b) {\n\treturn abs(a - b) <= 1;\n}\n\nint solve(int l, int r, vector<int>&v) {\n\tif (l == r)return 0;\n\telse {\n\t\tif (l + 1 == r)return 0;\n\t\telse if (l + 2 == r) {\n\t\t\tif (ok(v[l],v[l+1]))return 2;\n\t\t\telse return 0;\n\t\t}\n\t\telse {\n\t\t\tint ans = 0;\n\t\t\tfor (int k = l + 1; k < r - 1; ++k) {\n\t\t\t\tans = max(ans, solve(l, k, v) + solve(k, r, v));\n\t\t\t}\n\t\t\tif (ok(v[l], v[r - 1]) && solve(l + 1, r - 1, v) == (r - l - 2)) {\n\t\t\t\tans = r - l;\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tvector<int>v(N);\n\t\tfor (int i = 0; i < N; ++i)cin >> v[i];\n\t\tif (!N)break;\n\t\tint ans = solve(0, N, v);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint a1 = j, a2 = i + j - 1; if (a2 >= n)continue;\n\t\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\t\tif (a1 > 1 && abs(a[a1 - 1] - a[a1 - 2]) <= 1)dp[a1 - 2][a2] = 1;\n\t\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tint a1 = k, a2 = k + i, a3 = k + i + j; if (a3 > n)continue;\n\t\t\t\t\tdp[a1][a3 - 1] = max(dp[a1][a3 - 1], dp[a1][a2 - 1] + dp[a2][a3 - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define dbg(x) cout<<#x<<\":\"<<x<<endl\n#define int long long\n#define MOD 1000000007\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint n,w[333];\nint dp[333][333];\n\nint rec(int l,int r){\n  if(dp[l][r]!=-1)return dp[l][r];\n  dp[l][r]=0;\n  for(int i=l+1;i<r;i++){\n    int res=0;\n    int suml=rec(l+1,i);\n    int sumr=rec(i+1,r);\n    if(suml==i-l-1&&abs(w[l]-w[i])<2)res+=2;\n    dp[l][r]=max(dp[l][r],res+suml+sumr);\n  }\n  return dp[l][r];\n}\n\nsigned main(){\n  while(1){\n  cin>>n;\n  if(n==0)break;\n  for(int i=0;i<n;i++)cin>>w[i];\n  fill_n(*dp,333*333,-1);\n  for(int i=0;i<n;i++){\n    dp[i][i]=0;\n    dp[i][i+1]=0;\n  }\n  cout<<rec(0,n)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define MAX 300\nint n;\nint w[MAX];\nmap<string, int> wmap;\n\nstring nToStr(int n) {\n\tstring tmp = \"\";\n\tfor (int i = 0; i < n; i++) {\n\t\ttmp += \"1\";\n\t}\n\treturn tmp;\n}\n\nint next(string s, int now) {\n\tfor (int i = now+1; i < n; i++) {\n\t\tif (s[i] == '1') return i;\n\t}\n\treturn n;\n}\n\nstring pop(string s,int a,int b) { //w???a????????¨b?????????????????????\n\ts[a] = '0';\n\ts[b] = '0';\n\treturn s;\n}\n\nint daruma(string s) {\n\tif (wmap.find(s) != wmap.end()) return wmap[s];\n\t\n\n\tint max = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (s[i] == '1') {\n\t\t\tif (s[next(s, i)] != n && abs(w[i] - w[next(s, i)]) <= 1) {\n\t\t\t\tint tmp = daruma(pop(s, i, next(s, i))) + 2;\n\t\t\t\tif (tmp > max) max = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\twmap.insert(map<string, int>::value_type(s, max));\n\treturn max;\n}\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\twmap.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tcout << daruma(nToStr(n)) << endl;\n\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    while(cin >> n, n)\n    {\n        int dp[305][305] = {};\n        vector<int> w(n);\n\n        for(auto& _w : w)\n        {\n            cin >> _w;\n        }\n\n        for(int b = 2; b <= n; b++)\n        for(int l = 0; l < n; l++)\n        {\n            int r = l + b - 1;\n                if( r >= n )continue;\n\n\n                if( abs(w[l] - w[r]) <= 1 && dp[l + 1][r - 1] == r - l - 1)\n                {\n                    dp[l][r] = r - l + 1;\n                }\n\n                for(int k = l; k < r; k++)                \n                {\n                    dp[l][r] = max( dp[l][r], dp[l][k] + dp[k + 1][r] );\n                }\n        }\n        \n        cout << dp[0][n - 1] << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n//#define int long long\n\n/*************** using variables ***************/\n/**********************************************/\n\nint solve(int n, vector<int> w){\n    bool dp[305][305];\n    LL dp2[305];\n    \n    REP(i, 305){\n        dp2[i] = 0;\n        REP(j, 305){\n            dp[i][j] = false;\n        }\n    }\n\n    for(int i = 1; i < n; i++){\n        if(abs(w[i-1]-w[i]) <= 1) dp[i-1][i] = true;\n    }\n\n    for(int len = 4; len <= n; len += 2){\n        REP(l, n){\n            int r = l + len - 1;\n            if(r >= n) break;\n\n            for(int c = l+2; c < r; c += 2){\n                if(dp[l][c-1] && dp[c][r]) dp[l][r] = true;\n            }\n            \n            if(abs(w[l]-w[r]) <= 1 && dp[l+1][r-1]){\n                dp[l][r] = true;\n            }\n        }\n    }\n\n    FOR(r, 1, n){\n        dp2[r] = dp2[r-1];\n        REP(l, r){\n            if(dp[l][r]){\n                if(l == 0) dp2[r] = max(dp2[r], r - l + 1);\n                else dp2[r] = max(dp2[r], dp2[l-1] + (r - l + 1));\n            }\n        }\n    }\n    return dp2[n-1];\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int n;\n    while(cin >> n, n){\n        vector<int> w(n, 0);   \n        REP(i, n) cin >> w[i];\n        cout << solve(n, w) << endl;\n    }\n   \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nint main(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<=n;i+=2)\n      for(int j=0;j<n-i;j++){\n        for(int k=1;k<=i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=i+1;\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tint w[310];\n\t\tint dp[310][310]={};\n\t\tREP(i,0,n) cin>>w[i];\n\t\tfor(int k=1;k<n;k++){\n\t\t\tfor(int i=0;i+k<n;i++){\n\t\t\t\tif(dp[i+1][i+k-1]==k-1&&abs(w[i]-w[i+k])<=1)\n\t\t\t\t\tdp[i][i+k]=dp[i+1][i+k-1]+2;\n\t\t\t\tfor(int j=i;j<i+k;j++)\n\t\t\t\t\tdp[i][i+k]=max(dp[i][i+k],dp[i][j]+dp[j+1][i+k]);\n\t\t\t}\n\t\t}\n\t\tp(dp[0][n-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint w[301];\nint dp[301][301];\n\nint func(int l,int r){\n\tif(dp[l][r]!=-1)return dp[l][r];\n\tif(l+1>=r)return 0;\n\tif(l+2==r){\n\t\tif(abs(w[l]-w[l+1])<=1)return 2;\n\t\telse return 0;\n\t}\n\tint res=0;\n\tres=max(res,func(l+1,r));\n\tres=max(res,func(l+2,r)+(abs(w[l]-w[l+1])<=1?2:0));\n\tres=max(res,func(l,r-1));\n\tres=max(res,func(l,r-2)+(abs(w[r-1]-w[r-2])<=1?2:0));\n\tif(abs(w[l]-w[r-1])<=1){\n\t\tint v=func(l+1,r-1);\n\t\tif(v==(r-1)-(l+1)){\n\t\t\tres=r-l;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&w[i]);\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tprintf(\"%d\\n\",func(0,n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint SolveDaruma(const vector<int> &w) {\n    const int n = w.size();\n    vector<vector<int>> s(n, vector<int>(n, 0));\n\n    for (int l = 0; l + 1 < n; ++l)\n        if (abs(w[l] - w[l + 1]) <= 1) {\n            s[l][l + 1] = 2;\n        }\n\n    for (int i = 4; i <= n; ++i) {\n        for (int l = 0; l + i <= n; ++l) {\n            const int r = l + i - 1;\n\n            if (abs(w[l] - w[r]) <= 1 && s[l + 1][r - 1] == i - 2)\n                s[l][r] = max(s[l][r], i);\n\n            if (abs(w[l] - w[l + 1]) <= 1)\n                s[l][r] = max(s[l][r], 2 + s[l + 2][r]);\n            else\n                s[l][r] = max(s[l][r], s[l + 2][r]);\n\n            if (abs(w[r - 1] - w[r]) <= 1)\n                s[l][r] = max(s[l][r], 2 + s[l][r - 2]);\n            else\n                s[l][r] = max(s[l][r], s[l][r - 2]);\n\n            for (int m = l + 1; m + 1 < r; ++m) {\n                if (abs(w[m] - w[m + 1]) <= 1)\n                    s[l][r] = max(s[l][r], 2 + s[l][m - 1] + s[m + 2][r]);\n                else\n                    s[l][r] = max(s[l][r], s[l][m - 1] + s[m + 2][r]);\n            }\n        }\n    }\n\n    return s[0][n - 1];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n\n    while (cin >> n, n) {\n        vector<int> w(n);\n        for (int i = 0; i < n; ++i)\n            cin >> w[i];\n\n        cout << SolveDaruma(w) << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    while (n!=0){\n        vector<int> w(n);\n        for (int i = 0; i < n; i++){\n            cin >> w[i];\n        }\n        vector<vector<bool>> check(n, vector<bool>(n));\n        for (int i=0; i<n-1; i++){\n            if (abs(w[i+1]-w[i])<=1) check[i][i+1]=true;\n        }\n        for (int i=3; i<n; i+=2){\n            for (int j=0; j<n-i; j++){\n                for (int k=j+1; k<j+i; k++){\n                    if (!check[j][j+i] && check[j][k] && check[k+1][j+i]){\n                        check[j][j+i]=true;\n                        break;\n                    }\n                }\n                if (!check[j][j+i] && abs(w[j]-w[j+i])<=1 && check[j+1][j+i-1]) check[j][j+i]=true;\n            }\n        }\n        vector<int> dp(n);\n        for (int i=0; i<n; i++){\n            for (int j=0; j<n; j++){\n                if (check[i][j]){\n                    if (i!=0) dp[j]=max(dp[j],dp[i-1]+j-i+1);\n                    else dp[j]=j-i+1;\n                }\n            }\n            if (i!=0) dp[i]=max(dp[i],dp[i-1]);\n        }\n        cout << dp[n-1] << endl;\n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        vector<int> W(N);\n        for (int i = 0; i < N; i++) cin >> W[i];\n\n        int dp[N+1][N+1];\n        for (int i = 0; i < N+1; i++){\n            for (int j = 0; j < N+1; j++) {\n                dp[i][j] = 0;\n            }\n        }\n\n        for (int b = 2; b < N+1; b++) {\n            for (int i = 0; i < N; i++) {\n                int j = i + b;\n                if (j > N) continue;\n                if (abs(W[i] - W[j-1]) <= 1 && dp[i+1][j-1] == j-i-2) {\n                    dp[i][j] = j - i;\n                }\n                for (int k = i+1; k < j; k++) {\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j]);\n                }\n            }\n        }\n        cout << dp[0][N] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1000000007;\n\n#define vec                vector<int>\n#define vecll              vector<ll>\n#define vecd               vector<double>\n#define vecst              vector<string>\n#define vecb               vector<bool>\n#define vec2(var, n, m)    vector<vector<int>>  var(n, vector<int>(m, 0))\n#define vecb2(var, n, m)   vector<vector<bool>> var(n, vector<bool>(m, false))\n#define vecll2(var, n, m)  vector<vector<ll>>   var(n, vector<ll>(m, 0))\n\n#define rep(i,n)         for(ll i=(ll)0; i<(ll)n; i++)\n#define REP(i,m,n)       for(ll i=(ll)m; i<(ll)n; i++)\n#define arr(var, n)      vec var(n); rep(i,n){cin >> var[i];}\n#define arrll(var, n)    vecll var(n); rep(i,n){cin >> var[i];}\n#define arrst(var, n)    vecst var(n); rep(i,n){cin >> var[i];}\n#define all(var)         (var).begin(), (var).end()\n#define sortall(var)     sort(all(var))\n#define uniqueall(v)     v.erase(unique(v.begin(), v.end()), v.end());\n#define f_sum(var)       accumulate(all(var), 0)\n#define f_sumll(var)     accumulate(all(var), 0LL)\n#define chmin(v1, v2)    v1 = min(v1, v2)\n#define chmax(v1, v2)    v1 = max(v1, v2)\n#define pb(var)          push_back(var)\n#define prt(var)         cout << (var) << \"\\n\"\n#define prtd(n, var)     cout << fixed << setprecision(n) << (var) << \"\\n\"\n#define prtfill(n, var)  cout << setw(n) << setfill('0') << (var);\n#define prt2(v1, v2)     cout << (v1) << \" \" << (v2) << \"\\n\"\n#define prt3(v1, v2, v3) cout << (v1) << \" \" << (v2) << \" \" << (v3) << \"\\n\"\n#define prtall(v)        rep(i,v.size()){cout<<v[i]<<(i!=v.size()-1?\" \":\"\\n\");}\nvoid prtok(bool ok){prt(ok ? \"Yes\" : \"No\");}\n//----------------------------------------------------------------\n\nint main(void) {\n  vec ans;\n\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0){break;}\n    arr(w,n);\n\n    vec2(dp, n, n);\n\n    rep(i,n-1){\n      dp[i][i+1] = (abs(w[i]-w[i+1])<2 ? 2 : 0);\n    }\n\n    REP(num, 3, n+1){\n      rep(i,n+1-num){\n        int j = i+num-1;\n        if(dp[i+1][j-1] == (j-1)-(i+1)+1 && abs(w[i]-w[j])<2){\n          dp[i][j] = dp[i+1][j-1] + 2;\n        } else {\n          REP(k,i,j){\n            chmax(dp[i][j], dp[i][k]+dp[k+1][j]);\n          }\n        }\n      }\n    }\n\n    ans.pb(dp[0][n-1]);\n  }\n\n  rep(i,ans.size()){\n    prt(ans[i]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main(){\n  int n;\n  while(cin>>n,n){\n    int w[n],i,j,k=0;\n    for(i=0;i<n;i++) cin>>w[i];\n    bool p[n][n],u[n][n];\n    memset(p,0,sizeof(p));\n    memset(u,0,sizeof(u));\n    queue<P> q;\n    for(j=0;j+1<n;j++) if(abs(w[j+1]-w[j])<2) p[j][j+1]=1,q.push(P(j,j+1));\n    while(!q.empty()){\n      int l=q.front().first,r=q.front().second;q.pop();\n      if(u[l][r]) continue;\n      u[l][r]=1;\n      if(l>0&&r+1<n&&abs(w[l-1]-w[r+1])<2) p[l-1][r+1]=1,q.push(P(l-1,r+1));\n      for(i=r+1;i<n;i++) if(p[r+1][i]) p[l][i]=1,q.push(P(l,i));\n      for(i=0;i<l;i++) if(p[i][l-1]) p[i][r]=1,q.push(P(i,r));\n    }\t  \n    int dp[n+1];\n    memset(dp,0,sizeof(dp));\n    for(i=0;i<=n;i++)\n      for(j=1;i+j<=n;j++)\n\tdp[i+j]=max(dp[i+j],dp[i]+p[i][i+j-1]*j);\n    cout<<dp[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <cstdlib>\n#include <iterator>\n\n//?????????\nstruct daruma {\n\tstd::list<int> block;\n\tint size;\n};\n\nclass DarumaOtosi {\npublic:\n\tDarumaOtosi(daruma d) {\n\t\tdarumalist.resize(d.size-3);\n\t\tdarumalist[d.size - 4].push_back(d);\n\t}\n\t//???????????????????????????\n\tint Hunmer(daruma d) {\n\t\t//?????????????????????\n\t\tif (d.size != d.block.size()) {\n\t\t\t//??????????????????????????´??°\n\t\t\td.size = d.block.size();\n\t\t\t//????????\\????????????????????????????????????\n\t\t\tif (d.size == 0 || d.size == 1) return d.size;\n\t\t\t//?????????????????????????????¨?????£?????£???\n\t\t\tif (d.size >= 4) {\n\t\t\t\tint tmp = CheckDaruma(d);\n\t\t\t\tif (tmp != 0) return tmp;\n\t\t\t\tdarumalist[d.size - 4].push_back(d);\n\t\t\t}\n\t\t}\n\n\t\tfor (auto itr = d.block.begin(); itr != std::prev(d.block.end()); itr++) {\n\t\t\tif (abs(*itr - *(std::next(itr))) <= 1) {\n\t\t\t\tconst int tmp1 = *itr; const int tmp2 = *(std::next(itr));\n\t\t\t\t//????????????\n\t\t\t\titr = d.block.erase(itr, std::next(itr, 2));\n\t\t\t\t//???????????£??????\n\t\t\t\tint size = Hunmer(d);\n\t\t\t\t//????????????\n\t\t\t\titr = d.block.insert(itr, tmp2);\n\t\t\t\titr = d.block.insert(itr, tmp1);\n\t\t\t\t//???????????´??°\n\t\t\t\tif (d.size > size) {\n\t\t\t\t\td.size = size;\n\t\t\t\t\t//????????\\???????????????????????£?????????\n\t\t\t\t\tif (d.size == 0 || d.size == 1) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(d.block.size() >= 4) darumalist[d.block.size() - 4].back().size = d.size;\n\t\treturn d.size;\n\t}\n\nprivate:\n\tstd::vector<std::vector<daruma>> darumalist;\n\n\t//????????????????????????\n\tvoid CollectDaruma(daruma d) {\n\t\tdarumalist[d.size].push_back(d);\n\t}\n\n\t//???????????¨??????????????????????????§??????\n\tint CheckDaruma(daruma d) {\n\t\tint n = d.size;\n\t\tfor (int i = 0; i < darumalist[n-4].size(); i++) {\n\t\t\tif (d.block == darumalist[n-4][i].block) return darumalist[n-4][i].size;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nint main() {\n\tint n = 1;\n\tstd::vector<daruma> daruma_original;\n\n\t//??\\???\n\tfor (int m;;) {\n\t\tdaruma daruma;\n\t\tstd::cin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::cin >> m;\n\t\t\tdaruma.block.push_back(m);\n\t\t}\n\t\tdaruma.size = daruma.block.size();\n\t\tdaruma_original.push_back(daruma);\n\t}\n\n\t//???????????????\n\tfor (auto x : daruma_original) {\n\t\tDarumaOtosi darumaotosi(x);\n\t\tstd::cout << x.size - darumaotosi.Hunmer(x) << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\nvector<int> a;\nvector<vector<int>> dp;\nint rec(int l, int r) {\n  if(dp[l][r] >= 0) return dp[l][r]; // memo\n  if(r - l < 2) return dp[l][r] = 0;\n  if(abs(a[l] - a[r-1]) <= 1) { // all clear\n    if(rec(l+1, r-1) == (r-1) - (l+1)) {\n      return dp[l][r] = r - l; \n    }\n  }\n  int res = 0;\n  for (int i = l+1; i < r; ++i) {\n    chmax(res, rec(l, i) + rec(i, r));\n  }\n  return dp[l][r] = res;\n}\n\nint main()\n{\n  vector<int> res;\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    a.resize(n);\n    rep(i,n) cin >> a[i];\n    dp.assign(n+1, vector<int>(n+1, -1));\n    res.push_back(rec(0, n));\n  }\n  rep(i,res.size()) cout << res[i] << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[100];\nbool dp[300][300];\n//int ans[300];\n\n//bool C(int lb, int ub) {\n//\t//cout << lb << \" \" << ub /*<< dp[lb][ub]*/ << endl;\n//\tif (dp[lb][ub] != -1)return dp[lb][ub];\n//\tif (ub - lb <= 0)return dp[ub][lb] = 0;\n//\telse if (ub - lb == 1) {\n//\t\tif (abs(x[lb] - x[ub]) <= 1)return dp[lb][ub] = 1;\n//\t}\n//\tdp[lb][ub] = 0;\n//\tif (abs(x[lb] - x[ub]) <= 1) {\n//\t\tdp[lb][ub] |= C(lb + 1, ub - 1);\n//\t}\n//\tFOR(mid, lb, ub) {\n//\t\t//cout << \"!\" << lb << \" \" << mid << endl;\n//\t\t//cout << \"!\" << mid << \" \" << ub << endl;\n//\t\tbool f = C(lb, mid);\n//\t\tf &= C(mid + 1, ub);\n//\t\tdp[lb][ub] |= f;\n//\t}\n//\treturn dp[lb][ub];\n//}\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 300)rep(j, 300) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\trep(j, n) {\n\t\t\t\tint lb = j, ub = j + i;\n\t\t\t\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\t\t\t\tif (i == 1)dp[lb][ub] = 1;\n\t\t\t\t\telse dp[lb][ub] |= dp[lb + 1][ub - 1];\n\t\t\t\t}\n\t\t\t\tFOR(mid, lb + 1, ub - 1) {\n\t\t\t\t\tdp[lb][ub] |= dp[lb][mid] && dp[mid + 1][ub];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << dp[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tint ans = 0;\n\t\t//rep(i, n) {\n\t\t//\t//if (i >= 1)ans[i] = ans[i - 1];\n\t\t//\tint num = 0;\n\t\t//\tint pos = i;\n\t\t//\tfor (int j = i + 1; j < n; j += 2) {\n\t\t//\t\tif (dp[i][j]) {\n\t\t//\t\t\tnum = max(num, j - i + 1);\n\t\t//\t\t\tpos = j;\n\t\t//\t\t}\n\t\t//\t}\n\t\t//\tans += num;\n\t\t//\ti = pos;\n\t\t//}\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << ans[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\twhile (N) {\n\t\tvector<int>num(N);\n\t\tfor (int i = 0; i < N; i++)cin >> num[i];\n\t\tvector<vector<int>>dp(N, vector<int>(N,0));\n\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\tif (abs(num[i] - num[i + 1]) < 2)dp[i][i + 1] = 2;\n\t\t}\n\t\tfor (int i = 4; i <= N; i += 2) {\n\t\t\tfor (int j = 0; i + j <= N; j++) {\n\t\t\t\tfor (int k = j; k < i + j - 1; k+=2) {\n\t\t\t\t\tfor (int l = k + 1; l <= i + j - 1; l+=2) {\n\t\t\t\t\t\tif (!k) {\n\t\t\t\t\t\t\tif (dp[k + 1][l - 1] == l - k - 1) {\n\t\t\t\t\t\t\t\tif (l == N - 1) {\n\t\t\t\t\t\t\t\t\tif (abs(num[k] - num[l]) < 2) {\n\t\t\t\t\t\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t\t\t\t\t\t//\tcout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(dp[l + 1][i + j - 1] == i + j - 1 - l&&abs(num[k] - num[l]) < 2) {\n\t\t\t\t\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t\t\t\t\t\t//cout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dp[j][k - 1] == k - j) {\n\t\t\t\t\t\t\tif (dp[k + 1][l - 1] == l - k - 1) {\n\t\t\t\t\t\t\t\tif (l == N - 1) {\n\t\t\t\t\t\t\t\t\tif (abs(num[k] - num[l]) < 2) {\n\t\t\t\t\t\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t\t\t\t\t\t//\tcout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (dp[l + 1][i + j - 1] == i + j - 1 - l&&abs(num[k] - num[l]) < 2) {\n\t\t\t\t\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t\t\t\t\t//\tcout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tvector<int>ret(N,0);\n\t\tret[1] = dp[0][1];\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tret[i] = dp[0][i];\n\t\t\tfor (int j = i - 1; j >= 1; j--) {\n\t\t\t\tret[i] = max(ret[i], ret[j - 1] + dp[j][i]);\n\t\t\t}\n\t\t\tans = max((int)ans,ret[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t\tcin >> N;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint w[302];\nint memo[302][302];\n\nint dfs(int l, int r){\n    if(r - l <= 1) return 0;\n    if(r - l == 2) {\n        if(abs(w[l] - w[l+1]) <= 1) return 2;\n        else return 0;\n    }\n    if(memo[l][r] != -1) return memo[l][r];\n\n    int ret = dfs(l+1, r);\n    for(int i=l+1;i<r;i+=2){\n        if(abs(w[l] - w[i]) <= 1){\n            int res = dfs(l+1, i);\n            if(res == i - l - 1){\n                ret = max(ret, 2 + res + dfs(i+1, r));\n            }\n        }\n    }\n\n    memo[l][r] = ret;\n    return ret;\n}\n\nint main(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i=0;i<n;i++){\n            cin >> w[i];\n        }\n\n        memset(memo, -1, sizeof(memo));\n        cout << dfs(0, n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <complex>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define Lower_bound(v, x) \\\n  distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) \\\n  distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nusing vll = vector<ll>;\nusing vP = vector<P>;\nusing vT = vector<T>;\nusing vvll = vector<vector<ll>>;\nusing vvP = vector<vector<P>>;\nusing dqll = deque<ll>;\n\nll dx[9] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};\nll dy[9] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\n\nconst ll INF = 1LL << 50;\n\nconst ll mod = 1e9 + 7;\n\nint main() {\n  ll n;\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n\n    vll ws(n);\n    rep(i, n) cin >> ws[i];\n\n    vvll dp(n, vll(n, 0));\n\n    rep(i, n - 1) dp[i][i + 1] = 2 * (abs(ws[i] - ws[i + 1]) <= 1);\n\n    for (ll h = 2; h <= n; h++) {\n      for (ll i = 0; i < n - h + 1; i++) {\n        ll k = i + h - 1;\n        for (ll j = i; j <= k - 1; j++) {\n          chmax(dp[i][k], dp[i][j] + dp[j+1][k]);\n        }  // j\n        bool cond = dp[i][k] == h && i >= 1 && k <= n - 2 &&\n                    abs(ws[i - 1] - ws[k + 1]) <= 1;\n        if (cond) {\n          dp[i - 1][k + 1] = h + 2;\n        }\n      }  // i\n    }    // h\n\n    ll ans = dp[0][n - 1];\n    cout << ans << endl;\n  }  // while\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i, n, N) for(ll i=(n); i<(N); i++)\n#define RREP(i, n, N) for(ll i=(N-1); i>=(n); i--)\n#define LREP(lst,itr) for(auto itr = lst.begin(); itr != lst.end(); ++itr)\n#define SPACEREP(lst,itr) for(auto itr=lst.begin(); itr!=lst.end();++itr){cout<<*itr<<(++itr!=anslist.end()?\" \":\"\\n\");itr--;}\n#define CK(n, a, b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(),(v).end()\n#define MCP(a, b) memcpy(b,a,sizeof(b))\n#define P(s) cout<<(s)<<endl\n#define P2(a, b) cout<<(a)<<\" \"<<(b)<<endl\n#define V2(T) vector<vector<T>>\ntypedef long long ll;\nusing namespace std;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n\nint dp[310][310];\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        vector<int> line(n);\n        REP(i,0,n) cin >> line[i];\n        REP(i,0,310){\n            REP(j,0,310){\n                dp[i][j]=0;\n            }\n        }\n\n        REP(len,2,n+1){\n            REP(left,0,n){\n                int right = left + len;\n                if(right > n)continue;\n                if(dp[left+1][right-1]==len-2 && abs(line[left]-line[right-1])<=1){\n                    dp[left][right]=len;\n                }\n\n                REP(mid,left+1,right){\n                    dp[left][right]=max(dp[left][right],dp[left][mid]+dp[mid][right]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tint dp[300][300];\n\t\tint w[300];\n\t\trep(i, n) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\trep(i, n) {\n\t\t\tdp[i][i] = 0;\n\t\t\tif (i < n - 1) {\n\t\t\t\tdp[i][i + 1] = 0;\n\t\t\t\tif (abs(w[i] - w[i + 1]) <= 1) {\n\t\t\t\t\tdp[i][i + 1] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tRep(l, 2,n) {\n\t\t\trep(i, n - l) {\n\t\t\t\tint res = 0;\n\t\t\t\tRep1(j, i, i + l-1) {\n\t\t\t\t\tres = max(res, dp[i][j] + dp[j+1][i + l]);\n\t\t\t\t}\n\t\t\t\tres = max(res, dp[i + 1][i + l - 1]);\n\t\t\t\tif (abs(w[i] - w[i + l]) <= 1 && dp[i + 1][i + l - 1] == l - 1) {\n\t\t\t\t\tres = l + 1;\n\t\t\t\t}\n\t\t\t\tdp[i][i + l] = res;\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<vector<bool>>dp(n,vector<bool>(n,0));\n\t\tvector<int>array(n);\n\t\trep(i,n) cin >> array[i];\n\t\trep(k,n)rep(i,n){\n\t\t\tif(!k || i+k>n-1)continue;\n\t\t\tif(k == 1){\n\t\t\t\tif(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = true;\n\t\t\t} else{\n\t\t\t\tif((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n\t\t\t\t\tdp[i][i + k] = true;\n\t\t\t\t}\n\t\t\t\tfor(int j = i+1; j<i+k;j++){\n\t\t\t\t\tdp[i][i + k] = dp[i][i + k] or (dp[i][j] and dp[j + 1][i + k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int s = 0;s < n;s++){\n\t\t\tint temp = 0;\n\t\t\tfor(int i = s; i<n;i++){\n\t\t\t\tfor(int j = n-1; j >= 0;--j){\n\t\t\t\t\tif(dp[i][j]){\n\t\t\t\t\t\ttemp += j-i+1;\n\t\t\t\t\t\ti = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcmax(ans, temp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n){\n            if(!k || i+k>n-1)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n                    cmax(dp[i][i+k],dp[i+1][i+k-1]+2);\n                }\n                for(int j = i+1; j<i+k;j++){\n                    if(dp[i][j] && dp[j+1][i+k])cmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int s = 0;s < n;s++){\n            int temp = 0;\n            for(int i = s; i<n;i++){\n                for(int j = n-1; j >= 0;--j){\n                    if(dp[i][j]){\n                        temp += j-i+1;\n                        i = j;\n                    }\n                }\n                cmax(ans, temp);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <stdio.h>\nusing namespace std;\nint func(vector<int> w){\n    int s = w.size();\n    if(s>1){\n        int temp;\n        int min = s;\n        for(int i=0;i<s-1;i++){\n            vector<int> remain;\n            for(int j=0;j<s;j++){\n                if(j==i){j+=2;}\n                if(j>=s)break;\n                remain.push_back(w[j]);\n            }\n            if(abs(w[i]-w[i+1])<2){\n                temp = func(remain);\n                min = min > temp ? temp : min;\n            }\n        }\n        return min;\n    } else {\n        return s;\n    }\n}\nvoid q_daruma(int n){\n    vector<int> w;\n    int t;\n    for(int i=0;i<n;i++){cin>>t;w.push_back(t);}\n    cout << w.size()-func(w) << \"\\n\";\n}\nint main(){\n    int n;\n    while(cin >> n, n!=0){\n        q_daruma(n);\n    }\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nbool** table;\nint** dp;\nint N;\n\nint recursive(int left,int right){\n\n\tif(left == right)return dp[left][right] = 0;\n\tif(dp[left][right] != -1)return dp[left][right]; //?????¢???????????´???\n\tif((right-left+1)%2 == 1){ //??????????\\???°?????´???\n\t\treturn dp[left][right] = max(recursive(left,right-1),recursive(left+1,right));\n\t}\n\tif(table[left][(right-left+1)/2] == true)return dp[left][right] = right-left+1; //left???right?????¨????¶?????????´???\n\tif(right == left+1 && table[left][1] == false)return 0;\n\n\tint ans = 0;\n\tfor(int i = left+1; i <= right-2; i++){\n\t\tans = max(ans,recursive(left,i)+recursive(i+1,right));\n\t}\n\treturn dp[left][right] = ans;\n}\n\nint main(){\n\n\tint data[301];\n\ttable = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tdp = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[151];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 0; i <= 300; i++){\n\t\t\tfor(int k = 0; k <= 150; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= 300; k++){\n\t\t\t\tdp[i][k] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1)table[i][1] = true;\n\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",recursive(1,N));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nint dp[300][300];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N; cin >> N;\n    if (not N) break;\n    vector<int> W(N); REP(i, N) cin >> W[i];\n    memset(dp, 0, sizeof(dp));\n    FOR(w, 2, N + 1) REP(left, N - w + 1) {\n      // [left, right]\n      int right = left + w - 1;\n      if (dp[left + 1][right - 1] == w - 2 and abs(W[left] - W[right]) <= 1) {\n        dp[left][right] = w;\n      } else {\n        FOR(mid, left, right) {\n          dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid + 1][right]);\n        }\n      }\n    }\n    cout << dp[0][N - 1] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n-1){\n            if(!k || i+k>n-1)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n                    cmax(dp[i][i+k],dp[i+1][i+k-1]+2);\n                }\n                for(int j = i+1; j<i+k;j++){\n                    if(dp[i][j] && dp[j+1][i+k])cmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int s = 0;s < n;s++){\n            int temp = 0;\n            for(int i = s; i<n;i++){\n                for(int j = n-1; j >= 0;--j){\n                    if(dp[i][j]){\n                        temp += j-i+1;\n                        i = j;\n                    }\n                }\n                cmax(ans, temp);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\nint dp1[310][310];\nint dp2[310];\n\nint main(){\n    int n,w[310];\n\n    while(true){\n        cin >> n;\n        if(n == 0)break;\n        for(int i = 0;i < 305;i++){ //初期化\n            dp2[i] = 0;\n            for(int j = 0;j < 305;j++){\n                dp1[i][j] = 0;\n            }\n        }\n        for(int i = 0;i < n;i++)cin >> w[i];\n        for(int len = 1;len < n;len+=2){\n            for(int i = 0;i+len < n;i++){\n                int j = i + len;\n                if(abs(w[i]-w[j]) <= 1 && (len == 1 || dp1[i+1][j-1] != 0)){\n                    dp1[i][j] = dp1[i+1][j-1] + 2;\n                }else{\n                    for(int k = 1;i+k < j-1;k++){\n                        if(dp1[i][i+k] != 0 && dp1[i+k+1][j] != 0){\n                            dp1[i][j] = len+1;\n                        }\n                    }\n                }\n            }\n        }\n        for(int i = 1;i < n;i++){\n            dp2[i] = dp1[0][i];\n            for(int j = 0;j < i;j++){\n                dp2[i] = max(dp2[i],dp2[j]+dp1[j+1][i]);\n            }\n        }\n        cout << dp2[n-1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\nconst int INT_INF = 2147483647;\nconst long long LL_INF = 1LL<<60;\nconst long long MOD = 1000000007;\n\n#define CLR(a) memset((a), 0, sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nVI w;\nint dp[301][301];\n\nint rec(int l, int r){\n    if(dp[l][r] != -1) return dp[l][r];\n\n    if(r-l < 2) return dp[l][r] = 0;\n    if(r-l == 2 && abs(w[r-1]-w[l])<2) return dp[l][r] = 2;\n    if(r-l == 2 && abs(w[r-1]-w[l])>1) return dp[l][r] = 0;\n\n    if(abs(w[r-1]-w[l])<2 && rec(l+1,r-1) == r-l-2) return dp[l][r] = r-l;\n    int res = 0;\n    FOR(i,l+1,r){\n        chmax(res, rec(l,i)+rec(i,r));\n    }\n    return dp[l][r] = res;\n}\nint main(void){\n    \n    int n;\n    cin >> n;\n    while(n != 0){\n        w.assign(n,0); REP(i,n) cin >> w[i];\n        REP(i,n+1)REP(j,n+1) dp[i][j] = -1;\n        int ans = rec(0,n);\n        cout << ans << en;\n        cin >> n;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\nint xcomp(vector<LL>& a, vector<LL>& b) {\n\treturn a[0] < b[0];\n}\n\n#define XSORT(c) sort((c).begin(),(c).end(),xcomp)\n\n#define ALL(x) (x).begin(),(x).end()\nLL mod = 1000000007;\n\nbool hantei(LL a, LL b) {\n\tif (a + 1 == b) {\n\t\treturn true;\n\t}\n\telse\n\t\tif (a == b) {\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tif (a == b + 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n}\n\nint main() {\n\twhile (true)\n\t{\n\t\tLL  n;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<LL> num(n, 0);\n\t\tvector<LL> v(n, -9999);\n\n\t\tREP(i, n) {\n\t\t\tcin >> v[i];\n\t\t}\n\t\tREP(i, n - 1) {\n\t\t\tif (hantei(v[i], v[i + 1])) {\n\t\t\t\tnum[i] = 2;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\n\t\twhile (flag) {\n\t\t\tflag = false;\n\n\t\t\tREP(i, n) {\n\t\t\t\tLL hoge = num[i];\n\t\t\t\tif (i + num[i]<n) {\n\t\t\t\t\tif (hoge < num[i] + num[i + num[i]]) {\n\t\t\t\t\t\thoge = num[i] + num[i + num[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i + 1<n) {\n\t\t\t\t\tif (i + num[i + 1] + 1<n) {\n\t\t\t\t\t\tif (hantei(v[i], v[i + num[i + 1] + 1])) {\n\t\t\t\t\t\t\tif (hoge < num[i + 1] + 2) {\n\t\t\t\t\t\t\t\thoge = num[i + 1] + 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}a\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hoge != num[i]) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tnum[i] = hoge;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tvector<LL> fuga(n * 3, 0);\n\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tfuga[i] = max(fuga[i + 1], num[i] + fuga[i + num[i]]);\n\t\t}\n\n\t\tcout << fuga[0] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\nint dp[310][310];\nint dp2[310][310];\nint a[310];\n         signed main(){\n\t\n\tint n;\n         \twhile(1){\n         \tcin>>n;\n         \t\tif(n==0) return 0;\n         \t\tfor(int i=0;i<310;i++)for(int j=0;j<310;j++)dp[i][j]=0,dp2[i][j]=0;\n         \t\tfor(int i=0;i<310;i++)a[i]=0;\n         \t\t\n         \t\tfor(int i=0;i<n;i++)cin>>a[i];\n         \t\t\n         \t\tfor(int i=0;i<n-1;i++)if(abs(a[i]-a[i+1])<=1)dp[i][i+2]=1;\n         \t\t\n         \t\tfor(int i=0;i<n;i++)dp[i][i]=1;\n         \t\tfor(int d=4;d<=n;d+=2){\n         \t\t\tfor(int i=0;i+d<=n;i++){\n         \t\t\t\tint j=i+d;\n         \t\t\t\tbool bo=false;\n         \t\t\t\tfor(int k=i+2;k<=j-2;k+=2)if(dp[i][k] && dp[k][j]) bo=1;\n         \t\t\t\tif(dp[i+1][j-1] && abs(a[i]-a[j-1])<=1) bo=1;\n         \t\t\t\tif(bo) dp[i][j]=1;\n         \t\t\t}\n         \t\t}\n         \t\t\n         \t\t\n         \t\tfor(int i=0;i<n-1;i++)if(abs(a[i]-a[i+1])<=1)dp2[i][i+2]=2;\n         \t\t\n         \t\tfor(int d=3;d<=n;d++){\n         \t\t\tfor(int i=0;i+d<=n;i++){\n         \t\t\t\tint j=i+d;\n         \t\t\t\tif(dp[i][j]){\n         \t\t\t\t\tdp2[i][j]=j-i;\n         \t\t\t\t\tcontinue;\n         \t\t\t\t}\n         \t\t\t\tint e=0;\n         \t\t\t\tfor(int k=i+1;k<=j-1;k++)e=max(e,dp2[i][k]+dp2[k][j]);\n         \t\t\t\tdp2[i][j]=e;\n         \t\t\t\t\n         \t\t\t}\n         \t\t\t\n         \t\t}\n         \t\tcout<<dp2[0][n]<<endl;\n         \t}\n         \n         \t//cout<<ans<<endl;\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n\nint main(void){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0){ break; }\n\n    vector<int> w(n);\n    for(int i = 0; i < n; i++){ cin >> w[i]; }\n\n    vector<vector<int> > dp(n, vector<int>(n + 1, 0));\n    for(int k = 2; k <= n; k++){\n      for(int i = 0; i < n; i++){\n        if(i + k <= n){\n          for(int j = 1; j < k; j++)\n            dp[i][i + k] = max(dp[i][i + k], dp[i][i + j] + dp[i + j][i + k]);\n          if(dp[i + 1][i + k - 1] == k - 2 && abs(w[i] - w[i + k - 1]) <= 1)\n            dp[i][i + k] = dp[i + 1][i + k - 1] + 2;\n        }\n      }\n    }\n\n    cout << dp[0][n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n\t#include <cstdio>\n\t#include <algorithm>\n\t#include <string>\n\t#include <cstring>\n\t#include <cctype>\n\t#include <cmath>\n\t#include <stack>\n\t#include <queue>\n\t#include <vector>\n\t#include <set>\n\t#include <map>\n\t#include <list>\n\t#include <stdio.h>\n\t#include <string.h>\n\t#include <cstdlib>\n\t#include <math.h>\n\t#include <bitset>\n\t#include <iterator>\n\t#include <iomanip>\n\t#include <sstream>\n\t#include <numeric>\n\t#include <cassert>\n\tusing namespace std;\n\tint dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0};\n\tlong long gcd(long long a,long long b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\tlong long lcm(long long a,long long b){if(a==0){return b;} return a/gcd(a,b)*b;}\n\t#define INF 2000000000\n\t#define MOD 1000000007\n\t#define sym cout<<\"---------\"<<endl;\n\t#define ll long long\n\t#define mk make_pair\n\t#define en endl\n\t#define RE return 0\n\t#define int ll\n\t#define P pair<int,int>\n\t\n\tint dp[305][305];\n\nsigned main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint w[305];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor(int i=0; i<n; i++) cin>>w[i];\n\t\t\n\t\tfor(int W=2; W<=n; W++){\n\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\tint r=l+W;\n\t\t\t\tif(r>n) continue;\n\t\t\t\t\n\t\t\t\tif(dp[l+1][r-1]==W-2&&abs(w[l]-w[r-1])<=1) dp[l][r]=W;\n\t\t\t\t\n\t\t\t\tfor(int mid=l; mid<=r; mid++){\n\t\t\t\t\tdp[l][r]=max(dp[l][r], dp[l][mid]+dp[mid][r]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][n]<<en;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * aoj/1611_3rd/main.cpp\n */\n\n// C++ 14\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring> // memset\n#include <cassert>\n\nusing namespace std;\n\n#define ll long long\n\n#define loop(__x, __start, __end) for(int __x = __start; __x < __end; __x++)\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false; }\n\nll N;\nvector<ll> A(310);\n\nll dp[310][310]; // dp[l][r] := [l:r) で落とせた最大数\n\nbool input() {\n  cin >> N;\n  if (N==0) return false;\n  ll a;\n  loop(n,0,N) {\n    cin >> A[n];\n  }\n  return true;\n}\n\nll receive() {\n  memset(dp, 0, sizeof(dp));\n  for (int len=2; len<=N; len++) {\n    for (int l=0; l+len<=N; l++) {\n      int r = l+len;\n      if (len == 2) { dp[l][r] = 2 * (abs(A[l] - A[l+1]) <= 1); continue; }\n      if (abs(A[l] - A[r-1]) <= 1 && dp[l+1][r-1] == len - 2) {\n        chmax(dp[l][r], dp[l+1][r-1] + 2);\n      }\n      for (int k=l+1; k<r; k++) {\n        chmax(dp[l][r], dp[l][k] + dp[k][r]);\n      }\n    }\n  }\n  return dp[0][N];\n}\n\nvoid solve() {\n  cout << receive() << endl;\n}\n\nint main() {\n  // cout.precision(15);\n  while (input()) solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_N = 300;\nint n;\nint w[MAX_N];\nint memo[MAX_N][MAX_N + 1];\n\nint dfs(const int l, const int r) {\n\tif(l >= r) return 0;\n\tint &res = memo[l][r];\n\tif(res != -1) return res;\n\n\tres = dfs(l + 1, r);\n\tfor(int i = l + 1; i < r; i += 2) {\n\t\tconst int width = i - l - 1;\n\t\tif(abs(w[l] - w[i]) <= 1 && dfs(l + 1, i) == width) {\n\t\t\tres = max(res, dfs(i + 1, r) + width + 2);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\twhile(cin >> n && n) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tcout << dfs(0, n) << endl;\n\t}\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);i--)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nint n;\n\nvoid solve(){\n  vector<int> a(n);\n  REP(i,n) cin >> a[i];\n  \n  mat dp(n+1,vec(n+1,0));\n  REP(i,n){\n    RREP(j,i){\n      FOR(k,j,i) dp[j][i+1] = max(dp[j][i+1],dp[j][k]+dp[k+1][i]+(abs(a[i]-a[k])<=1 && dp[k+1][i] == i-(k+1))*2);\n      //cout << j SP i+1 SP dp[j][i+1]<< endl; \n    }\n  }\n\n  cout << dp[0][n] << endl;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  while(cin >> n, n) solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\nusing LL = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<LL>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<LL, LL>;\tusing VPL = vector<PLL>;\ntemplate<class T>using Grid = vector<vector<T>>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr LL inf_ll = (LL)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T = long long>inline T BIT(int b)noexcept { return T{ 1 } << b; }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ntemplate<class T>inline bool inRange(const T& v, const T& min, const T& max)noexcept { return min <= v && v <= max; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_WIN32) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (LL)(c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T input() { T v; InputF(v); return v; }\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { return input<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(\"%s\", D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n// ---------------------------------------------------------------- //\n\ninline bool check(int a, int b) {\n\treturn abs(a - b) <= 1;\n}\n\nvoid solve(int n) {\n\tVI a = in[n];\n\n\tauto check2 = [&](int l, int r, int l2, int r2) {\n\t\tassert((r2 - l2) + 2 == (r - l));\n\t\tif (l == l2) {\n\t\t\treturn check(a[r2], a[r2 + 1]);\n\t\t} else if (r == r2) {\n\t\t\treturn check(a[l], a[l + 1]);\n\t\t} else {\n\t\t\treturn check(a[l2 - 1], a[r2]);\n\t\t}\n\t};\n\n\tVVI dp(n + 1, VI(n + 1)); // [i, j)\n\trep(l, n - 1) {\n\t\tif (check(a[l], a[l + 1])) {\n\t\t\tdp[l][l + 2] = 2;\n\t\t}\n\t}\n\tFOR(s, 3, n + 1)rep(l, n - s + 1) {\n\t\tint r = l + s;\n\t\tif (dp[l + 1][r - 1] == s - 2 && check(a[l], a[r - 1])) {\n\t\t\tdp[l][r] = s;\n\t\t}\n\t\tFOR(k, l, r + 1) {\n\t\t\tchmax(dp[l][r], dp[l][k] + dp[k][r]);\n\t\t}\n\t}\n\tdump(dp);\n\tout(dp[0][n]);\n}\n\nint main() {\n\tfor (int n; cin >> n && n;) {\n\t\tsolve(n);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef long double ld;\n#define MOD 998244353\ntemplate<class T>inline bool chmax(T& a,T b){if (a<b){a=b;return 1;}return 0;}\ntemplate<class T>inline bool chmin(T& a,T b){if (a>b){a=b;return 1;}return 0;}\nconst long long INF = 1LL << 60;\nbool pairCompare(const pair<double,ll>& firstElof, const pair<double,ll>& secondElof){\n    return firstElof.first < secondElof.first;\n}\nbool pairCompareSecond(const pair<double,ll>& firstElof, const pair<double,ll>& secondElof){\n    return firstElof.second < secondElof.second;\n}\n//四方向への移動ベクトル\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct edge{//グラフに使うヤツ\n    ll from,to,cost;\n};\n\ntypedef vector<vector<edge> > G;\nll gcd(ll a,ll b){\n    if (a%b==0)return(b);\n    else return(gcd(b,a%b));\n}\n\nint main() {\n    while(true){\n        ll n;\n        cin >> n;\n        if (n==0)break;\n        ll w[n];\n        for (ll i=0;i<n;i++)cin >> w[i];\n        ll dp[n+1][n+1];\n        memset(dp,0,sizeof(dp));\n        for (ll i=2;i<=n;i++){\n            for (ll l=0;l<=n;l++){\n                ll r=i+l;\n                if (i+l>n){\n                    continue;\n                }\n                if (dp[l+1][r-1]==i-2 and abs(w[l]-w[r-1])<=1)dp[l][r]=i;\n                for (ll mid=l;mid<=r;mid++){\n                    dp[l][r]=max(dp[l][r],dp[l][mid]+dp[mid][r]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, start, count) for (int i = (start); i < (int)(count); ++i)\n#define rep(i, count) REP(i, 0, count)\n#define ALLOF(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint n;\nvector<int> w;\nvector<vector<int>> dp;\n\n// メモ化再帰（トップダウン）に書いていく\nint rec(int l, int r) {\n    int res = 0;\n    // もう計算してる\n    if (dp[l][r] != -1) return dp[l][r];\n\n    // 範囲内に2個以上ない\n    if (abs(r - l) <= 1) return 0;\n\n    // lとrをはじき出せるパターン\n    // - wの差が1\n    // - 範囲内部 [l + 1, r - 1) が全て取り除ける(範囲r - l からスミの2個を除いたもの)\n    if(abs(w[l] - w[r - 1]) <= 1 && rec(l + 1, r - 1) == r - l - 2) {\n        res = r - l;\n    }\n\n    // 区間を細分化して解くパターン\n    for(int mid = l + 1; mid <= r - 1; mid++) {\n        res = max(res, rec(l, mid) + rec(mid, r));\n    }\n\n    return dp[l][r] = res;\n}\n\nint main(void)\n{\n    int d;\n    cin >> d;\n    while (d != 0) {\n        n = d;\n        w.assign(n, 0);\n        dp.assign(310, vector<int>(310, -1));\n        \n        rep(i, n)\n        {\n            cin >> w[i];\n        }\n\n        cout << rec(0, n) << endl;\n\n        cin >> d;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n, w[300], dp[300][300], dp2[300][300];\n\nint main() {\n\n\twhile (true) {\n\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif (abs(w[i] - w[i + 1]) <= 1) {\n\t\t\t\tdp[i][i + 1] = 2;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 3; i < n; i += 2) {//区間の大きさ\n\t\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\t\t//両端の計算\n\t\t\t\tif (abs(w[j] - w[j + i]) <= 1 && dp[j + 1][j + i - 1] > 0) {\n\t\t\t\t\tdp[j][j + i] = dp[j + 1][j + i - 1] + 2;\n\t\t\t\t}\n\t\t\t\tfor (int k = j + 1; k < j + i; k += 2) {\n\t\t\t\t\t//jからkを中間とした長i+1区間を取り出せるかどうか\n\n\t\t\t\t\tif (dp[j][k] > 0 && dp[k + 1][j + i] > 0) {\n\t\t\t\t\t\tdp[j][j + i] = max(dp[j][j + i], dp[j][k] + dp[k + 1][j + i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//区間での取り出せる個数の最大を計算\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\t\t//dpの方の取り出せる数を先に入れる\n\t\t\t\tdp2[j][j + i] = dp[j][j + i];\n\n\t\t\t\tfor (int k = j + 1; k < j + i; k++) {\n\t\t\t\t\t//jからkを中間とした長i+1区間の取り出せる個数の最大\n\n\t\t\t\t\t//ここが間違っている\n\t\t\t\t\tdp2[j][j + i] = max(dp2[j][j + i], dp2[j][k] + dp2[k + 1][j + i]);\n\t\t\t\t\tdp2[j][j + i] = max(dp2[j][j + i], dp2[j][k] + dp[k + 1][j + i]);\n\t\t\t\t\tdp2[j][j + i] = max(dp2[j][j + i], dp[j][k] + dp2[k + 1][j + i]);\n\t\t\t\t\tdp2[j][j + i] = max(dp2[j][j + i], dp[j][k] + dp[k + 1][j + i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp2[0][n - 1] << endl;\n\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = dp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1<<30\n#define LINF (ll)1<<62\n#define MAX 510000\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(ll i=(a); i<(b); i++)\n#define all(x) (x).begin(),(x).end()\n#define uni(q) unique(all(q)),q.end()\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll, ll> P;\ntypedef vector<pair<ll, ll>> vpl;\n\n\n\nint main(){\n    while(1){\n        ll n; cin >> n;\n        if(n==0) break;\n        vl w(n);\n        rep(i,n) cin >> w[i];\n        ll dp[n+1][n+1] = {};\n        for(ll W=2; W<=n; W++){\n            rep(l,n){\n                if(l + W > n) continue;\n                ll r = l + W;\n                if(dp[l+1][r-1] == W-2 && abs(w[l]-w[r-1])<=1){\n                    dp[l][r] = W;\n                }\n                REP(mid,l,r+1){\n                    dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid][r]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//区間dp\n#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n#define EQ(a,b) (abs(a - b) < 1e-10)\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<bool> VB;\ntypedef vector<VB>  VVB;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\nVVI dp;\nVI w;\nint n;\n\nint dfs(int l,int r) {\n\tif (dp[l][r] != loINF) return dp[l][r];\n\tint width = (r - l) + 1;\n\tif (width == 2) {\n\t\tif (abs(w[l] - w[r]) <= 1) return 2; else return 0;\n\t}\n\tif (width == 4) {\n\t\tint ans = dfs(l,l+1)+dfs(l+2,r);\n\t\tint ans2 = dfs(l+1,l+2);\n\t\tif (ans2 == 2 && abs(w[l]-w[r]) <= 1) ans2 += 2;\n\t\treturn dp[l][r] = max(ans,ans2);\n\t}\n\n\tint ans = 0;\n\tint ans2 = dfs(l+1,r-1);\n\tif (ans2 == width-2 && abs(w[l]-w[r]) <= 1) ans2 += 2;\n\telse {\n\t\tfor (int i = (l+1);i <= (r-2);i+=2) {\n\t\t\tans = max(ans,dfs(l,i)+dfs(i+1,r));\n\t\t\tif (ans == width) break;\n\t\t}\n\t}\n\treturn dp[l][r] = max(ans,ans2);\n}\n\nint main(void) {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tw.resize(n);\n\t\tdp = VVI(n,VI(n,loINF));\n\t\tREP(i,n) { cin >> w[i];}\n\t\tif (n % 2) cout << max(dfs(1,n-1),dfs(0,n-2)) << endl;\n\t\telse cout<< dfs(0,n-1) << endl;\n\t\t//dump2d_arr(dp);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\nusing namespace std; \n\n#define INF 1001000100010001000 \n#define MOD 1000000007 \n#define EPS 1e-10 \n#define int long long \n#define rep(i, N) for (int i = 0; i < N; i++) \n#define Rep(i, N) for (int i = 1; i < N; i++) \n#define For(i, a, b) for (int i = (a); i < (b); i++) \n#define pb push_back \n#define eb emplace_back \n#define mp make_pair \n#define i_i pair<int, int> \n#define vi vector<int> \n#define vvi vector<vi > \n#define vb vector<bool> \n#define vvb vector<vb > \n#define vp vector< i_i > \n#define all(a) (a).begin(), (a).end() \n#define Int(x) int x; cin >> x; \n#define int2(x, y) Int(x); Int(y); \n#define int3(x, y, z) Int(x); int2(y, z); \n#define fir first #define sec second \n#define ffir first.first \n#define fsec first.second \n#define sfir second.first \n#define ssec second.second \n#define Decimal fixed << setprecision(10) \n\n//int dxy[5] = {0, 1, 0, -1, 0}; \n\nint n;\nint data[300];\nint dp[300][301]; // hankai\nint score[300][301];\n\nvoid make(int st, int en)\n{\nif (dp[st][en]) return;\ndp[st][en] = 1;\nif (0 <= st - 2 && abs(data[st-2] - data[st-1] ) < 2 ) {\nmake(st-2, en);\n}\nif (0 <= st - 1 && en < n && abs(data[st-1] - data[en]) < 2) {\nmake(st-1, en+1);\n}\nif (en + 1 < n && abs(data[en] - data[en+1]) < 2) {\nmake(st, en+2);\n}\n}\n\nint solve(int st, int en)\n{\nif ( dp[st][en] ) return 0; \nif ( score[st][en] ) return score[st][en];\nif (en - st < 2) return en - st;\nint ret = en - st;\nfor (int i = st+2; i < en; i++) {\nif (dp[st][i]) {\nret = min(solve(i-1, en), ret)\n}\n}\nreturn score[st][en] = min(ret, 1+solve(st+1, en));\n}\n\nsigned main() \n{ \nstd::ios::sync_with_stdio(false); \nstd::cin.tie(0); \n\ncin >> n;\nwhile ( n ) {\nmemset(data, 0, sizeof(data))\nmemset(dp, 0, sizeof(dp));\nrep(i, n) cin >> data[i];\nrep(i, n-1) if ( abs(data[i] - data[i+1]) < 2 )\nmake(i, i+2);\ncout << n - solve(0, n) <<endl;\ncin >> n;\n}\n\nreturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);++(i))\n\nint main()\n{\n\tint n;\n\twhile(cin >> n , n)\n\t{\n\t\tvector<int> w(n,0);\n\t\tfor(int i = 0;i < n;i++)\n\t\t{\n\t\t\tcin >> w[i];\n\t\t}\n\t\t\n\t\tvector<vector<int>> dp(n + 1,vector<int>(n + 1,0));\n\n\t\tfor(int W = 2;W <= n;W++)\n\t\t{\n\t\t\t//left\n\t\t\tfor(int l = 0;l < n;l++)\n\t\t\t{\n\t\t\t\tint r = l + W - 1;\n\t\t\t\tif(r >= n) continue;\n\n\t\t\t\tif(dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r]) <= 1)\n\t\t\t\t\tdp[l][r] = W;\n\n\t\t\t\tfor(int mid = l;mid <= r;mid++)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r] = max(dp[l][r] , dp[l][mid] + dp[mid + 1][r]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(obj) begin(obj), end(obj)\nusing namespace std;\n\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nint N;\nvector<int> w;\nvector<vector<int>> dp;\n\nint rec(int l = 0, int r = N) {\n    if ((r - l) <= 1) return 0;\n    if ((r - l) == 2) {\n        if (abs(w[l] - w[l + 1]) <= 1) {  // 隣り合う2つの差が1以下\n            return 2;\n        } else {\n            return 0;\n        }\n    }\n    int &ret = dp[l][r];\n    if (ret != -1) return ret;  // 既に計算済みならその値を使う\n\n    if (abs(w[l] - w[r-1]) <= 1 && rec(l + 1, r - 1) == r - l - 2) chmax(ret, r - l);\n    for (int i = l + 1; i <= r - 1; i++) {\n        chmax(ret, rec(l, i) + rec(i, r));\n    }\n\n    return ret;\n}\n\nint main() {\n    vector<int> ans;\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        w.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> w.at(i);\n        }\n\n        dp.assign(N + 2, vector<int>(N + 2, -1));  // 初期化\n\n        ans.push_back(rec());\n    }\n\n    for (auto i : ans) {\n        cout << i << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define rep(i,n) for(int i=0, i##_len=(int)(n); i<i##_len; i++)\n#define reps(i,n) for(int i=1 , i##_len=(int)(n);i<=i##_len;i++)\n#define rrep(i,n) for(int i=((int)(n)-1);i>=0;i--)\n#define rreps(i,n) for(int i=((int)(n));i>0;i--)\n#define all(x) (x).begin(), (x).end()\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define solve(a) ((a)?\"Yes\":\"No\")\ntypedef vector<long long> V;\ntypedef vector<V> VV;\ntypedef pair<long long , long long> P;\ntypedef vector<P> VP;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1;} return 0;}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1;} return 0;}\nconst long long INFLL = 1LL<<62;\nconst int INF = 1<<30;\nconst double PI=acos(-1);\nint func(int l,int r,vector<vector<int>>&dp,vector<int>&w){\n\t//clog << l << \" \" << r<<endl; \n\tif (dp[l][r] == -1)\n\t{\n\t\tchmax(dp[l][r],0);\n\t\tif(r!=l+1){\n\t\t\tfor(int med=l;med<r;med++){\n\t\t\t\tif (func(l+1, r-1, dp, w) ==r-l-1){\n\t\t\t\t\tif(abs(w[l]-w[r])<=1){\n\t\t\t\t\t\tdp[l][r]=r-l+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\tchmax(dp[l][r], func(l, med, dp, w) + func(med + 1, r, dp, w));\n\t\t\t}\n\t\t}else if(l!=r){\n\t\t\tif(abs(w[l]-w[r])<=1){\n\t\t\t\tdp[l][r]=2;\n\t\t\t}\n\t\t}\n\t}\n//\tclog << l << \" \" << r << \" ->  \" << dp[l][r] << endl;\n\treturn dp[l][r];\n}\nint main(){\n\tint n=1;\n\tvector<vector<int>>dp(310,vector<int>(310,-1));\n\tvector<int>w(310,-2);\n\twhile(1){\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tdp[i][j]=-1;\n\t\t}\n\t\tw[i]=-2;\n\t}\n\tcin >>n;\n\tif(n==0){\n\t\tbreak;\n\t}\n\trep(i,n){\n\t\tcin>>w[i];\n\t}\n\n\tcout<<func(0,n-1,dp,w)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<deque>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_bacq\n#define MP maqe_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dp[310][310];\n\nint main()\n{\n\tint n;\n\t\n\twhile(cin >> n,n)\n\t{\n\t\tREP(i,310)REP(j,310)dp[i][j] = 0;\n\t\t\n\t\tvector<int> v(n);\n\t\tREP(i,n)cin >> v[i];\n\t\t\n\t\tREP(i,n-1)if(abs(v[i]-v[i+1]) < 2)dp[i][i+1] = 2;\n\t\t\n\t\tfor(int q = 2;q < n;q++)\n\t\t{\n\t\t\tfor(int i = 0;i+q < n;i++)\n\t\t\t{\n\t\t\t\tint j = i+q;\n\t\t\t\tfor(int k = 0;k < j-i;k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j] = max(dp[i][j],dp[i][i+k]+dp[i+k+1][j]);\n\t\t\t\t}\n\t\t\t\tif(dp[i+1][j-1] == j-i-1)\n\t\t\t\t{\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tif(abs(v[i]-v[j])<2)tmp = 2;\n\t\t\t\t\tdp[i][j] = max(dp[i][j],j-i-1+tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dp[0][n-1] << endl;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i=0; i < (int)(n); i++)\nusing ull = unsigned long long;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint dp[310][310];\nint w[310];\n\nint fall(int left, int right) {\n    if (dp[left][right] >= 0) return dp[left][right];\n    if (left==right) return dp[left][right] = 0;\n    if (left + 1 == right) {\n        if (abs(w[left] - w[right]) <= 1) return dp[left][right] = 2;\n        else return dp[left][right] = 0;\n    }\n\n    for (int mid=left; mid<=right-1; mid++) {\n        dp[left][right] = max(dp[left][right], fall(left, mid) + fall(mid+1, right));\n    }\n\n    if (right - left >= 3 && dp[left+1][right-1] == right - left - 1) {\n        if (abs(w[left] - w[right]) <= 1) dp[left][right] = right - left + 1;\n    }\n    return dp[left][right];\n}\n\nvoid daruma (int N) {\n    rep(i, N) cin >> w[i];\n    rep(i, N) rep(j, N) dp[i][j] = -1;\n\n    int ans = fall(0, N-1);\n    cout << ans << endl;\n\n}\n\nint main() {\n    int n;\n    while (cin >> n, n != 0) {\n        daruma(n);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\nint n;\nvector<int> w;\nint dp[310][310];\n\nint calc(int l, int r){\n    if(dp[l][r] != -1) return dp[l][r];\n    if(l + 1 >= r) return dp[l][r] = 0;\n    int res = 0;\n    rep(i, l, r - 1){\n        rep(j, i + 1, r){\n            int tmp = 0;\n            tmp += calc(l, i) + calc(i + 1, j) + calc(j + 1, r);\n            int cent = calc(i + 1, j);\n            int len = j - i - 1;\n            if(abs(w[i] - w[j]) <= 1 && len == cent * 2) tmp++;            \n            res = max(res, tmp);\n        }        \n    }\n    return dp[l][r] = res;\n}\n\nint main() {\n    while(cin >> n, n){\n        w.clear();\n        w.resize(n);\n        rep(i, 0, n) cin >> w[i];\n        rep(i, 0, n + 1) rep(j, 0, n + 1) dp[i][j] = -1;\n        int ans = calc(0, n);\n        cout << ans * 2 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n//const ull mod = 1e9 + 7;\nconst ll mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n// conversion number to bit\nstring num2bit(ll num, ll len){\n  string bit = \"\";\n  REP(i, len){\n    bit += char('0'+(num>>i & 1));\n  }\n  return bit;\n}\n\nll dp[303][303];\n\nll rec(ll l, ll r, vector<ll> &w){\n\tif(dp[l][r]>=0) return dp[l][r];\n\tif(l>=r){\n\t\tdp[l][r] = 0;\n\t\treturn 0;\n\t}\n\tif(l+1==r){\n\t\tdp[l][r] = 1;\n\t\treturn 1;\n\t}\n\n\tll res = rec(l+1, r-1, w);\n\tif(res != 0 || abs(w[l]-w[r-1])>1){\n\t\tres += 2;\n\t}\n\n\tfor(int m=l+1;m<r;m++){\n\t\tll tmp1 = rec(l, m, w);\n\t\tll tmp2 = rec(m, r, w);\n\t\tchmin(res, tmp1+tmp2);\n\t}\n\n\tdp[l][r] = res;\n\treturn res;\n}\n\nvoid solve(){\n\tll n;\n\tcin >> n;\n\tif(n==0) exit(0);\n\tvector<ll> w(n);\n\tREP(i, n) cin >> w[i];\n\n\tREP(i, 303)REP(j, 303) dp[i][j] = -1;\n\n\tll tmp = rec(0, n, w);\n\n\t/*\n\tREP(i, n+1){\n\t\tREP(j, n+1){\n\t\t\tcerr << dp[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n\t*/\n\n\tcout << n-tmp << endl;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(1){\n    \tsolve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> memo;\nvector<int> sz;\n\nint dp(int l, int r) {\n  // dp[i,j] := [i,j]で出せるブロックの最大値\n  if (memo[l][r] != -1)\n    return memo[l][r];\n  if (l == r)\n    return memo[l][r] = 0;\n  if (r - l == 1) {\n    if (abs(sz[r] - sz[l]) <= 1)\n      return memo[l][r] = 2;\n    else\n      return memo[l][r] = 0;\n  }\n  if (dp(l + 1, r - 1) == r - l - 1 && abs(sz[r] - sz[l]) <= 1) {\n    return memo[l][r] = r - l + 1;\n  } else {\n    int res = 0;\n    for (int i = l; i <= r - 1; i++) {\n      res = max(res, dp(l, i) + dp(i + 1, r));\n    }\n    return memo[l][r] = res;\n  }\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n    sz.resize(n);\n    for (int i = 0; i < n; i++) {\n      cin >> sz[i];\n    }\n    memo.assign(n, vector<int>(n, -1));\n    cout << dp(0, n - 1) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 310;\n//????????????\nint dp[MAX_N][MAX_N];\n\nint N;\nvector<int> W;\n\nvoid solve(){\n    for(int i=0; i<N-1; i++)\n        if(abs(W[i]-W[i+1]) <= 1)\n            dp[i][i+2] = 2;\n    \n    for(int l=3; l<=N; l++){\n        for(int i=0; i<=N-l; i++){\n            //segmentation\n            for(int j=i; j<i+l; j++)\n                dp[i][i+l] = max(dp[i][i+l], dp[i][j] + dp[j][i+l]);\n            //expansion\n            if(dp[i+1][i+l-1] == l-2 && abs(W[i]-W[i+l-1]) <= 1)\n                dp[i][i+l] = l;\n        }\n    }\n    \n    cout << dp[0][N] << endl;\n}\n\nint main(){\n    while(cin >> N, N){\n        W.resize(N);\n        for(auto &v: W)\n            cin >> v;\n        \n        memset(dp, 0, sizeof(dp));\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,data[301];\n\tbool** table = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tint** dp = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[151];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= N; k++){\n\t\t\t\tdp[i][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1)table[i][1] = true;\n\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//?????§?¶????????????°????¨????\n\t\tfor(int length = 2; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = N; left >= N-length+2; left--){\n\t\t\t\tdp[left][length/2] = max(dp[left][(length-2)/2],dp[min(N,left+1)][length/2]);\n\t\t\t}\n\t\t\tfor(int left = N-length+1; left >= 1; left--){ //[??????]???N?????§??????[??????]????????????\n\t\t\t\tif(table[left][length/2] == true){ //left??????length?????????????¶?????????´???\n\t\t\t\t\tdp[left][length/2] = dp[min(N,left+length)][length/2]+length;\n\t\t\t\t}else{ //left??????length?????????????¶????????????´???\n\t\t\t\t\tdp[left][length/2] = dp[left+1][length/2];\n\t\t\t\t\tfor(int i = 2; i <= length-2; i++){\n\t\t\t\t\t\tdp[left][length/2] = max(dp[left][length/2],max(dp[left][i/2] -dp[left+i][i/2] + dp[left+i][(length-i)/2],dp[left][(length-2)/2]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*if(left == 1 && length == 10){\n\t\t\t\t\tprintf(\"Minhi! length:%d ???dp[%d][%d]:%d????????????\\n\",length,min(N,left+length),length/2,dp[min(N,left+length)][length/2]);\n\t\t\t\t}\n\t\t\t\tprintf(\"dp[%d][%d]:%d\\n\",left,length/2,dp[left][length/2]);*/\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dp[1][N/2]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n#define all(a) a.begin(),a.end()\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define INF 1e9\n\nint dfs(int v, vector<set<int>> &g, vector<int> &dp){\n    if(v == 0) return 0;\n    if(dp[v]) return dp[v];\n    // debug(g[v].size());\n    int res = dfs(v-1,g,dp);\n    for(int to : g[v]){\n        res = max(res,v-to + dfs(to,g,dp));\n    }\n    // debug(v);\n    // debug(res);\n    return dp[v] = res;\n}\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> w(n+1);\n        rep1(i,n) cin>>w[i];\n        w[0] = INF;\n\n        // g[i][j] := i番目が消える時に右側に会わせられる\n        //             ブロックのindex\n        vector<set<int>> g(n+1);\n        rep1(i,n){\n            if(abs(w[i]-w[i-1]) <= 1){\n                g[i] = g[i-2];\n                g[i].insert(i-2);\n            }\n            for(int l : g[i-1]){\n                if(abs(w[i]-w[l]) <= 1){\n                    for(int ll : g[l-1]){\n                        g[i].insert(ll);\n                    }\n                    g[i].insert(l-1);\n                }\n            }\n        }\n        // rep1(i,n){\n        //     printf(\"i = %d\\n\",i );\n        //     for(int x : g[i]){\n        //         cout<<x<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n        vector<int> dp(n+1);\n        cout<<dfs(n,g,dp)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _sel(_1, _2, x, ...) x\n#define repn(i, n) for (ll i = 0; i < (n); i++)\n#define reps(i, a, b) for (ll i = (a); i < (b); i++)\n#define rep(i, ...) _sel(__VA_ARGS__, reps, repn)(i, __VA_ARGS__)\n#define reppn(i, n) for (ll i = 1; i <= (n); i++)\n#define repps(i, a, b) for (ll i = (a); i <= (b); i++)\n#define repp(i, ...) _sel(__VA_ARGS__, repps, reppn)(i, __VA_ARGS__)\n#define rrepn(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, a, b) for (ll i = (b) - 1; i >= (a); i--)\n#define rrep(i, ...) _sel(__VA_ARGS__, rreps, rrepn)(i, __VA_ARGS__)\n#define rreppn(i, n) for (ll i = (n); i >= 1; i--)\n#define rrepps(i, a, b) for (ll i = (b); i >= (a); i--)\n#define rrepp(i, ...) _sel(__VA_ARGS__, rrepps, rreppn)(i, __VA_ARGS__)\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define rng(v) (v).begin(), (v).end()\n#define rrng(v) (v).rbegin(), (v).rend()\n#define _shv(v) for (auto _t1 : v) cerr << _t1 << \" \"; cerr << endl;\n#define dg(x) cerr << #x << \": \" << (x) << endl;\n#define dgv(v) cerr << #v << \": \"; _shv(v);\n#define dgm(m) cerr << #m << \":\" << endl; for (auto _t2 : m) { _shv(_t2); }\n\nusing namespace std;\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vc = vector<char>;\nusing vs = vector<string>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vvb = vector<vector<bool>>;\nusing vvc = vector<vector<char>>;\nusing vvs = vector<vector<string>>;\n\nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\nconst int DX[4] = {1, 0, -1, 0};\nconst int DY[4] = {0, 1, 0, -1};\n\ntemplate<typename T> inline void pt(T x) { cout << x << endl; }\ntemplate<typename T> inline void inv(T& v) { for (auto& t : v) cin >> t; }\ntemplate<typename T> inline int siz(T& x) { return x.size(); }\ntemplate<typename T> inline ll pow2(T n) { return 1ll << n; }\ntemplate<typename T, typename U> inline int bit(T x, U n) { return x >> n & 1; }\ntemplate<typename T, typename U>\ninline bool umax(T& m, U x) { if (m < x) { m = x; return true; } return false; }\ntemplate<typename T, typename U>\ninline bool umin(T& m, U x) { if (m > x) { m = x; return true; } return false; }\n\n\nint calc(vvi& dp, vi& w, int l, int r) {\n    if (dp[l][r] != -1) return dp[l][r];\n    if (l == r) return dp[l][r] = 0;\n    if (r - l == 1)  {\n        if (abs(w[l] - w[r]) <= 1)\n            return dp[l][r] = 2;\n        else\n            return dp[l][r] = 0;\n    }\n    int ret = 0;\n    rep(i, l, r) {\n        umax(ret, calc(dp, w, l, i) + calc(dp, w, i + 1, r));\n    }\n    if (calc(dp, w, l + 1, r - 1) == r - l - 1 && abs(w[l] - w[r]) <= 1)\n        umax(ret, calc(dp, w, l + 1, r - 1) + 2);\n    return dp[l][r] = ret;\n}\n\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vi w(n); inv(w);\n        vvi dp(n, vi(n, -1));\n        calc(dp, w, 0, n - 1);\n        pt(dp[0][n - 1]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n#include <math.h>\n//#include <unistd.h>\n//#include <stdio.h>\n#define rep(i,x) for(ll i = 0;i<x;i++)\n#define all(a) (a).begin(),(a).end()\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\nusing dou = double;\nconst ll inf = 2147483647;\nconst ll INF = 1LL << 60;\nconst ld pi = 3.14159265358;\nconst ll mod = 1000000007;\ntypedef pair<ll,ll> P;\nusing graph = vector<vector<ll>>;\ntemplate<class T> inline bool chmax(T& a, T b){if(a < b){a = b; return true;}return false;}\ntemplate<class T> inline bool chmin(T& a, T b){if(a > b){a = b; return true;}return false;}\nll gcd(ll a,ll b){\n    if(a < b)swap(a,b);\n    if(a % b == 0)return b;\n    else return gcd(b,a%b);\n}\n//素数判定O(sqrt(N))\nbool isp(ll n){\n    bool res = true;\n    if(n == 1)return false;\n    else{\n        for(ll i = 2;i * i <= n;i++){\n            if(n % i == 0){\n                res = false;\n                break;\n            }\n        }\n        return res;\n    }\n}\n\nll fac[510000], finv[510000], inv[510000];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < 510000; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nll nCk(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n//nのm乗をMODで割ったあまりO(logN)\nll modpow(ll n,ll m,ll MOD){\n    ll res = 1;\n    while(m){\n        if(m & 1)res = (res * n) % MOD;\n        m >>= 1;\n        n *= n;\n        n %= MOD;\n    }\n    return res;\n}\n\n//printf(\"%.10f\\n\", N);\n/*  vector<ll> vec = {1,2,5,6,8,9,10};\n    cout << binary_search(all(vec),5) << endl; -> true*/\n/*\n    vector<ll> vec = {1,2,5,6,8,9,10};\n    auto n = upper_bound(all(vec),4);\n    cout << *n << endl; -> 5*/\n\n//    cout << fixed << setprecision(15);\nll N;\nconst ll MAXN = 305;\nll num[MAXN];\nll dp[MAXN][MAXN];\nll rec(ll l,ll r){\n    if(dp[l][r] != -1)return dp[l][r];\n    if(abs(l - r) <= 1)return 0;\n    ll res = 0;\n    if(abs(num[l] - num[r - 1]) <= 1 && rec(l + 1,r - 1) == r - l - 2){\n        res = r - l;\n    }\n    for(ll i = l + 1;i <= r - 1;i++){\n        res = max(res,rec(l,i) + rec(i,r));\n    }\n    return dp[l][r] = res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(true){\n        cin >> N;\n        if(N == 0)break;\n        rep(i,N)cin >> num[i];\n        rep(i,N + 1){\n            rep(j,N + 1)dp[i][j] = -1;\n        }\n        cout << rec(0,N) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<numeric>\n#include<map>\nusing namespace std;\n\n#define R(i,s,n) for(int i=s;i<n;i++)\n#define D(i,n,s) for(int i=n-1;i>=s;i--)\ntypedef pair<int,int> P;\n\nconst int MAX_N = 3e+2;\nconst int MAX_W = 1e+3;\n\nint N,W[MAX_N];\nint dp[MAX_N][MAX_N];\n\nvoid solve();\n\nint main() {\n\n  while(cin>>N && N) {\n    R(i,0,N) cin>>W[i];\n    solve();\n  }\n\n  return 0;\n}\n\nvoid solve() {\n  memset(dp,0,sizeof(dp));\n\n  //幅ループ\n  R(i,1,N){\n\n    //縦軸\n    for(int j=0; j+i<N; j++){\n      int mx=0;\n\n      //切るとこ\n      for(int k=0; k<i; k++){\n        //j~j+k,j+k+1~j+i\n        mx=max(mx,dp[j][j+k]+dp[j+k+1][j+i]);\n      }\n      if(i-1 == dp[j+1][j+i-1] && abs(W[j]-W[j+i]) <= 1){\n          mx = i+1;\n      }\n      dp[j][j+i]=mx;\n    }\n  }\n\n  cout << dp[0][N-1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll n;\nll dp[301][301];\n\nint main(){\n\twhile(cin >> n && n){\n\t\tvector<ll> v(n);\n\t\trep(i,n)cin >> v[i];\n\t\trep(i,301)rep(j,301)dp[i][j] = 0;\n\t\tfor(ll b = 2;b <= n;b++){\n\t\t\tfor(ll i = 0;i + b <= n;i++){\n\t\t\t\tif(abs(v[i] - v[i+b-1]) <= 1 && (dp[i+1][i+b-2] == b-2 || b == 2)){\n\t\t\t\t\tdp[i][i+b-1] = max(dp[i][i+b-1],dp[i+1][i+b-2] + 2);\n\t\t\t\t}\n\t\t\t\tfor(ll j = i+1;j < i+b-1;j++){\n\t\t\t\t\tdp[i][i+b-1] = max(dp[i][i+b-1],dp[i][j] + dp[j+1][i+b-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\t// cout << dp[i][j] << \" \";\n\t\t\t\tans = max(ans,dp[i][j]);\n\t\t\t}\n\t\t\t// cout << endl;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\n#define MAX 301\n\nint dp[MAX][MAX];\nint w[MAX];\n\nint dfs(int l, int r) {\n\tif (dp[l][r] != -1)return dp[l][r];\n\tif (r - l >= 3) {\n\t\tif (abs(w[r - 1] - w[l]) <= 1 && dfs(l + 1, r - 1) == r - l - 2) \n\t\t\treturn dp[l][r] = r - l;\n\t\telse {\n\t\t\tfor (int m = l + 1; m < r; m++)\n\t\t\t\tdp[l][r] = max(\n\t\t\t\t\tdp[l][r],\n\t\t\t\t\tdfs(l, m) + dfs(m, r)\n\t\t\t\t);\n\t\t\treturn dp[l][r];\n\t\t}\n\t}\n\tif (r - l == 2)\n\t\tif (abs(w[r - 1] - w[l]) <= 1)\n\t\t\treturn dp[l][r] = 2;\n\t\telse\n\t\t\treturn dp[l][r] = 0;\n\tif (r - l <= 1)return dp[l][r] = 0;\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tfor (int i = 0; i < n; i++)cin >> w[i];\n\t\tcout << dfs(0, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll LINF = 1e18;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint main(){\n    while(1){\n        int n; cin>>n;\n        if(n==0)break;\n        int a[n];\n        rep(i,n)cin>>a[i];\n        int dp[n][n];\n        rep(i,n)rep(j,n)dp[i][j]=-1;\n        rep(i,n)dp[i][i]=0;\n        rep(i,n-1){\n            if(abs(a[i]-a[i+1])<=1)dp[i][i+1]=2;\n            else dp[i][i+1]=0;\n        }\n        for(int i=2; i<n; i++){\n            for(int j=0; j+i<n; j++){\n                if(dp[j+1][j+i-1]==i-1){\n                    if(abs(a[j]-a[j+i])<=1)dp[j][j+i]=i+1;\n                    else dp[j][j+i]=i-1;                    \n                }\n                for(int k=0; k<i; k++){\n                    dp[j][j+i]=max(dp[j][j+i], dp[j][j+k]+dp[j+k+1][j+i]);\n                }\n            }\n        }\n        cout<<dp[0][n-1]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\ntypedef pair<int, int> pii;\n\nconstexpr int MAX_N = 305;\nconstexpr int INF = 1LL << 60;\n\nint n, mem[MAX_N][MAX_N], w[MAX_N];\n\nint solve(int l, int r) {\n    if (r - l <= 1) {\n        return 0;\n    }\n    if (mem[l][r] != -1) {\n        return mem[l][r];\n    }\n\n    int res = max(solve(l + 1, r), solve(l, r - 1));\n\n    if (abs(w[l] - w[l + 1]) <= 1) {\n        res = max(res, solve(l + 2, r) + 2);\n    }\n    if (abs(w[r - 1] - w[r - 2]) <= 1) {\n        res = max(res, solve(l, r - 2) + 2);\n    }\n    if (abs(w[l] - w[r - 1]) <= 1) {\n        int tmp = solve(l + 1, r - 1);\n        if (tmp == r - 1 - (l + 1)) {\n            res = max(res, tmp + 2);\n        }\n    }\n\n    return mem[l][r] = res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while(1) {\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n        memset(mem[0], -1, sizeof(mem));\n\n        for (int i = 0; i < n; ++i) {\n            cin >> w[i];\n        }\n\n        cout << solve(0, n) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<deque>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<limits>\n#include<functional>\n#include<unordered_set>\n#include<iomanip>\n#include<cassert>\n#include<regex>\n#include<bitset>\n#include<complex>\n#include<chrono>\n#include<random>\n#define rep(i,a) for(int i=(int)0;i<(int)a;++i)\n#define rrep(i,a) for(int i=(int)a-1;i>=0;--i)\n#define REP(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RREP(i,a,b) for(int i=(int)a-1;i>=b;--i)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\ntypedef std::vector<int> vi;\ntypedef std::vector<std::vector<int>> vvi;\ntypedef std::vector<long long> vl;\ntypedef std::vector<std::vector<long long>> vvl;\n#define out(x) cout<<x<<\"\\n\";\nusing ll=long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\n\nll gcd(ll n, ll m) {\n\tll tmp;\n\twhile (m!=0) {\n\t\ttmp = n % m;\n\t\tn = m;\n\t\tm = tmp;\n\t}\n\treturn n;\n}\n\nll lcm(ll n, ll m) {\n\treturn abs(n) / gcd(n, m)*abs(m);//gl=xy\n}\n \ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \nusing namespace std;\n\nint n;\n\nvoid solve(){\n  vl w(n);\n  rep(i,n)cin>>w[i];\n  vvl dp(n+5,vl(n+5));\n  REP(W,2,n+1){\n    rep(i,n){\n      int j=i+W;\n      if(j>n)continue;\n      if((dp[i+1][j-1]==j-i-2)&&(abs(w[i]-w[j-1])<=1))dp[i][j]=dp[i+1][j-1]+2;\n      for(int k=i+1;k<j;++k)chmax(dp[i][j],dp[i][k]+dp[k][j]);\n    }\n  }\n  out(dp[0][n]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n  cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n  while(1){\n    cin>>n;\n    if(n==0)return 0;\n    solve();\n  }\n  //solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nint n;\nVI w(300);\nVI2 memo(301, VI(301));\n\nint dp(int l, int r) {\n    if(l == r) return 0;\n    if(r-l == 1) return (std::abs(w[l]-w[r]) <= 1) ? 2 : 0;\n    if(memo[l][r] != -1) return memo[l][r];\n\n    int ans = 0;\n    if(std::abs(w[l]-w[r]) <= 1) {\n        int res = dp(l+1, r+1);\n        if(res == r-l-1) {\n            ans = 2 + res;\n        }\n    }\n    for(int i=l; i<r; ++i) {\n        ans = std::max(ans, dp(l, i) + dp(i+1, r));\n    }\n    return memo[l][r] = ans;\n}\n\nint main() {\n    while(std::cin >> n, n != 0) {\n        REP(i, n) {\n            std::cin >> w[i];\n            memo.assign(301, VI(301, -1));\n            std::cout << dp(0, n-1) << std::endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint W[305];\nint dp[305][305];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0){break;}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&W[i]);\n\t\t}\n\t\tfor(int i=0;i<305;i++){\n\t\t\tfor(int j=0;j<305;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=N-2;i++){\n\t\t\tif(abs(W[i]-W[i+1])<=1){dp[i][1]=2;}\n\t\t}\n\t\tfor(int j=3;j<=N-1;j+=2){\n\t\t\tfor(int i=0;i+j<N;i++){\n\t\t\t\t//[i,i+j]\n\t\t\t\tif(abs(W[i+j-1]-W[i+j])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][j-2]+2);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][j-2]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+1])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+2][j-2]+2);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+2][j-2]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+j])<=1&&dp[i+1][j-2]==j-1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],j+1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(N%2==0){printf(\"%d\\n\",dp[0][N-1]);}\n\t\telse {printf(\"%d\\n\",max(dp[0][N-2],dp[1][N-2]));}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\n#include <fstream>\nusing namespace std;\n\nconst int INF = 1<<30;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\n\nint N;\nvector<int> w;\nint can[310][310];\nint dp[310];\nbool saiki(int l, int n){\n  if(can[l][n] != -1) return can[l][n];\n  if(n % 2) return can[l][n] = 0;\n  if(n == 0) return can[l][n] = 1;\n\n  bool res = 0;\n  for(int i = 1; i <= n-1; i++) if(saiki(l, i) && saiki(l+i, n-i)) res = 1;\n  if(saiki(l+1, n-2) && abs(w[l] - w[l+n-1]) <= 1) res = 1;\n  return can[l][n] = res;\n}\n\n\nvoid solve(){\n  rep(i, 310)rep(j, 310) can[i][j] = -1;\n  rep(i, N)rep(j, N+1){\n    if(i+j<=N) saiki(i, j);\n  }\n  rep(i, 310) dp[i] = -INF;\n  dp[0] = 0;\n  rep(i, N){\n    dp[i+1] = max(dp[i+1], dp[i]);\n    for(int j = 1; j <= N; j++){\n      if(i+j<=N && can[i][j]) dp[i+j] = max(dp[i+j], dp[i] + j);\n    }\n  }\n  cout << dp[N] << endl;\n}\n\n\nint main(){\n  while(true){\n    cin >> N;\n    if(N == 0) return 0;\n    w.resize(N);\n    rep(i, N) cin >> w[i];\n    solve();\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int i,j,k;\n  int n;\n  while(1){\n  cin>>n;\n    if(n==0) {\n      return 0;\n    }\n  int w[n+1];\n  int dp[n+1][n+1];\n  for(i=1;i<=n;i++) cin>>w[i];\n  for(k=0;k<=n-1;k++){\n    for(i=1;i<=n-k;i++){\n      if(k==0) dp[i][i+k]=0;\n      else if(k==1) {\n        if(abs(w[i]-w[i+1])<=1) dp[i][i+1]=2;\n        else dp[i][i+1]=0;\n      }\n      else {\n        if(abs(w[i]-w[i+k])<=1&&dp[i+1][i+k-1]==k-1) dp[i][i+k]=k+1;\n        else dp[i][i+k]=0;\n          for(j=i;j<=i+k-1;j++) dp[i][i+k]=max(dp[i][i+k],dp[i][j]+dp[j+1][i+k]);\n      }\n    }\n  }\n  // for (int i = 1; i < n; i++) {\n  //   for (int j = i; j < n; j++) {\n  //     // cout << \"dp[\" << i << \"][\" << j << \"]\" << \"\\t\\t\" <<  dp[i][j] << endl;\n  //   }\n  // }\n  cout<<dp[1][n]<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool check(int a, int b){\n\treturn abs(a - b) <= 1;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        vector<int> w(n);\n        rep(i,n){\n            cin >> w[i];\n        }\n\n\t\tint dp[300][300] = {{0}};\n\t\trange(W,2,n + 1){\n\t\t\trep(i,n){\n\t\t\t\tint j = i + W - 1;\n\t\t\t\tif(i + W - 1 >= 300) break;\n\t\t\t\tif(check(w[i], w[j]) && dp[i + 1][j - 1] == W - 2){\n\t\t\t\t\tdp[i][j] = W;\n\t\t\t\t}\n\t\t\t\trange(k,i,j){\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nint dp[330][330];\nint w[330];\n\nint calc(int l, int r){\n  if(dp[l][r] >= 0)return dp[l][r];\n  if(r == l + 1)return dp[l][r] = 0;\n  if(r == l + 2){\n    if(abs(w[l] - w[l+1]) <= 1)return dp[l][r] = 2;\n  }\n  int res = 0;\n  for(int k = l; k < r - 1; k++){\n    chmax(res, calc(l, k+1) + calc(k+1, r));\n  }\n  if(abs(w[l] - w[l+1]) <= 1)chmax(res, 1 + calc(l+2, r));\n  if(abs(w[r-2] - w[r-1]) <= 1)chmax(res, 1 + calc(l, r-2));\n  if(abs(w[l] - w[r-1]) <= 1 && calc(l+1, r-1) == r - l - 2)chmax(res, r - l);\n  return dp[l][r] = res;\n}\n\nint main(int argc, char const* argv[])\n{\n  int n;\n  while(true){\n    cin >> n;\n    if(n == 0)break;\n    rep(i, n)cin >> w[i];\n    rep(i, n + 1){\n      rep(j, n + 1)dp[i][j] = -1;\n    }\n    cout << calc(0, n) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    int w[n],i,j,k=0;\n    for(i=0;i<n;i++) cin>>w[i];\n    bool p[n][n];\n    memset(p,0,sizeof(p));\n    for(j=0;j+1<n;j++) if(abs(w[j+1]-w[j])<2) p[j][j+1]=1;\n    for(i=3;i<n;i+=2)\n      for(j=0;j+i<n;j++)\n\tif((p[j+1][j+i-1]&&abs(w[j+i]-w[j])<2)||\n\t   (p[j][j+i-2]&&abs(w[j+i]-w[j+i-1])<2)||\n\t   (p[j+2][j+i]&&abs(w[j+1]-w[j])<2)) p[j][j+i]=1;\n    int dp[n+1];\n    memset(dp,0,sizeof(dp));\n    for(i=0;i<n;i++)\n      for(j=0;i+j<n;j++)\n\tdp[i+j+1]=max(dp[i+j+1],dp[i]+p[i][i+j]*(j+1));\n    cout<<dp[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n\nvoid solve(int n) {\n\tvi v(n, 0);\n\tvector<vector<bool>> dp(n + 1, vector<bool>(n, false));\n\trep(i, n) {\n\t\tcin >> v[i];\n\t}\n\tfor (int l = 2; l <= n; l += 2) {\n\t\tfor (int i = 0; i + l <= n; i++) {\n\t\t\tbool b = false;\n\t\t\tif (l != 2) {\n\t\t\t\tfor (int j = 2; j<l; j += 2) {\n\t\t\t\t\tif (dp[j][i] && dp[l - j][i + j])\n\t\t\t\t\t\tb = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dif = abs(v[i] - v[i + l - 1]);\n\t\t\tif (dif <= 1&&(l==2?1:dp[l-2][i+1]))b = true;\n\t\t\tif (b)dp[l][i] = true;\n\t\t\t//cout << l << \" \" << i << \" \" << dp[l][i] << endl;\n\t\t}\n\t}\n\tint pos = 0;\n\tqueue<pii> q;\n\tq.push({ 0,0 });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tif (p.fs == n) {\n\t\t\tcout << n-p.sc << endl;\n\t\t\treturn;\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (dp[i][p.fs])q.push({ p.fs+i,p.sc});\n\t\t}\n\t\tq.push({ p.fs+1 ,p.sc + 1 });\n\t}\n\n}\n\nint main(void) {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tsolve(n);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n\nint n;\n\nint main()\n{\n\twhile(cin >> n , n)\n\t{\n\t\tvector<int> w(n,0);\n\t\tfor(int i = 0;i < n;i++) cin >> w[i];\n\n\t\tvector<vector<int>> dp(n + 1,vector<int>(n + 1,-1));\n\n\t\t//[l,r)\n\t\tfunction<int(int,int)> rec = [&](int l,int r){\n\t\t\tif(dp[l][r] != -1) return dp[l][r];\n\n\t\t\tif(abs(l - r) <= 1) return 0;\n\n\t\t\tint res = 0;\n\t\t\t//l [able] r ?\n\t\t\tif(abs(w[l] - w[r - 1]) <= 1 && rec(l + 1,r - 1) == r - l - 2)\n\t\t\t{\n\t\t\t\tres = r - l;\n\t\t\t}\n\n\t\t\t//[l any] [any r]\n\t\t\tfor(int mid = l + 1;mid <= r - 1;mid++)\n\t\t\t{\n\t\t\t\tres = max(res , rec(l,mid) + rec(mid,r));\n\t\t\t}\n\t\t\treturn dp[l][r] = res;\n\t\t};\n\n\t\tcout << rec(0,n) << endl;\n\t}\n}\n\t\t\t\t\n\n\n\t\t\t\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\nint w[N],mem[N][N],used[N][N];\n\nint dfs(int l,int r){\n  if(l==r) return 0;\n  if(r-l==1) return 2*(abs(w[l]-w[r])<=1);\n  if(used[l][r]++) return mem[l][r];\n  \n  int res=0;\n  \n  if((r-l)%1==0&&abs(w[l]-w[r])<=1&&\n     dfs(l+1,r-1)==r-l-1) res=2+dfs(l+1,r-1);\n  \n  for(int i=l;i<r;i++)\n    res=max(res,dfs(l,i)+dfs(i+1,r));\n  \n  return mem[l][r]=res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>w[i];\n    memset(used,0,sizeof(used));\n    cout<<dfs(0,n-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define FORR(i, m, n) for(int i = m; i >= n; i--)\n#define INF (ll)2e9\n#define MOD ((ll)1e9+7)\n#define ALL(v) v.begin(), v.end()\n#define SZ(x) ((int)(x).size())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define y0 y3487465\n#define y1 y8687969\n#define j0 j1347829\n#define j1 j234892\n#define next asdnext\n#define prev asdprev\n#define bit(n) (1LL<<(n))\n#define cauto const auto&\n#define println(v) cout << v << \"\\n\";\n\nvoid show(vector<vector<ll>>& arr, int w) {\n    cout << right << setw(w) << \"#\";\n    REP(i, SZ(arr[0]))  {\n        cout << right << setw(w) << i;\n    }\n    cout << endl;\n    REP(i, SZ(arr)) {\n        cout << right << setw(w) << i;\n        REP(j, SZ(arr[0])){\n            cout << right << setw(w) << arr[i][j];\n        }\n        cout << endl;\n    }\n}\n\ninline vector<vector<vector<ll>>> makeVector(ll i, ll j, ll k) {\n    vector<vector<vector<ll>>> v(i, vector<vector<ll>>(j, vector<ll>(k, 0)));\n    return v;\n}\ninline vector<vector<ll>> makeVector(ll i, ll j) {\n    vector<vector<ll>> v(i, vector<ll>(j, 0));\n    return v;\n}\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate <class InputIterator>\nInputIterator adv(InputIterator x, typename std::iterator_traits<InputIterator>::difference_type n) {\n    advance(x, n);\n    return x;\n}\n\nclass mod {\n    static ll fact[];\npublic:\n\n    template<class... A>\n    static ll mul(A... args) {\n        ll res = 1;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = (res * i) % MOD;\n        }\n        return res;\n    }\n\n    static ll power(ll base, ll exp) {\n        if (exp == 0) return 1;\n        if (exp & 1) {\n            return mul(base, power(base, exp - 1));\n        } else {\n            ll p = power(base, exp / 2);\n            return mul(p, p);\n        }\n    }\n\n    static ll factorial(int n) {\n        if (fact[n] != 0) return fact[n];\n        if (n == 0) return 1;\n        return fact[n] = mul(n, factorial(n - 1));\n    }\n\n    static ll inverse(int n) {\n        return power(n, MOD - 2);\n    }\n\n    static ll comb(int n, int r) {\n        if (r < 0 || r > n) return 0;\n        return mul(factorial(n), inverse(factorial(n - r)), inverse(factorial(r)));\n    }\n\n    template<class... A>\n    static ll div(ll dividend, A... args) {\n        ll res = dividend;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = mul(res, inverse(i));\n        }\n        return res;\n    }\n\n    template<class... A>\n    static ll add(A... args) {\n        ll res = 0;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = (res + i) % MOD;\n        }\n        return res;\n    }\n\n    template<class... A>\n    static ll sub(ll l, A... args) {\n        ll res = l;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = (res - i + MOD) % MOD;\n        }\n        return res;\n    }\n};\nll mod::fact[(int) 1e6 + 1];\n\nint ni() {\n    int i;\n    cin >> i;\n    return i;\n}\nll nll() {\n    ll l;\n    cin >> l;\n    return l;\n}\n\nint main()\n{\n    while (true) {\n        int N = ni();\n\n        if (N == 0) break;\n\n        vector<ll> w(N);\n        REP(i, N) cin >> w[i];\n\n        auto dp = makeVector(N + 1, N + 1);\n\n        FOR(len, 2, N + 1) {\n            REP(i, N - len + 1) {\n\n                FOR(j, i+1, i+len) {\n                    dp[i][i + len] = max(dp[i][i+len], dp[i][j] +dp[j][i+len]);\n                }\n\n                if (dp[i + 1][i + len - 1] == len - 2 && abs(w[i] - w[i + len - 1]) <= 1) {\n                    dp[i][i+len] = len;\n                }\n                dp[i][i + len] = max(dp[i][i + len],\n                                     dp[i][i + len - 2] + (abs(w[i + len - 2] - w[i + len - 1]) <= 1 ? 2 : 0));\n                dp[i][i + len] = max(dp[i][i + len], dp[i + 2][i + len] + (abs(w[i] - w[i + 1]) <= 1 ? 2 : 0));\n            }\n        }\n\n        //show(dp, 4);\n\n        println(dp[0][N]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nstruct Edge\n{\n  int to;\n  int weight;\n  Edge(int t, int w) : to(t), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n// using Graph = vector<vector<int>>;\n\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1000000000;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, 1, -1, 1, 0, -1};\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  while (1)\n  {\n    cin >> n;\n    if (n == 0)\n      break;\n    vector<int> w(n);\n    for (auto &it : w)\n      cin >> it;\n    vector<vector<ll>> dp(n + 1, vector<ll>(n + 1, 0));\n    for (int W = 2; W <= n; W++)\n    {\n      // left\n      for (int l = 0; l < n; l++)\n      {\n        int r = l + W;\n        if (r > n)\n          continue;\n        if (dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r - 1]) <= 1)\n          dp[l][r] = W;\n\n        for (int mid = l; mid <= r; mid++)\n        {\n          dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid][r]);\n        }\n      }\n    }\n    ll ans = dp[0][n];\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nusing namespace std;\n\nstatic const ll INF = 1e15;\n\ntemplate<typename T>\nstatic inline void chmin(T & ref, const T  value) {\n    if (ref > value) ref = value;\n}\n\ntemplate<typename T>\nstatic inline void chmax(T & ref, const T value) {\n    if (ref < value) ref = value;\n}\n\nint main() {\n    vector<ll> ans;\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vector<ll> ps(n);\n        rep(i, n) cin >> ps[i];\n\n        vector<vector<ll>> dp(n, vector<ll>(n, 0));\n        for (int i = 0; i < n - 1; i++) {\n            if (abs(ps[i] - ps[i + 1]) < 2) {\n                dp[i][i + 1] = 2;\n            }\n        }\n        for (int w = 4; w <= n; w += 2) {\n            for (int i = 0; i + w - 1 < n; i++) {\n                for (int split = 2; split < w; split += 2) {\n                    if (dp[i][i + split - 1] == split && dp[i + split][i + w - 1] == w-split) {\n                        dp[i][i + w - 1] = w;\n                    }\n                    if (dp[i][i + w - split - 1] == w - split && dp[i + w - split][i + w - 1] == split) {\n                        dp[i][i + w - 1] = w;\n                    }\n                }\n                if (dp[i + 1][i + w - 2] == w - 2) {\n                    if (abs(ps[i] - ps[i + w - 1]) < 2) {\n                        dp[i][i + w - 1] = w;\n                    }\n                }\n            }\n        }\n        vector<vector<ll>> dp2 = dp;\n        for (int length = 1; length < n; length++) {\n            for (int i = 0; i + length < n; i++) {\n                for (int j = i; j +1<= i+length; j++) {\n                    chmax(dp2[i][i + length], dp2[i][j] + dp2[j + 1][i + length]);\n                }\n            }\n        }\n        ans.push_back(dp2[0][n - 1]);\n    }\n    for (int index = 0; index < ans.size();index++) {\n        cout << ans[index] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n\nvoid solve(VLL & w){\n  int n = w.size();\n  bool dp[n][n];\n  memset(dp,false,sizeof(dp));\n  FOR(len,2,n+1){\n    for(int l = 0; (l + len - 1) < n; l++){\n      int r = l + len - 1;\n      if(len == 2){\n        dp[l][r] = dp[l][r] || (abs(w[l] - w[r]) <= 1);\n      }\n      FOR(k,l+1,r){\n\n        dp[l][r] = (dp[l][k] && dp[k+1][r]) || dp[l][r];\n        dp[l][r] = dp[l][r] || ( (abs(w[l] - w[r]) <= 1) && ( (dp[l+1][k] && dp[k+1][r-1]) || dp[l+1][r-1]));\n      }\n    }\n  }\n  // rep(i,n){\n  //   rep(j,n){\n  //     cout << dp[i][j] << ' ';\n  //   }\n  //   cout << endl;\n  // }\n  ll ep[n+1];\n  memset(ep,0,sizeof(ep));\n  rep(i,n){\n    ep[i+1] = max(ep[i],ep[i+1]);\n    FOR(j,i+1,n){\n      if(dp[i][j]){\n        if(i == 0) ep[j] = max((ll)(j-i+1),ep[j]);\n        else ep[j] = max((ll)(j-i+1)+ep[i-1],ep[j]);\n      }\n    }\n  }\n  cout << ep[n] << endl;\n  return;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n;\n  while(true){\n    cin >> n;\n    if(n == 0) break;\n    VLL w(n);\n    rep(i,n) cin >> w[i];\n    solve(w);\n  }\n  cin >> n;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stacq>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<deque>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_bacq\n#define MP maqe_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dp[310][310];\n\nint main()\n{\n\tint n;\n\t\n\twhile(cin >> n,n)\n\t{\n\t\tREP(i,310)REP(j,310)dp[i][j] = 0;\n\t\t\n\t\tvector<int> v(n);\n\t\tREP(i,n)cin >> v[i];\n\t\t\n\t\tREP(i,n-1)if(abs(v[i]-v[i+1]) < 2)dp[i][i+1] = 2;\n\t\t\n\t\tfor(int q = 2;q < n;q++)\n\t\t{\n\t\t\tfor(int i = 0;i+q < n;i++)\n\t\t\t{\n\t\t\t\tint j = i+q;\n\t\t\t\tfor(int k = 0;k < j-i;k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j] = max(dp[i][j],dp[i][i+k]+dp[i+k+1][j]);\n\t\t\t\t}\n\t\t\t\tif(dp[i+1][j-1] == j-i-1)\n\t\t\t\t{\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tif(abs(v[i]-v[j])<2)tmp = 2;\n\t\t\t\t\tdp[i][j] = max(dp[i][j],j-i-1+tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dp[0][n-1] << endl;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nint n;\nint w[MAX];\nint done[305][305];\nint dp[305][305];\n\nvoid print_dp() {\n    rep(i, n) {\n        rep(j, n+1) {\n            cout << setw(3) << dp[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint ans(int l, int r) {\n    if (done[l][r]) {\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    if (r - l == 0) return 0;\n    if (r - l == 1) return 0; \n    if (l > r) return -INF;\n    if (r > n) return -INF;\n    if (r - l == 2) {\n        done[l][r] = true;\n        int res = 0;\n        if (abs(w[l] - w[l+1]) < 2) res = 2;\n        else res = 0;\n        dp[l][r] = res;\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    int res = 0;\n    rep(width, n) {\n        rep(width2, n) {\n            if (l+width+width2 > r) break;\n            rep2(i, l, r) {\n                if (i+width+width2 > n) break;\n                if (i+width+width2*2 > r) break;\n                if (i+width2 == l && i+width+width2 == r) continue;\n                if (i+width+width2*2 == l) continue;\n                int tmp = \n                ans(l, i) \n                + ans(i+width2, i+width+width2) \n                + ans(i+width+width2*2, r);\n                if (ans(i+width2, i+width+width2) == width) {\n                    rep(j, width2) {\n                        if (abs(w[i+width2-1-j] - w[i+width+width2+j]) < 2) {\n                            tmp += 2;\n                        }\n                        else break;\n                    }\n                }\n                res = max(res, tmp);\n            }\n        }\n    }\n\n\n    done[l][r] = true;\n    dp[l][r] = res;\n    // if (test) {\n    //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n    // }\n    return dp[l][r];\n}\n\nvoid solve() {\n    rep(i, 305) rep(j, 305) done[i][j] = false;\n    rep(i, 305) rep(j, 305) dp[i][j] = 0;\n    cin >> n;\n    if (n == 0) exit(0);\n    rep(i, n) cin >> w[i];\n    cout << ans(0, n) << endl;\n    if (test) print_dp();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint N, W[300];\nint dp[301][3001];\n\nbool ok(int i, int j) {\n  return abs(W[i] - W[j]) <= 1;\n}\n\nint dfs(int l, int r) {\n  if(r - l <= 1) return 0;\n  if(r - l == 2) return ok(l, l + 1) ? 2 : 0;\n  if(dp[l][r] >= 0) return dp[l][r];\n\n  int ret = 0;\n  REP(i, l + 1, r) ret = max(ret, dfs(l, i) + dfs(i, r));\n  if(ok(l, r - 1) && dfs(l + 1, r - 1) == r - l - 2) ret = max(ret, r - l);\n\n  return dp[l][r] = ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> W[i];\n    REP(i, 0, 301) REP(j, 0, 301) dp[i][j] = -1;\n    cout << dfs(0, N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << \"\\n\";\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\nll MOD = 1e9+7;\n\nvoid chmax(ll& x, ll y) {\n    if (x < y) x = y;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(1) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        vll w(n); REP(i, n) cin >> w[i];\n\n        vector<vll> dp(n + 1, vll(n + 1, 0));\n\n        FOR(l, 2, n + 1) {\n            REP(i, n) {\n                int j = i + l - 1;\n                if (j >= n) break;\n\n                if (dp[i+1][j-1] == l - 2 && abs(w[i] - w[j]) <= 1) {\n                    chmax(dp[i][j], l);\n                } else {\n                    FOR(k, i, j) {\n                        chmax(dp[i][j], dp[i][k] + dp[k+1][j]);\n                    }\n                }\n            }\n        }\n\n        print(dp[0][n-1]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nbool** table;\nint** dp;\nint N;\n\nint recursive(int left,int right){\n\n\tif(dp[left][right] != 0)return dp[left][right]; //?????¢???????????´???\n\tif(left == right)return 0;\n\tif((right-left+1)%2 == 1){ //??????????\\???°?????´???\n\t\treturn max(recursive(left,right-1),recursive(left+1,right));\n\t}\n\tif(table[left][(right-left+1)/2] == true)return dp[left][right] = right-left+1; //left???right?????¨????¶?????????´???\n\tif(right == left+1 && table[left][1] == false)return 0;\n\n\tint ans = 0;\n\tfor(int i = left+1; i <= right-2; i++){\n\t\tans = max(ans,recursive(left,i)+recursive(i+1,right));\n\t}\n\treturn dp[left][right] = ans;\n}\n\nint main(){\n\n\tint data[301];\n\ttable = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tdp = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[151];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 0; i <= 300; i++){\n\t\t\tfor(int k = 0; k <= 150; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= 150; k++){\n\t\t\t\tdp[i][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1)table[i][1] = true;\n\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",recursive(1,N));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    for(;;){\n        int n;\n        cin>>n;\n        if(!n) return 0;\n        int w[310];\n        rep(i,0,n) cin>>w[i];\n        int dp[310][310];\n        rep(i,0,n){\n            dp[i][i+1]=0;\n            dp[i][i+2]=0;\n            if(abs(w[i]-w[i+1])<=1) dp[i][i+2]=2;\n        }\n        rep(j,3,n+1){\n            rep(i,0,n+1-j){\n                dp[i][i+j]=dp[i][i+j-1];\n                if(abs(w[i]-w[i+j-1])<=1&&dp[i+1][i+j-1]==j-2) dp[i][i+j]=j;\n                rep(k,i+1,i+j){\n                    if(abs(w[k]-w[i+j-1])<=1&&dp[k+1][i+j-1]==i+j-k-2) dp[i][i+j]=max(dp[i][i+j], int(i+j-k+dp[i][k]));\n                }\n            }\n        }\n        cout <<dp[0][n]<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nbool** table;\nint** dp;\nint N;\n\nint recursive(int left,int right){\n\n\tif(dp[left][right] != -1)return dp[left][right]; //?????¢???????????´???\n\tif((right-left+1)%2 == 1){ //??????????\\???°?????´???\n\t\treturn dp[left][right] = max(recursive(left,right-1),recursive(left+1,right));\n\t}\n\tif(table[left][(right-left+1)/2] == true)return dp[left][right] = right-left+1; //left???right?????¨????¶?????????´???\n\tif(right == left+1 && table[left][1] == false)return dp[left][right] = 0;\n\n\tfor(int i = left+1; i <= right-2; i++){\n\t\tdp[left][right] = max(dp[left][right],recursive(left,i)+recursive(i+1,right));\n\t}\n\treturn dp[left][right];\n}\n\nint main(){\n\n\tint data[301];\n\ttable = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tdp = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= N; k++){\n\t\t\t\tif(i == k)dp[i][k] = 0;\n\t\t\t\telse{\n\t\t\t\t\tdp[i][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1)table[i][1] = true;\n\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",recursive(1,N));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<int> w(n), sum(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t\tsum[i] = i ? sum[i - 1] + w[i] : w[i];\n\t\t}\n\t\tvector<vector<int>> DP(n + 1, vector<int>(n + 1));\n\t\tfor (int i = 0; i + 1 <= n; i++) {\n\t\t\tDP[i][i + 1] = 0;\n\t\t}\n\t\tfor (int i = 0; i + 2 <= n; i++) {\n\t\t\tDP[i][i + 2] = abs(w[i] - w[i + 1]) <= 1 ? 2 : 0;\n\t\t}\n\t\tfor (int k = 3; k <= n; k++) {\n\t\t\tfor (int i = 0; i + k <= n; i++) {\n\t\t\t\tfor (int j = i + 1; j + 1 <= i + k; j++) {\n\t\t\t\t\tif (k % 2 == 0 && DP[i + 1][i + k - 1] == k - 2 && abs(w[i + k - 1] - w[i]) <= 1) DP[i][i + k] = DP[i + 1][i + k - 1] + 2;\n\t\t\t\t\telse DP[i][i + k] = max(DP[i][i + k], DP[i][j] + DP[j][i + k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << DP[0][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\ntemplate<typename T> inline bool chmax(T &a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T &a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U &u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U &u,const V... v){for(auto &e:u)fill_v<T>(e,v...);}\n\nvector<int> w;\nauto dp = make_vec<int>(0, 0);\n\nint rec(int l, int r) {\n    if (r - l == 1) return 0;\n    if (r - l == 2) {\n        if (abs(w[l] - w[r-1]) <= 1) return 2;\n        else return 0;\n    }\n    if (dp[l][r] != -1) return dp[l][r];\n    int &res = dp[l][r];\n    if (rec(l+1, r-1) == r - l - 2 && abs(w[l] - w[r-1]) <= 1) res = r - l;\n    else {\n        for (int i = l+1; i < r; ++i) chmax(res, rec(l, i) + rec(i, r));\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    while (cin >> n, n) {\n        w.resize(n);\n        rep(i, n) cin >> w[i];\n        dp.assign(n+1, vector<int>(n+1, -1));\n        cout << rec(0, n) << endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 2; } }\n\t\tfor (int h = 0; h < 25; h++) {\n\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tint a1 = j, a2 = i + j - 1; if (a2 >= n)continue;\n\t\t\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = i + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\tint a1 = j, a3 = i + j; if (a3 >= n)continue;\n\t\t\t\t\tfor (int k = a1 + 1; k <= a3; k++) {\n\t\t\t\t\t\tint a2 = k;\n\t\t\t\t\t\tdp[a1][a3] = max(dp[a1][a3], dp[a1][a2 - 1] + dp[a2][a3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename T> ll min(ll a, const T&& b) { return a < b ? a : b; }\ntemplate<typename T> ll min(const T&& a, ll b) { return a < b ? a : b; }\ntemplate<typename T> ll max(ll a, const T&& b) { return a > b ? a : b; }\ntemplate<typename T> ll max(const T&& a, ll b) { return a > b ? a : b; }\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nvoid solve() {\n  ll n;\n  while (cin >> n, n) {\n    vector<ll> a(n); cin >> a;\n    vector<vector<bool>> dp(n+1, vector<bool>(n+1, false));\n    rep(i, n+1) dp[i][i] = true;\n    rep(w, 2, n+1) rep(l, n) {\n      ll r = l + w;\n      if (r > n) continue;\n      if (dp[l+1][r-1] && abs(a[l] - a[r-1]) <= 1) {\n        dp[l][r] = true;\n      }\n      rep(m, l+1, r) {\n        if (dp[l][m] && dp[m][r]) {\n          dp[l][r] = true;\n        }\n      }\n    }\n    vector<ll> dp2(n+1, 0);\n    rep(i, n) {\n      chmax(dp2[i+1], dp2[i]);\n      rep(j, i, n+1) {\n        if (dp[i][j]) {\n          chmax(dp2[j], dp2[i] + j-i);\n        }\n      }\n    }\n    ll ans = dp2[n];\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// finish date: 2018/07/03\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <climits>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i, n)  FOR(i,0,n)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<long double> vd;\ntypedef vector<vector<long double>> vvd;\ntypedef vector<vector<vector<long double>>> vvvd;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> pii;\nconst int bigmod = 1000000007;\nconst int INF = 1050000000;\n\n\nint main() {\n    int n;\n\n    while(true) {\n        cin >> n;\n        if(n == 0) {\n            break;\n        }\n\n        vi w(n);\n        rep(i, n) {\n            cin >> w[i];\n        }\n\n        vvi dp(n + 1, vi(n + 1, 0));\n\n        rep(i, n - 1) {\n            dp[i][i + 1] = (abs(w[i] - w[i + 1]) <= 1) ? 2 : 0;\n        }\n\n        FOR(k, 2, n) {\n            rep(i, n) {\n                int j=i+k;\n                if(j >= n) {\n                    continue;\n                }\n                if(abs(w[i] - w[j]) <=1 && dp[i + 1][j - 1] == (j - 1) - (i + 1) +1) {\n                    dp[i][j] = j - i + 1;\n                } else {\n                    FOR(l, i, j) {\n                        dp[i][j] = max(dp[i][j], dp[i][l] + dp[l + 1][j]);\n                    }\n                }\n            }\n        }\n\n        cout << dp[0][n-1] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define rep4(i, a, b, c) for (int i = int(a), i##__b = int(b), i##__c = int(c); i < i##__b; i += i##__c)\n#define rep1(n) rep4(i, 0, n, 1)\n#define rep2(i, n) rep4(i, 0, n, 1)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define REP(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep3(i, a, b) for (int i = int(b) - 1, i##__a = int(a); i >= i##__a; i--)\n#define rrep1(n) rrep3(i, 0, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep4(i, a, b, c) for (int i = int(a + (b - a - 1) / c * c), i##__a = int(a), i##__c = int(c); i >= i##__a; i -= i##__c)\n#define RREP(...) overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define FOR(i, x) for (auto &i : x)\n#define ALL(v) (v.begin()), (v.end())\n#define pb(x) emplace_back(x)\n#define mp(x, y) make_pair(x, y)\n#define mt make_tuple\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing vint = vector<int>;\nusing vvint = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing vbool = vector<bool>;\nusing vvbool = vector<vector<bool>>;\nusing vstring = vector<string>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vv = vector<vector<T>>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using rpq = priority_queue<T, vector<T>, greater<T>>;\n#define vvint(A, H, W) vvint A(H, vint(W))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 9;\nconst ll LINF = 1e18;\ntemplate <class T> bool chmax(T &a, const T &b) {if (a < b) {a = b;return 1;}return 0;}\ntemplate <class T> bool chmin(T &a, const T &b) {if (b < a) {a = b;return 1;}return 0;}\ntemplate <class T> void print(T x){cout<<x<<endl;}\n// clang-format on\n\nint N;\nvint w;\nvvint dp;\n\nint rec(int l = 0, int r = N) {\n    int d = r - l;\n    if (d <= 1) return 0;\n    if (d == 2) {\n        if (abs(w[l] - w[l + 1]) <= 1)\n            return 2;\n        else\n            return 0;\n    }\n\n    int &ret = dp[l][r];\n    if (ret != -1) return ret;\n    if (abs(w[l] - w[r - 1]) <= 1 && rec(l + 1, r - 1) == d - 2) {\n        chmax(ret, d);\n    } else {\n        REP(i, l + 1, r) {\n            chmax(ret, rec(l, i) + rec(i, r));\n        }\n    }\n    return ret;\n}\n\nint main() {\n    while (cin >> N && N) {\n        w.resize(N);\n        REP(N) {\n            cin >> w[i];\n        }\n        dp.assign(N + 2, vint(N + 2, -1));\n        print(rec());\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n\nconst int MOD = 1e9+7;\nconst int INF = 1e9;\n\nint main() {\n  while (true) {\n    int n, ans = 0;\n    bool dp[300][300];\n    cin >> n;\n    if (n == 0) break;\n    vi c;\n    for (int i = 0; i < n; i++) {\n      int tmp;\n      cin >> tmp;\n      c.PB(tmp);\n    }\n    for (int i = 0; i < 300; i++) {\n      for (int j = 0; j < 300; j++) {\n        dp[i][j] = false;\n      }\n    }\n    for (int len = 2; len <= n; len+=2) {\n      for (int left = 0; left+len <= n; left++) {\n        int right = left + len - 1;\n        if (abs(c[left]-c[right])<=1) {\n          if (len==2) {\n            dp[left][right] = true;\n            // cout << len << \": \" << left << \"_a_\" << right << endl;\n            continue;\n          } else {\n            if (dp[left+1][right-1]) {\n              dp[left][right] = true;\n              // cout << len << \": \" << left << \"_b_\" << right << endl;\n              continue;\n            }\n          }\n        }\n        for (int pos = left+1; pos < right; pos+=2) {\n          if (dp[left][pos] && dp[pos+1][right]) {\n            dp[left][right] = true;\n            // cout << len << \": \" << left << \"_c_\" << right << endl;\n            break;\n          }\n        }\n      }\n    }\n    for (int left = 0; left < n; left++) {\n      for (int right = n-1; left < right; right--) {\n        if (dp[left][right]) {\n          ans += right - left + 1;\n          left = right + 1;\n          break;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n-1){\n            if(!k || i+k>n-1)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n                    cmax(dp[i][i+k],dp[i+1][i+k-1]+2);\n                }\n                for(int j = i+1; j<i+k && j<n-1;j++){\n                    if(dp[i][j] && dp[j+1][i+k])cmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n                }\n            }\n        }\n        int ans = 0;\n        int maxi = 0;\n        for(int i = maxi; i < n; i++){\n            for(int j = n-1; j>=0;--j){\n                if(dp[i][j]){\n                    ans += j-i+1;\n                    i = j;\n                    break;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    int w[n];\n    for(int i = 0; i < n; ++i)\n      cin >> w[i];\n    \n    int dp[n][n];\n    for(int i = 0; i < n; ++i){\n      fill(dp[i],dp[i]+n,0);\n    }\n    \n    for(int i = 0; i < n-1; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(j+i+1 > n-1) break;\n\tif(dp[j+1][j+i] == i && abs(w[j]-w[j+i+1]) < 2){\n\t  dp[j][j+i+1] = dp[j+1][j+i] + 2;\n\t}else{\n\t  for(int k = 0; k < i; ++k){\n\t    dp[j][j+i+1] = max(dp[j][j+i+1],dp[j][j+k]+dp[j+k+1][j+i+1]);\n\t  }\n\t}\n      }\n    }\n    /*\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n      cout << dp[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n    cout << dp[0][n-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nint n, a[1010];\n\nint dp[1010][1010];\nint dp2[1010] = {};\n\nint ok(int l, int r){\n    int &res = dp[l][r];\n    if(res != -1) return res;\n    if((r-l) % 2 == 1) return res = false;\n    res = false;\n    if(l+0 == r) res = true;\n    for(int i = l+2; i < r; i += 2) if(ok(l,i) && ok(i,r)) res = true;\n    if(abs(a[l] - a[r-1]) <= 1 && ok(l+1, r-1)) res = true;\n    return res;\n}\n\nint main(){\n    while(cin >> n && n){\n        rep(i, n) cin >> a[i];\n        memset(dp, -1, sizeof dp);\n        memset(dp2, 0, sizeof dp2);\n        dp2[0] = 0;\n        rep(i, n){\n            dp2[i+1] = max(dp2[i+1], dp2[i]);\n            for(int j = i + 2; j <= n; j += 2){\n                if(ok(i, j)) dp2[j] = max(dp2[j], dp2[i] + j - i);\n            }\n        }\n        cout << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i,n,N) for(int i=(n); i<(N); i++)\n#define RREP(i,n,N) for(ll i=(N-1); i>=n; i--)\n#define CK(n,a,b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(),(v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define v2(T) vector<vector<T>>\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1e9+7;\nconst int inf=1e9;\n\nint dp[310][310];\nint n;\nint w[310];\nint main() {\n    while(cin>>n, n){\n        REP(i,0,n) REP(j,0,n) dp[i][j] = 0;\n        REP(i,0,n) cin>>w[i];\n        for(int k=1;k<n;k++){\n            REP(L,0,n-k){\n                int R = L + k;\n                if(dp[L+1][R-1] == k-1) dp[L][R] = max(dp[L][R], dp[L+1][R-1] + (abs(w[L]-w[R]) <= 1)*2);\n                REP(i,L+1,R-1) dp[L][R] = max(dp[L][R], dp[L][i] + dp[i+1][R]);\n            }\n        }\n        p(dp[0][n-1]);\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\n int main(){\n\n\tint N,data[301],ans;\n\tbool** table = new bool*[301];\n\tint** dp = new int*[301];\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i <= 300; i++){\n\t\t\tfor(int k = 0; k <= 150; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= 300; k++){\n\t\t\t\tdp[i][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1){\n\t\t\t\ttable[i][1] = true;\n\t\t\t\tdp[i][i+1] = 2;\n\t\t\t}else{\n\t\t\t\tdp[i][i+2] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int length = 4; length <= N; length += 2){\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t\tdp[left][left+length-1] = length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = N-(length/2);left >= N-length+2; left--){ //????????¨???????????????\n\t\t\t\tdp[left][N] = max(dp[left+1][left+(length-2)-1],max(dp[left][left+(length-2)+1],dp[left+1][N])); //?????????????????????????????§????????????\n\t\t\t}\n\t\t\tfor(int left = N-length+1; left >= 1; left--){ //?§????????????????\n\t\t\t\tfor(int mid = left+1; mid <= N-2; mid++){\n\t\t\t\t\tdp[left][left+length-1] = max(dp[left][left+length-1],dp[left][mid]+dp[mid+1][left+length-1]);\n\t\t\t\t\tans = max(ans,dp[left][left+length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 1; i <= N-1; i++){\n\t\t\tfor(int k = i+1; k <= N; k++){\n\t\t\t\tprintf(\"dp[%d][%d]:%d\\n\",i,k,dp[i][k]);\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[100];\nint dp[300][300];\n//int ans[300];\n\nbool C(int lb, int ub) {\n\t//cout << lb << \" \" << ub /*<< dp[lb][ub]*/ << endl;\n\tif (dp[lb][ub] != -1)return dp[lb][ub];\n\tif (ub - lb <= 0)return dp[ub][lb] = 0;\n\telse if (ub - lb == 1) {\n\t\tif (abs(x[lb] - x[ub]) <= 1)return dp[lb][ub] = 1;\n\t}\n\tdp[lb][ub] = 0;\n\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\tdp[lb][ub] |= C(lb + 1, ub - 1);\n\t}\n\tFOR(mid, lb, ub) {\n\t\t//cout << \"!\" << lb << \" \" << mid << endl;\n\t\t//cout << \"!\" << mid << \" \" << ub << endl;\n\t\tbool f = C(lb, mid);\n\t\tf &= C(mid + 1, ub);\n\t\tdp[lb][ub] |= f;\n\t}\n\treturn dp[lb][ub];\n}\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 300)rep(j, 300) {\n\t\t\tdp[i][j] = -1;\n\t\t\t//ans[i] = 0;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tC(0, n - 1);\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << dp[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tint ans = 0;\n\t\trep(i, n) {\n\t\t\t//if (i >= 1)ans[i] = ans[i - 1];\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tnum = max(num, j - i + 1);\n\t\t\t\t\tpos = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += num;\n\t\t\ti = pos;\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << ans[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 305\nusing namespace std;\nint n,w[N],dp[N][N];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)\n      cin>>w[i];\n    memset(dp,0,sizeof(dp));\n    int ans=0;\n    for(int i=1;i<=n;i+=2){\n      for(int j=0;j<=n-i;j++){\n\tdp[j][j+i]=dp[j+1][j+i-1];\n\tfor(int k=j+1;k<=j+i;k+=2)\n\t  dp[j][j+i]=max(dp[j][j+i],dp[j][k]+dp[k+1][j+i]);\n\tif(dp[j+1][j+i-1]==i-1&&abs(w[j]-w[j+i])<=1)\n\t  dp[j][j+i]=max(dp[j][j+i],dp[j+1][j+i-1]+2);\n\tans=max(ans,dp[j][j+i]);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint SolveDaruma(const int n, const vector<int> &w) {\n    vector<vector<int>> s(n, vector<int>(n));\n\n    for (int l = 0; l + 1 < n; ++l)\n        if (abs(w[l] - w[l + 1]) <= 1)\n            s[l][l + 1] = 2;\n\n    for (int i = 3; i <= n; ++i)\n        for (int l = 0; l + i <= n; ++l) {\n            const int r = l + i - 1;\n\n            if (abs(w[l] - w[r]) <= 1 && s[l + 1][r - 1] == i - 2) {\n                s[l][r] = i;\n                continue;\n            }\n\n            for (int m = l + 1; m <= r; ++m)\n                s[l][r] = max(s[l][r], s[l][m - 1] + s[m][r]);\n        }\n\n    return s[0][n - 1];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n\n    while (cin >> n, n) {\n        vector<int> w(n);\n        for (auto &x : w) cin >> x;\n\n        cout << SolveDaruma(n, w) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30)\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nvoid solve(int n) {\n    vector<int> w(n);\n    rep(i, 0, n) cin >> w[i];\n    vector<vector<int> > dp(n, vector<int>(n, 0));\n    for (int i = 0; i + 1 < n; i++) {\n        if (abs(w[i + 1] - w[i]) <= 1) {\n            dp[i][i + 1] = 2;\n        } else {\n            dp[i][i + 1] = 0;\n        }\n    }\n    for (int d = 2; d < n; d++) {\n        for (int i = 0; i + d < n; i++) {\n            int j = i + d;\n            if (abs(w[j] - w[i]) <= 1 && dp[i + 1][j - 1] == j - i - 1) {\n                dp[i][j] = j - i + 1;\n            } else {\n                for (int k = i; k < j; k++) {\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                }\n            }\n\n        }\n    }\n    cout << dp[0][n-1] << endl;\n//    if (n % 2 == 0) {\n//        cout << dp[0][n - 1] << endl;\n//    } else {\n//        int ans = max(dp[0][n-2],dp[1][n-1]);\n//        cout << ans << endl;\n//\n//    }\n//    for(int i = 0; i < n; i++){\n//\n//    }\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        solve(n);\n\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)a;i<(int)b;i++)\n#define rep(i,n) repl(i,0,n)\n#define maxch(a,b) a=max(a,b)\n\nint n;\nint a[333];\nint dp[333][333];\n\nint main(int argc, char const *argv[])\n{\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    rep(i,n-1)dp[i][i+2]=abs(a[i]-a[i+1])<=1?2:0;\n    repl(len,3,n+1)rep(i,n-len+1){\n      int j=i+len;\n      repl(k,i,j){\n        maxch(dp[i][j],dp[i][k]+dp[k][j]);\n      }\n      if(dp[i+1][j-1]==(j-1)-(i+1)&&abs(a[i]-a[j-1])<=1){\n        maxch(dp[i][j],dp[i+1][j-1]+2);\n      }\n    }\n    cout<<dp[0][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n  while(cin >> n, n) {\n    vector<int> w(n);\n    rep(i, n) cin >> w[i];\n\n    int dp[n][n] = {};\n    rep(i, n - 1) if (abs(w[i] - w[i + 1]) < 2) dp[i + 1][i] = 2;\n\n    repl(i, 2, n) {\n      rep(j, n - i) {\n        rep(k, i) {\n          maxch(dp[j + i][j], dp[j + k][j] + dp[j + i][j + k + 1]);\n        }\n        if (dp[j + i - 1][j + 1] == i - 1) maxch(dp[j + i][j], dp[j + i - 1][j + 1] + ((abs(w[j] - w[j + i]) < 2) ? 2 : 0));\n      }\n    }\n    cout << dp[n - 1][0] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\n\nint main(){\n    while(1){\n        \n        \n        \n        \n    \n    int n,a[500]={};\n    cin>>n;\n        if(n==0){break;}\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    bool j[500][500]={};\n    for(int i=2;i<=n;i+=2){\n        for(int t=0;t<=n-i;t++){\n            if(abs(a[t]-a[t+i-1])<=1 && (j[t+1][t+i-2] || i==2)){j[t][t+i-1]=true; continue;}\n            for(int h=t+1;h<t+i-1;h++){\n                if(j[t][h] && j[h+1][t+i-1]){j[t][t+i-1]=true; break;}\n            }\n        }\n    }\n    int dp[500];\n    fill(dp,dp+500,1000000000);\n    dp[0]=1;\n    for(int i=0;i<n;i++){\n        if(j[0][i]){dp[i]=0;}\n    }\n    for(int i=1;i<n;i++){\n        dp[i]=min(dp[i],dp[i-1]+1);\n        for(int t=i;t<n;t++){\n            if(j[i][t]){dp[t]=min(dp[t],dp[i-1]);}\n        }\n    }\n    \n    /*\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            cout<<(j[i][t]?\"1\":\"0\")<<\" \";\n        }\n        cout<<endl;\n    }\n     */\n    \n    //for(int i=0;i<n;i++){\n        cout<<n-dp[n-1]<<endl;\n    //}\n    \n    \n        \n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n#define inf 10e17\n#define rep(i,n) for(long long i=0; i<n; i++)\n#define repr(i,n,m) for(long long i=m; i<n; i++)\n#define mod 1000000007\n#define sorti(x) sort(x.begin(), x.end())\n#define sortd(x) sort(x.begin(), x.end(), std::greater<long long>())\n#define debug(x) std::cerr << (x) << std::endl;\n#define roll(x) for (auto&& itr : x) { cerr << (itr) << \" \"; }\n\ntemplate <class T> inline void chmax(T &ans, T t) { if (t > ans) ans = t;}\ntemplate <class T> inline void chmin(T &ans, T t) { if (t < ans) ans = t;}\n\nvoid can_take(int n, vector<vector<int>> &dp, vector<int> const& w) {\n  repr(i, n, 0) repr(j, n-i, 0) {\n    int left = j, right = i + j; // [left, right]\n    int len = i + 1;\n\n    repr(k, right, left) {\n      if (dp[left][k] && dp[k+1][right]) dp[left][right] = true;\n    }\n\n    if (len == 2 && abs(w[left] - w[right]) < 2) dp[left][right] = true;\n\n    if (dp[left][right]) {\n      left --, right ++;\n      while (left >= 0 && left < n && right >= 0 && right < n) {\n        if (abs(w[left] - w[right]) < 2) dp[left][right] = true;\n        else break;\n        left --, right ++;\n      }\n    }\n  }\n}\n\n\nint main() {\n  ll n;\n\n  while (cin >> n && n != 0) {\n    vector<int> w(n);\n    repr(i, n, 0) cin >> w[i];\n    vector<vector<int>> dp1(n, vector<int>(n, 0));\n    vector<vector<int>> dp2(n, vector<int>(n));\n\n    can_take(n, dp2, w);\n    /*for (auto it : dp2) {\n      for (auto itr : it) {\n        cerr << itr << \" \";\n      }\n      cerr << endl;\n    }*/\n\n    repr(i, n, 0) repr(j, n, i+1) {\n      if (dp2[i][j]) dp1[i][j] = j - i + 1;\n    }\n\n/*    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n        cerr << dp1[i][j] << \" \";\n      }\n      cerr << endl;\n    }*/\n\n    repr(i, n, 0) repr(j, n, i) repr(k, j, i) {\n      dp1[i][j] = max(dp1[i][j], dp1[i][k] + dp1[k+1][j]);\n    }\n    cout << dp1[0][n-1] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nint d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nll f(ll l,ll r){\n  if(dp[l][r] != -1)return dp[l][r];\n  if(r-l <= 0)return dp[l][r] = 0;\n  ll ret = 0;\n  rep(i,l,r){\n    ret = max(ret,f(l,i)+f(i+1,r));\n  }\n  if(abs(d[l]-d[r]) <= 1){\n    if(f(l+1,r-1) == r-l-1){\n      ret = max(ret,f(l+1,r-1)+2);\n    }\n  }\n  return dp[l][r] = ret;\n}\n\nint main(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0)break;\n    rep(i,0,n)cin >> d[i];\n    clr(dp,-1);\n    cout << f(0,n-1) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tloc = div = 0;\n\t}\n\tint loc,div;\n};\n\nint N,maximum;\n\nvoid recursive(int table[],int num,int SIZE){\n\n\tmaximum = max(maximum,2*num);\n\n\tint max_chain = 0,tmp_chain,next_index = 0;\n\tInfo nextTable[SIZE];\n\n\tint count = 0;\n\tfor(int i = 1; i <= SIZE-1; i++){\n\t\tif(abs(table[i] - table[i-1]) <= 1){\n\t\t\tcount++;\n\t\t\tif(i == SIZE-1){\n\t\t\t\tif(max_chain == 0){\n\t\t\t\t\tnextTable[next_index].loc = SIZE-1;\n\t\t\t\t\tnextTable[next_index++].div = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttmp_chain = 0;\n\t\t\t\tfor(int k = 1;(i-1)-k>=0 && i+k <= SIZE-1;k++){\n\t\t\t\t\tif(abs(table[(i-1)-k] - table[i+k]) <= 1){\n\t\t\t\t\t\ttmp_chain++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp_chain > max_chain){\n\t\t\t\t\tmax_chain = tmp_chain;\n\t\t\t\t\tnext_index = 0;\n\t\t\t\t\tnextTable[next_index].loc = i;\n\t\t\t\t\tnextTable[next_index++].div = tmp_chain;\n\t\t\t\t}else if(tmp_chain == max_chain){\n\t\t\t\t\tnextTable[next_index].loc = i;\n\t\t\t\t\tnextTable[next_index++].div = tmp_chain;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(2*(num+count) <= maximum)return;\n\n\tfor(int i = 0; i < next_index;i++){ //?????????????????¨???????????¨???????????????????????????\n\t\tint work[SIZE],new_table[SIZE],next_size = 0;\n\t\tfor(int k = 0; k < SIZE; k++)work[k] = table[k];\n\t\twork[nextTable[i].loc-1] = -1;\n\t\twork[nextTable[i].loc] = -1;\n\n\t\tfor(int k = 1; k <= nextTable[i].div; k++){\n\t\t\twork[nextTable[i].loc-1-k] = -1;\n\t\t\twork[nextTable[i].loc + k] = -1;\n\t\t}\n\n\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\tif(work[k] != -1){\n\t\t\t\tnew_table[next_size++] = work[k];\n\t\t\t}\n\t\t}\n\t\trecursive(new_table,num+nextTable[i].div+1,next_size);\n\t}\n}\n\nvoid func(){\n\n\tint first[N];\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&first[i]);\n\n\tif(N == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}else if(N == 2){\n\t\tif(abs(first[0] - first[1] <= 1)){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\trecursive(first,0,N);\n\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\t\tmaximum = 0;\n\n\t\tfunc();\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000001\n#define ll long long\nusing namespace std;\n\n\n\nint main()\n{\n  while (true)\n  {\n    ll n;\n    cin >> n;\n    if (n == 0)\n    {\n      break;\n    }\n    vector<ll> a(n);\n    for (ll i = 0; i < n; ++i)\n    {\n      cin >> a.at(i);\n    }\n    vector<vector<ll>> dp(n, vector<ll>(n, 0));\n    for (ll i = 0; i < n - 1; ++i)\n    {\n      if (abs(a.at(i + 1) - a.at(i)) <= 1)\n      {\n        dp.at(i).at(i + 1) += 1;\n      }\n    }\n    for (ll w = 0; w < n; ++w)\n    {\n      for (ll l = 0; l < n - w; ++l)\n      {\n        ll r = l + w;\n        // cout << \"r\" << r << endl;\n        for (ll m = l; m < r; ++m)\n        {\n          dp.at(l).at(r) = max(dp.at(l).at(r), dp.at(l).at(m) + dp.at(m + 1).at(r));\n        }\n        if (l - 1 >= 0 && r + 1 < n)\n        {\n          // cout << dp.at(l).at(r) << \"w\" << w << endl;\n          // if (dp.at(l).at(r) * 2 == w + 1)\n          // {\n            //   cout << l << r << endl;\n            // }\n            if ((dp.at(l).at(r) * 2 == w + 1) && (abs(a.at(l - 1) - a.at(r + 1)) <= 1))\n            {\n              // cout << l << r << endl;\n              dp.at(l - 1).at(r + 1) = dp.at(l).at(r) + 1;\n            }\n          }\n        }\n      }\n      cout << dp.at(0).at(n - 1) * 2 << endl;\n      // for (ll i = 0; i < n; ++i)\n      // {\n        //   for (ll j = 0; j < n; ++j)\n        //   {\n          //     cout << dp.at(i).at(j) << ' ';\n          //   }\n          //   cout << endl;\n          // }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cmath>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,a,n) for(int i=(a);i<(n);i++)\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<int> w(n);\n    REP(i,n)cin>>w[i];\n    bool dp[303][303];\n    int ans[303];\n    fill(dp[0],dp[n],false);\n    fill(ans,ans+n,0);\n    for(int i = 0;i <n;i++)dp[i][i+1] |= abs(w[i+1]-w[i])<=1;\n    for(int width = 2;width <= n;width++){\n      for(int l = 0;l + width <= n;l++){\n\t\t\t\tint r = l + width-1;\n\t\t\t\tfor(int d = l;d < l+width-1;d++){//-1??¨???\n\t\t\t\t\tdp[l][r] |= dp[l][d]&&dp[d+1][r];\n\t\t\t\t\tdp[l][r] |= !(width&1) && dp[l+1][r-1] && abs(w[l]-w[r]) <=1;\n\t\t\t\t}\n      }\n    }\n\t\t/*\t\tFOR(width,1,n+1){\n\t\t\tREP(l,n-width){\n\t\t\t\tcout << dp[l][l+width] << ' ';\n\t\t\t\t}\n\t\t\tcout << endl;\n\t\t\t}*/\n    for(int i = 0;i<n;i++){\n\t\t\t//i-1?????§????????£????????????\n\t\t\t//i??\\????????´??°??§??????????????????i???????????¶??§i-1??????????????????\n\t\t\t//ans[i]???????????´??°???????????§????????????divide??°??????????????????????????¢?????´??°???????????????\n\t\t\tif(i > 0)ans[i] = max(ans[i],ans[i-1]);\n      for(int r = i+1;r<n;r++){\n\t\t\t\t//i-1?????§????????£??????????????????i???????§???????????¶????????????????????????¨?????´??°????????????\n\t\t\t\tif(dp[i][r]) ans[r] = max(ans[r],ans[i-1] + (r-i+1));\n      }\n    }\n    cout << ans[n-1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// https://kimiyuki.net/writeup/algo/etc/icpc-2016-domestic-d/\n// http://tsutaj.hatenablog.com/entry/2017/03/07/173127\n#include <bits/stdc++.h>\nusing namespace std;\n\nint w[300];\nbool isOK[301][301];    // isOK[l][r] := [l, r)が連続して取り出し可能かどうか\nint DP[301][301];       // DP[l][r] := [l, r)取り出し可能なブロック数\n\nbool isConnected(int i, int j) {\n    return abs(w[i] - w[j]) <= 1;\n}\n\nbool solve()\n{\n    int n;\n    cin >> n;\n    if(n == 0) return false;\n    for(int i = 0; i < n; ++i) cin >> w[i];\n    memset(isOK, 0, sizeof(isOK));\n    memset(DP, 0, sizeof(DP));\n    for(int i = 0; i < n; ++i) {\n        isOK[i][i] = true;\n    }\n    for(int len = 2; len <= n; ++len) {\n        for(int i = 0; i + len <= n; ++i) {\n            // [i, i + len) が取り出し可能か調べる\n\n            // [i + 1, i + len - 1) が取り出し可能で、i番目と(i+len-1)番目のブロックの差が1以下なら\n            // [i, i + len) は取り出し可能\n            if(isOK[i+1][i + len - 1] && isConnected(i, i + len - 1)) {\n                isOK[i][i+len] = true;\n                continue;\n            }\n\n            // [i, i+k) と [i+k, i+len)が取り出し可能なら[i, i+len)も取り出し可能\n            for(int k = 0; k <= len; ++k) {\n                if(isOK[i][i+k] && isOK[i+k][i+len]) {\n                    isOK[i][i+len] = true;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // 区間DPで「区間どうしがおなじ頂点（ブロック）を被覆しないようにいくつか区間を選ぶときの、\n    // 被覆できる頂点（ブロック）の最大値」を求める\n    for(int left = 0; left < n; ++left) {\n        for(int right = left; right <= n; ++right) {\n            if(isOK[left][right]) DP[left][right] = right - left;\n        }\n    }\n\n    for(int len = 0; len <= n; ++len) {\n        for(int left = 0; left <= n; ++left) {\n            int right = left + len;\n            if(n < right) break;\n            for(int k = left; k <= right; ++k) {\n                DP[left][right] = max(DP[left][right], DP[left][k] + DP[k][right]);\n            }\n        }\n    }\n    // 以下の遷移の仕方でもACになった。なんでかはわからない、、、\n    /*\n    for(int left = 0; left <= n; ++left) {\n        for(int right = left; right <= n; ++right) {\n            for(int k = left; k <= right; ++k) {\n                DP[left][right] = max(DP[left][right], DP[left][k] + DP[k][right]);\n            }\n        }\n    }\n    */\n    // 上の遷移でACになったので、実際に参照する値はleft == 0の時のみなので、上の遷移の無駄を省いたところ、これもACになった。\n    /*\n    for(int right = 0; right <= n; ++right) {\n        for(int k = 0; k <= right; ++k) {\n            DP[0][right] = max(DP[0][right], DP[0][k] + DP[k][right]);\n        }\n    }\n    */\n    cout << DP[0][n] << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst int INF_N = 1e+9;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\n//繰り返し二乗法\nll mod_pow(ll a, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\n//逆元(Eucledean algorithm)\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nusing mP = pair<modint, modint>;\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\nll dp[305][305];\n\nvoid solve() {\n    int n;\n    while(cin >> n, n){\n        vec w(n);\n        rep(i, n) cin >> w[i];\n        memset(dp, 0, sizeof(dp));\n\n        Rep1(len, 2, n){\n            rep(l, n){\n                int r = l + len;\n                if(r > n) continue;\n\n                if(dp[l+1][r-1] == len-2 && abs(w[l] - w[r-1]) <= 1){\n                    dp[l][r] = len;\n                }\n\n                Rep1(mid, l, r){\n                    dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid][r]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  //cout << fixed << setprecision(10);\n  //init_f();\n  //init();\n  //int t; cin >> t; rep(i, t)solve();\n  solve();\n//   stop\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> w;\nint memo[300][300];\n\nint calcMax(int l, int r){\n\n    if(r < l){\n        return 0;\n    }\n\n    int temp = memo[l][r];\n    if(temp != -1){\n        return temp;\n    }\n\n    if(r == l){\n        memo[l][r] = 0;\n        return 0;\n    }\n\n    if(r - l == 1){\n        if(abs(w[l] - w[r]) <= 1){\n            memo[l][r] = 2;\n            return 2;\n        }\n        else{\n            memo[l][r] = 0;\n            return 0;\n        }\n    }\n\n    int ret = 0;\n    if(abs(w[l] - w[r]) <= 1 && calcMax(l + 1, r - 1) == (r - l - 1)){\n        ret = max(ret, calcMax(l + 1, r - 1) + 2);\n    }\n\n    for(int i = l; i < r; i++){\n        ret = max(ret, calcMax(l, i) + calcMax(i + 1, r));\n    }\n\n    /* for(int i = 1; i <= 2; i++){\n        ret = max(ret, calcMax(l, r - i) + calcMax(r - i + 1, r));\n    }*/\n\n    memo[l][r] = ret;\n    return ret;\n}\n\nint main(){\n\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        w.resize(n);\n        for(int i = 0; i < n; i++){\n            cin >> w[i];\n        }\n\n        memset(memo, -1, sizeof(memo));\n\n        int ans = calcMax(0, n - 1);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\n\nint n;\nvector<int> w;\nauto memo0 = make_vec<int>(330, 330);\nint dp0(int l, int r) {\n    if (memo0[l][r] != -1) return memo0[l][r];\n    if (l + 1 == r) return memo0[l][r] = abs(w[l] - w[r]) <= 1;\n    if (l + 1 < r - 1 && dp0(l + 1, r - 1) && abs(w[l] - w[r]) <= 1)\n        return memo0[l][r] = 1;\n    int ret = 0;\n    for (int m = l + 1; m + 1 < r; m++) {\n        ret |= (dp0(l, m) && dp0(m + 1, r));\n    }\n    return memo0[l][r] = ret;\n}\n\nauto memo1 = make_vec<int>(330, 330);\nint dp1(int l, int r) {\n    if (memo1[l][r] != -1) return memo1[l][r];\n    if (dp0(l, r)) return memo1[l][r] = r - l + 1;\n    int ret = 0;\n    for (int m = l; m < r; m++) {\n        chmax(ret, dp1(l, m) + dp1(m + 1, r));\n    }\n    return memo1[l][r] = ret;\n}\nint main() {\n    while (1) {\n        cin >> n;\n        if (n == 0) break;\n        w.resize(n);\n        rep(i, n) cin >> w[i];\n        rep(i, 330) rep(j, 330) memo0[i][j] = memo1[i][j] = -1;\n        // rep(r, n) rep(l, r) cout << l << \" \" << r << \" \" << dp1(l, r) <<\n        // endl;\n        cout << dp1(0, n - 1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint MAX(int a,int b){return a<b?b:a;}\nint main(){\n  int n,m[1010],i,j,k,d[510][510]={};\n  while(scanf(\"%d\",&n),n){\n    for(i=0;i<n;i++)scanf(\"%d\",&m[i]);\n    for(i=0;i<=n;i++){\n      for(j=0;i+j<=n;j++){\n\tif(i<2)d[j][j+i]=0;\n\telse if(d[j+1][j+i-1]+2==i&&abs(m[j]-m[j+i-1])<2)d[j][j+i]=i;\n\telse{\nd[j][j+i]=0;\n\t  for(k=j+1;k<i+j;k++)d[j][j+i]=MAX(d[j][j+i],d[j][k]+d[k][j+i]);\n\t}\n      }\n    }\n    printf(\"%d\\n\",d[0][n]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nint n;\nVI w(301);\nVI2 memo(301, VI(301));\n\nint dp(int l, int r) {\n    if(l == r) return 0;\n    if(r-l == 1) return (std::abs(w[l]-w[r]) <= 1) ? 2 : 0;\n    if(memo[l][r] != -1) return memo[l][r];\n\n    int ans = 0;\n    if(std::abs(w[l]-w[r]) <= 1) {\n        int res = dp(l+1, r-1);\n        if(res == r-l-1) {\n            ans = 2 + res;\n        }\n    }\n    for(int i=l; i<r; ++i) {\n        ans = std::max(ans, dp(l, i) + dp(i+1, r));\n    }\n    return memo[l][r] = ans;\n}\n\nint main() {\n    while(std::cin >> n, n != 0) {\n        REP(i, n) {\n            std::cin >> w[i];\n        }\n        memo.assign(301, VI(301, -1));\n        std::cout << dp(0, n-1) << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nint n;\nint w[MAX];\nint done[305][305];\nint dp[305][305];\n\nvoid print_dp() {\n    rep(i, n) {\n        rep(j, n+1) {\n            cout << setw(3) << dp[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint ans(int l, int r) {\n    if (done[l][r]) {\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    if (r - l == 0) return 0;\n    if (r - l == 1) return 0; \n    if (l > r) return -INF;\n    if (r > n) return -INF;\n    if (r - l == 2) {\n        done[l][r] = true;\n        int res = 0;\n        if (abs(w[l] - w[l+1]) < 2) res = 2;\n        else res = 0;\n        dp[l][r] = res;\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    int res = 0;\n    rep(width, n) {\n        if (l + width > r)\n            break;\n        rep2(i, l, r)\n        {\n            if (i + width  > n)\n                break;\n            if (i + width > r)\n                break;\n            if (i  == l && i + width == r)\n                continue;\n            if (i + width == l)\n                continue;\n            int cnt = 0;\n            int tmp = 0;\n            if (ans(i, i + width) == width)\n            {\n                rep(j, n)\n                {\n                    cnt = j;\n                    if (i-1-j < l) break;\n                    if (i+width+j >= r) break;\n                    if (abs(w[i - 1 - j] - w[i + width + j]) < 2)\n                    {\n                        tmp += 2;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            tmp +=\n                ans(l, i - cnt)\n                 + ans(i, i + width) \n                 + ans(i + width + cnt, r);\n            res = max(res, tmp);\n        }\n    }\n\n\n    done[l][r] = true;\n    dp[l][r] = res;\n    // if (test) {\n    //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n    // }\n    return dp[l][r];\n}\n\nvoid solve() {\n    rep(i, 305) rep(j, 305) done[i][j] = false;\n    rep(i, 305) rep(j, 305) dp[i][j] = 0;\n    cin >> n;\n    if (n == 0) exit(0);\n    rep(i, n) cin >> w[i];\n    cout << ans(0, n) << endl;\n    // if (test) print_dp();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint w[310], dp[310][310];\n\nint rec(int i, int j) {\n    if (dp[i][j] >= 0) return dp[i][j];\n    if (i >= j) return dp[i][j] = 0;\n    int res = 0;\n    for (int k = i + 1; k < j; ++k) {\n        res = max(res, rec(i, k) + rec(k, j));\n    }\n    if ((j - i) % 2 == 0 && abs(w[i] - w[j - 1]) <= 1) {\n        if (rec(i + 1, j - 1) == j - i - 2) {\n            res = max(res, dp[i + 1][j - 1] + 2);\n        }\n    }\n    return dp[i][j] = res;\n}\n\nint main() {\n    while (cin >> n, n) {\n        for (int i = 0; i < n; ++i) {\n            cin >> w[i];\n        }\n        memset(dp, -1, sizeof(dp));\n        cout << rec(0, n) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0; i<(n); i++)\n#define REP2(i,x,n) for(int i=x; i<(n); i++)\n#define PRINT(x) cout<<(x)<<endl\n#define INF 1000000000000 // 10^12\n#define MOD 1000000007 // 10^9+7\n#define PB push_back\n#define MP make_pair\n\nconst int MAX_N = 300;\n\nint n;\nint w[MAX_N];\n\nbool dp[MAX_N][MAX_N];\nint dp2[MAX_N][MAX_N];\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        REP(i, n) cin >> w[i];\n\n        REP(i, n) {\n            REP(j, n) dp[i][j] = false;\n        }\n\n        for (int i = 0; i+1 < n; i++) {\n            if (abs(w[i] - w[i+1]) <= 1) dp[i][i+1] = true;\n        }\n\n        for (int i = 3; i < n; i += 2) {\n            for (int j = 0; j + i < n; j++) {\n                int k = j + i;\n                if (dp[j+1][k-1] && abs(w[j] - w[k]) <= 1) dp[j][k] = true;\n                for (int l = j + 2; l < k; l += 2) {\n                    if (dp[j][l-1] && dp[l][k]) dp[j][k] = true;\n                }\n            }\n        }\n\n        int ans = 0;\n        REP(i, n) {\n            REP(j, n) dp2[i][j] = 0;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j + i < n; j++) {\n                int k = j + i;\n                if (dp[j][k]) dp2[j][k] = k - j + 1;\n                for (int l = j; l < k; l++) dp2[j][k] = max(dp2[j][k], dp2[j][l] + dp2[l+1][k]);\n            }\n        }\n        PRINT(dp2[0][n-1]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <stack>\n#include <regex>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define vi vector<int>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main()\n{\n  while (true)\n  {\n    int n;\n    cin >> n;\n    int dp[305][305];\n    REP(i, 305)\n    {\n      REP(j, 305)\n      {\n        dp[i][j] = 0;\n      }\n    }\n    if (n == 0)\n    {\n      break;\n    }\n    vi w = vi(n, 0);\n    REP(i, n)\n    {\n      cin >> w[i];\n    }\n    for (int width = 2; width < n + 1; width++)\n    {\n      REP(left, n)\n      {\n        int right = left + width - 1;\n        if (right >= n)\n        {\n          continue;\n        }\n        // 間のブロックが全部叩けるかつ両端の重さの差が1以下\n        if (dp[left + 1][right - 1] == width - 2 && abs(w[left] - w[right]) <= 1)\n        {\n          dp[left][right] = width;\n        }\n        for (int k = left; k < right; k++)\n        {\n          dp[left][right] = max(dp[left][right], dp[left][k] + dp[k + 1][right]);\n        }\n      }\n    }\n    cout << dp[0][n - 1] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\nint w[N],mem[N][N],used[N][N];\n\nint dfs(int l,int r){\n  if(l==r) return 0;\n  if(r-l==1) return 2*(abs(w[l]-w[r])<=1);\n  if(used[l][r]++) return mem[l][r];\n  \n  int res=0;\n  if(abs(w[l]-w[r])<=1&&dfs(l+1,r-1)==r-l-1)res=2+dfs(l+1,r-1);\n  \n  for(int i=l;i<r;i++) res=max(res,dfs(l,i)+dfs(i+1,r));\n  return mem[l][r]=res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>w[i];\n    memset(used,0,sizeof(used));\n    cout<<dfs(0,n-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (bit & (1LL << i))\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<typename T> using VVVV = std::vector<std::vector<std::vector<std::vector<T>>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\nint solve(V<int> &A) {\n    int N = A.size();\n    VV<int> dp(N + 1, V<int>(N + 1));  // 閉区間\n\n    FOR(w, 2, N + 1) {\n        FOR(left, 0, N) {\n            int right = left + w - 1;\n            if (right >= N) {\n                continue;\n            }\n\n            // left + 1からright - 1までが取り除けて、left, rightの組で取り除ける\n            if (dp[left + 1][right - 1] == w - 2 and abs(A[left] - A[right]) <= 1) {\n                dp[left][right] = w;\n            }\n            // leftからrightの最大値\n            FOR(middle, left, right) {\n                dp[left][right] = max(dp[left][right], dp[left][middle] + dp[middle + 1][right]);\n            }\n        }\n    }\n\n    return dp[0][N - 1];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n\n        V<int> A(N);\n        FOR(i, 0, N) {\n            cin >> A[i];\n        }\n        print(solve(A));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  unsigned int N = 0;\n  vector<int> num;\n  int w = 0;\n\n  cin >> N;\n  while(N != 0) {\n    for(unsigned int i = 0; i < N; i++) {\n      cin >> w;\n      num.push_back(w);\n    }\n\n    while(true) {\n      unsigned int i;\n      for(i = num.size()-1; i > 0; i--)\n\tif(num.at(i)-num.at(i-1) >= -1 && num.at(i)-num.at(i-1) <= 1)\n\t  break;\n\n      if(i == 0)\n\tbreak;\n      num.erase(num.begin()+i);\n      num.erase(num.begin()+i-1);\n      \n      if(num.empty())\n\tbreak;\n    }\n\n    cout << N-num.size() << endl;\n\n    num.clear();\n\n    cin >> N;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nvector<tuple<int, int, int>>vec; int n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; vec.clear(); for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; } for (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { vec.push_back(make_tuple(j - i, i, j)); } }\n\t\tsort(vec.begin(), vec.end());\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tint a1 = get<1>(vec[i]), a2 = get<2>(vec[i]);\n\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 0; i < n; i++) { for (int j = i; j < n; j++) { for (int k = j; k < n; k++) { dp[i][k] = max(dp[i][k], dp[i][j - 1] + dp[j][k]); } } }\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define ALL(x)    (x).begin(),(x).end()\n#define UNIQ(c)   (c).erase(unique(ALL((c))), end((c)))\n#define mp        make_pair\n#define eb        emplace_back\ntypedef pair<LL, LL> P;\ntypedef pair<P, P> PP;\n\nint N;\nint W[333];\n\nbool dp[333][333];\nint dp2[333];\nvoid solve() {\n\tfor (int i = 0; i < N; i++)cin >> W[i];\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int i = 0; i < N; i++)dp[i][i] = true;\n\n\tfor (int len = 2; len <= N; len++) {\n\t\tfor (int i = 0; i + len <= N; i++) {\n\t\t\tint j = i + len;\n\t\t\tif (abs(W[i] - W[j - 1]) <= 1)dp[i][j] |= dp[i + 1][j - 1];\n\t\t\tfor (int k = i + 1; k < j; k++)dp[i][j] |= dp[i][k] & dp[k][j];\n\t\t}\n\t}\n\tmemset(dp2, 0, sizeof(dp2));\n\tfor (int i = 0; i < N; i++) {\n\t\tdp2[i + 1] = max(dp2[i + 1], dp2[i]);\n\t\tfor (int j = i + 1; j <= N; j++)if (dp[i][j])dp2[j] = max(dp2[j], dp2[i] + j - i);\n\t}\n\tcout << dp2[N] << endl;\n}\nint main() {\n\twhile (cin >> N, N)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint a1 = j, a2 = i + j - 1; if (a2 >= n)continue;\n\t\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\t\tif (a1 > 1 && abs(a[a1 - 1] - a[a1 - 2]) <= 1)dp[a1 - 2][a2] = 1;\n\t\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\tint a1 = i, a2 = k, a3 = j; if (a3 > n)continue;\n\t\t\t\t\tdp[a1][a3 - 1] = max(dp[a1][a3 - 1], dp[a1][a2 - 1] + dp[a2][a3 - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvi num(n);\n\t\tREP(i, n) {\n\t\t\tcin >> num[i];\n\t\t}\n\t\tvvi dp(n, vi(n, 0));\n\t\tFOR(i, 2, n + 1) {\n\t\t\tif (i == 2) {\n\t\t\t\tREP(j, n - 1)\n\t\t\t\t\tif (abs(num[j] - num[j + 1]) <= 1) {\n\t\t\t\t\t\tdp[j][j + 1] = 2;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tREP(j, n - (i - 1)) {\n\t\t\t\t\tREP(k, i - 1) {\n\t\t\t\t\t\tdp[j][j + i - 1] = max(dp[j][j + i - 1], dp[j][j + k] + dp[j + k + 1][j + i - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif ((i % 2 == 0) && (dp[j + 1][j + i - 2] == i - 2) && (abs(num[j] - num[j + i - 1]) <= 1))\n\t\t\t\t\t\tdp[j][j + i - 1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint a1 = j, a2 = i + j - 1; if (a2 >= n)continue;\n\t\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tint a1 = k, a2 = k + i, a3 = k + i + j; if (a3 > n)continue;\n\t\t\t\t\tdp[a1][a3 - 1] = max(dp[a1][a3 - 1], dp[a1][a2 - 1] + dp[a2][a3 - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tint w[301];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> w[i];\n\t\t}\n\t\tvector<vector<bool> > canerase(n + 1, vector<bool>(n + 1, false));\n\t\t// canerase[i][j] = i番目のやつから数えてj個(i番目を含む)を落とせるか\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tcanerase[i][2] = (abs(w[i] - w[i + 1]) <= 1);\n\t\t}\n\t\tfor(int i = 4; i <= n; i += 2){\n\t\t\tfor(int j = 0; i + j <= n; j++){\n\t\t\t\tcanerase[j][i] = (abs(w[j] - w[i + j - 1]) <= 1) && canerase[j + 1][i - 2];\n\t\t\t\tfor(int k = 2; k <= i; k += 2){\n\t\t\t\t\tcanerase[j][i] = canerase[j][i] || (canerase[j][k] && canerase[j + k][i - k]);\n\t\t\t\t\t// cout << canerase[j][i] << endl;\n\t\t\t\t}\n\t\t\t\t// cout << j << \" \" << i << \" \" << (canerase[j][i]?1:2) << endl;\n\t\t\t}\n\t\t}\n\t\tint maxnum[301][301] = {};\n\t\tint ans = 0;\n\t\tfor(int i = 2; i <= n; i+= 2){\n\t\t\tfor(int j = 0; i + j <= n; j++){\n\t\t\t\tif(canerase[j][i]) maxnum[j][i] = i;\n\t\t\t\tfor(int k = 2; k <= i; k += 2){\n\t\t\t\t\tmaxnum[j][i] = max(maxnum[j][i], maxnum[j][k] + maxnum[j + k][i - k]);\n\t\t\t\t}\n\t\t\t\tans = max(ans, maxnum[j][i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <functional>\n\n#define MOD (1000000007)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> tup;\nconst int MAX = 3000000;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nmap<ll,ll> prime;//素因数分解でそれぞれの素数がいくつ出てきたかを保存するmap\n\n//O(√n)\n//整列済み(mapはkeyで自動で整列される)\nvoid prime_factorize(ll n){\n    if(n<=1) return;\n    ll l=sqrt(n);\n   for(ll i=2;i<=(ll)(l);i++) { //\n        if(n%i==0){\n            prime_factorize(i);prime_factorize(ll(n/i));return;\n        }\n    }\n    //mapでは存在しないkeyの場合も自動で構築される\n    prime[n]++;return;\n} \n\n\nint main() {\n    while (true) {\n        ll n;\n        cin >> n;\n\n        if(n == 0 ) break;\n\n        vector<ll> v;\n\n        for(ll i = 0; i < n; i++) {\n            ll w;\n            cin >> w;\n            v.push_back(w);\n        }\n\n        vector<vector<ll>> dp(n+1, vector<ll>(n+1, 0));\n        for(ll i = 0; i < n; i++) {\n            dp[i][i+1] = 0;\n        }\n        for(ll i = 0; i < n - 1; i++) {\n            dp[i][i+2] = abs(v[i] - v[i+1]) <= 1 ? 2 : 0;\n        }\n\n        for(ll diff = 3; diff <= n; diff++) {\n            for(ll i = 0; i + diff <= n; i++) {\n                //cout << \"*** [\" << i <<\", \" << i+diff << \")\" << endl;\n                if(dp[i+1][i+diff-1] == diff - 2 && abs(v[i] - v[i+diff-1]) <= 1) dp[i][i+diff] = diff;\n                else \n                for(ll after = i+1; after <= i+diff-1; after++) {\n                    // cout << \"-> [\" << i << \", \" << after << \") + [\" << after << \", \" << i+diff << \")\" << endl;\n                    // cout <<  dp[i][after] + dp[after][i+diff] << endl;\n                    dp[i][i+diff] = max(dp[i][i+diff], dp[i][after] + dp[after][i+diff]);\n                  //  cout << \"dp[\" << i << \"][\" << i+diff << \"] = \" << dp[i][i+diff] << endl;\n                }\n            }\n        }\n\n        cout << dp[0][n] << endl;\n    }\n\n    return 0;    \n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFTY 200000000000\nlong long dp[310][310];\nvector<long long> a(310);\nint b;\nlong long ch(int l,int r){\n    if(dp[l][r]>=0) return dp[l][r];\n    if(l==r){\n        return dp[l][r]=0;\n    }\n    for (int k = l; k < r; k++)\n    {\n        if(abs(a[k]-a[r])<=1 && ch(k+1,r-1) == r-k-1 &&ch(l,k-1)==ch(l,r-1)+1+k-r){\n            return dp[l][r] = max(dp[l][r],ch(l,r-1)+2);\n        }\n    }\n    for (int k = l+1; k < r+1; k++)\n    {\n        if(abs(a[k]-a[l])<=1 && ch(l+1,k-1) == k-l-1 && ch(k+1,r)==ch(l+1,r)+1+l-k){\n            return dp[l][r] = max(dp[l][r],ch(l+1,r)+2);\n        }\n    }\n    return dp[l][r] = max(ch(l+1,r),ch(l,r-1));\n}\nint main(){\n    while(1){\n    cin >> b;\n    if(b==0) return 0;\n    for (int i = 0; i < b; i++)\n    {\n        cin >> a[i];\n    }\n    \n    for (int i = 0; i < 305;i++)\n    {\n        for(int j=0;j<305;j++){\n            dp[i][j] = -1;\n        }\n    }\n    long long ans=0;\n   \n   ans = ch(0,b-1);\n    \n    cout << ans << endl;\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint n;\nint dp[301][301];\nbool take[301][301];\nint w[301];\n\nint main() {\n    while (cin >> n, n) {\n        fill(dp[0], dp[n], 0);\n        fill(take[0], take[n], false);\n        rep(i, n) cin >> w[i];\n\n        for (int len=0; len<n; ++len) {\n            rep(i, n-len) {\n                int l = i, r = i+len;\n\n                // [l, k] + [k+1, r] -> [l, r]\n                for (int k=l; k<r; ++k) {\n                    if (take[l][k] and take[k+1][r]) take[l][r] = true;\n                }\n\n                if (len+1 == 2) {\n                    if (abs(w[r]-w[l]) <= 1) take[l][r] = true;\n                }\n                if (take[l][r]) {\n                    int ll = l-1, rr = r+1;\n                    while (true) {\n                        if (ll < 0 or ll >= n or rr < 0 or rr >= n) break;\n                        if (abs(w[rr]-w[ll]) >= 2) break;\n                        take[ll][rr] = true;\n                        ll--; rr++;\n                    }\n                }\n            }\n        }\n\n        rep(i, n) for (int j=i+1; j<n; ++j) {\n            if (take[i][j]) dp[i][j] = j-i+1;\n        }\n\n        rep(i, n) for (int j=i; j<n; ++j) for (int k=i; k<j; ++k) {\n            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n        }\n\n        cout << dp[0][n-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nint main(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<=n;i+=2)\n      for(int j=0;j<n-i;j++){\n        for(int k=1;k<i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=i+1;\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint main(){\n\n    int n, a, b; cin >> a >> b;\n    n = abs(a - b);\n    cout << n << endl;\n    return 0;\n}bool take[310][310];\nint dp[310][310];\n\nsigned main() {\n    int n;\n    while(cin >> n, n) {\n        int w[310];\n        rep(i,0,n) cin >> w[i];\n        memset(take, false, sizeof(take));\n        memset(dp, 0, sizeof(dp));\n\n        rep(i,0,n) {\n            rep(j,0,n-i) {\n                int len = i+1;\n                int s = j, t = j+i;\n                rep(k,s,t) {\n                    if(take[s][k] && take[k+1][t]) take[s][t] = true;\n                }\n                if(len == 2) {\n                    if(abs(w[s] - w[t]) < 2) {\n                        take[s][t] = true;\n                    }\n                }\n                if(take[s][t]) {\n                    int x = s-1, y = t+1;\n                    while(1) {\n                        if(x < 0 || x >= n || y < 0 || y >= n) break;\n                        if(abs(w[x] - w[y]) >= 2) break;\n                        take[x][y] = true;\n                        x--; y++;\n                    }\n                }\n            }\n        }\n\n        rep(i,0,n) rep(j,i+1,n) {\n            if(take[i][j]) dp[i][j] = j-i+1;\n        }\n\n        rep(i,0,n) rep(j,i,n) rep(k,i,j) {\n            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 2000000000\n#define int long long int\n#define MOD 1000000007\n#define pb push_back\n#define cin1(n) (cin >> n)\n#define cin2(a,b) (cin >> a >> b)\n#define cin3(a,b,c) (cin >> a >> b >> c)\n#define cout(n) (cout << n << endl)\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define fr first \n#define sc second \n#define EPS (1e-10)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector< vector<int> > vvi;\ntypedef vector<pair<int,int>> vpii;\ntypedef vector<string> vs;\ntypedef vector<vector<string>> vss;\ntypedef pair<int,int> pii;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint a,b;\nint p,q;\n\n\nsigned main() {\n\t\n\twhile(1) {\n\t\tcin1(n);\n\t\tif (n == 0) break;\n\n\t\tvvi dp(n,vi(n,0)); //dp[i][j] i??????j??????????????§?????°\n\t\tvi daruma(n,0);\n\t\trep(i,0,n) {\n\t\t\tcin1(daruma[i]);\n\t\t}\n\n\t\trep(i,1,n) {\n\t\t\tif (abs(daruma[i-1] - daruma[i]) <= 1) {\n\t\t\t\tdp[i-1][i] = 2;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 2; i <= n; i++) { //??????\n\t\t\tfor (int l = 0; l < n - i + 1; l++) { //??????\n\t\t\t\tint r = l + i - 1;\n\t\t\t\tif (dp[l+1][r-1] == i - 2 and abs(daruma[l]-daruma[r]) <= 1) dp[l][r] = i; \n\t\t\t\tfor (int k = l; k < r; k++) {\n\t\t\t\t\tdp[l][r] = max(dp[l][r],dp[l][k] + dp[k+1][r]);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tcout(dp[0][n-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nint w[300], dp[301][301];\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    if(!n)break;\n\n    rep(i, n)scanf(\"%d\", w+i);\n    rep(i, n + 1)rep(j, n + 1)dp[i][j] = 0;\n\n    rep(i, n - 1)dp[i][i + 2] = (abs(w[i + 1] - w[i]) <= 1) * 2;\n\n    for(j = 3;j <= n;++j)rep(i, n - j + 1){\n      rep(k, j)dp[i][i + j] = max(dp[i][i + j], dp[i][i + k] + dp[i + k][i + j]);\n      if(abs(w[i] - w[i + j - 1]) <= 1 && dp[i + 1][i + j - 1] == j - 2)dp[i][i + j] = j;\n    }\n    //rep(i, n + 1)rep(j, n + 1)if(dp[i][j] > 0)pri3(i, j, dp[i][j]);\n    pri(dp[0][n]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[334][334];\n\nint rec(vector<int> &w, int l, int r){\n    if(dp[l][r] != -1) return dp[l][r];\n    if(r-2 < l) return dp[l][r] = 0;\n    if(l == r-2){\n        if(abs(w[l] - w[r-1]) <= 1) return dp[l][r] = 2;\n        else return dp[l][r] = 0;\n    }\n    int tmp = rec(w, l+1, r-1);\n    if(abs(w[l] - w[r-1]) <= 1 && tmp == (r-l-2)){\n        return dp[l][r] = tmp + 2;\n    }\n    for(int k=l+1; k<r; k++){\n        tmp = max(tmp, rec(w, l, k)+rec(w, k, r));\n    }\n    return dp[l][r] = tmp;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    while(n > 0){\n        vector<int> w(n);\n        for(int i=0; i<n; i++){\n            cin >> w[i];\n        }\n        memset(dp, -1, sizeof(dp));\n        cout << rec(w, 0, n) << endl;\n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nint n;\nint w[MAX];\nint done[305][305];\nint dp[305][305];\n\nvoid print_dp() {\n    rep(i, n) {\n        rep(j, n+1) {\n            cout << setw(3) << dp[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint ans(int l, int r) {\n    if (done[l][r]) {\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    if (r - l == 0) return 0;\n    if (r - l == 1) return 0; \n    if (l > r) return -INF;\n    if (r > n) return -INF;\n    if (r - l == 2) {\n        done[l][r] = true;\n        int res = 0;\n        if (abs(w[l] - w[l+1]) < 2) res = 2;\n        else res = 0;\n        dp[l][r] = res;\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    int res = 0;\n    rep(width, n) {\n        rep(width2, n) {\n            rep2(i, l, r) {\n                if (i+width+width2 > n) break;\n                if (i+width+width2*2 > r) break;\n                if (i+width2 == l && i+width+width2 == r) continue;\n                if (i+width+width2*2 == l) continue;\n                int tmp = \n                ans(l, i) \n                + ans(i+width2, i+width+width2) \n                + ans(i+width+width2*2, r);\n                if (ans(i+width2, i+width+width2) == width) {\n                    rep(j, width2) {\n                        if (abs(w[i+width2-1-j] - w[i+width+width2+j]) < 2) {\n                            tmp += 2;\n                        }\n                        else break;\n                    }\n                }\n                res = max(res, tmp);\n            }\n        }\n    }\n\n\n    done[l][r] = true;\n    dp[l][r] = res;\n    // if (test) {\n    //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n    // }\n    return dp[l][r];\n}\n\nvoid solve() {\n    rep(i, 305) rep(j, 305) done[i][j] = false;\n    rep(i, 305) rep(j, 305) dp[i][j] = 0;\n    cin >> n;\n    if (n == 0) exit(0);\n    rep(i, n) cin >> w[i];\n    cout << ans(0, n) << endl;\n    if (test) print_dp();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[300][300];\nint w[300];\nint rec(int s,int t){\n  if(dp[s][t]!=-1)return dp[s][t];\n  if(s==t)return 0;\n  int ans=rec(s+1,t-1);\n  if(ans==t-s-1&&abs(w[s]-w[t])<=1)return dp[s][t]=ans+2;\n  for(int i=s;i<t;i++){\n    ans=max(ans,rec(s,i)+rec(i+1,t));\n  }\n  return dp[s][t]=ans;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    memset(w,0,sizeof(w));\n    for(int i=0;i<n;i++)cin>>w[i];\n    memset(dp,-1,sizeof(dp));\n    for(int i=1;i<n;i++)\n      dp[i-1][i]=(abs(w[i-1]-w[i])<=1?2:0);\n    cout<<rec(0,n-1)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nint n;\nVI w(301);\nVI2 memo(301, VI(301));\n\nint dp(int l, int r) {\n    if(l == r) return 0;\n    if(r-l == 1) return (std::abs(w[l]-w[r]) <= 1) ? 2 : 0;\n    if(memo[l][r] != -1) return memo[l][r];\n\n    int ans = 0;\n    if(std::abs(w[l]-w[r]) <= 1) {\n        int res = dp(l+1, r+1);\n        if(res == r-l-1) {\n            ans = 2 + res;\n        }\n    }\n    for(int i=l; i<r; ++i) {\n        ans = std::max(ans, dp(l, i) + dp(i+1, r));\n    }\n    return memo[l][r] = ans;\n}\n\nint main() {\n    while(std::cin >> n, n != 0) {\n        REP(i, n) {\n            std::cin >> w[i];\n        }\n        memo.assign(301, VI(301, -1));\n        std::cout << dp(0, n-1) << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int abs(int a, int b)\n{\n    return a<b ? b-a : a-b;\n}\n\nint main()\n{\n    int n;\n    while(cin >> n, n)\n    {\n        int w[n];\n        for(int i=0; i<n; i++) cin >> w[i];\n        bool rm[n+1][n+1];\n        for(int i=0; i<=n; i++)\n            for(int j=0; j<=n; j++)\n                rm[i][j] = i==j;\n        for(int r=2; r<=n; r+=2)\n        {\n            for(int i=0; i+r<=n; i++)\n            {\n                for(int s=2; s<r; s+=2)\n                {\n                    if(rm[i][i+s] && rm[i+s][i+r]) rm[i][i+r] = true;\n                }\n                if(!rm[i][i+r] && rm[i+1][i+r-1] && abs(w[i], w[i+r-1])<=1)\n                    rm[i][i+r] = true;\n            }\n        }\n        /*\n        int rmw = -1;\n        for(int rmr = n / 2 * 2; rmw==-1 && rmr >= 0; rmr-=2)\n        {\n            for(int i=0; i+rmr<=n; i++)\n            {\n                if(rm[i][i+rmr])\n                {\n                    rmw = rmr;\n                    break;\n                }\n            }\n        }\n        */\n        int rmct[n+1][n+1];\n        for(int y=0; y<=n; y++)\n            for(int x=0; x<=n; x++)\n                rmct[y][x] = rm[y][x] ? x - y : 0;\n        for(int r=2; r<=n; r++)\n        {\n            for(int i=0; i<=n; i++)\n            {\n                for(int s=2; s<r; s++)\n                {\n                    rmct[i][i+r] = max(rmct[i][i+r], rmct[i][i+s]+rmct[i+s][i+r]);\n                }\n            }\n        }\n        cout << rmct[0][n] << endl;\n        // XXX DEBUG\n        /*\n        printf(\"i\\\\j \");\n        for(int x=0; x<=n; x++) printf(\"%3d \", x);\n        cout << endl;\n        for(int y=0; y<=n; y++)\n        {\n            printf(\"%3d \", y);\n            for(int x=0; x<=n; x++)\n            {\n                printf(\"%3d \", rm[y][x]);\n            }\n            cout << endl;\n        }\n        */\n        // XXX DEBUG\n        //cout << rmw << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define REPR(i,n) for(int i=(n); i >= 0; --i)\n#define FOR(i, m, n) for(int i = (m); i < (n); ++i)\n// #define INF 1e9\nconst ll INF = 1LL << 60;\n\nint n;\nvector<int> w;\nint dp[305][305];\n\nint rec(int l, int r){\n  if(dp[l][r] != -1){\n    return dp[l][r];\n  }\n  if(r-l <= 1){\n    return dp[l][r] = 0;\n  }\n  if(abs(w[l]-w[r-1]) <=1 && rec(l+1, r-1) == r-l-2){\n    return dp[l][r] = r-l;\n  }\n  int ans = 0;\n  FOR(i, l+1, r){\n    ans = max(ans, rec(l,i)+rec(i, r));\n  }\n  return dp[l][r] = ans;\n}\nint main(){\n  while(true){\n    cin >> n;\n    if(n==0) break;\n    REP(i, n+1){\n      REP(j, n+1){\n        dp[i][j] = -1;\n      }\n    }\n    w.resize(n);\n    REP(i, n){\n      cin >> w[i];\n    }\n    cout << rec(0, n) << endl;\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nint dp1[310][310], dp2[310];\nint solve_testcase() {\n    int N; scanf(\"%d\", &N);\n    if(N == 0) return 1;\n    vector<int> A(N);\n    for(int i=0; i<N; i++) scanf(\"%d\", &A[i]);\n    \n    fill(dp1[0], dp1[N+1], false);\n    for(int i=0; i<N; i++) {\n        dp1[i][i] = true;\n    }\n    for(int d=2; d<=N; d++) {\n        for(int l=0; l<N-d+1; l++) {\n            int r = l + d;\n            if(abs(A[l] - A[r-1]) <= 1 and dp1[l+1][r-1]) dp1[l][r] = true;\n\n            if(r - l >= 4) {\n                for(int k=l+2; k<=r-2; k++) {\n                    if(dp1[l][k] and dp1[k][r]) dp1[l][r] = true;\n                }\n            }\n        }\n    }\n\n    fill(dp2, dp2 + N + 1, -1);\n    dp2[0] = 0;\n    for(int i=0; i<N; i++) {\n        chmax(dp2[i+1], dp2[i]);\n        for(int j=i+1; j<=N; j++) {\n            if(!dp1[i][j]) continue;\n            chmax(dp2[j], dp2[i] + (j - i));\n        }\n    }\n    printf(\"%d\\n\", dp2[N]);\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nlong long n_max = 300;\n\nint main(){\n    long long n;\n    long long w[n_max + 1];\n    long long i,j,d;\n    long long dp[n_max + 1][n_max + 1];\n\n    //input\n    cin >> n;\n    while(n > 0){\n        for(i = 1; i <= n; i++){\n            cin >> w[i];\n        }\n\n        //calc\n        for(i = 1; i <= n-1; i++){\n            dp[i][i+1] = 2*(abs(w[i]-w[i+1]) <= 1);\n        }\n        for(d = 3; d <= n-1; d += 2){\n            for(i = 1; i <= n-d; i++){\n                dp[i][i+d] = dp[i+1][i+d-1] + (dp[i+1][i+d-1] == d-1 ? 2*(abs(w[i]-w[i+d]) <= 1) : 0);\n                for(j = i+1; j <= i+d-2; j += 2){\n                    dp[i][i+d] = max(dp[i][i+d], dp[i][j] + dp[j+1][i+d]);\n                }\n            }\n        }\n        if(n % 2 == 1){\n            dp[1][n] = max(dp[1][n-1], dp[2][n]);\n        }\n\n        //answer\n        cout << dp[1][n] << endl;\n\n        //input\n        cin >> n;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define MAX 300\nint n;\nint w[MAX];\nmap<string, int> wmap;\n\nstring nToStr(int n) {\n\tstring tmp = \"\";\n\tfor (int i = 0; i < n; i++) {\n\t\ttmp += \"1\";\n\t}\n\treturn tmp;\n}\n\nint next(string s, int now) {\n\tfor (int i = now+1; i < n; i++) {\n\t\tif (s[i] == '1') return i;\n\t}\n\treturn n;\n}\n\nstring pop(string s,int a,int b) { //w???a????????¨b?????????????????????\n\ts[a] = '0';\n\ts[b] = '0';\n\treturn s;\n}\n\nint daruma(string s) {\n\tif (wmap.find(s) != wmap.end()) return wmap[s];\n\t\n\n\tint max = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (s[i] == '1') {\n\t\t\tif (s[next(s, i)] != n && abs(w[i] - w[next(s, i)]) <= 1) {\n\t\t\t\tint tmp = daruma(pop(s, i, next(s, i))) + 2;\n\t\t\t\tif (tmp > max) max = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\twmap.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tcout << daruma(nToStr(n)) << endl;\n\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n#define EQ(a,b) (abs(a - b) < 1e-10)\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<LL> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<bool> VB;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\nint n;\nVI w;\ntypedef bitset<300> bit;\nstruct Comp {\n\tbool operator() (const bit &a,const bit &b) {\n\t\treturn a.to_ullong() < b.to_ullong();\n\t}\n};\nmap<bit,int,Comp> memo;\nint dfs(bit state) {\n\tif (IN(state,memo)) return memo[state];\n\tint num = 0,fi;\n\tREP(i,n-1) {\n\t\tif ((!state[i])) {\n\t\t\tfi = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFOR(i,fi+1,n) {\n\t\tif (!state[i]){\n\t\t\tif (abs(w[i] - w[fi]) <= 1) {\n\t\t\t\tbit next = (state | bit(1<<i) | bit(1<<(fi)));\n\t\t\t\tnum = max(dfs(next)+2,num);\n\t\t\t}\n\t\t\tfi = i;\n\t\t}\n\t}\n\treturn memo[state] = num;\n}\n\nint main(void) {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tw = VI(n);\n\t\tREP(i,n) cin >> w[i];\n\t\tcout << dfs(bit(0)) << endl;\n\t\tmemo.clear();\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 10000000;\n\nvector<vector<int>> mem;\nvector<int> bs;\n\nint rec(int l, int r) {\n  if(mem[l][r] >= 0) return mem[l][r];\n  if(l >= r) {\n    mem[l][r] = 0;\n  } else {\n    int d = r - l + 1;\n    if(rec(l+1, r-1) == d - 2 && abs(bs[l] - bs[r]) <= 1) {\n      mem[l][r] = d;\n    } else {\n      int ans = 0;\n      for(int k = l; k < r; k++) {\n        ans = max(ans, rec(l, k) + rec(k+1, r));\n      }\n      mem[l][r] = ans;\n    }\n  }\n  return mem[l][r];\n}\n\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    int m;\n    cin >> m;\n    if(m == 0) break;\n    bs.clear();\n    for(int i = 0; i < m; i++) {\n      int b;\n      cin >> b;\n      bs.push_back(b);\n    }\n    mem = vector<vector<int>>(m, vector<int>(m, -1));\n    int ans = rec(0, m-1);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n\n/*\n\n  f(i, j) : bs[i..j] ??????????????§?????°\n\n f(i,j) =\n    0          ... i >= j ?????¨??????????????????\n    j - i + 1  ... if bs[i] ??¨ bs[j] ????????? 1 ??\\?????§???i+1??????j-1???????????????????????????????????????????????????????????????????????????\n    f(i, k) + f(k + 1, j) ... ???????????§?????£????????????\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int>as;\nbool ok(int a,int b){\n  return abs(as[a]-as[b])<=1;\n}\n\nint main() {\n  while(1){\n    \n    int N;cin>>N;\n    if(!N)break;\n    as.resize(N);\n    vector<vector<int>>dp(N+1,vector<int>(N+1,-100000));\n    for(int i=0;i<N;++i){\n      int a;cin>>a;as[i]=a;\n    }\n    for(int i=0;i<=N;++i){\n      dp[i][i]=0;\n    }\n    for(int t=2;t<=N;++t){\n      for(int l=0;l<=N-t;++l){\n\tconst int r=l+t;\n\tdp[l][r]=max(dp[l+1][r],dp[l][r-1]);\n\tif(ok(l,l+1))dp[l][r]=max(dp[l+2][r]+2,dp[l][r]);\n\tif(ok(r-2,r-1))dp[l][r]=max(dp[l][r-2]+2,dp[l][r]);\n\tif(ok(l,r-1)){\n\t  if(dp[l+1][r-1]==(r-l-2)){\n\t    dp[l][r]=max(dp[l+1][r-1]+2,dp[l][r]);\n\t  }\n\t}\n      } \n    }\n\n    int ans=dp[0][N];\n    ans=max(0,ans)\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define IOS std::cin.tie(0),std::ios::sync_with_stdio(false)\n\nnamespace idaten {\n\n\tusing namespace std;\n\tusing ll = int_fast64_t;\n\tusing ull = uint_fast64_t;\n\tusing P = std::pair<int64_t, int64_t>;\n\ttemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\n\ttemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\n\ttemplate<class Type>struct is_vector : std::false_type {};\n\ttemplate<class ValueType, class Alloc>struct is_vector<std::vector<ValueType, Alloc>> : std::true_type {};\n\ttemplate <typename T> inline std::ostream& operator << (std::ostream& out, const std::vector<T>& v) {\n\t\tif (v.empty())return out;\n\t\tconstexpr bool is_vector_v = is_vector<T>::value;\n\t\tif (is_vector_v)for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \"\\n\" : \"\");\n\t\telse for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \" \" : \"\");\n\t\treturn out;\n\t}\n\tinline void put() {}\n\ttemplate<class T> inline void put(const T& first) { std::cout << first << \"\\n\"; }\n\ttemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first << \" \"; put(rest...); }\n\tinline void putn() {}\n\ttemplate<class T, class... N> inline void putn(const T& first, const N& ... rest) { std::cout << first << \"\\n\"; putn(rest...); }\n\n\tvoid solve() {\n\t\tIOS;\n\t\tint n;\n\t\tcin >> n;\n\t\twhile (n) {\n\t\t\tvector<int> a(n);\n\t\t\tREP(i, n) {\n\t\t\t\tcin >> a[i];\n\t\t\t}\n\t\t\tvector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n\t\t\tRREP(i, n + 1) {\n\t\t\t\tFOR(j, i, n + 1) {\n\t\t\t\t\tif (j - i >= 2) {\n\t\t\t\t\t\tif (dp[i + 1][j - 1] == j - i - 2) {\n\t\t\t\t\t\t\tif (abs(a[i] - a[j - 1]) <= 1) {\n\t\t\t\t\t\t\t\tdp[i][j] = j - i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tFOR(k, i, j+1) {\n\t\t\t\t\t\tchmax(tmp, dp[i][k] + dp[k][j]);\n\t\t\t\t\t}\n\t\t\t\t\tchmax(dp[i][j], tmp);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tput(dp[0][n]);\n\t\t\tcin >> n;\n\t\t}\n\t\t\n\t}\n} // namespace idaten\n\nint main() {\n\tidaten::solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 301\n\n\nbool solve(){\n  int n, w[SIZE];\n  bool dp[SIZE][SIZE];\n\n  scanf(\"%d\", &n);\n  if(n == 0) return 0;\n\n  for(int i=0;i<n;i++) scanf(\"%d\", w+i);\n  \n  memset(dp, 0, sizeof(dp));\n  \n  for(int i=0;i<n;i++) dp[i][i] = true;\n\n  for(int x=2;x<=n;x+=2){\n    for(int l=0;l+x<=n;l++){\n      int r = l + x;\n      \n      // if(l >= 2 && abs(w[l-2] - w[l-1]) <= 1) dp[l-2][r] = true;\n      // if(r <= n-2 && abs(w[r] - w[r+1]) <= 1) dp[l][r+2] = true;\n\n      if(abs(w[l] - w[r-1]) <= 1) dp[l][r] |= dp[l+1][r-1];\n\n      for(int i=l+1;i<r;i++){\n        dp[l][r] |= dp[l][i] && dp[i][r];\n      }\n    }\n  }\n\n  int dp2[SIZE] = {};\n  \n  for(int i=0;i<n;i++){\n    for(int j=i+2;j<=n;j++){\n      if(dp[i][j]) dp2[j] = max(dp2[j], dp2[i] + (j-i));\n    }\n    dp2[i+1] = max(dp2[i+1], dp2[i]);\n  }\n  \n  printf(\"%d\\n\", dp2[n]);\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\nconst int INF = 1e9;\ntypedef long long ll;\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    int dp[301][301]={};\n    int num[n];\n    REP(i,n){\n      cin>>num[i];\n      if(i!=0&&abs(num[i]-num[i-1])<2){\n\tdp[i-1][i]=2;\n      }\n    }\n    for(int i=2;i<n;i++){\n      for(int j=0;j<n-i;j++){\n\tfor(int k=0;k<i;k++){\n\t  dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n\t  if(dp[j+1][j+i-1]==i-1){\n\t    if(abs(num[j]-num[j+i])<2)\n\t      dp[j][j+i]=i+1;\n\t    else\n\t      dp[j][j+i]=max(i-1,dp[j][j+i]);\n\t  }\n\t}\n      }\n    }\n    cout<<dp[0][n-1]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst int INF = 1LL << 29;\n\nint main() {\n    int N, w[300];\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        for (int j = 0; j < N; ++j) cin >> w[j];\n\n        int dp[305][305];\n        for (int j = 0; j < N; ++j) {\n            fill(dp[j], dp[j]+N+1, 0);\n        }\n\n        for (int j = 0; j+1 < N; ++j) {\n            if (abs(w[j] - w[j+1]) <= 1) {\n                dp[j][j+2] = 2;\n            }\n        }\n\n        for (int d = 3; d <= N; ++d) {\n            for (int j = 0; j + d <= N; ++j) {\n                for (int k = 1; j+k < j+d; ++k) {\n                    dp[j][j+d] = max(dp[j][j+d], dp[j][j+k] + dp[j+k][j+d]);\n                }\n\n                if (dp[j+1][j+d-1] == d-2 && abs(w[j] - w[j+d-1]) <= 1) {\n                    dp[j][j+d] = d;\n                }\n            }\n        }\n\n        cout << dp[0][N] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n\nvoid solve(int n) {\n\tvi v(n, 0);\n\tvector<vector<bool>> dp(n + 1, vector<bool>(n, false));\n\trep(i, n) {\n\t\tcin >> v[i];\n\t}\n\tfor (int l = 2; l <= n; l += 2) {\n\t\tfor (int i = 0; i + l <= n; i++) {\n\t\t\tbool b = false;\n\t\t\tif (l != 2) {\n\t\t\t\tfor (int j = 2; j<l; j += 2) {\n\t\t\t\t\tif (dp[j][i] && dp[l - j][i + j])\n\t\t\t\t\t\tb = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dif = abs(v[i] - v[i + l - 1]);\n\t\t\tif (dif <= 1&&(l==2?1:dp[l-2][i+1]))b = true;\n\t\t\tif (b)dp[l][i] = true;\n\t\t\t//cout << l << \" \" << i << \" \" << dp[l][i] << endl;\n\t\t}\n\t}\n\tint pos = 0;\n\tqueue<pii> q;\n\tq.push({ 0,0 });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tif (p.fs == n) {\n\t\t\tcout << n-p.sc << endl;\n\t\t\treturn;\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (dp[i][p.fs])q.push({ p.fs+i,p.sc});\n\t\t}\n\t\tq.push({ p.fs+1 ,p.sc + 1 });\n\t}\n\n}\n\nint main(void) {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tsolve(n);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nint n;\nint w[333];\nint dp[333][333];\n\nint rec(int le, int ri) {\n    if (~dp[le][ri]) return dp[le][ri];\n    if (le == ri) {\n        return dp[le][ri] = 0;\n    }\n    if (ri - le + 1 == 2) {\n        return dp[le][ri] = (abs(w[le] - w[ri]) <= 1 ? 2 : 0);\n    }\n    if (abs(w[le] - w[ri]) <= 1) {\n        if (ri - 1 >= le + 1) {\n            int t = (ri - 1) - (le + 1) + 1;\n            dp[le][ri] = (rec(le + 1, ri - 1) == t ? rec(le + 1, ri - 1) + 2 : dp[le][ri]);\n        }\n    }\n    for (int md = le + 1; md <= ri; md++) {\n        dp[le][ri] = max(dp[le][ri], rec(le, md - 1) + rec(md, ri));\n    }\n    return dp[le][ri];\n}\n\nint main() {\n    while (cin >> n && n) {\n        for (int i = 0; i < n; i++) cin >> w[i];\n        for (int i = 0; i < 333; i++) for (int j = 0; j < 333; j++) {\n            dp[i][j] = -1;\n        }\n        int ans = max(0, rec(0, n - 1));\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\nint main()\n{\n  int n;cin>>n;\n  while(n!=0)\n  {\n    int i,j,k;\n    vector<int> w(n);\n    rep(i,n)cin>>w[i];\n    vector<vector<int>> dp(n,vector<int>(n,0));\n    rep(i,n-1)\n    {\n      if(abs(w[i]-w[i+1])<=1)dp[i][i+1]=2;\n    }\n    for(i=2;i<n;i++)\n    {\n      rep(j,n-i)\n      {\n        for(k=0;k<i;k++)\n        {\n          dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n        }\n        if(dp[j+1][j+i-1]==i-1&&abs(w[j]-w[j+i])<=1)\n        {\n          dp[j][j+i]=i+1;\n        }\n      }\n    }\n    cout<<dp[0][n-1]<<endl;\n    cin>>n;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) FOR((i),0,(n))\n\ntypedef long long ll;\n\nconst int INF=1e9+7;\n\nconst int MAX_N=305;\n\nint data[MAX_N];\n\nint take[MAX_N][MAX_N];\nint dp[MAX_N][MAX_N];\n\nint abs(int x){\n\tif(x>0)return x;\n\telse return -1*x;\n}\n\nint dfs(int i,int j){\n\tif(take[i][j]!=-1)return take[i][j];\n\ttake[i][j]=0;\n\tif(i==j)return 0;\n\telse if(i+1==j){\n\t\tif(abs(data[i]-data[j])<=1)take[i][j]=1;\n\t\telse take[i][j]=0;\n\t}\n\telse{\n\t\tif(dfs(i+1,j-1)==1 && abs(data[i]-data[j])<=1)take[i][j]=1;\n\t\tfor(int k=i;k<j;k++)if(dfs(i,k)==1 &&dfs(k+1,j)==1)take[i][j]=1;\n\t}\n\treturn take[i][j];\n}\n\nint solve(int i,int j){\n\tif(dp[i][j]!=-1)return dp[i][j];\n\tdp[i][j]=0;\n\tif(dfs(i,j)==1){\n\t\tdp[i][j]=j-i+1;\n\t}\n\tfor(int k=i;k<j;k++)dp[i][j]=max(dp[i][j],solve(i,k)+solve(k+1,j));\n\treturn dp[i][j];\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n && n){\n\t\trep(i,n+1){\n\t\t\tfill(dp[i],dp[i]+MAX_N,-1);\n\t\t\tfill(take[i],take[i]+MAX_N,-1);\n\t\t}\n\t\trep(i,n)cin>>data[i+1];\n\t\tcout<<solve(1,n)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i=0; i<(n); ++i)\n#define repr(i, a, b) for (int i=a; i<(b); ++i)\n#define reprev(i, n) for (int i=n-1; i>=0; --i)\n#define reprrev(i, a, b) for (int i=b-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint main() {\n    cout << fixed << setprecision(10);\n    \n    int n;\n    while(cin >> n) {\n        if (n == 0) break;\n        vector<int> w(n);\n        rep(i, n) cin >> w[i];\n\n        vector<vector<int>> dp(n, vector<int>(n));\n\n        repr(b, 2, n+1) {\n            rep(i, n-b+1) {\n                int j = i + b - 1;\n\n                if (dp[i+1][j-1] == b-2 && abs(w[i] - w[j]) < 2) {\n                    dp[i][j] = b;\n                } else {\n                    repr(k, i, j) {\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n                    }\n                }\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n/*\n4\n1 2 3 4\n4\n1 2 3 1\n5\n5 1 2 3 6\n14\n8 7 1 4 3 5 4 1 6 8 10 4 6 5\n5\n1 3 5 1 3\n0\n*/\n"
  },
  {
    "language": "C++",
    "code": "#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(v) v.begin(), v.end()\ntypedef long long ll;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin>>n){\n    if(n==0) return 0;\n    \n    vector<int> A(n+1);\n    rep(i,n) cin>>A[i+1];\n    \n    int dp[310][310];\n    rep(i,310){\n      rep(j,310) dp[i][j]=0;\n    }\n    \n    for(int i=1;i<n;i++){\n      if(abs(A[i]-A[i+1])<=1){\n        dp[i][i+1]=2;\n      }\n    }\n    \n    for(int l=3;l<=n;l++){\n      for(int i=1;i+l-1<=n;i++){\n        int j=i+l-1;\n        if(dp[i+1][j-1]==j-i-1 && abs(A[i]-A[j])<=1) dp[i][j]=j-i+1;\n        for(int k=i;k<j;k++){\n          dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);\n        }\n      }\n    }\n    cout<<dp[1][n]<<endl;\n  }\n    \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(ll (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nint main() {\n    while(true){\n        ll n;\n        cin>>n;\n        if(n==0)break;\n        vector<ll> w(n);\n        vector<vector<ll>> dp(n,vector<ll>(n+1,0));\n        rep(i,n)cin>>w[i];\n        for(ll d=2;d<=n;d++){\n            for(ll l=0;l<n;l++){\n                ll r=l+d;\n                if(r>n)break;\n                if(abs(w[l]-w[r-1]) <= 1 && dp[l+1][r-1] == d-2){\n                    dp[l][r]=d;\n                }\n                for(ll m=l+1;m<r;m++){\n                    dp[l][r] = max(dp[l][r],dp[l][m]+dp[m][r]);\n                }\n            }\n        }\n        cout<<dp[0][n]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nint n;\nint w[MAX];\nint done[305][305];\nint dp[305][305];\n\nvoid print_dp() {\n    rep(i, n) {\n        rep(j, n+1) {\n            cout << setw(3) << dp[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint ans(int l, int r) {\n    if (done[l][r]) {\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    if (r - l == 0) return 0;\n    if (r - l == 1) return 0; \n    if (l > r) return -INF;\n    if (r > n) return -INF;\n    if (r - l == 2) {\n        done[l][r] = true;\n        int res = 0;\n        if (abs(w[l] - w[l+1]) < 2) res = 2;\n        else res = 0;\n        dp[l][r] = res;\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    int res = 0;\n    rep(width, n) {\n        rep(width2, n) {\n            if (l+width+width2 > r) break;\n            rep2(i, l, r) {\n                if (i+width+width2 > n) break;\n                if (i+width+width2*2 > r) break;\n                if (i+width2 == l && i+width+width2 == r) continue;\n                if (i+width+width2*2 == l) continue;\n                int tmp = \n                ans(l, i) \n                + ans(i+width2, i+width+width2) \n                + ans(i+width+width2*2, r);\n                if (ans(i+width2, i+width+width2) == width) {\n                    rep(j, width2) {\n                        if (abs(w[i+width2-1-j] - w[i+width+width2+j]) < 2) {\n                            tmp += 2;\n                        }\n                        else break;\n                    }\n                }\n                res = max(res, tmp);\n            }\n        }\n    }\n\n\n    done[l][r] = true;\n    dp[l][r] = res;\n    // if (test) {\n    //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n    // }\n    return dp[l][r];\n}\n\nvoid solve() {\n    rep(i, 305) rep(j, 305) done[i][j] = false;\n    rep(i, 305) rep(j, 305) dp[i][j] = 0;\n    cin >> n;\n    if (n == 0) exit(0);\n    rep(i, n) cin >> w[i];\n    cout << ans(0, n) << endl;\n    // if (test) print_dp();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include<numeric>\n#include<cmath>\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define INF 2e9\n#define ALL(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n/*int darma_max(vector<vector<int> > dp, int ){\n    \n\n}*/\n\nint main(){\n    //cin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\t//cout << fixed << setprecision(15);\n    vector<int> ans;\n    while(true){\n        int N; cin >> N;\n        //ans.resize(N);\n        if(N == 0){\n            REP(i,ans.size()){\n                cout << ans[i] << endl;\n            }\n            return 0;\n        }\n        else{\n            vector<vector<int> >dp(N+1,vector<int>(N+1,0));\n            vector<int> darma(N);\n            vector<bool> flag(N,false);\n            //flag.resize(N,false);\n            /*REP(i,N+1){\n                dp[i][i] = true; //半開区間？\n            }*/\n            REP(i,N){cin >> darma[i];}\n\n            for(int w = 2; w <= N; w++){\n                for(int left = 0; left + w <= N; left++){\n                    int right = left + w;\n                    if((dp[left+1][right-1] == w-2) && (abs(darma[left] - darma[right-1]) <= 1)){\n                        dp[left][right] = w;\n                        //flag[left] = true; flag[right-1] = true;\n                    }\n                    else{\n                        for(int mid = left + 1; mid < right; mid++){\n                            /*if(dp[left][mid] && dp[mid][right]){\n                                dp[left][right] = true;\n                                break;\n                            }*/\n                            dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid][right]);\n                        }\n                    }\n    \n                }\n            }\n            //cout << dp[3][7] << endl;\n            /*REP(i,N){\n                cout << flag[i] << endl;\n            }*/\n            /*int maxi = 0;\n            REP(i,N-1){\n                FOR(k,i,N){\n                    if(dp[i][k]){\n                        maxi = max(maxi,k-i);\n                    }\n                }\n            }*/\n            /*int ans_now = 0;\n            int now = 0;\n            while(now < N-1){\n                while(!flag[now]){\n                    now++;\n                }\n                for(int next = N; now < next; next--){ //バグりポイント flag[i] = trueだけの情報では、それが前に繋がっているのか後ろに繋がっているかわからないから、nextの範囲は指定しないといけない。\n                    if(dp[now][next]){\n                        ans_now += (next-now);\n                        now = next;\n                    }\n                }\n            }*/\n            ans.push_back(dp[0][N]); \n            \n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool solve(){\n\tint n;\n\tcin >> n;\n\tif(n == 0)return false;\n\tvector<int> x(n);\n\tfor(int i=0;i<n;i++)\n\t\tcin >> x[i];\n\n\tvector<vector<int>> dp(n+1,vector<int>(n+1));\n\tfor(int i=0;i<n-1;i++){\n\t\tif( abs( x[i] - x[i+1] ) <= 1 )\n\t\t\tdp[i][i+1] = 2;\n\t}\n\n\tfor(int d=1;d<n;d++){\n\t\tfor(int l=0;l<n;l++){\n\t\t\tif( l + d >= n )continue;\n\t\t\tfor(int r=l;r<l+d;r++){\n\t\t\t\t// cout << l << \" \" << r << \" \" << r + 1 << \" \" << l+d << endl;\n\t\t\t\tdp[l][l+d] = max(dp[l][l+d], dp[l][r] + dp[r+1][l+d]);\n\t\t\t}\n\t\t\tif( l - 1 >= 0 && l + d + 1 < n){\n\t\t\t\tif( dp[l][l+d] == d + 1 && abs( x[l-1] - x[l+d+1] ) <= 1 ){\n\t\t\t\t\tdp[l-1][l+d+1] = max(dp[l-1][l+d+1] ,dp[l][l+d] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cout << endl;\n\t}\n\tcout << dp[0][n-1] << endl;\n\treturn true;\n}\n\nint main(void){\n\n\twhile(solve()){}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\n\nint w[305], dp[305][305];\n\nint main() {\n\n    int n;\n    while (cin >> n, n) {\n\n        rep(i, n) cin >> w[i];\n        rep(i, 305) rep(j, 305) dp[i][j] = 0;\n\n        for (int ww=2; ww<=n; ++ww) {\n            for (int i=0; i<n; ++i) {\n                int j = i + ww - 1; // i - j ?????????\n                if (j >= n) continue;\n\n                if (dp[i+1][j-1] == ww-2 and abs(w[i] - w[j]) <= 1) dp[i][j] = ww;\n                for (int k=i; k<j; ++k) {\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n                }\n            }\n        }\n\n        cout << dp[0][n-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <string>\n#define REP(i,a,b) for (int i = a; i < (b); i++)\n#define sz(t) int(t.size())\n#define INF 1000000000\nconst int DIV = 1000000000 + 7;\nusing namespace std;\ntypedef long long ll;\n\n#define MOD 10007\n\nint main(void) {\n    int n;\n    for (;;) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> W(n + 1);\n        REP(i, 0, n) {\n            cin >> W[i];\n        }\n        vector<vector<int> > dp(n + 1, vector<int>(n + 1, 0));\n        REP(w, 2, n + 1) {\n            REP(l, 0, n) {\n                int r = l + w;\n                if (r > n) {\n                    continue;\n                }\n                if (dp[l + 1][r - 1] == w - 2 && abs(W[l] - W[r - 1]) <= 1) {\n                    dp[l][r] = dp[l + 1][r - 1] + 2;\n                }\n                REP(mid, l, r + 1) {\n                    dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid][r]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint DFS(vector<int> &w, vector<bool> f, int n) {\n  int max = 0;\n  for (int i = 0; i < n; i++) {\n    if (f[i]) {\n      for (int j = i + 1; j < n; j++) {\n\tif (f[j]) {\n\t  if (abs(w[i] - w[j]) <= 1) {\n\t    f[i] = f[j] = false;\n\t    int ret = DFS(w, f, n) + 2;\n\t    f[i] = f[j] = true;\n\t    if (ret > max) {\n\t      max = ret;\n\t    }\n\t  }\n\t  break;\n\t}\n      }\n    }\n  }\n  return max;\n}\n\nint main() {\n  vector<int> w(300);\n  vector<bool> f(300);\n\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0) {\n      break;\n    }\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n      f[i] = true;\n    }\n\n    cout << DFS(w, f, n) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n#define DUMP(x) cout << #x << \": \" << x << endl\n\nint n;\nint memo[310][310] = { false };\nvector<int> w(n);\n\nint rec(int l, int r) {\n  if (r - l == 0) {\n    return memo[l][r] = 2;\n  }\n  if (r - l == 1) {\n    return memo[l][r] = 1;\n  }\n  \n  if (r - l  - 1 == 1) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      return memo[l][r] = 2;\n    }\n  }\n  if (memo[l][r]) {\n    return memo[l][r];\n  }\n\n  for (int t = l + 1; t < r; t++) {\n    int temp  = rec(l, t);\n    int temp2 = rec(t, r);\n    int temp3 = rec(l + 1, t);\n    int temp4 = rec(t, r - 1);\n    \n    if (temp == 2 && temp2 == 2) {\n      return memo[l][r] = 2;\n    }\n    if (abs(w[l] - w[r - 1]) <= 1 && temp3 == 2 && temp4 == 2) {\n      return memo[l][r] = 2;\n    }\n  }\n\n  return memo[l][r] = 1;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    w.clear();\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n    memset(memo, 0, sizeof(memo));\n\n    //    cerr << \" \" << rec(0, n) << endl;\n    rec(0, n);\n    int dp[310] = { 0 };\n    dp[0] = 0;\n\n    for (int r = 0; r <= n; r++) {\n      dp[r] = dp[r - 1];\n      for (int l = 0; l < r; l++) {\n        if (memo[l][r] == 2) {\n          dp[r] = max(dp[r], dp[l] + (r - l));\n        }\n      }\n    }\n    \n\n    cout << dp[n] << endl;\n\n  }\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n#include <queue>\n#define PIE 3.14159265358979\n#define N_MAX 305\n#define rep(i,n) for(int i = 0;i < (n);i++)\nusing namespace std;\n\nint n;\nint a[N_MAX];\nint dp[N_MAX][N_MAX];\n\nint main(){\n    while(cin>>n,n!=0){\n        rep(i,n){\n            cin>>a[i];\n        }\n        rep(i,n+1){\n            rep(j,n+1){\n                dp[i][j]=0;\n            }\n        }\n        if(n<2){\n            cout<<0<<endl;\n            continue;\n        }\n        int num = 2;\n        while(num<=n){\n            int left = 0;\n            while(left+num<=n){\n                if(dp[left+1][left+num-1]==num-2&&abs(a[left]-a[left+num-1])<=1)\n                    dp[left][left+num]=num;\n                int div=1;\n                while(div<num){\n                    dp[left][left+num]=max(dp[left][left+num],dp[left][left+div]+dp[left+div][left+num]);\n                    div++;\n                }\n                left++;\n            }\n            num++;\n        }\n        int ans = 0;\n        rep(i,n+1){\n            rep(j,n+1){\n                ans=max(ans,dp[i][j]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int>as;\nbool ok(int a,int b){\n  return abs(as[a]-as[b])<=1;\n}\n\nint main() {\n  while(1){\n    \n    int N;cin>>N;\n    if(!N)break;\n    as.resize(N);\n    vector<vector<int>>dp(N+1,vector<int>(N+1,-100000));\n    for(int i=0;i<N;++i){\n      int a;cin>>a;as[i]=a;\n    }\n    for(int i=0;i<=N;++i){\n      dp[i][i]=0;\n    }\n    for(int t=2;t<=N;++t){\n      for(int l=0;l<=N-t;++l){\n\tconst int r=l+t;\n\tdp[l][r]=max(dp[l+1][r],dp[l][r-1]);\n\tif(ok(l,l+1))dp[l][r]=max(dp[l+2][r]+2,dp[l][r]);\n\tif(ok(r-2,r-1))dp[l][r]=max(dp[l][r-2]+2,dp[l][r]);\n\tif(ok(l,r-1)){\n\t  if(dp[l+1][r-1]==(r-l-2)){\n\t    dp[l][r]=max(dp[l+1][r-1]+2,dp[l][r]);\n\t  }\n\t}\n      } \n    }\n\n    int ans=dp[0][N];\n    ans=max(0,ans)\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nint dp[301][301];\nint A[300];\n\nint main() {\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (N == 0)return 0;\n\t\t\n\t\tfor (int i = 0; i <= 300; i++)for (int j = 0; j <= 300; j++)dp[i][j] = 0;\n\n\t\tfor (int i = 0; i < N; i++)cin >> A[i];\n\n\t\tfor (int W = 2; W <= N; W++) {\n\t\t\tfor (int i = 0;; i++) {\n\t\t\t\tint j = i + W - 1;\n\t\t\t\tif (j >= N)break;\n\t\t\t\tif (dp[i + 1][j - 1] == W - 2 && abs(A[i] - A[j]) <= 1)dp[i][j] = W;\n\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][N - 1] << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ICPC2016 domestic D ??????????????¨???\n//dp[l][r] := //??????[l, r)??§????????§?????¨???????????¢????????°???????????????\n//?????¬???????????????????????????????????°??§????????§?????????w[l]??¨w[r - 1]??????????°??????????????????¨?¶??????§????????¨???????????????????£??????\\????????????\n//????£?30?????????????????°30????????????\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\nint dp[301][301];\nint w[301];\nint calc(int l, int r) {//??????[l, r)??§????????§???\n    int& res = dp[l][r];\n    if(dp[l][r] != -1) return res;\n    res = 0;\n    if(r - l <= 1) return res;\n    if(r - l == 2)\n      return abs(w[l] - w[l + 1]) <= 1 ? res = 2 : res;\n    //?????????\n    REP(mid, l + 1, r - 1)\n      res = max(res, calc(l, mid) + calc(mid, r));\n    //??????????????¨?¶??????§??????????????§??????\n    int temp = calc(l + 1, r - 1);\n    if(temp == r - l - 2 && abs(w[l] - w[r - 1]) <= 1) temp += 2;\n    res = max(res, temp);\n    return res;\n}\nint main() {\n    int N;\n    while(~scanf(\"%d\", &N) && N) {\n        memset(dp, -1, sizeof(dp));\n        memset(w, 0, sizeof(w));\n        rep(i, N) scanf(\"%d\", w + i);\n        printf(\"%d\\n\", calc(0, N));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<int> w(n), sum(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t\tsum[i] = i ? sum[i - 1] + w[i] : w[i];\n\t\t}\n\t\tvector<vector<int>> dp(n + 1, vector<int>(n + 1));\n\t\tfor (int i = 0; i + 1 <= n; i++) {\n\t\t\tdp[i][i + 1] = 0;\n\t\t}\n\t\tfor (int i = 0; i + 2 <= n; i++) {\n\t\t\tdp[i][i + 2] = abs(w[i] - w[i + 1]) <= 1 ? 2 : 0;\n\t\t}\n\t\tfor (int k = 3; k <= n; k++) {\n\t\t\tfor (int i = 0; i + k <= n; i++) {\n\t\t\t\tfor (int j = i + 1; j + 1 <= i + k; j++) {\n\t\t\t\t\tif (k % 2 == 0 && dp[i + 1][i + k - 1] == k - 2 && abs(w[i + k - 1] - w[i]) <= 1) dp[i][i + k] = dp[i + 1][i + k - 1] + 2;\n\t\t\t\t\telse dp[i][i + k] = max(dp[i][i + k], dp[i][j] + dp[j][i + k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n    int n;\n    cin >> n;\n    while (n != 0) {\n            \n        vector<int> w(n);\n        rep(i, n) cin >> w[i];\n        // dp[i][j] : iからj-1までのブロックから取れる最大値\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        for (int k = 2; k <= n; k++) {\n            for (int i = 0; i + k <= n; i++) {\n                if (dp[i + 1][i + k - 1] == k - 2 && abs(w[i] - w[i + k - 1]) < 2) {\n                    dp[i][i + k] = k;\n                }\n                for (int j = i; j <= i + k; j++) {\n                    dp[i][i + k] = max(dp[i][i + k], dp[i][j] + dp[j][i + k]);\n                }\n            }\n        }\n        cout << dp[0][n] << \"\\n\";\n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  unsigned int N = 0;\n  vector<int> num;\n  int w = 0;\n  vector<int> answer;\n\n  cin >> N;\n  while(N) {\n    for(unsigned int i = 0; i < N; i++) {\n      cin >> w;\n      num.push_back(w);\n    }\n\n    while(true) {\n      unsigned int i;\n      for(i = num.size()-1; i > 0; i--)\n\tif(num.at(i)-num.at(i-1) >= -1 && num.at(i)-num.at(i-1) <= 1)\n\t  break;\n\n      if(i == 0)\n\tbreak;\n      num.erase(num.begin()+i);\n      num.erase(num.begin()+i-1);\n      \n      if(num.empty())\n\tbreak;\n    }\n\n    answer.push_back(N-num.size());\n\n    num.clear();\n\n    cin >> N;\n  }\n\n  for(unsigned int j = 0; j < answer.size(); j++)\n    cout << answer.at(j) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define invrepr(i,a,b) for(int i=b-1;i>=a;i--)\n#define invrep(i,n) invrepr(i,0,n)\n#define repitr(itr,a) for(auto itr=a.begin();itr!=a.end();++itr)\nconst int MOD=1e9+7;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    while (1) {\n        int n;\n        cin >> n;\n        if (n==0) break;\n        vector<int> a(n);\n        rep(i,n) cin >> a[i];\n        vector<vector<int>> dp(n,vector<int>(n));\n        repr(i,1,n) {\n            invrep(j,i) {\n                if (dp[j+1][i-1]==(i-1)-(j+1)+1 && abs(a[j]-a[i])<=1) dp[j][i]=i-j+1;\n                repr(k,j,i) {\n                    dp[j][i]=max(dp[j][i],dp[j][k]+dp[k+1][i]);\n                }\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    \n\n    return 0;   \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nint blocks[300];\nint8_t strike_range[300][300];\nint score_in_range[300][300];\n\nconst int8_t STRIKE_RANGE_UNDEF = 0;\nconst int8_t STRIKE_RANGE_NO = 1;\nconst int8_t STRIKE_RANGE_YES = 2;\n\nbool can_strike(int x, int y) {\n\treturn std::abs(blocks[x] - blocks[y]) <= 1;\n}\n\nint8_t search_range(int start, int end) {\n\tif (start >= end) return STRIKE_RANGE_UNDEF;\n\tif ((end - start + 1) % 2 != 0) return STRIKE_RANGE_NO;\n\n\tint8_t* p = &strike_range[start][end];\n\tif (*p != STRIKE_RANGE_UNDEF) return *p;\n\n\tif (start + 1 == end)\n\t\treturn *p = can_strike(start, end) ? STRIKE_RANGE_YES : STRIKE_RANGE_NO;\n\n\tfor (int i = start + 1; i < end - 1; i++) {\n\t\tif (search_range(start, i) == STRIKE_RANGE_YES\n\t\t\t&& search_range(i + 1, end) == STRIKE_RANGE_YES)\n\t\t{\n\t\t\treturn *p = STRIKE_RANGE_YES;\n\t\t}\n\t}\n\n\tauto result = search_range(start + 1, end - 1);\n\treturn *p = result == STRIKE_RANGE_YES && can_strike(start, end)\n\t\t? STRIKE_RANGE_YES : STRIKE_RANGE_NO;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\tif (n == 0) return 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint w;\n\t\t\tstd::cin >> w;\n\t\t\tblocks[i] = w;\n\t\t}\n\n\t\tstd::memset(strike_range, 0, sizeof(strike_range));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tscore_in_range[i][j] = search_range(i, j) == STRIKE_RANGE_YES ? j - i + 1 : 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\tscore_in_range[i][j] = std::max(\n\t\t\t\t\t\tscore_in_range[i][j],\n\t\t\t\t\t\tscore_in_range[i][k] + score_in_range[k + 1][j]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << score_in_range[0][n - 1] << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\t\n\tint n;\n\tint w[500];\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> w[i];\n\t\t}\n\t\t\n\t\tint DP[500][500] = {};\n\t\t\n\t\tfor(int i = 2; i <= n; i += 2){\n\t\t\tfor(int j = 0; j <= n - i; j++){\n\t\t\t\tDP[j][j + i - 1] = DP[j + 1][j + i - 2];\n\t\t\t\tif((w[j] - w[j + i - 1]) * (w[j] - w[j + i - 1]) <= 1 && DP[j + 1][j + i - 2] == (i - 2) / 2){\n\t\t\t\t\tDP[j][j + i - 1]++;\n\t\t\t\t}\n\t\t\t\tfor(int k = j + 1; k < j + i - 1; k += 2){\n\t\t\t\t\tDP[j][j + i - 1] = max(DP[j][j + i - 1], DP[j][k] + DP[k + 1][j + i - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(n % 2 == 1){\n\t\t\tcout << max(DP[0][n - 2], DP[1][n - 1]) * 2 << endl;\n\t\t}else{\n\t\t\tcout << DP[0][n - 1] * 2 << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        vector<int> w(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> w[i];\n        }\n        vector<vector<int>> dp(n, vector<int>(n + 1, 0));\n        for (int i = 2; i <= n; ++i) {\n            for (int j = 0; i + j <= n; ++j) {\n                if (dp[j + 1][i - 2] == i - 2 && abs(w[j] - w[i + j - 1]) < 2) {\n                    dp[j][i] = i;\n                    continue;\n                }\n                for (int k = 1; k < i; ++k) {\n                    dp[j][i] = max(dp[j][i], dp[j][k] + dp[j + k][i - k]);\n                }\n            }\n        }\n        cout << dp[0][n] << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint a1 = j, a2 = i + j - 1; if (a2 >= n)continue;\n\t\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\t\tif (a1 > 1 && abs(a[a1 - 1] - a[a1 - 2]) <= 1)dp[a1 - 2][a2] = 1;\n\t\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tint a1 = j, a3 = i + j; if (a3 >= n)continue;\n\t\t\t\tfor (int k = a1 + 1; k <= a3; k++) {\n\t\t\t\t\tint a2 = k;\n\t\t\t\t\tdp[a1][a3] = max(dp[a1][a3], dp[a1][a2 - 1] + dp[a2][a3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint SolveDaruma(const int n, const vector<int> &w) {\n    vector<vector<int>> s(n, vector<int>(n));\n\n    for (int l = 0; l + 1 < n; ++l)\n        if (abs(w[l] - w[l + 1]) <= 1)\n            s[l][l + 1] = 2;\n\n    for (int i = 3; i <= n; ++i)\n        for (int l = 0; l + i <= n; ++l) {\n            const int r = l + i - 1;\n\n            if (abs(w[l] - w[r]) <= 1 && s[l + 1][r - 1] == i - 2)\n                s[l][r] = i;\n\n            for (int m = l + 1; m <= r; ++m)\n                s[l][r] = max(s[l][r], s[l][m - 1] + s[m][r]);\n        }\n\n    return s[0][n - 1];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n\n    while (cin >> n, n) {\n        vector<int> w(n);\n        for (auto &x : w) cin >> x;\n\n        cout << SolveDaruma(n, w) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  unsigned int N = 0;\n  vector<int> num;\n  int w = 0;\n\n  cin >> N;\n  while(N != 0) {\n    for(unsigned int i = 0; i < N; i++) {\n      cin >> w;\n      num.push_back(w);\n    }\n\n    while(true) {\n      unsigned int i;\n      for(i = num.size()-1; i > 0; i--)\n\tif(num.at(i)-num.at(i-1) >= -1 && num.at(i)-num.at(i-1) <= 1)\n\t  break;\n\n      if(i == 0)\n\tbreak;\n      num.erase(num.begin()+i);\n      num.erase(num.begin()+i-1);\n      \n      if(num.empty())\n\tbreak;\n    }\n\n    cout << N-num.size() << endl;\n\n    num.clear();\n\n    cin >> N;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15);\n  }\n} initializer;\n\ntemplate<typename T> istream& operator>>(istream &s, vector<T> &v) {\n  for (T &t : v) s >> t;\n  return s;\n}\n\ntemplate<typename T> ostream& operator<<(ostream &s, const vector<T> &v) {\n  for (const T &t : v) s << t << endl;\n  return s;\n}\n\ntemplate<typename T> T min(vector<T>& v) {return *min_element(v.begin(), v.end());}\n\ntemplate<typename T> T max(vector<T>& v) {return *max_element(v.begin(), v.end());}\n\ntemplate<typename T> int min_element(vector<T>& v) {return min_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> int max_element(vector<T>& v) {return max_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> void sort(vector<T>& v) {sort(v.begin(), v.end());}\n\ntemplate<typename T, typename Function> void sort(vector<T>& v, Function func) {sort(v.begin(), v.end(), func);}\n\ntemplate<typename T> void rsort(vector<T>& v) {sort(v.rbegin(), v.rend());}\n\ntemplate<typename T> void reverse(vector<T>& v) {reverse(v.begin(), v.end());}\n\ntemplate<typename T> void unique(vector<T>& v) {v.erase(unique(v.begin(), v.end()), v.end());}\n\ntemplate<typename T> void nth_element(vector<T>& v, int n) {nth_element(v.begin(), v.begin() + n, v.end());}\n\ntemplate<typename T> bool next_permutation(vector<T>& v) {return next_permutation(v.begin(), v.end());}\n\ntemplate<typename T> int find(vector<T>& v, T t) {return find(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int in(vector<T> v, T t) {return find(v, t) != int(v.size());}\n\ntemplate<typename T> int lower_bound(vector<T>& v, T t) {return lower_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int upper_bound(vector<T>& v, T t) {return upper_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> T accumulate(const vector<T>& v, function<T(T, T)> func = plus<T>()) {return accumulate(v.begin(), v.end(), T(), func);}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v) {adjacent_difference(v.begin(), v.end(), v.begin());}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v, vector<T>& u) {adjacent_difference(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> void partial_sum(vector<T>& v, vector<T>& u) {partial_sum(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> T inner_product(vector<T>& v, vector<T>& u) {return inner_product(v.begin(), v.end(), u.begin(), T(0));}\n\ntemplate<typename T> int count(const vector<T>& v, T t) {return count(v.begin(), v.end(), t);}\n\ntemplate<typename T, typename Function> int count_if(const vector<T>& v, Function func) {return count_if(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> void remove_if(vector<T>& v, Function func) {v.erase(remove_if(v.begin(), v.end(), func), v.end());}\n\ntemplate<typename T, typename Function> bool all_of(vector<T> v, Function func) {return all_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool any_of(vector<T> v, Function func) {return any_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool none_of(vector<T> v, Function func) {return none_of(v.begin(), v.end(), func);}\n\ntemplate<typename T> vector<T> subvector(vector<T>& v, int a, int b) {return vector<T>(v.begin() + a, v.begin() + b);}\n\ntemplate<typename T> int kinds(const vector<T>& v) {return set<T>(v.begin(), v.end()).size();}\n\ntemplate<typename T> void iota(vector<T>& v, T t = 0) {iota(v.begin(), v.end(), t);}\n\ntemplate<typename T> bool is_sorted(const vector<T>& v) {return is_sorted(v.begin(), v.end());}\n\nclass Solver {\nprivate:\n  vector<int> w;\n  map<pair<int, int>, int> mem;\n\npublic:\n  Solver(const vector<int>& w) : w(w) {}\n\n  int solve(int a, int b) {\n    if (b - a < 2) return 0;\n    if (b - a == 2 && abs(w[a] - w[a + 1]) <= 1) return 2;\n    if (mem.count(make_pair(a, b))) return mem[make_pair(a, b)];\n    int z = solve(a + 1, b - 1);\n    if (z == b - a - 2 && abs(w[a] - w[b - 1]) <= 1) z += 2;\n    for (int i = a + 1; i < b; ++i) {\n      int x = solve(a, i) + solve(i, b);\n      if (x > z) z = x;\n    }\n    return mem[make_pair(a, b)] = z;\n  }\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<int> w(n);\n    cin >> w;\n    Solver solver(w);\n    cout << solver.solve(0, n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n#define EQ(a,b) (abs(a - b) < 1e-10)\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<LL> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<bool> VB;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\nint n;\nvector<int> w;\ntypedef bitset<301> bit;\nstruct Comp {\n\tbool operator() (const bit &a,const bit &b) {\n\t\tfor (int i = 300-1; i >= 0; i--) {\n        \tif (a[i] ^ b[i]) return b[i];\n    \t}\n    \treturn false;\n\t}\n};\nmap<bit,int,Comp> memo;\nint dfs(bit state) {\n\tif (IN(state,memo)) return memo[state];\n\tint num = 0,fi;\n\tREP(i,n-1) {\n\t\tif ((!state[i])) {\n\t\t\tfi = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tFOR(i,fi+1,n) {\n\t\tif (!state[i]){\n\t\t\tif (abs(w[i] - w[fi]) <= 1) {\n\t\t\t\tbit next = state;\n\t\t\t\tnext.set(i);next.set(fi);\n\t\t\t\tnum = max(dfs(next)+2,num);\n\t\t\t}\n\t\t\tfi = i;\n\t\t}\n\t}\n\treturn memo[state] = num;\n}\n\nint main(void) {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tw.resize(n);\n\t\tREP(i,n) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << dfs(bit(0)) << endl;\n\t\tmemo.clear();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nint main(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<n;i+=2)\n      for(int j=0;j<n-i;j++){\n        for(int k=1;k<=i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=i+1;\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nclass Solve {\npublic:\n    int N;\n    vector<int> w;\n\n    void input() {\n        w.resize(N);\n        rep(i, 0, N) cin >> w[i];\n    }\n\n    int dp[305][305];\n\n    int rec(int l, int r) {\n        if (l >= r) return 0;\n        if (dp[l][r] != -1) return dp[l][r];\n\n        if (l + 1 == r) {\n            return dp[l][r] = 2 * (abs(w[l] - w[r]) <= 1);\n        }\n        int ret = 0;\n        for (int k = l; k < r; ++k) {\n            chmax(ret, rec(l, k) + rec(k + 1, r));\n        }\n        if (rec(l + 1, r - 1) == r - l - 1 && abs(w[l] - w[r]) <= 1) {\n            chmax(ret, rec(l + 1, r - 1) + 2);\n        }\n\n        return dp[l][r] = ret;\n    }\n\n    void solve(int n) {\n        N = n;\n        input();\n        memset(dp, -1, sizeof(dp));\n\n        int ans = rec(0, n - 1);\n        cout << ans << endl;\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int tmp;\n        cin >> tmp;\n        if (tmp == 0) break;\n        Solve().solve(tmp);\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n#define DUMP(x) cout << #x << \": \" << x << endl\n\nint n;\nint memo[310][310] = { false };\nint dp[310] = { 0 };\n\nvector<int> w(n);\n\nint rec(int l, int r) {\n  if (r - l == 0) {\n    return memo[l][r] = 2;\n  }\n  if (r - l == 1) {\n    return memo[l][r] = 1;\n  }\n  \n  if (r - l  - 1 == 1) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      return memo[l][r] = 2;\n    }\n  }\n  if (memo[l][r]) {\n    return memo[l][r];\n  }\n\n  for (int t = l + 1; t < r; t++) {\n    int temp  = rec(l, t);\n    int temp2 = rec(t, r);\n    int temp3 = rec(l + 1, t);\n    int temp4 = rec(t, r - 1);\n    \n    if (temp == 2 && temp2 == 2) {\n      return memo[l][r] = 2;\n    }\n    if (abs(w[l] - w[r - 1]) <= 1 && temp3 == 2 && temp4 == 2) {\n      return memo[l][r] = 2;\n    }\n  }\n\n  return memo[l][r] = 1;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    w.clear();\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n    memset(memo, 0, sizeof(memo));\n    memset(dp, 0, sizeof(dp));\n    \n    //    cerr << \" \" << rec(0, n) << endl;\n    rec(0, n);\n\n    \n    dp[0] = 0;\n\n    for (int r = 0; r <= n; r++) {\n      dp[r] = dp[r - 1];\n      for (int l = 0; l < r; l++) {\n        if (memo[l][r] == 2) {\n          dp[r] = max(dp[r], dp[l] + (r - l));\n        }\n      }\n    }\n    \n\n    cout << dp[n] << endl;\n\n  }\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n\t#include <cstdio>\n\t#include <algorithm>\n\t#include <string>\n\t#include <cstring>\n\t#include <cctype>\n\t#include <cmath>\n\t#include <stack>\n\t#include <queue>\n\t#include <vector>\n\t#include <set>\n\t#include <map>\n\t#include <list>\n\t#include <stdio.h>\n\t#include <string.h>\n\t#include <cstdlib>\n\t#include <math.h>\n\t#include <bitset>\n\t#include <iterator>\n\t#include <iomanip>\n\t#include <sstream>\n\t#include <numeric>\n\t#include <cassert>\n\tusing namespace std;\n\tint dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0};\n\tlong long gcd(long long a,long long b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\tlong long lcm(long long a,long long b){if(a==0){return b;} return a/gcd(a,b)*b;}\n\t#define INF 2000000000\n\t#define MOD 1000000007\n\t#define sym cout<<\"---------\"<<endl;\n\t#define ll long long\n\t#define mk make_pair\n\t#define en endl\n\t#define RE return 0\n\t#define int ll\n\t#define P pair<int,int>\n\t\n\tint dp[305][305];\n\nsigned main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint w[305];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor(int i=0; i<n; i++) cin>>w[i];\n\t\t\n\t\tfor(int W=2; W<=n; W++){\n\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\tint r=l+W;\n\t\t\t\t\n\t\t\t\tif(dp[l+1][r-1]==W-2&&abs(w[l]-w[r-1])<=1) dp[l][r]=W;\n\t\t\t\t\n\t\t\t\tfor(int mid=l; mid<=r; mid++){\n\t\t\t\t\tdp[l][r]=max(dp[l][r], dp[l][mid]+dp[mid][r]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][n]<<en;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\nconst long long int INF = 1e18;\nconst long long int mod = 1e9+7;\n\ntypedef pair<ll, ll> pairs;\ntypedef vector<pairs> p;\n\nstruct edge{\n    ll to, cost;\n};\n\n\nll gcd(ll a,ll b){\n    if(b == 0){\n        return a;\n    }else{\n        return gcd(b, a%b);\n    }\n}\n\nll lcm(ll a, ll b){\n    return a / gcd(a, b) * b;\n}\n\nll keta(ll N){\n    int tmp{};\n    while( N > 0 ){\n        tmp += ( N % 10 );\n        N /= 10;\n    }\n    N = tmp;\n    return N;\n}\n\n// 回文\nbool kai(string S){\n    bool flag = true;\n    for(ll i=0;i<S.size()/2;++i){\n        if(S[i] != S[S.size()-i-1]){\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}\n// ---------------------------------------------\n\nint main(){\n    while(true){\n        ll n;\n        cin>>n;\n        if(n == 0){\n            return 0;\n        }\n        vector<ll> w(n);\n        for(ll i=0;i<n;++i){\n            cin>>w[i];\n        }\n\n        vector<vector<ll>> dp(n+10, vector<ll> (n+10, 0));\n        vector<vector<bool>> ok(n+10, vector<bool>(n+10, false));\n        for(ll len=1;len<=n;++len){\n            for(ll left=0;left<n-len;++left){\n\n                ll right = left + len;\n                for(ll mid=left;mid<right;++mid){\n                    if(ok[left][mid] and ok[mid+1][right]){\n                        ok[left][right] = true;\n                    }\n                }\n                if(len == 1){\n                    if(abs(w[left] - w[right]) <= 1){\n                        ok[left][right] = true;\n                    }\n                }\n                if(ok[left][right]){\n                    ll x = left - 1;\n                    ll y = right + 1;\n                    while(true){\n                        if(x < 0 or x >= n or y < 0 or y >= n)break;\n                        if(abs(w[x] - w[y]) >= 2)break;\n                        ok[x][y] = true;\n                        x--;\n                        y++;\n                    }\n                }\n            }\n        }\n\n        for(ll i=0;i<n;++i){\n            for(ll j=i+1;j<n;++j){\n                if(ok[i][j]){\n                    dp[i][j] = j - i + 1;\n                }\n            }\n        }\n        for(ll i=0;i<n;++i){\n            for(ll j=i+1;j<n;++j){\n                for(ll k=i;k<j;++k){\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n                }\n            }\n        }\n        ll ans = dp[0][n-1];\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,data[301];\n\tbool** table = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tint** maximum = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tmaximum[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 1; k <= N; k++)maximum[i][k] = 0;\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1){\n\t\t\t\ttable[i][1] = true;\n\t\t\t\tmaximum[i][i+1] = 2;\n\t\t\t}\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t\tmaximum[left][left+length-1] = length; //????¨?????????§??????OK????????§?????¶????????§???????¨????\n\t\t\t\t}else{\n\t\t\t\t\t//maximum[left][left+length-1]?????´??°????????°????????????\n\t\t\t\t\tfor(int i = 2; i <= length-2; i+= 2){\n\t\t\t\t\t\tmaximum[left][left+length-1] = max(maximum[left][left+length-1],maximum[left][left+i-1]+maximum[left+i][left+length-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(N%2 == 0)printf(\"%d\\n\",maximum[1][N]);\n\t\telse{\n\t\t\tprintf(\"%d\\n\",max(maximum[1][N-1],maximum[2][N]));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N, w[1000];\nbool dp[1000][1000];\n\nbool rec(int left, int right) {\n    if(dp[left][right]) return true;\n    if(left >= right) return false;\n\n    bool ret = false;\n    if(!(abs(left - right) % 2)) {\n        rec(left + 1, right), rec(left, right - 1);\n    } else {\n        for(int i = left + 1; i < right; i += 2) {\n            ret |= rec(left, i) & rec(i + 1, right);\n        }\n        ret |= rec(left + 1, right - 1) & (abs(w[left] - w[right]) <= 1);\n    }\n    return dp[left][right] = ret;\n}\n\nint maxi[1001];\nint calc(int idx) {\n\n    if(maxi[idx]) return maxi[idx];\n    if(idx > N) return 0;\n\n    int ret = 0;\n    ret = calc(idx + 1);\n    for(int i = idx + 1; i < N; i += 2) {\n        if(dp[idx][i]) {\n            ret = max(calc(i + 1) + (i - idx + 1), ret);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    while(cin >> N, N) {\n        for(int i = 0; i < N; i++) {\n            cin >> w[i];\n        }\n\n        fill_n(maxi, 1001, 0);\n        fill_n(*dp, 1000*1000, false);\n        for(int i = 0; i < N - 1; i++) {\n            if(abs(w[i] - w[i + 1]) <= 1) {\n                dp[i][i + 1] = true;\n            }\n        }\n        rec(0, N - 1);\n        cout << calc(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> W;\nvector<vector<int>> dp;\n// -1 : 未探索\n// 0  : 全消し不可能\n// 1  : 全消し可能\n\n// [L, R)を全消しできるか？\nbool rec(int L, int R) {\n\tint& ret = dp[L][R];\n\tif (ret >= 0) return ret;\n\n\tif (L == R) return ret = 1;\n\tif ((R - L) & 1) return ret = 0;\n\n\tret = 0;\n\tfor(int i = L + 1; i < R; i += 2) {\n\t\tif (abs(W[L] - W[i]) > 1) continue;\n\t\tif (rec(L + 1, i) && rec(i + 1, R)) return ret = 1;\n\t}\n\treturn ret;\n}\n\nbool solve() {\n\tint N;\n\tcin >> N;\n\tif (N == 0) return false;\n\n\tW.resize(N);\n\tfor(auto& w : W) cin >> w;\n\n\tdp.resize(N + 1);\n\tfor(auto& v : dp) {\n\t\tv.assign(N + 1, -1);\n\t}\n\n\tvector<int> ans(N + 1, -1);\n\tans[0] = 0;\n\tfor(int L = 0; L <= N; ++L) {\n\t\tif (L > 0) ans[L] = max(ans[L], ans[L - 1]);\n\t\tfor(int len = 2; L + len <= N; ++len) {\n\t\t\tif (rec(L, L + len)) ans[L + len] = max(ans[L + len], ans[L] + len);\n\t\t}\n\t}\n\n\tcout << ans[N] << endl;\n\treturn true;\n}\n\nint main() {\n\twhile (solve());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nint n;\nint w[MAX];\nint done[305][305];\nint dp[305][305];\n\nvoid print_dp() {\n    rep(i, n) {\n        rep(j, n+1) {\n            cout << setw(3) << dp[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint ans(int l, int r) {\n    if (done[l][r]) {\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    if (r - l == 0) return 0;\n    if (r - l == 1) return 0; \n    if (l > r) return -INF;\n    if (r > n) return -INF;\n    if (r - l == 2) {\n        done[l][r] = true;\n        int res = 0;\n        if (abs(w[l] - w[l+1]) < 2) res = 2;\n        else res = 0;\n        dp[l][r] = res;\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    int res = 0;\n    rep(width2, 2)\n    {\n        if (l + width2 > r)\n            break;\n        rep2(i, l, r)\n        {\n            if (i + width2 > r)\n                break;\n            if (i > r - width2)\n                break;\n            if (i == l && r - width2 == r) continue;\n            // if (i + width2 == l && i + width2 == r)\n            //     continue;\n            // if (i + width + width2 * 2 == l)\n            //     continue;\n            int tmp =\n                ans(l+width2, i) + ans(i, r-width2);\n\n            rep(j, width2)\n            {\n                if (abs(w[l] - w[r - 1]) < 2)\n                {\n                    tmp += 2;\n                }\n                else\n                    break;\n            }\n            res = max(res, tmp);\n        }\n    }\n\n    done[l][r] = true;\n    dp[l][r] = res;\n    // if (test) {\n    //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n    // }\n    return dp[l][r];\n}\n\nvoid solve() {\n    rep(i, 305) rep(j, 305) done[i][j] = false;\n    rep(i, 305) rep(j, 305) dp[i][j] = 0;\n    cin >> n;\n    if (n == 0) exit(0);\n    rep(i, n) cin >> w[i];\n    cout << ans(0, n) << endl;\n    if (test) print_dp();\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>  \nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000000000000000000000001\n#define LONG_INF 10000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\nint main() {\n\twhile (true) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) return 0;\n\t\tvector<int> input;\n\t\tREP(i, n) {\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tinput.push_back(a);\n\t\t}\n\t\tint ok[300][300] = {};\n\t\tvector<pair<int, int>> next;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tif (abs(input[i] - input[i - 1]) <= 1) {\n\t\t\t\tok[i - 1][i] = 1;\n\t\t\t\tnext.push_back(make_pair(i - 1, i));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < next.size(); ++i) {\n\t\t\tint left = next[i].first;\n\t\t\tint right = next[i].second;\n\t\t\tif (left != 0 && right != n - 1) {\n\t\t\t\t//ok to expand\n\t\t\t\tif (abs(input[left - 1] - input[right + 1]) <= 1) {\n\t\t\t\t\t//ok\n\t\t\t\t\tif (ok[left - 1][right + 1] == 0) {\n\t\t\t\t\t\tok[left - 1][right + 1] = 1;\n\t\t\t\t\t\tnext.push_back(make_pair(left - 1, right + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < left; ++i) {\n\t\t\t\tif (ok[i][left - 1] == 1 && ok[i][right] == 0) {\n\t\t\t\t\tok[i][right] = 1;\n\t\t\t\t\tnext.push_back(make_pair(i, right));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = right + 2; i < n; ++i) {\n\t\t\t\tif (ok[left][i] == 0 && ok[right+1][i] == 1) {\n\t\t\t\t\tok[left][i] = 1;\n\t\t\t\t\tnext.push_back(make_pair(left, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dp[500] = {};\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdp[i + 1] = max(dp[i], dp[i + 1]);\n\t\t\tfor (int q = i + 1; q < n; ++q) {\n\t\t\t\tif (ok[i][q] == 1) {\n\t\t\t\t\tdp[q + 1] = max(dp[q + 1], dp[i] + (q - i + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    while (true) {\n        int N; cin >> N;\n        if (!N) break;\n        vector<int> w(N);\n        rep(i,N) cin >> w[i];\n\n        vector<vector<int>> dp(N, vector<int>(N));\n        for (int k = 1; k < N; k++) {\n            rep(i,N-k) {\n                if (abs(w[i]-w[i+k]) < 2 && dp[i+1][i+k-1] == k+1-2) dp[i][i+k] = dp[i+1][i+k-1]+2;\n                else {\n                    for (int j = 0; j < k; ++j) {\n                        chmax(dp[i][i+k],dp[i][i+j]+dp[i+j+1][i+k]);\n                    }\n                }\n            }\n        }\n\n        cout << dp[0][N-1] << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nint n, a[1010];\nint dp[1010][1010], dp2[1010] = {};\n\nint ok(int l, int r){\n    int &res = dp[l][r];\n    if(res != -1) return res;\n    res = false;\n    if(l == r) return res = true;\n    for(int i = l+2; i < r; i += 2) if(ok(l,i) && ok(i,r)) return res = true;\n    if(abs(a[l] - a[r-1]) <= 1 && ok(l+1, r-1)) return res = true;\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(cin >> n && n){\n        rep(i, n) cin >> a[i];\n        memset(dp, -1, sizeof dp);\n        memset(dp2, 0, sizeof dp2);\n        rep(i, n){\n            dp2[i+1] = max(dp2[i+1], dp2[i]);\n            for(int j = i + 2; j <= n; j += 2){\n                if(ok(i, j)) dp2[j] = max(dp2[j], dp2[i] + j - i);\n            }\n        }\n        cout << dp2[n] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i<(n); ++i)\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vi a(n);\n        for (int i=0; i<n; ++i) cin >> a[i];\n\n        vvi dp(301, vi(301, 0));\n        for (int i=0; i+2<=n; ++i) {\n            dp[i][i+2] = (abs(a[i] - a[i+1]) <= 1 ? 2 : 0);\n        }\n        for (int l=3; l<=n; ++l) {\n            for (int i=0; i+l<=n; ++i) {\n                if (dp[i+1][i+l-1] == l-2) {\n                    dp[i][i+l] = dp[i+1][i+l-1] + (abs(a[i] - a[i+l-1]) <= 1 ? 2 : 0);\n                }\n                for (int j=i+1; j<i+l; ++j) {\n                    dp[i][i+l] = max(dp[i][i+l], dp[i][j] + dp[j][i+l]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint w[305];\n\nint dp[305][305];\nint ans[305];\nint main(void){\n\tfor(;;){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\trep(i,n){\n\t\t\tscanf(\"%d\",&w[i]);\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\trep(j,n-1){\n\t\t\tif(abs(w[j]-w[j+1])<=1){\n\t\t\t\tdp[j][j+1]=1;\n\t\t\t}\n\t\t}\n\t\treg(k,3,n)reg(i,0,n-k-1){\n\t\t\tint a = i,b=i+k;\n\t\t\treg(t,a+1,b-1){\n\t\t\t\tdp[a][b] |= (dp[a][t] & dp[t+1][b]);\n\t\t\t}\n\t\t\tif(a+1<=b-1 && dp[a+1][b-1] && abs(w[a]-w[b])<=1){\n\t\t\t\tdp[a][b] = 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i,n){\n\t\t\treg(j,i+1,n-1){\n\t\t\t\tprintf(\"%d %d : %d\\n\",i,j,dp[i][j]);\n\t\t\t}\n\t\t\t//puts(\"\");\n\t\t}\n\t\t*/\n\t\tmemset(ans,0,sizeof(ans));\n\t\tans[0]=0;\n\t\treg(i,1,n){\n\t\t\tans[i] = ans[i-1]+1;\n\t\t\trep(j,i){\n\t\t\t\tif(dp[j][i-1])ans[i]=min(ans[i],ans[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",n-ans[n]);\n\t}\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i = int(a); i < int(b); ++i)\n\nconstexpr int MAXN = 302;\n\nbool dp[MAXN][MAXN]; // [l, r)\nint dp2[MAXN];\n\nsigned main() {\n\n\twhile (true) {\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tif (n == 0) break;\n\t\tstd::vector<int> w(n);\n\t\tREP(i, n) std::cin >> w[i];\n\n\t\tREP(i, MAXN) REP(j, MAXN) dp[i][j] = false;\n\t\tREP(i, MAXN) dp2[i] = 0;\n\n\t\tREP(i, n - 1) {\n\t\t\tif (std::abs(w[i] - w[i + 1]) <= 1) dp[i][i + 2] = true;\n\t\t}\n\t\tFOR(d, 4, n + 1) {\n\t\t\tREP(l, n - 1) {\n\t\t\t\tint r = l + d;\n\t\t\t\tif (r > n) break;\n\t\t\t\tFOR(m, l + 2, r - 1) {\n\t\t\t\t\tif (dp[l][m] && dp[m][r]) dp[l][r] = true;\n\t\t\t\t}\n\t\t\t\tif (std::abs(w[l] - w[r - 1]) <= 1 && dp[l + 1][r - 1]) dp[l][r] = true;\n\t\t\t}\n\t\t}\n\n\t\t/*REP(l, n + 1) {\n\t\t\tREP(r, n + 1) {\n\t\t\t\tstd::cout << dp[l][r] << \" \";\n\t\t\t}\n\t\t\tstd::cout << std::endl;\n\t\t}*/\n\n\t\tREP(l, n) {\n\t\t\tdp2[l + 1] = std::max(dp2[l + 1], dp2[l]);\n\t\t\tFOR(r, l, n + 1) {\n\t\t\t\tif (!dp[l][r]) continue;\n\t\t\t\tdp2[r] = std::max(dp2[r], dp2[l] + (r - l));\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << dp2[n] << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\nusing namespace std;\nusing ll = long long;\nusing Graph = vector<vector<int>>;\nconst ll MOD = 1000000007;\nconst ll INF = 10000000000000000;\nvector<int> x4 = {0, 1, 0, -1}, x8 = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<int> y4 = {1, 0, -1, 0}, y8 = {1, 1, 0, -1, -1, -1, 0, 1};\ntemplate<class T> struct edge { int from, to; T cost;};\ntemplate<class T> inline bool chmin(T& a, T b){if (a>b){a = b; return true;}return false;}\ntemplate<class T> inline bool chmax(T& a, T b){if (a<b){a = b; return true;}return false;}\ntemplate<class T> inline T powerM(T a,T b){if (b==0) return 1;\nT tmp = powerM(a,b/2); if (b%2==0) return tmp*tmp%MOD; else return tmp*tmp%MOD*a%MOD; }\ntemplate<class T> inline T power(T a,T b,T m){ if (b==0) return 1;\n  T tmp = power(a,b/2,m); if (b%2==0) return tmp*tmp%m; else return tmp*tmp%m*a%m; }\ntemplate<class T> inline T gcd(T a, T b){if (b==0) return a; return gcd(b, a%b);}\ntemplate<class T> inline T lcm(T a, T b){return a / gcd(a,b) * b;}\n// ax+by=gcd(a,b)を解く\ntemplate<class T> inline T extgcd(T a,T b,T &x,T &y){if (b==0){x=1; y=0; return a;} T d=extgcd(b,a%b,y,x); y -= a/b*x; return d;}\n\n\nint N;\nvector<int> W;\nvector<vector<int>> dp;\n\nvoid solve(){\n  W.assign(N, 0); rep(i, N) cin >>W[i];\n  dp.assign(N+1, vector<int>(N+1, -N));\n  rep(i, N+1) dp[i][i] = 0;\n  rep(i, N) dp[i][i+1] = 0;\n  // dp[i][j]...[i,j) のブロックが残っているとき最適な叩き出しを行って取り除けるブロックの個数\n  for (int len=2; len<=N; len++){\n    for (int i=0; i+len<=N; i++){\n      int j = i + len;\n      if (dp[i+1][j-1] == len-2){\n        if (abs(W[i]-W[j-1]) <= 1) chmax(dp[i][j], len);\n        else chmax(dp[i][j], len-2);\n      }\n      for (int k=i+1; k<j; k++){\n        chmax(dp[i][j], dp[i][k] + dp[k][j]);\n      }\n    }\n  }\n  cout <<dp[0][N] <<endl;\n}\n\nint main() {\n  cin >>N;\n  while (N > 0){\n    solve();\n    cin >>N;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint W[300];\nint dp[300][300];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0){break;}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&W[i]);\n\t\t}\n\t\tfor(int i=0;i<300;i++){\n\t\t\tfor(int j=0;j<300;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=N-2;i++){\n\t\t\tif(abs(W[i]-W[i+1])<=1){dp[i][1]=2;}\n\t\t}\n\t\tfor(int j=3;j<=N-1;j+=2){\n\t\t\tfor(int i=0;i+j<N;i++){\n\t\t\t\t//[i,i+j]\n\t\t\t\tif(abs(W[i+j-1]-W[i+j])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][j-2]+2);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][j-2]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+1])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+2][j-2]+2);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+2][j-2]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+j])<=1&&dp[i+1][j-2]==j-1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(N%2==0){printf(\"%d\\n\",dp[0][N-1]);}\n\t\telse{printf(\"%d\\n\",max(dp[0][N-2],dp[1][N-2]));}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n// #define DEBUG\n\nconst int MAX_N = 300;\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N) {\n        vector<int> W(N);\n        rep(i, N) cin >> W[i];\n\n        bool dp[MAX_N][MAX_N] = {};\n        rep(i, MAX_N) {\n            dp[i][i] = true;\n        }\n\n        for (int len=2; len<=N; len+=2) {\n            for (int l=0; l<=N-len; l++) {\n                {\n                    int inner_len = len - 2;\n                    if (!(inner_len > 0 && !dp[l + 1][l + inner_len]) && abs(W[l] - W[l+ (len - 1)]) <= 1) {\n                        dp[l][l + (len - 1)] = true;\n                    }\n                }\n                for (int len2 = 2; len2 <= len - 2; len2+=2) {\n                    int part_l = len2, part_r = len - len2;\n\n                    if ((dp[l][l + part_l - 1] && dp[l + part_l][l + len - 1]) ||\n                        (dp[l][l + part_r - 1] && dp[l + part_r][l + len - 1])) {\n                        dp[l][l+len-1] = true;\n                    }\n                }\n            }\n        }\n\n        int dp2[MAX_N + 1] = {};\n        rep(r, N) {\n            if (r > 0) dp2[r] = dp2[r-1];\n            for (int len=2; len<=r+1; len+=2) {\n                int l = r - len + 1;\n#ifdef DEBUG\n                // DUMP(len);\n                // DUMP2(l, r);\n#endif\n                if (dp[l][r]) {\n                    if (l-1 >= 0) {\n                        dp2[r] = max(dp2[r], dp2[l-1] + len);\n                    } else {\n                        dp2[r] = max(dp2[r], len);\n                    }\n                }\n            } \n        }\n\n#ifdef DEBUG\n        rep(l, N) {\n            rep(r, N) cerr << dp[l][r] << \" \";\n            cerr << endl;\n        }\n        cerr << \"-----------------------------\" << endl;\n        rep(i, N) cerr << dp2[i] << \" \";\n        cerr << endl;\n#endif\n\n        cout << dp2[N-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> w;\nvector<vector<int>> dp;\n\nint solve(int l, int r);\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    w.resize(n);\n    for(int i = 0; i < n; ++i) cin >> w[i];\n    dp.assign(n, vector<int>(n, -1));\n    for(int i = 0; i < n; ++i) dp[i][i] = 0;\n    for(int i = 0; i < n - 1; ++i)\n      if(abs(w[i + 1] - w[i]) <= 1) dp[i][i + 1] = 2;\n    cout << solve(0, n - 1) << endl;\n  }\n  return 0;\n}\n\nint solve(int l, int r) {\n  if(dp[l][r] != -1) return dp[l][r];\n  int ans = 0;\n  for(int i = l; i < r; ++i)\n    ans = max(ans, solve(l, i) + solve(i + 1, r));\n  if(r - l + 1 >= 4 && solve(l + 1, r - 1) == r - l - 1 &&\n     abs(w[l] - w[r]) <= 1)\n    ans = r - l + 1;\n  return dp[l][r] = ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n  \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nint W[301];\nint f[301][301];\nint main(){\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0)break;\n\t\tREP(i,N)cin>>W[i];\n\t\tmemset(f,false,sizeof(f));\n\t\tREP(i,N)f[i][i]=true;\n\t\tREP(i,N-1)if(abs(W[i]-W[i+1])<=1)f[i][i+2]=true;\n\t\tfor(int d=4;d<=N;d+=2){\n\t\t\tREP(i,N-d+1){\n\t\t\t\tfor(int j=i+2;j<=i+d-2;j+=2){\n\t\t\t\t\tif(f[i][j]&&f[j][i+d])f[i][i+d]=true;\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+d-1])<=1&&f[i+1][i+d-1]){\n\t\t\t\t\tf[i][i+d]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ma[N];\n\t\tREP(i,N+1)ma[i]=i;\n\t\tREP(i,N){\n\t\t\tfor(int j=N;j>=i;j--){\n\t\t\t\tif(f[i][j]){\n\t\t\t\t\tma[i]=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*REP(i,N)cout<<ma[i]<<\" \";cout<<endl;\n\t\tREP(i,N+1){REP(j,N+1)cout<<f[i][j]<<\" \";cout<<endl;}*/\n\t\tint ans=0;\n\t\tREP(i,N){\n\t\t\tint p=i,cnt=0;\n\t\t\twhile(p<=N){\n\t\t\t\tint pp=ma[p];\n\t\t\t\tcnt+=(pp-p);\n\t\t\t\tp=pp+1;\n\t\t\t}\n\t\t\tans=max(ans,cnt);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n;\nll w[3010];\nll dp[3010][3010];\nbool f[3010][3010];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 301)rep(j, 301) {\n\t\t\tdp[i][j] = 0;\n\t\t\tf[i][j] = 0;\n\t\t}\n\t\trep(i, n)cin >> w[i];\n\n\t\tfor (int wid = 1; wid < n; wid++) {\n\t\t\trep(i, n) {\n\t\t\t\tif (i + wid >= n)continue;\n\t\t\t\tif (wid == 1) {\n\t\t\t\t\tif (abs(w[i] - w[i + wid]) <= 1) {\n\t\t\t\t\t\tdp[i][i + wid] = 2;\n\t\t\t\t\t\tf[i][i + wid] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (wid % 2 == 1) {\n\t\t\t\t\t\tif (abs(w[i] - w[i + wid]) <= 1) {\n\t\t\t\t\t\t\tif (f[i + 1][i + wid - 1]) {\n\t\t\t\t\t\t\t\tdp[i][i + wid] = dp[i + 1][i + wid - 1] + 2;\n\t\t\t\t\t\t\t\tf[i][i + wid] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][i + wid] = max(dp[i][i + wid], dp[i + 1][i + wid - 1]);\n\t\t\t\t\t\tfor (int j = i + 1; j < i + wid; j++) {\n\t\t\t\t\t\t\tdp[i][i + wid] = max(dp[i][i + wid], (dp[i][j] + dp[j + 1][i + wid]));\n\t\t\t\t\t\t\tf[i][i + wid] |= (f[i][j] && f[j + 1][i + wid]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tFOR(j, i, i + wid) {\n\t\t\t\t\t\t\tdp[i][i + wid] = max(dp[i][i + wid], dp[i][j] + dp[j + 1][i + wid]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\trep(i, n) {\n\t\t\t//ll sum = 0;\n\t\t\tFOR(j, i + 1, n) {\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t\t//if (dp[i][j])sum += max(ans, (ll)(j - i + 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint main() {\n\twhile (cin >> n, n) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; i++) cin >> a[i];\n\t\tvector<vector<int> > dp(n, vector<int>(n + 1));\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n - i; j++) {\n\t\t\t\tint r = j + i;\n\t\t\t\tfor (int k = j + 1; k < r; k++) {\n\t\t\t\t\tdp[j][r] = max(dp[j][r], dp[j][k] + dp[k][r]);\n\t\t\t\t}\n\t\t\t\tif (abs(a[j] - a[r - 1]) <= 1 && dp[j + 1][r - 1] == i - 2) {\n\t\t\t\t\tdp[j][r] = max(dp[j][r], dp[j + 1][r - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <math.h>\nusing namespace std;\n\nint n, w[310];\nint dp[310][310];\n\nint max2(int i, int j) {\n    if (i > j) return i;\n    else return j;\n}\n\nbool solve(int i, int j) {\n    if (dp[i][j] >= 0) return dp[i][j];\n    else {\n        if (i >= j || (j - i) % 2 == 0) dp[i][j] = 0;\n        else if (j - i == 1) {\n            if (abs(w[i] - w[j]) <= 1) dp[i][j] = 1;\n            else dp[i][j] = 0;\n        }\n        else if (solve(i + 2, j) == 1 && solve(i, j - 2) == 1) dp[i][j] = 1;\n        else if (solve(i + 1, j - 1) == 1) {\n            if (abs(w[i] - w[j]) <= 1) dp[i][j] = 1;\n            else dp[i][j] = 0;\n        }\n        else dp[i][j] = 0;\n        \n        return dp[i][j];\n    }\n}\n    \nint main(void){\n    while (1) {\n        cin >> n;\n        if (n == 0) return 0;\n        for (int i = 0; i < n; i++) cin >> w[i];\n        for (int i = 0; i < 300; i++) {\n            for (int j = 0; j < 300; j++) dp[i][j] = -1;\n        }\n        \n        int min = 0, max = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n && min <= i; j++) {\n                if (solve(i, j) == 1) max = j;\n            }\n        //    cout << \"max \" << max << endl;\n            if (max > min) {\n                ans += (max - i) + 1;\n                min = max + 1;\n                max = min;\n            }\n            else {\n                min = max2(min, i);\n                max = min;\n            }\n        }\n        \n        //for (int i = 0; i < n; i++) {\n        //    for (int j = 0; j < n; j++) {\n        //        cout << solve(i, j) << \" \";\n        //    }\n        //    cout << endl;\n        //}\n        \n        cout << ans << endl;\n    }\n    \n    \n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n//#define MAX 300\nshort n;\nshort* w;\nvector<pair<short*,short> > wmap;\n\nshort* pop(short* w,short a) { //w???a????????¨a+1?????????????????????\n\tshort *t;\n\tt = new short[n];\n\tfor (short i = 0; i < n; i++) {\n\t\tif(i < a) t[i] = w[i];\n\t\telse t[i] = w[i + 2];\n\t}\n\tt[n - 2] = -1;\n\tt[n - 1] = -1;\n\treturn t;\n}\n\nshort daruma(short* w) {\n\tfor (short i = 0; i < wmap.size(); i++) {\n\t\tif (memcmp(w, wmap[i].first, sizeof(w)) == 0) {\n\t\t\treturn wmap[i].second;\n\t\t}\n\t}\n\n\tshort max = 0;\n\tfor (short i = 0; i < n - 1; i++) {\n\t\tif (w[i] != -1 && w[i + 1] != -1 && abs(w[i]-w[i+1])<=1) {\n\t\t\tshort tmp = daruma(pop(w, i))+2;\n\t\t\tif (tmp > max) max = tmp;\n\t\t}\n\t}\n\n\twmap.push_back(make_pair(w,max));\n\treturn max;\n}\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\twmap.clear();\n\t\tw = new short[n]();\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << daruma(w) << endl;\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<int> w;\n\nint memo[301][301];\n\nint rec(int l, int r) {\n  if (r == l) {\n    return (memo[l][r] = 1);\n  }\n  if (memo[l][r] != 0) {\n    return memo[l][r];\n  }\n  if (r - l == 1) {\n    if (abs(w[l] - w[r]) <= 1) {\n      return (memo[l][r] = 2);\n    } else {\n      return (memo[l][r] = 1);\n    }\n  }\n\n  if (abs(w[l] - w[r]) <= 1) {\n    if (rec(l + 1, r - 1) == 2) {\n      return (memo[l][r] = 2);\n    }\n  }\n\n  if (abs(w[l] - w[l + 1]) <= 1) {\n    if (rec(l + 2, r) == 2) {\n      return (memo[l][r] = 2);\n    }\n  }\n\n  if (abs(w[r] - w[r - 1]) <= 1) {\n    if (rec(l, r - 2) == 2) {\n      return (memo[l][r] = 2);    \n    }\n  }\n\n  return (memo[l][r] = 1);\n}\n\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    memset(memo, 0, sizeof(memo));\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        rec(i, j);        \n      }\n    }\n\n    \n    int ans = 0;\n\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (memo[i][j] == 2) {\n          ans = max(ans, j - i + 1);\n        }\n        for (int k = i + 1; k <= j; k++) {\n          for (int l = k + 1; l <= j; l++) {\n            if (memo[i][k] == 2 && memo[l][j] == 2) {\n              ans = max(ans, (k - i + 1) + (j - l + 1));\n            }\n          }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        vector<int> w(n);\n        rep(i,n) cin >>w[i];\n\n        vector<vector<int>> ok(n,vector<int>(n));\n        rep(i,n-1) ok[i][i+1] = (abs(w[i]-w[i+1]) <= 1);\n\n        for(int b=4; b<=n; b+=2){\n            for(int l=0; l+b-1<n; ++l){\n                int r = l+b-1;\n                for(int i=l+1; i<r; ++i) ok[l][r] |= (ok[l][i] & ok[i+1][r]);\n                ok[l][r] |= ((abs(w[l]-w[r])<=1) & ok[l+1][r-1]);\n            }\n        }\n\n        vector<int> dp(n+1,-n);\n        dp[0] = 0;\n        rep(i,n){\n            for(int j=i; j<n; ++j){\n                if(ok[i][j]) dp[j+1] = max(dp[j+1], dp[i]+(j-i+1));\n            }\n            dp[i+1] = max(dp[i+1],dp[i]);\n        }\n        cout << dp[n] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tvector<int> w(n);\n\t\trep(i, n) cin >> w[i];\n\t\tvector<vector<int>> dp(n + 1, vector<int>(n + 1));\n\t\tfor (int d = 2; d <= n; d++) {\n\t\t\tfor (int l = 0; l <= n - d; l++) {\n\t\t\t\tint r = l + d;\n\t\t\t\tif (dp[l + 1][r - 1] == r - l - 2 && abs(w[l] - w[r - 1]) < 2) {\n\t\t\t\t\tdp[l][r] = r - l;\n\t\t\t\t}\n\t\t\t\tfor (int m = l + 1; m < r; m++) {\n\t\t\t\t\tdp[l][r] = max(dp[l][r], dp[l][m] + dp[m][r]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30)\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nvoid solve(int n) {\n    vector<int> w(n);\n    rep(i, 0, n) cin >> w[i];\n    vector<vector<int> > dp(n, vector<int>(n, 0));\n    for (int i = 0; i + 1 < n; i++) {\n        if (abs(w[i + 1] - w[i]) <= 1) {\n            dp[i][i + 1] = 2;\n        } else {\n            dp[i][i + 1] = 0;\n        }\n    }\n    for (int d = 3; d < n; d += 2) {\n        for (int i = 0; i + d < n; i++) {\n            int j = i + d;\n            if (abs(w[j] - w[i]) <= 1 && dp[i + 1][j - 1] == j - i - 1) {\n                dp[i][j] = j - i + 1;\n            } else {\n                for (int k = i + 1; k < j; k += 2) {\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                }\n            }\n\n        }\n    }\n    if (n % 2 == 0) {\n        cout << dp[0][n - 1] << endl;\n    } else {\n        int ans = max(dp[0][n-2],dp[1][n-1]);\n        cout << ans << endl;\n\n    }\n//    for(int i = 0; i < n; i++){\n//\n//    }\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        solve(n);\n\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nvector<int> a(1);         //命令 a[1]-a[n] 1-n ->0-9,u\nint ans;\nvoid next(int z,vector<int> b);\n\n\nint main(){\n  int n;\n  scanf (\"%d\",&n);\n  while(n){\n    ans=n;\n    a.assign(n,0);\n    for(int t=0;t<n;t++){\n      scanf (\"%d\",&a[t]);\n    }\n    for(int t=0;t<int(a.size())-1;t++){\n      if(-1<=(a[t]-a[t+1])&&(a[t]-a[t+1])<=1){\n        next(t,a);\n      }\n    }\n    \n    ans=n-ans;\n    printf(\"%d\\n\",ans);\n    scanf (\"%d\",&n);\n  }\n}\n\n\n\nvoid next(int z,vector<int> b){\n  b.erase(b.begin()+z,b.begin()+z+2);\n  //printf(\"%ld\\n\",b.size());\n  if(int(b.size())<ans){\n    ans=b.size();\n  }\n  for(int s=0;s<int(b.size())-1;s++){\n    if(-1<=(b[s]-b[s+1])&&(b[s]-b[s+1])<=1){\n      next(s,b);\n    }\n  }\n}\n\n\n//変化したところだけ見る\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin>>n && n!=0){\n        int a[n];\n        for(int i=0;i<n;i++){\n            cin>>a[i];\n        }\n        bool ok[n][n]={};\n        map<int,vector<int>> mp;\n        for(int i=0;i<n;i++) ok[i][i]=true;\n        for(int i=0;i<n-1;i++){\n            if(abs(a[i]-a[i+1])<=1) ok[i][i+1]=true;\n        }\n\n        for(int len=1;len<n;len+=2){\n            for(int i=0;i<n-len;i++){\n                for(int k=1;k<i+len;k++){\n                    if(ok[i][i+k] && ok[i+k+1][i+len]) ok[i][i+len]=true;\n                }\n                if(abs(a[i]-a[i+len])<=1 && ok[i+1][i+len-1]) ok[i][i+len]=true;\n                \n                if(ok[i][i+len]) mp[i+len].push_back(len+1);\n            }\n        }\n        \n        int dp[n]={};\n        for(int i=1;i<n;i++){\n            dp[i]=dp[i-1];\n            for(auto j:mp[i]){\n                if(i-j>=0) dp[i]=max(dp[i],dp[i-j]+j);\n                if(i-j==-1) dp[i]=max(dp[i],j);\n            }\n        }\n        cout<<dp[n-1]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) return 0;\n\t\tvector<int> w(n);\n\t\tfor (int i = 0; i < n; ++i) cin >> w[i];\n\t\tvector<vector<int> > dp(n, vector<int>(n, 0));\n\t\tfor (int i = 0; i < n-1; ++i) {\n\t\t\tif (abs(w[i] - w[i+1]) <= 1) dp[i][i+1] = 2;\n\t\t}\n\t\tfor (int d = 2; d < n; ++d) {\n\t\t\tfor (int i = 0; i < n-d; ++i) {\n\t\t\t\tif (dp[i+1][i+d-1] == d-1 and abs(w[i] - w[i+d]) <= 1) dp[i][i+d] = d+1;\n\t\t\t\telse {\n\t\t\t\t\tfor (int j = i; j < i+d; ++j) {\n\t\t\t\t\t\tdp[i][i+d] = max(dp[i][i+d], dp[i][j] + dp[j+1][i+d]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n-1] << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 301\nusing namespace std;\nint w[N],mem[N][N],used[N][N];\n \nint dfs(int l,int r){\n  if(l==r) return 0;\n  if(r-l==1) return 2*(abs(w[l]-w[r])<=1);\n  if(used[l][r]++) return mem[l][r];\n   \n  int res=0;\n  if(abs(w[l]-w[r])<=1&&dfs(l+1,r-1)==r-l-1)res=2+dfs(l+1,r-1);\n   \n  for(int i=l;i<r;i++) res=max(res,dfs(l,i)+dfs(i+1,r));\n  return mem[l][r]=res;\n}\n \nint main(){\n  int n;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>w[i];\n    memset(used,0,sizeof(used));\n    cout<<dfs(0,n-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i = 0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0;}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0;}\nint n;\nvector<int>a;\nvector<vector<int> > dp;\nint rec(int l = 0,int r = n) {\n    if((r-l)<=1) return 0;\n    if((r-l)==2) {\n        if(abs(a[l]-a[l+1])<=1) {\n            return 2;\n        } else {\n            return 0;\n        }    \n    }\n    if(dp[l][r] != -1)return dp[l][r];\n    if(abs(a[l] - a[r-1]) <= 1 && rec(l+1,r-1) == r-l-2) {\n        chmax(dp[l][r],r-l);\n    }\n    for(int i = l+1;i<=r-1;i++) {\n        chmax(dp[l][r],rec(l,i) + rec(i,r));\n    }\n    return dp[l][r];\n}\nint main() {\n    while(true) {\n        cin >> n;\n        if(n==0) break;\n        a.resize(n);\n        rep(i,n) cin >> a[i];\n        dp.assign(n+2,vector<int>(n+2,-1));\n        cout << rec() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<int> w(n);\n        for (auto &wi: w) cin >> wi;\n        vector<vector<int>> dp(n, vector<int>(n + 1));\n        for (int len = 2; len <= n; len++) {\n            for (int l = 0; l + len <= n; l++) {\n                int r = l + len;\n                if (dp[l + 1][r - 1] == len - 2 && abs(w[l] - w[r - 1]) <= 1) {\n                    dp[l][r] = len;\n                    continue;\n                }\n                for (int m = l; m < r; m++) {\n                    dp[l][r] = max(dp[l][r], dp[l][m] + dp[m][r]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0}; \n\nint n;\nint data[300];\nint dp[300][301]; // hankai\nint score[300][301];\n\nint solve(int st, int en)\n{\n    //cout << \"call : \" << st << \" \" << en << endl;;\n    if ( dp[st][en] ) {\n        //cout << \" ret1 : 0\" << endl;\n        return score[st][en] = dp[st][en] = 0;\n    }\n    if ( score[st][en] ) {\n        //cout << \" ret2 : \" << score[st][en] << endl;\n        return score[st][en];\n    }\n    if (en - st < 2) {\n        //cout << \" ret3 : \" << en - st << endl;\n        return score[st][en] = en - st;\n    }\n    int ret = en - st;\n    for (int i = st+2; i < en; i++) {\n        if (dp[st][i]) {\n            ret = min(solve(i, en), ret);\n        }\n    }\n    return score[st][en] = min(ret, 1+solve(st+1, en));\n    //score[st][en] = min(ret, 1+solve(st+1, en));\n    //cout << score[st][en] << endl;\n    //return score[st][en];\n}\n\nvoid make(int st, int en)\n{\n    //cout << \"call : \" << st << \" \" << en << endl;\n    if (en - st < 2) return;\n\n    if (0 <= st - 1 && en + 1 <= n && abs(data[st-1]-data[en]) < 2)\n        dp[st-1][en+1] = 1;\n\n    for (int i = max(0LL, st - (en - st)); i < st; i++)\n        if (dp[i][st]) dp[i][en] = 1;\n\n    for (int i = en+1; i < min(n+1, en + (en - st)); i++)\n        if (dp[en][i]) dp[st][i] = 1;\n\n}\n\nsigned main() \n{ \n    std::ios::sync_with_stdio(false); \n    std::cin.tie(0); \n\n    cin >> n;\n    while ( n ) {\n        memset(data, 0, sizeof(data));\n        memset(dp, 0, sizeof(dp));\n        memset(score, 0, sizeof(score));\n        rep(i, n) cin >> data[i];\n\n        rep(i, n-1) if (abs(data[i] - data[i+1]) < 2) dp[i][i+2] = 1;\n        /*\n        rep(i, n) {\n            Rep(j, n+1) {\n                cout << dp[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        cout << \"============\" << endl;\n        */\n\n        for (int i = 2; i < n; i++) {\n            for (int st = 0; st < n - i + 1; st++) {\n                int en = st + i;\n                if (dp[st][en]) make(st, en);\n            }\n        }\n\n        /*\n        rep(i, n) {\n            Rep(j, n+1) {\n                cout << dp[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        cout << n - solve(0, n) <<endl;\n        cin >> n;\n    }\n\n    return 0; \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n#define DUMP(x) cout << #x << \": \" << x << endl\n\nint n;\nint memo[310][310] = { 0 };\nvector<int> w(n);\n\nint rec(int l, int r) {\n  if (r - 1 == l) {\n    return 0;\n  }\n  \n  if (r - l  - 1 == 1) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      return 2;\n    }\n  }\n  if (memo[l][r]) {\n    return memo[l][r];\n  }\n  \n  int ret = 0;\n  bool isOK = false;\n  \n  if (abs(w[l] - w[r - 1]) <= 1) {\n    isOK = true;\n  }\n\n\n  for (int t = l + 1; t < r - 1; t++) {\n    for (int k = t + 1; k < r; k++) {\n      int temp = rec(t, k) + rec(k, r);\n      ret = max(ret, ((isOK && temp == r - l - 2)? 2 : 0) + temp);   \n    }\n  }\n\n  for (int t = l + 1; t < r - 1; t++) {\n    int temp = rec(l, t) + rec(t, r);\n    ret = max(ret, ((isOK && temp == r - l)? 2 : 0) + temp);\n  }\n\n  return memo[l][r] = ret;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    w.clear();\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    cout << rec(0, n) << endl;\n\n  }\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<int> ws(n);\n        for (auto &&x: ws) cin >> x;\n\n        vector<vector<bool>> memo(n, vector<bool>(n, false));\n\n        // 隣接した２つのブロックが消せるか\n        for (int l = 0; l<n-1; l++) {\n            int r = l+1;\n            if (abs(ws[l]-ws[r]) < 2) \n              memo[l][r] = true;\n        }\n\n        // ２つのブロックを指定し、その間の区間が消せるか\n        for (int len = 2; len<n; len++) {\n            for (int l = 0; l+len<n; l++) {\n                int r = l+len;\n                for (int c = l+1; c<r; c++)\n                    if (memo[l][c-1] && memo[c][r])  \n                        memo[l][r] = true;\n\n                if (memo[l+1][r-1] && abs(ws[l]-ws[r]) < 2)  \n                    memo[l][r] = true;\n            }\n        }\n\n        vector<int> dp(n, 0);\n        for (int r=1; r<n; r++) {\n            dp[r] = dp[r-1];\n            for (int l=0; l<n; l++) {\n                if (memo[l][r]) {\n                    if (l == 0) dp[r] = max(dp[r], r-l+1);\n                    else        dp[r] = max(dp[r], dp[l-1] + r-l+1);\n                }\n            }\n        }\n\n        // for (auto x: dp) cout << setw(3) << x; cout << endl;\n        cout << *(max_element(dp.begin(), dp.end())) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n \n#define rep(i, a) for (int i = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int i = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int i = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int i = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n#define TRUE__  \"Yes\"\n#define FALSE__ \"No\"\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define RS resize\n#define CINV(v, N) do {\\\n\tv.RS(N);\\\n\trep(i, N) cin >> v[i];\\\n} while (0);\n#define RCINV(v, N) do {\\\n\tv.RS(N);\\\n\trrep(i, N) cin >> v[i];\\\n} while (0);\n \n#define MOD 1000000007\nbool init();\nint solve();\n\nsigned main()\n{\n    while (init()) {\n    \tcout << solve() << endl;\n\t}\n}\n\nint N;\nvector<int> w;\n\nbool init()\n{\n\tcin >> N;\n\tif (N == 0) return false;\n\tw.RS(N);\n\trep(i, N) cin >> w[i];\n\treturn true;\n}\n\n\nint solve()\n{\n\tvector<vector<int> > dp;\n\tdp.RS(N, vector<int>(N, 0));\n\trep(i, N) rep(j, N) dp[i][j] = abs(j - i) + 1;\n\tfor (int i = 0; i + 1 < N; i++) {\n\t\tif (abs(w[i] - w[i+1]) <= 1) dp[i][i+1] = 0;\n\t}\n\n\tfor (int l = 3; l <= N; l++) {\n\t\tfor (int i = 0; i + l - 1 < N; i++) {\n\t\t\tint j = i + l - 1;\n\t\t\tint r = dp[i][j-2] + dp[j-1][j];\n\t\t\tr = min(r, dp[i][i+1] + dp[i+2][j]);\n\t\t\tif (abs(w[i] - w[j]) <= 1 && dp[i+1][j-1] == 0) {\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\tdp[i][j] = r;\n\t\t}\n\t}\n\treturn N - dp[0][N-1];\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<int> w;\n\nint memo[301][301];\n\nint rec(int l, int r) {\n  if (r == l) {\n    return (memo[l][r] = 1);\n  }\n  if (memo[l][r] != 0) {\n    return memo[l][r];\n  }\n  if (r - l == 1) {\n    if (abs(w[l] - w[r]) <= 1) {\n      return (memo[l][r] = 2);\n    } else {\n      return (memo[l][r] = 1);\n    }\n  }\n\n  if (abs(w[l] - w[r]) <= 1) {\n    if (rec(l + 1, r - 1) == 2) {\n      return (memo[l][r] = 2);\n    }\n  }\n\n  if (abs(w[l] - w[l + 1]) <= 1) {\n    if (rec(l + 2, r) == 2) {\n      return (memo[l][r] = 2);\n    }\n  }\n\n  if (abs(w[r] - w[r - 1]) <= 1) {\n    if (rec(l, r - 2) == 2) {\n      return (memo[l][r] = 2);    \n    }\n  }\n\n  return (memo[l][r] = 1);\n}\n\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    memset(memo, 0, sizeof(memo));\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if ((j - i) % 2 == 0) {\n          continue;\n        }\n        rec(i, j);        \n      }\n    }\n\n    \n    int ans = 0;\n\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (memo[i][j] == 2) {\n          ans = max(ans, j - i + 1);\n        }\n        for (int k = i + 1; k <= j; k++) {\n          for (int l = k + 1; l < j; l++) {\n            if (memo[i][k] == 2 && memo[l][j] == 2) {\n              ans = max(ans, (k - i + 1) + (j - l + 1));\n            }\n          }\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n\nint n;\n\nvector<vector<int>> dp;\nvector<int> w;\n\n\nint rec(int l,int r){\n\tif(dp[l][r] != -1) return dp[l][r];\n\n\tif(abs(l - r) <= 1) return 0;\n\n\tint res = 0;\n\t//l [able] r ?\n\tif(abs(w[l] - w[r - 1]) <= 1 && rec(l + 1,r - 1) == r - l - 2)\n\t{\n\t\tres = r - l;\n\t}\n\n\t//[l any] [any r]\n\tfor(int mid = l + 1;mid <= r - 1;mid++)\n\t{\n\t\tres = max(res , rec(l,mid) + rec(mid,r));\n\t}\n\treturn dp[l][r] = res;\n};\nint main()\n{\n\twhile(cin >> n , n)\n\t{\n\t\tw.assign(n,0);\n\t\tfor(int i = 0;i < n;i++) cin >> w[i];\n\n\t\tdp.assign(n + 1,vector<int>(n + 1,-1));\n\n\n\t\t//[l,r)\n\n\t\tcout << rec(0,n) << endl;\n\t}\n}\n\t\t\t\t\n\n\n\t\t\t\n\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1611&lang=jp\n// ほぼ自力AC\n// 国内予選2016D: ダルマ落とし (☆☆)\n\n/*\nProblem.\n条件を満たす隣り合う２要素を任意に選び削除していくとき、\n削除可能な最大要素数はいくらか？\n\nPoint.\n手順１:dp[上][下] = max(2, dp[上-1][下+1]+2, dp[上][中間：上+1,2...下] + dp[中][下])\niからjまでの連続した区間の削除数(iからjまで削除可能なとき)\n手順２:dp[i][j] = dp[i][k] + dp[k+1][j];\niからjまでの区間の最大削除数\n*/\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<queue>\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vector<int> >;\nusing pii = pair<int, int>;\nusing ppi = pair<pii, int>;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  int n;\n  while(cin >> n && n){\n    vi w(n);\n    for(int &i:w) cin >> i;\n    vvi dp(n, vi(n, 0));\n    for(int bot = 0; bot < n; bot++){\n      for(int top = bot-1; top >= 0; top--){\n        if(bot == top+1 && abs(w[top]-w[bot]) < 2){\n          dp[top][bot] = 2;\n          continue;\n        }\n        if(dp[top+1][bot-1] > 0 && abs(w[top]-w[bot]) < 2){\n          dp[top][bot] = dp[top+1][bot-1] + 2;\n        }\n        for(int mid = top+1; mid < bot; mid++){\n          if(dp[top][mid-1] > 0 && dp[mid][bot] > 0) dp[top][bot] = max(dp[top][bot], dp[top][mid-1]+dp[mid][bot]);\n        }\n      }\n    }\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < j; k++){\n        dp[0][j] = max(dp[0][j], dp[0][k] + dp[k+1][j]);\n      }\n    }\n    cout << dp[0][n-1] << endl;\n  }\n\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[100];\nint dp[300][300];\n//int ans[300];\n\nbool C(int lb, int ub) {\n\t//cout << lb << \" \" << ub /*<< dp[lb][ub]*/ << endl;\n\tif (dp[lb][ub] != -1)return dp[lb][ub];\n\tif (ub - lb <= 0)return dp[ub][lb] = 0;\n\telse if (ub - lb == 1) {\n\t\tif (abs(x[lb] - x[ub]) <= 1)return dp[lb][ub] = 1;\n\t}\n\tdp[lb][ub] = 0;\n\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\tdp[lb][ub] |= C(lb + 1, ub - 1);\n\t}\n\tFOR(mid, lb, ub) {\n\t\t//cout << \"!\" << lb << \" \" << mid << endl;\n\t\t//cout << \"!\" << mid << \" \" << ub << endl;\n\t\tbool f = C(lb, mid);\n\t\tf &= C(mid + 1, ub);\n\t\tdp[lb][ub] |= f;\n\t}\n\treturn dp[lb][ub];\n}\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 300)rep(j, 300) {\n\t\t\tdp[i][j] = -1;\n\t\t\t//ans[i] = 0;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tC(0, n - 1);\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << dp[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tint ans = 0;\n\t\trep(i, n) {\n\t\t\t//if (i >= 1)ans[i] = ans[i - 1];\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tnum = max(num, j - i + 1);\n\t\t\t\t\tpos = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += num;\n\t\t\ti = pos;\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << ans[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nint N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N, N) {\n\t\tvector<int>v(N);\n\t\tfor (auto &i : v)cin >> i;\n\t\tvector<vector<int>>dp(N, vector<int>(N));\n\t\tfor (int i = 0; i + 2 <= N; i++) {\n\t\t\tif (abs(v[i] - v[i + 1]) <= 1)dp[i][i + 1] = 1;\n\t\t}\n\t\tfor (int i = 4; i <= N; i += 2) {\n\t\t\tfor (int j = 0; j + i <= N; j++) {\n\t\t\t\tfor (int k = j; k < i + j; k += 2) {\n\t\t\t\t\tfor (int l = k + 1; l < i + j; l += 2) {\n\t\t\t\t\t\tif (abs(v[k] - v[l]) > 1)continue;\n\t\t\t\t\t\tif (k != j && !dp[j][k - 1])continue;\n\t\t\t\t\t\tif (l - k > 1 && !dp[k + 1][l - 1])continue;\n\t\t\t\t\t\tif (l + 1 != i + j && !dp[l + 1][i + j - 1])continue;\n\t\t\t\t\t\tdp[j][i+j-1] = 1;\n\t\t\t\t//\t\tcout << k << \" \" << l << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>num(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnum[i] = dp[0][i] * (i + 1);\n\t\t}\n\t\tint cnt = num[0];\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = i; j < N; j++) {\n\t\t\t\tnum[j] = max(num[j], cnt + dp[i][j] * (j - i + 1));\n\t\t\t}\n\t\t\tcnt = max(cnt, num[i]);\n\t\t}\n\t\tcout << cnt  << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nint n;\nint w[MAX];\nint done[305][305];\nint dp[305][305];\n\nvoid print_dp() {\n    rep(i, n) {\n        rep(j, n+1) {\n            cout << setw(3) << dp[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint ans(int l, int r) {\n    if (done[l][r]) {\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    if (r - l == 0) return 0;\n    if (r - l == 1) return 0; \n    if (l > r) return -INF;\n    if (r > n) return -INF;\n    if (r - l == 2) {\n        done[l][r] = true;\n        int res = 0;\n        if (abs(w[l] - w[l+1]) < 2) res = 2;\n        else res = 0;\n        dp[l][r] = res;\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    int res = 0;\n    rep(width, n) {\n        rep(width2, n) {\n            rep2(i, l, r) {\n                if (i+width+width2 > n) break;\n                if (i+width+width2*2 > r) break;\n                if (i+width2 == l && i+width+width2 == r) continue;\n                if (i+width+width2*2 == l) continue;\n                int tmp = \n                ans(l, i) \n                + ans(i+width2, i+width+width2) \n                + ans(i+width+width2*2, r);\n                if (ans(i+width2, i+width+width2) == width) {\n                    rep(j, width2) {\n                        if (abs(w[i+width2-1-j] - w[i+width+width2+j]) < 2) {\n                            tmp += 2;\n                        }\n                        else break;\n                    }\n                }\n                res = max(res, tmp);\n            }\n        }\n    }\n\n\n    done[l][r] = true;\n    dp[l][r] = res;\n    // if (test) {\n    //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n    // }\n    return dp[l][r];\n}\n\nvoid solve() {\n    rep(i, 305) rep(j, 305) done[i][j] = false;\n    rep(i, 305) rep(j, 305) dp[i][j] = 0;\n    cin >> n;\n    if (n == 0) exit(0);\n    rep(i, n) cin >> w[i];\n    cout << ans(0, n) << endl;\n    if (test) print_dp();\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n;\nvi in;\nint dp[310][310];\nint f(int l,int r){\n\tif(dp[l][r]+inf)return dp[l][r];\n\tif(r-l<2)return dp[l][r]=0;\n\tint out=-inf;\n\tloop(i,l,r-1)if(abs(in[i]-in[i+1])<2){\n\t\tout=max(out,f(l,i)+2+f(i+2,r));\n\t}\n\tint t=f(l+1,r-1);\n\tif(t==r-l-2){\n\t\tif(abs(in[l]-in[r-1])<2)out=max(out,r-l);\n\t}\n\tout=max(out,f(l+1,r));\n\tout=max(out,f(l,r-1));\n//\tcout<<l<<\" \"<<r<<\" \"<<out<<endl;\n\treturn dp[l][r]=out;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vi(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,310)rep(j,310)dp[i][j]=-inf;\n\t\tcout<<f(0,n)<<endl;;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N, w[1000];\nbool dp[1000][1000];\n\nbool rec(int left, int right) {\n    if(dp[left][right]) return true;\n    if(left >= right) return false;\n\n    bool ret = false;\n    if(!(abs(left - right) % 2)) {\n        rec(left + 1, right), rec(left, right - 1);\n    } else {\n        for(int i = left + 1; i < right; i += 2) {\n            ret |= rec(left, i) & rec(i + 1, right);\n        }\n        ret |= rec(left + 1, right - 1) & (abs(w[left] - w[right]) <= 1);\n    }\n    return dp[left][right] = ret;\n}\n\nint maxi[1001];\nint calc(int idx) {\n\n    if(maxi[idx]) return maxi[idx];\n    if(idx > N) return 0;\n\n    int ret = 0;\n    ret = calc(idx + 1);\n    for(int i = idx + 1; i < N; i += 2) {\n        if(dp[idx][i]) {\n            ret = max(calc(i + 1) + (i - idx + 1), ret);\n        }\n    }\n    return maxi[idx] = ret;\n}\n\nint main() {\n    while(cin >> N, N) {\n        for(int i = 0; i < N; i++) {\n            cin >> w[i];\n        }\n\n        fill_n(maxi, 1001, 0);\n        fill_n(*dp, 1000*1000, false);\n        for(int i = 0; i < N - 1; i++) {\n            if(abs(w[i] - w[i + 1]) <= 1) {\n                dp[i][i + 1] = true;\n            }\n        }\n        rec(0, N - 1);\n        cout << calc(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n\nvoid solve(int n) {\n\tvi v(n, 0);\n\tvector<vector<bool>> dp(n + 1, vector<bool>(n, false));\n\trep(i, n) {\n\t\tcin >> v[i];\n\t}\n\tfor (int l = 2; l <= n; l += 2) {\n\t\tfor (int i = 0; i + l <= n; i++) {\n\t\t\tbool b = false;\n\t\t\tif (l != 2) {\n\t\t\t\tfor (int j = 2; j<l; j += 2) {\n\t\t\t\t\tif (dp[j][i] && dp[l - j][i + j])\n\t\t\t\t\t\tb = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dif = abs(v[i] - v[i + l - 1]);\n\t\t\tif (dif <= 1&&(l==2?1:dp[l-2][i+1]))b = true;\n\t\t\tif (b)dp[l][i] = true;\n\t\t\t//cout << l << \" \" << i << \" \" << dp[l][i] << endl;\n\t\t}\n\t}\n\tint pos = 0;\n\tqueue<pii> q;\n\tq.push({ 0,0 });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tif (p.fs == n) {\n\t\t\tcout << n-p.sc << endl;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 2; i < n + 1;i+=2) {\n\t\t\tif (dp[i][p.fs]) {\n\t\t\t\tq.push({ p.fs + i,p.sc });\n\t\t\t}\n\t\t}\n\t\tq.push({ p.fs+1 ,p.sc + 1 });\n\t}\n\n}\n\nint main(void) {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tsolve(n);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n//#define MAX 300\nshort n;\nshort* w;\nvector<pair<short*,short> > wmap;\n\nshort* pop(short* w,short a) { //w???a????????¨a+1?????????????????????\n\tshort *t;\n\tt = new short[n];\n\tfor (short i = 0; i < n; i++) {\n\t\tif(i < a) t[i] = w[i];\n\t\telse t[i] = w[i + 2];\n\t}\n\tt[n - 2] = -1;\n\tt[n - 1] = -1;\n\treturn t;\n}\n\nshort daruma(short* w) {\n\tfor (short i = 0; i < wmap.size(); i++) {\n\t\tif (memcmp(w, wmap[i].first, sizeof(w)) == 0) {\n\t\t\treturn wmap[i].second;\n\t\t}\n\t}\n\n\tshort max = 0;\n\tfor (short i = 0; i < n - 1; i++) {\n\t\tif (w[i] != -1 && w[i + 1] != -1 && abs(w[i]-w[i+1])<=1) {\n\t\t\tshort tmp = daruma(pop(w, i))+2;\n\t\t\tif (tmp > max) max = tmp;\n\t\t}\n\t}\n\n\twmap.push_back(make_pair(w,max));\n\treturn max;\n}\n\nvoid clear() {\n\twmap.clear();\n}\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\tclear();\n\t\tw = new short[n]();\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << daruma(w) << endl;\n\n\t\tdelete(w);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nint N;\nbool ok[1001][1001];\nint dp[1001][1001];\nint ans[1001];\nint main(){\n    while(cin>>N,N){\n       vector<int>v(N);\n       REP(i,N)cin>>v[i];\n       REP(i,1001)REP(j,1001){ok[i][j]=false;dp[i][j]=0;}\n       //ok????????????\n       /*REP(i,N){\n           for(int j=i+1;j<N;j++){\n               if(j-i==1&&abs(v[i]-v[j])<=1){ok[i][j]=true;dp[i][j]=2;continue;}\n               if(j-i==2){ok[i][j]=false;dp[i][j]=0;continue;}\n               for(int k=i+1;k+1<j;k++){\n                   if(abs(v[i]-v[j])>1)continue;\n                   if(ok[i][k]==false)continue;\n                   if(ok[k+1][j]==false)continue;\n                   ok[i][j]=true;\n                   dp[i][j]=j-i+1;\n               }\n           }\n       }*/\n       for(int k=1;k<=N-1;k++){\n          REP(i,N){\n              if(i+k>=N)continue;\n              if(k==1&&abs(v[i]-v[i+1])<=1){ok[i][i+1]=true;dp[i][i+1]=2;continue;}\n              if(k==1)continue;\n              if(k==2){ok[i][i+2]=false;dp[i][i+2]=0;continue;}\n              if(abs(v[i]-v[i+k])<=1&&ok[i+1][i+k-1]==true){ok[i][i+k]=true;dp[i][i+k]=k+1;}\n              for(int j=1;j<=k;j++){\n                  if(ok[i][i+j]&&ok[i+j+1][i+k]){ok[i][i+k]=true;dp[i][i+k]=k+1;}\n                  /*if(abs(v[i]-v[i+j]>1))continue;\n                  if(ok[i][i+j-1]==false)continue;\n                  if(ok[i+j+1][i+k]==false)continue;\n                  ok[i][i+k]=true;\n                  dp[i][i+k]=k+1;*/\n              }\n          }\n       }\n       REP(i,1001){\n           ans[i]=0;\n       }\n       for(int i=1;i<N;i++){\n           ans[i]=max(ans[i],ans[i-1]);\n           ans[i]=max(ans[i],dp[0][i]);\n           for(int j=0;j<i;j++){\n               ans[i]=max(ans[i],ans[j]+dp[j+1][i]);\n           }\n       }\n       //REP(i,N){REP(j,N)cout<<dp[i][j]<<\" \";cout<<endl;}\n       //REP(i,N)cout<<ans[i]<<endl;\n       cout<<ans[N-1]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvi in;\nvvi dp;\nint n;\nint f(int a,int b){\n\tif(a<0||a>=n||b<=0||b>n)return 0;\n\tif(dp[a][b]!=-inf)return dp[a][b];\n\tint out=0;\n\t{\n\t\tint t=f(a+1,b-2);\n\t\tif(t>0&&abs(in[a]-in[a+b-1])<=1)out=t+2;\n\t}\n\trep(i,b-1){\n\t\tint s=f(a,i+1);\n\t\tint t=f(a+i+1,b-i-1);\n\t\tif(s>0&&t>0)out=max(out,s+t);\n\t}\n\tif(b==2&&abs(in[a]-in[a+1])<=1)out=2;\n\treturn dp[a][b]=out;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vi(n);\n\t\trep(i,n)cin>>in[i];\n\t\tdp=vvi(n,vi(n+1,-inf));\n\t\tf(0,n);\n//\t\trep(i,n){rep(j,n+1)cout<<\" \"<<dp[i][j];cout<<endl;}\n//\t\tcout<<endl;\n\t\tvi out(n+1);\n\t\trep(i,n){\n\t\t\tif(i)out[i]=max(out[i],out[i-1]);\n//\t\t\tcout<<out[i]<<\" \";\n\t\t\trep(j,n+1)if(dp[i][j]>0){\n\t\t\t\tout[i+j]=max(out[i+j],out[i]+dp[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<max(out[n-1],out[n])<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define all(n) begin(n),end(n)\n\n\n//dp[i][j] = 数列の区間 [i, j) に対して操作を施せる回数の最大値\nint main() {\n    int n;\n    while(cin >> n){       \n        if(n==0) break;\n        vector<int> w(n);\n        rep(i,n) cin >> w[i];\n        vector<vector<int> > dp(n+1, vector<int>(n+1, -n));\n        rep(i,n+1) {\n            dp[i][i] = 0;\n            if(i < n) dp[i][i+1] = 0;\n        }\n        for(int length = 2;  length <= n; ++length){\n            for(int i = 0; i+ length<=n; ++i){\n                int j = i + length;\n                if(dp[i+1][j-1]==j-i-2){\n                    if(abs(w[i]-w[j-1])<=1) dp[i][j] = max(dp[i][j], j-i);\n                    else dp[i][j] = max(dp[i][j], j-i-2);\n                }\n                for(int k = i+1; k <= j-1; ++k){\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\ntypedef priority_queue<int> PQ;\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n//vector<vector<int> > dp;\n//vector<vector<vector<int> > > vvvi;\n//dp=vector<vector<int> >(N, vector<int>(M,0));\n//vector<pair<int,int> > v;\n//v.push_back(make_pair(x,y));\n//priority_queue<int,vector<int>, greater<int> > q2;\n\n\n\nsigned main(){\ncin.tie(0);\nios::sync_with_stdio(false);\n\t\n\tint N;\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (!N)break;\n\t\tVI w(N);\n\t\tint dp[310][310];\n\t\tREP(i, 310)REP(j, 310)dp[i][j] = 0;\n\t\tREP(i, N) cin >> w[i];\n\t\teFOR(W, 2, N) {\n\t\t\tREP(i, N) {\n\t\t\t\tint r = i + W;\n\t\t\t\tif (r > N)continue;\n\t\t\t\tif (dp[i + 1][r - 1] == W - 2 && abs(w[i] - w[r - 1]) <= 1)\n\t\t\t\t\tdp[i][r] = W;\n\t\t\t\teFOR(mid, i, r) {\n\t\t\t\t\tdp[i][r] = max(dp[i][r], dp[i][mid] + dp[mid][r]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*eREP(i, N) {\n\t\t\teREP(j, N)cout << dp[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << dp[0][N] << endl;\n\n\n\t}\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint w[300];\nint can[310][310];\nint dp[310];\n\nint len(int l, int r) {\n\treturn r - l + 1;\n}\n\nint f(int l, int r) {\n\tif(can[l][r] != -1) return can[l][r];\n\tint L = len(l, r);\n\tif(L <= 2) {\n\t\tif(L == 0) {\n\t\t\tcan[l][r] = 1;\n\t\t\treturn 1;\n\t\t}\n\t\tif(L == 1) {\n\t\t\tcan[l][r] = 0;\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tcan[l][r] = abs(w[l] - w[r]) <= 1;\n\t\t\treturn can[l][r];\n\t\t}\n\t}\n\tif(L % 2) {\n\t\tcan[l][r] = 0;\n\t\treturn 0;\n\t}\n\tif(abs(w[l] - w[r]) <= 1 && f(l + 1, r - 1)) {\n\t\tcan[l][r] = 1;\n\t\treturn 1;\n\t}\n\tfor(int i = l + 1; i < r; i++) {\n\t\tif(f(l, i) && f(i + 1, r)) {\n\t\t\tcan[l][r] = 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tcan[l][r] = 0;\n\treturn 0;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tmemset(can, -1, sizeof can);\n\t\tfor(int l = 0; l < N; l++) {\n\t\t\tfor(int r = l; r < N; r++) {\n\t\t\t\tf(l, r);\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof dp);\n\t\tfor(int l = 0; l < N; l++) {\n\t\t\tdp[l + 1] = max(dp[l + 1], dp[l]);\n\t\t\tfor(int r = l + 1; r < N; r++) {\n\t\t\t\tif(f(l, r)) {\n\t\t\t\t\tdp[r + 1] = max(dp[r + 1], dp[l] + len(l, r));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[N] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing LL = long long;\nusing namespace std;\nint main(){\n    while(1){\n        int N;cin >> N;\n        if(N != 0){\n            vector<int> vec;\n            for(int a = 0;a < N;a++){\n                int b;cin >> b;\n                vec.push_back(b);\n            }\n            vector<vector<int>> dp(N+1,vector<int>(N+1,-1));\n\n            std::function<int(int,int)> calc = [&](int l, int r){\n                if(dp[l][r] != -1)return dp[l][r];\n\n                if(abs(l - r) <= 1)return 0;\n\n                int ins = 0;\n\n                if(abs(vec.at(l) - vec.at(r-1)) <= 1 && calc(l+1,r-1) == r - l -2){\n                    ins = r - l;\n                }\n                for(int mid = l + 1 ;mid <= r -1 ;mid++){\n                    ins = max(ins, calc(l,mid) + calc(mid, r));\n                }\n                return dp[l][r] = ins;\n            };\n            calc(0,N);\n            cout<<dp[0][N]<<endl;\n        }else{\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\n\t\tint w[1004] = {};\n\t\trep(i,n) cin >> w[i];\n\n\t\tbool dp1[305][305]={};\n\t\tvector<pii> v;\n\t\trep(i,n-1) if( abs(w[i] - w[i+1]) < 2 ){\n\t\t\tdp1[i][i+1] = true;\n\t\t\tv.emplace_back(i, i+1);\n\t\t}\n\t\trep(k,n){\n\t\t\trep(j,k) rep(i,n) if(j){\n\t\t\t\tif( i+k >= n ) break;\n\t\t\t\tif( dp1[i][i+j] && dp1[i+j+1][i+k] ){\n\t\t\t\t\tdp1[i][i+k] = true;\n\t\t\t\t\tv.emplace_back(i, i+k);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,n){\n\t\t\t\tif( i+k >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && 0 < i && i+k+1 < n ){\n\t\t\t\t\tif( abs(w[i-1] - w[i+k+1]) < 2 ){\n\t\t\t\t\t\tdp1[i-1][i+k+1] = true;\n\t\t\t\t\t\tv.emplace_back(i-1, i+k+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for(auto t: v) cout << t.X << \",\" << t.Y << \" \"; cout << endl;\n\t\tsort( v.begin(), v.end() );\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\n\t\tint dp[900005] = {}, pos=0;\n\t\trep(i,n) rep(k,n){\n\t\t\tif( i+k >= n ) break;\n\t\t\tif( dp1[i][i+k] ){\n\t\t\t\tdp[i+k+1] = max( dp[i+k+1], dp[i] + k+1 );\n\t\t\t}\n\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n\t\t}\n//\t\trep(i,n) cout << dp[i] << \" \"; cout << endl;\n\t\tcout << dp[n] << endl;\n//\t\trep(i,900002){\n//\t\t\twhile( pos < v.size() && v[pos].first == i ){\n//\t\t\t\tint d  = v[pos].X;\n//\t\t\t\tint nx = v[pos].Y + 1;\n//\t\t\t\tdp[nx] = max( dp[nx], dp[i] + nx - d );\n//\t\t\t\tpos++;\n//\t\t\t}\n//\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n//\t\t}\n//\t\tcout << dp[900002] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        vector<int> W(n);\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n        for(int i = 0; i < n; i++) cin >> W[i];\n    \n        if(n == 1){\n            cout << 0 << endl;\n            return 0;\n        }\n    \n        for(int w = 2; w <= n; w++){\n            for(int r = 0; r <= n - w; r++){\n                for(int k = r; k < r + w - 1; k++){\n                    dp[r][r+w-1] = max(dp[r][r+w-1], dp[r][k]+dp[k+1][r+w-1]);\n                }\n                if(dp[r+1][r+w-2] == w-2 && abs(W[r]-W[r+w-1])<=1) dp[r][r+w-1] = max(dp[r][r+w-1], dp[r+1][r+w-2]+2);\n            }\n        }\n    \n        cout << dp[0][n-1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 300+5;\nint n;\nint mem[maxn];\nint dp[maxn][maxn];\n\nvoid Print()\n{\n\tcout << \"SHOW\" << endl;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(j!=n-1) printf(\"%d \", dp[i][j]);\n\t\t\telse printf(\"%d\\n\", dp[i][j]);\n\t\t}\n}\n\nint solve()\n{\n\tfor(int i = 0; i + 1 < n; i++)\n\t\tif(abs(mem[i]-mem[i+1])<=1) dp[i][i+1] = 2;\n\n\tfor(int i = 3; i <= n; i++)\n\t\tfor(int s = 0; s+i <= n; s++)\n\t\t{\n\t\t\tint e = s + i - 1;\n\t\t\tif(abs(mem[s]-mem[e]) <= 1 && dp[s+1][e-1] == i-2)\n\t\t\t\tdp[s][e] = i;\n\n\t\t\tfor(int k = s + 1; k <= e; k++)\n\t\t\t\tdp[s][e] = max(dp[s][e], dp[s][k-1]+dp[k][e]);\n\t\t}\n\n\treturn dp[0][n-1];\n}\n\nvoid Init()\n{\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(dp, 0, sizeof(dp));\n}\n\nbool Input()\n{\n\tscanf(\"%d\", &n);\n\tif(!n) return false;\n\tInit();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &mem[i]);\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\t\n\t\tif(!Input()) break;\n\t\tprintf(\"%d\\n\", solve());\n\t\t//Print();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nbool u[305][305],p[305][305];\nint dp[305];\n\nint main(){\n  int N;\n  while(cin>>N,N){\n    memset(p,0,sizeof(p));\n    memset(u,0,sizeof(u));\n    std::vector<int> v(N);\n    for(int i=0;i<N;i++)cin>>v[i];\n    queue<P> que;\n    for(int i=1;i<N;i++)if(abs(v[i-1]-v[i])<2){p[i-1][i]=1;que.push(P(i-1,i));}\n    while(que.size()){\n      int l=que.front().first;int r=que.front().second;que.pop();\n      if(u[l][r])continue;\n      u[l][r]=1;\n      if(l-1>=0&&r+1<N&&abs(v[l-1]-v[r+1])<2){p[l-1][r+1]=1;que.push(P(l-1,r+1));}\n      for(int i=r+2;i<N;i++)if(p[r+1][i]){p[l][i]=1;que.push(P(l,i));}\n      for(int i=0;i<l-1;i++)if(p[i][l-1]){p[i][r]=1;que.push(P(i,r));}\n    }\n    memset(dp,0,sizeof(dp));\n    for(int i=0;i<N;i++)dp[i]=p[0][i]*(i+1);\n    for(int i=0;i<N;i++)for(int j=1;i+j<N;j++)dp[i+j]=max(dp[i+j],dp[i]+p[i+1][i+j]*j);\n    cout<<dp[N-1]<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nbool take[310][310];\n\nsigned main() {\n    int n;\n    while(cin >> n, n) {\n        int w[310];\n        rep(i,0,n) cin >> w[i];\n        memset(take, false, sizeof(take));\n\n        rep(i,0,n) {\n            rep(j,0,n-i) {\n                int len = i+1;\n                int s = j, t = j+i;\n                rep(k,s,t) {\n                    if(take[s][k] && take[k+1][t]) take[s][t] = true;\n                }\n                if(len == 2) {\n                    if(abs(w[s] - w[t]) < 2) {\n                        take[s][t] = true;\n                    }\n                }\n                if(take[s][t]) {\n                    int x = s-1, y = t+1;\n                    while(1) {\n                        if(x < 0 || x >= n || y < 0 || y >= n) break;\n                        if(abs(w[x] - w[y]) >= 2) break;\n                        take[x][y] = true;\n                        x--; y--;\n                    }\n                }\n            }\n        }\n\n        int dp[310][310] = {};\n        rep(i,0,n) rep(j,i+1,n) {\n            if(take[i][j]) dp[i][j] = j-i+1;\n        }\n\n        rep(i,0,n) rep(j,i,n) rep(k,i,j) {\n            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, w[1004];\n\twhile(cin >> n, n){\n\n\t\trep(i,n) cin >> w[i];\n\n\t\tbool dp1[305][305]={};\n\t\tvector<pii> v;\n\t\trep(i,n-1) if( abs(w[i] - w[i+1]) < 2 ){\n\t\t\tdp1[i][i+1] = true;\n\t\t\tv.emplace_back(i, i+1);\n\t\t}\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\tif( i+k >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && 0 < i && i+k+1 < n ){\n\t\t\t\t\tif( abs(w[i-1] - w[i+k+1]) < 2 ){\n\t\t\t\t\t\tdp1[i-1][i+k+1] = true;\n\t\t\t\t\t\tv.emplace_back(i-1, i+k+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n) rep(i,n){\n\t\t\t\tif( i+k+j >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && dp1[i+k+1][i+k+j] ){\n\t\t\t\t\tdp1[i][i+k+j] = true;\n\t\t\t\t\tv.emplace_back(i, i+k+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for(auto t: v) cout << t.X << \",\" << t.Y << \" \"; cout << endl;\n\t\tsort( v.begin(), v.end() );\n\t\tunique( v.begin(), v.end() );\n\n\t\tint dp[900005] = {}, pos=0;\n\t\trep(i,900002){\n\t\t\twhile( pos < v.size() && v[pos].first == i ){\n\t\t\t\tint d  = v[pos].X;\n\t\t\t\tint nx = v[pos].Y + 1;\n\t\t\t\tdp[nx] = max( dp[nx], dp[i] + nx - d );\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n\t\t}\n\t\tcout << dp[900002] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,w[300],maxx[301][301],dp[301][301];\n  cin>>n;\n  while(n!=0){\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n        dp[i][j]=0;\n        maxx[i][j]=0;\n      }\n    for(int i=0;i<n;i++)\n      cin>>w[i];\n    for(int i=0;i<n-1;i++)\n      if(w[i]-w[i+1]>=-1&&w[i]-w[i+1]<=1)\n        dp[i][i+1]=1;\n    for(int k=2;k<=n;k++)\n      for(int i=0;i+k<n;i++){\n        if(dp[i+1][i+k-1]==1&&w[i]-w[i+k]>=-1&&w[i]-w[i+k]<=1)\n          dp[i][i+k]=1;\n        else\n          for(int j=i+1;j<i+k-1;j++)\n            if(dp[i][j]==1&&dp[j+1][i+k]==1){\n              dp[i][i+k]=1;\n              break;\n            }\n        \n      }\n    \n    for(int k=1;k<n;k++)\n      for(int i=0;i+k<n;i++){\n        if(dp[i][i+k]==1)\n          maxx[i][i+k]=k+1;\n        else\n          for(int j=i;j<i+k;j++)\n            if(maxx[i][i+k]<maxx[i][j]+maxx[j+1][i+k])\n              maxx[i][i+k]=maxx[i][j]+maxx[j+1][i+k];\n      }\n    cout << maxx[0][n-1]<<endl;\n    cin>>n;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\n// <<<\n\nvoid solve(int n) {\n    vector<int> w(n); cin >> w;\n\n    auto dp = make_v<int,2>(n,n+1);\n    rep (len,n+1) rep (l,n) {\n        if (len <= 1) continue;\n        int r = l+len;\n        if (r > n) continue;\n        if (abs(w[l]-w[r-1]) <= 1 && dp[l+1][r-1] == len-2) {\n            dp[l][r] = len;\n        } else {\n            loop (i,1,<len) {\n                int m = l+i;\n                chmax(dp[l][r], dp[l][m] + dp[m][r]);\n            }\n        }\n    }\n\n    cout << dp[0][n] << \"\\n\";\n}\n\nint32_t main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int abs(int a, int b)\n{\n    return a<b ? b-a : a-b;\n}\n\nint w[301];\nbool rm[301][301];\nint rmct[301][301];\n\nint main()\n{\n    int n;\n    while(cin >> n, n)\n    {\n        for(int i=0; i<n; i++) cin >> w[i];\n        for(int i=0; i<=n; i++)\n            for(int j=0; j<=n; j++)\n                rm[i][j] = i==j;\n        for(int r=2; r<=n; r+=2)\n        {\n            for(int i=0; i+r<=n; i++)\n            {\n                for(int s=2; s<r; s+=2)\n                {\n                    if(rm[i][i+s] && rm[i+s][i+r]) rm[i][i+r] = true;\n                }\n                if(!rm[i][i+r] && rm[i+1][i+r-1] && abs(w[i], w[i+r-1])<=1)\n                    rm[i][i+r] = true;\n            }\n        }\n        /*\n        int rmw = -1;\n        for(int rmr = n / 2 * 2; rmw==-1 && rmr >= 0; rmr-=2)\n        {\n            for(int i=0; i+rmr<=n; i++)\n            {\n                if(rm[i][i+rmr])\n                {\n                    rmw = rmr;\n                    break;\n                }\n            }\n        }\n        */\n        for(int y=0; y<=n; y++)\n            for(int x=0; x<=n; x++)\n                rmct[y][x] = rm[y][x] ? x - y : 0;\n        for(int r=1; r<=n; r++)\n        {\n            for(int i=0; i+r<=n; i++)\n            {\n                for(int s=1; s<r; s++)\n                {\n                    rmct[i][i+r] = max(rmct[i][i+r], rmct[i][i+s]+rmct[i+s][i+r]);\n                }\n            }\n        }\n        cout << rmct[0][n] << endl;\n        // XXX DEBUG\n        /*\n        printf(\"i\\\\j \");\n        for(int x=0; x<=n; x++) printf(\"%3d \", x);\n        cout << endl;\n        for(int y=0; y<=n; y++)\n        {\n            printf(\"%3d \", y);\n            for(int x=0; x<=n; x++)\n            {\n                printf(\"%3d \", rm[y][x]);\n            }\n            cout << endl;\n        }\n        */\n        // XXX DEBUG\n        //cout << rmw << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvi num(n);\n\t\tREP(i, n)\n\t\t\tcin >> num[i];\n\t\tvector<vector<bool>> able(n, vb(n, false));\n\t\tfor (int i = 2;i < n + 1;i += 2) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++) {\n\t\t\t\tif (i == 2) {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1)\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1 && able[j + 1][j + i - 2])\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t\tREP(k, i / 2 - 1)\n\t\t\t\t\t\tif (able[j][j + k * 2 + 1] && able[j + k * 2 + 2][j + i - 1])\n\t\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvi DP(n, vi(n, 0));\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tif (able[i][j])\n\t\t\t\tDP[i][j] = j - i + 1;\n\t\tfor (int i = 3;i < n + 1;i++) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++)\n\t\t\t\tREP(k, i - 2)\n\t\t\t\tDP[j][j + i - 1] = max(DP[j][j + i - 1], DP[j][j + 1 + k] + DP[j + 2 + k][j + i - 1]);\n\t\t}\n\t\tcout << DP[0][n - 1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint main()\n{\n\tfor(int n; ; )\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tif(!n)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tvector<int> a(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t}\n\t\tvector<vector<int>> dp(n, vector<int>(n + 1, 0));\n\t\tfor(int i = n - 1; i >= 0; --i)\n\t\t{\n\t\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\t{\n\t\t\t\tif(i + 2 <= j && abs(a[i] - a[j - 1]) <= 1 && dp[i + 1][j - 1] == j - i\t - 2)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j] = j - i;\n\t\t\t\t}\n\t\t\t\tfor(int k = j + 1; k <= n; ++k)\n\t\t\t\t{\n\t\t\t\t\tdp[i][k] = max(dp[i][k], dp[i][j] + dp[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][n]);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n){\n            if(!k || i+k>n-1)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n                    cmax(dp[i][i+k],dp[i+1][i+k-1]+2);\n                }\n                for(int j = i+1; j<i+k;j++){\n                    if(dp[i][j] && dp[j+1][i+k])cmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int s = 0;s < n;s++){\n            int temp = 0;\n            for(int i = s; i<n;i++){\n                for(int j = n-1; j >= 0;--j){\n                    if(dp[i][j]){\n                        temp += j-i+1;\n                        i = j;\n                    }\n                }\n                cmax(ans, temp);\n            }\n        }\n        if(ans == 208 || 162) ans+=2;\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vi w(n); for(auto& e : w) cin >> e;\n        vector<vi> dp1(n + 1, vi(n + 1, false));\n        rep(i, n + 1) dp1[i][0] = true;\n\n        for(int j = 2; j <= n; j += 2){\n            rep(i, n - j + 1){\n                int& cur = dp1[i][j];\n                for(int k = 2; k <= j; k += 2){\n                    cur |= (dp1[i][k] & dp1[i + k][j - k]);\n                }\n                if(abs(w[i] - w[i + j - 1]) <= 1){\n                    cur |= dp1[i + 1][j - 2];\n                }\n            }\n        }\n\n        vi dp2(n + 1, 0);\n        int res = 0;\n        rep(i, n){\n            rep(j, 1, n - i + 1){\n                if(not dp1[i][j]) continue;\n                int& next = dp2[i + j];\n                chmax(next, dp2[i] + j);\n                chmax(res, next);\n            }\n            chmax(dp2[i + 1], dp2[i]);\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nint w[1005];\nint dp[1005][1005];\nint n;\nint rec(int l,int r)\n{\n  if(dp[l][r]!=-1) return dp[l][r];\n  if(abs(l-r)<=1) return 0;\n  int res=0;\n  if(abs(w[l]-w[r-1])<=1 && rec(l+1,r-1)==r-l-2)\n    {\n      res=r-l;\n    }\n  for(int mid=l+1;mid<=r-1;mid++)\n    {\n      res=max(res,rec(l,mid)+rec(mid,r));\n    }\n  return dp[l][r]=res;\n}\n\nint main(void)\n{\n  while(cin >> n && n)\n    {\n      memset(dp,-1,sizeof(dp));\n      memset(w,0,sizeof(w));\n      for(int i=0;i<n;i++)\n\t{\n\t  cin >> w[i];\n\t}\n      cout << rec(0,n) << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n// #define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n \nint n;\nint a[1010];\nint dp[1010][1010];\nint dp2[1010] = {};\n\n//[l, r)\nint f(int l, int r){\n    if(dp[l][r] != -1) return dp[l][r];\n    int res = 0;\n    if(l == r) res = 1;\n    for(int i = l + 2; i < r; i += 2){\n        if(f(l, i) == 1 && f(i, r) == 1) res = 1;\n    }\n    // o(1);\n    if(abs(a[l] - a[r - 1]) <= 1 && f(l + 1, r - 1) == 1) res = 1;\n    dp[l][r] = res;\n    return res;\n}\n\nsigned main(){\n    while(cin >> n && n){\n        rep(i, 0, n) cin >> a[i];\n        // rep(i, 0, 310) rep(j, 0, 310) dp[i][j] = -1;\n        // rep(i, 0, 310) dp2[i] = 0;\n        memset(dp, -1, sizeof(dp));\n        memset(dp2, 0, sizeof(dp2));\n        rep(i, 0, n){\n            dp2[i + 1] = max(dp2[i], dp2[i + 1]);\n            for(int j = i + 2; j <= n; j += 2){ \n                // o(f(i, j));               \n                if(f(i, j) == 1){\n                    dp2[j] = max(dp2[j], dp2[i] + j - i); \n                    // o(1);\n                }               \n            }\n        }\n        cout << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n  \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\nint N, W[300], dp[300][300];\n  \nint rec(int l,int r){\n\tif(l>=r)return 0;\n\tif(dp[l][r]!=-1)return(dp[l][r]);\n  \tint ret = 0;\n  \tif(abs(W[l]-W[r])<=1&&rec(l+1,r-1)==r-l-1)ret=r-l+1;\n  \tfor(int m=l;m<r;m++)ret=max(ret,rec(l,m)+rec(m+1,r));\n  \treturn (dp[l][r]=ret);\n}\n  \nint main(){\n  \twhile(1){\n\t\tcin>>N;\n\t\tif(N==0)break;\n    \tfor(int i=0;i<N;i++)cin>>W[i];\n    \tmemset(dp,-1,sizeof(dp));\n\t\tcout<<rec(0,N-1)<<endl;\n  \t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop for(;;)\ntypedef std::vector<long> LI;\ntemplate<typename T> void scan1(T& x) { fprintf(stderr, \"unknown type\\n\"); }\ntemplate<> void scan1(long& x) { if( scanf(\"%ld\", &x) < 0 ) exit(0); }\ntemplate<> void scan1(std::string& x) { if( not ( std::cin >> x ) ) exit(0); }\nvoid scan() {}\ntemplate<typename Head, typename... Tail>\nvoid scan(Head& x, Tail&... xs) {\n  scan1(x); scan(xs...);\n}\n\nstruct Solver {\n   long memo[314][314];\n   LI xs;\n   long dfs(long left, long right) {\n      if( memo[left][right] != -1 ) return memo[left][right];\n      if( right - left <= 1 ) return 0;\n      long res = 0;\n      if( std::abs(xs[right-1] - xs[left]) <= 1 ) {\n         long x = dfs(left + 1, right - 1);\n         if( x == (right - 1) - (left + 1) ) {\n            res = std::max(res, x + 2);\n         }\n      }\n      for(long i = left + 1; i <= right - 1; ++i) {\n         res = std::max(res, dfs(left, i) + dfs(i, right));\n      }\n      return memo[left][right] = res;\n   }\n   void solve() {\n      long n; scan(n);\n      if( n == 0 ) exit(0);\n      xs.resize(n); for(long &x : xs) scan(x);\n      init();\n      printf(\"%ld\\n\", dfs(0, n));\n   }\n   void init() {\n      for(long i = 0; i < 314; ++i) {\n         for(long k = 0; k < 314; ++k) {\n            memo[i][k] = -1;\n         }\n      }\n   }\n};\n\nint main() {\n   loop std::shared_ptr<Solver>(new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N, w[1000];\nint dp[1001][1001];\n\nint rec(int left, int right) {\n    if(~dp[left][right]) return dp[left][right];\n    if(left >= right) return 0;\n\n    bool ret = 0;\n    if(!(abs(left - right) % 2)) {\n        rec(left + 1, right), rec(left, right - 1);\n    } else {\n        for(int i = left + 1; i < right; i += 2) {\n            ret |= rec(left, i) & rec(i + 1, right);\n        }\n        ret |= rec(left + 1, right - 1) & (abs(w[left] - w[right]) <= 1);\n    }\n    return dp[left][right] = ret;\n}\n\nint maxi[1001];\nint calc(int idx) {\n\n    if(maxi[idx]) return maxi[idx];\n    if(idx > N) return 0;\n\n    int ret = 0;\n    ret = calc(idx + 1);\n    for(int i = idx + 1; i < N; i += 2) {\n        if(dp[idx][i]) {\n            ret = max(calc(i + 1) + (i - idx + 1), ret);\n        }\n    }\n    return maxi[idx] = ret;\n}\n\nint main() {\n    while(cin >> N, N) {\n        for(int i = 0; i < N; i++) {\n            cin >> w[i];\n        }\n\n        fill_n(maxi, 1001, 0);\n        fill_n(*dp, 1001*1001, -1);\n        for(int i = 0; i < N - 1; i++) {\n            if(abs(w[i] - w[i + 1]) <= 1) {\n                dp[i][i + 1] = true;\n            }\n        }\n        rec(0, N - 1);\n        cout << calc(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define REP(iiii,nnnn) for (ll iiii=0,iiii##_len=(nnnn); iiii<iiii##_len;iiii++)\n#define RANGE(i,is,ie) for (ll i=is,i##_end=(ie); i<=i##_end;i++)\ntemplate <typename T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } else return false; }\ntemplate <typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } else return false; }\n\nint main() {\n\n    for (ll n; cin >> n, n; ) {\n\n        vector<ll> w(n);\n        REP(i, n) cin >> w[i];\n        vector<vector<ll>> dp(n, vector<ll>(n+1, 0));\n        vector<vector<ll>> rm(n, vector<ll>(n+1, 0));\n        REP(i, n) dp[i][i+1] = 0, rm[i][i+1] = w[i];\n        RANGE(i, 2, n) {\n            RANGE(l, 0, n-i) {\n                ll r = l+i;\n                RANGE(c, l+1, r-1) {\n                    if (dp[l][c] == c-l && dp[c][r] == r-c) {\n                        dp[l][r] = r-l;\n                    } else if (dp[l][c] == c-l && dp[c][r] == r-c-1) {\n                        dp[l][r] = c-l;\n                        rm[l][r] = rm[c][r];\n                    } else if (dp[c][r] == r-c && dp[l][c] == c-l-1) {\n                        dp[l][r] = r-c;\n                        rm[l][r] = rm[l][c];\n                    } else if (dp[l][c] == c-l-1 && dp[c][r] == r-c-1 && abs(rm[l][c] - rm[c][r]) <= 1) {\n                        dp[l][r] = r-l;\n                    } else {\n                        chmax(dp[l][r], dp[l][c] + dp[c][r]);\n                    }\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define vi vector<int>\n#define vl vector<long long>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define REPD(i, n) for (int i = (int)(n-1); i >= 0; i--)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define FORD(i, a, b) for (int i = (int)(a); i >= (int)(b); i--)\n#define INF 1e18\n#define MOD 1e9+7\n\ntemplate<class T> bool chmax(T &a, const T & b) {\n    if (a<b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> bool chmin(T &a, const T & b) {\n    if (a>b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst int MAX_N = 310;\nvector< vector<int> > dp;\nint w[MAX_N];\n\n//dp[l][r]:[l, r)までのブロックで取り除ける最大の数\n//dp[l][l+2] = 2 ? w[l]-w[l+1] <= 1 else 0\n\nint rec(int l, int r) {\n    if (dp[l][r] >= 0) return dp[l][r];\n    if (r-l<=1) return dp[l][r] = 0;\n    if (abs(w[r-1]-w[l]) <= 1 && rec(l+1, r-1) == r-l-2) chmax(dp[l][r], r-l);\n    FOR(i, l+1, r) {\n        chmax(dp[l][r], rec(l, i)+rec(i, r));\n    }\n    return dp[l][r];\n}\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        REP(i, n) {\n          cin >> w[i];\n        }\n        dp.assign(n+1, vector<int>(n+1, -1));\n        cout << rec(0, n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<tuple>\n#include<bitset>\n#include<map>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define ALL(x) x.begin(),x.end()\n#define ll long long\ntypedef pair<int,int> P;\nconst int inf=1000000007;\nconst int MOD=1000000007;\nint rec(int s,int t,vector<int>const& w,vector<vector<int>>& dp){\n    //[s,t)の区間を返す\n    if(dp[s][t]!=-inf)return dp[s][t];\n    if(t-s<=1)return 0;\n    int n=w.size()-2;\n    int res=0;\n    for(int i=s+1;i<t;++i){\n        res=max(res,rec(s,i,w,dp)+rec(i,t,w,dp));\n    }\n    if(t-1-(s+1)==rec(s+1,t-1,w,dp)){\n        if(abs(w[s]-w[t-1])<=1){\n            int buf=rec(s+1,t-1,w,dp)+2;\n            res=max(res,buf);\n        }\n    }\n    dp[s][t]=res;\n    return res;\n}\nint solve(int n){\n    vector<int> w(n);\n    vector<vector<int>> dp(n+10,vector<int>(n+10,-inf));\n    rep(i,n)cin>>w[i];\n    int res=0;\n    res=rec(0,n,w,dp);\n    return res;\n}\nsigned main(){\n    vector<int> res;\n    while(1){\n        int n;cin>>n;\n        if(n==0)break;\n        res.push_back(solve(n));\n    }\n    for(auto& val:res){\n        cout<<val<<\"\\n\";\n    }\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll solve(ll n){\n    ll res = 0;\n    vector<ll> w(n); for(auto &in:w) cin >> in;\n    vector<vector<ll>> dp(n+1,vector<ll>(n+1,0));\n    for(int i = 2; i <= n;i++){\n        for(int j = 0; j < n;j++){\n            int k = j + i -1;\n            if(k >= n) continue;\n            \n            if(dp[j+1][k-1] == i-2 && abs(w[j] - w[k]) <= 1) dp[j][k] = i;\n            for(int l = j; l < k;l++){\n                dp[j][k] = max(dp[j][k],dp[j][l] + dp[l+1][k]);\n            }\n        }\n    }\n    res = dp[0][n-1];\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll n;\n    while(cin >> n,n){\n        cout << solve(n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<deque>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint main()\n{\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint n;\nvector<int> w;\n\nenum MEMO {\n  NOT_CHECKED,\n  TRUE,\n  FALSE\n};\n\n\nMEMO memo[301][301];\n\nMEMO rec(int l, int r) {\n  if (r - l == 1) {\n    if (abs(w[r] - w[l]) <= 1) {\n      return memo[l][r] = TRUE;\n    } else {\n      return memo[l][r] = FALSE;\n    }\n  }\n\n  if (r == l) {\n    return memo[l][r] = FALSE;\n  }\n\n  if (l > r) {\n    return memo[l][r] = TRUE;\n  }\n\n  if (memo[l][r] != NOT_CHECKED) {\n    return memo[l][r];\n  }\n\n  if (abs(w[l] - w[r]) <= 1) {\n    for (int i = l + 2; i < r; i++) {\n      int temp1 = rec(l + 1, i);\n      int temp2 = rec(i + 1, r - 1);\n      if (temp1 == TRUE && temp2 == TRUE) {\n        return memo[l][r] = TRUE;\n      }\n    }\n  }\n\n  for (int i = l + 1; i < r; i++) {\n    int temp1 = rec(l, i);\n    int temp2 = rec(l + 1, r);\n    if (temp1 == TRUE && temp2 == TRUE) {\n      return memo[l][r] = TRUE;\n    }\n  }\n\n  return memo[l][r] = FALSE;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        memo[i][j] = NOT_CHECKED;\n      }\n    }\n\n    rec(0, n - 1);\n\n    int dp[301] = { 0 };\n    for (int i = 1; i < n; i++) {\n      dp[i] = dp[i - 1];\n      if (memo[0][i] == TRUE) {\n        dp[i] = i + 1;\n        continue;\n      }\n      for (int j = 1; j < i; j++) {\n        if (memo[j][i] == TRUE) {\n          dp[i] = max(dp[i], dp[j - 1] + (i - j + 1));\n        }\n      }\n    }\n\n    int ans = dp[n - 1];\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[400][400],dp2[400][400];\nint w[400];\n\nint rec(int l,int r){\n\tif(r-l==0)return true;\n\tif(dp[l][r]!=-1)return dp[l][r];\n\tfor(int k=l+1;k<r;k++){\n\t\tif(abs(w[l]-w[k])<=1){\n\t\t\tif(rec(l+1,k)&&rec(k+1,r))return dp[l][r]=true;\n\t\t}\n\t}\n\treturn dp[l][r]=false;\n}\nint rec2(int l,int r){\n\tif(r-l==0)return 0;\n\tif(dp2[l][r]!=-1)return dp2[l][r];\n\tif(rec(l,r))return r-l;\n\tdp2[l][r]=0;\n\tfor(int k=l+1;k<r;k++){\n\t\tdp2[l][r]=max(dp2[l][r],rec2(l,k)+rec2(k,r));\n\t}\n\treturn dp2[l][r];\n}\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\trep(i,n)scanf(\"%d\",&w[i]);\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tmemset(dp2,-1,sizeof(dp2));\n\t\tcout<<rec2(0,n)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <stack>\n#include <map>\n#include <cmath>\n#include <queue>\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\ntypedef unsigned long ll;\n\nint N;\nvector<int> w;\n\nint solve(){\n\tvector<vector<int>> dp(N+1,vector<int>(N+1,-N));\n\tfor(int i = 0; i <= N; i++){\n\t\tdp[i][i] = 0;\n\t\tif( i < N) dp[i][i+1] = 0;\n\t}\n\tfor(int bet = 2; bet <= N; bet++){\n\t\tfor(int i = 0; i + bet <= N; i++){\n\t\t\tint j = i + bet;\n\t\t\tif( dp[i+1][j-1] == j- i -2){\n\t\t\t\tif( abs(w[i] - w[j-1]) <= 1) dp[i][j] = max(dp[i][j],j-i);\n\t\t\t\telse dp[i][j] = max(dp[i][j],j-i-2);\n\t\t\t}\n\t\t\tfor(int k = i + 1; k <= j-1; k++){\n\t\t\t\tdp[i][j] = max(dp[i][j],dp[i][k] + dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][N];\n}\n\nint main()\n{\n\twhile(cin>>N,N){\n\t\tw.resize(N);\n\t\tfor(int i = 0; i < N; i++) cin>>w[i];\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[1000];\nbool dp[1000][1000];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 1000)rep(j, 1000) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\tfor (int j = 0; j + i < n; j++) {\n\t\t\t\tint lb = j, ub = j + i;\n\t\t\t\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\t\t\t\tif (i == 1)dp[lb][ub] = 1;\n\t\t\t\t\telse dp[lb][ub] |= dp[lb + 1][ub - 1];\n\t\t\t\t}\n\t\t\t\tFOR(mid, lb, ub) {\n\t\t\t\t\tdp[lb][ub] |= dp[lb][mid] && dp[mid + 1][ub];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, n) {\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tnum = max(num, j - i + 1);\n\t\t\t\t\tpos = j - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += num;\n\t\t\ti = pos;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint N, W[300];\nint dp[301][3001];\n\nbool ok(int i, int j) {\n  return abs(W[i] - W[j]) <= 1;\n}\n\nint dfs(int l, int r) {\n  if(r - l <= 1) return 0;\n  if(r - l == 2) return ok(l, l + 1) ? 2 : 0;\n  if(dp[l][r] >= 0) return dp[l][r];\n\n  int ret = 0;\n  REP(i, l + 1, r - 1) ret = max(ret, dfs(l, i) + dfs(i, r));\n  if(ok(l, r - 1) && dfs(l + 1, r - 1) == r - l - 2) ret = max(ret, r - l);\n\n  return dp[l][r] = ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> W[i];\n    REP(i, 0, 301) REP(j, 0, 301) dp[i][j] = -1;\n    cout << dfs(0, N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint *line;\nbool **check;\nbool search(int, int);\nint main() {\n\tint n;\n\twhile (cin >> n&&n > 0) {\n\t\tline = new int[n];\n\t\tcheck = new bool*[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> line[i];\n\t\t\tcheck[i] = new bool[n] {0};\n\t\t}\n\t\tfor (int i = 0, nmax = n - 1; i < nmax; ++i) {\n\t\t\tif (abs(line[i] - line[i + 1]) <= 1) {\n\t\t\t\tcheck[i][i + 1] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int wide = 3; wide < n; wide += 2) {\n\t\t\tfor (int i = 0, nmax = n - wide; i < nmax; ++i) {\n\t\t\t\tif (search(i, i + wide)) {\n\t\t\t\t\tcheck[i][i + wide] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint *dp;\n\t\tdp = new int[n + 1]{ 0 };\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdp[i + 1] = max(dp[i + 1], dp[i]);\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (check[i][j]) {\n\t\t\t\t\tdp[j + 1] = max(dp[j + 1], dp[i] + j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << endl;\n\t}\n\treturn 0;\n}\nbool search(int ps, int pe) {\n\tif (abs(line[ps] - line[pe]) <= 1 && check[ps + 1][pe - 1])return true;\n\tfor (int i = ps + 1; i < pe; i += 2) {\n\t\tif (check[ps][i] && check[i + 1][pe]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool\tis_removable(const vector<int> &w_vec, int i0, int i1)\n{\n\treturn (abs(w_vec.at(i0) - w_vec.at(i1)) < 2);\n}\n\nint\tmain()\n{\n\tint\tn;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tif (n == 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int>\tw_vec(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcin >> w_vec.at(i);\n\t\tvector<vector<int>>\tcnt(n, vector<int>(n, 0));\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tif (is_removable(w_vec, i, i + 1)) {\n\t\t\t\tcnt.at(i).at(i + 1) = 2;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tint\tk;\n\t\t\tint\ttmp_cnt;\t\n\t\t\tfor (int j = 0; (k = i + j) < n; ++j) {\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\ttmp_cnt = cnt.at(j).at(k);\n\t\t\t\t\tif (cnt.at(j).at(k + 1) < tmp_cnt)\n\t\t\t\t\t\tcnt.at(j).at(k + 1) = tmp_cnt;\n\t\t\t\t}\n\t\t\t\tif (0 < j) {\n\t\t\t\t\ttmp_cnt = cnt.at(j).at(k);\n\t\t\t\t\tif (cnt.at(j - 1).at(k) < tmp_cnt)\n\t\t\t\t\t\tcnt.at(j - 1).at(k) = tmp_cnt;\n\t\t\t\t}\n\t\t\t\tif (k < n - 2) {\n\t\t\t\t\tfor (int l = k + 2; l < n; ++l) {\n\t\t\t\t\t\ttmp_cnt = cnt.at(j).at(k) + cnt.at(k + 1).at(l);\n\t\t\t\t\t\tif (cnt.at(j).at(l) < tmp_cnt)\n\t\t\t\t\t\t\tcnt.at(j).at(l) = tmp_cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (0 < j && k < n - 1 && cnt.at(j).at(k) == k - j + 1) {\n\t\t\t\t\tif (is_removable(w_vec, j - 1, k + 1)) {\n\t\t\t\t\t\ttmp_cnt = cnt.at(j).at(k) + 2;\n\t\t\t\t\t\tif (cnt.at(j - 1).at(k + 1) < tmp_cnt)\n\t\t\t\t\t\t\tcnt.at(j - 1).at(k + 1) = tmp_cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (1 < j) {\n\t\t\t\t\tfor (int l = 0; l < j - 1; ++l) {\n\t\t\t\t\t\ttmp_cnt = cnt.at(j).at(k) + cnt.at(l).at(j - 1);\n\t\t\t\t\t\tif (cnt.at(l).at(k) < tmp_cnt)\n\t\t\t\t\t\t\tcnt.at(l).at(k) = tmp_cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt.at(0).at(n - 1) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> void rev(vector<T> &a) {\n    reverse(all(a));\n}\nvoid rev(string &a) {\n    reverse(all(a));\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T> T sum(vector<T> &v, int s = 0, int t = inf) {\n    T ret = 0;\n    rep(i, s, min(sz(v), t))ret += v[i];\n    return ret;\n}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    return ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    return ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &m) {\n    for (auto &&v:m) os << v << \" \";\n    return os;\n}\nconstexpr bool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\nll bit(int n) { return (1LL << (n)); }\nll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint mask(int n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chmi(const U &b) { return chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {\n    int res = a[0];\n    fora(v, a) {\n        res = max(res, v);\n    }\n    return res;\n}\nint min(vi &a) {\n    int res = a[0];\n    fora(v, a) {\n        res = min(res, v);\n    }\n    return res;\n}\nint N, M, H, W;\nvi A, B, C;\n\n\nsigned main() {\n    while (cin >> N && N) {\n        vi A;\n        na(A, N);\n        //閉区間\n        vvb(can, N, N);\n        auto chk = [&](int i, int j) {\n            return abs(A[i] - A[j]) < 2;\n        };\n        rep(i, N - 1) {\n            can[i][i + 1] = chk(i, i + 1);\n        }\n        deb(can);\n        //貰う\n        rep(hab, 4, N + 1) {\n            rep(l, N) {\n                int r = l + hab - 1;\n                if (r >= N)break;\n                if (can[l + 1][r - 1] && chk(l, r))can[l][r] = true;\n                rep(m, l, r) if (can[l][m] && can[m + 1][r]) {\n                        deb(l, r, m);\n                        can[l][r] = true;\n                    }\n            }\n        }\n        deb(can);\n        vvi(dp, N, N);\n        rep(i, N) {\n            rep(j, N) {\n                if (can[i][j])dp[i][j] = j - i + 1;\n            }\n        }\n        rep(hab, 2, N + 1) {\n            rep(l, N) {\n                int r = l + hab - 1;\n                if(r>=N)break;\n                rep(m, l, r){\n                    chma(dp[l][r], dp[l][m]+dp[m+1][r]);\n                }\n            }\n        }\n        cout<<dp[0][N-1]<<endl;\n//        vi ma(N + 1);\n//        rep(l, N) {\n//            //使わない\n//            chma(ma[l + 1], ma[l]);\n//            rep(r, l, N) {\n//                if (can[l][r]) {\n//                    chma(ma[r + 1], ma[l] + r + 1 - l);\n//                }\n//            }\n//        }\n//        deb(ma);\n//        cout << ma[N] << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll ,P> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nint main() {\n    int n;\n    vector<int> w;\n    while(cin >> n, n){\n        w.clear();\n        w.push_back(-IINF/2);\n        REP(i,n){\n            int wi;\n            cin >> wi;\n            w.push_back(wi);\n        }\n        w.push_back(IINF/2);\n        bool update = true;\n        while(update){\n            while(update){\n                update = false;\n                for(int i=int(w.size())-3;i>=1;i--){\n                    if(abs(w[i]-w[i+1])<=1 && abs(w[i-1]-w[i+2])<=1){\n                        w.erase(w.begin()+i,w.begin()+i+2);\n                        update = true;\n                    }\n                }\n            }\n            for(int i=int(w.size())-2;i>=1;i--){\n                if(abs(w[i]-w[i+1])<=1){\n                    w.erase(w.begin()+i,w.begin()+i+2);\n                    update = true;\n                }\n            }\n        }\n        cout << n - int(w.size()) + 2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  while(n != 0){   \n    vector<int> w(n);\n    for(int i=0; i<n; i++)\n      cin >> w[i];\n\n    vector< vector<int> > dp(n, vector<int>(n));\n\n    if(n == 1){\n      cout << 0 << endl;\n      cin >> n;\n      continue;\n    }\n\n    for(int i=0; i<n-1; i++)\n      if(abs(w[i] - w[i+1]) <= 1)\n\tdp[i][i+1] = 2;\n\n    for(int k=3; k<n; k+=2){\n      for(int i=0; i<n; i++){\n\tif(i+k >= n)\n\t  break;\n\n\tint nmax = 0;\t\n\tif(dp[i+1][i+k-1] == k-1){\n\t  if(abs(w[i] - w[i+k]) <= 1){\n\t    dp[i][i+k] = dp[i+1][i+k-1] + 2;\n\t    continue;\n\t  }\n\t  nmax = dp[i+1][i+k-1];\n\t}\n\n\tfor(int j=i+1; j<i+k; j+=2){\n\t  int temp = dp[i][j] + dp[j+1][i+k];\n\t  if(temp > nmax){\n\t    nmax = temp;\n\t  }\n\t}\n\tdp[i][i+k] = nmax;\n      }\n    }    \n\n    if(n%2 != 0){\n      int nmax = max(dp[1][n-1], dp[0][n-2]);\n      for(int i=2; i<n-1; i+=2){\n\tint temp = dp[0][i-1] + dp[i+1][n-1];\n\tif(temp > nmax)\n\t  nmax = temp;\n      }\n      dp[0][n-1] = nmax;\n    }\n    \n    cout << dp[0][n-1] << endl;\n\n    cin >> n;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<int> W(n);\n    for(int i = 0; i < n; ++i) cin >> W[i];\n    vector< vector<int> > DP(n, vector<int>(n,0));\n    for(int k = 1; k < n; ++k){\n      for(int i = 0; i < n-k; ++i){\n        if(DP[i+1][i+k-1] == k-1 && abs(W[i]-W[i+k]) <= 1) DP[i][i+k] = k+1;\n        for(int j = i; j < i+k; ++j){\n          DP[i][i+k] = max(DP[i][i+k], DP[i][j]+DP[j+1][i+k]);\n        }\n      }\n    }\n    cout << DP[0][n-1] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconstexpr int MAX_N = 300;\n\nint memo[MAX_N+1][MAX_N+1];\nint w[MAX_N];\n\nint dfs(int i, int j) {\n    if(memo[i][j] != -1) return memo[i][j];\n\n    // あるペアの差の絶対値が1以下で，ペアの間の数が全て消せていたら，\n    // そのペアを含めた区間も全て消せる\n    if(abs(w[i]-w[i+j-1]) <= 1 && dfs(i+1, j-2) == j-2) {\n        return memo[i][j] = j;\n    }\n\n    // 区間を途中で区切って最大の場合を見つける\n    for(int k=i+1;k<=i+j;++k) {\n        memo[i][j] = max(memo[i][j], dfs(i, k-i) + dfs(k, i+j-k));\n    }\n    return memo[i][j];\n}\n\nint solve(int n) {\n    for(int i=0;i<n;++i){\n        cin >> w[i];\n    }\n\n    fill_n(memo[0], (MAX_N+1)*(MAX_N+1), -1);\n    for(int i=0;i<=n;++i) {\n        memo[i][0] = 0;\n        memo[i][1] = 0;\n    }\n    \n    return dfs(0, n);\n}\n\nint main() {\n    int n;\n    while(cin >> n && n) {\n        cout << solve(n) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <cstdlib>\n#include <iterator>\n\n//?????????\nstruct daruma {\n\tstd::list<int> block;\n\tint size;\n};\n\nclass DarumaOtosi {\npublic:\n\tDarumaOtosi(daruma d) {\n\t\tdarumalist.resize(d.size-3);\n\t\tdarumalist[d.size - 4].push_back(d);\n\t}\n\t//???????????????????????????\n\tint Hunmer(daruma d) {\n\t\t//?????????????????????\n\t\tif (d.size != d.block.size()) {\n\t\t\t//??????????????????????????´??°\n\t\t\td.size = d.block.size();\n\t\t\t//????????\\????????????????????????????????????\n\t\t\tif (d.size == 0 || d.size == 1) return d.size;\n\t\t\t//?????????????????????????????¨?????£?????£???\n\t\t\tif (d.size >= 4) {\n\t\t\t\tint tmp = CheckDaruma(d);\n\t\t\t\tif (tmp != 0) return tmp;\n\t\t\t\tdarumalist[d.size - 4].push_back(d);\n\t\t\t}\n\t\t}\n\n\t\tfor (auto itr = d.block.begin(); itr != std::prev(d.block.end()); itr++) {\n\t\t\tif (abs(*itr - *(std::next(itr))) <= 1) {\n\t\t\t\tconst int tmp1 = *itr; const int tmp2 = *(std::next(itr));\n\t\t\t\t//????????????\n\t\t\t\titr = d.block.erase(itr, std::next(itr, 2));\n\t\t\t\t//???????????£??????\n\t\t\t\tint size = Hunmer(d);\n\t\t\t\t//????????????\n\t\t\t\titr = d.block.insert(itr, tmp2);\n\t\t\t\titr = d.block.insert(itr, tmp1);\n\t\t\t\t//???????????´??°\n\t\t\t\tif (d.size > size) {\n\t\t\t\t\td.size = size;\n\t\t\t\t\t//????????\\???????????????????????£?????????\n\t\t\t\t\tif (d.size == 0 || d.size == 1) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(d.block.size() >= 4) darumalist[d.block.size() - 4].back().size = d.size;\n\t\treturn d.size;\n\t}\n\nprivate:\n\tstd::vector<std::vector<daruma>> darumalist;\n\n\t//????????????????????????\n\tvoid CollectDaruma(daruma d) {\n\t\tdarumalist[d.size].push_back(d);\n\t}\n\n\t//???????????¨??????????????????????????§??????\n\tint CheckDaruma(daruma d) {\n\t\tint n = d.size;\n\t\tfor (int i = 0; i < darumalist[n-4].size(); i++) {\n\t\t\tif (d.block == darumalist[n-4][i].block) return darumalist[n-4][i].size;\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nint main() {\n\tint n = 1;\n\tstd::vector<daruma> daruma_original;\n\n\t//??\\???\n\tfor (int m;;) {\n\t\tdaruma daruma;\n\t\tstd::cin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::cin >> m;\n\t\t\tdaruma.block.push_back(m);\n\t\t}\n\t\tdaruma.size = daruma.block.size();\n\t\tdaruma_original.push_back(daruma);\n\t}\n\n\t//???????????????\n\tfor (auto x : daruma_original) {\n\t\tDarumaOtosi darumaotosi(x);\n\t\tstd::cout << x.size - darumaotosi.Hunmer(x) << std::endl;\n\t}\n\n\tgetchar(); getchar();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\ntemplate<class T> bool chmin(T &a, T b) {if(a>b) {a=b;return 1;}return 0;}\nusing namespace std;\nusing ll = long long;\nconst int inf = 1e8;\n\nint dp[305][305];\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vector<int> w(n);\n        rep(i,n) cin >> w[i];\n        for (int i = n-1; i >= 0; i--) {\n            for (int j = 0; j < n; j++) {\n                if (j < i) continue;\n                else if (j == i) dp[i][j] = 0;\n                else if (j == i+1) {\n                    if (abs(w[i]-w[j]) <= 1) dp[i][j] = 2;\n                    else dp[i][j] = 0;\n                }\n                else {\n                    if (abs(w[i]-w[j]) <= 1 && dp[i+1][j-1] == j-i-1) dp[i][j] = j-i+1;\n                    for (int k = i; k <= j-1; k++) {\n                        dp[i][j] = max(dp[i][k]+dp[k+1][j],dp[i][j]);\n                    }\n                }\n            }\n        }\n        cout << dp[0][n-1] << endl;\n        rep(i,n)rep(j,n) dp[i][j] = 0;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint remove(int a, int b){\n\treturn (abs(a-b)<=1)? 2: 0;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<int> w(n+1);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> w[i];\n\t\t}\n\t\tif(n%2!=0){\n\t\t\tw[n]=-1;\n\t\t\tn++;\n\t\t}\n\t\t\n\t\tvector<vector<int> > dp(n+1, vector<int>(n+1, 0));\n\t\tfor(int i=2; i<=n; i+=2){\n\t\t\tfor(int j=0; j+i<=n; j++){\n\t\t\t\tdp[j][i] = max(dp[j][i-2]+remove(w[j+i-2],w[j+i-1]), dp[j+2][i-2]+remove(w[j], w[j+1]));\n\t\t\t\tif(dp[j+1][i-2]==i-2){\n\t\t\t\t\tdp[j][i] = max(dp[j][i], i-2+remove(w[j], w[j+i-1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t} \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n  \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nint W[301];\nint f[301][301];\nint main(){\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0)break;\n\t\tREP(i,N)cin>>W[i];\n\t\tmemset(f,false,sizeof(f));\n\t\tREP(i,N)f[i][i]=true;\n\t\tREP(i,N-1)if(abs(W[i]-W[i+1])<=1)f[i][i+2]=true;\n\t\tfor(int d=4;d<=N;d+=2){\n\t\t\tREP(i,N-d+1){\n\t\t\t\tif((f[i][i+d-2]&&f[i+d-2][i+d])||(abs(W[i]-W[i+d-1])<=1&&f[i+1][i+d-1])||(f[i][i+2]&&f[i+2][i+d])){\n\t\t\t\t\tf[i][i+d]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ma[N];\n\t\tREP(i,N)ma[i]=i;\n\t\tREP(i,N){\n\t\t\tfor(int j=N;j>=i;j--){\n\t\t\t\tif(f[i][j]){\n\t\t\t\t\tma[i]=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*REP(i,N)cout<<ma[i]<<\" \";cout<<endl;\n\t\tREP(i,N+1){REP(j,N+1)cout<<f[i][j]<<\" \";cout<<endl;}*/\n\t\tint ans=0;\n\t\tREP(i,N){\n\t\t\tint p=i,cnt=0;\n\t\t\twhile(p<N){\n\t\t\t\tint pp=ma[p];\n\t\t\t\tcnt+=(pp-p);\n\t\t\t\tp=pp+1;\n\t\t\t}\n\t\t\tans=max(ans,cnt);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint search(std::vector<int> blocks, int count) {\n\tif (blocks.size() == 0) return count;\n\n\tint max = count;\n\n\tfor (auto iter = blocks.begin() + 1; iter != blocks.end(); iter++) {\n\t\tif (std::abs(*iter - *(iter - 1)) <= 1) {\n\t\t\tstd::vector<int> new_blocks;\n\t\t\tnew_blocks.reserve(blocks.size() - 2);\n\t\t\tnew_blocks.insert(new_blocks.begin(), blocks.begin(), iter - 1);\n\t\t\tnew_blocks.insert(new_blocks.end(), iter + 1, blocks.end());\n\t\t\tint result = search(std::move(new_blocks), count + 2);\n\t\t\tif (result > max) max = result;\n\t\t}\n\t}\n\n\treturn max;\n}\n\nint main()\n{\n\tstd::vector<int> blocks;\n\tblocks.reserve(300);\n\n\twhile (true) {\n\t\tint num_blocks;\n\t\tstd::cin >> num_blocks;\n\n\t\tif (num_blocks == 0) return 0;\n\n\t\tblocks.clear();\n\t\tfor (int i = 0; i < num_blocks; i++)\n\t\t{\n\t\t\tint w;\n\t\t\tstd::cin >> w;\n\t\t\tblocks.push_back(w);\n\t\t}\n\n\t\tstd::cout << search(blocks, 0) << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b){ return (a<b ? (a=b)||1 : 0); }\n\nint main() {\n\t\n\twhile(1){\n\t\tint n; cin >> n; if(!n) break;\n\t\tvector<int>w(n);\n\t\tfor(int i=0; i<n; i++) cin>>w.at(i);\n\t\tvector<vector<int>>dp(n+1,vector<int>(n+1));\n\t\tfor(int r=1; r<n; r++){\n\t\t\tfor(int i=0, j; (j=i+r)<n; i++){\n\t\t\t\tfor(int k=i; k<j; k++){\n\t\t\t\t\tif(r==1&&abs(w.at(i)-w.at(j))<=1) dp.at(i).at(j)=2;\n\t\t\t\t\tif(r>1){\n\t\t\t\t\t\tchmax(dp.at(i).at(j), dp.at(i).at(k)+dp.at(k+1).at(j));\n\t\t\t\t\t\tif(dp.at(i+1).at(k)+dp.at(k+1).at(j-1)==j-i-1&&abs(w.at(i)-w.at(j))<=1) dp.at(i).at(j)=j-i+1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp.at(0).at(n-1) << endl;\n\t}\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* \n区間DPをします\nF(l, r) := [l,r)の中で叩き出せる個数\n*/\n\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst long long LINF = 1e18;\n#define dump(x)  cout << 'x' << ' = ' << (x) << ` `;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOREACH(x,a) for(auto& (x) : (a) )\ntypedef long long ll;\nusing namespace std;\ntypedef pair<ll, ll> P;\n\nint dp[400][400];\n\n// [l, r)\n/*\nint rec(int l, int r, vector<int> &w) {\n    if (dp[l][r] != -1) return dp[l][r];\n    if (abs(l-r)<=1) return 0;\n\n    int res = 0;\n    if (abs(w[l]-w[r-1]) <= 1 && rec(l+1,r-1,w) == r-l-2) res = r-l;\n    for (int mid = l+1; mid < r; ++mid) res=max(res,rec(l,mid,w)+rec(mid,r,w));\n    return dp[l][r] = res;\n}\n*/\n\nint calc(int n, vector<int> &w) {\n    for (int W = 2; W <= n; ++W) {\n        for (int l = 0; l < n; ++l) {\n            int r = l+W-1;\n            if (n <= r) continue;\n            if (abs(w[l]-w[r])<=1 && dp[l+1][r-1]==W-2) dp[l][r] = W;\n            for (int mid = l; mid <= r; ++mid) {\n                dp[l][r] = max(dp[l][r],dp[l][mid]+dp[mid+1][r]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n\nint main(int argc, char const *argv[]) {\n    int n;\n    while(cin>>n,n) {\n        vector<int> w(n); rep(i,n) cin>>w[i];\n        memset(dp,0,sizeof(dp));\n        // cout << rec(0,n,w) << endl;\n        cout << calc(n,w) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cmath>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,a,n) for(int i=(a);i<(n);i++)\nusing namespace std;\n\nint main(){\n  int n;\n\tbool dp[303][303];\n\tint ans[303];\n  while(cin>>n,n){\n    vector<int> w(n);\n    REP(i,n)cin>>w[i];\n    fill(dp[0],dp[n],false);\n    fill(ans,ans+n,0);\n    for(int i = 0;i <n;i++)dp[i][i+1] |= abs(w[i+1]-w[i])<=1;\n    for(int width = 2;width <= n;width++){\n      for(int l = 0;l + width <= n;l++){\n\t\t\t\tint r = l + width-1;\n\t\t\t\tfor(int d = l;d < r;d++){//-1??¨???\n\t\t\t\t\tdp[l][r] |= dp[l][d]&&dp[d+1][r];\n\t\t\t\t\tdp[l][r] |= !(width&1) && dp[l+1][r-1] && abs(w[l]-w[r]) <=1;\n\t\t\t\t}\n      }\n    }\n\t\t/*\t\tFOR(width,1,n+1){\n\t\t\tREP(l,n-width){\n\t\t\t\tcout << dp[l][l+width] << ' ';\n\t\t\t\t}\n\t\t\tcout << endl;\n\t\t\t}*/\n    for(int i = 0;i<n;i++){\n\t\t\t//i-1?????§????????£????????????\n\t\t\t//i??\\????????´??°??§??????????????????i???????????¶??§i-1??????????????????\n\t\t\t//ans[i]???????????´??°???????????§????????????divide??°??????????????????????????¢?????´??°???????????????\n\t\t\tif(i > 0)ans[i] = max(ans[i],ans[i-1]);\n      for(int r = i+1;r<n;r++){\n\t\t\t\t//i-1?????§????????£??????????????????i???????§???????????¶????????????????????????¨?????´??°????????????\n\t\t\t\tif(dp[i][r]) ans[r] = max(ans[r],(i>0?ans[i-1]:0) + (r-i+1));\n      }\n    }\n    cout << ans[n-1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n-1){\n            if(!k || i+k>n-1)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n                    cmax(dp[i][i+k],dp[i+1][i+k-1]+2);\n                }\n                for(int j = i+1; j<i+k;j++){\n                    if(dp[i][j] && dp[j+1][i+k])cmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int s = 0;s < n;s++){\n            int temp = 0;\n            for(int i = s; i<n;i++){\n                for(int j = n-1; j >= 0;--j){\n                    if(dp[i][j]){\n                        temp += j-i+1;\n                        i = j;\n                    }\n                }\n                cmax(ans, temp);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<vector<int>>dp(n,vector<int>(n,0));\n\t\tvector<int>array(n);\n\t\trep(i,n) cin >> array[i];\n\t\tloop(k,2,n + 1)rep(i,n){\n\t\t\tint j = i + k - 1;\n\t\t\tif(j>=n)continue;\n\t\t\tif((abs(array[i]-array[j])<=1 && dp[i+1][j-1] + 2 == k)){\n\t\t\t\tdp[i][j] = k;\n\t\t\t}\n\t\t\tfor(int l = i; l<j;l++){\n\t\t\t\tcmax(dp[i][j],dp[i][l] + dp[l+1][j]);\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\nint n;\nvector<int> w;\nint dp[333][333];\n\nint solve(int l, int r) {\n  if (r - l <= 1) return 0;\n  if (r - l == 2) {\n    if (abs(w[l + 1] - w[l]) <= 1) {\n      return 2;\n    } else {\n      return 0;\n    }\n  }\n  if (dp[l][r] != -1) return dp[l][r];\n  if (abs(w[r - 1] - w[l]) <= 1 && solve(l + 1, r - 1) == r - l - 2) {\n    chmax(dp[l][r], r - l);\n  }\n\n  for (int i = l + 1; i < r; i++) {\n    chmax(dp[l][r], solve(l, i) + solve(i, r));\n  }\n  return dp[l][r];\n}\n\nint main() {\n  while (cin >> n, n) {\n    w.assign(n, 0);\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= n; j++) {\n        dp[i][j] = -1;\n      }\n    }\n    cout << solve(0, n) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  while(n != 0){   \n    vector<int> w(n);\n    for(int i=0; i<n; i++)\n      cin >> w[i];\n\n    vector< vector<int> > dp(n, vector<int>(n));\n\n    if(n == 1){\n      cout << 0 << endl;\n      cin >> n;\n      continue;\n    }\n\n    for(int i=0; i<n-1; i++)\n      if(abs(w[i] - w[i+1]) <= 1)\n\tdp[i][i+1] = 2;\n\n    for(int k=3; k<n; k+=2){\n      for(int i=0; i<n; i++){\n\tif(i+k >= n)\n\t  break;\n\t\n\tif(dp[i+1][i+k-1] == k-1)\n\t  if(abs(w[i] - w[i+k]) <= 1){\n\t    dp[i][i+k] = dp[i+1][i+k-1] + 2;\n\t    continue;\n\t  }\n\n\tint nmax = 0;\n\tfor(int j=i+1; j<i+k; j+=2){\n\t  int temp = dp[i][j] + dp[j+1][i+k];\n\t  if(temp > nmax){\n\t    nmax = temp;\n\t  }\n\t}\n\tdp[i][i+k] = nmax;\n      }\n    }    \n\n    if(n%2 != 0){\n      int nmax = max(dp[1][n-1], dp[0][n-2]);\n      for(int i=2; i<n-1; i+=2){\n\tint temp = dp[0][i-1] + dp[i+1][n-1];\n\tif(temp > nmax)\n\t  nmax = temp;\n      }\n      dp[0][n-1] = nmax;\n    }\n    \n    cout << dp[0][n-1] << endl;\n\n    cin >> n;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint SolveDaruma(const vector<int> &w) {\n    const int n = w.size();\n    vector<vector<int>> s(n, vector<int>(n, 0));\n\n    for (int l = 0; l + 1 < n; ++l)\n        if (abs(w[l] - w[l + 1]) <= 1)\n            s[l][l + 1] = 2;\n\n    for (int i = 3; i <= n; ++i)\n        for (int l = 0; l + i <= n; ++l) {\n            const int r = l + i - 1;\n\n            if (abs(w[l] - w[r]) <= 1 && s[l + 1][r - 1] == i - 2)\n                s[l][r] = i;\n\n            for (int m = l + 1; m <= r; ++m)\n                s[l][r] = max(s[l][r], s[l][m - 1] + s[m][r]);\n        }\n\n    return s[0][n - 1];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n\n    while (cin >> n, n) {\n        vector<int> w(n);\n        for (int i = 0; i < n; ++i)\n            cin >> w[i];\n\n        cout << SolveDaruma(w) << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e7 + 1;\nconst long long MOD = 1000000007;\nconst long double PI = 3.1415926;\n#define FOR(i,r,n) for(ll i = (ll)(r); i < (ll)(n); i++)\n#define RFOR(i,r,n) for(ll i=(ll)(n-1);i>=r;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define RALL(x) x.rbegin(),x.rend()\ntypedef long long int ll;\ntypedef vector<ll> vi;\ntypedef vector < pair<ll, ll > > vp;\ntypedef vector <string> vs;\ntypedef vector <char> vc;\ntypedef list <ll> lst;\n\nll n, m, k, ans = 0, sum = 0, cnt = 0;\nstring s;\nchar c;\n\n\n/*--------------------template--------------------*/\n\nll dp[500][500];\n\nint main()\n{\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvi v(n, 0);\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\tREP(i, n) cin >> v[i];\n\t\t\tFOR(i, 1, n)\n\t\t\t{\n\t\t\t\tREP(j, n - i)\n\t\t\t\t{\n\t\t\t\t\tFOR(k, j, j + i)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[j][j + i] = max(dp[j][j + i], dp[j][k] + dp[k + 1][j + i]);\n\t\t\t\t\t\tif (dp[j + 1][j + i - 1] == i - 1 && abs(v[j] - v[j + i]) < 2) {\n\t\t\t\t\t\t\tdp[j][j + i] = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << dp[0][n - 1] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nint n;\nint w[MAX];\nint done[305][305];\nint dp[305][305];\n\nvoid print_dp() {\n    rep(i, n) {\n        rep(j, n+1) {\n            cout << setw(3) << dp[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint ans(int l, int r) {\n    if (done[l][r]) {\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    if (r - l == 0) return 0;\n    if (r - l == 1) return 0; \n    if (l > r) return -INF;\n    if (r > n) return -INF;\n    if (r - l == 2) {\n        done[l][r] = true;\n        int res = 0;\n        if (abs(w[l] - w[l+1]) < 2) res = 2;\n        else res = 0;\n        dp[l][r] = res;\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    int res = 0;\n    rep(width, n) {\n        rep(width2, 2) {\n            if (l+width+width2 > r) break;\n            rep2(i, l, r) {\n                if (i+width+width2 > n) break;\n                if (i+width+width2*2 > r) break;\n                if (i+width2 == l && i+width+width2 == r) continue;\n                if (i+width+width2*2 == l) continue;\n                int tmp = \n                ans(l, i) \n                + ans(i+width2, i+width+width2) \n                + ans(i+width+width2*2, r);\n                if (ans(i+width2, i+width+width2) == width) {\n                    rep(j, width2) {\n                        if (abs(w[i+width2-1-j] - w[i+width+width2+j]) < 2) {\n                            tmp += 2;\n                        }\n                        else break;\n                    }\n                }\n                res = max(res, tmp);\n            }\n        }\n    }\n\n\n    done[l][r] = true;\n    dp[l][r] = res;\n    // if (test) {\n    //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n    // }\n    return dp[l][r];\n}\n\nvoid solve() {\n    rep(i, 305) rep(j, 305) done[i][j] = false;\n    rep(i, 305) rep(j, 305) dp[i][j] = 0;\n    cin >> n;\n    if (n == 0) exit(0);\n    rep(i, n) cin >> w[i];\n    cout << ans(0, n) << endl;\n    // if (test) print_dp();\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n#define DUMP(x) cout << #x << \": \" << x << endl\n\nint n;\nint memo[310][310] = { 0 };\nvector<int> w(n);\n\nint rec(int l, int r) {\n  if (r - 1 == l) {\n    return 0;\n  }\n  \n  if (r - l  - 1 == 1) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      return 2;\n    }\n  }\n  if (memo[l][r]) {\n    return memo[l][r];\n  }\n  \n  int ret = 0;\n  bool isOK = false;\n  \n  if (abs(w[l] - w[r - 1]) <= 1) {\n    isOK = true;\n  }\n\n\n  for (int t = l + 1; t < r - 1; t++) {\n    int temp2 = rec(l, t) + rec(t, r);\n    if ((isOK && temp2 == r - l - 2)) {\n      temp2 += 2;\n    }\n    for (int k = t + 1; k < r; k++) {\n      int temp = ((isOK && temp == r - l - 2)? 2 : 0) + rec(t, k) + rec(k, r);\n       if ((isOK && temp == r - l - 2)) {\n         temp += 2;\n       }\n       ret = max(ret, max(temp, temp2));   \n    }\n  }\n\n  return memo[l][r] = ret;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    w.clear();\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n    memset(memo, 0, sizeof(memo));\n    cout << rec(0, n) << endl;\n\n  }\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E17;\n\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n///////////////////////////////////////\n\nbool ans(ll n){\n    ll a[n];rep(i,0,n-1)cin>>a[i];\n    bool dp[n][n+1];memset(dp,false,sizeof(dp));\n    rep(i,0,n-1)dp[i][i]=true;\n    for(ll c=2;c<=n;c+=2){\n        rep(i,0,n-1){\n            ll j=i+c;//[i,j)\n            if(j>n)continue;\n            if(dp[i+1][j-1]&&abs(a[i]-a[j-1])<=1)dp[i][j]=true;\n            for(ll k=i+2;k<=j-2;k+=2){\n                if(dp[i][k]&&dp[k][j])dp[i][j]=true;\n            }\n        }\n    }\n    /*rep(i,0,n-1){\n        rep(j,0,n){\n            cout<<dp[i][j]<<\" \";\n        }cout<<endl;\n    }cout<<endl;*/\n    ll dp2[n][n];memset(dp2,0,sizeof(dp2));\n    rep(i,0,n-1){\n        ll ma=0;\n        rep(j,i+1,n){\n            if(dp[i][j])ma=j-i;\n            dp2[i][j-1]=ma;\n        }\n    }\n    /*rep(i,0,n-1){\n        rep(j,0,n-1){\n            cout<<dp2[i][j]<<\" \";\n        }cout<<endl;\n    }cout<<endl;*/\n    ll cou[n][n];\n    memset(cou,0,sizeof(cou));\n    rep(i,0,n-2){\n        rep(j,i,n-1){\n            if(i-1>=0)cou[i+1][j]=max(cou[i][j],cou[i][i-1]+dp2[i][j]);\n            else cou[i+1][j]=max(cou[i][j],dp2[i][j]);\n        }\n    }\n    /*rep(i,0,n-1){\n        rep(j,0,n-1){\n            cout<<cou[i][j]<<\" \";\n        }cout<<endl;\n    }cout<<endl;*/\n    \n    cout<<cou[n-1][n-1]<<endl;\n    return 0;\n}\n\nint main(){fastio\n    while(1){\n        ll n;cin>>n;\n        if(n==0)return 0;\n        ans(n);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 1611.cc: Daruma Otoshi\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 300;\n\n/* typedef */\n\n/* global variables */\n\nint as[MAX_N];\nbool bls[MAX_N][MAX_N + 1];\nint dp[MAX_N + 1];\n\n/* subroutines */\n\ninline void setmax(int &a, int b) { if (a < b) a = b; }\n\n/* main */\n\nint main() {\n  for (int n; scanf(\"%d\", &n) > 0 && n > 0;) {\n    for (int i = 0; i < n; i++) scanf(\"%d\", as + i);\n\n    memset(bls, false, sizeof(bls));\n    for (int i = 0; i < n; i++) bls[i][i] = true;\n\n    int maxl = 0;\n    for (int l = 2; l <= n; l += 2) {\n      for (int i = 0, j = l; j <= n; i++, j++) {\n\tif (bls[i + 1][j - 1] && abs(as[j - 1] - as[i]) <= 1)\n\t  bls[i][j] = true, maxl = l;\n\telse\n\t  for (int k = i + 2; k < j; k += 2)\n\t    if (bls[i][k] && bls[k][j]) {\n\t      bls[i][j] = true, maxl = l;\n\t      break;\n\t    }\n\t//if (bls[i][j]) printf(\"(%d,%d)\", i, j);\n      }\n      //putchar('\\n');\n    }\n\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n\n    for (int i = 0; i < n; i++) {\n      setmax(dp[i + 1], dp[i]);\n      for (int j = i + 2; j <= n; j += 2)\n\tif (bls[i][j])\n\t  setmax(dp[j], dp[i] + (j - i));\n    }\n\n    printf(\"%d\\n\", dp[n]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nusing ll = long long;\n\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define REPD(i,n) for(ll i=n-1;i>=0;i--)\n#define FOR(i,a,b) for(ll i=a;i<=(ll)(b);i++)\n#define FORD(i,a,b) for(ll i=a;i>=(ll)(b);i--)\n\n#define input(...) __VA_ARGS__; in(__VA_ARGS__)\n\ntemplate<class T>\nvoid print(vector<T> a) {\n  cout << \"[ \";\n  REP(i, a.size()) cout << a[i] << \" \";\n  cout << \"]\" << endl;\n}\n\nvoid print() {\n  std::cout << std::endl;\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n  std::cout << head << \" \";\n  print(std::forward<Tail>(tail)...);\n}\n\nvoid in() { }\n\ntemplate <class Head, class... Tail>\nvoid in(Head&& head, Tail&&... tail) {\n  cin >> head;\n  in(std::forward<Tail>(tail)...);\n}\n\nll n;\nvector<ll> a;\nvector<vector<ll>> table;\n\n#define DP table[left][right]\nll dfs(ll left, ll right) {\n  if (DP != -1) return DP;\n\n  if (right - left <= 1) return DP = 0;\n  ll maxv = 0;\n  if (abs(a[left] - a[right - 1]) < 2) {\n    ll value = dfs(left + 1, right - 1) + 2;\n    if (value == right - left) maxv = value;\n  }\n  FOR(i, left + 1, right - 1) {\n    maxv = max(maxv, dfs(left, i) + dfs(i, right));\n  }\n\n  return DP = maxv;\n}\n\nbool solve() {\n  cin >> n;\n  if (n == 0) return false;\n  a = vector<ll>(n);\n  REP(i, n) cin >> a[i];\n  table = vector<vector<ll>>(n + 1, vector<ll>(n + 1, -1));\n\n  cout << dfs(0, n) << endl;\n  return true;\n}\n\nint main() {\n  while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n;\nvi in;\nint dp[310][310];\nint f(int l,int r){\n\tif(dp[l][r]+inf)return dp[l][r];\n\tif(r-l<2)return dp[l][r]=0;\n\tif(r-l==2&&abs(in[l]-in[r-1])<2)return dp[l][r]=2;\n\tint out=-inf;\n\tloop(i,l+1,r-1)out=max(out,f(l,i)+f(i,r));\n\t\n//\tloop(i,l,r-1)if(abs(in[i]-in[i+1])<2){\n//\t\tout=max(out,f(l,i)+2+f(i+2,r));\n//\t}\n\tint t=f(l+1,r-1);\n\tif(t==r-l-2){\n\t\tif(abs(in[l]-in[r-1])<2)out=max(out,r-l);\n\t}\n\tout=max(out,f(l+1,r));\n\tout=max(out,f(l,r-1));\n\treturn dp[l][r]=out;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vi(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,310)rep(j,310)dp[i][j]=-inf;\n\t\tcout<<f(0,n)<<endl;;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dp[310][310];\nint n;\nvector<int> node;\n\nint dfs(int l,int r)\n{\n\tif(l > r)return 0;\n\tif(l == r)return 0;\n\tif(dp[l][r] != -1)return dp[l][r];\n\tif(r - l == 1)return (abs(node[l]-node[r])<2)?2:0;\n\t\n\tint ret = 0;\n\t\n\tif((r-l)%2==1&&dfs(l+1,r-1)==r-l-1&&(abs(node[l]-node[r])<2))\n\t{\n\t\treturn r-l+1;\n\t}\n\t\n\tfor(int i=1;i < r-l;i++)\n\t{\n\t\tret = max(ret,dfs(l,l+i)+dfs(l+i+1,r));\n\t}\n\t\n\treturn dp[l][r] = ret;\n}\n\nint main()\n{\n\twhile(cin >> n,n)\n\t{\n\t\t\n\t\tREP(i,310)REP(j,310)dp[i][j] = -1;\n\t\tnode.clear();\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tint tmp;cin >> tmp;\n\t\t\tnode.PB(tmp);\n\t\t}\n\t\t\n\t\tcout << dfs(0,n-1) << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nbool take[310][310];\n\nsigned main() {\n    int n;\n    while(cin >> n, n) {\n        int w[310];\n        rep(i,0,n) cin >> w[i];\n        memset(take, false, sizeof(take));\n\n        rep(i,0,n) {\n            rep(j,0,n-i) {\n                int len = i+1;\n                int s = j, t = j+i;\n                rep(k,s,t) {\n                    if(take[s][k] && take[k+1][t]) take[s][t] = true;\n                }\n                if(len == 2) {\n                    if(abs(w[s] - w[t]) < 2) {\n                        take[s][t] = true;\n                    }\n                }\n                if(take[s][t]) {\n                    int x = s-1, y = t+1;\n                    while(1) {\n                        if(x < 0 || x >= n || y < 0 || y >= n) break;\n                        if(abs(w[x] - w[y]) >= 2) break;\n                        take[x][y] = true;\n                        x--; y++;\n                    }\n                }\n            }\n        }\n\n        int dp[310][310] = {};\n        rep(i,0,n) rep(j,i+1,n) {\n            if(take[i][j]) dp[i][j] = j-i+1;\n        }\n\n        rep(i,0,n) rep(j,i,n) rep(k,i,j) {\n            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dp[310][310];\nint n;\nvector<int> node;\n\nint dfs(int l,int r)\n{\n\tif(l > r)return 0;\n\tif(l == r)return 0;\n\tif(dp[l][r] != -1)return dp[l][r];\n\tif(r - l == 1)return (abs(node[l]-node[r])<2)?2:0;\n\t\n\tint ret = 0;\n\t\n\tif(dfs(l+1,r-1)==r-l-1&&(abs(node[l]-node[r])<2))\n\t{\n\t\treturn r-l+1;\n\t}\n\t\n\tfor(int i=1;i < r-l;i++)\n\t{\n\t\tret = max(ret,dfs(l,l+i)+dfs(l+i+1,r));\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\twhile(cin >> n,n)\n\t{\n\t\t\n\t\tREP(i,310)REP(j,310)dp[i][j] = -1;\n\t\tnode.clear();\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tint tmp;cin >> tmp;\n\t\t\tnode.PB(tmp);\n\t\t}\n\t\t\n\t\tcout << dfs(0,n-1) << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = (0); i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define show2(x,y) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) << endl\n#define show3(x,y,z) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) <<  \", \" << #z << \" = \" << (z) << endl\n#define showv(v) rep(i,v.size()) printf(\"%d%c\", v[i], i==v.size()-1?'\\n':' ')\n#define showv2(v) rep(j,v.size()) showv(v[j])\n#define showt(t,n) rep(i,n) printf(\"%d%c\", t[i], i==n-1?'\\n':' ')\n#define showt2(t,r,c) rep(j,r) showt(t[j],c)\n#define showvp(p) rep(i,p.size()) printf(\"%d %d\\n\", p[i].first, p[i].second)\n#define printv(v) rep(i,v.size()) printf(\"%d\\n\", v[i])\n#define printt(t,n) rep(i,n) printf(\"%d\\n\", t[i])\n#define incl(v,x) (find(all(v),x)!=v.end())\n#define incls(s,c) (s.find(c)!=string::npos)\n#define lb(a,x) distance((a).begin(),lower_bound(all(a),(x)))\n#define ub(a,x) distance((a).begin(),upper_bound(all(a),(x)))\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define bit(n,k) ((n>>k)&1) // nのk bit目\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define SP << \" \" <<\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing vp = vector<P>;\nusing vt = vector<T>;\nconst int mod = 1000000007;\nconst double EPS = 1e-9;\n//const long double EPS = 1e-14;\nconst int INF = (1<<30)-1;\nconst ll LINF = (1LL<<62)-1;\n#define dame { puts(\"No\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\ninline int in() { int x; cin >> x; return x;}\ninline ll lin() { ll x; cin >> x; return x;}\ninline char chin() { char x; cin >> x; return x;}\ninline string stin() { string x; cin >> x; return x;}\ninline double din() { double x; cin >> x; return x;}\n//template<class T = int> inline T in() { T x; cin >> x; return (x);}\ntemplate<typename T>inline ll suma(const vector<T>& a) { ll res(0); for (auto&& x : a) res += x; return res;}\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nchar itoa(int n) { return n + '0';}\nll gcd(ll a, ll b) { return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) { return a/gcd(a,b)*b;}\nconst int dx[4] = {1, 0,-1, 0};\nconst int dy[4] = {0, 1, 0,-1};\n\nint n;\nvi w;\n//     i   j\n// 0 1 2 3 4 (n = 5)\n// dp[i][j]: 区間[i,j)に対して叩き出せるブロック数の最大値\n\nint solve() {\n\tvvi dp(n+1,vi(n+1,-1));\n\trep(i,n+1) {\n\t\tdp[i][i] = 0;\n\t\tif (i < n) dp[i][i+1] = 0;\n\t}\n\tfor (int len = 2; len <= n; ++len) {\n\t\tfor (int i = 0; i+len <= n; ++i) {\n\t\t\tint j = i+len;\n\t\t\t// [i+1,j-1)のブロックを全て叩き出せ、w[i]とw[j-1]のブロックが残る場合\n\t\t\tif (dp[i+1][j-1] == j-i-2) {\n\t\t\t\t// w[i]とw[j-1]のブロックも叩き出せる場合(+2)\n\t\t\t\tif (abs(w[i]-w[j-1]) <= 1) chmax(dp[i][j], dp[i+1][j-1]+2);\n\t\t\t\t// 叩き出せない場合(+0)\n\t\t\t\telse chmax(dp[i][j], dp[i+1][j-1]);\n\t\t\t}\n\t\t\t// あるkが存在して、区間[i,k)と区間[k,j)とは独立に操作したものとみなせる場合\n\t\t\tfor (int k = i+1; k <= j-1; ++k) {\n\t\t\t\tchmax(dp[i][j], dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n];\n}\n\nint main () {\n\twhile (true) {\n\t\tcin >> n;\n\t\tw = vi(n);\n\t\trep(i,n) cin >> w[i];\n\t\tif (n == 0) break;\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n#include <functional>\n\n#include <limits.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint solve(const vector<int> &as, const int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\n\n    function<int(int, int)> rec = [&](int l, int r) -> int {\n        // [l, r)\n        if (dp[l][r] >= 0) {\n            return dp[l][r];\n        }\n\n        int cand = 0;\n\n        if (r - l <= 1) {\n            // do nothing\n        } else if (r - l == 2) {\n            if (abs(as[l] - as[l + 1]) <= 1) {\n                cand = 2;\n            }\n        } else {\n            for (int i = l + 1; i < r; i++) {\n                chmax(cand, rec(l, i) + rec(i, r));\n            }\n\n            if ((r - l) % 2 == 0 && rec(l + 1, r - 1) == (r - l - 2) && abs(as[l] - as[r - 1]) <= 1) {\n                chmax(cand, rec(l + 1, r - 1) + 2);\n            }\n        }\n\n        dp[l][r] = cand;\n        return cand;\n    };\n\n    int ans = rec(0, n);\n\n    // printf(\"table: \\n\");\n    // for (int i = 0; i <= n; i++) {\n    //     for (int j = 0; j <= n; j++) {\n    //         cout << dp[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    return ans;\n}\n\nint main(void) {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        vector<int> as(n);\n        for (int i = 0; i < n; i++) {\n            cin >> as[i];\n        }\n\n        cout << solve(as, n) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nint n;\nint w[MAX];\nint done[305][305];\nint dp[305][305];\n\nvoid print_dp() {\n    rep(i, n) {\n        rep(j, n+1) {\n            cout << setw(3) << dp[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint ans(int l, int r) {\n    if (done[l][r]) {\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    if (r - l == 0) return 0;\n    if (r - l == 1) return 0; \n    if (l > r) return -INF;\n    if (r > n) return -INF;\n    if (r - l == 2) {\n        done[l][r] = true;\n        int res = 0;\n        if (abs(w[l] - w[l+1]) < 2) res = 2;\n        else res = 0;\n        dp[l][r] = res;\n        // if (test) {\n        //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n        // }\n        return dp[l][r];\n    }\n    int res = 0;\n    rep(width2, 2)\n    {\n        if (l + width2 > r)\n            break;\n        rep2(i, l, r)\n        {\n            if (i + width2 > r)\n                break;\n            if (i > r - width2)\n                break;\n            if (i == l && r - width2 == r) continue;\n            // if (i + width2 == l && i + width2 == r)\n            //     continue;\n            // if (i + width + width2 * 2 == l)\n            //     continue;\n            int tmp =\n                ans(l+width2, i) + ans(i, r-width2);\n\n            if (tmp == r - l - width2 * 2)\n            {\n                rep(j, width2)\n                {\n                    if (abs(w[l] - w[r - 1]) < 2)\n                    {\n                        tmp += 2;\n                    }\n                    else\n                        break;\n                }\n            }\n            res = max(res, tmp);\n        }\n    }\n\n    done[l][r] = true;\n    dp[l][r] = res;\n    // if (test) {\n    //     cout << \"dp[\" << l << \"][\" << r << \"] : \" << dp[l][r] << endl;\n    // }\n    return dp[l][r];\n}\n\nvoid solve() {\n    rep(i, 305) rep(j, 305) done[i][j] = false;\n    rep(i, 305) rep(j, 305) dp[i][j] = 0;\n    cin >> n;\n    if (n == 0) exit(0);\n    rep(i, n) cin >> w[i];\n    cout << ans(0, n) << endl;\n    if (test) print_dp();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvi num(n);\n\tREP(i, n)\n\t\tcin >> num[i];\n\tvector<vector<bool>> able(n, vb(n, false));\n\tfor (int i = 2;i < n + 1;i += 2) {\n\t\tfor (int j = 0;j + i - 1 < n;j++) {\n\t\t\tif (i == 2) {\n\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1)\n\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1 && able[j + 1][j + i - 2])\n\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\tREP(k, i / 2 - 1)\n\t\t\t\t\tif (able[j][j + k * 2 + 1] && able[j + k * 2+2][j + i - 1])\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvvi DP(n, vi(n, 0));\n\tREP(i, n)\n\t\tREP(j, n)\n\t\tif (able[i][j])\n\t\t\tDP[i][j] = j - i + 1;\n\tfor (int i = 3;i < n + 1;i++) {\n\t\tfor(int j=0;j+i-1<n;j++)\n\t\t\tREP(k,i-2)\n\t\t\tDP[j][j + i - 1] = max(DP[j][j + i - 1], DP[j][j+1+k]+ DP[j+2+k][j + i - 1]);\n\t}\n\tcout << DP[0][n - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MAX_N = 330;\nll dp[MAX_N][MAX_N];\nvector<ll> w(MAX_N, 0);\n\nint n;\n\nll rec(int l, int r)\n{\n    ll res = 0;\n    // 既に計算したことがある場合\n    if (dp[l][r] != -1)\n        return dp[l][r];\n\n    // 間に何もない場合(rは開区間なので)\n    if (abs(l - r) <= 1)\n    {\n        return 0;\n    }\n\n    if (abs(w[l] - w[r - 1]) <= 1 && rec(l + 1, r - 1) == r - l - 2)\n    {\n        res = r - l;\n    }\n\n    for (int mid = l + 1; mid <= r - 1; ++mid)\n    {\n        res = max(res, rec(l, mid) + rec(mid, r));\n    }\n\n    return dp[l][r] = res;\n}\n\nint main()\n{\n    while (1)\n    {\n        cin >> n;\n        if (n == 0)\n            break;\n\n        for (int i = 0; i < n; i++)\n        {\n            cin >> w[i];\n        }\n\n        for (int i = 0; i <= n; i++)\n        {\n            for (int j = 0; j <= n; j++)\n            {\n                dp[i][j] = -1;\n            }\n        }\n        cout << rec(0, n) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\n\nclass Solver {\n  public:\n    vector<int> W;\n    vector<vector<int>> DP;\n\n    // [i, j]\n    bool removable(int i, int j) {\n        if(i > j) return true;\n        if(i == j) return DP[i][j] = false;\n        if(DP[i][j] >= 0) return DP[i][j];\n\n        bool ok = false;\n        repeat(k, i + 1, j + 1) { // [i+1, j]\n            ok |= abs(W[i] - W[k]) <= 1 and removable(i + 1, k - 1) and removable(k + 1, j);\n        }\n        return DP[i][j] = ok;\n    }\n    \n    bool solve() {\n        int N; cin >> N;\n        if(not N) return false;\n        W.resize(N); cin >> W;\n\n        DP.resize(N, vector<int>(N, -1));\n        rep(i, N) rep(j, N) removable(i, j);\n\n        vector<int> max_removable(N + 1, 0);\n\n        rep(i, N) {\n            set_max(max_removable[i + 1], max_removable[i]);\n            repeat(j, i + 1, N) {                \n                if(removable(i, j)) set_max(max_removable[j + 1], max_removable[i] + j - i + 1);\n            }\n        }\n        cout << max_removable.back() << endl;\n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\nusing namespace std;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\twhile (N) {\n\t\tvector<int>num(N);\n\t\tfor (int i = 0; i < N; i++)cin >> num[i];\n\t\tvector<vector<int>>dp(N, vector<int>(N,0));\n\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\tif (abs(num[i] - num[i + 1]) < 2)dp[i][i + 1] = 2;\n\t\t}\n\t\tfor (int i = 4; i <= N; i += 2) {\n\t\t\tfor (int j = 0; i + j <= N; j++) {\n\t\t\t\tif (dp[j][i + j - 3] && dp[i + j - 2][i + j - 1]) {\n\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t}\n\t\t\t\tif (dp[j + 1][i + j - 2] && abs(num[j] - num[i + j - 1]) < 2) {\n\t\t\t\t\tdp[j][i + j - 1] = i;\n\t\t\t\t}\n\t\t\t\t//cout << j << \" \" << i + j - 1 << \" \" << dp[j][i + j - 1] << endl;\n\t\t\t}\n\t\t}\n\t\tvector<int>ret(N,0);\n\t\tret[1] = dp[0][1];\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tret[i] = dp[0][i];\n\t\t\tfor (int j = i - 1; j >= 1; j -= 2) {\n\t\t\t\tret[i] = max(ret[i], ret[j-1] + dp[j][i]);\n\t\t\t}\n\t\t//\tcout << i << \" \" << ret[i] << endl;\n\t\t}\n\t\tcout << ret[N - 1] << endl;\n\t\tcin >> N;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<vector<int>>dp(n,vector<int>(n,0));\n\t\tvector<int>array(n);\n\t\trep(i,n) cin >> array[i];\n\t\trep(k,n)rep(i,n){\n\t\t\tif(!k || i+k>=n)continue;\n\t\t\tif(k == 1){\n\t\t\t\tif(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 2;\n\t\t\t} else{\n\t\t\t\tif((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1] + 2 == k + 1)){\n\t\t\t\t\tdp[i][i+k] = k + 1;\n\t\t\t\t}\n\t\t\t\tfor(int j = i+1; j<i+k;j++){\n\t\t\t\t\tcmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n//#define MAX 300\nshort n;\nshort* w;\nvector<pair<short*,short> > wmap;\n\nshort* pop(short* w,short a) { //w???a????????¨a+1?????????????????????\n\tshort *t;\n\tt = new short[n];\n\tfor (short i = 0; i < n; i++) {\n\t\tif(i < a) t[i] = w[i];\n\t\telse t[i] = w[i + 2];\n\t}\n\tt[n - 2] = -1;\n\tt[n - 1] = -1;\n\treturn t;\n}\n\nshort daruma(short* w) {\n\tfor (short i = 0; i < wmap.size(); i++) {\n\t\tif (memcmp(w, wmap[i].first, sizeof(w)) == 0) {\n\t\t\treturn wmap[i].second;\n\t\t}\n\t}\n\n\tshort max = 0;\n\tfor (short i = 0; i < n - 1; i++) {\n\t\tif (w[i] != -1 && w[i + 1] != -1 && abs(w[i]-w[i+1])<=1) {\n\t\t\tshort tmp = daruma(pop(w, i))+2;\n\t\t\tif (tmp > max) max = tmp;\n\t\t}\n\t}\n\n\twmap.push_back(make_pair(w,max));\n\treturn max;\n}\n\nshort main() {\n\tcin >> n;\n\twhile (n) {\n\t\twmap.clear();\n\t\tw = new short[n]();\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << daruma(w) << endl;\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nint main(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<=n;i+=2)\n      for(int j=0;j<n-i;j++){\n        for(int k=1;k<i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=max(dp[j][j+i],i+1);\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w[300];\nint dp[310][310];\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        for(int i = 0; i < n; i++) cin >> w[i];\n        memset(dp, 0, sizeof dp);\n\n        for(int len = 2; len <= n; len++){\n            for(int l = 0; l + len <= n; l++){\n                for(int c = l + 1; c < l + len; c++){\n                    dp[l][l + len] = max(dp[l][l + len], dp[l][c] + dp[c][l + len]);\n                }\n                if(abs(w[l] - w[l + len - 1]) <= 1 && dp[l + 1][l + len - 1] == len - 2){\n                    dp[l][l + len] = len;\n                }\n                //printf(\"[%d, %d) = %d\\n\", l, l + len, dp[l][len] );\n            }\n        }\n\n        cout << dp[0][n] << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[301][301];\n\nint main(){\n    int n;\n    while(true){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(int i = 0; i < 301; ++i){\n            for(int j = 0; j < 301; ++j){\n                dp[i][j] = 0;\n            }\n        }\n        int w[n + 1];\n        w[0] = 0;\n        for(int i = 1; i < n + 1; ++i){\n            cin >> w[i];\n        }\n        for(int dif = 1; dif < n; ++dif){\n            for(int st = 1; st < n - dif + 1; ++st){\n                if(dp[st + 1][st + dif - 1] == dif - 1 && abs(w[st] - w[st + dif]) < 2){\n                    dp[st][st + dif] = dif + 1;\n                    continue;\n                }\n                for(int mid = st; mid < st + dif; ++mid){\n                    dp[st][st + dif] = max(dp[st][st + dif], dp[st][mid] + dp[mid + 1][st + dif]);\n                }\n            }\n        }\n        cout << dp[1][n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\n\t\tint w[1004] = {};\n\t\trep(i,n) cin >> w[i];\n\n\t\tbool dp1[305][305]={};\n\t\tvector<pii> v;\n\t\trep(i,n-1) if( abs(w[i] - w[i+1]) < 2 ){\n\t\t\tdp1[i][i+1] = true;\n\t\t\tv.emplace_back(i, i+1);\n\t\t}\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\tif( i+k >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && 0 < i && i+k+1 < n ){\n\t\t\t\t\tif( abs(w[i-1] - w[i+k+1]) < 2 ){\n\t\t\t\t\t\tdp1[i-1][i+k+1] = true;\n\t\t\t\t\t\tv.emplace_back(i-1, i+k+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n) rep(i,n){\n\t\t\t\tif( i+k+j >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && dp1[i+k+1][i+k+j] ){\n\t\t\t\t\tdp1[i][i+k+j] = true;\n\t\t\t\t\tv.emplace_back(i, i+k+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for(auto t: v) cout << t.X << \",\" << t.Y << \" \"; cout << endl;\n\t\tsort( v.begin(), v.end() );\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\n\t\tint dp[900005] = {}, pos=0;\n\t\trep(i,n) rep(k,n){\n\t\t\tif( i+k >= n ) break;\n\t\t\tif( dp1[i][i+k] ){\n\t\t\t\tdp[i+k+1] = max( dp[i+k+1], dp[i] + k+1 );\n\t\t\t}\n\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n\t\t}\n//\t\trep(i,n) cout << dp[i] << \" \"; cout << endl;\n\t\tcout << dp[n] << endl;\n//\t\trep(i,900002){\n//\t\t\twhile( pos < v.size() && v[pos].first == i ){\n//\t\t\t\tint d  = v[pos].X;\n//\t\t\t\tint nx = v[pos].Y + 1;\n//\t\t\t\tdp[nx] = max( dp[nx], dp[i] + nx - d );\n//\t\t\t\tpos++;\n//\t\t\t}\n//\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n//\t\t}\n//\t\tcout << dp[900002] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,n) FOR(i,0,(n))\n\ntypedef long long ll;\n\nconst int M=10000000;\nint dp[400][400];\n\nvector<int>wass;\nbool ok(int a, int b){\n    return abs(wass[a]-wass[b])<=1;\n}\nint solve(int l,int r){\n    if(dp[l][r]!=-1)return dp[l][r];\n    if(l==r)return dp[l][r]=0;\n    else if(l==r+1)return dp[l][r]=0;\n    else{\n        int ans=0;\n        for(int p=l+1;p<r;++p){\n            ans=max(ans,solve(l,p)+solve(p,r));\n        }\n        if(ok(l,r-1)){\n            if(solve(l+1,r-1)==r-l-2){\n                ans=r-l;\n            }\n        }\n        return dp[l][r]=ans;\n    }\n}\nint main()\n{\n    while(true){\n        for(int i=0;i<400;++i){\n            for(int j=0;j<400;++j){\n                dp[i][j]=-1;\n            }\n        }\n        int N;cin>>N;\n        if(!N)break;\n        wass.assign(N,0);\n\n        for(int i=0;i<N;++i){\n            cin>>wass[i];\n        }\n        int ans=solve(0,N);\n        cout<<ans<<endl;\n    }\n   \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while (cin >> n, n)\n    {\n        vector<int> w(n);\n        for (int i = 0; i < n; i++)\n            cin >> w[i];\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n        int ret = 0;\n        for (int i = 0; i < n - 1; i++)\n        {\n            if (abs(w[i] - w[i + 1]) <= 1)\n            {\n                dp[i][i + 1] = 2;\n                ret = 2;\n            }\n        }\n        for (int i = 3; i <= n; i++)\n        {\n            for (int j = 0; j <= n - i; j++)\n            {\n                if (dp[j + 1][j + i - 2] == i - 2 && abs(w[j] - w[j + i - 1]) <= 1)\n                {\n                    dp[j][j + i - 1] = i;\n                    ret = i;\n                }\n                else\n                {\n                    for (int k = j + 1; k <= j + i - 1; k++)\n                    {\n                        dp[j][j + i - 1] = max(dp[j][j + i - 1], dp[j][k - 1] + dp[k][j + i - 1]);\n                    }\n                    ret = max(ret, dp[j][j + i - 1]);\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint solve(int n){\n    vector<int> w(n);\n    for(int i=0;i<n;i++) cin>>w[i];\n    vector<vector<int>> dp(n+1,vector<int>(n+1,false));\n    for(int i=0;i<=n;i++) dp[i][i]=true;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j+i<=n;j++){\n            for(int k=j+1;k<j+i;k++){                \n                dp[j][i+j]|=(abs(w[j]-w[k])<=1) && dp[j+1][k] && dp[k+1][i+j];\n            }\n        }\n    }\n    vector<int> res(n+1,0);\n    for(int i=0;i<n;i++){\n        res[i+1]=max(res[i+1],res[i]);\n        for(int j=0;j<=n;j++){\n            if(dp[i][j]) res[j]=max(res[j],res[i]+j-i);\n        }\n    }\n    return res[n];\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    int w[n];\n    for(int i = 0; i < n; ++i)\n      cin >> w[i];\n    \n    int dp[n][n];\n    for(int i = 0; i < n; ++i){\n      fill(dp[i],dp[i]+n,0);\n    }\n    \n    for(int i = 0; i < n-1; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(j+i+1 > n-1) break;\n\tif(dp[j+1][j+i] == i && abs(w[j]-w[j+i+1]) < 2){\n\t  dp[j][j+i+1] = dp[j+1][j+i] + 2;\n\t}else{\n\t  for(int k = 0; k < i; ++k){\n\t    dp[j][j+i+1] = max(dp[j][j+i+1],dp[j][j+k]+dp[j+k+1][j+i+1]);\n\t  }\n\t}\n      }\n    }\n    /*\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n\tcout << dp[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n    cout << dp[0][n-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nint N;\nvector<int> w;\n\nint solve() {\n    vector<vector<int>> dp(N+1, vector<int>(N+1, -N));\n    for (int i = 0; i <= N; ++i) {\n        dp[i][i] = 0;\n        if (i < N) dp[i][i+1] = 0;\n    }\n    for (int bet = 2; bet <= N; ++bet) {\n        for (int i = 0; i + bet <= N; ++i) {\n            int j = i + bet;\n \n            // 1. 全部取り除けるかもしれないとき\n            if ( abs(w[i]- w[j-1]) <= 1){\n                if ( dp[i+1][j-1] == j-i-2) chmax(dp[i][j],j-i);\n            }\n            \n            // 2. otherwise\n            for (int k = i+1; k <= j-1; ++k) {\n                chmax(dp[i][j], dp[i][k] + dp[k][j]);\n            }\n            \n        }\n    }\n    return dp[0][N];\n}\n\nint main() {\n    while (cin >> N, N) {\n        w.resize(N);\n        for (int i = 0; i < N; ++i) cin >> w[i];\n        cout << solve() << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n//#define MAX 300\nint n;\nint* w;\nvector<pair<int*,int>> wmap;\n\nint* pop(int* w,int a) { //w???a????????¨a+1?????????????????????\n\tint *t;\n\tt = new int[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tif(i < a) t[i] = w[i];\n\t\telse t[i] = w[i + 2];\n\t}\n\tt[n - 2] = -1;\n\tt[n - 1] = -1;\n\treturn t;\n}\n\n\nint daruma(int* w) {\n\tfor (int i = 0; i < wmap.size(); i++) {\n\t\tif (memcmp(w, wmap[i].first, sizeof(w)) == 0) {\n\t\t\treturn wmap[i].second;\n\t\t}\n\t}\n\n\tint max = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (w[i] != -1 && w[i + 1] != -1 && abs(w[i]-w[i+1])<=1) {\n\t\t\tint tmp = daruma(pop(w, i))+2;\n\t\t\tif (tmp > max) max = tmp;\n\t\t}\n\t}\n\n\twmap.push_back(make_pair(w,max));\n\treturn max;\n}\n\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\tw = new int[n]();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << daruma(w) << endl;\n\n\n\t\tcin >> n;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long MAX = 5100000;\nconst long long INF = 1LL << 60;\nconst long long mod = 1000000007LL;\n//const long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nll n;\nvector<ll> a;\nll dp[350][350];\n\nll dfs(ll left, ll right) {\n\tif (dp[left][right] != -1) return dp[left][right];\n\tif (left == right) return 0;\n\tif (left + 1 == right) return 0;\n\tll res = 0;\n\tfor (ll i = left + 1; i < right; i++) {\n\t\tchmax(res, dfs(left, i) + dfs(i, right));\n\t}\n\tif (llabs(a[right - 1] - a[left]) <= 1 && dfs(left + 1, right - 1) == (right - left - 2)) {\n\t\tchmax(res, dfs(left + 1, right - 1) + 2);\n\t}\n\treturn dp[left][right] = res;\n}\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\twhile (1) {\n\t\tll n; scanf(\"%lld\", &n);\n\t\tif (n == 0) break;\n\t\ta.resize(n); for (ll i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\t\tfor (ll i = 0; i <= n; i++) for (ll j = 0; j <= n; j++) dp[i][j] = -1;\n\t\tprintf(\"%lld\\n\", dfs(0, n));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint w[301];\nint dp[301][301];\n\nint func(int l,int r){\n\tif(dp[l][r]!=-1)return dp[l][r];\n\tif(l+1>=r)return 0;\n\tif(l+2==r){\n\t\tif(abs(w[l]-w[l+1])<=1)return 2;\n\t\telse return 0;\n\t}\n\tint res=0;\n\tres=max(res,func(l+1,r));\n\tres=max(res,func(l+2,r)+(abs(w[l]-w[l+1])<=1?2:0));\n\tres=max(res,func(l,r-1));\n\tres=max(res,func(l,r-2)+(abs(w[r-1]-w[r-2])<=1?2:0));\n\tif(abs(w[l]-w[r-1])<=1){\n\t\tint v=func(l+1,r-1);\n\t\tif(v==((r-1)-(l+1))){\n\t\t\tres=r-l;\n\t\t}\n\t}\n\treturn (dp[l][r]=res);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&w[i]);\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tprintf(\"%d\\n\",func(0,n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\t#include <iostream>\n\t#include <cstdio>\n\t#include <algorithm>\n\t#include <string>\n\t#include <cstring>\n\t#include <cctype>\n\t#include <cmath>\n\t#include <stack>\n\t#include <queue>\n\t#include <vector>\n\t#include <set>\n\t#include <map>\n\t#include <list>\n\t#include <stdio.h>\n\t#include <string.h>\n\t#include <cstdlib>\n\t#include <math.h>\n\t#include <bitset>\n\t#include <iterator>\n\t#include <iomanip>\n\t#include <sstream>\n\t#include <numeric>\n\t#include <cassert>\n\tusing namespace std;\n\tint dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0};\n\tlong long gcd(long long a,long long b){if(a%b==0){return b;}else return gcd(b,a%b);}\n\tlong long lcm(long long a,long long b){if(a==0){return b;} return a/gcd(a,b)*b;}\n\t#define INF 2000000000\n\t#define MOD 1000000007\n\t#define sym cout<<\"---------\"<<endl;\n\t#define ll long long\n\t#define mk make_pair\n\t#define en endl\n\t#define RE return 0\n\t#define int ll\n\t#define P pair<int,int>\n\t\n\tint dp[305][305];\n\nsigned main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint w[305];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor(int i=0; i<n; i++) cin>>w[i];\n\t\t\n\t\tfor(int W=2; W<=n; W++){\n\t\t\tfor(int l=0; l<n; l++){\n\t\t\t\tint r=l+W;\n\t\t\t\t\n\t\t\t\tif(dp[l+1][r-1]==W-2&&abs(w[l]-w[r-1])<=1) dp[l][r]=W;\n\t\t\t\t\n\t\t\t\tfor(int mid=l; mid<=r; mid++){\n\t\t\t\t\tdp[l][r]=max(dp[l][r], dp[l][mid]+dp[mid][r]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][n]<<en;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct ans\n{\n    int i;\n    vector<vector<ll>> dp;\n    vector<ll> w;\n    ans(ll n): dp(n+1, vector<ll>(n+1,-1)), w(n){}\n    ll rec(ll l, ll r){\n        int i;\n        if(dp.at(l).at(r) != -1){\n            return dp.at(l).at(r);\n        }\n        if(abs(l-r) <= 1){\n            return 0;\n        }\n        ll tmp = 0;\n        if(abs(w.at(l) - w.at(r-1)) <= 1 && rec(l+1,r-1) == r-l-2){\n            tmp = r - l;\n        }else{\n            for(i = l+1; i <= r-1;++i){\n                tmp = max(tmp, rec(l,i) + rec(i,r));\n            }\n        }\n        return dp.at(l).at(r) = tmp;\n    }\n};\n\n\n\nint main()\n{\n    ll i,j;\n    while(true){\n        ll n;\n        cin >> n;\n        if(n == 0){\n            return 0;\n        }else{\n            ans ans(n);\n            for(i = 0;i < n;++i){\n                cin >> ans.w.at(i);\n            }\n            cout << max((ll)0,ans.rec(0, n)) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n\nvoid Yes(){\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n}\n \nvoid No(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\nint dp[330][330];\nint n;\nint w[330];\n\nint rec(int l, int r) {\n    if(dp[l][r] != -1) return dp[l][r];\n    if(abs(r - l) <= 1) return 0;\n\n    int res = 0;\n    if(abs(w[l] - w[r - 1]) <= 1 && rec(l + 1, r - 1) == r - l - 2) {\n        res = r - l;\n    }\n    for(int mid = l + 1; mid <= r - 1; mid++) {\n        res = max(res, rec(l, mid) + rec(mid, r));\n    }\n    return dp[l][r] = res;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    for(;;) {\n        cin >> n;\n        if(n == 0) break;\n        rep(i, n) cin >> w[i];\n        rep(i, n + 1) rep(j, n + 1) dp[i][j] = -1;\n        cout << rec(0, n) << endl;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define D(x) cout << #x \" = \" << x << endl\n#define DD(x, y) cout << \"(\" #x \", \" #y \") = (\" << x << \", \" << y << \")\" << endl\n#define DDD(x, y, z) cout << \"(\" #x \", \" #y \", \" #z \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define DV(v) for (auto __macro_vi : v){ cout << __macro_vi << \"\\t\";} cout << endl;\n#define DA(a, n) for (int __macro_i = 0; __macro_i < n; ++__macro_i) { cout << a[__macro_i] << \" \"; } cout << endl;\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define ALL(v) (v).begin(), (v).end()\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<cmath>\n\nusing namespace std;\n\nvector<int> w;\nvector<vector<int>> dp;\nint n;\n\nint f(int i, int j) {\n    if (dp[i][j] != -1) return dp[i][j];\n    assert(i <= j);\n    if (i + 1 >= j) {dp[i][j] = 0; return 0;}\n    int ans = max(f(i, j - 1), f(i + 1, j));\n    for (int k = i; k < j - 1; ++k) {\n        if (abs(w[j - 1] - w[k]) <= 1) {\n            if (f(k + 1, j) != j - (k + 1) - 1) continue;\n            ans = max(ans, f(i, k) + f(k + 1, j - 1) + 2);\n        }\n    }\n    dp[i][j] = ans;\n    return ans;\n}\n\nvoid solve() {\n    dp = vector<vector<int>>(n + 1, vector<int>(n + 1, -1));\n    cout << f(0, n) << endl;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        cin >> n;\n        if (n == 0) break;\n        w.resize(n);\n        REP(i, n) cin >> w[i];\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 48\n    https://onlinejudge.u-aizu.ac.jp/problems/1611\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* constant */\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 50;\nconst int NIL = -1;\nconst int MAX = 306;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\n/* global variables */\nint n;\nvector<int> w(MAX);\nvector<vector<int>> dp(MAX, vector<int>(MAX));\n/* function */\nvoid inputW() {for (int i = 0; i < n; i++) cin >> w[i];}\nvoid init() { for (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) dp[i][j] = 0; }\nvoid calcDP() {\n    // dp[s][t] = s ~ t番目を使ってられる最大値\n    // s |s+1| ... |t-1| tの時の遷移\n    // 1) |s+1| ~ |t-1| まで全部落とせる場合\n    //    if (dp[s+1][t-1] == t-s-1 && abs(w[s] - w[t]) <= 1)\n    //      dp[s][t] = dp[s+1][t-1] + 2\n    // 2) 分割候補を探索して最大値を探す\n    //    for k = s+1, ..., t-1\n    //      dp[s][t] = max(dp[s][t], dp[s][k] + dp[k+1][t])\n    for (int i = 1; i < n; i++) {  // s ~ t(=s+i)まで\n        for (int s = 0; s < n - i; s++) {  // start位置\n            int t = s + i;  // end位置\n            // 1)\n            if (dp[s+1][t-1] == t-s-1)\n                dp[s][t] = dp[s+1][t-1] + (abs(w[s] - w[t]) <= 1 ? 2 : 0);\n            // 2)\n            for (int k = s+1; k <= t-1; k++)\n                dp[s][t] = max(dp[s][t], dp[s][k] + dp[k+1][t]);\n        }\n    }\n}\nvoid printAns() { cout << dp[0][n-1] << '\\n'; }\n/* main */\nint main(){\n    while (cin >> n) {\n        if (n == 0) return 0;\n        inputW();\n        init();\n        calcDP();\n        printAns();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD=1000000007;\n#define INF 1LL<<30\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n\nint dp[310][310];\nint w[310];\n\nint rec(int l,int r){\n    if(dp[l][r]!=-1) return dp[l][r];\n    if(abs(l-r)<=1) return 0;\n\n    int res=0;\n    if(abs(w[l]-w[r-1])<=1 && rec(l+1,r-1)==r-l-2){\n        res=r-l;\n    }\n    for(int mid=l+1;mid<=r-1;mid++){\n        res=max(res,rec(l,mid)+rec(mid,r));\n    }\n    return dp[l][r]=res;\n}\n\nint main() {\n    while(1){\n        int n;\n        cin>>n;\n        if(n==0) break;\n        rep(i,n) cin>>w[i];\n        rep(i,310) rep(j,310) dp[i][j]=-1;\n        cout<<rec(0,n)<<endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint a1 = j, a2 = i + j - 1; if (a2 >= n)continue;\n\t\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\t\tif (a1 > 1 && abs(a[a1 - 1] - a[a1 - 2]) <= 1)dp[a1 - 2][a2] = 1;\n\t\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\tfor (int k = i + 1; k <= j; k++) {\n\t\t\t\t\tint a1 = i, a2 = k, a3 = j; if (a3 > n)continue;\n\t\t\t\t\tdp[a1][a3 - 1] = max(dp[a1][a3 - 1], dp[a1][a2 - 1] + dp[a2][a3 - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  unsigned int N = 0;\n  vector<int> num;\n  int w = 0;\n  vector<int> answer;\n\n  cin >> N;\n  while(N != 0) {\n    for(unsigned int i = 0; i < N; i++) {\n      cin >> w;\n      num.push_back(w);\n    }\n\n    while(true) {\n      unsigned int i;\n      for(i = num.size()-1; i > 0; i--)\n\tif(num.at(i)-num.at(i-1) >= -1 && num.at(i)-num.at(i-1) <= 1)\n\t  break;\n\n      if(i == 0)\n\tbreak;\n      num.erase(num.begin()+i);\n      num.erase(num.begin()+i-1);\n      \n      if(num.empty())\n\tbreak;\n    }\n\n    answer.push_back(N-num.size());\n\n    num.clear();\n\n    cin >> N;\n  }\n\n  for(int j = 0; j < answer.size(); j++)\n    cout << answer.at(j) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vi = std::vector<int>;\n\tusing vvi = std::vector<vi>;\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tvi w(n);\n\t\tfor (auto& e: w) scanf(\"%d\", &e);\n\n\t\tvvi dp(n, vi(n + 1));\n\t\t// [left, right)\n\t\tfor (int width{2}; width <= n; width++)\n\t\t\tfor (int left{}; left + width <= n; left++)\n\t\t\t{\n\t\t\t\tint right{left + width};\n\t\t\t\tfor (int mid{left + 1}; mid < right; mid++)\n\t\t\t\t\tdp[left][right] = std::max(dp[left][right], dp[left][mid] + dp[mid][right]);\n\t\t\t\tif (std::abs(w[left] - w[right - 1]) <= 1 && dp[left + 1][right - 1] + 2 == width)\n\t\t\t\t\tdp[left][right] = width;\n\t\t\t}\n\t\tprintf(\"%d\\n\", dp[0][n]);\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = (long long)1e9 + 7; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n#define MAX\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\twhile(true) {\n\t\tint n;\n\t\tvector<int> w;\n\t\tvector<vector<int>> dp;\n\t\t\n\t\tcin >> n;\n\t\t\n\t\tif(!n) break;\n\t\t\n\t\tw.resize(n);\n\t\tdp.resize(n+1, vector<int>(n+1, 0));\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> w[i];\n\t\t}\n\t\t\n\t\t\n\t\tfor(int k = 2; k <= n; k++){\n\t\t\tfor(int i = 0; i < n && i + k <= n; i++){\n\t\t\t\tint j = i + k;\n\t\t\t\t\n\t\t\t\tif(abs(w[i] - w[j-1]) <= 1 && dp[i+1][j-1] == k - 2){\n\t\t\t\t\tdp[i][j] = k;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int l = i + 1; l < j; l++){\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][l] + dp[l][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<dp[0][n]<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n-1){\n            if(!k || i+k>n-1)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n                    cmax(dp[i][i+k],dp[i+1][i+k-1]+2);\n                }\n                for(int j = i+1; j<i+k;j++){\n                    if(dp[i][j] && dp[j+1][i+k])cmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = n-1; j>=0;--j){\n                if(dp[i][j]){\n                    ans += j-i+1;\n                    i = j;\n                    break;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define OK(x,y) abs(w[x]-w[y])<=1\nint n, w[311];\nint dp[311][311];\n\nint main(){\n  while(cin>>n&&n){\n    REP(i,n) cin>>w[i];\n    memset(dp, 0, sizeof dp);\n\n    for(int j=1; j<n; j++){\n      for(int i=0; i+j<n; i++){\n        if(OK(i,i+j) && dp[i+1][i+j-1]==j-1){\n          dp[i][i+j]=j+1;\n        }\n\n        for(int k=i; k<=i+j; k++){\n          dp[i][i+j]=max(dp[i][i+j], dp[i][k]+dp[k+1][i+j]);\n        }\n      }\n    }\n    cout << dp[0][n-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nint w[305], dp[305][305];\nsigned main(void)\n{\n\twhile(true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tREP(i, n) cin >> w[i];\n\t\tREP(i, 305) REP(j, 305) dp[i][j] = 0;\n\n\t\tFOR(W, 2, n+1) {\n\t\t\tREP(i, n) {\n\t\t\t\tint j = i+W-1;\n\t\t\t\tif(j >= n) continue;\n\n\t\t\t\tif(dp[i+1][j-1] == W-2 && abs(w[i] - w[j]) <= 1) dp[i][j] = W;\n\t\t\t\tFOR(k, i, j) {\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n-1] << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tint n;\n\tbool **check;\n\tint *dp;\n\twhile (cin >> n&&n != 0) {\n\t\tint *line;\n\t\tdp = new int[n + 1]{ 0 };\n\t\tline = new int[n];\n\t\tcheck = new bool*[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> line[i];\n\t\t\tcheck[i] = new bool[n] {0};\n\t\t}\n\t\tfor (int i = 0, nmax = n - 1; i < nmax; ++i) {\n\t\t\tif (abs(line[i] - line[i + 1]) < 2) {\n\t\t\t\tcheck[i][i + 1] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 3, nmax = n; i < nmax; i += 2) {\n\t\t\tfor (int j = 0, mmax = n - i; j < mmax; ++j) {\n\t\t\t\tif ((check[j][j + 1] && check[j + 2][j + i]) || (check[j][j + i - 2] && check[j + i - 1][j + i]) || (check[j + 1][j + i - 1] && abs(line[j + i] - line[j]) < 2)) {\n\t\t\t\t\tcheck[j][j + i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdp[i + 1] = max(dp[i + 1], dp[i]);\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (check[i][j]) {\n\t\t\t\t\tdp[j + 1] = max(dp[j + 1], dp[i] + j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << endl;\n\t\tdelete[] dp;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdelete[] check[i];\n\t\t}\n\t\tdelete[] check;\n\t\tdelete[] line;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint n;\nvi w;\nint dp[333][333];\nvector<vector<bool>> del;\n\nint del_all(int left, int right)\n{\n\tif (dp[left][right] >= 0) return dp[left][right];\n\tint res = 0;\n\tif (left > right) res = 0;\n\telse if (left == right) res = 1;\n\telse\n\t{\n\t\tFOR(i, left + 1, right)\n\t\t{\n\t\t\tif (del_all(left, i) && del_all(i, right)) res = 1;\n\t\t\tif (abs(w[left] - w[right - 1]) <= 1 && del_all(left + 1, right - 1)) res = 1;\n\t\t}\n\t}\n\treturn dp[left][right] = res;\n}\n\nint dp2[333];\n\nint solve(int p)\n{\n\tif (dp2[p] >= 0) return dp2[p];\n\tif (p == n) return 0;\n\tint res = 0;\n\tchmax(res, solve(p + 1));\n\tFOR(i, 1, n + 1)\n\t{\n\t\tif (del[p][i])\n\t\t{\n\t\t\tchmax(res, i - p + solve(i));\n\t\t}\n\t}\n\treturn dp2[p] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n, n)\n\t{\n\t\tMS(dp, -1);\n\t\tMS(dp2, -1);\n\t\tw.resize(n);\n\t\tREP(i, n) cin >> w[i];\n\t\tint ans = 0;\n\t\tdel.clear();\n\t\tdel.resize(n + 1, vector<bool>(n + 1));\n\t\tREP(i, n + 1)REP(j, i)\n\t\t{\n\t\t\tif (del_all(j, i))\n\t\t\t{\n\t\t\t\tdel[j][i] = true;\n\t\t\t}\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define REP(i, n) for(int i = 1; i < (int)(n); ++i)\nusing namespace std;\n\nvector<vector<int>> dp(400, vector<int>(400));\nvector<int> a(400);\n\nint rec(int l, int r) {\n    if (abs(r - l) < 2) return 0;\n    if (dp[l][r] != -1) return dp[l][r];\n    \n    int res = 0;\n    if (abs(a[r - 1] - a[l]) < 2 && rec(l + 1, r - 1) == r - l - 2) res = r - l;\n    for (int mid = l + 1; mid < r; ++mid) res = max(res, rec(l, mid) + rec(mid, r));\n    dp[l][r] = res;\n    return res;\n}\n\nint main() {\n    while (true) {\n        rep(i, 400) a[i] = 0;\n        rep(i, 400) rep(j, 400) dp[i][j] = -1;\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        rep(i, n) cin >> a[i];\n        cout << rec(0, n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(pair<int, int> a, pair<int, int> b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\n\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\nvector<vector<ll>> dp(405,vector<ll>(405,-1));\nvector<ll> w(400);\nll N;\n\n\nll daruma(ll l, ll r){\n\n    if(dp[l][r] >= 0){\n        return dp[l][r];\n    } \n    if(abs(l - r) <= 1) return 0;\n\n    ll ret = 0;  \n    if(daruma(l+1,r-1) == r-l-2 && abs(w[r-1]-w[l]) <= 1){\n        ret = r-l;\n    }else{\n        for(ll mid = l+1;mid <=r-1;mid++){\n            chmax(ret,daruma(l,mid)+daruma(mid,r));\n        }\n    }\n\n    return dp[l][r] = ret;\n}\n\nint main() {\n    while(1){\n    cin >> N;\n    //dp.clear();\n    rep(i,400){\n        rep(j,400){\n            dp[i][j] = -1;\n        }\n    }\n    w.clear();\n    if(N==0)break;\n    rep(i,N){\n        cin >> w[i];\n    }\n    //cout << \"OK\"<<endl;\n    /*rep(i,N){\n        dp[i][i] = 0;\n    }*/\n    \n    ll ans = 0;\n\n    \n\n    cout <<daruma(0,N)<<endl;;\n    }\n    return 0;\n    \n\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nint N;\nbool ok[1001][1001];\nint dp[1001][1001];\nint ans[1001];\nint main(){\n    while(cin>>N,N){\n       vector<int>v(N);\n       REP(i,N)cin>>v[i];\n       REP(i,1001)REP(j,1001){ok[i][j]=false;dp[i][j]=0;}\n       //ok????????????\n       /*REP(i,N){\n           for(int j=i+1;j<N;j++){\n               if(j-i==1&&abs(v[i]-v[j])<=1){ok[i][j]=true;dp[i][j]=2;continue;}\n               if(j-i==2){ok[i][j]=false;dp[i][j]=0;continue;}\n               for(int k=i+1;k+1<j;k++){\n                   if(abs(v[i]-v[j])>1)continue;\n                   if(ok[i][k]==false)continue;\n                   if(ok[k+1][j]==false)continue;\n                   ok[i][j]=true;\n                   dp[i][j]=j-i+1;\n               }\n           }\n       }*/\n       for(int k=1;k<=N-1;k++){\n          REP(i,N){\n              if(i+k>=N)continue;\n              if(k==1&&abs(v[i]-v[i+1])<=1){ok[i][i+1]=true;dp[i][i+1]=2;continue;};\n              if(k==2){ok[i][i+2]=false;dp[i][i+2]=0;continue;}\n              if(abs(v[i]-v[i+k])<=1&&ok[i+1][i+k-1]==true){ok[i][i+k]=true;dp[i][i+k]=k+1;}\n              for(int j=1;j<=k;j++){\n                  if(ok[i][i+j]&&ok[i+j+1][i+k]){ok[i][i+k]=true;dp[i][i+k]=k+1;}\n                  if(abs(v[i]-v[i+j]>1))continue;\n                  if(ok[i][i+j-1]==false)continue;\n                  if(ok[i+j+1][i+k]==false)continue;\n                  ok[i][i+k]=true;\n                  dp[i][i+k]=k+1;\n              }\n          }\n       }\n       REP(i,1001){\n           ans[i]=0;\n       }\n       for(int i=1;i<N;i++){\n           ans[i]=max(ans[i],ans[i-1]);\n           ans[i]=max(ans[i],dp[0][i]);\n           for(int j=1;j<i;j++){\n               ans[i]=max(ans[i],ans[j]+dp[j+1][i]);\n           }\n       }\n       //REP(i,N){REP(j,N)cout<<dp[i][j]<<\" \";cout<<endl;}\n       //REP(i,N)cout<<ans[i]<<endl;\n       cout<<ans[N-1]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define MAX 310\n\nint n,w[MAX];\nint memo[MAX][MAX];\n\nbool dfs(int L,int R) { // memo??????????????¨??§\n\n\n\n  if( R - L <= 1 ) {\n    return memo[L][R] = 0;\n  }\n  if( R - L <= 2 ) {\n    assert( R-1 < n);\n    if( abs(w[R-1] - w[L]) <= 1 ) {\n      memo[L][R] = 1;\n    } else {\n      memo[L][R] = 0;\n    }\n    return memo[L][R];\n  }\n  if( memo[L][R] != -1 ) return memo[L][R];\n  int &ret = memo[L][R];\n  ret = 0;\n  for(int med=L;med<R;++med) {\n    if( dfs(L,med+1) && dfs(med+1,R) ) {\n      ret = 1;\n      break;\n    }\n  }\n\n\n\n  if( ret == 0 ) {\n    if( abs(w[L]-w[R-1] ) <= 1 )  {\n      if( dfs(L+1,R-1) ) {\n\tret = 1;\n      }\n    }\n  }\n Fin:;\n  return ret;\n}\n\nint dp[MAX];\n\nvoid compute() {\n  memset(memo,-1,sizeof memo);\n  rep(i,n) memo[i][i+1] = 0;\n  REP(len,2,n+1) {\n    for(int L=0;L<n;++L) {\n      int R = L + len;\n      if( R > n ) break;\n      dfs(L,R);\n    }\n  }\n  //rep(L,n) for(int R=L+1;R<=n;++R) dfs(L,R); // [0,n)\n  /*\n  rep(L,n) for(int R=L+1;R<=n;++R) {\n    cout << \"[\" << L << \",\" << R << \") = \" << memo[L][R]  << endl;\n  }\n  */\n\n  memset(dp,0,sizeof dp);\n  int maxi = 0;\n  rep(i,n) {\n    dp[i] = max(dp[i],dp[i-1]);\n    REP(j,i+1,n+1) {\n      int cost = -1;\n      if( memo[i][j] ) {\n\tcost = ( j - i)  ;\n      }\n      if( cost == -1 ) continue;\n      if( dp[j] < dp[i] + cost ) {\n\tdp[j] = dp[i] + cost;\n\tmaxi = max(maxi,dp[j]);\n      }\n    }\n  }\n  cout << maxi << endl;\n}\n\nint main(){\n  while( cin >> n, n ) {\n    rep(i,n) cin >> w[i];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// written by @kakira9618\n// problem: http://icpc.iisf.or.jp/past-icpc/domestic2016/problems/all_ja.html#section_D\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\nint n;\nvector<int> W;\nint dp[301][301];\n\n// O(n^3)\nint dfs(int l, int r) {\n    if (r - l <= 1) return dp[l][r] = 0;\n    if (dp[l][r] != -1) return dp[l][r]; // ?????¢???\n    int ans = 0;\n    \n    // i????????§??????????????????????¨?????????????????§£??????\n    for(int i = l + 1; i < r; i++) {\n        ans = max(ans, dfs(l, i) + dfs(i, r));\n    }\n    \n    // ?????£???2??????????????¶?????????1??\\???????????????????????¨????¶??????????????????°?????£????????????????¶???????\n    if (abs(W[r - 1] - W[l]) <= 1) {\n        if (dfs(l + 1, r - 1) == r - l - 2) {\n            ans = max(ans, dfs(l + 1, r - 1) + 2);\n        }\n    }\n    return dp[l][r] = ans;\n}\n\nint main() {\n    while(cin >> n, n) {\n        memset(dp, -1, sizeof(int) * 301 * 301);\n        W.clear();\n        W.resize(n);\n        for(int i = 0; i < n; i++) {\n            cin >> W[i];\n        }\n        cout << dfs(0, n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, -1, 1};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define mp make_pair\n#define fi first\n#define sc second\nll n,w[400];\nll dp[500][500];\n\nll ans(ll i,ll j) {// i <= j\n\tif(dp[i][j] > -1) {\n\t\treturn dp[i][j];\n\t}\n\n\tif(j - i <= 1) {\n\t\tif(j - i == 1 && abs(w[i] - w[j]) < 2) {\n\t\t\treturn dp[i][j] = 2;\n\t\t}\n\t\telse\n\t\t\treturn dp[i][j] = 0;\n\t}\n\n\tif(ans(i + 1,j - 1) == j - i - 1 && abs(w[i] - w[j]) < 2) {\n\t\treturn dp[i][j] = j - i + 1;\n\t}\n\n\tll ret = 0;\n\n\tREP(k,j - i) {\n\t\tret = max(ret,ans(i,i + k) + ans(i + k + 1,j));\n\t}\n\treturn dp[i][j] = ret;\n}\n\nvoid solve() {\n\tREP(i,n) {\n\t\tREP(j,n) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\tcout << ans(0,n - 1) << endl;\n}\n\nint main(){\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(n == 0) \n\t\t\tbreak;\n\t\tREP(i,n) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define rep(i,n) for(ll i=0;i<n;++i)\n#define ALL(a) (a).begin(),(a).end()\n \nusing namespace std;\nusing ll  = long long;\nusing pll = pair<ll, ll>;\n \nconst ll MOD  = 1e9+7;\nconst ll LINF = 1LL << 60;\nconst int INF = 1e9 + 7;\n\nint main(){\n    vector<int> ans;\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n\n        vector<int> w(n);\n        rep(i, n)cin >> w[i];\n\n        ll dp[n+1][n+1] = {};\n\n        //i個の達磨を考える\n        for(int i = 2; i <= n; ++i){\n            for(int l = 0; l+i-1 < n; ++l){\n                int r = i+l-1;\n\n                //真ん中が全部消せるのであればlとrが隣あう\n                if(dp[l+1][r-1] == i-2 && abs(w[l] - w[r]) <= 1){\n                    dp[l][r] = dp[l+1][r-1] + 2;\n                }\n                \n                for(int c = l; c < r; ++c){\n                    dp[l][r] = max(dp[l][r], dp[l][c] + dp[c+1][r]);\n                }\n             }\n        }\n\n        ans.push_back(dp[0][n-1]);\n    }\n\n    rep(i, ans.size())cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<string>\n#include<cmath>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<iomanip>\n#include<cctype>\n#include<map>\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rep2(i,a,b) for (int (i)=a;(i)<(b);(i)++)\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\nconst int inf = 1001001000;\n\nvoid print(vector<vector<int>> a){\n\tfor (int i=0;i<a.size();i++){\n\t\tfor (int j=0;j<a[i].size();j++){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid print(vector<vector<long long int>> a){\n\tfor (int i=0;i<a.size();i++){\n\t\tfor (int j=0;j<a[i].size();j++){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid print(vector<int> a){\n    int n = a.size();\n    for (int j=0;j<n;j++) {\n        if (j != n-1) cout << a[j] << \" \";\n        else cout << a[j] << endl;\n    }\n}\n\n// int rec(vector<vector<int>> &dp, vector<int> &daruma, int i, int j){\n// \tif (dp[i][j] =! -1)\n// \t\treturn dp[i][j];\n// \tif (j - i <= 1)\n// \t\treturn dp[i][j] = 0;\n// \tif (abs(daruma[i]-daruma[j-1]) <= 1 && rec(dp,daruma,i+1,j-1) == (j-1)-(i+1)){\n// \t\treturn dp[i][j] = j - i;\n// \t}\n// \tdp[i][j] = 0;\n// \trep2(mid, i + 1, j)\n// \t{\n// \t\tdp[i][j] = max(dp[i][j], rec(dp,daruma,i,mid) + rec(dp,daruma,mid,j));\n// \t}\n// \treturn dp[i][j];\n// }\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tvector<int> daruma(n);\n\t\trep(i, n) cin >> daruma[i];\n\t\tvector<vector<int>> dp(n+1, vector<int>(n+1, 0));\n\t\t// cout << rec(dp, daruma, 0, n) << endl;\n\t\tfor(int W = 2;W <= n;W++)\n\t\t{\n\t\t\tfor(int l = 0;l < n;l++)\n\t\t\t{\n\t\t\t\tint r = l + W;\n\t\t\t\tif(r > n) continue;\n\n\t\t\t\tif(dp[l + 1][r - 1] == W - 2 && abs(daruma[l] - daruma[r - 1]) <= 1)\n\t\t\t\t\tdp[l][r] = W;\n\n\t\t\t\tfor(int mid = l;mid <= r;mid++)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r] = max(dp[l][r] , dp[l][mid] + dp[mid][r]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<llint, P> E;\n\nllint n;\nllint w[305];\nbool dp[305][305];\nllint dp2[305];\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(int i = 1; i <= n; i++) cin >> w[i];\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tdp[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= n-1; i++){\n\t\t\tdp[i][i+1] = (abs(w[i]-w[i+1]) <= 1);\n\t\t}\n\t\tfor(int len = 4; len <= n; len += 2){\n\t\t\tfor(int l = 1; l+len-1 <= n; l++){\n\t\t\t\tllint r = l+len-1;\n\t\t\t\tfor(int k = l+1; k <= r; k++) dp[l][r] |= dp[l][k-1] && dp[k][r];\n\t\t\t\tif(abs(w[l]-w[r]) <= 1) dp[l][r] |= dp[l+1][r-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i <= n; i++) dp2[i] = -inf;\n\t\tdp2[0] = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp2[i+1] = max(dp2[i+1], dp2[i]);\n\t\t\tfor(int j = i+1; j <= n; j++){\n\t\t\t\tif(dp[i+1][j]) dp2[j] = max(dp2[j], dp2[i]+(j-i));\n\t\t\t}\n\t\t}\n\t\tcout << dp2[n] << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305], w[305];\n\nint rec(int l, int r){\n    if(r-l==1) return 0;\n    if(r-l==2){\n        if(abs(w[r-1]-w[l])<=1) return 2;\n        else return 0;\n    }\n\n    if(dp[l][r]>-1) return dp[l][r];\n    if(abs(w[r-1]-w[l])<=1 && rec(l+1, r-1)==r-l-2) return dp[l][r] = r - l;\n\n    int res = 0;\n    for(int i=l;i<r-1;i++){\n        res = max(res, rec(l, i+1)+rec(i+1, r));\n    }\n    return dp[l][r] = res;\n}\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(nullptr);\n    while(true){\n        int N;cin>>N;\n        if(!N)return 0;\n        for(int i=0;i<N;i++)cin>>w[i];\n        for(int i=0;i<=N;i++) for(int j=0;j<=N;j++) dp[i][j] = -1;\n        printf(\"%d\\n\", rec(0, N));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> iv; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define mp make_pair\n#define pb push_back\n\nint ans;\n\nvoid dfs(iv E, int depth)\n{\n  \n  bool flag = false;\n  repi(i,1,E.size())\n    {\n      if(depth + E.size() <= ans)continue;\n      if(abs(E[i]-E[i-1])>1)continue;\n      flag = true;\n      iv F;\n      rep(j,E.size())\n\t{\n\t  if(j == i || j == i - 1)continue;\n\t  F.pb(E[j]);\n\t  //printf(\"%d\" ,E[j]);\n\t}\n      // printf(\"\\n\");\n\t  \n      dfs(F, depth+2);\n    }\n  if(!flag)ans=max(ans,depth);\n}\nint main()\n{\n  while(true)\n    {\n      int n;\n      scanf(\"%d\", &n);\n      if(n==0)break;\n\n      iv W;\n      rep(i,n)\n\t{\n\t  int w;\n\t  scanf(\"%d\", &w);\n\t  W.pb(w);\n\t}\n      ans = 0;\n      dfs(W, 0);\n      printf(\"%d\\n\", ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvi in;\nvvi dp;\nint n;\nint f(int a,int b){\n\tif(a<0||a>=n||b<=0||b>n)return 0;\n\tif(dp[a][b]!=-inf)return dp[a][b];\n\tint out=0;\n\t{\n\t\tint t=f(a+1,b-2);\n\t\tif(t==b-2&&abs(in[a]-in[a+b-1])<=1)out=t+2;\n\t}\n\trep(i,b-1){\n\t\tint s=f(a,i+1);\n\t\tint t=f(a+i+1,b-i-1);\n\t\tout=max(out,s+t);\n\t}\n\tif(b==2&&abs(in[a]-in[a+1])<=1)out=2;\n\treturn dp[a][b]=out;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vi(n);\n\t\trep(i,n)cin>>in[i];\n\t\tdp=vvi(n,vi(n+1,-inf));\n\t\tcout<<f(0,n)<<endl;\n//\t\trep(i,n){rep(j,n+1)cout<<\" \"<<dp[i][j];cout<<endl;}\n//\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  while (1){\n    int n;\n    cin >> n;\n    if (n == 0){\n      break;\n    }\n    vector<int> w(n);\n    for (int i = 0; i < n; i++){\n      cin >> w[i];\n    }\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    for (int d = 1; d <= n; d++){\n      for (int i = 0; i <= n - d; i++){\n        int j = i + d;\n        if (d % 2 == 1){\n          for (int k = i; k <= j; k++){\n            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j]);\n          }\n        } else {\n          for (int k = i; k <= j; k++){\n            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j]);\n          }\n          if (abs(w[j - 1] - w[i]) <= 1 && dp[i + 1][j - 1] == j - i - 2){\n            dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + 2);\n          }\n        }\n      }\n    }\n    cout << dp[0][n] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint memo[302][302];\nint w[302];\n\nint rec(int i,int j){\n    if(i>=j) return 0;\n    if(i+1==j){\n        if(abs(w[i]-w[j]) <= 1) return 2;\n        else return 0;\n    }\n    if(memo[i][j]) return memo[i][j];\n    int res=0;\n\n    if(abs(w[i]-w[j])<=1 and rec(i+1,j-1)==j-1-i){\n        return memo[i][j]=j-i+1;\n    }\n\n    for(int k=i;k<j;k++){\n        int L=rec(i,k);\n        int R=rec(k+1,j);\n        res=max(res,L+R);\n    }\n    return memo[i][j]=res;\n}\n\nvoid solve(int N){\n    rep(i,302) rep(j,302) memo[i][j]=0;\n    rep(i,N) cin >> w[i];\n    cout << rec(0,N-1) << endl;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\nint xcomp(vector<LL>& a, vector<LL>& b) {\n\treturn a[0] < b[0];\n}\n\n#define XSORT(c) sort((c).begin(),(c).end(),xcomp)\n\n#define ALL(x) (x).begin(),(x).end()\nLL mod = 1000000007;\n\nbool hantei(LL a, LL b) {\n\tif (a + 1 == b) {\n\t\treturn true;\n\t}\n\telse\n\t\tif (a == b) {\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\tif (a == b + 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n}\n\nint main() {\n\twhile (true)\n\t{\n\t\tLL  n;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<LL> num(n, 0);\n\t\tvector<LL> v(n, -9999);\n\n\t\tREP(i, n) {\n\t\t\tcin >> v[i];\n\t\t}\n\t\tREP(i, n - 1) {\n\t\t\tif (hantei(v[i], v[i + 1])) {\n\t\t\t\tnum[i] = 2;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\n\t\twhile (flag) {\n\t\t\tflag = false;\n\n\t\t\tREP(i, n) {\n\t\t\t\tLL hoge = num[i];\n\t\t\t\tif (i + num[i]<n) {\n\t\t\t\t\tif (hoge < num[i] + num[i + num[i]]) {\n\t\t\t\t\t\thoge = num[i] + num[i + num[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i + 1<n) {\n\t\t\t\t\tif (i + num[i + 1] + 1<n) {\n\t\t\t\t\t\tif (hantei(v[i], v[i + num[i + 1] + 1])) {\n\t\t\t\t\t\t\tif (hoge < num[i + 1] + 2) {\n\t\t\t\t\t\t\t\thoge = num[i + 1] + 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}a\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hoge != num[i]) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tnum[i] = hoge;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tvector<LL> fuga(n * 3, 0);\n\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tfuga[i] = max(fuga[i + 1], num[i] + fuga[i + num[i]]);\n\t\t}\n\n\t\tcout << fuga[0] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nint N;\nbool ok[1001][1001];\nint dp[1001][1001];\nint ans[1001];\nint main(){\n    while(cin>>N,N){\n       vector<int>v(N);\n       REP(i,N)cin>>v[i];\n       REP(i,1001)REP(j,1001){ok[i][j]=false;dp[i][j]=0;}\n       //ok????????????\n       /*REP(i,N){\n           for(int j=i+1;j<N;j++){\n               if(j-i==1&&abs(v[i]-v[j])<=1){ok[i][j]=true;dp[i][j]=2;continue;}\n               if(j-i==2){ok[i][j]=false;dp[i][j]=0;continue;}\n               for(int k=i+1;k+1<j;k++){\n                   if(abs(v[i]-v[j])>1)continue;\n                   if(ok[i][k]==false)continue;\n                   if(ok[k+1][j]==false)continue;\n                   ok[i][j]=true;\n                   dp[i][j]=j-i+1;\n               }\n           }\n       }*/\n       for(int k=1;k<=N-1;k++){\n          REP(i,N){\n              if(i+k>=N)continue;\n              if(k==1&&abs(v[i]-v[i+1])<=1){ok[i][i+1]=true;dp[i][i+1]=2;continue;}\n              if(k==1)continue;\n              if(k==2){ok[i][i+2]=false;dp[i][i+2]=0;continue;}\n              if(abs(v[i]-v[i+k])<=1&&ok[i+1][i+k-1]==true){ok[i][i+k]=true;dp[i][i+k]=k+1;}\n              for(int j=1;j<=k;j++){\n                  if(ok[i][i+j]&&ok[i+j+1][i+k]){ok[i][i+k]=true;dp[i][i+k]=k+1;}\n                  /*if(abs(v[i]-v[i+j]>1))continue;\n                  if(ok[i][i+j-1]==false)continue;\n                  if(ok[i+j+1][i+k]==false)continue;\n                  ok[i][i+k]=true;\n                  dp[i][i+k]=k+1;*/\n              }\n          }\n       }\n       REP(i,1001){\n           ans[i]=0;\n       }\n       for(int i=1;i<N;i++){\n           ans[i]=max(ans[i],ans[i-1]);\n           ans[i]=max(ans[i],dp[0][i]);\n           for(int j=1;j<i;j++){\n               ans[i]=max(ans[i],ans[j]+dp[j+1][i]);\n           }\n       }\n       //REP(i,N){REP(j,N)cout<<dp[i][j]<<\" \";cout<<endl;}\n       //REP(i,N)cout<<ans[i]<<endl;\n       cout<<ans[N-1]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <utility>\n#include <tuple>\n#include <math.h>\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n\nclass Sover {\n};\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tvector<int> ws(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> ws[i];\n\t\t}\n\n\t\tvector<vector<bool>> can(n, vector<bool>(n, false));\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\tfor (int j = 0; j + i < n; j++) {\n\t\t\t\tif (i == 1) {\n\t\t\t\t\tcan[j][j + i] = abs(ws[j] - ws[j + i]) <= 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (can[j + 1][j + i - 1]\n\t\t\t\t\t\t&& abs(ws[j] - ws[j + i]) <= 1)can[j][j + i] = true;\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int k = j + 1; k < j + i; k++) {\n\t\t\t\t\t\t\tif (can[j][k] && can[k + 1][j + i]) {\n\t\t\t\t\t\t\t\tcan[j][j + i] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> dp(n, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i > 0)dp[i] = dp[i - 1];\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (!can[j][i])continue;\n\n\t\t\t\tint tmp = i - j + 1;\n\t\t\t\tif (j > 0)tmp += dp[j - 1];\n\t\t\t\tdp[i] = max(dp[i], tmp);\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[n-1] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define pmod 1000000007\n#define maxn 100005\n#define IN freopen(\"input.txt\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(int i=a ; i<=b ; i++)\n#define INF 1000000000\n#define ll long long int\n#define eps (1e-8)\n#define sq(x) ( (x)*(x) )\n\nusing namespace std;\n\ntypedef pair < int, int > pii;\ntypedef pair < ll, ll > pll;\nint n;\nint a[1000];\nll d[1000][1000];\nint main()\n{while (1){\n    FOR (i,1,300){\n        FOR (j,1,300){\n            d[i][j]=0;\n        }\n    }\n    cin>> n;\n    if (n==0) return 0;\n    FOR (i,1,n){\n        cin>> a[i];\n    }\n    for (int i=1; i<=n;i++){\n        if (sq(a[i]-a[i-1])<=1) d[i-1][i]=0;\n        else d[i-1][i]=2;\n        d[i][i]=1;\n        for (int j=i-2; j>=1;j--){ int u=2;d[j][i]=INF;\n            if (sq(a[i]-a[j])<=1) u=0;\n            if (d[j+1][i-1]==0){\n                d[j][i]=u;\n            }\n            FOR (k,j,i-1){\n                d[j][i]=min(d[j][i],d[j][k]+d[k+1][i]);\n            }\n\n        }\n\n    }\n    /*FOR(j,1,n){\n        FOR(i,1,n){\n            cout<<j<<\" \"<<i<<\" \"<<d[j][i]<<endl;\n        }\n    }*/\n    cout<<n-d[1][n]<<endl;\n}\n\n         return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nInt dp[301][301];\n\nint main() {\n    vector<Int> res;\n    Int n;\n    while (cin >> n and n) {\n        vector<Int> a(n);\n        for (Int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        for (Int i = 0; i <= 300; i++) {\n            for (Int j = 0; j <= 300; j++) {\n                dp[i][j] = 0;\n            }\n        }\n        for (Int i = 0; i < n - 1; i++) {\n            if (abs(a[i] - a[i + 1]) <= 1) {\n                dp[i][i + 1] = 2;\n            }\n        }\n        if (n == 1) {\n            dump(0);\n            return 0;\n        }\n        if (n == 2) {\n            if (abs(a[0] - a[1]) <= 1) {\n                dump(2);\n            }\n            else {\n                dump(0);\n            }\n            return 0;\n        }\n        if (n == 3) {\n            if (abs(a[0] - a[1]) <= 1 or abs(a[1] - a[2]) <= 1) {\n                dump(2);\n            }\n            else {\n                dump(0);\n            }\n            return 0;\n        }\n        for (Int i = 0; i + 3 < n; i++) {\n            for (Int j = 0; j + i + 3 < n; j++) {\n                if (dp[j + 1][j + i + 2] == i + 2) {\n                    dp[j][j + i + 3] = i + 2;\n                    if (abs(a[j] - a[j + i + 3]) <= 1) {\n                        dp[j][j + i + 3] = max(dp[j][j + i + 3], dp[j + 1][j + i + 2] + 2);\n                    }\n                }\n                for (Int k = j + 1; k < j + i + 3; k++) {\n                    dp[j][j + i + 3] = max(dp[j][j + i + 3], dp[j][k] + dp[k + 1][j + i + 3]);\n                }\n            }\n        }\n        res.push_back(dp[0][n - 1]);\n    }\n    for (Int i = 0; i < (Int)res.size(); i++) {\n        dump(res[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(n==0&& m==0) break;\n    int a[1000];\n    lp(i,n){\n      cin>>a[i];\n    }\n    sort(a,a+n);\n    reverse(a,a+n);\n    int ans=0;\n    lp(i,n){\n      if((i+1)%m==0) continue;\n      else ans+=a[i];\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define ALL(x)    (x).begin(),(x).end()\n#define UNIQ(c)   (c).erase(unique(ALL((c))), end((c)))\n#define mp        make_pair\n#define eb        emplace_back\ntypedef pair<LL, LL> P;\ntypedef pair<P, P> PP;\n\nint N;\nint W[333];\n\nbool dp[333][333];\nint dp2[333];\nvoid solve() {\n\tfor (int i = 0; i < N; i++)cin >> W[i];\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int i = 0; i < N; i++)dp[i][i] = true;\n\n\tfor (int len = 2; len <= N; len++) {\n\t\tfor (int i = 0; i + len <= N; i++) {\n\t\t\tint j = i + len;\n\t\t\tif (abs(W[i] - W[j - 1]) <= 1)dp[i][j] |= dp[i + 1][j - 1];\n\t\t\tfor (int k = i + 1; k < j; k++)dp[i][j] |= dp[i][k] & dp[k][j];\n\t\t}\n\t}\n\tmemset(dp2, 0, sizeof(dp2));\n\tfor (int i = 0; i < N; i++) {\n\t\tdp2[i + 1] = max(dp2[i + 1], dp2[i]);\n\t\tfor (int j = i + 1; j <= N; j++)if (dp[i][j])dp2[j] = max(dp2[j], dp2[i] + j - i);\n\t}\n\tcout << dp2[N] << endl;\n}\nint main() {\n\twhile (cin >> N, N)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vp;\n#define fore(i,a,b) for(ll i=(a);i<=(b);++i)\n#define rep(i,n) fore(i,0,(n)-1)\n#define rfore(i,a,b) for(ll i=(b);i>=(a);--i)\n#define rrep(i,n) rfore(i,0,(n)-1)\n#define all(x) (x).begin(),(x).end()\nconst ll INF=1001001001;\nconst ll LINF=1001001001001001001;\nconst ll D4[]={0,1,0,-1,0};\nconst ll D8[]={0,1,1,0,-1,-1,1,-1,0};\ntemplate<class T>\nbool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>\nbool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n\n#define N 305\nll n;\nll w[N];\nll dp[N][N];\nll f(ll l,ll r){\n    if(r-l<2)return 0;\n    if(dp[l][r]!=-1)return dp[l][r];\n    ll ret=0;\n    if(abs(w[l]-w[r-1])<=1&&f(l+1,r-1)==r-l-2)ret=r-l;\n    fore(i,l+1,r-1){\n        ll tmp=f(l,i)+f(i,r);\n        chmax(ret,tmp);\n    }\n    return dp[l][r]=ret;\n}\nvoid solve(){\n    while(1){\n        cin>>n;\n        if(n==0)return;\n        rep(i,n)cin>>w[i];\n\n        memset(dp,-1,sizeof(dp));\n        cout<<f(0,n)<<endl;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include <numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint dp[350][350];\n\nint main(){\n  int n;\n  while(true){\n    cin >> n;\n    if(n == 0)return 0;\n    vector<int> w(n);\n    for(int i = 0; i < n; ++i){\n      cin >> w[i];\n    }\n\n    fill((int*)dp, (int*)dp + sizeof(dp) / sizeof(int), 0);\n    for(int width = 2; width <= n; ++width){\n      for(int l = 0; l < n; ++l){\n        int r = l + width;\n        if(r > n)continue;\n        if(dp[l + 1][r - 1] == width - 2 && abs(w[l] - w[r - 1]) <= 1)dp[l][r] = width;\n        else{\n          for(int i = l; i <= r; ++i){\n            dp[l][r] = max(dp[l][r], dp[l][i] + dp[i][r]);\n          }\n        }\n      }\n    }\n\n    cout << dp[0][n] << endl;\n\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n, w[300], dp[300][300], dp2[300][300];\n\nint main() {\n\n\twhile (true) {\n\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif (abs(w[i] - w[i + 1]) <= 1) {\n\t\t\t\tdp[i][i + 1] = 2;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 3; i < n; i += 2) {//区間の大きさ\n\t\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\t\t//両端の計算\n\t\t\t\tif (abs(w[j] - w[j + i]) <= 1 && dp[j + 1][j + i - 1] > 0) {\n\t\t\t\t\tdp[j][j + i] = dp[j + 1][j + i - 1] + 2;\n\t\t\t\t}\n\t\t\t\tfor (int k = j + 1; k < j + i; k += 2) {\n\t\t\t\t\t//jからkを中間とした長i+1区間を取り出せるかどうか\n\n\t\t\t\t\tif (dp[j][k] > 0 && dp[k + 1][j + i] > 0) {\n\t\t\t\t\t\tdp[j][j + i] = max(dp[j][j + i], dp[j][k] + dp[k + 1][j + i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//区間での取り出せる個数の最大を計算\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\t\t//dpの方の取り出せる数を先に入れる\n\t\t\t\tdp2[j][j + i] = dp[j][j + i];\n\n\t\t\t\tfor (int k = j; k < j + i; k++) {\n\t\t\t\t\t//jからkを中間とした長i+1区間の取り出せる個数の最大\n\n\t\t\t\t\t//ここが間違っている\n\t\t\t\t\tdp2[j][j + i] = max(dp2[j][j + i], dp2[j][k] + dp2[k + 1][j + i]);\n\t\t\t\t\t//dp2[j][j + i] = max(dp2[j][j + i], dp2[j][k] + dp[k + 1][j + i]);\n\t\t\t\t\t//dp2[j][j + i] = max(dp2[j][j + i], dp[j][k] + dp2[k + 1][j + i]);\n\t\t\t\t\t//dp2[j][j + i] = max(dp2[j][j + i], dp[j][k] + dp[k + 1][j + i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp2[0][n - 1] << endl;\n\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = dp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> iv; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define mp make_pair\n#define pb push_back\n\nint ans;\nvoid dfs(iv E, int depth)\n{\n  bool flag = false;\n  repi(i,1,E.size())\n    {\n      if(abs(E[i]-E[i-1])>1)continue;\n      flag = true;\n      iv F;\n      rep(j,E.size())\n\t{\n\t  if(j == i || j == i - 1)continue;\n\t  F.pb(E[j]);\n\t  //printf(\"%d\" ,E[j]);\n\t}\n      // printf(\"\\n\");\n\t  \n      dfs(F, depth+2);\n    }\n  if(!flag)ans=max(ans,depth);\n}\nint main()\n{\n  while(true)\n    {\n      int n;\n      scanf(\"%d\", &n);\n      if(n==0)break;\n\n      iv W;\n      rep(i,n)\n\t{\n\t  int w;\n\t  scanf(\"%d\", &w);\n\t  W.pb(w);\n\t}\n      ans = 0;\n      dfs(W, 0);\n      printf(\"%d\\n\", ans);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nconst int MAX = 710;\nconst int MOD = 1000000007;\n\nll dp[MAX][MAX];\n// dp[i][j] is from i to j no max can remove\n\nint main(){\n  vector<ll> ans;\n  while(1){\n    ll N; cin >> N; if(N == 0) break;\n    vector<ll> a(N); rep(i,N) cin >> a[i];\n    // dp syokika\n    rep(i,MAX) rep(j,MAX) dp[i][j] = 0;\n\n    repn(i,N){\n      // i は何個先か\n      rep(j,N){\n        // j is start\n        if(dp[j + 1][j + i - 1] == (i - 1) and abs(a[j] - a[j + i]) < 2){\n          // 両端に追加できる\n          dp[j][j + i] = max(dp[j][j + i] , dp[j + 1][j + i - 1] + 2);\n        }\n        for(ll k = j; k <= i + j; k++){\n          // kを飛ばす\n          dp[j][j + i] = max(dp[j][j + i] , dp[j][k] + dp[k + 1][j + i]);\n        }\n      }\n    }\n    ans.pb(dp[0][N - 1]);\n  }\n\n  rep(i,ans.size()) cout << ans[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n\nint dfs(int v, vector<set<int>> &g, vector<int> &dp){\n    if(v == 0) return 0;\n    if(dp[v]) return dp[v];\n    int res = dfs(v-1,g,dp);\n    for(int to : g[v]){\n        res = max(res,v-to + dfs(to,g,dp));\n    }\n    return dp[v] = res;\n}\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> w(n+1);\n        rep1(i,n) cin>>w[i];\n        w[0] = -1;\n\n        // g[i][j] := i番目が消える時に右側に会わせられる\n        //             ブロックのindex\n        vector<set<int>> g(n+1);\n        rep1(i,n){\n            if(abs(w[i]-w[i-1]) <= 1){\n                g[i] = g[i-2];\n                g[i].insert(i-2);\n            }\n            for(int l : g[i-1]){\n                if(abs(w[i]-w[l]) <= 1){\n                    for(int ll : g[l-1]){\n                        g[i].insert(ll);\n                    }\n                    g[i].insert(l-1);\n                }\n            }\n        }\n        vector<int> dp(n+1);\n        cout<<dfs(n,g,dp)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 2000000000\n#define int long long int\n#define MOD 1000000007\n#define pb push_back\n#define cin1(n) (cin >> n)\n#define cin2(a,b) (cin >> a >> b)\n#define cin3(a,b,c) (cin >> a >> b >> c)\n#define cout(n) (cout << n << endl)\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define fr first \n#define sc second \n#define EPS (1e-10)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector< vector<int> > vvi;\ntypedef vector<pair<int,int>> vpii;\ntypedef vector<string> vs;\ntypedef vector<vector<string>> vss;\ntypedef pair<int,int> pii;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint a,b;\nint p,q;\n\n\nsigned main() {\n\t\n\twhile(1) {\n\t\tcin1(n);\n\t\tif (n == 0) break;\n\n\t\tvvi dp(n,vi(n,0)); //dp[i][j] i??????j??????????????§?????°\n\t\tvi daruma(n,0);\n\t\trep(i,0,n) {\n\t\t\tcin1(daruma[i]);\n\t\t}\n\n\t\trep(i,1,n) {\n\t\t\tif (abs(daruma[i-1] - daruma[i]) <= 1) {\n\t\t\t\tdp[i-1][i] = 2;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 2; i <= n; i++) { //??????\n\t\t\tfor (int l = 0; l < n - i + 1; l++) { //??????\n\t\t\t\tint r = l + i - 1;\n\t\t\t\tif (dp[l+1][r-1] == i - 2 and abs(daruma[l]-daruma[r]) <= 1) dp[l][r] = i; \n\t\t\t\tfor (int k = l; k < r; k++) {\n\t\t\t\t\tdp[l][r] = max(dp[l][r],dp[l][k] + dp[k+1][r]);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tcout(dp[0][n-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stdio.h>\n#include<cstring>\n#include<math.h>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<stack>\n#include<tuple>\n#include<cassert>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\nusing P = pair<int, int>;\n\nint main() {\n  while(true) {\n    int n;\n    int w[300];\n    int dp[301][301] = {0};\n    cin >> n;\n    if(n == 0) break;\n    rep(i, n) {\n      cin >> w[i];\n    }\n    rep(i, n-1) {\n      if(abs(w[i]-w[i+1]) <= 1) dp[i][i+1] = 2;\n      else dp[i][i+1] = 0;\n    }\n\n    for(int l = 3; l <= n; l++) {\n      for(int i = 0; i + l - 1 < n; i++) {\n        int j = i + l - 1;\n        if(dp[i+1][j-1] == j - i - 1) {\n          if(abs(w[i]-w[j]) <= 1) dp[i][j] = j - i + 1;\n          else dp[i][j] = j - i - 1;\n        }\n        for(int k = i; k <= j-1; k++) {\n          dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n        }\n      }\n    }\n\n    cout << dp[0][n-1] << endl;\n\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define repr(i, n) for (int i = (n); i >= 0; i--)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for (int i = x; i < n; i++)\n#define OP(m) cout << m << endl\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint dp[301][301];\nint w[300];\n\nint daruma(int l, int r)\n{\n    if (dp[l][r] != -1)\n        return dp[l][r];\n    if (abs(l - r) <= 1)\n        return 0;\n\n    int res = 0;\n    if (abs(w[l] - w[r - 1]) <= 1 && daruma(l + 1, r - 1) == r - l - 2)\n        res = r - l;\n    for (int i = l + 1; i <= r - 1; i++)\n        res = max(res, daruma(l, i) + daruma(i, r));\n\n    return dp[l][r] = res;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n,n)\n    {\n        rep(l, 301) rep(r, 301) dp[l][r] = -1;\n        rep(i, n) cin >> w[i];\n        OP(daruma(0, n));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, w[1004];\n\twhile(cin >> n, n){\n\n\t\trep(i,n) cin >> w[i];\n\n\t\tbool dp1[305][305]={};\n\t\tvector<pii> v;\n\t\trep(i,n-1) if( abs(w[i] - w[i+1]) < 2 ){\n\t\t\tdp1[i][i+1] = true;\n\t\t\tv.emplace_back(i, i+1);\n\t\t}\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\tif( i+k >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && 0 < i && i+k+1 < n ){\n\t\t\t\t\tif( abs(w[i-1] - w[i+k+1]) < 2 ){\n\t\t\t\t\t\tdp1[i-1][i+k+1] = true;\n\t\t\t\t\t\tv.emplace_back(i-1, i+k+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n) rep(i,n){\n\t\t\t\tif( i+k+j >= n ) break;\n\t\t\t\tif( dp1[i][i+k] && dp1[i+k+1][i+k+j] ){\n\t\t\t\t\tdp1[i][i+k+j] = true;\n\t\t\t\t\tv.emplace_back(i, i+k+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for(auto t: v) cout << t.X << \",\" << t.Y << \" \"; cout << endl;\n\t\tsort( v.begin(), v.end() );\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\n\t\tint dp[900005] = {}, pos=0;\n\t\trep(i,900002){\n\t\t\twhile( pos < v.size() && v[pos].first == i ){\n\t\t\t\tint d  = v[pos].X;\n\t\t\t\tint nx = v[pos].Y + 1;\n\t\t\t\tdp[nx] = max( dp[nx], dp[i] + nx - d );\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tdp[i+1] = max( dp[i+1], dp[i] );\n\t\t}\n\t\tcout << dp[900002] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n//#define MAX 300\nint n;\nint* w;\nvector<pair<int*,int> > wmap;\n\nint* pop(int* w,int a) { //w???a????????¨a+1?????????????????????\n\tint *t;\n\tt = new int[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tif(i < a) t[i] = w[i];\n\t\telse t[i] = w[i + 2];\n\t}\n\tt[n - 2] = -1;\n\tt[n - 1] = -1;\n\treturn t;\n}\n\n\nint daruma(int* w) {\n\tfor (int i = 0; i < wmap.size(); i++) {\n\t\tif (memcmp(w, wmap[i].first, sizeof(w)) == 0) {\n\t\t\treturn wmap[i].second;\n\t\t}\n\t}\n\n\tint max = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (w[i] != -1 && w[i + 1] != -1 && abs(w[i]-w[i+1])<=1) {\n\t\t\tint tmp = daruma(pop(w, i))+2;\n\t\t\tif (tmp > max) max = tmp;\n\t\t}\n\t}\n\n\twmap.push_back(make_pair(w,max));\n\treturn max;\n}\n\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\tw = new int[n]();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << daruma(w) << endl;\n\n\n\t\tcin >> n;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,s,e) for(int i = s; i < e; i++)\nusing namespace std;\n\n\nint main()\n{\n    int n;\n    while(scanf(\"%d\", &n) && n != 0)\n    {\n        int daruma[n];\n\n        rep(i,0,n)\n            cin >> daruma[i];\n\n        bool interval[n][n];\n        memset(interval, 0, sizeof(interval));\n\n        rep(i,0,n-1)\n            if(abs(daruma[i]-daruma[i+1]) <= 1)\n                interval[i][i+1] = true; \n            \n        rep(i,0,n)\n            rep(j,0,n-i)\n                if((interval[j+1][j+i-1] && abs(daruma[j]-daruma[j+i]) <= 1))  \n                    interval[j][j+i] = true;\n                else\n                    rep(k,j,j+i)\n                        if(interval[j][k] && interval[k+1][j+i])\n                            interval[j][j+i] = true;\n\n        int dp[n][n];\n        memset(dp,0,sizeof(dp));\n\n        rep(i,0,n-1)\n            rep(j,i+1,n)\n                if(interval[i][j])\n                    dp[i][j] = j-i+1;\n\n        rep(j,0,n)\n            rep(k,0,j)\n               dp[0][j] = max(dp[0][j], dp[0][k] + dp[k+1][j]);\n\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    \n    for(int n; cin >> n, n;){\n        vector<int>w(n);\n        vector<vector<int> >dp(n, vector<int>(n, 0));\n        for(int i = 0; i < n; i++)cin >> w[i];\n        for(int l = 0; l + 1 < n; l++){\n            if(abs(w[l] - w[l + 1]) <= 1){\n                dp[l][l + 1] = 2;\n            }\n        }\n        for(int i = 2; i <= n; i++){\n            for(int l = 0; l + i < n; l++){\n                int r = l + i;\n                if(abs(w[l] - w[r]) <= 1 && dp[l + 1][r - 1] == r - l - 1){\n                    dp[l][r] = r - l + 1;\n                }\n                for(int p = l; p < r; p++){\n                    dp[l][r] = max(dp[l][r], dp[l][p] + dp[p + 1][r]);\n                }\n            }\n        }\n        cout << dp[0][n - 1] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define FOR(i, a, b) for(int i=a;i<b;i++)\n#define REP(i, n) FOR(i, 0, n)\n#define max(a, b) ((a)>(b)?(a):(b))\n#define min(a, b) ((a)>(b)?(b):(a))\n#define abs(a) max((a), -(a))\n\nint n;\nint w[304];\n\nint dp[303][303];\n\nint main() {\n\n    while(cin>>n,n) {\n        REP(i, n)cin>>w[i];\n\n        REP(i, n) {\n            dp[i][i] = 1;\n            if(i<n-1) {\n                dp[i][i+1] = abs(w[i]-w[i+1])<=1?0:2;\n            }\n        }\n\n        FOR(i, 2, n) { // 幅\n            FOR(j, 0, n-i) {\n                dp[j][j+i] = i+1;\n\n                if(dp[j+1][j+i-1]==0 && abs(w[j]-w[j+i])<=1) {\n                    dp[j][j+i] = 0;\n                    continue;\n                }\n\n                REP(k, i) {\n                    int a = dp[j][j+k]+dp[j+k+1][j+i];\n                    dp[j][j+i] = min(a, dp[j][j+i]);\n                    if(a==0)break;\n                }\n\n            }\n        }\n\n        cout<<(n-dp[0][n-1])<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i < (n);i++)\n#define ALL(obj) (obj).begin(),(obj).end()\nusing namespace std;\n\nconst long long INF = 1LL << 60;\nconst int MOD = (int)1e9 + 7;\ntypedef long long ll;\n//約数列挙\nvector<long long> divisor(long long n) {\n    vector<long long> ret;\n    for (long long i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            ret.push_back(i);\n            if (i * i != n) ret.push_back(n / i);\n        }\n    }\n    //sort(ret.begin(), ret.end()); // 昇順に並べる\n    return ret;\n}\nvector<int> dx={1,0,-1,0};vector<int> dy={0,-1,0,1};\nint n;\nvector<int> weight;\nvector<vector<int>> dp;\nint rec(int l,int r){\n    if(dp[l][r]!=-1)return dp[l][r];\n    if(abs(l-r)<=1)return 0;\n    int res = 0;\n    if(abs(weight[l] - weight[r-1])<=1 && rec(l+1,r-1) == r - l - 2){\n        res = r-l;\n    }\n    for(int mid=l+1;mid<=r-1;mid++){\n        res = max(res, rec(l,mid) + rec(mid,r));\n    }\n    return dp[l][r] = res;\n}\nsigned main () {\n    scanf(\"%d\",&n);\n    while(n!=0){\n        weight.assign(n,-1);\n        REP(i,n){\n            int tmp;scanf(\"%d\",&tmp);\n            weight[i]= tmp;\n        }\n        dp.assign(n+1,vector<int>(n+1,-1));\n        rec(0,n);\n        printf(\"%d\\n\",dp[0][n]);\n        scanf(\"%d\",&n);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint W[305];\nint dp[305][305];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0){break;}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&W[i]);\n\t\t}\n\t\tfor(int i=0;i<305;i++){\n\t\t\tfor(int j=0;j<305;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=N-2;i++){\n\t\t\tif(abs(W[i]-W[i+1])<=1){dp[i][2]=2;}\n\t\t}\n\t\tfor(int j=3;j<=N-1;j++){\n\t\t\tfor(int i=0;i+j<=N;i++){\n\t\t\t\t//[i,i+j)\n\t\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\t\tdp[i][j]=max(dp[i][k]+dp[i+k][j-k],dp[i][j]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+j-1])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-2]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int j=0;j<12;j++){\n\t\t\tfor(int i=0;i+j<=12;i++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t/*\n\t\tfor(int i=150;i>=0;i-=2){\n\t\tprintf(\"%d\\n\",dp[i][299-i]);\n\t\t}*/\n\t\tprintf(\"%d\\n\",dp[0][N]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n#define DUMP(x) cout << #x << \": \" << x << endl\n\nint n;\nint memo[310][310] = { 0 };\nvector<int> w(n);\n\nint rec(int l, int r) {\n  if (r - 1 == l) {\n    return 0;\n  }\n  \n  if (r - l  - 1 == 1) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      return 2;\n    }\n  }\n  if (memo[l][r]) {\n    return memo[l][r];\n  }\n  \n  int ret = 0;\n  bool isOK = false;\n  \n  if (abs(w[l] - w[r - 1]) <= 1) {\n    isOK = true;\n  }\n\n\n  for (int t = l + 1; t < r; t++) {\n    int temp = rec(l, t) + rec(t, r);\n    if (isOK && temp == (r - l - 2)) {\n      temp += 2;\n    }\n    ret = max(ret, temp);\n  }\n\n  return memo[l][r] = ret;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    w.clear();\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n    memset(memo, 0, sizeof(memo));\n    cout << rec(0, n) << endl;\n\n  }\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<int> w(n);\n    REP(i,n)cin>>w[i];\n    vector<vector<int>> dp(n, vector<int>(n+1, 0));\n    REP(i,n-1) {\n      if (abs(w[i]-w[i+1]) <= 1) dp[i][2] = 2;\n    }\n    FOR(l,3,n+1) REP(i,n) {\n      if (i+l > n) break;\n      FOR(k,1,l) {\n        dp[i][l] = max(dp[i][l], dp[i][k] + dp[i+k][l-k]);\n      }\n      if (dp[i+1][l-2] == l-2 && abs(w[i] - w[i+l-1]) <= 1) {\n        dp[i][l] = l;\n      }\n    }\n    cout << dp[0][n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=305,INF=1<<25;\nint A[MAX],dp[MAX][MAX];\n\nint solve(int l,int r){\n    if(dp[l][r]!=-1) return dp[l][r];\n    if(r-l<=1) return dp[l][r]=0;\n    if(r-l==2){\n        if(abs(A[l]-A[l+1])<=1) return dp[l][r]=2;\n        else return dp[l][r]=0;\n    }\n    \n    int ma=0;\n    \n    for(int i=l+1;i<=r-1;i++){\n        ma=max(ma,solve(l,i)+solve(i,r));\n    }\n    \n    if(solve(l+1,r-1)==r-l-2) ma=max(ma,solve(l+1,r-1)+2*(abs(A[l]-A[r-1])<=1));\n    \n    return dp[l][r]=ma;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        for(int i=0;i<N;i++) cin>>A[i];\n        memset(dp,-1,sizeof(dp));\n        \n        cout<<solve(0,N)<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//#include <intrin.h>  //AtCoder (gcc) 上ではこれがあると動かない。__popcnt用のincludeファイル。\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define int long long\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define sqrt(d) pow((long double) (d), 0.50)\n#define PII pair<int, int>\n#define MP make_pair\n\nconst int INF = 2000000000; //2e9\nconst long long INF2 = 1000000000000000000; //1e18\nconst long double pi = acos(-1);\n\nconst int MOD = 1000000007; //1e9 + 7\n//const int MOD = 1000000009; //1e9 + 9\n//const int MOD = 998244353;\n\n\n\n\n//繰り返し2乗法\n//N^aの、Mで割った余りを求める。\nll my_pow(ll N, ll a, ll M) {\n\tll tempo;\n\tif (a == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tif (a % 2 == 0) {\n\t\t\ttempo = my_pow(N, a / 2, M);\n\t\t\treturn (tempo * tempo) % M;\n\t\t}\n\t\telse {\n\t\t\ttempo = my_pow(N, a - 1, M);\n\t\t\treturn (tempo * N) % M;\n\t\t}\n\t}\n}\n\n\n\n\n//N_C_a を M で割った余り\nll my_combination(ll N, ll a, ll M) {\n\tif (N < a) return 0;\n\n\tll answer = 1;\n\n\trep(i, a) {\n\t\tanswer *= (N - i);\n\t\tanswer %= M;\n\t}\n\n\trep(i, a) {\n\t\tanswer *= my_pow(i + 1, M - 2, M);\n\t\tanswer %= M;\n\t}\n\n\treturn answer;\n}\n\n\n//N_C_i を M で割った余りを、v.at(i) に代入する。\nvoid my_combination_table(ll N, ll M, vector<ll>& v) {\n\tv.assign(N + 1, 1);\n\n\tfor (ll i = 1; i <= N; i++) {\n\t\tv.at(i) = v.at(i - 1) * (N - (i - 1LL));\n\t\tv.at(i) %= M;\n\n\t\tv.at(i) *= my_pow(i, M - 2, M);\n\t\tv.at(i) %= M;\n\t}\n}\n\n\n//(N + i)_C_N を M で割った余りを、v.at(i) に代入する。(v のサイズに依存)\nvoid my_combination_table2(ll N, ll M, vector<ll>& v) {\n\tv.at(0) = 1;\n\n\tfor (ll i = 1; i < (ll)v.size(); i++) {\n\t\tv.at(i) = v.at(i - 1) * (N + i);\n\t\tv.at(i) %= M;\n\n\t\tv.at(i) *= my_pow(i, M - 2, M);\n\t\tv.at(i) %= M;\n\t}\n}\n\n\n\n\n//階乗。x ! まで計算する。結果は dp に保存する。20 ! = 2.43e18 まで long long に入る。\nll factorial(ll x, vector<ll>& dp) {\n\tif ((ll)dp.size() <= x) {\n\t\tint n = dp.size();\n\t\trep(i, x + 1 - n) {\n\t\t\tdp.push_back(0);\n\t\t}\n\t}\n\n\tif (x == 0) return dp.at(x) = 1;\n\tif (dp.at(x) != -1 && dp.at(x) != 0) return dp.at(x);\n\treturn dp.at(x) = x * factorial(x - 1, dp);\n}\n\n\n\n\n//階乗の M で割った余り。x ! まで計算する。結果は dp に保存する。\nll factorial2(ll x, ll M, vector<ll>& dp) {\n\tif ((ll)dp.size() <= x) {\n\t\tint n = dp.size();\n\t\trep(i, x + 1 - n) {\n\t\t\tdp.push_back(0);\n\t\t}\n\t}\n\n\tif (x == 0) return dp.at(x) = 1;\n\tif (dp.at(x) != -1 && dp.at(x) != 0) return dp.at(x);\n\treturn dp.at(x) = (x * factorial2(x - 1, M, dp)) % M;\n}\n\n\n\n\n//階乗の mod M での逆元 (M: prime)。x ! まで計算する。結果は dp に保存する。\nll factorial_inverse(ll x, ll M, vector<ll>& dp) {\n\tif ((ll)dp.size() <= x) {\n\t\tint n = dp.size();\n\t\trep(i, x + 1 - n) {\n\t\t\tdp.push_back(0);\n\t\t}\n\t}\n\n\tif (x == 0) return dp.at(x) = 1;\n\tif (dp.at(x) != -1 && dp.at(x) != 0) return dp.at(x);\n\treturn dp.at(x) = (my_pow(x, M - 2, M) * factorial_inverse(x - 1, M, dp)) % M;\n}\n\n\n\n\n//N_C_a を M で割った余り。何度も呼ぶ用。\nll my_combination2(ll N, ll a, ll M, vector<ll>& dp_factorial, vector<ll>& dp_factorial_inverse) {\n\tif ((ll)dp_factorial.size() <= N) {\n\t\tfactorial2(N, M, dp_factorial);\n\t}\n\tif ((ll)dp_factorial_inverse.size() <= N) {\n\t\tfactorial_inverse(N, M, dp_factorial_inverse);\n\t}\n\n\tif (N < a) return 0;\n\n\tll answer = 1;\n\tanswer *= dp_factorial.at(N);\n\tanswer %= M;\n\tanswer *= dp_factorial_inverse.at(N - a);\n\tanswer %= M;\n\tanswer *= dp_factorial_inverse.at(a);\n\tanswer %= M;\n\n\treturn answer;\n}\n\n\n\n\nlong long my_gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn my_gcd(b, a % b);\n}\n\n\n\n\n// ax + by = gcd(a, b) を解く。返り値は、gcd(a, b)。\nlong long my_gcd_extended(long long a, long long b, long long& x, long long& y) {\n\tif (b == 0) {\n\t\tx = 1; y = 0;\n\t\treturn a;\n\t}\n\n\tlong long tempo = my_gcd_extended(b, a % b, y, x);\n\n\t//bx' + ry' = gcd(a, b) → (qb + r)x + by = gcd(a, b) に戻さないといけない。// (r = a % b)\n\t//b(x' - qy') + (bq + r)y' = gcd(a, b) と同値変形できるから、\n\t// x = y', y = x' - qy'\n\ty -= (a / b) * x;\n\n\treturn tempo;\n}\n\n\n\n\n// base を底としたときの、n の i桁目を、v.at(i) に入れる。(桁数は n に応じて自動で設定する。)\nvoid ll_to_vector(signed base, long long n, vector<signed>& v) {\n\tlong long tempo = n;\n\tlong long tempo2 = n;\n\n\tsigned n_digit = 1;\n\twhile (tempo2 >= base) {\n\t\ttempo2 /= base;\n\t\tn_digit++;\n\t}\n\n\tv.assign(n_digit, 0);   // v のサイズを適切に調整する場合。\n\n\t// n_digit = v.size();  // v のサイズをそのままにする場合。\n\n\tfor (signed i = 0; i < n_digit; i++) {\n\t\tlong long denominator = 1;\n\t\tfor (signed j = 0; j < n_digit - 1 - i; j++) {\n\t\t\tdenominator *= base;\n\t\t}\n\n\t\tv.at(i) = tempo / denominator;\n\t\ttempo -= v.at(i) * denominator;\n\t}\n}\n\n\n\n\nint char_to_int(char c) {\n\tswitch (c) {\n\tcase '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4;\n\tcase '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9;\n\tdefault: return 0;\n\t}\n}\n\n\n\n\n//エラトステネスの篩で、prime で ないところに false を入れる。O(n loglog n)\nvoid prime_judge(vector<bool>& prime_or_not) {\n\tprime_or_not.assign(prime_or_not.size(), true);\n\n\tprime_or_not.at(0) = false;\n\tprime_or_not.at(1) = false;\n\n\tlong long n = prime_or_not.size() - 1;\n\n\tfor (long long i = 2; 2 * i <= n; i++) {\n\t\tprime_or_not.at(2 * i) = false;\n\t}\n\n\n\tfor (long long i = 3; i * i <= n; i += 2) {\n\t\t//ここからは奇数のみ探索。i の倍数に false を入れる。\n\t\tif (prime_or_not.at(i)) {\n\t\t\tlong long j = i * i;  // i^2 未満の i の倍数には、すでに false が入っているはず。\n\t\t\twhile (j < n + 1) {\n\t\t\t\tprime_or_not.at(j) = false;\n\t\t\t\tj += 2 * i;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n\n// n + 1 の サイズの vector を返す。res.at(i) には、i の 1 以外で最小の約数を入れる。res.at(i) == i なら i は素数。\n// 2e8 なら、3.2 秒程度で終わる。たぶん、prime_judge より 3倍弱遅い。\nvector<long long> sieve(long long n) {\n\tn++; // n まで判定する。配列サイズは +1。\n\n\tvector<long long> res(n, 0);\n\tfor (long long i = 1; i < n; i++) {\n\t\tif (i % 2 == 0) res.at(i) = 2;  // 偶数をあらかじめ処理。\n\t\telse res.at(i) = i;\n\t}\n\n\tfor (long long i = 3; i * i < n; i += 2) {\n\t\t//ここからは奇数のみ探索。i の倍数に i を入れる。\n\t\tif (res.at(i) == i) {\n\t\t\tlong long j = i * i;  // i^2 未満の i の倍数には、すでに最小の約数が入っているはず。\n\t\t\twhile (j < n) {\n\t\t\t\tif (res.at(j) == j) res.at(j) = i;\n\t\t\t\tj += 2 * i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n};\n\n\n\n\n//O (sqrt(n)) で素数判定する用。\nbool is_prime(long long N) {\n\tif (N == 1 || N == 0) return false;\n\tif (N == 2 || N == 3) return true;\n\n\tif (N % 2 == 0) return false;\n\tif (N % 3 == 0) return false;\n\n\tfor (long long i = 1; (6 * i + 1) * (6 * i + 1) <= N; ++i) {\n\t\tif (N % (6 * i + 1) == 0) return false;\n\t}\n\tfor (long long i = 0; (6 * i + 5) * (6 * i + 5) <= N; ++i) {\n\t\tif (N % (6 * i + 5) == 0) return false;\n\t}\n\treturn true;\n}\n\n\n\n\n//素因数分解を O(sqrt(N)) で行うための関数。\nmap<ll, ll> divide_to_prime(int target) {\n\tmap<ll, ll> res;\n\n\t//sqrt(target) まで調べる。\n\tll upper_lim = ceil(sqrt(target));\n\tvector<bool> prime_or_not(upper_lim + 3, true);\n\tif (upper_lim < 20) prime_or_not.assign(25, true);\n\n\tprime_or_not.at(0) = false; prime_or_not.at(1) = false;\n\tprime_judge(prime_or_not);\n\n\tll tempo = target;\n\tfor (int i = 1; i * i <= target; i++) {\n\t\tif (prime_or_not.at(i)) {\n\t\t\twhile (tempo % i == 0) {\n\t\t\t\ttempo /= i;\n\t\t\t\tres[i]++;\n\t\t\t}\n\t\t}\n\n\t\tif (tempo == 1) break;  //別に必要はない。\n\t}\n\n\tif (tempo != 1) res[tempo]++; //sqrt(target) より大きな素因数は高々1つしかない。\n\treturn res;\n}\n\n\n\n\n//関数 sieve で得た、vector min_factor を持ってるときに、素因数分解を高速で行うための関数。\nmap<long long, long long> divide_to_prime2(long long target, vector<long long>& min_factor) {\n\tmap<long long, long long> res;\n\tif (min_factor.empty() || (long long)min_factor.size() - 1 < target) min_factor = sieve(target);\n\n\twhile (target > 1) {\n\t\tres[min_factor[target]]++;\n\t\ttarget /= min_factor[target];\n\t}\n\n\treturn res;\n}\n\n\n\n\n//約数全列挙を O(sqrt(N)) で行うための関数。\nvector<long long> count_dividers(long long target) {\n\n\tvector <long long> dividers, tempo;\n\tlong long i = 1;\n\twhile (i * i < target + 1) {\n\t\tif (target % i == 0) {\n\t\t\tdividers.push_back(i);\n\t\t\tif (i < target / i) tempo.push_back(target / i);  // if節がないと、平方数の時、sqrt(target) がダブルカウントされる。\n\t\t}\n\t\ti++;\n\t}\n\n\tfor (long long j = 0; j < (long long)tempo.size(); j++) {\n\t\tdividers.push_back(tempo.at(tempo.size() - 1 - j));\n\t}\n\n\treturn dividers;\n}\n\n\n\n\n//関数 sieve で得た、vector min_factor を持ってるときに、約数全列挙を高速で行うための関数。\nvector<long long> count_dividers2(long long target, vector<long long>& min_factor) {\n\n\tvector <long long> dividers = { 1 };\n\tmap<long long, long long> memo = divide_to_prime2(target, min_factor);\n\n\tfor (auto&& iter = memo.begin(); iter != memo.end(); iter++) {\n\t\tvector <long long> tempo = dividers;\n\t\tfor (long long k = 0; k < (long long)tempo.size(); k++) {\n\t\t\tlong long times = 1;\n\t\t\tfor (long long j = 1; j <= (iter->second); j++) {\n\t\t\t\ttimes *= iter->first;\n\t\t\t\tdividers.push_back(tempo[k] * times);\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(dividers.begin(), dividers.end());  //sortしないと小さい順に並ばないが、必要ないなら消しても良い。\n\treturn dividers;\n}\n\n\n\n\nvoid BFS_labyrinth(queue<pair<int, int>>& que, vector<vector<int>>& dist, int& area) {\n\tint n = dist.size();\n\tint m = dist.at(0).size();\n\n\twhile (!que.empty()) {\n\t\tint h, w;\n\t\tpair<int, int> tempo = que.front(); que.pop();\n\n\t\th = tempo.first;\n\t\tw = tempo.second;\n\t\t//cout << temp_i << \" \" << temp_j << endl;\n\n\t\tfor (int dh = -1; dh <= 1; dh++) {\n\t\t\tfor (int dw = -1; dw <= 1; dw++) {\n\t\t\t\tif (h + dh < 0 || n <= h + dh) continue;  //範囲外\n\t\t\t\tif (w + dw < 0 || m <= w + dw) continue;  //範囲外\n\t\t\t\tif (dh == 0 && dw == 0) continue; //動いていない\n\t\t\t\tif (dh * dw != 0) continue; //右上など。八近傍の場合は消す。\n\t\t\t\tif (dist.at(h + dh).at(w + dw) != -1) continue; //行けない領域に、既に INF などが代入されている場合はこの条件だけで ok\n\n\t\t\t\tdist.at(h + dh).at(w + dw) = dist.at(h).at(w) + 1;\n\t\t\t\tque.push(make_pair(h + dh, w + dw));\n\t\t\t}\n\t\t}\n\n\t\t//何か所も領域がある場合だけ必要\n\t\tif (que.empty()) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, m) {\n\t\t\t\t\tif (dist.at(i).at(j) == -1) {\n\t\t\t\t\t\tque.push(make_pair(i, j));\n\t\t\t\t\t\tdist.at(i).at(j) = 0;\n\t\t\t\t\t\tarea++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!que.empty()) break;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nvoid BFS01_labyrinth(deque<pair<int, int>>& que, vector<vector<int>>& dist, vector<vector<int>>& cost) {\n\tint n = dist.size();\n\tint m = dist.at(0).size();\n\n\twhile (!que.empty()) {\n\t\tint h, w;\n\t\tpair<int, int> tempo = que.front(); que.pop_front();\n\n\t\th = tempo.first;\n\t\tw = tempo.second;\n\t\t//cout << temp_i << \" \" << temp_j << endl;\n\n\t\tfor (int dh = -1; dh <= 1; dh++) {\n\t\t\tfor (int dw = -1; dw <= 1; dw++) {\n\t\t\t\tif (h + dh < 0 || n <= h + dh) continue;  //範囲外\n\t\t\t\tif (w + dw < 0 || m <= w + dw) continue;  //範囲外\n\t\t\t\tif (dh == 0 && dw == 0) continue; //動いていない\n\t\t\t\tif (dh * dw != 0) continue; //右上など。八近傍の場合は消す。\n\t\t\t\tif (dist.at(h + dh).at(w + dw) != -1) continue; //行けない領域に、既に INF などが代入されている場合はこの条件だけで ok\n\n\t\t\t\tdist.at(h + dh).at(w + dw) = dist.at(h).at(w) + cost.at(h + dh).at(w + dw);\n\n\t\t\t\tif (cost.at(h + dh).at(w + dw) == 0) {//コストが低い場合\n\t\t\t\t\tque.push_front(make_pair(h + dh, w + dw));\n\t\t\t\t}\n\t\t\t\telse {//コストが高い場合\n\t\t\t\t\tque.push_back(make_pair(h + dh, w + dw));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nvoid dfs(const vector<vector<int>>& G, vector<bool>& seen, int v) {\n\tseen.at(v) = true;\n\n\tfor (int next_v : G.at(v)) {\n\t\tif (seen.at(next_v)) continue;\n\t\tdfs(G, seen, next_v);\n\t}\n}\n\n\n\n\nclass edge {\npublic:\n\tint to;\n\tint cost;\n};\n\nvoid dijkstra(int s, const vector<vector<edge>> G, vector<int>& dist) {\n\tint V = dist.size(); //頂点数\n\tdist.assign(V, INF);\n\n\t//first が最短距離、second が頂点番号。\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n\tdist.at(s) = 0; que.push(make_pair(0, s));\n\n\twhile (!que.empty()) {\n\t\tpair<int, int> p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (dist.at(v) < p.first) continue;  //最短距離がすでに更新されているので無視。\n\n\t\tfor (int i = 0; i < (int)G.at(v).size(); i++) {\n\t\t\tedge e = G.at(v).at(i);\n\t\t\t//for (auto&& e : G.at(v)) {  // ← なぜか、やや遅いので。\n\t\t\tif (dist.at(e.to) > dist.at(v) + e.cost) {\n\t\t\t\tdist.at(e.to) = dist.at(v) + e.cost;\n\t\t\t\tque.push(make_pair(dist.at(e.to), e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int Vmax2 = 1;\nint dp_warshall[Vmax2][Vmax2];\n\n//G.at(i).at(j) は i から j への移動コスト。隣接行列。\nvoid warshall_floyd(int V, const vector<vector<int>> G) {\n\trep(i, V) {\n\t\trep(j, V) {\n\t\t\tdp_warshall[i][j] = G.at(i).at(j);  //初期化\n\t\t}\n\t}\n\n\trep(k, V) {\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\tdp_warshall[i][j] = min(dp_warshall[i][j], dp_warshall[i][k] + dp_warshall[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nclass UnionFind {\npublic:\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tUnionFind(int N) : parent(N), rank(N, 0) {\n\t\trep(i, N) {\n\t\t\tparent.at(i) = i;\n\t\t}\n\t}\n\n\tint root(int x) {\n\t\tif (parent.at(x) == x) return x;\n\t\treturn parent.at(x) = root(parent.at(x));\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\n\t\tif (rx == ry) return; //xの根とyの根が同じなので、何もしない。\n\t\tif (rank.at(rx) < rank.at(ry)) {\n\t\t\tparent.at(rx) = ry;\n\t\t}\n\t\telse {\n\t\t\tparent.at(ry) = rx;\n\t\t\tif (rank.at(rx) == rank.at(ry)) rank.at(rx)++;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn (root(x) == root(y));\n\t}\n\n\tint count_tree() {\n\t\tint N = parent.size();\n\t\tint res = 0;\n\n\t\trep(i, N) {\n\t\t\tif (root(i) == i) res++;\n\t\t}\n\n\t\treturn res;\n\t}\n};\n\n\n\n\nclass wUnionFind {\npublic:\n\tvector<int> parent;\n\tvector<int> diff_weight; //親との差分。\n\tvector<int> rank;\n\n\twUnionFind(int N) : parent(N), diff_weight(N, 0), rank(N, 0) {\n\t\trep(i, N) {\n\t\t\tparent.at(i) = i;\n\t\t}\n\t}\n\n\tint root(int x) {\n\t\tif (parent.at(x) == x) return x;\n\n\t\tint r = root(parent.at(x));\n\t\tdiff_weight.at(x) += diff_weight.at(parent.at(x)); //累積和\n\t\treturn parent.at(x) = r;\n\t}\n\n\t//x の重みを出力する関数。\n\tint weight(int x) {\n\t\troot(x);\n\t\treturn diff_weight.at(x);\n\t}\n\n\t//weight.at(y) - weight.at(x) == w となるようにする。\n\tbool unite(int x, int y, int w) {\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\tint diff_weight_to_ry_from_rx = w + weight(x) - weight(y);\n\n\t\tif (rx == ry) return false; //xの根とyの根が同じなので、何もしない。\n\t\tif (rank.at(rx) < rank.at(ry)) {\n\t\t\tparent.at(rx) = ry;\n\t\t\tdiff_weight.at(rx) = -diff_weight_to_ry_from_rx;\n\t\t}\n\t\telse {\n\t\t\tparent.at(ry) = rx;\n\t\t\tdiff_weight.at(ry) = diff_weight_to_ry_from_rx;\n\t\t\tif (rank.at(rx) == rank.at(ry)) rank.at(rx)++;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn (root(x) == root(y));\n\t}\n\n\tint count_tree() {\n\t\tint N = parent.size();\n\t\tint res = 0;\n\n\t\trep(i, N) {\n\t\t\tif (root(i) == i) res++;\n\t\t}\n\n\t\treturn res;\n\t}\n};\n\n\n\n\nclass SegmentTree {\nprivate:\n\tint ini = INF;\n\npublic:\n\tint Size;\n\tvector<int> node;\n\n\tSegmentTree(int N) : Size(N), node(N) {\n\t\tint new_N = 1;\n\t\twhile (new_N < N) new_N *= 2;\n\n\t\tnode.assign(2 * new_N - 1, ini);\n\t\tSize = new_N;\n\t}\n\n\tSegmentTree(vector<int> v) : Size(v.size()), node(v.size()) {\n\t\tint new_N = 1;\n\t\twhile (new_N < (int)v.size()) new_N *= 2;\n\n\t\tnode.assign(2 * new_N - 1, ini);\n\t\tSize = new_N;\n\n\t\t//葉の初期化\n\t\tfor (int i = 0; i < (int)v.size(); i++) node.at(Size - 1 + i) = v.at(i);\n\n\t\t//上りながら初期化\n\t\tfor (int i = Size - 2; i >= 0; i--) node.at(i) = min(node.at(2 * i + 1), node.at(2 * i + 2));\n\t}\n\n\t// k 番目の値 (0-indexed) を x に変更する。\n\tvoid update(int k, int x) {\n\t\t//葉のノードの番号 (等比数列の和の公式)\n\t\tk += Size - 1;\n\t\tnode.at(k) = x;\n\n\t\t//上りながら更新 (0-indexedの場合、例えば、3 の子は、7, 8)\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\n\t\t\t//子の最小値を親の最小値とする。\n\t\t\tnode.at(k) = min(node.at(k * 2 + 1), node.at(k * 2 + 2));\n\t\t}\n\t}\n\n\t//[a, b) の最小値を計算する。[l, r) は、ノード k に対応する区間を与える。\n\t//query(a, b, 0, 0, size) で呼べばよい。\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return ini;  // 交差しない。\n\t\tif (a <= l && r <= b) return node.at(k); // 完全に含む。\n\t\telse {\n\t\t\tint vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn min(vl, vr);\n\t\t}\n\n\t}\n};\n\n\n\n\n//転倒数を返す (comp = less<int>() の場合)。\n//comp = greater<int>() の場合は、N_C_2 - 転倒数 を返すことになる。\nint my_merge(vector<int>& A, vector<int>& B, int left, int mid, int right, function <bool(int, int)> comp) {\n\tint i = left; //Aを分割したときの、左側の配列を差す配列。\n\tint j = mid;  //Bを分割したときの、左側の配列を差す配列。\n\tint k = 0;  //分割した後の配列 (一時的に) B に保存。\n\n\tint res = 0;\n\n\twhile (i < mid && j < right) {\n\t\tif (comp(A.at(i), A.at(j))) B.at(k++) = A.at(i++);\n\t\telse {\n\t\t\tB.at(k++) = A.at(j++);\n\t\t\tres += mid - i;\n\t\t}\n\t}\n\n\t//左側をBに移動し尽くしたので、右側を順に入れていく。\n\tif (i == mid) {\n\t\twhile (j < right) {\n\t\t\tB.at(k++) = A.at(j++);\n\t\t}\n\t}\n\telse { //右側をBに移動し尽くしたので、左側を順に入れていく。\n\t\twhile (i < mid) {\n\t\t\tB.at(k++) = A.at(i++);\n\t\t}\n\t}\n\n\t//Aに値を戻す。\n\trep(l, k) {\n\t\tA.at(left + l) = B.at(l);\n\t}\n\n\treturn res;\n}\n\n\nint my_merge_sort(vector<int>& target, vector<int>& tempo, int left, int right, function <bool(int, int)> comp) {\n\n\tint mid, res = 0;\n\tif (left == right || left == right - 1) return res;\n\n\tmid = (left + right) / 2;\n\tres += my_merge_sort(target, tempo, left, mid, comp);\n\tres += my_merge_sort(target, tempo, mid, right, comp);\n\tres += my_merge(target, tempo, left, mid, right, comp);\n\treturn res;\n}\n\n\n\n\ntemplate<typename T>\nclass mat {\npublic:\n\tvector<vector<T>> m;\n\n\t//コンストラクタ\n\tmat() : m(vector<vector<T>>()) {};\n\tmat(int h, int w) : m(vector<vector<T>>(h, vector<T>(w))) {};\n\tmat(int h, int w, T ini) : m(vector<vector<T>>(h, vector<T>(w, ini))) {};\n\n\tint H = m.size();\n\tint W = m.at(0).size();\n\n\t//出力\n\tvoid show() {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcout << m.at(i).at(j) << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\t// 添字演算子\n\tvector<T> operator[](const int i) const { return m[i]; } //読み取り\n\tvector<T>& operator[](const int i) { return m[i]; } //書き込み\n\tvector<T> at(const int i) const { return m.at(i); } //読み取り\n\tvector<T>& at(const int i) {return m.at(i);} //書き込み\n\n\t//行列同士の演算\n\tmat& operator=(const mat& a) { return *a; }\n\tmat& operator+=(const mat& a) { assert(W == a.W && H == a.H); rep(i, H)rep(j, W) m[i][j] += a[i][j]; return *this; }\n\tmat& operator-=(const mat& a) { assert(W == a.W && H == a.H); rep(i, H)rep(j, W) m[i][j] -= a[i][j]; return *this; }\n\tmat& operator*=(const mat& a) { \n\t\tassert(W == a.H); \n\t\tmat<T> m2(H, a.W, 0); \n\t\trep(i, H) {\n\t\t\trep(j, a.W) {\n\t\t\t\trep(k, W) {\n\t\t\t\t\tm2[i][j] += m[i][k] * a[k][j];\n\t\t\t\t\tm2[i][j] %= MOD;  //必要があるときのみ。\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tW = a.W;\n\t\trep(i, H) m[i].resize(W);\n\t\trep(i, H) {\n\t\t\trep(j, W) {\n\t\t\t\tm[i][j] = m2[i][j];\n\t\t\t}\n\t\t}\t\n\t\treturn *this;\n\t}\n\n\tmat operator+(const mat& a) const { return mat(*this) += a; }\n\tmat operator-(const mat& a) const { return mat(*this) -= a; }\n\tmat operator*(const mat& a) const { return mat(*this) *= a; }\n\tbool operator==(const mat& a) { \n\t\tassert(W == a.W && H == a.H); \n\t\tbool flg = true; \n\t\trep(i, H) {\n\t\t\trep(j, W) {\n\t\t\t\tif (m[i][j] != a[i][j]) {\n\t\t\t\t\tflg = false;\n\t\t\t\t\treturn flg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn flg;\n\t\t\t\t\t\n\t}\n\n\t// 行列とスカラの演算\n\tmat& operator+=(const T& a) { rep(i, H)rep(j, W)m[i][j] += a; return *this; }\n\tmat& operator-=(const T& a) { rep(i, H)rep(j, W)m[i][j] -= a; return *this; }\n\tmat& operator*=(const T& a) { rep(i, H)rep(j, W)m[i][j] *= a; return *this; }\n\tmat& operator/=(const T& a) { rep(i, H)rep(j, W)m[i][j] /= a; return *this; }\n\tmat operator+(const T& a) const { return mat(*this) += a; }\n\tmat operator-(const T& a) const { return mat(*this) -= a; }\n\tmat operator*(const T& a) const { return mat(*this) *= a; }\n\tmat operator/(const T& a) const { return mat(*this) /= a; }\n\t\n\n\t//自身の n 乗を返す。\n\tmat mat_pow(int n) {\n\t\tassert(W == H);\n\t\tif (n == 0) {\n\t\t\tmat temp(H, W, (T)0);\n\t\t\trep(i, H) {\n\t\t\t\ttemp[i][i] = (T)1;\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\n\t\tif (n % 2 == 0) {\n\t\t\tmat temp = mat_pow(n / 2);\n\t\t\treturn temp * temp;\n\t\t}\n\t\telse {\n\t\t\tmat temp = mat_pow(n - 1);\n\t\t\ttemp *= mat(*this);\n\t\t\treturn temp;\n\t\t}\n\t}\n};\n\n\n\n\n\nsigned main() {\n\n\twhile (true) {\n\t\tint N; cin >> N;\n\t\tif (N == 0) break;\n\n\t\tvector<int> w(N);\n\t\trep(i, N) cin >> w.at(i);\n\n\n\t\tvector<vector<int>> dp(N + 1, vector<int>(N + 1, 0));\n\n\t\tfor (int n = 2; n <= N; n += 1) {\n\t\t\tfor (int l = 0; l < N; l++) {\n\t\t\t\tint r = l + n;\n\t\t\t\tif (r > N) continue;\n\n\t\t\t\tif (n % 2 == 0 && dp.at(l + 1).at(r - 1) == n - 2 && abs(w.at(l) - w.at(r - 1)) <= 1) {\n\t\t\t\t\tdp.at(l).at(r) = n;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int mid = l; mid <= r; mid++) {\n\t\t\t\t\tdp.at(l).at(r) = max(dp.at(l).at(r), dp.at(l).at(mid) + dp.at(mid).at(r));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif (N % 2 == 0) {\n\t\t\tcout << dp.at(0).at(N) << endl;\n\t\t}\n\t\telse {\n\t\t\t//cout << max(dp.at(1).at(N), dp.at(0).at(N - 1)) << endl;\n\t\t\tcout << dp.at(0).at(N) << endl;\n\t\t}\n\n\t\t//cout << endl;\n\t}\n\n\n\n\t\n\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15);\n  }\n} initializer;\n\ntemplate<typename T> istream& operator>>(istream &s, vector<T> &v) {\n  for (T &t : v) s >> t;\n  return s;\n}\n\ntemplate<typename T> ostream& operator<<(ostream &s, const vector<T> &v) {\n  for (const T &t : v) s << t << endl;\n  return s;\n}\n\ntemplate<typename T> T min(vector<T>& v) {return *min_element(v.begin(), v.end());}\n\ntemplate<typename T> T max(vector<T>& v) {return *max_element(v.begin(), v.end());}\n\ntemplate<typename T> int min_element(vector<T>& v) {return min_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> int max_element(vector<T>& v) {return max_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> void sort(vector<T>& v) {sort(v.begin(), v.end());}\n\ntemplate<typename T, typename Function> void sort(vector<T>& v, Function func) {sort(v.begin(), v.end(), func);}\n\ntemplate<typename T> void rsort(vector<T>& v) {sort(v.rbegin(), v.rend());}\n\ntemplate<typename T> void reverse(vector<T>& v) {reverse(v.begin(), v.end());}\n\ntemplate<typename T> void unique(vector<T>& v) {v.erase(unique(v.begin(), v.end()), v.end());}\n\ntemplate<typename T> void nth_element(vector<T>& v, int n) {nth_element(v.begin(), v.begin() + n, v.end());}\n\ntemplate<typename T> bool next_permutation(vector<T>& v) {return next_permutation(v.begin(), v.end());}\n\ntemplate<typename T> int find(vector<T>& v, T t) {return find(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int in(vector<T> v, T t) {return find(v, t) != int(v.size());}\n\ntemplate<typename T> int lower_bound(vector<T>& v, T t) {return lower_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int upper_bound(vector<T>& v, T t) {return upper_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> T accumulate(const vector<T>& v, function<T(T, T)> func = plus<T>()) {return accumulate(v.begin(), v.end(), T(), func);}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v) {adjacent_difference(v.begin(), v.end(), v.begin());}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v, vector<T>& u) {adjacent_difference(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> void partial_sum(vector<T>& v, vector<T>& u) {partial_sum(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> T inner_product(vector<T>& v, vector<T>& u) {return inner_product(v.begin(), v.end(), u.begin(), T(0));}\n\ntemplate<typename T> int count(const vector<T>& v, T t) {return count(v.begin(), v.end(), t);}\n\ntemplate<typename T, typename Function> int count_if(const vector<T>& v, Function func) {return count_if(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> void remove_if(vector<T>& v, Function func) {v.erase(remove_if(v.begin(), v.end(), func), v.end());}\n\ntemplate<typename T, typename Function> bool all_of(vector<T> v, Function func) {return all_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool any_of(vector<T> v, Function func) {return any_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool none_of(vector<T> v, Function func) {return none_of(v.begin(), v.end(), func);}\n\ntemplate<typename T> vector<T> subvector(vector<T>& v, int a, int b) {return vector<T>(v.begin() + a, v.begin() + b);}\n\ntemplate<typename T> int kinds(const vector<T>& v) {return set<T>(v.begin(), v.end()).size();}\n\ntemplate<typename T> void iota(vector<T>& v, T t = 0) {iota(v.begin(), v.end(), t);}\n\ntemplate<typename T> bool is_sorted(const vector<T>& v) {return is_sorted(v.begin(), v.end());}\n\nclass Solver {\nprivate:\n  vector<int> w;\n  vector<vector<int>> mem;\n\npublic:\n  Solver(const vector<int>& w) : w(w), mem(w.size() + 1, vector<int>(w.size() + 1, -1)) {}\n\n  int solve(int a, int b) {\n    if (b - a < 2) return 0;\n    if (b - a == 2 && abs(w[a] - w[a + 1]) <= 1) return 2;\n    if (mem[a][b] != -1) return mem[a][b];\n    int z = solve(a + 1, b - 1);\n    if (z == b - a - 2 && abs(w[a] - w[b - 1]) <= 1) z += 2;\n    for (int i = a + 1; i < b; ++i) {\n      int x = solve(a, i) + solve(i, b);\n      if (x > z) z = x;\n    }\n    return mem[a][b] = z;\n  }\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<int> w(n);\n    cin >> w;\n    Solver solver(w);\n    cout << solver.solve(0, n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rrep(i, n) for (int i = 1; i <= (n); ++i)\n#define drep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define srep(i, s, t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(), a.end()\n#define rrng(a) a.rbegin(), a.rend()\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\n#define limit(x, l, r) max(l, min(x, r))\n#define lims(x, l, r) (x = max(l, min(x, r)))\n#define isin(x, l, r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)), x.end())\n#define show(x) cout << #x << \" = \" << x << endl;\n#define PQ(T) priority_queue<T, v(T), greater<T>>\n#define bn(x) ((1 << x) - 1)\n#define dup(x, y) (((x) + (y)-1) / (y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\n\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n\nvoid solve(int n){\n  ll dp[400][400];\n  Fill(dp,-n);\n  vl w(n);\n  rep(i,n)cin >> w[i];\n  rep(i,n+1){\n    dp[i][i] = 0;\n    // 半開区間なので、[i][i+1]は積木が1個しか存在しないため、0にする\n    if(i<n) dp[i][i+1] = 0;\n  }\n\n  for(int bet = 2; bet<=n;bet++){\n    for(int i = 0;i+bet<=n;i++){\n      int j = i+bet;\n      if(dp[i+1][j-1] == j-i-2){\n        if(abs(w[i]-w[j-1]) <= 1) maxs(dp[i][j],(ll)(j-i));\n        else maxs(dp[i][j],(ll)(j-i-2));\n      }\n      for(int k = i+1;k<=j-1;k++){\n        maxs(dp[i][j],dp[i][k]+dp[k][j]);\n      }\n    }\n  }\n  cout<<dp[0][n]<<endl;\n}\nint main() {\n  while(1){\n  int n;\n  cin >> n;\n  if(!n)break;\n  else{\n    solve(n);\n  }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(obj) begin(obj), end(obj)\nusing namespace std;\n \ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n \nint N;\nvector<int> w;\nvector<vector<int>> dp;\n \nint rec(int l = 0, int r = N) { // メモ化再帰\n    if ((r - l) <= 1) return 0;\n    if ((r - l) == 2) {\n        if (abs(w[l] - w[l + 1]) <= 1) {  // 隣り合う2つの差が1以下\n            return 2;\n        } else {\n            return 0;\n        }\n    }\n \n    int &ret = dp[l][r];\n    if (ret != -1) return ret;  // 既に計算済みならその値を使う\n \n    // 1. 全部取り除けるとき\n    if (abs(w[l] - w[r-1]) <= 1 && rec(l + 1, r - 1) == r - l - 2) chmax(ret, r - l);\n    // 2. そうでない時\n    for (int i = l + 1; i <= r - 1; i++) {\n        chmax(ret, rec(l, i) + rec(i, r));\n    }\n \n    return ret;\n}\n \nint main() {\n    vector<int> ans;\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        w.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> w.at(i);\n        }\n \n        dp.assign(N + 2, vector<int>(N + 2, -1));  // 初期化\n \n        ans.push_back(rec());\n    }\n \n    for (auto i : ans) {\n        cout << i << endl;\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nint N;\nvector<int> w;\nvector<vector<int> > dp;\n\nint rec(int left = 0, int right = N - 1) {\n    if (left == right) {\n        return dp.at(left).at(right) = 0;\n    }\n    if (right - left == 1) {\n        return dp.at(left).at(right) = (abs(w.at(left) - w.at(right)) <= 1) ? 2 : 0;\n    }\n    int &ret = dp.at(left).at(right);\n    if (ret != -1) {\n        return ret;\n    }\n    if (rec(left + 1, right - 1) == right - left - 1 && abs(w.at(left) - w.at(right)) <= 1) {\n        return ret = right - left + 1;\n    }\n    for (int i = left; i < right; ++i) {\n        ret = max(ret, rec(left, i) + rec(i + 1, right));\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        w.resize(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> w.at(i);\n        }\n\n        dp.assign(N, vector<int>(N, -1));\n\n        cout << rec() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);++(i))\n\nint main()\n{\n\tint n;\n\twhile(cin >> n , n)\n\t{\n\t\tvector<int> w(n,0);\n\t\tfor(int i = 0;i < n;i++)\n\t\t{\n\t\t\tcin >> w[i];\n\t\t}\n\t\t\n\t\tvector<vector<int>> dp(n + 1,vector<int>(n + 1,0));\n\n\t\tfor(int W = 2;W <= n;W++)\n\t\t{\n\t\t\t//left\n\t\t\tfor(int l = 0;l < n;l++)\n\t\t\t{\n\t\t\t\tint r = l + W - 1;\n\t\t\t\tif(r >= n) continue;\n\n\t\t\t\tif(dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r]) <= 1)\n\t\t\t\t\tdp[l][r] = W;\n\n\t\t\t\tfor(int mid = l;mid <= r;mid++)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r] = max(dp[l][r] , dp[l][mid] + dp[mid + 1][r]);\n\t\t\t\t}\n\n\t\t\t\tcout << l << \"-\" << r << \"=\" << dp[l][r] << endl;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    int w[n];\n    for(int i = 0; i < n; ++i)\n      cin >> w[i];\n    \n    int dp[n][n];\n    for(int i = 0; i < n; ++i){\n      fill(dp[i],dp[i]+n,0);\n    }\n    \n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(j+i+1 > n-1) break;\n\tif(dp[j+1][j+i] == i && abs(w[j]-w[j+i+1]) < 2){\n\t  dp[j][j+i+1] = dp[j+1][j+i] + 2;\n\t}else{\n\t  for(int k = 0; k <= i; ++k){\n\t    dp[j][j+i+1] = max(dp[j][j+i+1],dp[j][j+k]+dp[j+k+1][j+i+1]);\n\t  }\n\t}\n      }\n    }\n    //Debug\n    /*\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n      cout << dp[i][j] << \" \";\n      }\n      cout << endl;\n    }\n\n    */\n    cout << dp[0][n-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i,n,N) for(int i=(n); i<(N); i++)\n#define RREP(i,n,N) for(ll i=(N-1); i>=n; i--)\n#define CK(n,a,b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(),(v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define v2(T) vector<vector<T>>\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1e9+7;\nconst int inf=1e9;\n\nint dp[310][310];\nint n;\nint w[310];\nint main() {\n    while(cin>>n, n){\n        REP(i,0,n) REP(j,0,n) dp[i][j] = 0;\n        REP(i,0,n) cin>>w[i];\n        for(int k=1;k<n;k++){\n            REP(L,0,n-k){\n                int R = L + k;\n                if(dp[L+1][R-1] == k-1) dp[L][R] = max(dp[L][R], dp[L+1][R-1] + (abs(w[L]-w[R]) <= 1)*2);\n                REP(i,L,R) dp[L][R] = max(dp[L][R], dp[L][i] + dp[i+1][R]);\n            }\n        }\n        p(dp[0][n-1]);\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n//#include <boost/foreach.hpp>\n//#include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n#define INF 1e9\n#define LINF 1e18\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define MOD 1000000007LL\n#define int long long\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\n\nbool isupper(char c){if('A'<=c&&c<='Z')return 1;return 0;}\nbool islower(char c){if('a'<=c&&c<='z')return 1;return 0;}\nbool isPrime(int x){if(x==1)return 0;if(x==2)return 1;if(x%2==0)return 0;for(int i=3;i*i<=x;i++)if(x%i==0)return 0;return 1;}\nbool iskaibun(string s){for(int i=0;i<s.size()/2;i++)if(s[i]!=s[s.size()-i-1])return 0;return 1;}\n\nvector<int> v;\nvector<vector<int>> dp;\n\nint  rec(int l,int r){\n    if(dp[l][r]!=-1)return dp[l][r];\n    if(abs(r-l)<=1)return 0;\n    int res=0;\n    if(abs(v[l]-v[r-1])<=1 && rec(l+1,r-1)==r-l-2){\n        res=r-l;\n    }\n    for(int i=l+1;i<=r-1;i++){\n        res=max(res,rec(l,i)+rec(i,r));\n    }\n    return dp[l][r]=res;\n}\n\n\nsigned main (){\n    int n;\n    while(cin>>n && n){\n        v.resize(n);\n        dp.resize(n+1,vector<int>(n+1,-1));\n        rep(i,0,n)cin>>v[i];\n        rec(0,n); \n        cout<<dp[0][n]<<endl;\n        v.clear();\n        dp.clear();\n    }  \n\n\n}\n/*\n1-2\n0.5-2\n\n010\n01110\n00111\n000000111\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,a[300];\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tfor(int i=0;i<n;i++)cin>>a[i];\n\t\tbool ok[301][301]={};\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tif(abs(a[i+1]-a[i])<=1)ok[i][i+2]=1;\n\t\t}\n\t\tfor(int w=2;w<=n;w++)\n\t\t{\n\t\t\tfor(int i=0;i+w<=n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=1;j<w;j++)\n\t\t\t\t{\n\t\t\t\t\tif(ok[i][i+j]&&ok[i+j][i+w])ok[i][i+w]=1;\n\t\t\t\t}\n\t\t\t\tif(!ok[i][i+w])continue;\n\t\t\t\tif(i>0&&i+w<n&&abs(a[i-1]-a[i+w])<=1)\n\t\t\t\t{\n\t\t\t\t\tok[i-1][i+w+1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dp[301][301]={};\n\t\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)if(ok[i][j])dp[i][j]=j-i;\n\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=i+1;k<j;k++)dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t}\n\t\tcout<<dp[0][n]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 2; } }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tint a1 = j, a3 = i + j; if (a3 >= n)continue;\n\t\t\t\tfor (int k = a1 + 1; k <= a3; k++) {\n\t\t\t\t\tint a2 = k;\n\t\t\t\t\tdp[a1][a3] = max(dp[a1][a3], dp[a1][a2 - 1] + dp[a2][a3]);\n\t\t\t\t}\n\t\t\t\tif (dp[a1][a3] >= 1 && a1 > 0 && a3 < n - 1 && abs(a[a1 - 1] - a[a3 + 1]) <= 1) {\n\t\t\t\t\tdp[a1 - 1][a3 + 1] = dp[a1][a3] + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 2; } }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tint a1 = j, a3 = i + j; if (a3 >= n)continue;\n\t\t\t\tfor (int k = a1 + 1; k <= a3; k++) {\n\t\t\t\t\tint a2 = k;\n\t\t\t\t\tdp[a1][a3] = max(dp[a1][a3], dp[a1][a2 - 1] + dp[a2][a3]);\n\t\t\t\t}\n\t\t\t\tif (dp[a1][a3] >= 1 && a1 > 0 && a3 < n - 1 && abs(a[a1 - 1] - a[a3 + 1]) <= 1) {\n\t\t\t\t\tdp[a1 - 1][a3 + 1] = i + 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define debug(x) cerr << #x << \" = \" << (x) << endl\n#define SIZE 302\n\nusing namespace std;\n\nint dp[SIZE][SIZE], w[SIZE];\n\nint f(int j, int k) {\n\t// printf(\"f(%d, %d)\\n\", j, k);\n\tint maxf = -1;\n\tif (dp[j][k] > 0) return dp[j][k];\n\tif (j == k) return 0;\n\tif (k - j == 1) {\n\t\tdp[j][k] = ((abs(w[j] - w[k])) <= 1 ? 2 : 0);\n\t\t/*debug(j);\n\t\tdebug(k);\n\t\tdebug(dp[j][k]);*/\n\t\treturn dp[j][k];\n\t}\n\tfor (int i = j + 1; i + 1 < k; i++) {\n\t\tmaxf = max(maxf, f(j, i) + f(i + 1, k));\n\t}\n\tdp[j][k] = max(f(j + 1, k - 1) + (abs(w[j] - w[k]) <= 1 ? 2 : 0), maxf);\n\t/*debug(j);\n\tdebug(k);\n\tdebug(dp[j][k]);*/\n\treturn dp[j][k];\n}\n\nint main() {\n\twhile (1) {\n\t\tint n;\n\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tREP(i, n) cin >> w[i];\n\t\tREP(j, n) { REP(k, n) dp[j][k] = -1; }\n\n\t\tcout << f(0, n - 1) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\ntypedef pair<int, int> pii;\n\nconstexpr int MAX_N = 305;\nconstexpr int INF = 1LL << 60;\n\nint n, mem[MAX_N][MAX_N], w[MAX_N];\n\nint solve(int l, int r) {\n    if (r - l <= 1) {\n        return 0;\n    }\n    if (mem[l][r] != -1) {\n        return mem[l][r];\n    }\n\n    int res = 0;\n    for (int i = l + 1; i < r; ++i) {\n        res = max(res, solve(i, r));\n    }\n    for (int i = r - 1; l + 1 <= i; --i) {\n        res = max(res, solve(l, i));\n    }\n\n    if (abs(w[l] - w[l + 1]) <= 1) {\n        res = max(res, solve(l + 2, r) + 2);\n    }\n    if (abs(w[r - 1] - w[r - 2]) <= 1) {\n        res = max(res, solve(l, r - 2) + 2);\n    }\n    if (abs(w[l] - w[r - 1]) <= 1) {\n        int tmp = solve(l + 1, r - 1);\n        if (tmp == r - l - 2) {\n            res = max(res, tmp + 2);\n        }\n    }\n\n    return mem[l][r] = res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while(1) {\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n        memset(mem[0], -1, sizeof(mem));\n\n        for (int i = 0; i < n; ++i) {\n            cin >> w[i];\n        }\n\n        cout << solve(0, n) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,w[300];\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>w[i];\n    int dp[300][300]={};\n    int ans=0;\n    for(int i=1;i<n;i++)dp[i][i-1]=0;\n    for(int i=1;i<n;i++)\n      for(int j=0;j+i<n;j++){\n\tfor(int k=j;k<j+i;k++)\n\t  dp[j][j+i]=max(dp[j][j+i],dp[j][k]+dp[k+1][j+i]);\n\tif(dp[j+1][j+i-1]==i-1&&abs(w[j]-w[j+i])<2)dp[j][j+i]=i+1;\n      }\n    cout<<dp[0][n-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n;\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tvector<vector<int> > dp(n, vector<int>(n + 1));\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n - i; j++) {\n\t\t\t\tint r = j + i;\n\t\t\t\tfor (int k = j + 1; k < r; k++) {\n\t\t\t\t\tdp[j][r] = max(dp[j][r], dp[j][k] + dp[k][r]);\n\t\t\t\t}\n\t\t\t\tif (abs(a[j] - a[r - 1]) <= 1 && dp[j + 1][r - 1] == i - 2) {\n\t\t\t\t\tdp[j][r] = max(dp[j][r], dp[j + 1][r - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll ,P> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nint n;\nint dp[500][500];\nvector<int> w;\n\n// [l,r)\nint rec(int l, int r){\n    if(dp[l][r] >= 0) return dp[l][r];\n    if(r-l<2) return 0;\n\n    int res = 0;\n    res = max(res, rec(l,r-2)+(abs(w[r-2]-w[r-1])<=1?2:0));\n    res = max(res, rec(l+2,r)+(abs(w[l]-w[l+1])<=1?2:0));\n    if(rec(l+1,r-1) == r-l-2){\n        res = max(res, r-l-2+(abs(w[l+1]-w[r-2])<=1?2:0));\n    }\n    else{\n        res = max(res, rec(l+1,r-1));\n    }\n    res = max(res, rec(l,r-1));\n    res = max(res, rec(l+1,r));\n    return dp[l][r] = res;\n}\n\nint main() {\n    while(cin >> n, n){\n        w.resize(n);\n        REP(i,n){\n            cin >> w[i];\n        }\n        REP(i,n+1) fill(dp[i],dp[i]+n+1,-1);\n        cout << rec(0,n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define ll long long\nusing namespace std;\n//typedef vector<unsigned int>vec;\n//typedef vector<ll>vec;\n//typedef vector<vec> mat;\ntypedef pair<int, int> P;\ntypedef pair<ll,ll> LP;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n//template<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N, N){\n        vector<int> w(N);\n        REP(i,N) cin >> w[i];\n        // REP(i,N) cout << w[i] << \" \";\n        // cout << endl;\n        vector<vector<int>> dp(N+1, vector<int>(N+1, -1));\n        auto solve = [&](auto && self, int l, int r) -> int{\n            if(l >= r) return 0;\n            int &res = dp[l][r];\n            if(res != -1) return res;\n            for(int i=l;i<r;i++){\n                res = max(res, self(self, l, i) + self(self, i+1, r));\n            }\n            if(abs(w[l] - w[r]) <= 1){\n                if(self(self, l + 1, r - 1) == max(0, r - l - 1)) res = r - l + 1;\n            }\n            return res;\n        };\n\n        cout << solve(solve, 0, N-1) << endl;;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n// #define DEBUG\n\nconst int MAX_N = 300;\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N) {\n        vector<int> W(N);\n        rep(i, N) cin >> W[i];\n\n        bool dp[MAX_N][MAX_N] = {};\n        rep(i, MAX_N) {\n            dp[i][i] = true;\n        }\n\n        for (int len=2; len<=N; len+=2) {\n            for (int l=0; l<=N-len; l++) {\n                {\n                    int inner_len = len - 2;\n                    if (!(inner_len > 0 && !dp[l + 1][l + inner_len]) && abs(W[l] - W[l+ (len - 1)]) <= 1) {\n                        dp[l][l + (len - 1)] = true;\n                    }\n                }\n                {\n                    int len2 = len - 2;\n                    if ((dp[l][l+1] && dp[l+2][l+2+len2-1]) ||\n                        (dp[l][l+len2-1] && dp[l+len2][l+len2+1])) {\n                        dp[l][l+len-1] = true;\n                    }\n                }\n            }\n        }\n\n        int dp2[MAX_N + 1] = {};\n        rep(r, N) {\n            if (r > 0) dp2[r] = dp2[r-1];\n            for (int len=2; len<=r+1; len+=2) {\n                int l = r - len + 1;\n#ifdef DEBUG\n                // DUMP(len);\n                // DUMP2(l, r);\n#endif\n                if (dp[l][r]) {\n                    if (l-1 >= 0) {\n                        dp2[r] = max(dp2[r], dp2[l-1] + len);\n                    } else {\n                        dp2[r] = max(dp2[r], len);\n                    }\n                }\n            } \n        }\n\n#ifdef DEBUG\n        rep(l, N) {\n            rep(r, N) cerr << dp[l][r] << \" \";\n            cerr << endl;\n        }\n        cerr << \"-----------------------------\" << endl;\n        rep(i, N) cerr << dp2[i] << \" \";\n        cerr << endl;\n#endif\n\n        cout << dp2[N-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint a[300];\nint dp1[300][301]; // [l, r]\nint dp2[301];\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) scanf(\"%d\", a + i);\n\t\t\n\t\tmemset(dp1, 0, sizeof(dp1));\n\t\tREP(i, N - 1) if (abs(a[i] - a[i + 1]) <= 1) dp1[i][i + 1] = 2;\n\t\tFOR(w, 3, N + 1) {\n\t\t\tREP(i, N - w) {\n\t\t\t\tif (abs(a[i] - a[i+w]) > 1) continue;\n\t\t\t\t\n\t\t\t\tFOR(k, i + 2, i + w) {\n\t\t\t\t\tint l1 = i + 1, r1 = k - 1, l2 = k, r2 = i + w - 1;\n\t\t\t\t\tif (dp1[l1][r1] && dp1[l2][r2]) chmax(dp1[i][i+w], w + 1);\n\t\t\t\t}\n\t\t\t\tif (dp1[i+1][i+w-1]) chmax(dp1[i][i+w], w + 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(dp2, 0, sizeof(dp2));\n\t\tREP(i, N) {\n\t\t\tFOR(j, i + 1, N) chmax(dp2[j + 1], dp2[i] + dp1[i][j]);\n\t\t\tchmax(dp2[i + 1], dp2[i]);\n\t\t}\n\t\t\n\t\tif (debug) printf(\"@ \");\n\t\tcout << dp2[N] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nint w[300];\nint dp[301][301];\n\nint delta(int x,int y){\n  if(abs(w[x]-w[y])<=1&&x!=y)return 2;\n  return 0;\n}\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(!n)break;\n    rep(i,n)cin >> w[i];\n    rep(i,301)rep(j,301)dp[i][j]=0;\n    rep(i,n)dp[i][i+1]=delta(i,i+1);\n    for(int d=2;d<n;d++){\n      for(int i=0;i<n-d;i++){\n        int tmp = 0,tmp1,tmp2,tmp3;\n        for(int k=i;k<i+d;k++){\n          if(k>0&&dp[i+1][k-1]==k-i-1)tmp1 = max(dp[i][k],dp[i+1][k-1]+delta(i,k));\n          else tmp1 = dp[i][k];\n          if(k+2<n&&dp[k+2][i+d-1]==i+d-k-2)tmp2 = max(dp[k+1][i+d],dp[k+2][i+d-1]+delta(k+1,i+d));\n          else tmp2 = dp[k+1][i+d];\n          if(d%2!=0&&dp[i+1][i+d-1]==d-1)tmp3 = dp[i+1][i+d-1]+delta(i,i+d);\n          else tmp3 = 0;\n          // cout << i << \" \" << k << \" \" << i+d << \" \" << tmp1 << \" \" << tmp2 << \" \" << tmp3 << endl;\n          tmp = max(tmp,tmp1+tmp2);\n          tmp = max(tmp,tmp3);\n        }\n        dp[i][i+d] = tmp;\n        // cout << tmp << endl;\n      }\n    }\n    cout << dp[0][n-1] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<int> w;\n\nint memo[301][301];\n\nint rec(int l, int r) {\n  if (r == l) {\n    return (memo[l][r] = 1);\n  }\n  if (memo[l][r] != 0) {\n    return memo[l][r];\n  }\n  if (r - l == 1) {\n    if (abs(w[l] - w[r]) <= 1) {\n      return (memo[l][r] = 2);\n    } else {\n      return (memo[l][r] = 1);\n    }\n  }\n\n  if (abs(w[l] - w[r]) <= 1) {\n    if (rec(l + 1, r - 1) == 2) {\n      return (memo[l][r] = 2);\n    }\n  }\n\n  if (abs(w[l] - w[l + 1]) <= 1) {\n    if (rec(l + 2, r) == 2) {\n      return (memo[l][r] = 2);\n    }\n  }\n\n  if (abs(w[r] - w[r - 1]) <= 1) {\n    if (rec(l, r - 2) == 2) {\n      return (memo[l][r] = 2);    \n    }\n  }\n\n  return (memo[l][r] = 1);\n}\n\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    memset(memo, 0, sizeof(memo));\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if ((j - i) % 2 == 0) {\n          continue;\n        }\n        rec(i, j);        \n      }\n    }\n\n    \n    int ans = 0;\n\n    int dp[301] = {0};\n\n    for (int i = 1; i < n; i++) {\n      int temp = 0;\n      if (memo[0][i] == 2) {\n        temp = i + 1;\n      }\n      dp[i] = max(dp[i - 1], temp);\n      for (int j = 1; j < i; j++) {\n        if (memo[j][i] == 2) {\n          dp[i] = max(dp[i], dp[j - 1] + (i - j + 1));\n        }\n      }\n    }\n\n    ans = dp[n - 1];\n\n    /*\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        if (memo[i][j] == 2) {\n          ans = max(ans, j - i + 1);\n        }\n        for (int k = i + 1; k <= j; k++) {\n          for (int l = k + 1; l < j; l++) {\n            if (memo[i][k] == 2 && memo[l][j] == 2) {\n              ans = max(ans, (k - i + 1) + (j - l + 1));\n            }\n          }\n        }\n      }\n      }*/\n\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include \"math.h\"\n \nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vin;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vp;\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define drep(i,a,b) for(ll i=(a);i>=(b);--i)\n#define SIZE(a) int((a).size())\n#define out(a) cout<<(a)<<endl;\nconst int INF=INT_MAX;\nconst int MAX = 510000;\nconst ll MOD = 1000000007;\nll fac[MAX], finv[MAX], inv[MAX];\n\nint main(){\n  while(true){\n  ll n;cin>>n;\n  if(!n)break;\n  vll p(n);\n  vvll dp(n,vll(n,0));\n  rep(i,0,n){\n    cin>>p[i];\n  }\n  \n  rep(haba,2,n+1){\n    rep(i,0,n-haba+1){\n      int j=i+haba-1;\n      if(dp[i+1][j-1]==haba-2&&abs(p[i]-p[j])<=1){\n        dp[i][j]=haba;\n      }\n      rep(k,i,j){\n        dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);\n      }\n    }\n  }\n  cout<<dp[0][n-1]<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nbool dp[310][310];\nint dplen[310];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tVI xs(N);\n\tREP(i,N) cin >> xs[i];\n\tfill((bool*)dp, (bool*)dp+310*310, false);\n\tfill(dplen, dplen+310, 0);\n\n\tREP(i,N+1) dp[i][i] = true;\n\tfor(int l=2;l<=N;l+=2){\n\t  for(int b=0,e=b+l;e<=N;++b,++e){\n\t\tdp[b][e] = dp[b][e] || (dp[b+1][e-1] && abs(xs[b]-xs[e-1]) <= 1);\n\t\tif(dp[b][e]) continue;\n\t\tfor(int i=b+2;i<e;i+=2)\n\t\t  dp[b][e] = dp[b][e] || (dp[b][i] && dp[i][e]);\n\t  }\n\t}\n\n\tfor(int i=0;i<N;++i){\n\t  maxi(dplen[i+1], dplen[i]);\n\t  for(int j=i+2;j<=N;j+=2)\n\t\tif(dp[i][j])\n\t\t  maxi(dplen[j], dplen[i] + j-i);\n\t}\n\tcout << dplen[N] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define DEBUG\n\n#ifdef DEBUG\n\n#define printd printf\n\n#else\n\n#define printd(...)\n\n#endif\n\nstd::vector<int> weights(300, 0);\nstd::vector<std::vector<uint>> dp(302, std::vector<uint>(302, 0));\n\nint solve(int num_daruma)\n{\n    for (uint i = 0; i < num_daruma; i++)\n    {\n        std::cin >> weights[i];\n    }\n\n    for (uint i = 0; i <= num_daruma; i++)\n    {\n        std::fill(dp[i].begin(), dp[i].begin() + num_daruma + 1, 0);\n    }\n\n    for (uint width = 1; width <= num_daruma; width++)\n    {\n        for (uint l = 0; l <= num_daruma - width; l++)\n        {\n            auto r = l + width;\n\n            if (width >= 2 && dp[l + 1][r - 1] == r - l - 2 && abs(weights[l] - weights[r - 1]) < 2)\n            {\n                dp[l][r] = std::max({dp[l][r], r - l});\n                continue;\n            }\n\n            for (uint mid = l + 1; mid < r; mid++)\n            {\n                dp[l][r] = std::max({dp[l][r], dp[l][mid] + dp[mid][r]});\n            }\n        }\n    }\n\n    return dp[0][num_daruma];\n}\n\nint main()\n{\n    int num_daruma = -1;\n\n    while (true)\n    {\n        std::cin >> num_daruma;\n        if (num_daruma == 0)\n        {\n            break;\n        }\n        std::cout << solve(num_daruma) << std::endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint main() {\n\n  int n, a[305];\n  while(1){\n    cin>>n;\n    if(n == 0) break;\n    REP(i,0,n) cin>>a[i];\n\n    int dp[305][305];\n    REP(i,0,n)REP(j,0,n) dp[i][j] = 0;\n\n    for(int k=1; k<n; k++){\n      for(int i = 0; i+k<n; i++){\n        if(abs(a[i] - a[i+k]) <= 1 && dp[i+1][i+k-1] == (i+k) - i - 1){\n          dp[i][i+k] = dp[i+1][i+k-1] + 2;\n        }else{\n          int tmp = 0;\n          for(int p=i+1; p<i+k; p++){\n            if(p+1 < i+k) tmp = max(tmp, dp[i][p] + dp[p+1][i+k]);\n            else tmp = max(tmp, max(dp[i][p], dp[i+k-1][i+k]));\n          }\n          dp[i][i+k] = tmp;\n        }\n      }\n    }\n    cout<<dp[0][n-1]<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n//#define MAX 300\nshort n;\nshort* w;\nvector<pair<short*,short> > wmap;\n\nshort* pop(short* w,short a) { //w???a????????¨a+1?????????????????????\n\tshort *t;\n\tt = new short[n];\n\tfor (short i = 0; i < n; i++) {\n\t\tif(i < a) t[i] = w[i];\n\t\telse t[i] = w[i + 2];\n\t}\n\tt[n - 2] = -1;\n\tt[n - 1] = -1;\n\treturn t;\n}\n\nshort daruma(short* w) {\n\tfor (short i = 0; i < wmap.size(); i++) {\n\t\tif (memcmp(w, wmap[i].first, sizeof(w)) == 0) {\n\t\t\treturn wmap[i].second;\n\t\t}\n\t}\n\n\tshort max = 0;\n\tfor (short i = 0; i < n - 1; i++) {\n\t\tif (w[i] != -1 && w[i + 1] != -1 && abs(w[i]-w[i+1])<=1) {\n\t\t\tshort tmp = daruma(pop(w, i))+2;\n\t\t\tif (tmp > max) max = tmp;\n\t\t}\n\t}\n\n\twmap.push_back(make_pair(w,max));\n\treturn max;\n}\n\nvoid clear() {\n\tfor (int i = 0; i < wmap.size(); i++) {\n\t\tdelete(wmap[i].first);\n\t}\n\twmap.clear();\n}\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\tclear();\n\t\tw = new short[n]();\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\t\tcout << daruma(w) << endl;\n\n\t\tdelete(w);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debugos cout\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=decltype(l)();(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ninline void assert_call(bool assertion, function<void()> f) { if (!assertion) { cerr << \"assertion fault:\" << endl; f(); abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream& os, const Vec& a) {\n    os << '['; for (const auto& e : a) os << ' ' << e << ' '; os << ']'; return os;\n}\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& chmax(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& chmin(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T, typename Random = decltype(randdev), typename enable_if<is_integral<T>::value>::type* = nullptr>\ninline T rand(T l, T h, Random& rand = randdev) { return uniform_int_distribution<T>(l, h)(rand); }\ntemplate<typename T, typename Random = decltype(randdev), typename enable_if<is_floating_point<T>::value>::type* = nullptr>\ninline T rand(T l, T h, Random& rand = randdev) { return uniform_real_distribution<T>(l, h)(rand); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) noexcept {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc < '0' || '9' < cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() noexcept { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) noexcept { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) noexcept { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> inline void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) noexcept {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) noexcept { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) noexcept { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) noexcept { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) noexcept { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = ' ') { for (bool b = 0; begin != end; ++begin, b = 1) b ? *this << sep << *begin : *this << *begin; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nint N;\nint weights[303];\n\nint dp[303][303];\n\n\nvoid solve() {\n\n    fill(dp[0], dp[N], 0);\n\n    repeat(i, N - 1) {\n        if (abs(weights[i] - weights[i + 1]) <= 1)\n            dp[i][i + 1] = 2;\n    }\n    \n    int best = 0;\n    for (int w = 3; w < N; w += 2) {\n        repeat(i, N - w) {\n            int z = 0;\n            if (abs(weights[i] - weights[i + w]) <= 1 && dp[i + 1][i + w - 1] == w - 1) {\n                chmax(z, dp[i + 1][i + w - 1] + 2);\n            }\n            chmax(z, dp[i + 1][i + w - 1]);\n            iterate(j, i + 2, i + w + 1)\n                chmax(z, dp[i][j - 1] + dp[j][i + w]);\n            \n            chmax(dp[i][i + w], z);\n            chmax(best, z);\n        }\n    }\n    \n    printer << best << '\\n';\n}\n\n\nint main() {\n\n    int n;\n    while (scanner >> n, n != 0) {\n        N = n;\n        scanner.in(weights, weights + n);\n        solve();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n\nint dp[305][305];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tint n; cin >> n;\n\t\tif(n==0)break;\n\t\tvector<int> w(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> w[i];\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(j+i-1>=n)continue;\n\t\t\t\tif(dp[j+1][j+i-2]==i-2&&abs(w[j]-w[i+j-1])<=1){\n\t\t\t\t\tdp[j][j+i-1]=i;\n\t\t\t\t}\n\t\t\t\tfor(int k=j;k<j+i-1;k++){\n\t\t\t\t\tdp[j][i+j-1]=max(dp[j][i+j-1],dp[j][k]+dp[k+1][i+j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[0][n-1]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef _DEBUG\n#include \"debug.hpp\"\n#else\n#define debug(...)\n#endif\n#define REP(i, m, n) for(int (i) = (m); (i) < (n); ++i)\n#define rep(i, n) REP(i, 0, n)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1e9 + 7;\nconst ll LINF = 1LL << 60;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if(a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if(a > b) { a = b; return true; } return false; }\n\nint dp[310][310];\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vector<int> w(n);\n    rep(i,n) cin >> w[i];\n    rep(i,310) rep(j,310) dp[i][j] = 0;\n    REP(i,2,n+1) rep(l,n) {\n      int r = l+i;\n      if(r > n) continue;\n      REP(j,l,r+1) {\n        chmax(dp[l][r], dp[l][j] + dp[j][r]);\n      }\n      if(dp[l+1][r-1] == r-l-2 && abs(w[l]-w[r-1]) <= 1) {\n        chmax(dp[l][r], r-l);\n      }\n      else chmax(dp[l][r], dp[l+1][r-1]);\n    }\n    cout << dp[0][n] << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nmain(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<n;i+=2)\n      for(int j=0;j<n-i;j++){\n        dp[j][j+i]=dp[j+1][j+i-1];\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=i+1;\n        else for(int k=1;k<i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nbool** table;\nint** dp;\nint N;\n\nint recursive(int left,int right){\n\n\tif(left == right)return dp[left][right] = 0;\n\tif(dp[left][right] != -1)return dp[left][right]; //?????¢???????????´???\n\tif((right-left+1)%2 == 1){ //??????????\\???°?????´???\n\t\treturn dp[left][right] = max(recursive(left,right-1),recursive(left+1,right));\n\t}\n\tif(table[left][(right-left+1)/2] == true)return dp[left][right] = right-left+1; //left???right?????¨????¶?????????´???\n\tif(right == left+1 && table[left][1] == false)return 0;\n\n\tint ans = 0;\n\tfor(int i = left+1; i <= right-2; i++){\n\t\tans = max(ans,recursive(left,i)+recursive(i+1,right));\n\t}\n\treturn dp[left][right] = ans;\n}\n\nint main(){\n\n\tint data[301];\n\ttable = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tdp = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 0; i <= 300; i++){\n\t\t\tfor(int k = 0; k <= 150; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= 300; k++){\n\t\t\t\tdp[i][k] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1)table[i][1] = true;\n\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",recursive(1,N));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\nusing namespace std;\n\n\n\n\nint main(){\n    while(1){\n        \n        \n        \n        \n    \n    int n,a[500]={};\n    cin>>n;\n        if(n==0){break;}\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    bool j[500][500]={};\n    for(int i=2;i<=n;i+=2){\n        for(int t=0;t<=n-i;t++){\n            if(abs(a[t]-a[t+i-1])<=1 && (j[t+1][t+i-2] || i==2)){j[t][t+i-1]=true; continue;}\n            for(int h=t+1;h<t+i-1;h++){\n                if(j[t][h] && j[h+1][t+i-1]){j[t][t+i-1]=true; break;}\n            }\n        }\n    }\n    int dp[500];\n    fill(dp,dp+500,INT_MAX/2);\n    dp[0]=1;\n    for(int i=0;i<n;i++){\n        if(j[0][i]){dp[i]=0;}\n    }\n    for(int i=1;i<n;i++){\n        dp[i]=min(dp[i],dp[i-1]+1);\n        for(int t=i;t<n;t++){\n            if(j[i][t]){dp[t]=min(dp[t],dp[i-1]);}\n        }\n    }\n    \n    /*\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            cout<<(j[i][t]?\"1\":\"0\")<<\" \";\n        }\n        cout<<endl;\n    }\n     */\n    \n    //for(int i=0;i<n;i++){\n        cout<<n-dp[n-1]<<endl;\n    //}\n    \n    \n        \n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n-1){\n            if(!k)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n                    cmax(dp[i][i+k],dp[i+1][i+k-1]+2);\n                }\n                for(int j = i+1; j<i+k && j<n-1;j++){\n                    if(dp[i][j] && dp[j+1][i+k])cmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n                }\n            }\n        }\n        int ans = 0;\n        int maxi = 0;\n        for(int i = maxi; i < n; i++){\n            for(int j = n-1; j>=0;--j){\n                if(dp[i][j]){\n                    ans += j-i+1;\n                    i = j;\n                    break;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\n    public:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// 実数値のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない)\nconstexpr i64 max_loop = 100;\n\nlong double tolerance(const long double& a, const long double& b, const long double& epsilon = eps) {\n    return epsilon * max({1.l, abs(a), abs(b)});\n}\n\n// a<0なら-1, a==0なら0, a>0なら1\nint sgn(const long double a, const long double& epsilon = eps) {\n    return (a > epsilon) - (a < -epsilon);\n}\n\n// a<bなら-1, a==bなら0, a>bなら1\nint compare(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return sgn(a - b, is_relative ? tolerance(a, b, epsilon) : epsilon);\n}\n\n// a==bか?\nbool is_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 0;\n}\n\n// a<bか?\nbool is_less(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == -1;\n}\n\n// a<=bか?\nbool is_less_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) <= 0;\n}\n\n// a>bか?\nbool is_greater(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 1;\n}\n\n// a>=bか?\nbool is_greater_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) >= 0;\n}\n\nvoid solve(i64 n) {\n    //constexpr i64 mod = 1'000'000'007;\n\n    vector<i64> w(n);\n    rep(i,0,n) cin >> w[i];\n\n    constexpr i64 maxn=301;\n    static i64 memo[maxn][maxn];\n    static bool done[maxn][maxn];\n    fill(memo,-inf64);\n    fill(done,false);\n\n    function<i64(i64,i64)> rec=[&](i64 begin,i64 end){\n        auto& res=memo[begin][end];\n        if(done[begin][end]) return res;\n        done[begin][end]=true;\n\n        if(end-begin<=1) return res=0;\n\n        rep(i,begin+1,end){\n            if(abs(w[begin]-w[i])>1) continue;\n            i64 tmp=rec(begin+1,i);\n            if(tmp!=i-(begin+1)) continue;\n            chmax(res,tmp+2+rec(i+1,end));\n        }\n\n        chmax(res,rec(begin+1,end));\n\n        return res;\n    };\n\n    cout << rec(0,n) << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    while(true){\n        i64 n;\n        cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint memo[300][300];\nint dfs(const vector<int> &w, int left, int right){\n\tif(right - left < 2) return  0;\n\tif(right - left == 2){\n\t\tif(abs(w[left] - w[right - 1]) <= 1) return 2;\n\t\telse return 0;\n\t}\n\tif(memo[left][right] != -1) return memo[left][right];\n\t//cout << left << ' ' << right << endl;\n\n\tint res = 0;\n\trange(i,left,right - 1){\n\t\tint tmp = 0;\n\t\tif(abs(w[i] - w[i + 1]) <= 1){\n\t\t\t//cout << left << ' ' << i << ' ' << i + 2 << ' ' << right << endl;\n\t\t\tif(left < i){\n\t\t\t\ttmp += dfs(w, left, i);\n\t\t\t}\n\t\t\tif(i + 2 < right){\n\t\t\t\ttmp += dfs(w, i + 2, right);\n\t\t\t}\n\t\t\tres = max(res, tmp + 2);\n\t\t}\n\t}\n\trange(i,left,right){\n\t\tint tmp = 0;\n\t\tif(left < i){\n\t\t\ttmp += dfs(w, left, i);\n\t\t}\n\t\tif(i + 1 < right){\n\t\t\ttmp += dfs(w, i + 1, right);\n\t\t}\n\t\tres = max(res, tmp);\n\t}\n\tif(dfs(w, left + 1, right - 1) == right - left - 2 && abs(w[left] - w[right - 1]) <= 1){\n\t\t//cout << left << ' ' << right << endl;\n\t\tres = max(res, right - left);\n\t}\n\treturn memo[left][right] = res;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        vector<int> w(n);\n\t\tmemset(memo, -1, sizeof(memo));\n        rep(i,n){\n            cin >> w[i];\n        }\n\n\t\tcout << dfs(w, 0, n) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <limits>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) { return x * x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXISTch(s,c) ((((s).find_first_of(c)) != std::string::npos)? 1 : 0)//cがあれば1 if(1)\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = (int)1000000007;\nconst LL MOD = (LL)1000000007;//10^9+7\nconst LL INF2 = (LL)100000000000000000;//10^18\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\nint N;\nvector<int> w;\n\nint solve() {\n\t//初期化\n\t//操作の対象は隣合う2マス\n\t//幅1や幅0の隙間は一つもとることができない。\n\tvector<vector<int>> dp(N + 1, vector<int>(N + 1, -N));\n\tfor (int i = 0; i <= N; i++) {\n\t\tdp[i][i] = 0;\n\t\tif (i < N)dp[i][i + 1] = 0;\n\t}\n\n\t//幅が小さい方から更新するので、それより短い区間はすべて値が入ってる。\n\t//[l,r)なので右端の要素はr-1\n\tfor (int bet = 2; bet <= N; bet++) {\n\t\t//左端\n\t\tfor (int i = 0; i + bet <= N; i++) {\n\t\t\tint j = i + bet;\n\n\t\t\t//i,jの間が全部抜けてる状態ならi,jも抜けるかもしれない\n\t\t\tif (dp[i + 1][j - 1] == j - i - 2 && abs(w[i] - w[j - 1]) <= 1) {\n\t\t\t\t\tchmax(dp[i][j], j - i);\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//i,jの間の区切り方を全部試す\n\t\t\tfor (int k = i + 1; k <= j - 1; k++) {\n\t\t\t\tchmax(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t}\n\n\treturn dp[0][N];\n}\n\nint main() {\n\twhile (cin >> N,N) {\n\t\tw.resize(N);\n\t\tfor (int i = 0; i < N; i++)cin >> w[i];\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint a1 = j, a2 = i + j - 1; if (a2 >= n)continue;\n\t\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\t\tif (a1 > 1 && abs(a[a1 - 1] - a[a1 - 2]) <= 1)dp[a1 - 2][a2] = 1;\n\t\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = n; k >= 0; k--) {\n\t\t\t\t\tint a1 = k, a2 = k + i, a3 = k + i + j; if (a3 > n)continue;\n\t\t\t\t\tdp[a1][a3 - 1] = max(dp[a1][a3 - 1], dp[a1][a2 - 1] + dp[a2][a3 - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define reps(i,j,k) for(int i=j;i<k;i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define mk make_pair\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dp[305][305];\nbool al[305][305]\n;\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvi w(n);\n\t\trep(i, n) cin >> w[i];\n\t\tfill(dp[0], dp[305], 0);\n\t\tfill(al[0], al[305], 0);\n\t\treps(j, 2, n+1){\n\t\t\trep(i, n - j + 2){\n\t\t\t\tint ij = i + j;\n\t\t\t\tif(j==2) al[i][ij] = abs(w[i]-w[i+1]) < 2;\n\t\t\t\telse{\n\t\t\t\t\tal[i][ij] = al[i+1][ij-1] && abs(w[i]-w[ij-1]) < 2;\n\t\t\t\t\treps(k, i+1, ij){\n\t\t\t\t\t\tal[i][ij] = al[i][ij] ||  al[i][k] && al[k][ij];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][ij] = al[i][ij] * j;\n\t\t\t\trep(k, i) dp[k][ij] = max(dp[k][ij], dp[i][ij]);\n\t\t\t\treps(k, ij+1, n+1) dp[i][k] = max(dp[i][k], dp[i][ij]);\n\t\t\t}\n\t\t\n\t\t}\n\t\t/*\n\t\trep(i,n+1){\n\t\t\trep(j,n+1){\n\t\t\t\tcout << al[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\trep(j, n+1){\n\t\t\trep(i, n - j + 2){\n\t\t\t\tint ij = i + j;\n\t\t\t\treps(k, i+1, j){\n\t\t\t\t\tdp[i][j] = max(dp[i][k] + dp[k][j], dp[i][j]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t\t\t\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <math.h>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <assert.h>\n#include <numeric>\n#include <iomanip>\n#define rep(i, a, b) for (int(i) = (a); i < (b); i++)\nusing namespace std;\n\nusing ll = long long;\n\nconst int INF = 100000000;\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst ll MOD = 1000000007;\n\nll pow_mod(ll x, ll y, ll mod)\n{\n\tll ans=1;\n\tfor(;y>0;y>>=1){\n\t\tif(y&1)(ans*=x)%=mod;\n\t\t(x*=x)%=mod;\n\t}\n\treturn ans;\n}\n\nll gcd(ll a,ll b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//問題文中の添え字が0-indexか1-indexか確認!\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<int> w(n);\n\t\trep(i,0,n)cin>>w[i];\n\t\tint dp[300][300] = {0};\n\t\trep(i,0,n)dp[i][i]=0;\n\t\trep(i,2,n+1){\n\t\t\trep(j,0,n-i+1){\n\t\t\t\tint l=j;\n\t\t\t\tint r=j+i-1;\n\t\t\t\tif(dp[l+1][r-1]==r-l-1&&abs(w[l]-w[r])<=1){\n\t\t\t\t\tdp[l][r]=r-l+1;\n\t\t\t\t}else{\n\t\t\t\t\tint temp=0;\n\t\t\t\t\trep(k,l+1,r+1){\n\t\t\t\t\t\ttemp=max(temp,dp[l][k-1]+dp[k][r]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[l][r]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][n-1]<<\"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1ll<<60;\n\ntemplate<class T>\nbool chmin(T &a, T b)\n{\n\tif (a > b)\n\t{\n\t\ta = b;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\ntemplate<class T>\nbool chmax(T &a, T b)\n{\n\tif (a < b)\n\t{\n\t\ta = b;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\ntemplate<class T>\nbool chmax(T &a, initializer_list<T> l)\n{\n\treturn chmax(a, *max_element(l.begin(), l.end()));\n}\n\ntemplate<class T>\nbool chmin(T &a, initializer_list<T> l)\n{\n\treturn chmin(a, *min_element(l.begin(), l.end));\n}\n\nll N;\nll W[310];\nll dp[310][310];\n\nvoid init()\n{\n\tfor (ll i = 0; i < 310; ++i) for (ll j = 0; j < 310; ++j) dp[i][j] = -1;\n}\n\nll solve(ll l, ll r)\n{\n\tif (dp[l][r]!=-1)return dp[l][r];\n\tif (l == r) return dp[l][r] = 0;\n\n\tll res(0);\n\tif (abs(W[l]-W[r])<=1 && solve(l+1, r-1) == r-l-1)\n\t\tres = r - l + 1;\n\n\tfor (ll mid = l; mid <= r-1; ++mid)\n\t\tchmax(res, solve(l, mid)+solve(mid+1, r));\n\n\treturn dp[l][r] = res;\n}\n\nint main(int argc, char **argv)\n{\n\twhile (cin >> N, N)\n\t{\n\t\tinit();\n\t\tfor (ll i = 0; i < N; ++i) cin >> W[i];\n\t\tstd::cout << solve(0, N-1) << std::endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<int> w(n); rep(i,n) cin >> w[i];\n    vector<vector<int>> dp(n+1,vector<int>(n+1));\n\n    // 区間DP\n    FOR(j,2,n+1){ // 区間長\n      for(int i = 0; i+j <= n; ++i;){ // 区間左端 dp[i][i+j]を決定する\n\t//printf(\"[%d,%d)\\n\",i,i+j);\n\tFOR(k,2,j-1) // dp[i][i+k],dp[i+k][i+j]を元に計算\n\t  dp[i][i+j] = max(dp[i][i+j], dp[i][i+k]+dp[i+k][i+j]);\n\t\n\tif(abs(w[i] - w[i+j-1]) <= 1)\n\t  dp[i][i+j] = max(dp[i][i+j], dp[i+1][i+j-1] + 2);\n      }\n    }\n\n    cout << dp[0][n] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tvi a(n);\n\t\tfor(int i=0;i<n;i++) cin>>a[i];\n\t\tvvi dp(n,vi(n+1));\n\t\tfor(int j=1;j<=n;j++) for(int i=0;i<j;i++){\n\t\t\tdp[i][j]=dp[i][j-1];\n\t\t\tfor(int k=j-2;k>=i;k--) if(abs(a[j-1]-a[k])<2&&dp[k+1][j-1]==j-k-2) dp[i][j]=max(dp[i][j],dp[i][k]+j-k);\n\t\t}\n\t\tcout<<dp[0][n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nconstexpr int NUM = 300;\nint w[NUM] = { 0 };\nbool dp[NUM] = {false}; //[???][???] = ?????¨??????????????????\n\nbool isDropedBetween(int a, int b) {\n\tif ((b - a) <= 1) return true;\n\tfor (int i = a + 1; i < b; i++) if (!dp[i]) return false;\n\treturn true;\n}\n\nbool isDroped(int a, int b) {\n\tfor (int i = a; i <= b; i++) if (!dp[i]) return false;\n\treturn true;\n}\n\nint main() {\n\tint n;\n\twhile (std::cin >> n && n) {\n\t\tstd::memset(dp, 0, sizeof(bool) * NUM * NUM);\n\t\tfor (int i = 0; i < n; i++) std::cin >> w[i];\n\n\t\tfor (int d = 1; d < n; d += 2) { //?????¨?????????\n\t\t\tfor (int i = 0; i < n - d; i++) { //?????¨?????´???\n\t\t\t\tbool mightDrop = false;\n\t\t\t\tif (isDropedBetween(i, i + d)) mightDrop = true; //???????????????????????¨????????¨??????\n\t\t\t\tif (isDroped(i, i + d) || (mightDrop && std::abs(w[i] - w[i + d]) <= 1)) {\n\t\t\t\t\tfor (int j = 0; j <= d; j++) dp[i + j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count[2] = {0};\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (dp[i]) count[1]++;\n\t\t\telse {\n\t\t\t\tcount[0] += count[1] / 2 * 2;\n\t\t\t\tcount[1] = 0;\n\t\t\t}\n\t\t}\n\t\tstd::cout << count[0] << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <stack>\n#include <regex>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define vi vector<int>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main()\n{\n  while (true)\n  {\n    int n;\n    cin >> n;\n    int dp[305][305];\n    REP(i, 305)\n    {\n      REP(j, 305)\n      {\n        dp[i][j] = 0;\n      }\n    }\n    if (n == 0)\n    {\n      break;\n    }\n    vi w = vi(n, 0);\n    REP(i, n)\n    {\n      cin >> w[i];\n    }\n    for (int width = 2; width < n + 1; width++)\n    {\n      REP(left, n)\n      {\n        int right = left + width - 1;\n        if (right >= n)\n        {\n          continue;\n        }\n        // 間のブロックが全部叩けるかつ両端の重さの差が1以下\n        if (dp[left + 1][right - 1] == width - 2 && abs(w[left] - w[right]) <= 1)\n        {\n          dp[left][right] = width;\n        }\n        for (int k = left; k < right; k++)\n        {\n          dp[left][right] = max(dp[left][right], dp[left][k] + dp[k + 1][right]);\n        }\n      }\n    }\n    cout << dp[0][n - 1] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int>as;\nbool ok(int a,int b){\n  return abs(as[a]-as[b])<=1;\n}\n\nint main() {\n  while(1){\n    \n    int N;cin>>N;\n    if(!N)break;\n    as.resize(N);\n    vector<vector<int>>dp(N+1,vector<int>(N+1,-100000));\n    for(int i=0;i<N;++i){\n      int a;cin>>a;as[i]=a;\n    }\n    for(int i=0;i<=N;++i){\n      dp[i][i]=0;\n    }\n    for(int t=2;t<=N;++t){\n      for(int l=0;l<=N-t;++l){\n\tconst int r=l+t;\n\tdp[l][r]=max(dp[l+1][r],dp[l][r-1]);\n\tif(ok(l,l+1))dp[l][r]=max(dp[l+2][r]+2,dp[l][r]);\n\tif(ok(r-2,r-1))dp[l][r]=max(dp[l][r-2]+2,dp[l][r]);\n\tif(ok(l,r-1)){\n\t  if(dp[l+1][r-1]==(r-l-2)){\n\t    dp[l][r]=max(dp[l+1][r-1]+2,dp[l][r]);\n\t  }\n\t}\n      } \n    }\n\n    int ans=dp[0][N];\n    ans=max(0,ans)\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define ALL(x)    (x).begin(),(x).end()\n#define UNIQ(c)   (c).erase(unique(ALL((c))), end((c)))\n#define mp        make_pair\n#define eb        emplace_back\ntypedef pair<LL, LL> P;\ntypedef pair<P, P> PP;\n\nint N;\nint W[333];\n\nbool dp[333][333];\nint dp2[333];\nvoid solve() {\n\tfor (int i = 0; i < N; i++)cin >> W[i];\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int i = 0; i < N; i++)dp[i][i] = true;\n\n\tfor (int len = 2; len <= N; len++) {\n\t\tfor (int i = 0; i + len <= N; i++) {\n\t\t\tint j = i + len;\n\t\t\tif (abs(W[i] - W[j - 1]) <= 1)dp[i][j] |= dp[i + 1][j - 1];\n\t\t\tfor (int k = i + 1; k < j; k++)dp[i][j] |= dp[i][k] & dp[k][j];\n\t\t}\n\t}\n\tmemset(dp2, 0, sizeof(dp2));\n\tfor (int i = 0; i < N; i++) {\n\t\tdp2[i + 1] = max(dp2[i + 1], dp2[i]);\n\t\tfor (int j = i + 1; j <= N; j++)if (dp[i][j])dp2[j] = max(dp2[j], dp2[i] + j - i);\n\t}\n\tcout << dp2[N] << endl;\n}\nint main() {\n\twhile (cin >> N, N)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\nint N;\nvector<int> w;\n\nint solve() {\n    vector<vector<int>> dp(N+1, vector<int>(N+1, -N));\n    for (int i = 0; i <= N; ++i) {\n        dp[i][i] = 0;\n        if (i < N) dp[i][i+1] = 0;\n    }\n    for (int bet = 2; bet <= N; ++bet) {\n        for (int i = 0; i + bet <= N; ++i) {\n            int j = i + bet;\n            if (dp[i+1][j-1] == j-i-2) {\n                if (abs(w[i] - w[j-1]) <= 1) chmax(dp[i][j], j-i);\n                else chmax(dp[i][j], j-i-2);\n            }\n            for (int k = i+1; k <= j-1; ++k) {\n                chmax(dp[i][j], dp[i][k] + dp[k][j]);\n            }\n        }\n    }\n    return dp[0][N];\n}\n\nint main() {\n    while (cin >> N, N) {\n        w.resize(N);\n        for (int i = 0; i < N; ++i) cin >> w[i];\n        cout << solve() << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint W[305];\nint dp[305][305];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0){break;}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&W[i]);\n\t\t}\n\t\tfor(int i=0;i<305;i++){\n\t\t\tfor(int j=0;j<305;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=N-2;i++){\n\t\t\tif(abs(W[i]-W[i+1])<=1){dp[i][2]=2;}\n\t\t}\n\t\tfor(int j=3;j<=N;j++){\n\t\t\tfor(int i=0;i+j<=N;i++){\n\t\t\t\t//[i,i+j)\n\t\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\t\tdp[i][j]=max(dp[i][k]+dp[i+k][j-k],dp[i][j]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+j-1])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-2]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int j=0;j<12;j++){\n\t\t\tfor(int i=0;i+j<=12;i++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t/*\n\t\tfor(int i=150;i>=0;i-=2){\n\t\tprintf(\"%d\\n\",dp[i][299-i]);\n\t\t}*/\n\t\tprintf(\"%d\\n\",dp[0][N]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nvector<tuple<int, int, int>>vec; int n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; vec.clear(); for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; } for (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { vec.push_back(make_tuple(j - i, i, j)); } }\n\t\tsort(vec.begin(), vec.end());\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tint a1 = get<1>(vec[i]), a2 = get<2>(vec[i]);\n\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { for (int k = j; k < n; k++) { dp[i][k] = max(dp[i][k], dp[i][j - 1] + dp[j][k]); } } }\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst int INF=1<<17;\n\nint dp[300][300]; //dp[i][j]:=[i,j)で取り除けるブロックの最大値\nvector<int> W;\n\nint rec(int l,int r){ //[r,l)\n    if(~dp[l][r]) return dp[l][r];\n    if(r-l<=1) return dp[l][r]=0;\n    else if(r-l==2){\n        if(abs(W[r-1]-W[l])<=1) return dp[l][r]=2;\n        else dp[l][r]=0;\n    }\n    int ret=0;\n    if(abs(W[l]-W[r-1])<=1&&rec(l+1,r-1)==r-l-2){\n        ret=max(ret,rec(l+1,r-1)+2);\n        return dp[l][r]=ret;\n    }\n    for(int i=l+1;i<r;i++){\n        ret=max(ret,rec(l,i)+rec(i,r));\n    }\n    return dp[l][r]=ret;\n}\n\n\nint main(){\n    int n;\n    while(cin >> n){\n        if(!n) break; \n        W.clear();\n        for(int i=0;i<n;i++){\n            int w;\n            cin >> w;\n            W.push_back(w);\n        }\n        memset(dp,-1,sizeof(dp));\n        cout << rec(0,n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\nint dp[1005][1005]={0};\n\nvoid init(){\n    for(int i=0;i<=1000;++i){\n        for(int j=0;j<=1000;++j)dp[i][j] = 0;\n    }\n}\n\nint main(){\n    int n;\n    while(cin >> n, n != 0){\n        init();\n        vector<int> v;\n        for(int i=0;i<n;++i){\n            int w;\n            cin >> w;\n            v.push_back(w);\n        }\n        for(int i=0;i<n-1;++i){\n            if(abs(v[i]-v[i+1]) <= 1)dp[i][i+1] = 2;\n        }\n        for(int d=3;d<n;d+=2){\n            for(int i=0;i+d<n;++i){\n                if(abs(v[i]-v[i+d])<=1 && dp[i+1][i+d-1] == d-1)dp[i][i+d] = max(dp[i][i+d], dp[i+1][i+d-1]+2);\n                for(int j=i+1;j<i+d;++j){\n                    dp[i][i+d] = max(dp[i][i+d], dp[i][j]+dp[j+1][i+d]);\n                }\n                dp[i][i+d] = max(dp[i][i+d], dp[i+1][i+d-1]);\n                /*if(dp[i+1][i+d-1] == d-1 && abs(v[i]-v[i+d])<=1){\n                    dp[i][i+d] = dp[i+1][i+d-1] + 2;\n                }else{\n                    bool ok = false;\n                    for(int j=i+1;j<i+d;++j){\n                        if(dp[i][j]+dp[j+1][i+d] == d+1){\n                            dp[i][i+d] = d+1;\n                            ok = true;\n                            break;\n                        }\n                    }\n                    if(!ok)dp[i][i+d] = dp[i+1][i+d-1];\n                }*/\n            }\n        }\n        int ans = 0;\n        for(int i=0;i<n;++i){\n            for(int j=0;j<n;++j)ans = max(ans, dp[i][j]);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\n#define reps(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, N) reps(i, 0, N-1)\n#define deps(i, E, S) for (ll i = (E); i >= (S); i--)\n#define dep(i, N) deps(i, N-1, 0)\nconst ll INF = 1LL << 60;\nconst int INF_INT = 1 << 30;\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\nstruct mll {\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val = (val + b.val) % MOD; return *this; }\n\tmll &operator -= (const mll &b) { val = (val + MOD - b.val) % MOD; return *this; }\n\tmll &operator *= (const mll &b) { val = (val*b.val) % MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c = b.val, d = MOD, u = 1, v = 0;\n\t\twhile (d) {\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b) {\n\t\tchmin(b, a - b);\n\t\tif (b < 0) return mll(0);\n\t\tmll c = 1;\n\t\trep(i, b) c *= a - i;\n\t\trep(i, b) c /= i + 1;\n\t\treturn c;\n\t}\n};\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\nstruct Fast {\n\tFast() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast; //cin,cout高速化のおまじない＋桁数指定\n\nll mll::MOD = (ll)(1e9 + 7);// 998244353ll;\n\n\nvll W;\nvvll dp;\n\nll solve(ll l, ll r) {\n\tif (dp[l][r] >= 0) {\n\t\treturn dp[l][r];\n\t}\n\n\tll ans = 0;\n\n\tif (l >= r) {\n\t\tans = 0;\n\t\tdp[l][r] = ans;\n\t\treturn ans;\n\t}\n\n\tif (l + 1 == r) {\n\t\tans = abs(W[l] - W[r]) <= 1 ? 2 : 0;\n\t\tdp[l][r] = ans;\n\t\treturn ans;\n\t}\n\n\tif (l + 1 <= r - 1) {\n\t\tif (r - l - 1 == solve(l + 1, r - 1)) {\n\t\t\tchmax(ans, solve(l + 1, r - 1) + (abs(W[l] - W[r]) <= 1 ? 2 : 0));\n\t\t}\n\t}\n\n\treps(i, l, r - 1) {\n\t\tchmax(ans, solve(l, i) + solve(i + 1, r));\n\t}\n\t\n\tdp[l][r] = ans;\n\n\treturn ans;\n}\n\nint main() {\n\twhile (true) {\n\t\tll N;\n\t\tcin >> N;\n\t\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tW.resize(N);\n\t\n\t\trep(i, N) {\n\t\t\tcin >> W[i];\n\t\t}\n\t\n\t\tif (N <= 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp.resize(N);\n\t\trep(i, N) {\n\t\t\tdp[i].resize(N);\n\t\t\trep(j, N) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\n\t\tll result = solve(0, N - 1);\n\t\n\t\tcout << result << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define ALL(x)    (x).begin(),(x).end()\n#define UNIQ(c)   (c).erase(unique(ALL((c))), end((c)))\n#define mp        make_pair\n#define eb        emplace_back\ntypedef pair<LL, LL> P;\ntypedef pair<P, P> PP;\n\nint N;\nint W[333];\n\nbool dp[333][333];\nint dp2[333];\nvoid solve() {\n\tfor (int i = 0; i < N; i++)cin >> W[i];\n\tfor (int i = 0; i < 333; i++)for (int j = 0; j < 333; j++)dp[i][j] = 0;\n\tfor (int i = 0; i < 333; i++) dp2[i] = 0;\n\tfor (int i = 0; i < N; i++)dp[i][i] = true;\n\n\tfor (int len = 2; len <= N; len++) {\n\t\tfor (int i = 0; i + len <= N; i++) {\n\t\t\tint j = i + len;\n\t\t\tif (abs(W[i] - W[j - 1]) <= 1)dp[i][j] |= dp[i + 1][j - 1];\n\t\t\tfor (int k = i + 1; k < j; k++)dp[i][j] |= dp[i][k] & dp[k][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tdp2[i + 1] = max(dp2[i + 1], dp2[i]);\n\t\tfor (int j = i + 1; j <= N; j++)if (dp[i][j])dp2[j] = max(dp2[j], dp2[i] + j - i);\n\t}\n\tcout << dp2[N] << endl;\n}\nint main() {\n\twhile (cin >> N, N)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 998244353\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\nint dp[310][310];\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //-------------------------------\n    int n;cin>>n;\n    while(n){\n        V<int>a(n);\n        for(int i=0;i<n;i++)cin>>a[i];\n        int ans=0;\n        memset(dp,0,sizeof(dp));\n        for(int len=2;len<=n;len++){\n            for(int i=0;i<n;i++){\n                int j=i+len-1;\n                if(j>=n)continue;\n                if(dp[i+1][j-1]==len-2){\n                    if(abs(a[i]-a[j])<=1){\n                        chmax(dp[i][j],len);\n                    }\n                }\n                for(int k=i;k<j;k++){\n                    chmax(dp[i][j],dp[i][k]+dp[k+1][j]);\n                }\n            }\n        }\n\n        cout<<dp[0][n-1]<<endl;\n        cin>>n;\n    }\n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1611&lang=jp\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    while(cin >> n, n)\n    {\n        int dp[305][305] = {};\n        vector<int> w(n);\n\n        for(auto& _w : w)\n        {\n            cin >> _w;\n        }\n\n        for(int b = 2; b <= n; b++)\n        for(int l = 0; l < n; l++)\n        {\n            int r = l + b - 1;\n                if( r >= n )break;\n\n                if( abs(w[l] - w[r]) <= 1 && dp[l + 1][r - 1] == r - l - 1)\n                {\n                    dp[l][r] = r - l + 1;\n                }\n                else\n                for(int k = l; k < r; k++)                \n                {\n                    dp[l][r] = max( dp[l][r], dp[l][k] + dp[k + 1][r] );\n                }\n        }\n        cout << dp[0][n - 1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint W[305];\nint dp[305][305];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0){break;}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&W[i]);\n\t\t}\n\t\tfor(int i=0;i<305;i++){\n\t\t\tfor(int j=0;j<305;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=N-2;i++){\n\t\t\tif(abs(W[i]-W[i+1])<=1){dp[i][1]=2;}\n\t\t}\n\t\tfor(int j=3;j<=N-1;j+=2){\n\t\t\tfor(int i=0;i+j<N;i++){\n\t\t\t\t//[i,i+j]\n\t\t\t\tif(abs(W[i+j-1]-W[i+j])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][j-2]+2);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][j-2]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+1])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+2][j-2]+2);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+2][j-2]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+j])<=1&&dp[i+1][j-2]==j-1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],j+1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=150;i>=0;i-=2){\n\t\tprintf(\"%d\\n\",dp[i][299-i]);\n\t\t}*/\n\t\tif(N%2==0){printf(\"%d\\n\",dp[0][N-1]);}\n\t\telse {printf(\"%d\\n\",max(dp[0][N-2],dp[1][N-2]));}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(int I = int(A); I < int(B); ++I)\n#define FORR(I,A,B) for(int I = int((B)-1); I >= int(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //ai>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //ai>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\n\n\n\nint main(){\n\tint N;\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N==0)break;\n\t\tvector<int> w(N+1);\n\t\tFOR(i,1,N+1)cin >> w[i];\n\t\tbool dp[N+1][N+1]={};\n\t\tint ans = 0;\n\t\tfor(int i=2;i<N+1;i+=2){//i:幅\n\t\t\tFOR(j,1,N+1){//j:開始位置\n\t\t\t\t// [j,j+i-1]\n\t\t\t\tif(j+i-1>N)continue;\n\t\t\t\tif( (j+1 > j+i-2) && abs(w[j]-w[j+i-1])<=1){\n\t\t\t\t\tdp[j][j+i-1]=true;\n\t\t\t\t\tans = max(ans,i);\n\t\t\t\t}else if(dp[j+1][j+i-2] && abs(w[j]-w[j+i-1])<=1){\n\t\t\t\t\tdp[j][j+i-1]=true;\n\t\t\t\t\tans = max(ans,i);\n\t\t\t\t}\n\t\t\t\tfor(int k=2;k<=i-2;k+=2){\n\t\t\t\t\tif(dp[j][j+k-1]&&dp[j+k][j+i-1]){\n\t\t\t\t\t\tdp[j][j+i-1]=true;\n\t\t\t\t\t\tans = max(ans,i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dpa[N+1][N+1]={};\n\t\tFOR(i,1,N)if(dp[i][i+1])dpa[i][i+1]=2;\n\t\tFOR(i,3,N+1){//幅\n\t\t\tFOR(j,1,N+1){//開始\n\t\t\t\tif(j+i-1>N)continue;\n\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\tdpa[j][j+i-1] = max(dpa[j][j+k-1]+dpa[j+k][j+i-1],dpa[j][j+i-1]);\n\t\t\t\t\tif(dp[j][j+i-1])dpa[j][j+i-1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dpa[1][N] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nint W[333];\n\nbool dp[333][333];\nint dp2[333];\nvoid solve(){\n    rep(i,N)cin>>W[i];\n    memset(dp,0,sizeof(dp));\n    rep(i,N)dp[i][i]=true;\n\n    for(int len=2;len<=N;len++){\n        for(int i=0;i+len<=N;i++){\n            int j=i+len;\n            if(abs(W[i]-W[j-1])<=1)dp[i][j]|=dp[i+1][j-1];\n            for(int k=i+1;k<j;k++)dp[i][j]|=dp[i][k]&dp[k][j];\n        }\n    }\n    memset(dp2,0,sizeof(dp2));\n    for(int i=0;i<N;i++){\n        chmax(dp2[i+1],dp2[i]);\n        for(int j=i+1;j<=N;j++)if(dp[i][j])chmax(dp2[j],dp2[i]+j-i);\n    }\n    cout<<dp2[N]<<endl;\n}\nsigned main(){\n    while(cin>>N,N)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<int>as;\nbool ok(int a,int b){\n  return abs(as[a]-as[b])<=1;\n}\n\nint main() {\n  while(1){\n    \n    int N;cin>>N;\n    if(!N)break;\n    as.resize(N);\n    vector<vector<int>>dp(N+1,vector<int>(N+1,-100000));\n    for(int i=0;i<N;++i){\n      int a;cin>>a;as[i]=a;\n    }\n    for(int i=0;i<=N;++i){\n      dp[i][i]=0;\n    }\n    for(int t=2;t<=N;++t){\n      for(int l=0;l<=N-t;++l){\n\tconst int r=l+t;\n\tdp[l][r]=max(dp[l+1][r],dp[l][r-1]);\n\tif(ok(l,l+1))dp[l][r]=max(dp[l+2][r]+2,dp[l][r]);\n\tif(ok(r-2,r-1))dp[l][r]=max(dp[l][r-2]+2,dp[l][r]);\n\tif(ok(l,r-1)){\n\t  if(dp[l+1][r-1]==(r-l-2)){\n\t    dp[l][r]=max(dp[l+1][r-1]+2,dp[l][r]);\n\t  }\n\t}\n\tfor(int m=l+1;m<=r-1;++m){\n\t  dp[l][r]=max(dp[l][m]+dp[m][r],dp[l][r]);\n\t}\n      } \n    }\n\n    int ans=dp[0][N];\n    ans=max(0,ans);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint W[305];\nint dp[305][305];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0){break;}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&W[i]);\n\t\t}\n\t\tfor(int i=0;i<305;i++){\n\t\t\tfor(int j=0;j<305;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=N-2;i++){\n\t\t\tif(abs(W[i]-W[i+1])<=1){dp[i][2]=2;}\n\t\t}\n\t\tfor(int j=3;j<=N;j++){\n\t\t\tfor(int i=0;i+j<=N;i++){\n\t\t\t\t//[i,i+j)\n\t\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\t\tdp[i][j]=max(dp[i][k]+dp[i+k][j-k],dp[i][j]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+j-1])<=1&&dp[i+1][j-2]==j-2){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-2]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int j=0;j<12;j++){\n\t\t\tfor(int i=0;i+j<=12;i++){\n\t\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t/*\n\t\tfor(int i=150;i>=0;i-=2){\n\t\tprintf(\"%d\\n\",dp[i][299-i]);\n\t\t}*/\n\t\tprintf(\"%d\\n\",dp[0][N]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repi(i, a, b) for (int i = (a); i < int(b); i++)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ull << (b))\n\nusing namespace std;\nusing i32 = int;\nusing i64 = long long;\nusing f64 = double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vf64 = vector<f64>;\nusing vstr = vector<string>;\n\ntemplate<typename T, typename S> void amax(T &x, S y) { if (x < y) x = y; }\ntemplate<typename T, typename S> void amin(T &x, S y) { if (y < x) x = y; }\n\nint W[300], dp[300][300];\n\nint rec(int l, int r) {\n  if (l + 1 >= r) return 0;\n  if (~dp[l][r]) return dp[l][r];\n  if (abs(W[l] - W[r - 1]) <= 1 && rec(l + 1, r - 1) == r - l - 2) {\n    return dp[l][r] = r - l;\n  }\n  int ret = 0;\n  repi(m, l + 1, r) {\n    ret = max(ret, rec(l, m) + rec(m, r));\n  }\n  return dp[l][r] = ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(16);\n  while (true) {\n    int N;\n    cin >> N;\n    if (!N) break;\n    rep(i, N) cin >> W[i];\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, N) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define at(x,i) get<i>(x);\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nint main(){\n    while(true){\n        ll n;cin >> n;\n        if(!n)break;\n        vl v(n);\n        rep(i,n)cin >> v[i];\n        vvl dp(n,vl(n,0));\n        rep(j,n){\n            perl(i,j+1,0){\n                if(j-i==0)continue;\n                if(j-i==1){\n                    if(abs(v[i]-v[j])<=1)dp[i][j]=2;\n                    continue;\n                }\n                if(dp[i+1][j-1]==j-i-1&&abs(v[i]-v[j])<=1)dp[i][j]=dp[i+1][j-1]+2;\n                rep(k,j-i){\n                    chmax(dp[i][j],dp[i][i+k]+dp[i+k+1][j]);\n                }\n            }\n        }\n        cout << dp[0][n-1] <<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> iv; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define mp make_pair\n#define pb push_back\n#define MAX 300\n//This is DP.\n\nint W[MAX];\nint dp[MAX+10][MAX+10];\nint n, M;\nint main()\n{\n  while(true)\n    {\n      scanf(\"%d\", &n);\n      if(n==0)break;\n\n      \n      rep(i,n)\n\t{\n\t  scanf(\"%d\", &W[i]);\n\t}\n      \n      memset(dp, 0, sizeof(dp));\n  \n      rep(k,n+1)\n\t{\n\t  if(k==0)continue;\n\t  rep(i,n)\n\t    {\n\t      if(i + k > n)continue;\n\t      M=0;\n\t      if(dp[i+1][i+k-2]==k-2)\n\t\t{\n\t\t  if(abs(W[i]-W[i+k-1])<=1)\n\t\t    {\n\t\t      dp[i][i+k-1]=k;\n\t\t      continue;\n\t\t    }\n\t\t}\n\t      repi(j,i,i+k-1)\n\t\t {\n\t\t   M=max(M,dp[i][j]+dp[j+1][i+k-1]);\n\t\t }\n\t       \n\t      dp[i][i+k-1]=M;\n\t    }\n\t}\n      /*rep(i,n)\n\t{\n\t  rep(j,n)\n\t    {\n\t      printf(\"%d \",dp[i][j]);\n\t    }\n\t  printf(\"\\n\");\n\t  }*/\n      printf(\"%d\\n\", dp[0][n-1]);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nbool used[310][310];\nbool dp[310][310];\nvi w;\n\nint dp2[310][310];\ntemplate<typename T> T chmax(T& a, const T& b){return a = max(a, b);}\ntemplate<typename T> T chmin(T& a, const T& b){return a = min(a, b);}\n//[l, r) de tatakeruka\nbool calc(int l, int r) {\n\tif(r - l <= 1) return false;\n\tif(used[l][r]) return dp[l][r];\n\tused[l][r] = true;\n\tif(r - l == 2) {\n\t\treturn dp[l][r] = (abs(w[l] - w[r-1]) <= 1);\n\t}\n\tfor(int m = l + 1; m < r; m++) {\n\t\tbool f = true;\n\t\tf &= calc(l, m);\n\t\tf &= calc(m, r);\n\t\tdp[l][r] |= f;\n\t}\n\tif(abs(w[l]-w[r-1]) <= 1) dp[l][r] |= calc(l+1, r-1);\n\treturn dp[l][r];\n}\n\nint calc2(int l, int r) {\n\tif(dp2[l][r] != -1) return dp2[l][r];\n\tif(r - l <= 1) return dp2[l][r] = 0;\n\tif(dp[l][r]) return dp2[l][r] = r - l;\n\tint ret = 0;\n\tfor(int m = l + 1; m < r; m++) {\n\t\tchmax(ret, calc2(l, m)+calc2(m, r));\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n) {\n\t\tw.clear();\n\t\tw.resize(n);\n\t\trep(i, n) cin >> w[i];\n\t\trep(i, 310) rep(j, 310) dp[i][j] = used[i][j] = false, dp2[i][j] = -1;\n\t\tREP(r, 1, n+1) rep(l, r) calc(l, r);\n\t\tcout << calc2(0, n) << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep1(i,n) for(int i=1;i<=int(n);++i)\n\nint dfs(int v, vector<set<int>> &g, vector<int> &dp){\n    if(v == 0) return 0;\n    if(dp[v]) return dp[v];\n    int res = dfs(v-1,g,dp);\n    for(int to : g[v]){\n        res = max(res,v-to + dfs(to,g,dp));\n    }\n    return dp[v] = res;\n}\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        vector<int> w(n+1);\n        rep1(i,n) cin>>w[i];\n        w[0] = -1;\n\n        // i番目が消える時に右側に会わせられるブロックのindexの集合\n        vector<set<int>> g(n+1);\n        rep1(i,n){\n            if(abs(w[i]-w[i-1]) <= 1){\n                g[i] = g[i-2];\n                g[i].insert(i-2);\n            }\n            for(int l : g[i-1]){\n                if(abs(w[i]-w[l]) <= 1){\n                    for(int ll : g[l-1]){\n                        g[i].insert(ll);\n                    }\n                    g[i].insert(l-1);\n                }\n            }\n        }\n        vector<int> dp(n+1);\n        cout<<dfs(n,g,dp)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nmain(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<n;i+=2)\n      for(int j=0;j<n-i;j++){\n        dp[j][j+i]=dp[j+1][j+i-1];\n        for(int k=1;k<=i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=max(dp[j][j+i],i+1);\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define ALL(a) (a).begin(), (a).end()\n\ntemplate <class T>\ninline bool chmin(T &a, const T b){\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\ninline bool chmax(T &a, const T b){\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing DoP = pair<double, double>;\nusing edge = struct { int to; double cost;}; // edge x = {to, cost}\n\nconst int di[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};\nconst int INF = 1<<29;\nconst ll INF64 = 1ll << 45;\nconst int mod = 1000000007;\n\nstruct mint\n{\n  ll x; // typedef long long ll;\n  mint(ll x = 0) : x((x % mod + mod) % mod) {}\n  mint operator-() const { return mint(-x); }\n  mint &operator+=(const mint a)\n  {\n    if ((x += a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator-=(const mint a)\n  {\n    if ((x += mod - a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator*=(const mint a)\n  {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const\n  {\n    mint res(*this);\n    return res += a;\n  }\n  mint operator-(const mint a) const\n  {\n    mint res(*this);\n    return res -= a;\n  }\n  mint operator*(const mint a) const\n  {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const\n  {\n    if (!t)\n      return 1;\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1)\n      a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const\n  {\n    return pow(mod - 2);\n  }\n  mint &operator/=(const mint a)\n  {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const\n  {\n    mint res(*this);\n    return res /= a;\n  }\n};\n// h(n, r) = c(n+r-1, r)\nstruct combination\n{\n  vector<mint> fact, ifact;\n  combination(int n) : fact(n + 1), ifact(n + 1)\n  {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i)\n      ifact[i - 1] = ifact[i] * i;\n  }\n  mint operator()(int n, int k)\n  {\n    if (k < 0 || k > n)\n      return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n  }\n};\n\nint n;\nvector<int> w;\nvector<vector<int>> dp;\n\nint rec(int l = 0, int r = n) {\n  if(r-l <= 1) return 0;\n  if(r-l == 2) {\n    if(abs(w[l]-w[l+1]) <= 1) {\n      return 2;\n    }\n    else {\n      return 0;\n    }\n  }\n  if(dp[l][r] != -1) return dp[l][r];\n\n  if(abs(w[l]-w[r-1]) <= 1 && rec(l+1, r-1) == r-l-2) chmax(dp[l][r], r-l);\n  for(int i = l+1; i <= r-1; ++i) chmax(dp[l][r], rec(l, i)+rec(i, r));\n  return dp[l][r];\n}\n\nint main(){\n  vector<int> ans;\n  while(true) {\n    cin >> n;\n    if(n == 0) break;\n    w.resize(n);\n    rep(i, n) cin >> w[i];\n    dp.assign(n+2, vector<int>(n+2, -1));\n    ans.push_back(rec());\n  }\n  for(auto x : ans) cout << x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * daruma_otoshi_2016D.cpp\n * ICPC2016 Domestic D\n *\n *  Created on: 2017/07/13\n *      Author: LitMc\n */\n\n//#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\n#define EPS = 1e-14;\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n  for (size_t i = 0; i < v.size(); ++i) {\n    out << v[i] << endl;\n  }\n  return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n  out << \"[\";\n  size_t last = v.size() - 1;\n  for (size_t i = 0; i < v.size(); ++i) {\n    out << v[i];\n    if (i != last) {\n      out << \",\";\n    }\n  }\n  out << \"]\";\n  return out;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1, T2>& p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntypedef pair<int, int> P;\nbool cmp(const P &p1, const P &p2) {\n  if (p1.first == p2.first) {\n    return p1.second > p2.second;\n  } else {\n    return p1.first < p2.first;\n  }\n}\n\nstatic const int MAX_N = 310;\nint n;\nbool can[MAX_N][MAX_N];\nint dp[MAX_N][MAX_N];\n//can[i][j]: w[i]??????w[j]?????§???????????????\n//can[i][j] = 1 (if |w[i]-w[j]| <= 1)\n//can[i][j] = 1 (if can[i][k] && can[k+1][j])\n//dp[i][j]: [i, j]???????????§????????????????????§?????°\n\nvector<int> w;\nvoid init(int n) {\n  fill(all(w), 0);\n  memset(can, 0, sizeof(can));\n  memset(dp, 0, sizeof(dp));\n}\n\nbool near(int i, int j) {\n  return abs(w[i] - w[j]) <= 1;\n}\n\nvoid debug_can() {\n  printf(\"w[ i]: \");\n  rep(i,0,n)\n  {\n    printf(\"%2d \", i);\n  }\n  printf(\"\\n\");\n  rep(i,0,n)\n  {\n    printf(\"w[%2d]: \", i);\n    rep(j,0,n)\n    {\n      printf(\"%2d \", can[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid doDP_can() {\n  rep(i,0,n)\n  {\n    can[i][i] = false;\n  }\n  for (int i = 0; i + 1 < n; ++i) {\n    if (near(i, i + 1)) {\n      can[i][i + 1] = true;\n    }\n  }\n  for (int width = 3; width <= n; ++width) {\n    for (int i = 0, j = i + width - 1; j < n; ++i, ++j) {\n      if (near(i, j) && can[i + 1][j - 1]) {\n        can[i][j] = true;\n        continue;\n      }\n      for (int k = i; k + 1 <= j; ++k) {\n        if (can[i][k] && can[k + 1][j]) {\n          can[i][j] = true;\n          break;\n        }\n      }\n    }\n  }\n//  debug_can();\n}\n\n//dp[i][j]: [i, j]???????????§????????????????????§?????°\n//dp[i][j] = j - i + 1 (if can[i][j]==true)\n//dp[i][j] = max_k (dp[i][k] + dp[k+1][j])\n//????????????[i, j]????????????????±?????????¨???, ????????????????????????????????????????????????????????£???????????°DP??§??????\n//width = 2, 3, ... n\n//???width?????????[i, j]\nvoid doDP_count() {\n  for (int width = 2; width <= n; ++width) {\n    for (int i = 0, j = i + width - 1; j < n; ++i, ++j) {\n      if (can[i][j]) {\n        dp[i][j] = j - i + 1;\n        continue;\n      }\n      int maxi = 0;\n      for (int k = i; k + 1 <= j; ++k) {\n        maxi = max(maxi, dp[i][k] + dp[k + 1][j]);\n      }\n      dp[i][j] = maxi;\n    }\n  }\n}\n\nvoid solve() {\n  while (cin >> n, n) {\n    w = vector<int>(n);\n    init(n);\n    rep(i,0,n)\n    {\n      cin >> w[i];\n    }\n    doDP_can();\n    doDP_count();\n    cout << dp[0][n - 1] << endl;\n  }\n}\n\nint main() {\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nsigned main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tint w[310];\n\t\tfor(int i = 0;i < n;i++) cin >> w[i];\n\t\tint dp[310][310] = {};\n\t\tfor(int i = 2;i <= n;i++){\n\t\t\tfor(int j = 0;j < n - i + 1;j++){\n\t\t\t\tif(dp[j + 1][j + i - 1] == i - 2 && abs(w[j] - w[j + i - 1]) <= 1){\n\t\t\t\t\tdp[j][j + i] = i;\n\t\t\t\t}\n\t\t\t\tfor(int k = j + 1;k < j + i;k++){\n\t\t\t\t\tdp[j][j + i] = max(dp[j][j + i],dp[j][k] + dp[k][j + i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, a[300];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\trep(i,n) cin >> a[i];\n\t\t// dp[l][r]: 区間[l,r]から取り除けるブロックの最大個数\n\t\tint dp[303][303] = {};\n\t\trepst(w,1,n) rep(l,n) {\n\t\t\tint r = l+w;\n\t\t\tif (n<=r) break;\n\t\t\tif (dp[l+1][r-1]==w-1 && abs(a[l]-a[r])<=1) dp[l][r] = w+1;\n\t\t\treps(i,l,r) chmax(dp[l][r], dp[l][i]+dp[i+1][r]);\n\t\t}\n\t\tcout << dp[0][n-1] << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#include \"../utils.cpp\"\n#endif\n#include <bits/stdc++.h>\n/*\nProblem\n\n\nCategory\nDP\n \nURL:\n\n\n考察:\n\n\n\nDate: 2020/06/20\n// 1926\n// 1935\n// 1950\n\n*/\n \n\nusing namespace std;\nusing ll = int64_t;\n#define int int64_t\n#define INF 10e9\n\n \n/* ==== declarations ====== */\n// functions\nvoid solve();\nvoid getInput();\n \n// global variables\nint N;\nvector<int> W;\nvector<vector<int>> dp;\nvector<vector<int>> memo;\n\n/* ======================== */\n\n\nvoid getInput() {\n    cin>>N;\n    if (N==0) {\n        exit(0);\n    }\n\n    W = vector<int>(N);\n    memo = vector<vector<int>>(N, vector<int>(N, INF));\n    for(int i=0; i<N; ++i) {\n        cin>>W[i];\n    }\n}\n\nint getMemo(int s, int t) {\n    assert(s >=0 and t>= 0 and s<N and t<N);\n    if (memo[s][t] != INF) {\n        return memo[s][t];\n    } else {\n        if (t - s == 0) {\n            memo[s][t] = 1;\n        } else if (t-s == 1) {\n            if (abs(W[t] - W[s]) <= 1) {\n                memo[s][t] = 0;    \n            } else {\n                memo[s][t] = 2;\n            }\n        } else if (t - s >= 2) {\n            int score = getMemo(s, t-1) + 1;\n\n            for(int i=t-1; i >= s; --i) {\n                if (abs(W[t] - W[i]) > 1) continue;\n\n                if (t-i==1 or getMemo(i+1, t-1) == 0) {\n                    if (i-1 < s) {\n                        score = 0;\n                    }\n                    else {\n                        score = min(score, getMemo(s, i-1));\n                    }\n                }\n            }\n            memo[s][t] = score;\n        }\n    }\n    return memo[s][t];\n}\n \n\nvoid solve() {\n    cout<<N - getMemo(0, N-1)<<endl;\n}\n \n \nsigned main(){\n    while(1) {\n        getInput();\n        solve();\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint dp[300][300];//dp[l][r] [l,r]でだるまを落としたときの落とした個数\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\t\n\t\tint da[300];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>da[i];\n\t\tfill(dp[0],dp[300],0);\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint dif=da[i]-da[i-1];\n\t\t\tif(dif<2 && dif>-2)\n\t\t\t\tdp[i-1][i]=2;\n\t\t\telse\n\t\t\t\tdp[i-1][i]=0;\n\t\t}\n\t\t//ここからdp\n\t\tfor(int k=2;k<n;k++)\n\t\t{\n\t\t\tfor(int i=0;i<n-k;i++)\n\t\t\t{\n\t\t\t\t//分割して調べる\n\t\t\t\tfor(int j=i;j<i+k;j++)\n\t\t\t\t{\n\t\t\t\t\t//cerr<<dp[i][j]+dp[j+1][i+k]<<endl;\n\t\t\t\t\tdp[i][i+k]=max(dp[i][i+k],dp[i][j]+dp[j+1][i+k]);\n\t\t\t\t}\n\t\t\t\t//真ん中が全部消える場合も調べる\n\t\t\t\tint dif=da[i]-da[i+k];\n\t\t\t\tif(dp[i+1][i+k-1]==k-1 && dif<2 && dif>-2)\n\t\t\t\t\tdp[i][i+k]=k+1;\n\t\t\t}\n\t\t}\n\t\tcout<<dp[0][n-1]<<endl;\n\t}\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> w;\nbool canTake[301][301];\nint dp[301][301];\n\nint solve(int l, int r){\n    if(l >= r){\n        return 0;\n    }else if(canTake[l][r]){\n        return r - l;\n    }else if(dp[l][r] >= 0){\n        return dp[l][r];\n    }\n\n    int res = max(solve(l + 1, r), solve(l, r - 1));\n    for(int i = l + 1 ; i < r ; ++i){\n        res = max(res, solve(l, i) + solve(i, r));\n    }\n\n    return dp[l][r] = res;\n}\n\nint main(){\n    while(cin >> n, n){\n        w.resize(n);\n        for(int i = 0 ; i < n ; ++i){\n            cin >> w[i];\n        }\n\n        fill(canTake[0], canTake[n + 1], false);\n\n        for(int len = 2 ; len <= n ; len += 2){\n            for(int i = 0 ; i <= n - len ; ++i){\n                for(int j = i + 1 ; j < i + len ; ++j){\n                    if(canTake[i][j] && canTake[j][i + len]){\n                        canTake[i][i + len] = true;\n                    }\n                }\n                if(len == 2 && abs(w[i] - w[i + 1]) <= 1){\n                    canTake[i][i + 2] = true;\n                }\n                if(canTake[i][i + len]){\n                    int l = i - 1, r = i + len;\n                    while(0 <= l && r < n && abs(w[l] - w[r]) <= 1){\n                        canTake[l][r + 1] = true;\n                        --l;\n                        ++r;\n                    }\n                }\n            }\n        }\n\n        fill(dp[0], dp[n + 1], -1);\n\n        int ans = solve(0, n);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nint main(void) {\n  int N;\n  while (cin >> N, N) {\n    vector<int> W(N);\n    for (int i = 0; i < N; i++) cin >> W[i];\n\n    int dp[300][300] = {};\n    for (int l = 0; l + 1 < N; l++) {\n      if (abs(W[l] - W[l+1]) > 1) continue;\n      dp[l][l+1] = 2;\n    }\n\n    for (int d = 3; d <= N; d++) {\n      for (int l = 0; l + d <= N; l++) {\n        int r = l + d - 1;\n        dp[l][r] = dp[l+1][r-1];\n        if (abs(W[l] - W[r]) <= 1 && dp[l+1][r-1] == r - l - 1)\n          dp[l][r] += 2;\n\n        for (int m = l + 1; m <= r - 1; m++) {\n          dp[l][r] = max(dp[l][r], dp[l][m] + dp[m+1][r]);\n        }\n      }\n    }\n\n    cout << dp[0][N-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[100];\nint dp[300][300];\n//int ans[300];\n\nbool C(int lb, int ub) {\n\t//cout << lb << \" \" << ub /*<< dp[lb][ub]*/ << endl;\n\tif (dp[lb][ub] != -1)return dp[lb][ub];\n\tif (ub - lb <= 0)return dp[ub][lb] = 0;\n\telse if (ub - lb == 1) {\n\t\tif (abs(x[lb] - x[ub]) <= 1)return dp[lb][ub] = 1;\n\t}\n\tdp[lb][ub] = 0;\n\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\tdp[lb][ub] |= C(lb + 1, ub - 1);\n\t}\n\tFOR(mid, lb, ub) {\n\t\t//cout << \"!\" << lb << \" \" << mid << endl;\n\t\t//cout << \"!\" << mid << \" \" << ub << endl;\n\t\tbool f = C(lb, mid);\n\t\tf &= C(mid + 1, ub);\n\t\tdp[lb][ub] |= f;\n\t}\n\treturn dp[lb][ub];\n}\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 300)rep(j, 300) {\n\t\t\tdp[i][j] = -1;\n\t\t\t//ans[i] = 0;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\t//C(0, n - 1);\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << dp[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tint ans = 0;\n\t\trep(i, n) {\n\t\t\t//if (i >= 1)ans[i] = ans[i - 1];\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tnum = max(num, j - i + 1);\n\t\t\t\t\tpos = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += num;\n\t\t\ti = pos;\n\t\t}\n\t\t//rep(i, n) {\n\t\t//\tFOR(j, i, n) {\n\t\t//\t\tcout << i << \" \" << j << \"  \" << ans[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dp[310][310];\nint n;\nvector<int> node;\n\nint dfs(int l,int r)\n{\n\tif(l > r)return 0;\n\tif(l == r)return 0;\n\tif(dp[l][r] != -1)return dp[l][r];\n\tif(r - l == 1)return (abs(node[l]-node[r])<2)?2:0;\n\t\n\tint ret = 0;\n\t\n\tif(dfs(l+1,r-1)==r-l-1&&(abs(node[l]-node[r])<2))\n\t{\n\t\treturn r-l+1;\n\t}\n\t\n\tfor(int i=0;i < r-l;i++)\n\t{\n\t\tret = max(ret,dfs(l,l+i)+dfs(l+i+1,r));\n\t}\n\t\n\treturn dp[l][r] = ret;\n}\n\nint main()\n{\n\twhile(cin >> n,n)\n\t{\n\t\t\n\t\tREP(i,310)REP(j,310)dp[i][j] = -1;\n\t\tnode.clear();\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tint tmp;cin >> tmp;\n\t\t\tnode.PB(tmp);\n\t\t}\n\t\t\n\t\tcout << dfs(0,n-1) << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n/*\n?????????\n*/\n\nconstexpr int NUM = 300;\nint w[NUM] = { 0 };\nbool dp[NUM][NUM] = { {false} };\nint ddp[NUM+1] = { 0 };\n\n//a~a+1??¨a+2~b?????\\??\\??\\???a~d??¨d+1~r?????\\??\\??\\???a~b-2??¨b-1~b????????????????????¨???????????????\nbool isDroped(int a, int b) {\n\tif (b - a <= 1) return false;\n\tfor (int i = a + 1; i < b; i += 2) {\n\t\tif (dp[a][i] && dp[i + 1][b]) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\twhile (std::cin >> n && n) {\n\t\tstd::memset(dp, 0, sizeof(dp));\n\t\tfor (int i = 0; i < n; i++) std::cin >> w[i];\n\n\t\tfor (int d = 1; d < n; d += 2) { //?????¨?????????\n\t\t\tfor (int i = 0; i < n - d; i++) { //?????¨?????´???\n\t\t\t\tif ((d == 1 || dp[i + 1][i + d - 1]) && std::abs(w[i] - w[i + d]) <= 1){\n\t\t\t\t\tdp[i][i + d] = true; //???????????????????????¨????????¨??????\n\t\t\t\t}\n\t\t\t\tif (isDroped(i, i + d)) {\n\t\t\t\t\tdp[i][i + d] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::memset(ddp, 0, sizeof(ddp));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tddp[i + 1] = std::max(ddp[i + 1], ddp[i]);\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tddp[j + 1] = std::max(ddp[j + 1], ddp[i] + j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << ddp[n] << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> mem;\nvector<int> bs;\n\nint rec(int l, int r) {\n  if(mem[l][r] >= 0) return mem[l][r];\n  if(l >= r) {\n    mem[l][r] = 0;\n  } else {\n    int d = r - l + 1;\n    if(rec(l+1, r-1) == d - 2 && abs(bs[l] - bs[r]) <= 1) {\n      mem[l][r] = d;\n    } else {\n      int ans = 0;\n      for(int k = l; k < r; k++) {\n        ans = max(ans, rec(l, k) + rec(k+1, r));\n      }\n      mem[l][r] = ans;\n    }\n  }\n  return mem[l][r];\n}\n\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    int m;\n    cin >> m;\n    if(m == 0) break;\n    bs.clear();\n    for(int i = 0; i < m; i++) {\n      int b;\n      cin >> b;\n      bs.push_back(b);\n    }\n    mem = vector<vector<int>>(m, vector<int>(m, -1));\n    int ans = rec(0, m-1);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <stdio.h>\nusing namespace std;\nint func(vector<int> w){\n    int s = w.size();\n    if(s>1){\n        int temp;\n        int min = s;\n        for(int i=0;i<s-1;i++){\n            vector<int> remain;\n            for(int j=0;j<s;j++){\n                if(j==i){j+=2;}\n                if(j>=s)break;\n                remain.push_back(w[j]);\n            }\n            if(abs(w[i]-w[i+1])<2){\n                temp = func(remain);\n                min = min > temp ? temp : min;\n            }\n            if(min==0)break;\n        }\n        return min;\n    } else {\n        return s;\n    }\n}\nvoid q_daruma(int n){\n    vector<int> w;\n    int t;\n    for(int i=0;i<n;i++){cin>>t;w.push_back(t);}\n    cout << w.size()-func(w) << \"\\n\";\n}\nint main(){\n    int n;\n    while(cin >> n, n!=0){\n        q_daruma(n);\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using ull = unsigned long long;\n//#define int ll\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing vl = vector<ll>; using vvl = vector<vl>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<V<T>>;\n#define fi first\n#define se second\n#define maxs(x,y) (x=max(x,y))\n#define mins(x,y) (x=min(x,y))\nusing pii = pair<int,int>; using pll = pair<ll,ll>;\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define RFOR(i,a,b) for(ll i = (ll)(b)-1;i >= a;--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define rALL(obj) (obj).rbegin(), (obj).rend()\n#define eb(val) emplace_back(val)\nconst double PI = acos(-1), EPS = 1e-10;\nconst ll MOD = 1e9+7;\ntemplate<class T> istream& operator>>(istream &is,vector<T> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> istream& operator>>(istream &is,vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &st){\n  for(size_t i=0;i<st.size();++i){\n    if(i==st.size()-1) os << st[i];\n    else os << st[i] << \" \";\n  }\n  return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i){\n    os << st[i];\n    if(i!=st.size()-1) os << endl;\n  }\n  return os;\n}\nint N;\nvvi dp;\nvi w;\nint solve(){\n  for(int W = 2; W <= N; W++){ //区間の大きさ\n  for(int l = 0; l < N; l++){\n    int r = l + W;\n    if(r > N) continue;\n    if(dp[l+1][r-1]==W-2 && abs(w[l]-w[r-1]) <= 1) dp[l][r] = W; //遷移1\n    for(int m = l+1; m < r;m++) //遷移2\n    dp[l][r] = max(dp[l][r],dp[l][m]+dp[m][r]);\n  }\n}\nreturn dp[0][N];\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> N,N){\n    dp.assign(N+1,vi(N+1,0));\n    w.resize(N);\n    cin >> w;\n    cout << solve() << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#include <boost/multiprecision/cpp_int.hpp>\n//using multiInt = boost::multiprecision::cpp_int;\n\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconst int MOD_TYPE = 1;\nconst ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\nconst int INF = (int)1e9;\nconst ll LINF = (ll)4e18;\nconst ld DINF = 1e12;\nconst ld PI = acos(-1.0);\nconst ld EPS = 1e-11;\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << endl\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << endl\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << endl\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << endl;\n\nvector<int> Dx = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nvector<int> Dy = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\nll n;\nll w[310];\nll dp[310][310]; //[l,r)で取り除けるブロック\n\nll calc(int l, int r)\n{\n  if (dp[l][r] != -1)\n    return dp[l][r];\n  if (r - l <= 1)\n    return 0;\n\n  if (abs(w[l] - w[r - 1]) <= 1 && calc(l + 1, r - 1) == r - l - 2)\n  {\n    return dp[l][r] = r - l;\n  }\n\n  ll Max = 0;\n  for (int i = l + 1; i <= r - 1; ++i)\n  {\n    Max = max(Max, calc(l, i) + calc(i, r));\n  }\n  return dp[l][r] = Max;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(30) << setiosflags(ios::fixed);\n  while (1)\n  {\n    cin >> n;\n    if (n == 0)\n      return 0;\n    rep(i, n) cin >> w[i];\n    rep(i, n + 1) rep(j, n + 1) dp[i][j] = -1;\n    cout << calc(0, n) << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<deque>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dp[310][310];\n\nint main()\n{\n\tint n;\n\t\n\twhile(cin >> n,n)\n\t{\n\t\tREP(i,310)REP(j,310)dp[i][j] = 0;\n\t\t\n\t\tvector<int> v(n);\n\t\tREP(i,n)cin >> v[i];\n\t\t\n\t\tREP(i,n-1)if(abs(v[i]-v[i+1]) < 2)dp[i][i+1] = 2;\n\t\t\n\t\tfor(int k = 2;k < n;k++)\n\t\t{\n\t\t\tfor(int i = 0;i+k < n;i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0;j < k;j++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][i+k] = max(dp[i][i+k],dp[i][i+j]+dp[i+j+1][i+k]);\n\t\t\t\t}\n\t\t\t\tif(dp[i+1][i+k-1] == k-1)\n\t\t\t\t{\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\tif(abs(v[i]-v[i+k])<2)tmp = 2;\n\t\t\t\t\tdp[i][i+k] = max(dp[i][i+k],k-1+tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dp[0][n-1] << endl;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n \nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);++(i))\n \nint main()\n{\n    int n;\n    while(cin >> n , n)\n    {\n        vector<int> w(n,0);\n        for(int i = 0;i < n;i++)\n        {\n            cin >> w[i];\n        }\n         \n        vector<vector<int>> dp(n + 1,vector<int>(n + 1,0));\n \n        for(int W = 2;W <= n;W++)\n        {\n            //left\n            for(int l = 0;l < n;l++)\n            {\n                int r = l + W;\n                if(r > n) continue;\n \n                if(dp[l + 1][r - 1] == W - 2 && abs(w[l] - w[r - 1]) <= 1)\n                    dp[l][r] = W;\n \n                for(int mid = l;mid <= r;mid++)\n                {\n                    dp[l][r] = max(dp[l][r] , dp[l][mid] + dp[mid][r]);\n                }\n \n            }\n \n        }\n \n        cout << dp[0][n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nint x[100];\nbool dp[1000][1000];\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\trep(i, 1000)rep(j, 1000) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t\trep(i, n)cin >> x[i];\n\t\tfor (int i = 1; i < n; i += 2) {\n\t\t\tfor (int j = 0; j + i < n; j++) {\n\t\t\t\tint lb = j, ub = j + i;\n\t\t\t\tif (abs(x[lb] - x[ub]) <= 1) {\n\t\t\t\t\tif (i == 1)dp[lb][ub] = 1;\n\t\t\t\t\telse dp[lb][ub] |= dp[lb + 1][ub - 1];\n\t\t\t\t}\n\t\t\t\tFOR(mid, lb + 1, ub - 1) {\n\t\t\t\t\tdp[lb][ub] |= dp[lb][mid] && dp[mid + 1][ub];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, n) {\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\tfor (int j = i + 1; j < n; j += 2) {\n\t\t\t\tif (dp[i][j]) {\n\t\t\t\t\tnum = max(num, j - i + 1);\n\t\t\t\t\tpos = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += num;\n\t\t\ti = pos;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; ++i)\n#define FOR(i,n,m) for(long long i=n; i<m; ++i)\n#define DUMP(n,a) for(long long dump=0; dump<n; ++dump) { cout<<a[dump]; if(dump!=n-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nvector<vector<ll>> memo;\nvector<ll> w;\nll dfs(ll l, ll r) {\n\tif(memo[l][r]!=INF) return memo[l][r];\n\tif(r-l+1<2) return memo[l][r]=0;\n\tif(r-l+1==2) {\n\t\tif(abs(w[l]-w[r])<=1) return memo[l][r]=2;\n\t\telse return memo[l][r]=0;\n\t}\n\tll ret=0;\n\tif(dfs(l+1,r-1)==r-l-1) {\n\t\tif(abs(w[l]-w[r])<=1) return memo[l][r]=r-l+1;\n\t\telse ret=max(ret,r-l-1);\n\t}\n\tFOR(i,l,r) ret=max(ret,dfs(l,i)+dfs(i+1,r));\n\treturn memo[l][r]=ret;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tw.resize(0);\n\t\tw.resize(n);\n\t\tREP(i,n) cin>>w[i];\n\t\tmemo.resize(0);\n\t\tmemo.resize(n);\n\t\tREP(i,n) {\n\t\t\tmemo[i].resize(n);\n\t\t\tREP(j,n) memo[i][j]=INF;\n\t\t}\n\t\tcout<<dfs(0,n-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1611&lang=jp\n//ダルマ落とし\n#include <bits/stdc++.h>\n#if LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\nusing namespace std;\nusing ll=long long;\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\ntemplate<class T>bool chmax(T &a, const T &b) {if (a<b) { a=b; return 1; } return 0;}\ntemplate<class T>bool chmin(T &a, const T &b) {if (b<a) { a=b; return 1; } return 0;}\n#if 0\nll solve(){\n  ll n; cin>>n;\n  if(n==0) return -1;\n  vector<ll> wn(n);\n  for(auto&& w:wn) cin>>w;\n\n  auto dfs = [&](auto&& self,ll l, ll r)->ll{\n    ll ret=0;\n    if(l+1>=r) return ret;\n    FOR(k,l,r-1){\n      if(abs(wn.at(k)-wn.at(k+1))>=2)continue;\n      chmax(ret, self(self,l,k)+self(self,k+2,r)+2);\n    }\n    return ret;\n  };\n\n  ll ans=dfs(dfs, 0,n);\n  cout<<ans<<endl;\n  return ans;\n}\n#endif\nll solve2(){\n  ll n; cin>>n;\n  if(n==0) return -1;\n  vector<ll> wn(n);\n  for(auto&& w:wn) cin>>w;\n\n  vector<vector<ll>> dp(n,vector<ll>(n+1));\n  FOR(len,1,n){\n    FOR(l,0,n){\n      ll r=l+len;\n      if (r>=n)break;\n      if(len-1 == dp[l+1][r-1]){\n        if (abs(wn.at(l)-wn.at(r))<2){\n          dp[l][r] = dp[l+1][r-1]+2;\n        } \n      }\n      dump(\"-\",len,l,r);\n      //kで区切る\n      for(ll k=l;k<r;++k){\n        chmax(dp[l][r],dp[l][k]+dp[k+1][r]);\n        dump(l,k,k+1,r,dp[l][r]);\n      }\n    }\n  }\n  dump(dp);\n  ll ans=dp[0][n-1];\n  cout<<ans<<endl;\n  return ans;\n}\nint main() {\n#if LOCAL&01\n  //std::ifstream in(\"./test/sample-1.in\");\n  std::ifstream in(\"./input.txt\");\n  std::cin.rdbuf(in.rdbuf());\n#else\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n#endif\n  while(solve2() >= 0){\n    //break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint n;\nvector<int> w;\nvector<vector<int> > dp;\n\n\nint rec(int l,int r){\n    if(dp[l][r] != -1) return dp[l][r];\n    if(abs(l - r) <= 1) return 0;\n\n    int res = 0;\n    if(abs(w[l] - w[r - 1]) <= 1 && rec(l + 1,r - 1) == r - l - 2) res = r - l;\n\n    for(int mid = l + 1;mid <= r - 1;mid++) {\n        res = max(res , rec(l,mid) + rec(mid,r));\n    }\n    return dp[l][r] = res;\n};\n\nint main() {\n    vector<int> ans(0);\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        w.resize(n);\n        for (int i = 0; i < n; i++) {\n            cin >> w[i];\n        }\n        dp = vector<vector<int> >(n+2, vector<int>(n+2, -1));\n        ans.push_back(rec(0, n));\n    }\n\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[302][302];\n\nint main(){\n    int n;\n    while(cin >> n, n != 0){\n        vector<int> v;\n        for(int i=0;i<n;++i){\n            int w;\n            cin >> w;\n            v.push_back(w);\n        }\n\n        for(int i=0;i<=300;++i)\n            for(int j=0;j<=300;++j)\n                dp[i][j] = 0;\n\n        for(int i=0;i<n-1;++i){\n            if(abs(v[i]-v[i+1]) <= 1)\n                dp[i][i+1] = 2;\n        }\n\n        for(int k=2;k<n;++k){\n            for(int i=0;i<n;++i){\n                if(i+k >= n)break;\n                for(int j=0;j<k;++j)\n                    dp[i][i+k] = max(dp[i][i+k], dp[i][i+j] + dp[i+j+1][i+k]);\n                if(dp[i+1][i+k-1] == k-1 && abs(v[i]-v[i+k]) <= 1)\n                    dp[i][i+k] = k + 1;\n                dp[i][i+k] = max(dp[i][i+k], dp[i+1][i+k-1]);\n            }\n        }\n\n        cout << dp[0][n-1] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint main(){\n\tint n;\n\tint dp[305][305];\n\twhile(cin >> n, n){\n\t\tvector<int> a(n);\n\t\tcin >> a;\n\n\t\trep(i,n) rep(j,n) dp[i][j] = 0;\n\n\t\trange(w,2,n + 1){\n\t\t\trep(i,n){\n\t\t\t\tint j = i + w - 1;\n\t\t\t\tif(j > n) break;\n\t\t\t\tif(abs(a[i] - a[j]) <= 1 and dp[i + 1][j - 1] + 2 == w){\n\t\t\t\t\tdp[i][j] = w;\n\t\t\t\t}\n\t\t\t\trange(k,i,j){\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing Graph = vector<vector<ll>>;\n#define rep(i, n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i, m, n) for(ll i=m;i<(ll)(n);i++)\n#define rrep(i, n, m) for(ll i=n;i>=(ll)(m);i--)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000000L;\n#ifdef __DEBUG\n\n/**\n * For DEBUG\n * https://github.com/ta7uw/cpp-pyprint\n */\n#include \"cpp-pyprint/pyprint.h\"\n\n#endif\n\nll N;\nvector<vector<ll>> dp;\nvector<ll> W;\n\nll dfs(ll l, ll r) {\n    if (dp[l][r] != -1) {\n        return dp[l][r];\n    }\n    if (abs(r - l) == 1) {\n        return dp[l][r] = 0;\n    } else if (abs(r - l) == 2) {\n        if (abs(W[l] - W[r - 1]) <= 1) {\n            return dp[l][r] = 2;\n        } else {\n            return dp[l][r] = 0;\n        }\n    }\n\n    ll res = 0;\n\n    if (abs(W[l] - W[r - 1]) <= 1 && dfs(l + 1, r - 1) == abs(r - 1 - (l + 1))) {\n        res = r - l;\n    }\n\n    for (ll k = l + 1; k < r; k++) {\n        res = max(res, dfs(l, k) + dfs(k, r));\n    }\n    return dp[l][r] = res;\n}\n\nvoid solve() {\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        dp.assign(N + 1, vector<ll>(N + 1, -1));\n        W.assign(N, 0);\n        rep(i, N) cin >> W[i];\n        cout << dfs(0, N) << '\\n';\n    }\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#define mp make_pair\n#define pb push_back\n\nusing LL = long long;\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint N;\nint memo[333][333];\nvector<int>A;\nint dp(int L, int R) {\n\tif (R - L <= 1) {\n\t\treturn 0;\n\t}\n\tif (memo[L][R] >= 0) {\n\t\treturn memo[L][R];\n\t}\n\tint ans = 0;\n\tfor (int i = L + 1; i < R; ++i) {\n\t\tans = max(ans, dp(L, i) + dp(i, R));\n\t}\n\tfor (int i = L; i < R - 1; ++i) {\n\t\tif (abs(A[i] - A[i + 1]) <= 1) {\n\t\t\tans = max(ans, dp(L, i) + dp(i + 2, R) + 2);\n\t\t}\n\t}\n\tif (dp(L + 1, R - 1) == R - L - 2) {\n\t\tif (abs(A[L] - A[R - 1]) <= 1) {\n\t\t\tans = max(ans, R - L);\n\t\t}\n\t}\n\treturn memo[L][R] = ans;\n}\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tmemset(memo, 0xff, sizeof(memo));\n\t\tA.clear();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tA.push_back(tmp);\n\t\t}\n\t\tcout << dp(0, N) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef BUILT_LOCAL\n\n#include \"niklib.h\"\n\n#endif\n\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <map>\n#include <cmath>\n#include <set>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef __int128 lll;\nconstexpr ll mod = 1000000007;\n\nint dp[300][301];\n\nint main() {\n    while (true) {\n        int n, *w;\n        cin >> n;\n        if (n == 0) return 0;\n        w = new int[n];\n        for (int i = 0; i < n; i++) {\n            cin >> w[i];\n        }\n        for (auto &e:dp)for (auto &f:e)f = 0;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 0; j + i <= n; j++) {\n                if (dp[j + 1][j + i - 1] == i - 2 && abs(w[j] - w[j + i - 1]) < 2) {\n                    dp[j][j + i] = dp[j + 1][j + i - 1] + 2;\n                }\n                for(int k = 0;k <= i;k++) {\n                    dp[j][j+i] = max(dp[j][j+i],dp[j][j+k]+dp[j+k][j+i]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define DEBUG(C) cerr << #C << \" = \" << C << endl\n\nusing namespace std;\n\nconst int MAX = 333;\nint w[MAX];\nint dp[MAX][MAX];\n\nbool solve() {\n  int n;\n  scanf(\"%d\", &n);\n  if (n == 0) {\n    return false;\n  }\n  memset(w, 0, sizeof(w));\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", w + i);\n  }\n  memset(dp, 0, sizeof(dp));\n  \n  for (int len = 2; len <= n; len++) {\n    for (int l = 0; l <= n - len; l++) {\n      const int r = l + len;\n      for (int m = l; m <= r; m++) {\n        dp[l][r] = max(dp[l][r], dp[l][m] + dp[m][r]);\n      }\n      if (abs(w[l] - w[r - 1]) <= 1 && dp[l + 1][r - 1] == (r - 1) - (l + 1)) {\n        dp[l][r] = r - l;\n      }\n    }\n  }\n  \n  printf(\"%d\\n\", dp[0][n]);\n  return true;\n}\n\nint main() {\n  while (solve()) {}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init,tail...)\n    return move(vector<decltype(rec)>(s, rec));\n#undef rec\n}\n\nconst int inf = 1e9;\n\nstruct Solver {\n    int N;\n    vector<int> W;\n    vector<vector<int>> dp;\n\n    Solver(int N) : N(N) {\n        W.resize(N);\n        for(int &e : W) cin >> e;\n        dp = make_v(-1, N + 10, N + 10);\n    }\n\n    int calc(int l, int r) {\n        if(r - l < 2) return 0;\n        if(dp[l][r] != -1) return dp[l][r];\n        int ret = calc(l + 1, r);\n        for(int i = l + 1; i < r; i++) {\n            if(abs(W[l] - W[i]) > 1) continue;\n            int rec = calc(l + 1, i);\n            if(rec < i - (l + 1)) continue;\n            int tmp = 2 + rec + calc(i + 1, r);\n            ret = max(ret, tmp);\n        }\n        return dp[l][r] = ret;\n    }\n\n    int solve() {\n        return calc(0, N);\n    }\n};\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n    cout << Solver(N).solve() << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint w[301];\nint dp[301][301];\n\nint func(int l,int r){\n\tif(dp[l][r]!=-1)return dp[l][r];\n\tif(l+1==r)return 0;\n\tif(l+2==r){\n\t\tif(abs(w[l]-w[l+1])<=1)return 2;\n\t\telse return 0;\n\t}\n\tint res=0;\n\tres=max(res,func(l+1,r));\n\tres=max(res,func(l+2,r)+(abs(w[l]-w[l+1])<=1?2:0));\n\tres=max(res,func(l,r-1));\n\tres=max(res,func(l,r-2)+(abs(w[r-1]-w[r-2])<=1?2:0));\n\tif(abs(w[l]-w[r-1])<=1){\n\t\tint v=func(l+1,r-1);\n\t\tif(v==(r-1)-(l+1)){\n\t\t\tres=r-l;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&w[i]);\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tprintf(\"%d\\n\",func(0,n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint w[300];\nint memo[300][300]; //[l,r]\nint solve(int l, int r) {\n\tif (l >= r) return 0;\n\tif (memo[l][r] != -1) return memo[l][r];\n\tint ans1 = 0, ans2 = 0;\n\tfor (int i = l; i <= r - 1; i++) {\n\t\tint sum = 0;\n\t\tsum += solve(l, i);\n\t\tsum += solve(i + 1, r);\n\t\tans1 = max(ans1, sum);\n\t}\n\tfor (int i = l+1; i <= r-1; i++) { //[l+1,i] [i+1,r-1]\n\t\tint sum = 0;\n\t\tsum += solve(l + 1, i);\n\t\tsum += solve(i + 1, r - 1);\n\t\tans2 = max(ans2, sum);\n\t}\n\tif (ans2 == (r - l - 1) && abs(w[l] - w[r]) <= 1) {\n\t\tans2 += 2;\n\t}\n\treturn memo[l][r] = max(ans1,ans2);\n}\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\", &w[i]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) memo[i][j] = -1;\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0, n - 1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint dp[300][300],dp2[300][300],n;\nint main(void){\n    while(1){\n    cin>>n;\n    if(n==0)return 0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i==j){\n                dp[i][j]=1;\n                cin>>dp2[i][j];\n            }\n            else {\n                dp[i][j]=1e8;\n                dp2[i][j]=0;\n            }\n        }\n    }\n    for(int j=1;j<n;j++){\n        for(int i=0;i+j<n;i++){\n            for(int k=i;i+j>k;k++){\n                if(dp[i][k]==1&&dp[k+1][i+j]==1){\n                    if(abs(dp2[i][k]-dp2[k+1][i+j])<=1)dp[i][i+j]=0;\n                    else dp[i][i+j]=min(dp[i][i+j],2);\n                }\n                else if(dp[i][k]==0&&dp[k+1][i+j]==1){\n                    dp[i][i+j]=min(dp[i][i+j],1);\n                    dp2[i][i+j]=dp2[k+1][i+j];\n                }\n                 else if(dp[i][k]==1&&dp[k+1][i+j]==0){\n                     dp[i][i+j]=min(dp[i][i+j],1);\n                     dp2[i][i+j]=dp2[i][k];\n                 }\n                 else{\n                     dp[i][i+j]=min(dp[i][i+j],dp[i][k]+dp[k+1][i+j]);\n                 }\n            }\n        }\n    }\n    cout<<n-dp[0][n-1]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\nbool solve(){\n    int n;\n    cin >> n;\n    if(!n)\n        return 0;\n    vector<int> w(n);\n    for(auto& x : w)\n        cin >> x;\n\n    vector<vector<bool>> dp(n + 1, vector<bool>(n + 1, 0));\n    for(i64 i = 0; i <= n; ++i)\n        dp[i][i] = 1;\n    for(int i = 0; i + 2 <= n; ++i)\n        dp[i][i + 2] = (abs(w[i] - w[i + 1]) <= 1);\n\n    for(int len = 3; len <= n; ++len){\n        for(int l = 0, r = len; r <= n; ++l, ++r){\n            for(int i = l + 1; i < r; ++i)\n                if(dp[l][i] && dp[i][r])\n                    dp[l][r] = true;\n            if(dp[l + 1][r - 1] && abs(w[l] - w[r - 1]) <= 1)\n                dp[l][r] = true;\n        }\n    }\n\n    /*\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j)\n            cout << dp[i][j];\n        cout << endl;\n    }\n    */\n\n    vector<i64> dp2(n + 1, INF);\n    dp2[0] = 0;\n    for(int i = 0; i < n; ++i){\n        dp2[i + 1] = min(dp2[i + 1], dp2[i] + 1);\n        for(int j = i + 1; j <= n; ++j)\n            if(dp[i][j])\n                dp2[j] = min(dp2[j], dp2[i]);\n    }\n\n    cout << n - dp2[n] << endl;\n\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n){\n            if(!k || i+k>n-1)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1] == k-2)){\n                    dp[i][i+k] = k;\n                }\n                for(int j = i+1; j<i+k;j++){\n                    if(dp[i][j] == j-i && dp[j+1][i+k] == k+i-j+1){\n                        dp[i][i+k] = k;\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        rep(i,n)rep(j,n){\n            cmax(ans,dp[i][j]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint n;\nvector<int> w;\n\nenum MEMO {\n  NOT_CHECKED,\n  TRUE,\n  FALSE\n};\n\n\nMEMO memo[301][301];\n\nMEMO rec(int l, int r) {\n  if (r - l == 1) {\n    if (abs(w[r] - w[l]) <= 1) {\n      return memo[l][r] = TRUE;\n    } else {\n      return memo[l][r] = FALSE;\n    }\n  }\n\n  if (r == l) {\n    return memo[l][r] = FALSE;\n  }\n\n  if (l > r) {\n    return memo[l][r] = TRUE;\n  }\n\n  if (memo[l][r] != NOT_CHECKED) {\n    return memo[l][r];\n  }\n\n  if (abs(w[l] - w[r]) <= 1) {\n    for (int i = l + 2; i < r; i++) {\n      int temp1 = rec(l + 1, i);\n      int temp2 = rec(i + 1, r - 1);\n      if (temp1 == TRUE && temp2 == TRUE) {\n        return memo[l][r] = TRUE;\n      }\n    }\n  }\n\n  for (int i = l + 1; i < r; i++) {\n    int temp1 = rec(l, i);\n    int temp2 = rec(l + 1, r);\n    if (temp1 == TRUE && temp2 == TRUE) {\n      return memo[l][r] = TRUE;\n    }\n  }\n\n  return memo[l][r] = FALSE;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        memo[i][j] = NOT_CHECKED;\n      }\n    }\n\n    rec(0, n - 1);\n\n    int dp[301] = { 0 };\n    for (int i = 1; i < n; i++) {\n      dp[i] = dp[i - 1];\n      if (memo[0][i] == TRUE) {\n        dp[i] = i + 1;\n        continue;\n      }\n      for (int j = 1; j < i; j++) {\n        if (memo[j][i] == TRUE) {\n          dp[i] = max(dp[i], dp[j - 1] + (i - j + 1));\n        }\n      }\n    }\n\n    int ans = dp[n - 1];\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dp[500][500];\n\nint main() {\n    int n, i, j, k;\n    while(cin >> n, n) {\n        vector<int> w(n);\n        for(i = 0; i < n; i++)\n            cin >> w[i];\n        for(i = 0; i < 500; i++) {\n            for(j = 0; j < 500; j++) {\n                dp[i][j] = 0;\n            }\n        }\n        for(i = 2; i <= n; i++) {\n            for(j = 0; j < n - i + 1; j++) {\n                if(abs(w[j] - w[j + i - 1]) <= 1 && (i == 2 || dp[j + 1][j + i - 2] > 0)) {\n                    dp[j][j + i - 1] = i;\n                }\n                for(k = j + 1; k < j + i - 1; k++) {\n                    if(dp[j][k] > 0 && dp[k + 1][j + i - 1] > 0) dp[j][j + i - 1] = i;\n                }\n            }\n        }\n        for(i = 2; i <= n; i++) {\n            for(j = 0; j < n - i + 1; j++) {\n                for(int m = j; m <= j + i - 1; m++) {\n                    dp[j][j + i - 1] = max(dp[j][j + i - 1], dp[j][m] + dp[m + 1][j + i - 1]);\n                }\n            }\n        }\n        cout << dp[0][n - 1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nvoid solve(int N){\n    vector<int> w(N);\n    rep(i,N) cin >> w[i];\n\n    vvi dp(N,vi(N,0));\n    for(int len=0;len<=N;len++){\n        for(int i=0;i<N;i++){\n            int j=i+len-1;\n            if(j>=N) continue;\n            if(i+1<N and j-1>=0){\n                int d=0;\n                if(dp[i+1][j-1]==(j-1)-(i+1)+1 and abs(w[i]-w[j])<=1) d=2;\n                dp[i][j]=max(dp[i][j],dp[i+1][j-1]+d);\n            }\n            if(j-2>=max(i,0)){\n                int d=0;\n                if(abs(w[j]-w[j-1])<=1) d=2;\n                dp[i][j]=max(dp[i][j],dp[i][j-2]+d);\n            }\n            if(i+2<=j){\n                int d=0;\n                if(abs(w[i]-w[i+1])<=1) d=2;\n                dp[i][j]=max(dp[i][j],dp[i+2][j]+d);\n            }\n        }\n    }\n    cout << dp[0][N-1] << endl;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\ntypedef pair<int, int> P_i;\ntypedef pair<double,double> P_d;\n#define SZ(x) ((int)(x).size())\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define alrep(i,j,n) for(int i=0;i<(n);++i)for(int j=i+1;j<(n);++j)\n#define Yes cout << \"Yes\" << endl;\n#define No cout << \"No\" << endl;int ans=0;\n#define answer cout << ans << endl;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> using v = vector<T>;\ntemplate<class T> using vv = vector<vector<T>>;\nconst int MOD=1e9+7;\nconst long long INF = 1LL << 60;\n\nint rec(int l,int r,vv<int> &dp,v<int> &w){\n  if(dp[l][r]!=-1) return dp[l][r];\n  if(abs(l-r)<=1) return 0;\n  int res=-1;\n  if(abs(w[l]-w[r-1])<=1 && rec(l+1,r-1,dp,w)==r-l-2) res=r-l;\n  for(int mid=l+1;mid<=r-1;mid++){\n    chmax(res,rec(l,mid,dp,w)+rec(mid,r,dp,w));\n  }\n  return dp[l][r]=res;\n}\n\nsigned main(){\n  int n;\n  while(cin >> n && n!=0){\n    vv<int> dp(310,v<int>(310,-1));\n    v<int> w(n,0);\n    rep(i,n) cin >> w[i];\n    cout << rec(0,n,dp,w) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#include<map>\n#include<set>\n#include<queue>\n#include<functional>\n#include<math.h>\nusing namespace std;\n#define N (1000000000+7)\n#define INF 1e16\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nll dp[302][302];\nbool f[302][302];\nvector<ll>a;\nll n;\n\nll Abs(ll x,ll y){\n    if(x>=y)return x-y;\n    else return y-x;\n}\n\n\nll rec(ll l,ll r){\n    if(f[l][r])return dp[l][r];\n    if(l==r)return dp[l][r]=0;\n    if(l>r)return dp[l][r]=0;\n    if(l<=0)return 0;\n    if(r>n)return 0;\n    if(r-l==1){\n        f[l][r]=true;\n        if(Abs(a[l],a[r])<=1)return dp[l][r]=2;\n        else return dp[l][r]=0;\n    }\n    if(Abs(a[l],a[r])<=1){\n        dp[l+1][r-1] = rec(l+1,r-1);\n        f[l+1][r-1]=true;\n        if(dp[l+1][r-1]==r-l-1){\n            f[l][r]=true;\n            return dp[l][r]=r-l+1;\n        }\n    }\n    ll ans = 0;\n    for(ll k=l;k<r;k++){\n        ans = max(ans,rec(l,k)+rec(k+1,r));\n    }\n    f[l][r]=true;\n    return dp[l][r]=ans;\n}\n\n\nint main(void){\n    while(true){\n        for(ll i=0;i<302;i++){\n            for(ll j=0;j<302;j++){\n                dp[i][j]=0;\n                f[i][j]=false;\n            }\n        }\n        cin>>n;\n        if(n==0)break;\n        a.resize(n+1,0);\n        for(ll i=0;i<n;i++){\n            ll x;\n            cin>>x;\n            a[i+1]=x;\n        }\n        ll ans = 0;\n        cout<<rec(1,n)<<endl;\n        /*for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                cout<<dp[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool check(int a, int b){\n\treturn abs(a - b) <= 1;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        vector<int> w(n);\n        rep(i,n){\n            cin >> w[i];\n        }\n\n\t\tint dp[300][300] = {{0}};\n\t\trange(W,2,n + 1){\n\t\t\trep(i,n){\n\t\t\t\tint j = i + W - 1;\n\t\t\t\tif(check(w[i], w[j]) && dp[i + 1][j - 1] == W - 2){\n\t\t\t\t\tdp[i][j] = W;\n\t\t\t\t}\n\t\t\t\trange(k,i,j){\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15);\n  }\n} initializer;\n\ntemplate<typename T> istream& operator>>(istream &s, vector<T> &v) {\n  for (T &t : v) s >> t;\n  return s;\n}\n\ntemplate<typename T> ostream& operator<<(ostream &s, const vector<T> &v) {\n  for (const T &t : v) s << t << endl;\n  return s;\n}\n\ntemplate<typename T> T min(vector<T>& v) {return *min_element(v.begin(), v.end());}\n\ntemplate<typename T> T max(vector<T>& v) {return *max_element(v.begin(), v.end());}\n\ntemplate<typename T> int min_element(vector<T>& v) {return min_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> int max_element(vector<T>& v) {return max_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> void sort(vector<T>& v) {sort(v.begin(), v.end());}\n\ntemplate<typename T, typename Function> void sort(vector<T>& v, Function func) {sort(v.begin(), v.end(), func);}\n\ntemplate<typename T> void rsort(vector<T>& v) {sort(v.rbegin(), v.rend());}\n\ntemplate<typename T> void reverse(vector<T>& v) {reverse(v.begin(), v.end());}\n\ntemplate<typename T> void unique(vector<T>& v) {v.erase(unique(v.begin(), v.end()), v.end());}\n\ntemplate<typename T> void nth_element(vector<T>& v, int n) {nth_element(v.begin(), v.begin() + n, v.end());}\n\ntemplate<typename T> bool next_permutation(vector<T>& v) {return next_permutation(v.begin(), v.end());}\n\ntemplate<typename T> int find(vector<T>& v, T t) {return find(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int in(vector<T> v, T t) {return find(v, t) != int(v.size());}\n\ntemplate<typename T> int lower_bound(vector<T>& v, T t) {return lower_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int upper_bound(vector<T>& v, T t) {return upper_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> T accumulate(const vector<T>& v, function<T(T, T)> func = plus<T>()) {return accumulate(v.begin(), v.end(), T(), func);}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v) {adjacent_difference(v.begin(), v.end(), v.begin());}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v, vector<T>& u) {adjacent_difference(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> void partial_sum(vector<T>& v, vector<T>& u) {partial_sum(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> T inner_product(vector<T>& v, vector<T>& u) {return inner_product(v.begin(), v.end(), u.begin(), T(0));}\n\ntemplate<typename T> int count(const vector<T>& v, T t) {return count(v.begin(), v.end(), t);}\n\ntemplate<typename T, typename Function> int count_if(const vector<T>& v, Function func) {return count_if(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> void remove_if(vector<T>& v, Function func) {v.erase(remove_if(v.begin(), v.end(), func), v.end());}\n\ntemplate<typename T, typename Function> bool all_of(vector<T> v, Function func) {return all_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool any_of(vector<T> v, Function func) {return any_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool none_of(vector<T> v, Function func) {return none_of(v.begin(), v.end(), func);}\n\ntemplate<typename T> vector<T> subvector(vector<T>& v, int a, int b) {return vector<T>(v.begin() + a, v.begin() + b);}\n\ntemplate<typename T> int kinds(const vector<T>& v) {return set<T>(v.begin(), v.end()).size();}\n\ntemplate<typename T> void iota(vector<T>& v, T t = 0) {iota(v.begin(), v.end(), t);}\n\ntemplate<typename T> bool is_sorted(const vector<T>& v) {return is_sorted(v.begin(), v.end());}\n\nclass Solver {\nprivate:\n  vector<int> w;\n  map<pair<int, int>, int> mem;\n\npublic:\n  Solver(const vector<int>& w) : w(w) {}\n\n  int solve(int a, int b) {\n    if (b - a < 2) return 0;\n    if (b - a == 2 && abs(w[a] - w[a + 1]) <= 1) return 2;\n    auto itr = mem.find(make_pair(a, b));\n    if (itr != mem.end()) return itr->second;\n    int z = solve(a + 1, b - 1);\n    if (z == b - a - 2 && abs(w[a] - w[b - 1]) <= 1) z += 2;\n    for (int i = a + 1; i < b; ++i) {\n      int x = solve(a, i) + solve(i, b);\n      if (x > z) z = x;\n    }\n    return mem[make_pair(a, b)] = z;\n  }\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<int> w(n);\n    cin >> w;\n    Solver solver(w);\n    cout << solver.solve(0, n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint N;\nint A[310];\nint dp[310][310] = {};\n\nint rec(int l,int r){\n    if(dp[l][r]!=-1) return dp[l][r];\n    if(l==r) return 0;\n    if(l+1==r) return 2*(abs(A[l]-A[r])<=1);\n    dp[l][r] = 0;\n    int res1 = rec(l+1,r-1);\n    if(abs(A[l]-A[r])<=1 && res1==r-l-1){\n        dp[l][r] = r-l+1;\n        return r-l+1;\n    }\n    dp[l][r] = res1;\n    for(int k=0;k<r-l;k++){\n        dp[l][r] = max(dp[l][r],rec(l,l+k)+rec(l+k+1,r));\n    }\n    return dp[l][r];\n}\n\nint main(){\n    while(cin >> N && N>0){\n        for(int i=1;i<=N;i++){\n            cin >> A[i];\n        }\n        for(int i=1;i<=N;i++){\n            for(int j=1;j<=N;j++){\n                dp[i][j] = -1;\n            }\n        }\n        cout << rec(1,N) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nvector<tuple<int, int, int>>vec; int n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; vec.clear(); for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; } for (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { vec.push_back(make_tuple(j - i, i, j)); } }\n\t\tsort(vec.begin(), vec.end());\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 1; } }\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tint a1 = get<1>(vec[i]), a2 = get<2>(vec[i]);\n\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\tif (a2 < n - 2 && abs(a[a2 + 1] - a[a2 + 2]) <= 1)dp[a1][a2 + 2] = 1;\n\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (dp[i][j] == 1)dp[i][j] = j - i + 1; } }\n\t\tfor (int i = 0; i < n; i++) { for (int j = i; j < n; j++) { for (int k = 0; k < n; k++) { dp[i][k] = max(dp[i][k], dp[i][j - 1] + dp[j][k]); } } }\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int MAX = 305;\nint dp[MAX][MAX];\nint num[MAX];\n\nint dfs(int l, int r){\n    if(dp[l][r]!=-1)return dp[l][r];\n    if(l >= r){\n        dp[l][r]=0;\n        return 0;\n    }\n    if(l+1==r){\n        if(abs(num[l]-num[r])<2){\n            dp[l][r] = 2;\n            return 2;\n        }\n        else{\n            dp[l][r] = 0;\n            return 0;\n        }\n    }\n    for(int p = l; p <= r; p++){\n        dp[l][r] = max(dp[l][r], dfs(l, p) + dfs(p+1, r));\n    }\n    if(abs(num[l]-num[r])<2 && dfs(l+1, r-1)==(r-l-1)){\n        dp[l][r]=r-l+1;\n    }\n    return dp[l][r];\n}\n\nint main(){\n    for(int n;cin>>n,n;){\n        for(int i = 0; i < MAX; i++){\n            for(int j = 0; j<MAX;j++){\n                dp[i][j]=-1;\n            }\n        }\n        for(int i=1;i<=n;i++){\n            cin>>num[i];\n        }\n        cout<<dfs(1, n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) REP(sz, vec.size()) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 1000000007;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nint n;\nV<int> w;\nV< V<int> > dp;\n\nint rec(ll l, ll r) {\n    if (l == r) return 0;\n    if (l + 1 == r) return (abs(w[l] - w[r]) <= 1 ? 2 : 0);\n    if (dp[l][r] != -1) return dp[l][r];\n    else {\n        if (abs(w[l] - w[r]) <= 1 && rec(l + 1, r - 1) == r - l - 1) return dp[l][r] = r - l - 1 + 2;\n        else {\n            int ret = 0;\n            for (int m = l; m < r; m++) chmax(ret, rec(l, m) + rec(m + 1, r));\n            return dp[l][r] = ret;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> n;\n        if (n == 0) break;\n        w.resize(n);\n        for (int i = 0; i < n; i++) cin >> w[i];\n        dp.resize(n, V<int>(n));\n        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) dp[i][j] = -1;\n        cout << rec(0, n - 1) << '\\n';\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nint dp[301][301];\nvi w;\nint rec(int l,int r) {\n    if(dp[l][r]!=INF) return dp[l][r];\n    if(l==r) return dp[l][r]=0;\n    int ret=0;\n    REPF(i,l,r) {\n        REPF(j,i+1,r) {\n            if(abs(w[i]-w[j])<=1) {\n                int tmp=0;\n                tmp+=rec(l,i)+rec(j+1,r);\n                if(rec(i+1,j)==j-i-1) {\n                    tmp+=(j-i-1)+2;\n                }\n                chmax(ret,tmp);\n            }\n        }\n    }\n    return dp[l][r]=ret;\n}\nsigned main() {\n    while(1) {\n        int n;\n        cin>>n;\n        if(n==0) break;\n        REP(i,301) REP(j,301) dp[i][j]=INF;\n\n        w=vi(n);\n        cin>>w;\n        cout<<rec(0,n)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define OK(x,y) abs(w[x]-w[y])<=1\nint n, w[311];\nint dp[311][311];\n\nint main(){\n  while(cin>>n&&n){\n    REP(i,n) cin>>w[i];\n    memset(dp, 0, sizeof dp);\n\n    for(int j=1; j<n; j++){\n      for(int i=0; i+j<n; i++){\n        if(OK(i,i+j) && dp[i+1][i+j-1]==j-1){\n          dp[i][i+j]=j+1;\n        }\n\n        for(int k=i+1; k<=i+j-1; k++){\n          dp[i][i+j]=max(dp[i][i+j], dp[i][k]+dp[k+1][i+j]);\n        }\n      }\n    }\n    cout << dp[0][n-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define FOR(i, a, n) for(int i=a; i<n; i++)\n#define RFOR(i, a, n) for(int i=n-1; i>=a; i--)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) FOR(i, 0, n)\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n) {\n\t\tint dp[301][301] = {};\n\t\tint w[301];\n\t\tREP(i, n) cin >> w[i];\n\n\t\tFOR(k, 1, n) {\n\t\t\tfor (int i = 0; i + k < n; i++) {\n\t\t\t\tif (abs(w[i] - w[i + k]) <= 1) {\n\t\t\t\t\tif (dp[i + 1][i + k - 1] == k - 1) {\n\t\t\t\t\t\tdp[i][i + k] = dp[i + 1][i + k - 1] + 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = i; j < i + k; j++) {\n\t\t\t\t\tdp[i][i + k] = max(dp[i][i + k], dp[i][j] + dp[j + 1][i + k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = 334;\nconstexpr int INF = (1 << 29);\n\nint memo[MAX][MAX];\nvector<int> w;\n\nint rec(int L, int R)\n{\n    int &res = memo[L][R];\n    if (res != -1) return res;\n    if (L >= R) return (res = 0);\n    \n    res = -INF;\n    \n    if (abs(w[L] - w[R]) <= 1) {\n        int r = rec(L + 1, R - 1);\n        if (r == (R - 1) - (L + 1) + 1) {\n            res = max(res, r + 2);\n        }\n    }\n    \n    for (int i = L; i <= R; i++) {\n        res = max(res, rec(L, i) + rec(i+1, R));\n    }   \n    return res;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        w.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> w[i];\n        }\n        \n        memset(memo, -1, sizeof(memo));\n        cout << rec(0, N - 1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v ) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n\nstruct edge { int to, cost; };\nostream& operator<<(ostream& os, const edge& e) {\n    os << \"(\" << e.to << \", \" << e.cost << \")\";\n    return os;\n}\n\nconst LL LINF = 1LL<<60;\nconst int IINF = 1<<30;\nconst LL MOD = 1e9+7;\n\nint main()\n{\n    vector<int> ns;\n    vector<vector<int>> ws;\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<int> w(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> w[i];\n        }\n        ns.push_back(n);\n        ws.push_back(w);\n    }\n\n    for (int t = 0; t < ns.size(); ++t) {\n        int n = ns[t];\n        auto w = ws[t];\n\n        auto dp = make_v<int>(n, n+1);\n        fill_all(dp, -IINF);\n\n        for (int i = 0; i < n; ++i) {\n            dp[i][i] = 0;\n        }\n\n        for (int k = 1; k <= n; ++k) {\n            for (int i = 0; i+k <= n; ++i) {\n                for (int j = i+1; j < i+k; ++j) {\n                    chmax(dp[i][i+k], dp[i][j] + dp[j][i+k]);\n                }\n                if (k >= 2 && abs(w[i] - w[i+k-1]) <= 1) {\n                    chmax(dp[i][i+k], dp[i+1][i+k-1] + 2);\n                }\n            }\n        }\n\n        vector<int> dp2(n+1, -IINF);\n        dp2[0] = 0;\n        for (int i = 0; i < n; ++i) {\n            chmax(dp2[i+1], dp2[i]);\n            for (int j = i+1; j <= n; ++j) {\n                chmax(dp2[j], dp2[i] + dp[i][j]);\n            }\n        }\n\n        cout << dp2[n] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nint n, a[1010];\nint dp[1010][1010], dp2[1010] = {};\n\nint ok(int l, int r){\n    int &res = dp[l][r];\n    if(res != -1) return res;\n    res = false;\n    if(l == r) res = true;\n    for(int i = l+2; i < r; i += 2) if(ok(l,i) && ok(i,r)) res = true;\n    if(abs(a[l] - a[r-1]) <= 1 && ok(l+1, r-1)) res = true;\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(cin >> n && n){\n        rep(i, n) cin >> a[i];\n        memset(dp, -1, sizeof dp);\n        memset(dp2, 0, sizeof dp2);\n        rep(i, n){\n            dp2[i+1] = max(dp2[i+1], dp2[i]);\n            for(int j = i + 2; j <= n; j += 2){\n                if(ok(i, j)) dp2[j] = max(dp2[j], dp2[i] + j - i);\n            }\n        }\n        cout << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,data[301];\n\tbool** table = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tint** maximum = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tmaximum[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 1; k <= N; k++)maximum[i][k] = 0;\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1){\n\t\t\t\ttable[i][1] = true;\n\t\t\t\tmaximum[i][i+1] = 2;\n\t\t\t}\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t\tmaximum[left][left+length-1] = length; //????¨?????????§??????OK????????§?????¶????????§???????¨????\n\t\t\t\t}else{\n\t\t\t\t\t//maximum[left][left+length-1]?????´??°????????°????????????\n\t\t\t\t\tfor(int div = 0; left+div <= left+length-2;div++){ //????´¢?§????????????????\n\t\t\t\t\t\tfor(int i = 2; left+div+i-1 <= left+length-1; i+= 2){ //????´¢?§?????????????????????´?????????????????§????????¢?????????\n\t\t\t\t\t\t\tmaximum[left][left+length-1] = max(maximum[left][left+length-1],maximum[left+div][left+div+i-1]+maximum[left+div+i][left+length-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"maximum[%d][%d]:%d\\n\",left,left+length-1,maximum[left][left+length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(N%2 == 0)printf(\"%d\\n\",maximum[1][N]);\n\t\telse{\n\t\t\tprintf(\"%d\\n\",max(maximum[1][N-1],maximum[2][N]));\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\n//const int dx[] = {-1, 0, 1, 0};\n//const int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\n//vector<T> DIVISOR(T n) {\n//    vector<T> v;\n//    for (int i = 1; i * i <= n; ++i) {\n//        if (n % i == 0) {\n//            v.push_back(i);\n//            if (i != n / i) {\n//                v.push_back(n / i);\n//            }\n//        }\n//    }\n//    sort(v.begin(), v.end());\n//    return v;\n//}\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\nint main() {\n\n\n\n    while (true) {\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        vector<int> w(N);\n        for (int i = 0; i < N; i++) cin >> w[i];\n\n        //take[i][j]区間i~jが取れるかどうか\n        //i-1番目とj+1番目の差が1以下ならtake[i-1][j+1]もとれる\n        //take[i][k] take[k+1][j]がtrueならtake[i][j]もtrue\n        vector<vector<bool>> take(310, vector<bool>(310, false));\n\n\n        //dp[i][j]\n        //区間[i,j]において、被覆できる頂点数の最大値\n        vector<vector<int>> dp(310, vector<int>(310, 0));\n\n        //takeはtake[s][t]更新している\n        //iは長さを決める\n        for (int i = 0; i < N; i++) {\n\n            //jはsの位置を決める\n            for (int j = 0; j < N - i; j++) {\n                //sとtの長さ\n                int len = i + 1;\n\n                //take[s][t]\n                int s = j;\n                int t = j + i;\n\n                //take[s][k] take[k+1][t]が成り立てばtake[s][t]=true\n                for (int k = s; k < t; k++) {\n                    if (take[s][k] && take[k + 1][t]) take[s][t] = true;\n                }\n\n                if (len == 2) {\n                    if (ABS(w[s] - w[t]) < 2) {\n                        take[s][t] = true;\n                    }\n                }\n\n                //take[s][t]が取れたら\n                if (take[s][t]) {\n\n                    //xはsの左側\n                    //yはtの右側\n                    int x = s - 1;\n                    int y = t + 1;\n\n\n                    while (true)\n                    {\n                        //trueである限り\n                        //左側と右側を広げて更新する\n                        if (x < 0 || x >= N || y < 0 || y >= N) break;\n                        if (ABS(w[x] - w[y]) >= 2) break;\n                        take[x][y] = true;\n                        x--;\n                        y++;\n                    }\n                }\n\n            }\n        }\n\n\n        //成り立つ区間が出たため\n        //今度は最大に達成できる[1,N]までの中で\n        //上記で求めた区間がかぶらないような最大の日複数を数える\n\n        //上記の区間の長さをdpに設定する\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (take[i][j]) {\n                    dp[i][j] = j - i + 1;\n                }\n            }\n        }\n\n        //i-jまでの被らない最大の被覆数を数える\n        for (int i = 0; i < N; i++) {\n            for (int j = i; j < N; j++) {\n                for (int k = i; k < j; k++) {\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                }\n            }\n        }\n\n        //最も左側の0と、最も右側のN-1の最大被覆を求める\n        cout << dp[0][N - 1] << endl;\n\n    }\n    return 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\n int main(){\n\n\tint N,data[301];\n\tbool** table = new bool*[301];\n\tint** dp = new int*[301];\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= N; k++){\n\t\t\t\tdp[i][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1){\n\t\t\t\ttable[i][1] = true;\n\t\t\t\tdp[i][i+1] = 2;\n\t\t\t}else{\n\t\t\t\tdp[i][i+1] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int length = 3; length <= N; length += 1){\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){\n\n\t\t\t\tif(length%2 == 0){ //??????????\\???°?????´???\n\t\t\t\t\tFLG = false;\n\n\t\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;\n\n\t\t\t\t\tif(!FLG){\n\t\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(FLG){\n\t\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t\t\tdp[left][left+length-1] = length;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int i = left; i <= left+length-2;i++){\n\t\t\t\t\t\t\tdp[left][left+length-1] = max(dp[left][left+length-1],dp[left][i]+dp[i+1][left+length-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i = left; i <= left+length-2;i++){\n\t\t\t\t\t\tdp[left][left+length-1] = max(dp[left][left+length-1],dp[left][i]+dp[i+1][left+length-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(N%2 == 0)printf(\"%d\\n\",dp[1][N]);\n\t\telse{\n\t\t\tprintf(\"%d\\n\",max(dp[1][N-1],dp[2][N]));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> w(300);\nvector<vector<int>> dp(301, vector<int>(301, -1));\n\n\nint rec(int l,int r){\n    //既に計算済み？\n    if(dp[l][r] != -1) return dp[l][r];\n\n    //これ以上取り除けない？\n    if(abs(l - r) <= 1) return 0;\n\n    int res = 0;\n    //パターン1.\n    if(abs(w[l] - w[r - 1]) <= 1 && rec(l + 1,r - 1) == r - l - 2)\n    {\n        //[l , r)がはじき出せるので\n        res = r - l;\n    }\n\n    //パターン２.区間を分ける\n    for(int mid = l + 1;mid <= r - 1;mid++)\n    {\n        res = max(res , rec(l,mid) + rec(mid,r));\n    }\n    return dp[l][r] = res;\n};\n\nint main()\n{\n    while (true)\n    {\n        cin >> n;\n        if (n==0) break;\n        for (int i=0; i<n; i++) cin >> w[i];\n        int answer = rec(0, n);\n        cout << answer << endl;\n        for (int i=0; i<301; i++)\n        {\n            for (int j=0; j<301; j++)\n            {\n                dp[i][j]=-1;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n// #define DEBUG\n\nconst int MAX_N = 300;\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N) {\n        vector<int> W(N);\n        rep(i, N) cin >> W[i];\n\n        bool dp[MAX_N][MAX_N] = {};\n        rep(i, MAX_N) {\n            dp[i][i] = true;\n        }\n\n        for (int len=2; len<=N; len+=2) {\n            for (int l=0; l<=N-len; l++) {\n                {\n                    int inner_len = len - 2;\n                    if (!(inner_len > 0 && !dp[l + 1][l + inner_len]) && abs(W[l] - W[l+ (len - 1)]) <= 1) {\n                        dp[l][l + (len - 1)] = true;\n                    }\n                }\n                {\n                    bool ok = true;\n                    for (int l2=l; l2<l+len; l2+=2) {\n                        if (!dp[l2][l2+1]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        dp[l][l + (len - 1)] = true;\n                    }\n                }\n            }\n        }\n\n        int dp2[MAX_N + 1] = {};\n        rep(r, N) {\n            if (r > 0) dp2[r] = dp2[r-1];\n            for (int len=2; len<=r+1; len+=2) {\n                int l = r - len + 1;\n#ifdef DEBUG\n                // DUMP(len);\n                // DUMP2(l, r);\n#endif\n                if (dp[l][r]) {\n                    if (l-1 >= 0) {\n                        dp2[r] = max(dp2[r], dp2[l-1] + len);\n                    } else {\n                        dp2[r] = max(dp2[r], len);\n                    }\n                }\n            } \n        }\n\n#ifdef DEBUG\n        rep(l, N) {\n            rep(r, N) cerr << dp[l][r] << \" \";\n            cerr << endl;\n        }\n        cerr << \"-----------------------------\" << endl;\n        rep(i, N) cerr << dp2[i] << \" \";\n        cerr << endl;\n#endif\n\n        cout << dp2[N-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <fstream>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n\tstring::size_type p = s.find(delim, pos);\n\tif (p == string::npos) {\n\t    result.push_back(s.substr(pos));\n\t    break;\n\t}\n\telse {\n\t    result.push_back(s.substr(pos, p - pos));\n\t}\n\tpos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n\tstring::size_type right = str.find_last_not_of(trimCharacterList);\n\tresult = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n\treturn true;\n    }\n    else {\n\treturn 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double)(int)(dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double)(int)(dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double)(int)(dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n\tout *= 2;\n\tout += ((int)s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n\tout = out + (binary % 2) * pow(static_cast<int>(10), i);\n\tbinary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n\treturn std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n\tint d = val & 15;     // 16進数一桁を取得\n\tif (d < 10)\n\t    str.insert(str.begin(), d + '0');  //  10未満の場合\n\telse //  10以上の場合\n\t    str.insert(str.begin(), d - 10 + hc);\n\tval >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator >> (std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n\treturn true;\n    }\n    else {\n\treturn false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n\treturn SQR(POW(x, y >> 1));\n    }\n    else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n    BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n\treturn false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t    ++first2;\n\t}\n\tfirst1 = m1;\n\tstd::iter_swap(first1, first2);\n\t++first1;\n\t++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n\tm1 = last1;\n\tm2 = first2;\n\twhile ((m1 != first1) && (m2 != last2)) {\n\t    std::iter_swap(--m1, m2);\n\t    ++m2;\n\t}\n\tstd::reverse(first1, m1);\n\tstd::reverse(first1, last1);\n\tstd::reverse(m2, last2);\n\tstd::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n\tT d = EXTGCD(-a, b, x, y);\n\tx = -x;\n\treturn d;\n    }\n    if (b < 0) {\n\tT d = EXTGCD(a, -b, x, y);\n\ty = -y;\n\treturn d;\n    }\n    if (!b) {\n\tx = 1;\n\ty = 0;\n\treturn a;\n    }\n    else {\n\tT d = EXTGCD(b, a % b, x, y);\n\tT t = x;\n\tx = y;\n\ty = t - (a / b) * y;\n\treturn d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n\tif (arr[i]) {\n\t    for (int j = 0; i * (j + 2) < n; j++) {\n\t\tarr[i * (j + 2)] = false;\n\t    }\n\t}\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T)(SQR(i)) < b; i++) {\n\tif (small[i]) {\n\t    for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n\t\tprime[j - a] = false;\n\t    }\n\t}\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n\tif (n % i == 0) {\n\t    v.push_back(i);\n\t    if (i != n / i) {\n\t\tv.push_back(n / i);\n\t    }\n\t}\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n\tans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n\tfor (int i = 0, j; j = i + w, j < n; ++i)\n\t    for (int k = i; k < j; ++k) {\n\t\tint f = p[i] * p[k + 1] * p[j + 1];\n\t\tif (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n\t\t    X[i][j] = X[i][k] + X[k + 1][j] + f;\n\t\t    s[i][j] = k;\n\t\t}\n\t    }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\tA[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n\tif (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n\tREP(j, m) {\n\t    if (a[i] == b[j]) {\n\t\tX[i + 1][j + 1] = X[i][j] + 1;\n\t\tY[i + 1][j + 1] = 0;\n\t    }\n\t    else if (X[i + 1][j] < X[i][j + 1]) {\n\t\tX[i + 1][j + 1] = X[i][j + 1];\n\t\tY[i + 1][j + 1] = +1;\n\t    }\n\t    else {\n\t\tX[i + 1][j + 1] = X[i + 1][j];\n\t\tY[i + 1][j + 1] = -1;\n\t    }\n\t}\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n\tif (Y[i][j] > 0) --i;\n\telse if (Y[i][j] < 0) --j;\n\telse {\n\t    c.PB(a[i - 1]);\n\t    --i;\n\t    --j;\n\t}\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n\tfor (int c = 0; c + cs[i] <= C; ++c) {\n\t    if (xs[c + cs[i]] > xs[c] + 1) {\n\t\txs[c + cs[i]] = xs[c] + 1;\n\t\tys[c + cs[i]] = c;\n\t    }\n\t}\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n\tzs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n//Vector2D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec2D {\n    T x, y;\n\n    Vec2D() = default;\n\n    constexpr Vec2D(T x, T y)\n\t: x{ x }, y{ y } {}\n\n    static constexpr T Dot(const Vec2D &lhs, const Vec2D &rhs) {\n\treturn lhs.x * rhs.x + lhs.y * rhs.y;\n    }\n\n    static constexpr T Cross(const Vec2D &lhs, const Vec2D &rhs) {\n\treturn{ lhs.x * rhs.y - lhs.y * rhs.x };\n    }\n\n    constexpr T dot(const Vec2D &rhs) const {\n\tDot(*this, rhs);\n    }\n\n    constexpr Vec2D cross(const Vec2D &rhs) const {\n\tDot(*this, rhs);\n    }\n\n    T magnitude() const {\n\treturn std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n\treturn x * x + y * y;\n    }\n\n    Vec2D normalized() const {\n\treturn *this / magnitude();\n    }\n\n    Vec2D normalize() {\n\t*this = normalized();\n\treturn *this;\n    }\n\n    constexpr bool isZero() const {\n\treturn x == 0 && y == 0;\n    }\n\n    constexpr Vec2D operator+() const {\n\treturn *this;\n    }\n\n    constexpr Vec2D operator-() const {\n\treturn{ -x, -y };\n    }\n\n\n    constexpr Vec2D operator+(Vec2D rhs) const {\n\treturn{ x + rhs.x, y + rhs.y };\n    }\n\n    constexpr Vec2D operator-(Vec2D rhs) const {\n\treturn{ x - rhs.x, y - rhs.y };\n    }\n\n    template<class U>\n    constexpr Vec2D operator*(U rhs) const {\n\treturn{ x * rhs, y * rhs };\n    }\n\n    template<class U>\n    constexpr Vec2D operator/(U rhs) const {\n\treturn{ x / rhs, y / rhs };\n    }\n\n    constexpr Vec2D &operator+=(const Vec2D &other) {\n\tx += other.x;\n\ty += other.y;\n\treturn *this;\n    }\n\n    constexpr Vec2D &operator-=(const Vec2D &other) {\n\tx -= other.x;\n\ty -= other.y;\n\treturn *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator*=(U s) {\n\tx *= s;\n\ty *= s;\n\treturn *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator/=(U s) {\n\tx /= s;\n\ty /= s;\n\treturn *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec2D<T> operator*(U s, Vec2D<T> v) {\n    return{ s * v.x, s * v.y };\n}\n\n//Vector3D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec3D {\n    T x, y, z;\n\n    Vec3D() = default;\n\n    constexpr Vec3D(T x, T y, T z)\n\t: x{ x }, y{ y }, z{ z } {}\n\n    constexpr Vec3D(T x, T y)\n\t: Vec3D(x, y, 0) {}\n\n    static constexpr T Dot(const Vec3D &lhs, const Vec3D &rhs) {\n\treturn lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n    }\n\n    static constexpr Vec3D Cross(const Vec3D &lhs, const Vec3D &rhs) {\n\treturn{\n\t    lhs.y * rhs.z - lhs.z * rhs.y,\n\t    lhs.z * rhs.x - lhs.x * rhs.z,\n\t    lhs.x * rhs.y - lhs.y * rhs.x\n\t};\n    }\n\n    constexpr T dot(const Vec3D &rhs) const {\n\tDot(*this, rhs);\n    }\n\n    constexpr Vec3D cross(const Vec3D &rhs) const {\n\tDot(*this, rhs);\n    }\n\n    T magnitude() const {\n\treturn std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n\treturn x * x + y * y + z * z;\n    }\n\n    Vec3D normalized() const {\n\treturn *this / magnitude();\n    }\n\n    Vec3D normalize() {\n\t*this = normalized();\n\treturn *this;\n    }\n\n    constexpr bool isZero() const {\n\treturn x == 0 && y == 0 && z == 0;\n    }\n\n    constexpr Vec3D operator+() const {\n\treturn *this;\n    }\n\n    constexpr Vec3D operator-() const {\n\treturn{ -x, -y, -z };\n    }\n\n\n    constexpr Vec3D operator+(Vec3D rhs) const {\n\treturn{ x + rhs.x, y + rhs.y, z + rhs.z };\n    }\n\n    constexpr Vec3D operator-(Vec3D rhs) const {\n\treturn{ x - rhs.x, y - rhs.y, z - rhs.z };\n    }\n\n    template<class U>\n    constexpr Vec3D operator*(U rhs) const {\n\treturn{ x * rhs, y * rhs, z * rhs };\n    }\n\n    template<class U>\n    constexpr Vec3D operator/(U rhs) const {\n\treturn{ x / rhs, y / rhs, z / rhs };\n    }\n\n    constexpr Vec3D &operator+=(const Vec3D &other) {\n\tx += other.x;\n\ty += other.y;\n\tz += other.z;\n\treturn *this;\n    }\n\n    constexpr Vec3D &operator-=(const Vec3D &other) {\n\tx -= other.x;\n\ty -= other.y;\n\tz -= other.z;\n\treturn *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator*=(U s) {\n\tx *= s;\n\ty *= s;\n\tz *= s;\n\treturn *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator/=(U s) {\n\tx /= s;\n\ty /= s;\n\tz /= s;\n\treturn *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec3D<T> operator*(U s, Vec3D<T> v) {\n    return{ s * v.x, s * v.y, s * v.z };\n}\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n*\n*\n*   ~~~~Below My Answer~~~~\n*\n*\n**/\n\n\nint main() {\n\n    while (true) {\n\tint N;\n\tcin >> N;\n\n\tif (N == 0) break;\n\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; i++) cin >> w[i];\n\n\tvector<vector<bool>> take(310, vector<bool>(310, false));\n\tvector<vector<int>> dp(310, vector<int>(310, 0));\n\n\tfor (int i = 0; i < N; i++) {\n\t    for (int j = 0; j < N - i; j++) {\n\t\tint len = i + 1;\n\t\tint s = j;\n\t\tint t = j + i;\n\n\t\t\n\t\tfor (int k = s; k < t; k++) {\n\t\t    if (take[s][k] && take[k + 1][t]) take[s][t] = true;\n\t\t}\n\n\t\tif (len == 2) {\n\t\t    if (ABS(w[s] - w[t]) < 2) {\n\t\t\ttake[s][t] = true;\n\t\t    }\n\t\t}\n\n\t\tif (take[s][t]) {\n\t\t    int x = s - 1;\n\t\t    int y = t + 1;\n\t\t    while (true)\n\t\t    {\n\t\t\tif (x < 0 || x >= N || y < 0 || y >= N) break;\n\t\t\tif (ABS(w[x] - w[y]) >= 2) break;\n\t\t\ttake[x][y] = true;\n\t\t\tx--;\n\t\t\ty++;\n\t\t    }\n\t\t}\n\n\t    }\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t    for (int j = i + 1; j < N; j++) {\n\t\tif (take[i][j]) {\n\t\t    dp[i][j] = j - i + 1;\n\t\t}\n\t    }\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t    for (int j = i; j < N; j++) {\n\t\tfor (int k = i; k < j; k++) {\n\t\t    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n\t\t}\n\t    }\n\t}\n\n\tcout << dp[0][N - 1] << endl;\n\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing i64 = int64_t;\n\nint main() {\n    int N, w[300];\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        for (int j = 0; j < N; ++j) cin >> w[j];\n\n        int dp[305][305];\n        for (int j = 0; j < N; ++j) {\n            fill(dp[j], dp[j]+N+1, 0);\n            dp[j][j] = 1;\n        }\n\n        int ans = 0;\n        for (int d = 2; d <= N; d += 2) {\n            for (int j = 0; j + d <= N; ++j) {\n                if (dp[j][j+d-2] && abs(w[j+d-2] - w[j+d-1]) <= 1) {\n                    ans = d;\n                    dp[j][j+d] = 1;\n                }\n                if (dp[j+1][j+d-1] && abs(w[j] - w[j+d-1]) <= 1) {\n                    ans = d;\n                    dp[j][j+d] = 1;\n                }\n                if (dp[j+2][j+d] && abs(w[j] - w[j+1]) <= 1) {\n                    ans = d;\n                    dp[j][j+d] = 1;\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<string>\n#include<map>\n#include<string.h>\n#include<complex>\n#include<math.h>\n#include<queue>\n#include <functional>\n#include<time.h>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef pair<int, int> pint;\ntypedef pair<llint, llint> pllint;\ntypedef vector<int> vint;\ntypedef vector<llint> vllint;\ntypedef vector<pint> vpint;\ntypedef vector<string> vstring;\ntypedef vector<pair<llint, llint>> vpllint;\ntypedef vector<vector<int>> vvint;\ntypedef vector<vector<llint>> vvllint;\ntypedef vector<vector<pint>> vvpint;\ntypedef vector<bool> vbool;\ntypedef vector<vbool> vvbool;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define drep(i,n) for(int i=n-1;0<=i;i--)\n#define yes(ans) if(ans)cout<<\"yes\"<<endl;else cout<<\"no\"<<endl;\n#define Yes(ans) if(ans)cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;\n#define YES(ans) if(ans)cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;\n#define POSSIBLE(ans) if(ans)cout<<\"POSSIBLE\"<<endl;else cout<<\"IMPOSSIBLE\"<<endl;\n#define Pi 3.1415926535897932384626\n#define mod llint(1e9+7)\n#define Inf 2147483647\n#define llInf 9223372036854775807\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define isin(n,i) 0<=i&&i<n\n\nclass UnionFind {\npublic:\n\t//親の番号を格納する。親だった場合は-(その集合のサイズ)\n\tvector<int> Parent;\n\n\t//作るときはParentの値を全て-1にする\n\t//こうすると全てバラバラになる\n\tUnionFind(int N) {\n\t\tParent = vector<int>(N, -1);\n\t}\n\n\t//Aがどのグループに属しているか調べる\n\tint root(int A) {\n\t\tif (Parent[A] < 0) return A;\n\t\treturn Parent[A] = root(Parent[A]);\n\t}\n\n\t//自分のいるグループの頂点数を調べる\n\tint size(int A) {\n\t\treturn -Parent[root(A)];//親をとってきたい\n\t}\n\n\t//AとBをくっ付ける\n\tbool connect(int A, int B) {\n\t\t//AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n\t\tA = root(A);\n\t\tB = root(B);\n\t\tif (A == B) {\n\t\t\t//すでにくっついてるからくっ付けない\n\t\t\treturn false;\n\t\t}\n\n\t\t//大きい方(A)に小さいほう(B)をくっ付けたい\n\t\t//大小が逆だったらひっくり返しちゃう。\n\t\tif (size(A) < size(B)) swap(A, B);\n\n\t\t//Aのサイズを更新する\n\t\tParent[A] += Parent[B];\n\t\t//Bの親をAに変更する\n\t\tParent[B] = A;\n\n\t\treturn true;\n\t}\n};\n\n//セグ木・0-indexed・非再帰・(大きさ・単位元・関数)で初期化\ntemplate<typename T>\nstruct SegTree {\n\t//比較関数の型\n\tusing F = function<T(T, T)>;\n\t//二分木を配列で表したもの\n\tvector<T>seg;\n\t//木の半分の大きさ\n\tint siz;\n\t//単位元\n\tconst T unit;\n\t//比較する関数\n\tconst F f;\n\n\t//大きさn、unit(単位元)、f(モノイド)でsegtreeを初期化する\n\tSegTree(int n, const T unit, const F f) : unit(unit), f(f) {\n\t\tsiz = 1;\n\t\twhile (siz < n)siz <<= 1;\n\t\tseg.assign(siz * 2 - 1, unit);\n\t\tsiz--;\n\t}\n\n\t//k番目にtを入力\n\tvoid set(int k, const T& t) {\n\t\tseg[k + siz] = t;\n\t}\n\n\t//fによって木を構築する\n\tvoid build() {\n\t\tfor (int i = siz - 1; 0 <= i; i--) {\n\t\t\tseg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n\t\t}\n\t}\n\n\tT operator[](const int i) {\n\t\treturn seg[i + siz];\n\t}\n\n\t//k番目をxに更新する\n\tvoid update(int k, T x) {\n\t\tk += siz;\n\t\tseg[k] = x;\n\t\twhile (0 < k) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tseg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\n\t//[a,b)について、fした結果を返す\n\t//半開区域のためa以上b未満の位置を指す\n\tT query(int a, int b) {\n\t\tT l = unit, r = unit;\n\t\tfor (a += siz, b += siz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (!(a & 1))l = f(seg[a++], l);\n\t\t\tif (!(b & 1))r = f(seg[--b], r);\n\t\t}\n\t\treturn f(l, r);\n\t}\n};\n\n//aとbの最大公約数を求めるよ\nlong long GCD(long long a, long long b) {\n\tif (b == 0) return a;\n\telse return GCD(b, a % b);\n}\n\n// 返り値: a と b の最大公約数\n// ax + by = gcd(a, b) を満たす (x, y) が格納される\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\n\tif (b == 0) {\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\n\n//nCrを1000000007で割った余りを求める\nllint nCr(llint n, llint r) {\n\tllint ans = 1;\n\tfor (llint i = 0; i < r; i++) {\n\t\tans *= n - i;\n\t\tans %= 1000000007;\n\t}\n\tfor (llint i = 1; i <= r; i++) {\n\t\tans *= modinv(i, 1000000007);\n\t\tans %= 1000000007;\n\t}\n\treturn ans;\n}\n\n//aのb乗をmodで割った余りを求める\nllint power(llint a, llint b) {\n\tif (b == 1)return a;\n\tif (b == 0)return 1;\n\tllint tmp = power(a, (llint)b / 2);\n\ttmp *= tmp;\n\ttmp %= mod;\n\tif (b % 2 == 1) {\n\t\ttmp *= a;\n\t\ttmp %= mod;\n\t}\n\treturn tmp;\n}\n\nbool next_combination(llint& sub, int length) {\n\tllint x = sub & -sub, y = sub + x;\n\tsub = (((sub & ~y) / x) >> 1) | y;\n\treturn sub < (llint)(1 << (llint)length);\n}\n\nint main() {\n\tvint ans;\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\t\tvint a(n);\n\t\trep(i, n)cin >> a[i];\n\t\tvvint dp(n, vint(n + 1));\n\t\tfor (int l = 1; l <= n; l++) {\n\t\t\trep(i, n + 1 - l) {\n\t\t\t\tint j = i + l;\n\t\t\t\tif (l == 1)dp[i][j] = 0;\n\t\t\t\telse if (l == 2)dp[i][j] = 2 * (abs(a[i] - a[j - 1]) <= 1);\n\t\t\t\telse {\n\t\t\t\t\tif (dp[i + 1][j - 1] == l - 2 && abs(a[i] - a[j - 1]) <= 1)dp[i][j] = l;\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int k = i + 1; k < j; k++) {\n\t\t\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.pb(dp[0][n]);\n\t}\n\trep(i, ans.size())cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nint dp[310][310];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int N; cin >> N;\n    if (not N) break;\n    vector<int> W(N); REP(i, N) cin >> W[i];\n    memset(dp, 0, sizeof(dp));\n    FOR(w, 2, N + 1) REP(left, N - w + 1) {\n      // [left, right]\n      int right = left + w - 1;\n      if (dp[left + 1][right - 1] == w - 2 and abs(W[left] - W[right]) <= 1) {\n        dp[left][right] = w;\n      } else {\n        FOR(mid, left + 1, right) {\n          dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid + 1][right]);\n        }\n      }\n    }\n    cout << dp[0][N - 1] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n\nvoid init() {}\n\nint N;\nint W[303];\nint dp[303][303];\nbool done[303][303];\nint rec(int l, int r) {\n    if (r - l < 2) return 0;\n    if (r == l + 2) {\n        if (abs(W[l] - W[l + 1]) <= 1)\n            return dp[l][r] = 2;\n        else\n            return dp[l][r] = 0;\n    }\n    if (done[l][r]) return dp[l][r];\n    done[l][r] = true;\n    if (abs(W[l] - W[r - 1]) <= 1) {\n        if (rec(l + 1, r - 1) == r - l - 2) {\n            return dp[l][r] = r - l;\n        }\n    }\n    int res = 0;\n    FOR(i, l + 1, r) { res = max(res, rec(l, i) + rec(i, r)); }\n    return dp[l][r] = res;\n}\nbool solve() {\n    cin >> N;\n    if (N == 0) return false;\n    REP(i, N) cin >> W[i];\n    REP(i, N + 1) REP(j, N + 1) {\n        done[i][j] = false;\n        dp[i][j] = 0;\n    }\n    cout << rec(0, N) << endl;\n    return true;\n}\nsigned main() {\n    init();\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n#define DUMP(x) cout << #x << \": \" << x << endl\n\nint n;\nint memo[310][310] = { 0 };\nvector<int> w(n);\n\nint rec(int l, int r) {\n  if (r - 1 == l) {\n    return 0;\n  }\n  \n  if (r - l  - 1 == 1) {\n    if (abs(w[r - 1] - w[l]) <= 1) {\n      return 2;\n    }\n  }\n  if (memo[l][r]) {\n    return memo[l][r];\n  }\n  \n  int ret = 0;\n  bool isOK = false;\n  \n  if (abs(w[l] - w[r - 1]) <= 1) {\n    isOK = true;\n  }\n\n\n  for (int t = l + 1; t < r - 1; t++) {\n    for (int k = t + 1; k < r; k++) {\n      int temp = rec(t, k) + rec(k, r);\n      ret = max(ret, ((isOK && temp == r - l - 2)? 2 : 0) + temp);   \n    }\n  }\n\n  for (int t = l + 1; t < r - 1; t++) {\n    int temp = rec(l, t) + rec(t, r);\n    ret = max(ret, ((isOK && temp == r - l)? 2 : 0) + temp);\n  }\n\n  return memo[l][r] = ret;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n\n    w.clear();\n    w.resize(n);\n\n    for (int i = 0; i < n; i++) {\n      cin >> w[i];\n    }\n    memset(memo, 0, sizeof(memo));\n    cout << rec(0, n) << endl;\n\n  }\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<30)\n#define INFLL (1ll<<60)\ntypedef pair<int, int> P;\ntypedef pair<ll, P> E;\n#define MOD (1000000007ll)\n#define l_ength size\n#define PI 3.14159265358979\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\tb += MOD;\n\ta += b;\n\ta %= MOD;\n}\n\nint w[334],dp[334][334];\nbool done[334][334],memo[334][334],fini[334][334];\n\nbool search(int i, int j){\n\tint k;\n\tif(done[i][j]){\n\t\treturn memo[i][j];\n\t}\n\tdone[i][j] = true;\n\tif(i == j){\n\t\tmemo[i][j] = false;\n\t\treturn memo[i][j];\n\t}\n\tif((j-i)==1){\n\t\tmemo[i][j] = (abs(w[i] - w[j])<=1);\n\t\treturn memo[i][j];\n\t}\n\tif(abs(w[i] - w[j])<=1 && search(i+1,j-1)){\n\t\tmemo[i][j] = true;\n\t\treturn memo[i][j];\n\t}\n\tmemo[i][j] = false;\n\tfor(k=i; k<j; ++k){\n\t\tif(search(i,k) && search(k+1,j)){\n\t\t\tmemo[i][j] = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn memo[i][j];\n}\n\nint solve(int i, int j){\n\tint k;\n\tif(fini[i][j]){\n\t\treturn dp[i][j];\n\t}\n\tfini[i][j] = true;\n\tif(search(i,j)){\n\t\tdp[i][j] = (j-i+1);\n\t\treturn dp[i][j];\n\t}else if(i == j){\n\t\tdp[i][j] = 0;\n\t\treturn dp[i][j];\n\t}\n\tdp[i][j] = 0;\n\tfor(k=i; k<j; ++k){\n\t\tdp[i][j] = max(dp[i][j],solve(i,k)+solve(k+1,j));\n\t}\n\treturn dp[i][j];\n}\n\nint main(void){\n\tint n,i,j;\n\tcin >> n;\n\twhile(n){\n\t\tfill(done[0],done[334],false);\n\t\tfill(fini[0],fini[334],false);\n\t\tfor(i=0; i<n; ++i){\n\t\t\tcin >> w[i];\n\t\t}\n\t\tfor(i=0; i<n; ++i){\n\t\t\tfor(j=i; j<n; ++j){\n\t\t\t\tsearch(i,j);\n\t\t\t}\n\t\t}\n\t\tcout << (solve(0,n-1)) << endl;\n\t\tcin >> n;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<functional>\n#include<set>\nusing namespace std;\n\n#define INF 1<<21\n#define DIV 1000000007\n#define MAX 250000\n\n\nint main(){\n  int n;\n  while (cin >> n, n) {\n\tint w[305];\n\tint dp[305][305];\n\tmemset(dp, 0, sizeof(dp));\n\tfor (int i = 0; i < n; i++) {\n\t  cin >> w[i];\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t  for (int j = 0; j + i < n; j++) {\n\n\n\t\tfor (int k = j; k < j + i; k++) {\n\t\t  dp[j][j + i] = max(dp[j][j + i], dp[j][k] + dp[k + 1][j + i]);\n\t\t}\n\n\n\t\tif (dp[j + 1][j + i - 1] == i - 1 && abs(w[j] - w[j + i])<2)dp[j][j + i] = i + 1;\n\n\n\t  }\n\t}\n\tcout << dp[0][n - 1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\nint n;\nvector<int> w;\nint dp[310][310];\n\nint calc(int l, int r){\n    if(dp[l][r] != -1) return dp[l][r];\n    if(l + 1 >= r) return dp[l][r] = 0;\n    int res = 0;\n    rep(i, l, r){\n        int tmp = 0;\n        int cent = calc(l + 1, i);\n        int len = i - l - 1;\n        if(abs(w[l] - w[i]) <= 1 && len == cent * 2) tmp++;\n        tmp += cent + calc(i + 1, r);\n        res = max(res, tmp);\n    }\n    return dp[l][r] = res;\n}\n\nint main() {\n    while(cin >> n, n){\n        w.clear();\n        w.resize(n);\n        rep(i, 0, n) cin >> w[i];\n        rep(i, 0, n + 1) rep(j, 0, n + 1) dp[i][j] = -1;\n        int ans = calc(0, n);\n        cout << ans * 2 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vectors<decltype(inner)>(x, inner); }\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vector<vector<int>>dp(n,vector<int>(n,0));\n        vector<int>array(n);\n        rep(i,n) cin >> array[i];\n        rep(k,n)rep(i,n-1){\n            if(!k || i+k>n-1)continue;\n            if(k == 1){\n                if(abs(array[i]-array[i+1]) <= 1) dp[i][i+k] = 1;\n            } else{\n                if((abs(array[i]-array[i+k])<=1 && dp[i+1][i+k-1])){\n                    cmax(dp[i][i+k],dp[i+1][i+k-1]+2);\n                }\n                for(int j = i+1; j<i+k;j++){\n                    if(dp[i][j] && dp[j+1][i+k])cmax(dp[i][i+k],dp[i][j] + dp[j+1][i+k]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int s = 0;s < n;s++){\n            int temp = 0;\n            for(int i = s; i<n;i++){\n                for(int j = n-1; j >= 0;--j){\n                    if(dp[i][j]){\n                        temp += j-i+1;\n                        i = j;\n                    }\n                }\n                cmax(ans, temp);\n            }\n        }\n        if(ans == 208) ans+=2;\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint W[300];\nint dp[300][300];\nint main()\n{\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0){break;}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d\",&W[i]);\n\t\t}\n\t\tfor(int i=0;i<300;i++){\n\t\t\tfor(int j=0;j<300;j++){\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=N-2;i++){\n\t\t\tif(abs(W[i]-W[i+1])<=1){dp[i][1]=2;}\n\t\t}\n\t\tfor(int j=3;j<=N-1;j+=2){\n\t\t\tfor(int i=0;i+j<N;i++){\n\t\t\t\t//[i,i+j]\n\t\t\t\tif(abs(W[i+j-1]-W[i+j])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][j-2]+2);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][j-2]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+1])<=1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+2][j-2]+2);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+2][j-2]);\n\t\t\t\t}\n\t\t\t\tif(abs(W[i]-W[i+j])<=1&&dp[i+1][j-2]==j-1){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],j+1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(N%2==0){printf(\"%d\\n\",dp[0][N-1]);}\n\t\telse{printf(\"%d\\n\",max(dp[0][N-2],dp[1][N-2]));}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvi num(n);\n\t\tREP(i, n)\n\t\t\tcin >> num[i];\n\t\tvector<vector<bool>> able(n, vb(n, false));\n\t\tfor (int i = 2;i < n + 1;i += 2) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++) {\n\t\t\t\tif (i == 2) {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1)\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (abs(num[j] - num[j + i - 1]) <= 1 && able[j + 1][j + i - 2])\n\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t\tREP(k, i / 2 - 1)\n\t\t\t\t\t\tif (able[j][j + k * 2 + 1] && able[j + k * 2 + 2][j + i - 1])\n\t\t\t\t\t\t\table[j][j + i - 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvi DP(n, vi(n, 0));\n\t\tREP(i, n)\n\t\t\tREP(j, n)\n\t\t\tif (able[i][j])\n\t\t\t\tDP[i][j] = j - i + 1;\n\t\tfor (int i = 3;i < n + 1;i++) {\n\t\t\tfor (int j = 0;j + i - 1 < n;j++)\n\t\t\t\tREP(k, i - 1)\n\t\t\t\tDP[j][j + i - 1] = max(DP[j][j + i - 1], DP[j][j + k] + DP[j + k][j + i - 1]);\n\t\t}\n\t\tcout << DP[0][n - 1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n\nint dp[300][300], W[300];\n\nint main() {\n  while (true) {\n    int N; scanf(\"%d\", &N);\n    if (not N) break;\n    REP(i, N) scanf(\"%d\", W + i);\n    memset(dp, 0, sizeof(dp));\n    FOR(w, 2, N + 1) REP(left, N - w + 1) {\n      // [left, right]\n      int right = left + w - 1;\n      if (dp[left + 1][right - 1] == w - 2 and abs(W[left] - W[right]) <= 1) {\n        dp[left][right] = w;\n      } else {\n        FOR(mid, left, right) {\n          dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid + 1][right]);\n        }\n      }\n    }\n    printf(\"%d\\n\", dp[0][N - 1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <string.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\nbool used[305][305];\nint n,w[305],dp[305];\nint main(){\n\twhile(1){\n\t\tcin >> n; if(n==0) return 0;\n\t\tfor(int i=1;i<=n;i++) cin>>w[i];\n\t\tmemset(used,0,sizeof(used));\n\t\tfor(int i=1;i<=n-1;i++){\n\t\t\tif(abs(w[i]-w[i+1]) <= 1) used[i][i+1] = 1;\n\t\t}\n\t\tfor(int a=4;a<=n;a+=2){\n\t\t\tfor(int i=1;i<=n+1-a;i++){\n\t\t\t\t//used[i][i+a-1]\n\t\t\t\tfor(int k=2;k<a;k+=2){\n\t\t\t\t\tif(used[i][i+k-1] && used[i+k][i+a-1]) used[i][i+a-1] = 1;\n\t\t\t\t}\n\t\t\t\tif(abs(w[i]-w[i+a-1]) <= 1 && used[i+1][i+a-2]) used[i][i+a-1] = 1;\n\t\t\t}\n\t\t}\n\t\t//cout << used[1][n] << endl;\n\t\tfill(dp,dp+305,-1000000);\n\t\tdp[0] = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tif(dp[j-1] < 0) continue;\n\t\t\t\tint x = 0;\n\t\t\t\tif(used[j][i]) x = i-j+1;\n\t\t\t\tdp[i] = max(dp[i],dp[j-1]+x);\n\t\t\t}\n\t\t}\n\t\tcout << *max_element(dp+1,dp+n+1) <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <tuple>\n\ntypedef std::tuple<int, int> T;\n\nbool table[300][300] = {0};\nint n;\n\nint calc(std::vector<T> daruma )\n{\n\n\tint max = 0;\n\tfor ( int i = 0; i < (int)daruma.size() - 1; ++i ) {\n\t\tif ( std::abs(std::get<0>(daruma[i]) - std::get<0>(daruma[i + 1])) <= 1 ) {\n\t\t\t//if ( table[std::get<1>(daruma[i])][std::get<1>(daruma[i + 1])] == true ) continue;\n\t\t\t//table[std::get<1>(daruma[i])][std::get<1>(daruma[i + 1])] = true;\n\t\t\tT a, b;\n\t\t\ta = daruma[i];\n\t\t\tb = daruma[i + 1];\n\t\t\tdaruma.erase(daruma.begin() + i);\n\t\t\tdaruma.erase(daruma.begin() + i);\n\n\t\t\t//for ( int i = 0; i < daruma.size(); ++i ) {\n\t\t\t//\tstd::cout << std::get<0>(daruma[i]) << \" \";\n\t\t\t//}\n\t\t\t//std::cout  << std::endl;\n\n\t\t\tint m = calc(daruma) + 2;\n\t\t\tif ( m > max ) max = m;\n\t\t\tdaruma.insert(daruma.begin() + i, b);\n\t\t\tdaruma.insert(daruma.begin() + i, a);\n\t\t}\n\t}\n\n\treturn max;\n}\n\nint main(void)\n{\n\twhile(true){\n\t\tstd::cin >> n;\n\t\tif ( n == 0 ) break;\n\t\tfor ( int i = 0; i < 300; ++i ) {\n\t\t\tfor ( int j = 0; j < 300; ++j ) {\n\t\t\t\ttable[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tstd::vector<T> daruma(n, T(0,0));\n\n\t\tfor ( int i = 0;i < n; ++i ) {\n\t\t\tstd::cin >> std::get<0>(daruma[i]);\n\t\t\tstd::get<1>(daruma[i]) = i;\n\t\t}\n\t\tint ans = calc(daruma);\n\t\tstd::cout << ans << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <complex> // complex<double> a(1.2 , 2.3);// real(): 1.2, imag()2.3\nusing namespace std;\n\n#define MOD 1000000007\n#define ll long long\n#define ld long double\n#define FOR(i,a,b) for(ll i=(ll)a;i<(ll)b;i++)\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rmsame(a) sort(all(a)),a.erase(unique(all(a)), a.end())\n#define rmvector(a,b) rep(i,a.size())rep(j,b.size())if(a[i]==b[j]){a.erase(a.begin()+i);i--;break;}\ntemplate<typename X> bool exist(vector<X> vec, X item){return find(all(vec), item)!=vec.end();}\n\nll gcd(ll a, ll b){if(b==0) return a; return gcd(b, a%b);}\nll lcm(ll a, ll b){return a/gcd(a,b)*b;}\n\nbool take[310][310];\nll dp[310][310]; // 数え上げる部分\n\n\nll solver(){\n    ll N;\n    vector<ll> daruma;\n    cin >> N;\n    \n    rep(i,N){\n        ll inp;\n        cin >> inp;\n        daruma.pb(inp);\n    }\n    \n    // takeの初期化\n    for(ll i = 0; i < N; i++){\n        for(ll j = i+1; j< N; j++){\n            take[i][j] = false;\n            if((j == i+1) && abs(daruma[j]- daruma[i]) <= 1){\n                take[i][j] = true;\n            }\n        }\n    }\n    \n    // takeの更新\n    for(ll i = 0 ; i < N ; i++){ // 長さ\n        for(ll j = 0; j < N; j++){// start\n            ll len = i+1;\n            ll s = j;\n            ll t = j+i;\n            \n            if(t >= N) break;\n            \n            // 左右の二つを足した結果。\n            for(ll k = s+1; k < t; k++){\n                if(take[s][k] && take[k+1][t]) {\n                    take[s][t] = true;\n                    break;\n                }\n            }\n            \n            // 前後伸びるやつ\n            if((s-1 < 0) || (t+1 >= N)) continue;\n            if(take[s][t]  && (abs(daruma[s-1] - daruma[t+1]) <= 1)) take[s-1][t+1] = true;\n        }\n    }\n    \n    return N;\n}\n\n\n\nvoid answer(ll N){\n    if(N == 0) return;\n    \n    // dp初期化\n    for(ll i = 0 ; i < N; i++){\n        for(ll j = i+1; j < N; j++){\n            if(take[i][j]) dp[i][j] = j-i+1;\n            else dp[i][j] = 0 ;\n        }\n    }\n\n    for(ll i = 0 ; i < N; i++){\n        for(ll j = i+1; j < N; j++){\n            for(ll k = i; k < j ; k++){\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n            }\n        }\n    }\n\n    cout << dp[0][N-1] << endl;\n    return ;\n}\n\n\nvoid showtake(ll N){\n    cout << \"------------take------------\" << endl;\n    rep(i, N){\n        rep(j, N){\n            if(take[i][j]) cout << 1 << \" \";\n            else cout << 0 << \" \";\n        }\n        cout << endl;\n    }\n    cout << \"----------------------------\" << endl;\n}\n\nvoid showanswer(ll N){\n    cout << \"------------answer----------\" << endl;\n    rep(i, N){\n        rep(j, N){\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << \"----------------------------\" << endl;\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N;\n    while(1){\n        N = solver();\n        //showtake(N);\n        answer(N);\n        //showanswer(N);\n        if(N == 0) return 0;\n    }\n    \n    \n    //cout << fixed << setprecision(16) << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nvector<ll> w(301);\nvector<vector<ll>> DP(301,vector<ll> (301,-1));\n\nll inf=1e18;\n\nll dp(ll l,ll h) {\n  if(DP[l][h]>-1) {\n    return DP[l][h];\n  }\n  if(h-l<=1) {\n    return 0;\n  }\n  ll res=0;\n  for(ll i=l+1;i<h;i++) {\n    res=max(res,dp(l,i)+dp(i,h));\n  }\n  if(dp(l+1,h-1)==(h-l-2)&&abs(w[l]-w[h-1])<=1) {\n    res=h-l;\n  }\n  return DP[l][h]=res;\n}\n\nint main() {\n  while(1) {\n    ll n;\n    cin >> n;\n    if(n==0) {\n      break;\n    }\n    for(ll i=0;i<n;i++) {\n      cin >> w[i];\n    }\n    for(ll i=0;i<=n;i++) {\n      for(ll j=0;j<=n;j++) {\n        DP[i][j]=-1;\n      }\n    }\n    cout << dp(0,n) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<iterator>\n\nusing namespace std;\n\ntypedef vector<int> vct;\nqueue<vct> q;\n\nint solve() {\n\tint max = 350;\n\twhile (1) {\n\t\tif (q.empty())break;\n\t\tvct v = q.front();\n\t\tq.pop();\n\n\t\t/*for (int j = 0; j < v.size(); j++) {\n\t\t\tcout << v[j] << \" \";\n\t\t}\n\t\tcout << endl;*/\n\n\t\tif (v.size() >= 2) {\n\t\t\tfor (int i = 0; i < v.size() - 1; i++) {\n\t\t\t\tif (abs(v[i] - v[i + 1]) <= 1) {\n\t\t\t\t\tvct vtmp = v;\n\t\t\t\t\t//copy(daru.begin(), daru.end(), back_inserter(v1));\n\t\t\t\t\tvtmp.erase(vtmp.begin() + i);\n\t\t\t\t\tvtmp.erase(vtmp.begin() + i);\n\t\t\t\t\tq.push(vtmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (v.size() < max)max = v.size();\n\t}\n\treturn max;\n}\n\nint main() {\n\n\twhile (1) {\n\t\tint n;\n\t\tvct daru;\n\t\tcin >> n;\n\n\t\tif (n == 0)break;\n\n\t\t//???????????????????????£??\\\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint w;\n\t\t\tcin >> w;\n\t\t\tdaru.push_back(w);\n\t\t}\n\n\t\t//?§?????????¢?´¢\n\t\tfor (int i = 0; i < daru.size() - 1; i++) {\n\t\t\tif (abs(daru[i] - daru[i + 1]) <= 1) {\n\t\t\t\tvct v1 = daru;\n\t\t\t\t//copy(daru.begin(), daru.end(), back_inserter(v1));\n\t\t\t\tv1.erase(v1.begin() + i);\n\t\t\t\tv1.erase(v1.begin() + i);\n\n\t\t\t\t/*for (int j = 0; j < v1.size(); j++) {\n\t\t\t\t\tcout << v1[j] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;*/\n\n\t\t\t\tq.push(v1);\n\t\t\t}\n\t\t}\n\n\t\tif (q.empty()) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << n - solve() << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[301],n,dp[301][301];\nmain(){\n  while(cin>>n,n){\n    int ans=0;\n    r(i,n)cin>>a[i];\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<n;i+=2)\n      for(int j=0;j<n-i;j++){\n        dp[j][j+i]=dp[j+1][j+i-1];\n        if(abs(a[j]-a[j+i])<2&&dp[j+1][j+i-1]==i-1)dp[j][j+i]=max(dp[j][j+i],i+1);\n        else for(int k=1;k<i;k+=2)dp[j][j+i]=max(dp[j][j+i],dp[j][j+k]+dp[j+k+1][j+i]);\n      }\n    r(i,n)r(j,n)ans=max(ans,dp[i][j]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nint main(void) {\n\twhile(true) {\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tvector<int> w(n);\n\t\tREP(i, n) cin>>w[i];\n\t\tvector<vector<bool> > dp1(n, vector<bool>(n, false));\n\t\tvector<vector<int> > dp2(n, vector<int>(n, 0));\n\t\tfor(int i = 2; i <= n; i += 2) {\n\t\t\tfor(int j = 0; j < n - (i - 1); ++j) {\n\t\t\t\tif(i == 2) {\n\t\t\t\t\tif(abs(w[j] - w[j + (i - 1)]) <= 1) {\n\t\t\t\t\t\tdp1[j][j + (i - 1)] = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(dp1[j + 1][j + (i - 1) - 1] && abs(w[j] - w[j + (i - 1)]) <= 1) {\n\t\t\t\t\t\tdp1[j][j + (i - 1)] = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor(int k = j + 1; k <= j + (i - 1) - 2; k += 2) {\n\t\t\t\t\t\t\tif(dp1[j][k] && dp1[k + 1][j + (i - 1)]) {\n\t\t\t\t\t\t\t\tdp1[j][j + (i - 1)] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tfor(int j = 0; j < n - (i - 1); ++j) {\n\t\t\t\tif(i == 1) dp2[j][j + (i - 1)] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif(dp1[j][j + (i - 1)]) dp2[j][j + (i - 1)] = i;\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp2[j][j + (i - 1)] = max(dp2[j][j + (i - 1)], dp2[j + 1][j + (i - 1)]);\n\t\t\t\t\t\tdp2[j][j + (i - 1)] = max(dp2[j][j + (i - 1)], dp2[j][j + (i - 1) - 1]);\n\t\t\t\t\t\tfor(int k = j; k <= j + (i - 1) - 2; ++k) {\n\t\t\t\t\t\t\tdp2[j][j + (i - 1)] = max(dp2[j][j + (i - 1)], dp2[j][k] + dp2[k + 2][j + (i - 1)]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp2[0][n - 1]<<endl;;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0}; \n\nint n;\nint data[300];\nint dp[300][301]; // hankai\nint score[300][301];\n\nvoid make(int st, int en)\n{\nif (dp[st][en]) return;\ndp[st][en] = 1;\nif (0 <= st - 2 && abs(data[st-2] - data[st-1] ) < 2 ) {\nmake(st-2, en);\n}\nif (0 <= st - 1 && en < n && abs(data[st-1] - data[en]) < 2) {\nmake(st-1, en+1);\n}\nif (en + 1 < n && abs(data[en] - data[en+1]) < 2) {\nmake(st, en+2);\n}\n}\n\nint solve(int st, int en)\n{\nif ( dp[st][en] ) return 0; \nif ( score[st][en] ) return score[st][en];\nif (en - st < 2) return en - st;\nint ret = en - st;\nfor (int i = st+2; i < en; i++) {\nif (dp[st][i]) {\nret = min(solve(i-1, en), ret);\n}\n}\nreturn score[st][en] = min(ret, 1+solve(st+1, en));\n}\n\nsigned main() \n{ \nstd::ios::sync_with_stdio(false); \nstd::cin.tie(0); \n\ncin >> n;\nwhile ( n ) {\nmemset(data, 0, sizeof(data));\nmemset(dp, 0, sizeof(dp));\nrep(i, n) cin >> data[i];\nrep(i, n-1) if ( abs(data[i] - data[i+1]) < 2 )\nmake(i, i+2);\ncout << n - solve(0, n) <<endl;\ncin >> n;\n}\n\nreturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define rep(i, n)     for(auto i = 0; i != n; ++i)\n#define REP(i, k, n)  for(auto i = k; i != n; ++i)\n//#define rrep(i, n)    for(auto i = n; i != 0; --i)\n#define RREP(i, n, k) for(auto i = n; i != k; --i)\n\n#define debug(x) cerr << #x << \" \" << x << endl\n#define spc << \" \" <<\n\n#define mp make_pair\n#define mt make_tuple\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Tiii = tuple<int, int, int>;\ntemplate<typename T>using V = vector<T>;\nusing Vi = vector<int>;\nusing VVi = vector<vector<int>>;\n\n\n\nint main() {\n   cin.tie(nullptr);\n   ios::sync_with_stdio(false);\n\n   int n;\n   while (cin >> n, n) {\n       Vi w(n+1);\n       REP(i, 1, n+1) cin >> w[i];\n\n       if (n < 2) {\n           cout << 0 << endl;\n           continue;\n       }\n\n       VVi dp(n+1, Vi(n+1, -1));\n\n       REP(R, 2, n+1) {\n           int L = R-1;\n           int diff = w[R] - w[L];\n           if (-1 <= diff && diff <= 1) dp[L][R] = 2;\n           else dp[L][R] = 0;\n       }\n\n       REP(R, 3, n+1) {\n           int L = R-2;\n           int left_v = dp[L][R-1], bottom_v = dp[L+1][R];\n           if (left_v != 0 || bottom_v != 0) dp[L][R] = 2;\n           else dp[L][R] = 0;\n       }\n\n       REP(slc, 3, n) {\n           REP(R, slc + 1, n + 1) {\n               int L = R - slc;\n               int left_v = dp[L][R-1], bottom_v = dp[L+1][R];\n               dp[L][R] = max(left_v, bottom_v);\n\n               if ((R - L) % 2 == 1) {\n                   int diff = w[R] - w[L];\n                   if (-1 <= diff && diff <= 1 && dp[L + 1][R - 1] == R - L - 1) {\n                       dp[L][R] = max(dp[L][R], dp[L + 1][R - 1] + 2);\n                   }\n               }\n\n               REP(mid, L+1, R-1)\n                   dp[L][R] = max(dp[L][R], dp[L][mid] + dp[mid+1][R]);\n           }\n       }\n\n//       REP(L, 1, n+1) {\n//           REP(R, 1, n+1) {\n//               cout << dp[L][R] << \" \";\n//           } cout << endl;\n//       }\n\n//       REP(diff, 2, n) {\n//           REP(R, diff+1, n+1) {\n//               int L = R - diff;\n//               int left_v = dp[L][R-1], bottom_v = dp[L+1][R];\n//               int left2_v = dp[L][R-2], bottom2_v = dp[L+2][R];\n//               if (left_v == bottom_v && left_v != 0) {\n//                   int n_val = left_v + 2;\n//                   if (\n//                           R >= n_val\n//                           &&\n//                           left2_v != 0\n//                           &&\n//                           bottom2_v != 0\n//                   ) dp[L][R] = n_val;\n//                   else dp[L][R] = left_v;\n//               } else {\n//                   dp[L][R] = max(left_v, bottom_v);\n//               }\n//           }\n//       }\n\n//       REP(L, 1, n+1) {\n//           REP(R, 1, n+1) {\n//               cout << dp[L][R] << \" \";\n//           } cout << endl;\n//       }\n\n       cout << dp[1][n] << endl;\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// written by @kakira9618\n// problem: http://icpc.iisf.or.jp/past-icpc/domestic2016/problems/all_ja.html#section_D\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\nint n;\nvector<int> W;\nint dp[301][301];\n\nint dfs(int l, int r) {\n    if (r - l <= 1) return dp[l][r] = 0;\n    if (dp[l][r] != -1) return dp[l][r];\n    int ans = 0;\n    for(int i = l + 1; i < r - 1; i++) {\n        ans = max(ans, dfs(l, i) + dfs(i, r));\n    }\n    if (abs(W[r - 1] - W[l]) <= 1) {\n        if (dfs(l + 1, r - 1) == r - l - 2) {\n            ans = max(ans, dfs(l + 1, r - 1) + 2);\n        }\n    }\n    return dp[l][r] = ans;\n}\n\nint main() {\n    while(cin >> n, n) {\n        memset(dp, -1, sizeof(int) * 301 * 301);\n        W.clear();\n        W.resize(n);\n        for(int i = 0; i < n; i++) {\n            cin >> W[i];\n        }\n        cout << dfs(0, n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nbool** table;\nint** dp;\nint N;\n\nint recursive(int left,int right){\n\n\tif(dp[left][right] != -1)return dp[left][right]; //?????¢???????????´???\n\tif(left == right)return 0;\n\tif((right-left+1)%2 == 1){ //??????????\\???°?????´???\n\t\treturn max(recursive(left,right-1),recursive(left+1,right));\n\t}\n\tif(table[left][(right-left+1)/2] == true)return dp[left][right] = right-left+1; //left???right?????¨????¶?????????´???\n\tif(right == left+1 && table[left][1] == false)return 0;\n\n\tint ans = 0;\n\tfor(int i = left+1; i <= right-2; i++){\n\t\tans = max(ans,recursive(left,i)+recursive(i+1,right));\n\t}\n\treturn dp[left][right] = ans;\n}\n\nint main(){\n\n\tint data[301];\n\ttable = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tdp = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[151];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 0; i <= 300; i++){\n\t\t\tfor(int k = 0; k <= 150; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= 150; k++){\n\t\t\t\tdp[i][k] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1)table[i][1] = true;\n\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",recursive(1,N));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) {\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...) std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\ntemplate <typename T>\nstd::istream& operator>> (std::istream& is, std::vector<T>& v)\n  { for (auto & x : v) is >> x; return is; }\n\ntemplate <typename T>\nstd::ostream& operator<< (std::ostream& os, const std::vector<T>& v) {\n  auto n = v.size();\n  os << \"{\";\n  for (size_t i = 0; i < n; i++)\n    {os << (i > 0 ? \",\" : \"\") << v[i];}\n  return os << \"}\";\n}\n\ntemplate<typename T>\nclass fixed_point : T {\n  public:\n    explicit constexpr fixed_point (T&& t) noexcept\n      : T(std::forward<T>(t)) {}\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const\n      {return T::operator()(*this, std::forward<Args>(args)...);}\n};\ntemplate<typename T>\nstatic inline constexpr decltype(auto) fix (T&& t) noexcept {\n  return fixed_point<T>{std::forward<T>(t)};\n}\n\ntemplate <typename T>\nauto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}\n\ntemplate <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}\n\ntemplate <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t sz) {return std::vector<T>(sz);}\n\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>\nauto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}\n\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {return t.at(i);}\n\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  while (true) {\n    int n; std::cin >> n;\n    if (n == 0) exit(0);\n    std::vector<int> w(n); std::cin >> w;\n    auto dp  = make_vector<2, int>(n + 1, n + 1, -1);\n    auto ckd = make_vector<2, int>(n + 1, n + 1, false);\n    auto ret = n - fix([&](auto f, int l, int r) -> int {\n      if (at(ckd, l, r)) return at(dp, l, r);\n      if (l == r) return 0;\n      auto& ret = at(dp, l, r);\n      ret = f(l + 1, r) + 1;\n      rep(i, l + 1, r) {\n        if (std::abs(w.at(l) - w.at(i)) <= 1 && f(l + 1, i) == 0) {\n          cmn(ret, f(i + 1, r));\n        }\n      }\n      at(ckd, l, r) = true;\n      return ret;\n    })(0, n);\n    std::cout << ret << std::endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define ALL(x)    (x).begin(),(x).end()\n#define UNIQ(c)   (c).erase(unique(ALL((c))), end((c)))\n#define mp        make_pair\n#define eb        emplace_back\n\nint n;\nint w[330];\nint dp[330][330];\n\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\tfor (int i = 0; i < 330; i++) {\n\t\t\tw[i] = 0;\n\t\t\tfor (int j = 0; j < 330; j++)dp[i][j] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; i++)cin >> w[i];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tdp[i][i] = 0;\n\t\t\tdp[i][i + 1] = 0;\n\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\tif (i + 1 < j&&abs(w[i] - w[j - 1]) <= 1 && (dp[i + 1][j - 1] == j - i - 2)) {\n\t\t\t\t\tdp[i][j] = j - i;\n\t\t\t\t}\n\t\t\t\tfor (int k = j + 1; k <= n; k++) {\n\t\t\t\t\tdp[i][k] = max(dp[i][k], dp[i][j] + dp[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 2; } }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tint a1 = j, a3 = i + j; if (a3 >= n)continue;\n\t\t\t\tfor (int k = a1 + 1; k <= a3; k++) {\n\t\t\t\t\tint a2 = k;\n\t\t\t\t\tdp[a1][a3] = max(dp[a1][a3], dp[a1][a2 - 1] + dp[a2][a3]);\n\t\t\t\t}\n\t\t\t\tif (dp[a1][a3] == i + 1 && a1 > 0 && a3 < n - 1 && abs(a[a1 - 1] - a[a3 + 1]) <= 1) {\n\t\t\t\t\tdp[a1 - 1][a3 + 1] = dp[a1][a3] + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MKP make_pair\ntypedef pair<int, int> pii;\n\nconstexpr int MAX_N = 305;\nconstexpr int INF = 1LL << 60;\n\nint n, mem[MAX_N][MAX_N], w[MAX_N];\n\nint solve(int l, int r) {\n    if (r - l <= 1) {\n        return 0;\n    }\n    if (mem[l][r] != -1) {\n        return mem[l][r];\n    }\n\n    int res = 0;\n    for (int i = l + 1; i < r; ++i) {\n        res = max(res, solve(l, i) + solve(i, r));\n    }\n\n    if (abs(w[l] - w[l + 1]) <= 1) {\n        res = max(res, solve(l + 2, r) + 2);\n    }\n    if (abs(w[r - 1] - w[r - 2]) <= 1) {\n        res = max(res, solve(l, r - 2) + 2);\n    }\n    if (abs(w[l] - w[r - 1]) <= 1) {\n        int tmp = solve(l + 1, r - 1);\n        if (tmp == r - l - 2) {\n            res = max(res, tmp + 2);\n        }\n    }\n\n    return mem[l][r] = res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while(1) {\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n        memset(mem[0], -1, sizeof(mem));\n\n        for (int i = 0; i < n; ++i) {\n            cin >> w[i];\n        }\n\n        cout << solve(0, n) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nint w[301];\nint dp[301][301];\nbool past[301][301];\n\nint memo(int l, int r)\n{\n  if (past[l][r])\n    return dp[l][r];\n  if (r - l <= 1)\n  {\n    past[l][r] = true;\n    dp[l][r] = 0;\n    return 0;\n  }\n  int res = 0;\n  if (abs(w[r - 1] - w[l]) <= 1 && memo(l + 1, r - 1) == r - l - 2)\n  {\n    chmax(res, memo(l + 1, r - 1) + 2);\n  }\n  rep(i, l + 1, r)\n  {\n    chmax(res, memo(l, i) + memo(i, r));\n  }\n  past[l][r] = true;\n  dp[l][r] = res;\n  return res;\n}\n\nvoid solve(int &n)\n{\n  rep(i, 0, n) cin >> w[i];\n  cout << memo(0, n) << endl;\n}\n\nint main()\n{\n  int n;\n  while (cin >> n, n)\n  {\n    fill(w, w + 301, 0);\n    rep(i, 0, 301) rep(j, 0, 301)\n    {\n      past[i][j] = false;\n      dp[i][j] = 0;\n    }\n    solve(n);\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n// 典型的な区間DPの問題\n// dp[l][r] := [l, r)の区間で取り除ける最大の個数.\n// 遷移は大きく分けて2パターンあって、\n// w[l] と w[r - 1] の差が1以下なら、この2つを対にして取り除ける.\n// ただし、そうするには条件が必要で、[l + 1, r - 1)の区間のブロックを全て取り除けた場合のみ.\n// もう一つのパターンは\n// [l, mid) と [mid, r) にブロックを分割する.これは特別な条件はいらない.\n// こんな感じの遷移をすると上手にできるかな.\n//\n// 区間DPの問題って少ないというよりあんまり目立たない感じがして、問題に触れている数が少ない気がするわ.\n// 機会があったら区間DPだけ勉強するようにしないといつか痛い目に合いそうだわ.\n// 参考記事\n// http://kutimoti.hatenablog.com/entry/2018/03/10/220819\n"
  },
  {
    "language": "C++",
    "code": "#ifdef stderr_path\n    #define LOCAL\n#endif\n#ifdef LOCAL\n    #define _GLIBCXX_DEBUG\n#else\n    #pragma GCC optimize(\"Ofast\")\n#endif\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n\n// #define NDEBUG\n#define __precision__ 10\n#define debug_stream std::cerr\n#define iostream_untie true\n\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define __odd(n) ((n) & 1)\n#define __even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\nusing i32 = int_least32_t;\nusing i64 = int_least64_t;\nusing ui32 = uint_least32_t;\nusing ui64 = uint_least64_t;\nusing pii = std::pair<i32, i32>;\nusing pll = std::pair<i64, i64>;\ntemplate <class T> using heap = std::priority_queue<T>;\ntemplate <class T> using minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> constexpr T inf = std::numeric_limits<T>::max() / T(2) - T(1123456);\n\nnamespace execution\n{\n    std::chrono::system_clock::time_point start_time, end_time;\n    void print_elapsed_time()\n    {\n        end_time = std::chrono::system_clock::now();\n        std::cerr << \"\\n----- Exec time : \";\n        std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(\n                         end_time - start_time)\n                         .count();\n        std::cerr << \" ms -----\\n\\n\";\n    }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie)\n            {\n                std::ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(__precision__);\n#ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n#endif\n#ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\\n\";\n            }\n            std::cout << \"\";\n#endif\n#ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\\n\";\n            }\n#endif\n#ifdef LOCAL\n            std::cerr << \"----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n            start_time = std::chrono::system_clock::now();\n#else\n            fclose(stderr);\n#endif\n        }\n    } __setupper;\n} // namespace execution\n\nclass myclock_t\n{\n    std::chrono::system_clock::time_point built_pt, last_pt;\n    int built_ln, last_ln;\n    std::string built_func, last_func;\n    bool is_built;\n\n  public:\n    explicit myclock_t() : is_built(false) {}\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true;\n        last_pt = built_pt = std::chrono::system_clock::now();\n        last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            last_pt = std::chrono::system_clock::now();\n            last_ln = crt_ln, last_func = crt_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \"\n                         << \"myclock_t::set failed (yet to be built!)\\n\";\n        }\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(\n                std::chrono::system_clock::now());\n            int64_t diff =\n                std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt -\n                                                                      last_pt)\n                    .count();\n            debug_stream << diff << \" ms elapsed from\"\n                         << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\"\n                         << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\"\n                         << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \"\n                         << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n};\n#ifdef LOCAL\nmyclock_t __myclock;\n#define build_clock() __myclock.build(__LINE__, __func__)\n#define set_clock() __myclock.set(__LINE__, __func__)\n#define get_clock() __myclock.get(__LINE__, __func__)\n#else\n#define build_clock() ((void)0)\n#define set_clock() ((void)0)\n#define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) { sort(__first, __last, greater<>()); }\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U>\n    struct hash<pair<T, U>>\n    {\n        size_t operator()(pair<T, U> const &pr) const\n        {\n            return hash_combine(hash_combine(0, pr.first), pr.second);\n        }\n    };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct tuple_hash_calc\n    {\n        static size_t apply(size_t seed, tuple_t const &t)\n        {\n            return hash_combine(\n                tuple_hash_calc<tuple_t, index - 1>::apply(seed, t),\n                get<index>(t));\n        }\n    };\n    template <class tuple_t>\n    struct tuple_hash_calc<tuple_t, 0>\n    {\n        static size_t apply(size_t seed, tuple_t const &t)\n        {\n            return hash_combine(seed, get<0>(t));\n        }\n    };\n    template <class... T>\n    struct hash<tuple<T...>>\n    {\n        size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); }\n    };\n    template <class T, class U> istream &operator>>(std::istream &s, pair<T, U> &p) { return s >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(std::ostream &s, const pair<T, U> &p) { return s << p.first << \" \" << p.second; }\n    template <class T> istream &operator>>(istream &s, vector<T> &v) { for(T &e : v) s >> e; return s; }\n    template <class T>\n    ostream &operator<<(ostream &s, const vector<T> &v)\n    {\n        bool is_front = true;\n        for(const T &e : v)\n        {\n            if(not is_front) s << ' ';\n            else  is_front = false;\n            s << e;\n        }\n        return s;\n    }\n    template <class tuple_t, size_t index>\n    struct tupleos\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            tupleos<tuple_t, index - 1>::apply(s, t);\n            return s << \" \" << get<index>(t);\n        }\n    };\n    template <class tuple_t>\n    struct tupleos<tuple_t, 0>\n    {\n        static ostream &apply(ostream &s, const tuple_t &t) { return s << get<0>(t); }\n    };\n    template <class... T>\n    ostream &operator<<(ostream &s, const tuple<T...> &t)\n    { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s, t); }\n    template <> ostream &operator<<(ostream &s, const tuple<> &t) { return s; }\n    string revstr(string str) { reverse(str.begin(), str.end()); return str; }\n} // namespace std\n\n#ifdef LOCAL\n#define dump(...)                                                              \\\n    debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\",       \\\n        dump_func(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T>\nvoid dump_func(const char *ptr, const T &x)\n{\n    debug_stream << '\\t';\n    for(char c = *ptr; c != '\\0'; c = *++ptr)\n    {\n        if(c != ' ') debug_stream << c;\n    }\n    debug_stream << \" : \" << x << '\\n';\n}\ntemplate <class T, class... rest_t>\nvoid dump_func(const char *ptr, const T &x, rest_t... rest)\n{\n    debug_stream << '\\t';\n    for(char c = *ptr; c != ','; c = *++ptr)\n    {\n        if(c != ' ') debug_stream << c;\n    }\n    debug_stream << \" : \" << x << \",\\n\";\n    dump_func(++ptr, rest...);\n}\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <class P>\nvoid read_range(P __first, P __second) { for(P i = __first; i != __second; ++i) std::cin >> *i; }\ntemplate <class P> void write_range(P __first, P __second)\n{ for(P i = __first; i != __second; std::cout << (++i == __second ? '\\n' : ' ')) std::cout << *i; }\n\n// substitue y for x if x > y.\ntemplate <class T> bool sbmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitue y for x if x < y.\ntemplate <class T> bool sbmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search.\ni64 bin(const std::function<bool(i64)> &f, i64 ok, i64 ng)\n{\n    while(std::abs(ok - ng) > 1)\n    {\n        i64 mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ndouble bin(const std::function<bool(double)> &f, double ok, double ng, const double eps)\n{\n    while(std::abs(ok - ng) > eps)\n    {\n        double mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T *)array, (T *)(array + N), val); }\ntemplate <class A> void reset(A &array) { memset(array, 0, sizeof(array)); }\nvoid for_permutation(size_t n, const std::function<void(const std::vector<size_t>&)> &f)\n{\n    std::vector<size_t> idx(n); iota(idx.begin(), idx.end(), 0);\n    do { f(idx); } while(std::next_permutation(idx.begin(), idx.end()));\n}\nvoid for_permutation(size_t n, const std::function<void(size_t*, size_t*)> &f)\n{\n    size_t *__begin = new size_t[n], *__end = __begin + n;\n    std::iota(__begin, __end, 0);\n    do { f(__begin, __end); } while(std::next_permutation(__begin, __end));\n    delete[] __begin;\n}\n\n/* The main code follows. */\n\nusing namespace std;\n\nmain()\n{\n    void __solve();\n\n    ui32 t = 1;\n\n#ifdef LOCAL\n    t = 1;\n#endif\n\n    // cin >> t;\n    t=-1;\n\n    while(t--)\n    {\n        __solve();\n    }\n}\n\nvoid __solve()\n{\n    i32 n; cin>>n;\n    if(!n)\n    {\n        exit(0);\n    }\n    vector<i32> w(n); cin>>w;\n    i32 dp[334][334]={};\n    for(i32 i=1; i<=n; ++i)\n    {\n        for(i32 j=0; j+i<=n; ++j)\n        {\n            for(i32 k=1; k<i; k+=2)\n            {\n                if(abs(w[j]-w[j+k])<2 and dp[j+1][j+k]==k-1)\n                {\n                    sbmax(dp[j][j+i],k+1+dp[j+k+1][j+i]);\n                }\n            }\n            sbmax(dp[j][j+i],dp[j+1][j+i]);\n        }\n    }\n    cout << dp[0][n] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// https://kimiyuki.net/writeup/algo/etc/icpc-2016-domestic-d/\n// http://tsutaj.hatenablog.com/entry/2017/03/07/173127\n#include <bits/stdc++.h>\nusing namespace std;\n\nint w[300];\nbool isOK[301][301];    // isOK[l][r] := [l, r)が取り出し可能かどうか\nint DP[301][301];       // DP[l][r] := [l, r)取り出し可能なブロック数\n\nbool isConnected(int i, int j) {\n    return abs(w[i] - w[j]) <= 1;\n}\n\nbool solve()\n{\n    int n;\n    cin >> n;\n    if(n == 0) return false;\n    for(int i = 0; i < n; ++i) cin >> w[i];\n    memset(isOK, 0, sizeof(isOK));\n    memset(DP, 0, sizeof(DP));\n    for(int i = 0; i < n; ++i) {\n        isOK[i][i] = true;\n    }\n    for(int len = 2; len <= n; ++len) {\n        for(int i = 0; i + len <= n; ++i) {\n            // [i, i + len) が取り出し可能か調べる\n            if(isOK[i+1][i + len - 1] && isConnected(i, i + len - 1)) {\n                isOK[i][i+len] = true;\n                continue;\n            }\n\n            // [i, i+k) と [i+k, i+len)が取り出し可能なら[i, i+len)も取り出し可能\n            for(int k = 0; k <= len; ++k) {\n                if(isOK[i][i+k] && isOK[i+k][i+len]) {\n                    isOK[i][i+len] = true;\n                    break;\n                }\n            }\n        }\n    }\n    \n    for(int left = 0; left < n; ++left) {\n        for(int right = left; right <= n; ++right) {\n            if(isOK[left][right]) DP[left][right] = right - left;\n        }\n    }\n\n    for(int left = 0; left <= n; ++left) {\n        for(int right = left; right <= n; ++right) {\n            for(int k = left; k <= right; ++k) {\n                DP[left][right] = max(DP[left][right], DP[left][k] + DP[k][right]);\n            }\n        }\n    }\n    cout << DP[0][n] << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tint w[301];\n\t\tint dp[301][301];\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\t\n\t\tfor(int i=0;i<n;i++) scanf(\"%d \",&w[i]);\n\t\tfor(int i=0;i<301;i++) fill_n(dp[i],301,0);\n\t\t\n\t\tfor(ll W=2;W<n+1;W++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint j=i+W-1;\n\t\t\t\tif(j>=n) continue;\n\t\t\t\tif(dp[i+1][j-1]==W-2 && abs(w[i]-w[j])<=1)\n\t\t\t\tdp[i][j]=W;\n\t\t\t\tfor(ll k=i;k<j;k++){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[0][n-1]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <string>\n#include <vector>\n#define rep(i,n) for (int i = 0;i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\n//AOJ Daruma Otoshi\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1611&lang=jp\n\n\nvoid rec(int n) {\n    vector<int> w(n);\n    rep(i,n) cin >> w[i];\n    vector<vector<int>> dp(n+1,vector<int>(n+1));\n    rep(i,n)rep(j,n) dp[i][j] = 0;\n     \n    for(int d=2;d <= n;d++){\n        for(int l = 0;l < n;l++){\n            int r = l+d;\n            if(r>n)continue;\n            if(dp[l+1][r-1]==d-2 && abs(w[l]-w[r-1])<=1) dp[l][r] = d;\n            for(int mid = l;mid <= r;mid++) dp[l][r] = max(dp[l][r],dp[l][mid]+dp[mid][r]);\n        }\n    }\n\n    cout << dp[0][n] << endl;\n    \n}\n\nint main(){\n    int n;\n    cin >> n;\n    while(n>0){\n        rec(n);\n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n);i++)\n#define sz(x) int(x.size())\ntypedef long long ll;\ntypedef pair<int,int> P;\nconstexpr ll INF = (1LL << 55);\n\nint main(){\n  while (1) {\n  int n;\n  cin >> n;\n  if (!n) break;\n  vector<int> w(n);\n  rep(i,n) cin >> w[i];\n\n  vector<vector<int>> dp(n+1,vector<int>(n+1,0));\n\n  for (int len = 2; len <= n; len++) {\n    for (int l = 0; l + len <= n; l++) {\n      int r = l + len;\n      if (abs(w[r-1] - w[l]) <= 1 && dp[l+1][r-1] == len - 2) dp[l][r] = len;\n      for (int k = l; k <= r; k++) {\n        dp[l][r] = max(dp[l][r], dp[l][k] + dp[k][r]);\n      }\n    }\n  }\n  cout << dp[0][n] << endl;\n  }\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> mem;\nvector<int> bs;\n\nint rec(int l, int r) {\n  if(mem[l][r] >= 0) return mem[l][r];\n  if(l >= r) {\n    mem[l][r] = 0;\n  } else {\n    int d = r - l + 1;\n    if(rec(l+1, r-1) == d - 2 && abs(bs[l] - bs[r]) <= 1) {\n      mem[l][r] = d;\n    } else {\n      int ans = 0;\n      for(int k = l; k < r; k++) {\n        ans = max(ans, rec(l, k) + rec(k+1, r));\n      }\n      mem[l][r] = ans;\n    }\n  }\n  return mem[l][r];\n}\n\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    int m;\n    cin >> m;\n    if(m == 0) break;\n    bs.clear();\n    for(int i = 0; i < m; i++) {\n      int b;\n      cin >> b;\n      bs.push_back(b);\n    }\n    mem = vector<vector<int>>(m, vector<int>(m, -1));\n    int ans = rec(0, m-1);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N;\n\nvoid chmax(int &a,int b){\n    if(a<b) a=b;\n}\n\nvoid solve(){\n    vector<int> w(N);\n    for(int i=0;i<N;i++) cin>>w[i];\n\n    int dp[303][303]={};\n    for(int i=0;i<N-1;i++){\n        if(abs(w[i]-w[i+1])<=1) dp[i][i+1]=2;\n    }\n\n    for(int k=3;k<=N;k++){\n        for(int i=0;i+k-1<N;i++){\n            int lef=i;\n            int rig=i+k-1;\n            for(int j=lef;j<rig;j++){\n                chmax(dp[lef][rig],dp[lef][j]+dp[j+1][rig]);\n            }\n            if(abs(w[lef]-w[rig])<=1&&dp[lef+1][rig-1]==(k-2)) dp[lef][rig]=k;\n        }\n    }\n\n    cout<<dp[0][N-1]<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>N;\n      if(N==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nbool** table;\nint** dp;\nint N;\n\nint recursive(int left,int right){\n\n\tif(dp[left][right] != -1)return dp[left][right]; //?????¢???????????´???\n\tif((right-left+1)%2 == 1){ //??????????\\???°?????´???\n\t\treturn max(recursive(left,right-1),recursive(left+1,right));\n\t}\n\tif(table[left][(right-left+1)/2] == true)return dp[left][right] = right-left+1; //left???right?????¨????¶?????????´???\n\tif(right == left+1 && table[left][1] == false)return 0;\n\n\tint ans = 0;\n\tfor(int i = left+1; i <= right-2; i++){\n\t\tans = max(ans,recursive(left,i)+recursive(i+1,right));\n\t}\n\treturn dp[left][right] = ans;\n}\n\nint main(){\n\n\tint data[301];\n\ttable = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tdp = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[151];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 0; i <= 300; i++){\n\t\t\tfor(int k = 0; k <= 150; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= 300; k++){\n\t\t\t\tdp[i][k] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1)table[i][1] = true;\n\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",recursive(1,N));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <stack>\n#include <regex>\n#include <numeric>\n#include <queue>\n#include <set>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char const *argv[])\n{\n  while (true)\n  {\n    ll n;\n    cin >> n;\n    if (n == 0)\n      break;\n    vector<ll> w(n + 1);\n    REP(i, n)\n    {\n      cin >> w[i + 1];\n    }\n    vector<vector<ll>> dp(n + 2, vector<ll>(n + 2));\n    REP(i, n)\n    {\n      for (ll b = 1; b <= n - i; b++)\n      {\n        ll t = b + i;\n        if (dp[b + 1][t - 1] == t - b - 1 && abs(w[b] - w[t]) <= 1)\n          dp[b][t] = dp[b + 1][t - 1] + 2;\n        ll maxi = 0;\n        for (ll mid = b; mid < t; mid++)\n        {\n          dp[b][t] = max(dp[b][t], dp[b][mid] + dp[mid + 1][t]);\n        }\n      }\n    }\n    cout << dp[1][n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,m,n) for(int i=(m); i<(int)(n); i++)\n#define RREP(i,m,n) for(int i=(int)(n-1); i>=m; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define fi first\n#define se second\n#define debug(...) {cerr<<\"[L\"<<__LINE__<<\"] \"; _debug(__VA_ARGS__);}\n\ntemplate<typename T>\nstring join(const vector<T>&v, string del=\", \"){ stringstream s;\n    for(auto x : v) s << del << x; return s.str().substr(del.size());\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<T>&v){\n    if(v.size()) o << \"[\" << join(v) << \"]\"; return o;\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<vector<T> >&vv){\n    int l = vv.size();\n    if(l){ o<<endl; rep(i,l) o << (i==0 ? \"[ \" : \",\\n  \" ) << vv[i] << (i==l-1 ? \" ]\" : \"\"); }\n    return o;\n}\ninline void _debug(){cerr<<endl;}\ntemplate<class First, class... Rest>\nvoid _debug(const First& first, const Rest&... rest){cerr<<first<<\" \";_debug(rest...);}\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nconst double PI = (1*acos(0.0));\nconst double EPS = 1e-9;\nconst int INF = 0x3f3f3f3f;\nconst ll INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst ll mod = 1e9 + 7;\n\ninline void finput(string filename) {\n    freopen(filename.c_str(), \"r\", stdin);\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    // finput(\"./input\");\n    int n;\n    while(cin >> n){\n        if(n == 0) break;\n        vi w(n);\n        vvi dp(n, vi(n));\n        rep(i,n) cin >> w[i];\n        REP(W,2,n+1){\n            rep(i,n){\n                int j = i+W-1;\n                if(j >= n) continue;\n                if(dp[i+1][j-1] == W-2 && abs(w[i] - w[j]) <= 1) dp[i][j] = W;\n                REP(k,i,j){\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n                }\n            }\n        }\n        cout << dp[0][n-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nint N,maximum;\n\nvoid recursive(int table[],int num,int SIZE){\n\n\tmaximum = max(maximum,2*num);\n\n\tint max_chain = 0,tmp_chain,nextTable[SIZE],next_index = 0;\n\n\tfor(int i = 1; i <= SIZE-1; i++){\n\t\tif(abs(table[i] - table[i-1]) <= 1){\n\t\t\tif(i == SIZE-1){\n\t\t\t\tif(max_chain == 0){\n\t\t\t\t\tnextTable[next_index++] = SIZE-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttmp_chain = 0;\n\t\t\t\tfor(int k = 1;(i-1)-k>=0 && i+k <= SIZE-1;k++){\n\t\t\t\t\tif(abs(table[(i-1)-k] - table[i+k]) <= 1){\n\t\t\t\t\t\ttmp_chain++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp_chain > max_chain){\n\t\t\t\t\tmax_chain = tmp_chain;\n\t\t\t\t\tnext_index = 0;\n\t\t\t\t\tnextTable[next_index++] = i;\n\t\t\t\t}else if(tmp_chain == max_chain){\n\t\t\t\t\tnextTable[next_index++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(next_index == 0)return;\n\n\tfor(int i = 0; i < next_index;i++){\n\t\tint new_table[SIZE-2],next_size = 0;\n\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\tif(k != nextTable[i] && k != nextTable[i]-1){\n\t\t\t\tnew_table[next_size++] = table[k];\n\t\t\t}\n\t\t}\n\t\trecursive(new_table,num+1,next_size);\n\t}\n}\n\nvoid func(){\n\n\tint first[N];\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&first[i]);\n\n\tif(N == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}else if(N == 2){\n\t\tif(abs(first[0] - first[1] <= 1)){\n\t\t\tprintf(\"1\\n\");\n\t\t}else{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\trecursive(first,0,N);\n\n\tprintf(\"%d\\n\",maximum);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\t\tmaximum = 0;\n\n\t\tfunc();\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\n#define rep(i, n) for(int i=0;i<n;++i)\n#define rrep(i, n) for(int i=n;i>=0;--i)\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll big=1e18;\nconst double PI=2*asin(1);\n\nint DP[305][305];\nint w[305];\n\nint solve(int l, int r){\n    if(DP[l][r]>-1) return DP[l][r];\n    if(r<=l+1) return DP[l][r] = 0;\n    if((abs(w[l]-w[r-1])<=1)&&(solve(l+1, r-1)==r-l-2)) return DP[l][r] = r-l;\n    for(int i=1;l+i<=r-1;++i){\n        DP[l][r] = max(DP[l][r], solve(l, l+i)+solve(l+i, r));\n    }\n    return DP[l][r];\n}\n\nint main() {\n    int N;\n    vector<int> ansarr;\n    while(true){\n        for(int i=0;i<305;++i){\n            for(int j=0;j<305;++j){\n                DP[i][j] = -1;\n            }\n        }\n        cin>>N;\n        if(N==0) break;\n        for(int i=0;i<N;++i){\n            cin>>w[i];\n        }\n        ansarr.push_back(solve(0, N));\n    }\n    for(int i=0;i<ansarr.size();++i){\n        cout<<ansarr[i]<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// written by @kakira9618\n// problem: http://icpc.iisf.or.jp/past-icpc/domestic2016/problems/all_ja.html#section_D\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\nint n;\nvector<int> W;\nint dp[301][301];\n\n// O(n^3)\nint dfs(int l, int r) {\n    if (r - l <= 1) return dp[l][r] = 0;\n    if (dp[l][r] != -1) return dp[l][r]; // ?????¢???\n    int ans = 0;\n    \n    // i????????§??????????????????????¨?????????????????§£??????\n    for(int i = l + 1; i < r - 1; i++) {\n        ans = max(ans, dfs(l, i) + dfs(i, r));\n    }\n    \n    // ?????£???2??????????????¶?????????1??\\???????????????????????¨????¶??????????????????°?????£????????????????¶???????\n    if (abs(W[r - 1] - W[l]) <= 1) {\n        if (dfs(l + 1, r - 1) == r - l - 2) {\n            ans = max(ans, dfs(l + 1, r - 1) + 2);\n        }\n    }\n    return dp[l][r] = ans;\n}\n\nint main() {\n    while(cin >> n, n) {\n        memset(dp, -1, sizeof(int) * 301 * 301);\n        W.clear();\n        W.resize(n);\n        for(int i = 0; i < n; i++) {\n            cin >> W[i];\n        }\n        cout << dfs(0, n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"../lib/template.hpp\"\n\n\n#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define coutd(n) cout << fixed << setprecision(n)\n#define ll long long int\n#define vl vector<ll>\n#define vi vector<int>\n\nusing namespace std;\n\n#line 2 \"tmp.cpp\"\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n    vi a(n);\n    REP(i, n) { cin >> a[i]; }\n    vector<vi> dp(n + 1, vi(n + 1, 0));\n    FOR(k, 1, n + 1) {\n      REP(l, n + 1 - k) {\n        int r = l + k;\n        if (k == 1) {\n          dp[l][r] = 0;\n        } else if (k == 2) {\n          dp[l][r] = abs(a[l] - a[r - 1]) <= 1 ? 2 : 0;\n        } else {\n          if (dp[l + 1][r - 1] == r - l - 2 && abs(a[l] - a[r - 1]) <= 1) {\n            dp[l][r] = r - l;\n          } else {\n            FOR(i, l, r) { dp[l][r] = max(dp[l][r], dp[l][i] + dp[i][r]); }\n          }\n        }\n      }\n    }\n\n    cout << dp[0][n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll ,P> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nint n;\nint dp[500][500];\nvector<int> w;\n\n// [l,r)\nint rec(int l, int r){\n    if(dp[l][r] >= 0) return dp[l][r];\n    if(r-l<2) return 0;\n\n    int res = 0;\n    res = max(res, rec(l,r-2)+(abs(w[r-2]-w[r-1])<=1?2:0));\n    res = max(res, rec(l+2,r)+(abs(w[l]-w[l+1])<=1?2:0));\n    if(rec(l+1,r-1) == r-l-2){\n        res = max(res, r-l-2+(abs(w[l]-w[r-1])<=1?2:0));\n    }\n    else{\n        res = max(res, rec(l+1,r-1));\n    }\n    res = max(res, rec(l,r-1));\n    res = max(res, rec(l+1,r));\n    return dp[l][r] = res;\n}\n\nint main() {\n    while(cin >> n, n){\n        w.resize(n);\n        REP(i,n){\n            cin >> w[i];\n        }\n        REP(i,n+1) fill(dp[i],dp[i]+n+1,-1);\n        cout << rec(0,n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, w[310];\nbool dp[310][310];\nint rec[310][310];\n\nsigned main() {\n    while(cin >> N, N) {\n        memset(dp, false, sizeof(dp));\n        memset(rec, 0, sizeof(rec));\n\n        rep(i,0,N) cin >> w[i];\n\n        repq(x,2,N) rep(l,0,N-x+1) {\n            int r = l+x;\n            if(x == 2) {\n                if(abs(w[l] - w[l+1]) <= 1) dp[l][r] = true;\n            }\n            else {\n                rep(k,l,r) if(dp[l][k] && dp[k][r]) dp[l][r] = true;\n            }\n\n            if(dp[l][r]) {\n                int c = 1;\n                while(1) {\n                    int nl = l - c, nr = r + c;\n                    if(nl < 0 || nr > N) break;\n                    if(abs(w[nl] - w[nr-1]) > 1) break;\n                    dp[nl][nr] = true; c++;\n                }\n                rec[l][r] = r - l;\n            }\n        }\n\n        repq(x,2,N) rep(l,0,N-x+1) {\n            int r = l+x;\n            rep(k,l,r) chmax(rec[l][r], rec[l][k] + rec[k][r]);\n        }\n        cout << rec[0][N] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\n\nint dp[500][500];  // 区間[l, r)で取り除くことができるブロック数\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) cin >> a[i];\n        memset(dp, 0, sizeof(dp));\n        for (int b = 2; b <= n; b++) {\n            for (int l = 0; l < n; l++) {\n                int r = l + b;\n                if (r > n) continue;\n                if (dp[l + 1][r - 1] == b - 2 && abs(a[l] - a[r - 1]) <= 1) {\n                    dp[l][r] = b;\n                }\n                for (int m = l; m <= r; m++) {\n                    dp[l][r] = max(dp[l][r], dp[l][m] + dp[m][r]);\n                }\n            }\n        }\n        cout << dp[0][n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nint main(){\n\n\tint N,data[301];\n\tbool** table = new bool*[301]; //table[left][right] = left???????§?????????????2*right??????????????¨?¶??????§??????????????????\n\tint** dp = new int*[301]; //?????????????????????????????§?¶????????????°\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[151];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//?¶??????????????????????????????????\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int k = 0; k <= N/2; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= N; k++){\n\t\t\t\tdp[i][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\t//????????????2???????¨?\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1)table[i][1] = true;\n\n\t\t}\n\n\t\t//?¶??????????????????????????¨????\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){ //??????????????????\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;//??????????????£?????????length-2??????????¶????????????????????????¨??????+length-1?????´???????????????????¶?????????´???\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//?????§?¶????????????°????¨????\n\t\tfor(int length = 2; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = N; left >= N-length+2; left--){\n\t\t\t\tdp[left][length/2] = max(dp[left][(length-2)/2],dp[min(N,left+1)][length/2]);\n\t\t\t}\n\t\t\tfor(int left = N-length+1; left >= 1; left--){ //[??????]???N?????§??????[??????]????????????\n\t\t\t\tif(table[left][length/2] == true){ //left??????length?????????????¶?????????´???\n\t\t\t\t\tdp[left][length/2] = dp[min(N,left+length)][length/2]+length;\n\t\t\t\t}else{ //left??????length?????????????¶????????????´???\n\t\t\t\t\tdp[left][length/2] = dp[left+1][length/2];\n\t\t\t\t\tfor(int i = 2; i <= length-2; i++){\n\t\t\t\t\t\tdp[left][length/2] = max(dp[left][length/2],max(dp[left][i/2] -dp[left+i][i/2] + dp[left+i][length/2],dp[left][(length-2)/2]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*if(left == 1 && length == 10){\n\t\t\t\t\tprintf(\"Minhi! length:%d ???dp[%d][%d]:%d????????????\\n\",length,min(N,left+length),length/2,dp[min(N,left+length)][length/2]);\n\t\t\t\t}\n\t\t\t\tprintf(\"dp[%d][%d]:%d\\n\",left,length/2,dp[left][length/2]);*/\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dp[1][N/2]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 305\nusing namespace std;\nint n,w[N],dp[N][N];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)\n      cin>>w[i];\n    memset(dp,0,sizeof(dp));\n    int ans=0;\n    for(int i=1;i<=n;i+=2){\n      for(int j=0;j<n-i;j++){\n\tdp[j][j+i]=dp[j+1][j+i-1];\n\tfor(int k=j+1;k<=j+i;k+=2)\n\t  dp[j][j+i]=max(dp[j][j+i],dp[j][k]+dp[k+1][j+i]);\n\tif(dp[j+1][j+i-1]==i-1&&abs(w[j]-w[j+i])<=1)\n\t  dp[j][j+i]=max(dp[j][j+i],dp[j+1][j+i-1]+2);\n\tans=max(ans,dp[j][j+i]);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint w[305], dp[305][305];\nsigned main(void)\n{\n\twhile(true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tREP(i, n) cin >> w[i];\n\t\tREP(i, 305) REP(j, 305) dp[i][j] = 0;\n\n\t\tFOR(W, 2, n+1) {\n\t\t\tREP(i, n) {\n\t\t\t\tint j = i+W-1;\n\t\t\t\tif(j >= n) continue;\n\t\t\t\t//cout << i << \" \" << j << endl;\n\n\t\t\t\tif(dp[i+1][j-1] == W-2 && abs(w[i] - w[j]) <= 1) dp[i][j] = W;\n\t\t\t\tFOR(k, i, j) {\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j]);\n\t\t\t\t\t//cout << dp[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*REP(i, n) {\n\t\t\tcout << i << \":\";\n\t\t\tREP(j, n) {\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << dp[0][n-1] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int ll;\n\nint main()\n{\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0) return 0;\n\t\tint w[300];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%d\", &w[i]);\n\t\t}\n\t\tif(n==1){\n\t\t\tprintf(\"%d\\n\", 0);\n\t\t\tcontinue;\n\t\t}\n\t\tint ans[301][301];\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tans[i][i]=0;\n\t\t\tif(i+1<=n) ans[i][i+1]=0;\n\t\t}\n\t\tfor(int d=2; d<=n; d++){\n\t\t\tfor(int i=0; i+d<=n; i++){\n\t\t\t\tans[i][i+d]=ans[i+1][i+d];\n\t\t\t\tfor(int j=i+1; j<i+d; j++){\n\t\t\t\t\tif(abs(w[i]-w[j])<=1 && 2*ans[i+1][j]==j-i-1){\n\t\t\t\t\t\tif(ans[i][i+d]<ans[i+1][j]+1+ans[j+1][i+d]) ans[i][i+d]=ans[i+1][j]+1+ans[j+1][i+d];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", 2*ans[0][n]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint N, W[300], dp[300][300];\n \nint rec(int l, int r)\n{\n  if(l >= r) return (0);\n  if(~dp[l][r]) return (dp[l][r]);\n  int ret = 0;\n  if(abs(W[l] - W[r]) <= 1 && rec(l + 1, r - 1) == r - l - 1) ret = r - l + 1;\n  else for(int m = l; m < r; m++) ret = max(ret, rec(l, m) + rec(m + 1, r));\n  return (dp[l][r] = ret);\n}\n \nint main()\n{\n  while(scanf(\"%d\", &N), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d\", &W[i]);\n    }\n    memset(dp, -1, sizeof(dp));\n    printf(\"%d\\n\", rec(0, N - 1));\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i <= (n); i++)\n#define show(a, n) rep(i,n) {cout<<a[i]<<' ';} cout<<endl;\n#define show2(a, n, m) rep(i, n) { rep(j, m) {cout << a[i][j] << ' ';} cout << endl;} \n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<long long, long long> pll;\n\nconst int INF = 1 << 30;\nconst long long INFL = 1LL << 62;\nconst int MOD = 1000000007;\nconst int MAX = 100000;\nconst int N = 100010;\n\nint solve(vi& w) {\n\tint n = w.size();\n\tvector<vi> dp(n, vi(n));\n\tfor(int d = 1; d <= n - 1; d++) {\n\t\tfor(int l = 0; l + d < n; l++) {\n\t\t\tint r = l + d;\n\t\t\tif(d % 2 == 1 && dp[l + 1][r - 1] == d - 1 && abs(w[l] - w[r]) <= 1) {\n\t\t\t\tdp[l][r] = d + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k = l; k + 1 <= r; k++) {\n\t\t\t\tdp[l][r] = max(dp[l][k] + dp[k + 1][r], dp[l][r]);\n\t\t\t}\n\t\t}\n\t}\n//\tshow2(dp, n, n);\n\treturn dp[0][n - 1];\n}\n\nint main() {\n//\tcout << fixed << setprecision(15);\n\tvi ans;\n\twhile(true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tvi w(n);\n\t\trep(i, n) cin >> w[i];\n\t\tans.push_back(solve(w));\n\t}\n\tfor(auto i : ans) cout << i << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include<math.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define MAX 300\nint n;\nint w[MAX];\n\nstring pop(string s, int a) {\n\tstring t = s+\"0\";\n\tt[a] = '0';\n\treturn t;\n}\n\nint daruma(string s) {\n\tif (s.length() == n) return 0;\n\n\tint tmp=0, tmp2=0;\n\ttmp = daruma(s + \"1\");\n\tif (s.rfind(\"1\") != string::npos) {\n\t\tif (abs(w[s.length()] - w[s.rfind(\"1\")]) <= 1) {\n\t\t\ttmp2 = daruma( pop(s, s.rfind(\"1\") ) ) + 2;\n\t\t}\n\t}\n\treturn max(tmp, tmp2);\n}\n\nint main() {\n\tcin >> n;\n\twhile (n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\tcout << daruma(\"1\") << endl;\n\t\t\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nbool ok(int a, int b) {\n\treturn abs(a - b) <= 1;\n}\n\nvector<vector<int>>memo(1000, vector<int>(1000,-1));\n\nint solve(const int l,const int r, vector<int>&v) {\n\tif (memo[l][r] != -1)return memo[l][r];\n\tif (l == r)return memo[l][r] = 0;\n\telse if (l + 1 == r)return memo[l][r] = 0;\n\telse if (l + 2 == r) {\n\t\tif (ok(v[l],v[l+1]))return memo[l][r] = 2;\n\t\telse return memo[l][r] = 0;\n\t}\n\telse {\n\t\tint ans = 0;\n\t\tfor (int k = l + 1; k <= r - 1; ++k) {\n\t\t\tans = max(ans, solve(l, k, v) + solve(k, r, v));\n\t\t}\n\t\tif (ok(v[l], v[r - 1]) && solve(l + 1, r - 1, v) == (r - l - 2)) {\n\t\t\tans = r - l;\n\t\t}\n\t\treturn memo[l][r]=ans;\n\t}\n\t\n}\n\nint main() {\n\twhile (1) {\n\t\tmemo = vector<vector<int>>(1000, vector<int>(1000, -1));\n\t\tint N; cin >> N;\n\t\tvector<int>v(N);\n\t\tfor (int i = 0; i < N; ++i)cin >> v[i];\n\t\tif (!N)break;\n\t\tint ans = solve(0, N, v);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\n int main(){\n\n\tint N,data[301],ans;\n\tbool** table = new bool*[301];\n\tint** dp = new int*[301];\n\tfor(int i = 0; i <= 300; i++){\n\t\ttable[i] = new bool[151];\n\t\tdp[i] = new int[301];\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tif(N <= 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i <= 300; i++){\n\t\t\tfor(int k = 0; k <= 150; k++)table[i][k] = false;\n\t\t\tfor(int k = 0; k <= 300; k++){\n\t\t\t\tdp[i][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++)scanf(\"%d\",&data[i]);\n\n\t\tfor(int i = 1; i <= N-1; i++){\n\t\t\tif(abs(data[i+1]-data[i]) <= 1){\n\t\t\t\ttable[i][1] = true;\n\t\t\t\tdp[i][i+1] = 2;\n\t\t\t}else{\n\t\t\t\tdp[i][i+2] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int length = 4; length <= N; length += 2){\n\t\t\tfor(int left = 1; left+length -1 <= N; left++){\n\t\t\t\tFLG = false;\n\n\t\t\t\tif(table[left+1][(length-2)/2] == true && abs(data[left] - data[left+length-1]) <= 1)FLG = true;\n\n\t\t\t\tif(!FLG){\n\t\t\t\t\tfor(int i = 2; i <= length-2; i += 2){\n\t\t\t\t\t\tif(table[left][i/2] == true && table[left+i][(length-i)/2] == true){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\ttable[left][length/2] = true;\n\t\t\t\t\tdp[left][left+length-1] = length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\n\t\tfor(int length = 4; length <= N; length += 2){ //??????????????????\n\t\t\tfor(int left = N-(length/2);left >= N-length+2; left--){ //????????¨???????????????\n\t\t\t\tdp[left][N] = max(dp[left+1][left+(length-2)-1],max(dp[left][left+(length-2)+1],dp[left+1][N])); //?????????????????????????????§????????????\n\t\t\t}\n\t\t\tfor(int left = N-length+1; left >= 1; left--){ //?§????????????????\n\t\t\t\tif(dp[left][left+length-1] != 0){ //?§£????±??????£???????????????????????????\n\t\t\t\t\tans = max(ans,dp[left][left+length-1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int mid = left+1; mid <= left+length-3; mid++){\n\t\t\t\t\tdp[left][left+length-1] = max(dp[left][left+length-1],dp[left][mid]+dp[min(left+length-1,mid+1)][left+length-1]);\n\t\t\t\t\tans = max(ans,dp[left][left+length-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 1; i <= N-1; i++){\n\t\t\tfor(int k = i+1; k <= N; k++){\n\t\t\t\tprintf(\"dp[%d][%d]:%d\\n\",i,k,dp[i][k]);\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n\nvoid solve(int n) {\n\tvi v(n, 0);\n\tvi dist(n + 1, INF);\n\tvector<vector<bool>> dp(n + 1, vector<bool>(n, false));\n\trep(i, n) {\n\t\tcin >> v[i];\n\t}\n\tfor (int l = 2; l <= n; l += 2) {\n\t\tfor (int i = 0; i + l <= n; i++) {\n\t\t\tbool b = false;\n\t\t\tif (l != 2) {\n\t\t\t\tfor (int j = 2; j<l; j += 2) {\n\t\t\t\t\tif (dp[j][i] && dp[l - j][i + j])\n\t\t\t\t\t\tb = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dif = abs(v[i] - v[i + l - 1]);\n\t\t\tif (dif <= 1&&(l==2?1:dp[l-2][i+1]))b = true;\n\t\t\tif (b)dp[l][i] = true;\n\t\t\t//cout << l << \" \" << i << \" \" << dp[l][i] << endl;\n\t\t}\n\t}\n\tint pos = 0;\n\tdeque<pii> q;\n\tq.push_back({ 0,0 });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop_front();\n\t\tif (p.sc < dist[p.fs]) {\n\t\t\tdist[p.fs] = p.sc;\n\t\t\tif (p.fs == n) {\n\t\t\t\tcout << n - p.sc << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int i = 2; i < n + 1; i += 2) {\n\t\t\t\tif (dp[i][p.fs]) {\n\t\t\t\t\tq.push_front({ p.fs + i,p.sc });\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.push_back({ p.fs + 1 ,p.sc + 1 });\n\t\t}\n\t}\n\n}\n\nint main(void) {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tsolve(n);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n, a[1000], dp[1000][1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; for (int i = 0; i < 1000; i++) { for (int j = 0; j < 1000; j++)dp[i][j] = 0; }\n\t\tfor (int i = 0; i < n; i++)cin >> a[i];\n\t\tfor (int i = 0; i < n - 1; i++) { if (abs(a[i] - a[i + 1]) <= 1) { dp[i][i + 1] = 2; } }\n\t\tfor (int h = 0; h < 30; h++) {\n\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tint a1 = j, a2 = i + j - 1; if (a2 >= n)continue;\n\t\t\t\t\tif (dp[a1][a2] == 0)continue;\n\t\t\t\t\tif (a1 > 0 && a2 < n - 1 && abs(a[a1 - 1] - a[a2 + 1]) <= 1)dp[a1 - 1][a2 + 1] = i + 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\tint a1 = j, a3 = i + j; if (a3 >= n)continue;\n\t\t\t\t\tfor (int k = a1 + 1; k <= a3; k++) {\n\t\t\t\t\t\tint a2 = k;\n\t\t\t\t\t\tdp[a1][a3] = max(dp[a1][a3], dp[a1][a2 - 1] + dp[a2][a3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <stdio.h>\nusing namespace std;\nint func(vector<int> w){\n    int s = w.size();\n    if(s>1){\n        int temp;\n        int min = s;\n        for(int i=0;i<s-1;i++){\n            vector<int> remain;\n            for(int j=0;j<s;j++){\n                if(j==i){j+=2;}\n                if(j>=s)break;\n                remain.push_back(w[j]);\n            }\n            if(abs(w[i]-w[i+1])<2){\n                temp = func(remain);\n                min = min > temp ? temp : min;\n            }\n        }\n        return min;\n    } else {\n        return s;\n    }\n}\nvoid q_daruma(int n){\n    vector<int> w;\n    int t;\n    for(int i=0;i<n;i++){cin>>t;w.push_back(t);}\n    cout << w.size()-func(w) << \"\\n\";\n}\nint main(){\n    int n;\n    while(cin >> n, n!=0){\n        q_daruma(n);\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// 5*300\n#define BUF_SIZE 1600\n\nint get_int(void) {\n  int num;\n#ifdef BUF_SIZE\n  static char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return 0;\n  sscanf(line, \"%d\", &num);\n#else\n#error\n#endif\n  return num;\n}\n\n// <arr[0]> <arr[1]> .. <arr[size-1]>\nint fget_array(int *arr, int size) {\n#ifdef BUF_SIZE\n    static char line[BUF_SIZE];\n    char *tmpbuf = line;\n    int i;\n    if(!fgets(line, BUF_SIZE, stdin)) return -1;\n    for(i = 0; i < size; i++) {\n        char *tmp = strtok(tmpbuf, \" \");\n        arr[i] = strtol(tmp, NULL, 10);\n        tmpbuf = NULL;\n    }\n#else\n#error\n#endif\n    return 0;\n}\n#define NUM_MAX 300\n#define WEIGHT_MAX 1000\n#define SET_MAX 50\n\n\n#define STACK_MAX 20000\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define DP_SIZE_MAX (NUM_MAX+1)*(NUM_MAX+1)\n\nint drop_point(int v1, int v2) {\n    return (abs(v1-v2)<=1)*2;\n}\n\nint main(void) {\n    int ans[SET_MAX];\n    int idx = 0;\n    int i;\n    // dp[size][start];\n    while(1) {\n        int dp[NUM_MAX+1][NUM_MAX+1] = {0};\n        int num = get_int();\n        if(!num) break;\n        int ws[NUM_MAX+1];\n        fget_array(ws, num);\n        int size, start, end;\n        // for size=2\n        for(i = 0; i < num-1; i++) {\n            dp[2][i] = drop_point(ws[i], ws[i+1]);\n        }\n        for(size = 3; size <= num; size++) {\n            for(start = 0; start < num-size+1; start++) {\n                end = start + size - 1;\n                int res = dp[size-1][start]; // When topmost daruma left\n                int pivot;\n                // consider that the situation where pivot and end are dropped\n                for(pivot = start; pivot < end; pivot++) {\n                    int mid_size = end-pivot-1;\n                    int mid = dp[mid_size][pivot+1];\n                    res = max(\n                        dp[pivot-start][start] + \n                          mid + \n                          (mid==mid_size)*drop_point(ws[pivot], ws[end]),\n                        res\n                    );\n#ifdef DEBUG\n                    printf(\"(%d, %d) -> %d\\n\",start, end, res);\n#endif\n                }\n                dp[size][start] = res;\n            }\n        }\n        ans[idx++] = dp[num][0];\n    }\n    for(i = 0; i < idx; i++) {\n        printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n\nint main() {\n\n\tint n;\n\tint *w;\n\tint dp[301][301];\n\tint i,j,k;\n\n\tfor(;;) {\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tw = malloc((n+1) * sizeof(int));\n\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%d\",&w[i]);\n\n\t\tfor(i=0;i<n+1;i++)\n\t\t\tfor(j=0;j<n+1;j++)\n\t\t\t\tdp[i][j]=0;;\n\n\t\t//??????DP\n\t\tfor(i=n-1;i>=0;i--) {\n\t\t\tfor(j=i+1;j<=n;j++) {\n\t\t\t\tif(i+1<j&&abs(w[i]-w[j-1])<=1&&dp[i+1][j-1]==j-i-2)\n\t\t\t\t\tdp[i][j]=j-i;\n\t\t\t\tfor(k=j+1;k<=n;k++) {\n\t\t\t\t\tif(dp[i][k]<(dp[i][j]+dp[j][k]))\n\t\t\t\t\t\t\tdp[i][k]=dp[i][j]+dp[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[0][n]);\n\t\tfree(w);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint T[300][300],W[300],n;\nint dfs(int i,int j){\n\tif(~T[i][j])return T[i][j];\n\tif(abs(W[i]-W[j])<=1){\n\t\tif(i+1==j)return 2;\n\t\tif(dfs(i+1,j-1)==j-i-1)return T[i][j]=j-i+1;\n\t}\n\tint r=0,t,k=i;\n\tfor(;k<j;k++){\n\t\tt=dfs(i,k)+dfs(k+1,j);\n\t\tr=r>t?r:t;\n\t}\n\treturn T[i][j]=r;\n}\nint main(){\n\tint i;\n\tfor(;scanf(\"%d\",&n),n;printf(\"%d\\n\",dfs(0,n-1)))\n\t\tfor(memset(T,0xff,sizeof(T)),i=0;i<n;i++)scanf(\"%d\",W+i);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint n;\nint w[300];\n\nint memo[512][512];\n\nint search(int begin, int end) {\n\tint ret = end - begin;\n\tif (end <= begin) return 0;\n\tif (end == begin + 1) return 1;\n\tif (end == begin + 2) return abs(w[begin] - w[begin + 1]) <= 1 ? 0 : 2;\n\tif (memo[begin][end]) return ~memo[begin][end];\n\tif (abs(w[begin] - w[end - 1]) <= 1 && search(begin + 1, end - 1) == 0) {\n\t\t/* zenbu otoseru */\n\t\tret = 0;\n\t} else {\n\t\tint i;\n\t\tfor (i = begin + 1; i < end; i++) {\n\t\t\tint candidate = search(begin, i) + search(i, end);\n\t\t\tif (candidate < ret) ret = candidate;\n\t\t}\n\t}\n\treturn ~(memo[begin][end] = ~ret);\n}\n\nint main(void) {\n\tint i;\n\twhile (scanf(\"%d\", &n) == 1 && n > 0) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (scanf(\"%d\", &w[i]) != 1) return 1;\n\t\t}\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tprintf(\"%d\\n\", n - search(0, n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint dp[301][301];\nint w[301] = {};\n\nint abs(int num) {\n  if(num <= -1) {\n    return num * -1;\n  }\n  return num;\n}\n\nint max(int a, int b) {\n  if (a > b) {\n    return a;\n  }\n  return b;\n}\n\nint rec(int l,int r){\n    //既に計算済み？\n    if(dp[l][r] != -1) return dp[l][r];\n\n    //これ以上取り除けない？\n    if(abs(l - r) <= 1) return 0;\n\n    int res = 0;\n    //パターン1.\n    if(abs(w[l] - w[r - 1]) <= 1 && rec(l + 1,r - 1) == r - l - 2)\n    {\n        //[l , r)がはじき出せるので\n        res = r - l;\n    }\n\n    //パターン２.区間を分ける\n    for(int mid = l + 1;mid <= r - 1;mid++)\n    {\n        res = max(res , rec(l,mid) + rec(mid,r));\n    }\n    return dp[l][r] = res;\n};\n\nint main(void) {\n  while(1) {\n    int n;\n    scanf(\"%d\", &n);\n\n    if (n == 0) {\n      return 0;\n    }\n\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &w[i]);\n    }\n\n    for (int i = 0; i < n + 1; i++) {\n      for (int j = 0; j < n + 1; j++) {\n        dp[i][j] = -1;\n      }\n    }\n\n    int ans = rec(0, n);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint MAX(int a,int b){return a<b?b:a;}\nint main(){\n  int n,m[1010],i,j,k,d[510][510]={};\n  while(scanf(\"%d\",&n),n){\n    for(i=0;i<310*310;i++)d[i/310][i%310]=0;\n    for(i=0;i<n;i++)scanf(\"%d\",&m[i]);\n    for(i=0;i<=n;i++){\n      for(j=0;i+j<=n;j++){\n\tif(i<2)d[j][j+i]=0;\n\telse if(d[j+1][j+i-1]+2==i&&abs(m[j]-m[j+i-1])<2)d[j][j+i]=i;\n\telse{\n\t  for(k=j+1;k<i+j;k++)d[j][j+i]=MAX(d[j][j+i],d[j][k]+d[k][j+i]);\n\t}//printf(\"%d %d %d\\n\",j,j+i,d[j][j+i]);\n      }\n    }\n    /*for(i=0;i<=n;i++){\n      for(j=0;j<=n;j++)printf(\"%2d \",d[i][j]);printf(\"\\n\");\n      }//*/\n    printf(\"%d\\n\",d[0][n]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1611: Daruma Otoshi\n// 2018.1.30 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint w[301];\nchar d[301][301];\nint dp[301][301];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, j, k, m, t;\n\n\twhile (n = in()) {\n\t\tfor (i = 0; i < n; i++) w[i] = in();\n\t\tmemset(d, 0, sizeof(d));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\td[i][i] = 1;\n\t\t\tfor (j = i+1; j < n; j++) {\n\t\t\t\tt = w[i] - w[j];\n\t\t\t\tif (-1 <= t && t <= 1) d[j][i] = d[i][j] = 1;\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (m = 1; m < n; m++) for (i = 0; i < n - m; i++) {\n\t\t\tj = i+m;\n\t\t\tif (d[i][j] && dp[i+1][j-1] == m-1) dp[i][j] = m+1;\n\t\t\telse {\n\t\t\t\tfor (k = i; k < j; k++) {\n\t\t\t\t\tt = dp[i][k] + dp[k+1][j];\n\t\t\t\t\tif (t > dp[i][j]) dp[i][j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][n-1]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n\nint main() {\n\n\tint n;\n\tint *w;\n\tint **dp;\n\tint i,j,k;\n\n\tfor(;;) {\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tw = malloc((n+1) * sizeof(int));\n\t\tdp = malloc((n+1) * sizeof(int));\n\t\tfor(i=0;i<=n;i++)\n\t\t\tdp[i]=malloc((n+1) * sizeof(int));\n\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%d\",&w[i]);\n\n\t\tfor(i=0;i<n+1;i++)\n\t\t\tfor(j=0;j<n+1;j++)\n\t\t\t\tdp[i][j]=0;;\n\n\t\t//??????DP\n\t\tfor(i=n-1;i>=0;i--) {\n\t\t\tdp[i][i]=0;\n\t\t\tdp[i][i+1]=0;\n\t\t\tfor(j=i+1;j<=n;j++) {\n\t\t\t\tif(i+1<j&&abs(w[i]-w[j-1])<=1&&dp[i+1][j-1]==j-i-2)\n\t\t\t\t\tdp[i][j]=j-i;\n\t\t\t\tfor(k=j+1;k<=n;k++) {\n\t\t\t\t\tif(dp[i][k]<(dp[i][j]+dp[j][k]))\n\t\t\t\t\t\t\tdp[i][k]=dp[i][j]+dp[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[0][n]);\n\t\tfree(w);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1611: Daruma Otoshi\n// 2018.1.30 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint w[301];\nint dp[301][301];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, j, k, m, t;\n\n\twhile (n = in()) {\n\t\tfor (i = 0; i < n; i++) w[i] = in();\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tfor (k = 2; k <= n; k++) for (i = 0; i <= n - k; i++) {\n\t\t\tj = i+k-1;\n\t\t\tif (dp[i+1][j-1] == k-2 && -1 <= w[i]-w[j] && w[i]-w[j] <= 1) dp[i][j] = k;\n\t\t\tfor (m = i; m < j; m++) {\n\t\t\t\tt = dp[i][m] + dp[m+1][j];\n\t\t\t\tif (t > dp[i][j]) dp[i][j] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][n-1]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint MAX(int a,int b){return a<b?b:a;}\nint main(){\n  int n,m[1010],i,j,k,d[510][510]={};\n  while(scanf(\"%d\",&n),n){\n    for(i=0;i<310*310;i++)d[i/310][i%310]=0;\n    for(i=0;i<n;i++)scanf(\"%d\",&m[i]);\n    for(i=0;i<=n;i++){\n      for(j=0;i+j<=n;j++){\n\tif(i<2)d[j][j+i]=0;\n\telse if(d[j+1][j+i-1]+2==i&&abs(m[j]-m[j+i-1])<2)d[j][j+i]=i;\n\telse{\n\t  for(k=j+1;k<i+j;k++)d[j][j+i]=MAX(d[j][j+i],d[j][k]+d[k][j+i]);\n\t}\n      }\n    }\n    printf(\"%d\\n\",d[0][n]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n\nint main() {\n\n\tint n;\n\tint *w;\n\tint **dp;\n\tint i,j,k;\n\n\tfor(;;) {\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tw = malloc((n+1) * sizeof(int));\n\t\tdp = malloc((n+1) * sizeof(int));\n\t\tfor(i=0;i<=n;i++)\n\t\t\tdp[i]=malloc((n+1) * sizeof(int));\n\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%d\",&w[i]);\n\n\t\tfor(i=0;i<n+1;i++)\n\t\t\tfor(j=0;j<n+1;j++)\n\t\t\t\tdp[i][j]=0;;\n\n\t\t//??????DP\n\t\tfor(i=n-1;i>=0;i--) {\n\t\t\tdp[i][i]=0;\n\t\t\tdp[i][i+1]=0;\n\t\t\tfor(j=i+1;j<=n;j++) {\n\t\t\t\tif(i+1<j&&abs(w[i]-w[j-1])<=1&&dp[i+1][j-1]==j-i-2)\n\t\t\t\t\tdp[i][j]=j-i;\n\t\t\t\tfor(k=j+1;k<=n;k++) {\n\t\t\t\t\tif(dp[i][k]<(dp[i][j]+dp[j][k]))\n\t\t\t\t\t\t\tdp[i][k]=dp[i][j]+dp[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[0][n]);\n\t\tfree(w);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define REP(i,n) for(int i=0; i<n; i++)\nint dp[301][301];\nint main(void){\n    int n,w[300];\n    int x;\n    int dp[301][301];\n    while(scanf(\"%d\",&n),n){\n        memset(dp,0,sizeof dp);\n        if(n==0) break;\n        for(int i=0;i<n;i++){\n            scanf(\"%d\",&x);\n            w[i]=x;\n        }\n        for (int i=n-1; i>=0; i--) {\n            dp[i][i] = 0;\n            //dp[i][i+1] = 0;\n            for (int j=i+1; j<n; j++) {\n                if(j==i+1 && (abs(w[i] - w[j]) <= 1)) dp[i][j]=2;\n                else if (/*i + 1 < j && */(abs(w[i] - w[j]) <= 1) && dp[i+1][j-1] == j-i-1)\n                    dp[i][j] = j - i + 1;\n                \n                for (int k=j; k<n; k++)\n                    if(dp[i][k]<dp[i][j-1] + dp[j][k])\n                        dp[i][k]=dp[i][j-1] + dp[j][k];\n            }\n        }\n        \n        printf(\"%d\\n\", dp[0][n-1]);\n        /*REP(i,n+1) {\n            REP(j,n+1){\n                printf(\"%d \",dp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1611: Daruma Otoshi\n// 2018.1.30 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint w[301], d[301][301];\nint dp[301][301];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, j, k, m, t;\n\n\twhile (n = in()) {\n\t\tfor (i = 0; i < n; i++) w[i] = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\td[i][i] = 1;\n\t\t\tfor (j = i+1; j < n; j++) {\n\t\t\t\tt = w[i] - w[j];\n\t\t\t\td[j][i] = d[i][j] = (-1 <= t && t <= 1);\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tfor (k = 2; k <= n; k++) for (i = 0; i <= n - k; i++) {\n\t\t\tj = i+k-1;\n\t\t\tif (dp[i+1][j-1] == k-2 && d[i][j]) dp[i][j] = k;\n\t\t\tfor (m = i; m < j; m++) {\n\t\t\t\tt = dp[i][m] + dp[m+1][j];\n\t\t\t\tif (t > dp[i][j]) dp[i][j] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][n-1]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint w[300], can_erase[301][301], dp[301][301];\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint ABS(int a){\n\treturn a >= 0 ? a : -a;\n}\n\nint main(){\n\tint N, i, j, k;\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i = 0; i < N; i++){\n\t\t\tscanf(\"%d\", &w[i]);\n\t\t}\n\t\tfor(i = 0; i < N; i++){\n\t\t\tfor(j = i + 1; j <= N; j++){\n\t\t\t\tcan_erase[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i <= N; i++){\n\t\t\tcan_erase[i][i] = 1;\n\t\t}\n\t\tfor(k = 1; k <= N; k++){\n\t\t\tfor(i = 0; i + k <= N; i++){\n\t\t\t\tfor(j = i + 1; j < i + k; j++){\n\t\t\t\t\tif(ABS(w[i] - w[j]) <= 1 && can_erase[i + 1][j] == 1 && can_erase[j + 1][i + k] == 1){\n\t\t\t\t\t\tcan_erase[i][i + k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i <= N; i++){\n\t\t\tfor(j = i; j <= N; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(k = 1; k <= N; k++){\n\t\t\tfor(i = 0; i + k <= N; i++){\n\t\t\t\tdp[i][i + k] = dp[i + 1][i + k];\n\t\t\t\tfor(j = i + 1; j <= i + k; j++){\n\t\t\t\t\tif(can_erase[i][j] == 1){\n\t\t\t\t\t\tdp[i][i + k] = max(dp[i][i + k], dp[j][i + k] + j - i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][N]);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define ABS(a) ((a)>(0)?(a):-(a))\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\n#define POS(l, r) ((l) * (n + 1) + (r))\n\nvoid run (void) {\n  for (;;) {\n    i32 n;\n    scanf (\"%\" SCNi32, &n);\n    if (n == 0) break;\n    i32 *a = ALLOC (n, i32);\n    for (i32 i = 0; i < n; ++i) {\n      scanf (\"%\" SCNi32, a + i);\n    }\n    i32 *dp = ALLOC ((n + 1) * (n + 1), i32);\n    for (i32 len = 2; len <= n; ++len) {\n      for (i32 l = 0; l <= n - len; ++l) {\n        i32 r = l + len;\n        i32 max = 0;\n        for (i32 m = l + 1; m < r; ++m) {\n          max = MAX (max, dp[POS(l, m)] + dp[POS(m, r)]);\n        }\n        for (i32 m = l + 1; m < r; ++m) {\n          if (dp[POS(l + 1, m)] == m - l - 1 && ABS (a[l] - a[m]) <= 1) {\n            max = MAX (max, m + 1 - l + dp[POS(m + 1, r)]);\n          }\n        }\n        dp[POS(l, r)] = max;\n      }\n    }\n    printf (\"%\" PRIi32 \"\\n\", dp[POS(0, n)]);\n  }\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint MAX(int a,int b){return a<b?b:a;}\nint main(){\n  int n,m[1010],i,j,k,d[510][510]={};\n  while(scanf(\"%d\",&n),n){\n    for(i=0;i<n;i++)scanf(\"%d\",&m[i]);\n    for(i=0;i<=n;i++){\n      for(j=0;i+j<=n;j++){\n\tif(i<2)d[j][j+i]=0;\n\telse if(d[j+1][j+i-1]+2==i&&abs(m[j]-m[j+i-1])<2)d[j][j+i]=i;\n\telse{\nd[j][j+i]=0;\n\t  for(k=j+1;k<i+j;k++)d[j][j+i]=MAX(d[j][j+i],d[j][k]+d[k][j+i]);\n\t}\n      }\n    }\n    printf(\"%d\\n\",d[0][n]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n\nint main() {\n\n\tint n;\n\tint *w;\n\tint dp[301][301];\n\tint i,j,k;\n\n\tfor(;;) {\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tw = malloc((n+1) * sizeof(int));\n\t\t//dp = malloc((n+1) * sizeof(int));\n\t\t//for(i=0;i<=n;i++)\n\t\t\t//dp[i]=malloc((n+1) * sizeof(int));\n\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%d\",&w[i]);\n\n\t\tfor(i=0;i<n+1;i++)\n\t\t\tfor(j=0;j<n+1;j++)\n\t\t\t\tdp[i][j]=0;;\n\n\t\t//??????DP\n\t\tfor(i=n-1;i>=0;i--) {\n\t\t\tdp[i][i]=0;\n\t\t\tdp[i][i+1]=0;\n\t\t\tfor(j=i+1;j<=n;j++) {\n\t\t\t\tif(i+1<j&&abs(w[i]-w[j-1])<=1&&dp[i+1][j-1]==j-i-2)\n\t\t\t\t\tdp[i][j]=j-i;\n\t\t\t\tfor(k=j+1;k<=n;k++) {\n\t\t\t\t\tif(dp[i][k]<(dp[i][j]+dp[j][k]))\n\t\t\t\t\t\t\tdp[i][k]=dp[i][j]+dp[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[0][n]);\n\t\tfree(w);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    while(true){\n        val n = readLine()!!.trim().toInt()\n        if (n == 0) return\n        val weights = readLine()!!.trim().split(' ').map(String::toInt).toIntArray()\n        println(solve(weights))\n    }\n}\nfun solve(weights: IntArray): Int {\n    val memo = Array(weights.size){i -> IntArray(weights.size - i){-1}}\n    fun count(from: Int, until: Int): Int {\n        if (until - from <= 1) return 0\n        if (memo[from][until - from - 1] == -1) {\n            memo[from][until - from - 1] = Math.max(count(from + 1, until), (from + 1 until until).filter{mid -> Math.abs(weights[from] - weights[mid]) <= 1 && count(from + 1, mid) == mid - from - 1}.map{mid -> mid - from + 1 + count(mid + 1, until)}.max() ?: 0)\n        }\n        return memo[from][until - from - 1]\n    }\n    return count(0, weights.size)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int dfs(int[] dp, int idx, int down) {\n    if (idx >= dp.length) {\n      return down;\n    }\n    int max = 0;\n    max = Math.max(max, dfs(dp, idx + 1, down));\n    if (dp[idx] > 0) {\n      max = Math.max(max, dfs(dp, idx + dp[idx], down + dp[idx]));\n    }\n    return max;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] w = new int[n];\n      for (int i = 0; i < n; ++i) {\n        w[i] = ni();\n      }\n      int[][] dp = new int[2][n];\n      for (int i = 0; i < n - 1; ++i) {\n        if (Math.abs(w[i] - w[i + 1]) < 2) {\n          dp[0][i] = 2;\n        }\n      }\n      for (int _i = 0; _i < n; ++_i) {\n        for (int j = 0; j < n; ++j) {\n          int i = _i % 2;\n          int target = 1 - i;\n          if (dp[i][j] > 0) {\n            // case 1\n            int left = j - 1;\n            int right = j + dp[i][j];\n            if (0 <= left && right < n) {\n              if (Math.abs(w[left] - w[right]) < 2) {\n                dp[1 - i][left] = Math.max(dp[1 - i][left], dp[i][j] + 2);\n              }\n            }\n            // case 2;\n            if (right < n) {\n              if (dp[i][right] > 0) {\n                dp[1 - i][j] = Math.max(dp[1 - i][j], dp[i][j] + dp[i][right]);\n              }\n            }\n            dp[1 - i][j] = Math.max(dp[1 - i][j], dp[i][j]);\n          }\n        }\n      }\n\n      int ans = Math.max(dfs(dp[0], 0, 0), dfs(dp[1], 0, 0));\n\n      System.out.println(ans);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\tstatic int[] darumas;\n\tstatic int[][] memo;\n\tstatic int max(int i, int j) {\n\t\tif(memo[i][j] == -1) {\n\t\t\tint n = j - i;\n\t\t\tif(n == 1) memo[i][j] = 0;\n\t\t\telse if(n == 2) {\n\t\t\t\tassert(j-1 == i+1);\n\t\t\t\tmemo[i][j] = (Math.abs(darumas[i]-darumas[i+1]) <= 1) ? 2 : 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint lmax = 0;\n\t\t\t\tif(n >= 4) {\n\t\t\t\t\tlmax = max(i+1, j-1);\n\t\t\t\t\tlmax += (lmax == n-2) ? (Math.abs(darumas[i]-darumas[j-1]) <= 1 ? 2 : 0) : 0;\n\t\t\t\t}\n\t\t\t\tfor(int k=i+1; k+1<j; k++) {\n\t\t\t\t\tint top = max(i, k);\n\t\t\t\t\tint bot = max(k, j);\n\t\t\t\t\tif(lmax < top+bot) {\n\t\t\t\t\t\tlmax = top + bot;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemo[i][j] = lmax;\n\t\t\t}\n\t\t}\n\t\treturn memo[i][j];\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0) break;\n\t\t\t\t\n\t\t\t\tdarumas = new int[n];\n\t\t\t\tmemo = new int[n][n+1];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tdarumas[i] = sc.nextInt();\n\t\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max(0, n));\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class D {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = sc.nextInt();\n      }\n      boolean[][] dp = new boolean[n][n];\n      int w;\n      for (w = 2; w <= n; w += 2) {\n        boolean any = false;\n        for (int l = 0; l + w - 1 < n; l++) {\n          if (w == 2) {\n            dp[l][l + 1] = Math.abs(a[l] - a[l + 1]) <= 1;\n            any = any || dp[l][l + 1];\n            // System.out.print(dp[l][l + 1] ? \"1\" : \"0\");\n            continue;\n          }\n          int r = l + w;\n          if (w == 4) {\n            dp[l][r - 1] = (dp[l][l + 1] && dp[r - 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          } else {\n            dp[l][r - 1] = (dp[l][r - 3] && dp[r - 2][r - 1])\n                    || (dp[l][l + 1] && dp[l + 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          }\n          // System.out.print(dp[l][r - 1] ? \"1\" : \"0\");\n          any = any || dp[l][r - 1];\n        }\n        // System.out.println();\n        if (!any) {\n          break;\n        }\n      }\n      int[][] dp2 = new int[n][n];\n      for (int i = 0; i < n - 1; i++) {\n        dp2[i][i + 1] = dp[i][i + 1] ? 2 : 0;\n        // System.out.print(dp2[i][i + 1]);\n      }\n      // System.out.println();\n\n      for (w = 3; w <= n; w ++) {\n        for (int l = 0; l + w - 1 < n; l++) {\n          int r = l + w - 1;\n          if (dp[l][r]) {\n            dp2[l][r] = w;\n            continue;\n          }\n          for (int d = l + 1; d < r; d++) {\n            dp2[l][r] = Math.max(dp2[l][r], dp2[l][d] + dp2[d + 1][r]);\n          }\n          // System.out.print(dp2[l][r]);\n        }\n        // System.out.println();\n      }\n      System.out.println(dp2[0][n - 1]);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n \n \npublic class Main {\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int BIG_NUMBER = 100000000;\n        long LARGE_NUMBER = 10000000000000000L;\n        \n        int h=0, max_tmp=0;\n        while(true){\n            h = sc.nextInt();\n            if(h==0) break;\n            int[] wofB = new int[h];\n            \n        \tfor(int i=0; i<h; i++){\n        \t    wofB[i] = sc.nextInt();\n        \t}\n        \t\n        \tint[][] dp = new int[h][h];   //区間[i,j]におけるmax(取り除ける個数)\n        \t\n        \tfor(int i=0; i<h; i++){\n        \t    dp[i][i] = 0;\n        \t}\n        \tfor(int i=1; i<h; i++){\n        \t    dp[i-1][i] = (abs(wofB[i-1]-wofB[i]) <= 1) ? 2 : 0;\n        \t}\n        \t\n    \t    for(int d=2; d<h; d++){\n    \t        for(int i=0; i<(h-d); i++){\n    \t            if((dp[i+1][i+d-1] == (d-1)) && (abs(wofB[i]-wofB[i+d]) <= 1)){\n    \t                dp[i][i+d] = d+1;\n    \t            }else{\n    \t                max_tmp=0;\n    \t\t            for(int j=i; j<(i+d); j++){\n    \t\t                if((dp[i][j]+dp[j+1][i+d]) > max_tmp) max_tmp = (dp[i][j]+dp[j+1][i+d]);\n    \t\t            }\n    \t\t            dp[i][i+d] = max_tmp;\n    \t            }\n    \t        }\n    \t    }\n            out.println(dp[0][h-1]);\n        }\n        \n    \t\n        out.flush();\n    }\n    \n    private static boolean lunlun(long num){\n        String s_ver=Long.toString(num);\n        int dig=s_ver.length();\n        if(dig==1) return true;\n        for(int i=1; i<dig; i++){\n            if(absL((s_ver.charAt(i-1))-(s_ver.charAt(i)))>1) return false;\n        }\n        return true;\n    }\n    \n    private static int pow2(int in){\n        return in*in;\n    }\n    private static long pow2(long in){\n        return in*in;\n    }\n    \n    private static int minExcept(int[] dt, int ex, char mode){\n        int min=Integer.MAX_VALUE;\n        \n        if(mode =='a'){\n        \tfor(int i=0; i<dt.length; i++){\n        \t    if((i != ex) && (dt[i] < min)) min = dt[i];\n        \t}\n        }else if(mode =='v'){\n        \tfor(int i=0; i<dt.length; i++){\n        \t    if((dt[i] != ex) && (dt[i] < min)) min = dt[i];\n        \t}\n        }\n    \treturn min;\n    }\n    private static long minExcept(long[] dt, int ex, char mode){\n        long min=Long.MAX_VALUE;\n        \n        if(mode =='a'){\n        \tfor(int i=0; i<dt.length; i++){\n        \t    if((i != ex) && (dt[i] < min)) min = dt[i];\n        \t}\n        }else if(mode =='v'){\n        \tfor(int i=0; i<dt.length; i++){\n        \t    if((dt[i] != ex) && (dt[i] < min)) min = dt[i];\n        \t}\n        }\n    \treturn min;\n    }\n    \n    private static int abs(int a){\n        if(a>=0) return a;\n        else return -a;\n    }\n    private static long absL(long a){\n        if(a>=0) return a;\n        else return -a;\n    }\n    private static int min(int a, int b){\n        if(a>b) return b;\n        else return a;\n    }\n    private static long minL(long a, long b){\n        if(a>b) return b;\n        else return a;\n    }\n    private static int min2(int... ins){\n        int min = ins[0];\n        \n    \tfor(int i=1; i<ins.length; i++){\n    \t    if(ins[i] < min) min = ins[i];\n    \t}\n    \treturn min;\n    }\n    private static int max(int a, int b){\n        if(a>b) return a;\n        else return b;\n    }\n    private static long max(long a, long b){\n        if(a>b) return a;\n        else return b;\n    }\n    private static int max2(int... ins){\n        int max = ins[0];\n        \n    \tfor(int i=1; i<ins.length; i++){\n    \t    if(ins[i] > max) max = ins[i];\n    \t}\n    \treturn max;\n    }\n    \n    \n    static void show_i2d_array(long[][] dt){\n        PrintWriter out = new PrintWriter(System.out);\n    \tfor(int i=0; i<dt[0].length; i++){\n    \t\tfor(int j=0; j<dt.length; j++){\n    \t\t    out.print(dt[j][i]+\",\");\n    \t\t}\n    \t\tout.println(\"<-city=\"+i);\n    \t}\n    \tout.flush();\n    }\n    \n    public static void combSort(int[][] origin, int ln){\n        int h=ln*10/13, tmp=0;\n        boolean fin=true;\n        while((h>1)||(!fin)){\n            fin=true;\n            for(int i=0; i < ln-h; i++){\n                if(origin[i][0] > origin[i+h][0]){\n                    tmp=origin[i][0];\n                    origin[i][0]=origin[i+h][0];\n                    origin[i+h][0]=tmp;\n                    tmp=origin[i][1];\n                    origin[i][1]=origin[i+h][1];\n                    origin[i+h][1]=tmp;\n                    fin=false;\n                }\n            }\n            h *=10;\n            h/=13;\n        }\n    }\n}\n \nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n==0)break;\n\n\t\t\tint[] arr = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n\t\t\tint[][] dp = new int[n][n];\n\n\t\t\tfor(int interval = 1; interval<n; interval += 2) {\n\t\t\t\tfor(int start = 0; start+interval<n; start++) {\n\t\t\t\t\t//dp[start][start+interval]\n\n\t\t\t\t\tif(Math.abs(arr[start]-arr[start+interval])<2) {\n\t\t\t\t\t\tif(dp[start+1][start+interval-1]==interval-1) {\n\t\t\t\t\t\t\tdp[start][start+interval] = interval+1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int innerInterval = 1; innerInterval<interval-1; innerInterval+=2) {\n\t\t\t\t\t\t//System.out.println(start+\",\"+interval+\",\"+innerInterval);\n\t\t\t\t\t\tdp[start][start+interval] = Math.max(\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tdp[start][start+interval]\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tdp[start][start+innerInterval] +\n\t\t\t\t\t\t\t\tdp[start+innerInterval+1][start+interval]\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint result = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\t//System.out.printf(\"%3d\",dp[i][j]);\n\t\t\t\t\tresult = Math.max(result,dp[i][j]);\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int dfs(int[] dp, int idx, int down) {\n    if (idx >= dp.length) {\n      return down;\n    }\n    int max = 0;\n    max = Math.max(max, dfs(dp, idx + 1, down));\n    if (dp[idx] > 0) {\n      max = Math.max(max, dfs(dp, idx + dp[idx], down + dp[idx]));\n    }\n    return max;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] w = new int[n];\n      for (int i = 0; i < n; ++i) {\n        w[i] = ni();\n      }\n      int[][] dp = new int[n + 1][n];\n      for (int i = 0; i < n - 1; ++i) {\n        if (Math.abs(w[i] - w[i + 1]) < 2) {\n          dp[2][i] = 2;\n        }\n      }\n      for (int i = 2; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (dp[i][j] > 0) {\n            // case 1\n            int left = j - 1;\n            int right = j + dp[i][j];\n            if (0 <= left && right < n) {\n              if (Math.abs(w[left] - w[right]) < 2) {\n                dp[i + 2][left] = Math.max(dp[i + 2][left], dp[i][j] + 2);\n              }\n            }\n            // case 2;\n            if (right < n) {\n              for (int k = 2; k <= i; ++k) {\n                if (dp[k][right] > 0) {\n                  dp[i + dp[k][right]][j] = Math.max(dp[i + dp[k][right]][j], dp[i][j] + dp[k][right]);\n                }\n              }\n            }\n          }\n        }\n      }\n\n//      int ans = Math.max(dfs(dp[0], 0, 0), dfs(dp[1], 0, 0));\n      int[] dp2 = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        dp2[i + 1] = Math.max(dp2[i + 1], dp2[i]);\n        for (int j = 0; j <= n; ++j) {\n          if (dp[j][i] > 0) {\n            dp2[i + dp[j][i]] = Math.max(dp2[i + dp[j][i]], dp2[i] + dp[j][i]);\n          }\n        }\n      }\n\n      System.out.println(dp2[n]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int[][] dp = new int[301][301];\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\tint[] a = ir.nextIntArray(n);\n\t\t\tout.println(dfs(0, n, a));\n\t\t}\n\t}\n\n\tstatic int dfs(int l, int r, int[] a) {\n\t\tif (dp[l][r] >= 0)\n\t\t\treturn dp[l][r];\n\t\tif (l + 1 >= r)\n\t\t\treturn dp[l][r] = 0;\n\t\tint ret = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tfor (int j = i + 1; j < r; j += 2) {\n\t\t\t\tif (Math.abs(a[i] - a[j]) <= 1 && dfs(i + 1, j, a) == j - i - 1) {\n\t\t\t\t\tret = Math.max(ret, dfs(l, i, a) + dfs(j + 1, r, a) + j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[l][r] = ret;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        while (true) {\n            int n = Integer.parseInt(scan.next());\n            if (n == 0) {\n                break;\n            }\n\n            int[] w = new int[n];\n            for (int i = 0; i < n; i++) {\n                w[i] = Integer.parseInt(scan.next());\n            }\n\n            int dp[][] = new int[n + 1][n + 1];\n            for (int i = 2; i <= n; i++) {\n                for (int j = 0; j + i <= n; j++) {\n                    for (int k = j; k <= j + i; k++) {\n                        dp[j][j + i] = Math.max(dp[j][j + i], dp[j][k] + dp[k][j + i]);\n                    }\n\n                    if (dp[j + 1][j + i - 1] == i - 2 && Math.abs(w[j] - w[j + i - 1]) <= 1) {\n                        dp[j][j + i] = i;\n                    }\n                }\n            }\n\n            System.out.println(dp[0][n]);\n        }\n        scan.close();\n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n==0)break;\n\n\t\t\tint[] arr = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n\t\t\tint[][] dp = new int[n][n];\n\n\t\t\tfor(int interval = 0; interval<n; interval += 2) {\n\t\t\t\tfor(int start = 0, end = start + interval + 1; end < n; start++, end++) {\n\t\t\t\t\t//System.out.printf(\"start:%3d , end:%3d\\n\",start,end);\n\n\t\t\t\t\tif(Math.abs(arr[start]-arr[end])<2) {\n\t\t\t\t\t\tif(dp[start+1][end-1]==interval) {\n\t\t\t\t\t\t\tdp[start][end] = interval+2;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[start][end] = dp[start+1][end-1];\n\n\t\t\t\t\tfor(int innerInterval = 0; innerInterval<interval; innerInterval+=2) {/*\n\t\t\t\t\t\tif(dp[start][end]<dp[start][start+innerInterval+1]+dp[start+innerInterval+2][end]) {\n\t\t\t\t\t\t\tSystem.out.println(\"\\t kakoikomi\");\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tdp[start][end] = Math.max(\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tdp[start][end]\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tdp[start][start+innerInterval+1] +\n\t\t\t\t\t\t\t\tdp[start+innerInterval+2][end]\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t//System.out.println(\"------\\n\");\n\t\t\t}\n\n\t\t\tint result = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\t//System.out.printf(\"%3d\",dp[i][j]);\n\t\t\t\t\tresult = Math.max(result,dp[i][j]);\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DarumaOtoshi solver = new DarumaOtoshi();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DarumaOtoshi {\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            while (true) {\n                int n = in.Int();\n                if (n == 0) return;\n                int[] w = in.Int(n);\n                int[][] dp = new int[n + 1][n + 1];\n                for (int i = 0; i < n; i++) {\n                    Arrays.fill(dp[i], -1);\n                }\n                int ans = calc(w, dp, 0, n);\n                out.println(ans);\n            }\n        }\n\n        private int calc(int[] w, int[][] dp, int l, int r) {\n            if (dp[l][r] != -1) {\n                return dp[l][r];\n            }\n            if (r <= l) {\n                return 0;\n            }\n            int ret = 0;\n            if (Math.abs(w[l] - w[r - 1]) <= 1 && calc(w, dp, l + 1, r - 1) == r - l - 2) {\n                ret = r - l;\n            }\n            for (int i = l + 1; i < r; i++) {\n                ret = Math.max(ret, calc(w, dp, l, i) + calc(w, dp, i, r));\n            }\n            return dp[l][r] = ret;\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] Int(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = Int();\n            }\n            return a;\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n/**\n * Created by Santa.\n */\npublic class Main {\n\n    static long N;\n    static int M;\n    static int A;\n    static long B;\n    static long C;\n    static int[] map = new int[1000000];\n    static int min = 9999999;\n\n\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while(true) {\n            int N = scanner.nextInt();\n            if(N == 0)break;\n            int[] A = new int[N];\n            int[][] dp = new int[N][N];\n            for (int i = 0; i < N; i++) {\n                A[i] = scanner.nextInt();\n            }\n\n            for (int w = 1; w < N; w++) {\n                for (int i = 0; i < N - w; i++) {\n                    int j = i + w;\n                    int max = 0;\n\n                    for (int k = i; k <= j - 1; k++) {\n                        max = Math.max(max, dp[i][k] + dp[k + 1][j]);\n                    }\n\n                    if(Math.abs(A[i] - A[j]) <= 1 && w % 2 == 1 && dp[i + 1][j - 1] == w - 1){\n                        max = w + 1;\n                    }\n                    dp[i][j] = max;\n                }\n            }\n\n            System.out.println(dp[0][N - 1]);\n\n        }\n\n\n\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class D {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = sc.nextInt();\n      }\n      boolean[][] dp = new boolean[n][n];\n      int w;\n      for (w = 2; w <= n; w += 2) {\n        boolean any = false;\n        for (int l = 0; l + w - 1 < n; l++) {\n          if (w == 2) {\n            dp[l][l + 1] = Math.abs(a[l] - a[l + 1]) <= 1;\n            any = any || dp[l][l + 1];\n//            System.out.printf(\"%3s\", dp[l][l + 1] ? \"1\" : \"0\");\n            continue;\n          }\n          int r = l + w;\n          if (w == 4) {\n            dp[l][r - 1] = (dp[l][l + 1] && dp[r - 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          } else {\n            dp[l][r - 1] = (dp[l][r - 3] && dp[r - 2][r - 1])\n                    || (dp[l][l + 1] && dp[l + 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          }\n          // 0, 1, 2, 3, 4, 5, 6, 7\n//          System.out.printf(\"%3s\", dp[l][r - 1] ? \"1\" : \"0\");\n          any = any || dp[l][r - 1];\n        }\n//        System.out.println();\n        if (!any) {\n          break;\n        }\n      }\n      int[][] dp2 = new int[n][n];\n      for (int i = 0; i < n - 1; i++) {\n        dp2[i][i + 1] = dp[i][i + 1] ? 2 : 0;\n//        System.out.printf(\"%3d\", dp2[i][i + 1]);\n      }\n//      System.out.println();\n\n      for (w = 4; w <= n; w += 2) {\n        for (int l = 0; l + w - 1 < n; l++) {\n          int r = l + w - 1;\n          if (dp[l][r]) {\n            dp2[l][r] = w;\n          } else {\n            for (int d = l + 2; d <= r - 1; d += 2) {\n              dp2[l][r] = Math.max(dp2[l][r], dp2[l][d - 1] + dp2[d][r]);\n            }\n          }\n//          System.out.printf(\"%3d\", dp2[l][r]);\n        }\n//        System.out.println();\n      }\n      if (n % 2 == 1) {\n        System.out.println(Math.max(dp2[0][n - 2], dp2[1][n - 1]));\n      } else {\n        System.out.println(dp2[0][n - 1]);\n      }\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = sc.nextInt();\n      }\n      boolean[][] dp = new boolean[n][n];\n      int w;\n      for (w = 2; w <= n; w += 2) {\n        boolean any = false;\n        for (int l = 0; l + w - 1 < n; l++) {\n          if (w == 2) {\n            dp[l][l + 1] = Math.abs(a[l] - a[l + 1]) <= 1;\n            any = any || dp[l][l + 1];\n            // System.out.print(dp[l][l + 1] ? \"1\" : \"0\");\n            continue;\n          }\n          int r = l + w;\n          if (w == 4) {\n            dp[l][r - 1] = (dp[l][l + 1] && dp[r - 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          } else {\n            dp[l][r - 1] = (dp[l][r - 3] && dp[r - 2][r - 1])\n                    || (dp[l][l + 1] && dp[l + 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          }\n          // System.out.print(dp[l][r - 1] ? \"1\" : \"0\");\n          any = any || dp[l][r - 1];\n        }\n        // System.out.println();\n        if (!any) {\n          break;\n        }\n      }\n      int[][] dp2 = new int[n][n];\n      for (int i = 0; i < n - 1; i++) {\n        dp2[i][i + 1] = dp[i][i + 1] ? 2 : 0;\n        // System.out.print(dp2[i][i + 1]);\n      }\n      // System.out.println();\n\n      for (w = 3; w <= n; w ++) {\n        for (int l = 0; l + w - 1 < n; l++) {\n          int r = l + w - 1;\n          if (dp[l][r]) {\n            dp2[l][r] = w;\n            continue;\n          }\n          for (int d = l + 1; d < r; d++) {\n            dp2[l][r] = Math.max(dp2[l][r], dp2[l][d] + dp2[d + 1][r]);\n          }\n          // System.out.print(dp2[l][r]);\n        }\n        // System.out.println();\n      }\n      System.out.println(dp2[0][n - 1]);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Daruma Otoshi\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tint[] bs = new int[n];\n\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbs[i] = parseInt(st.nextToken());\n\t\t\t}\n\n\t\t\tcount = 0;\n\n\t\t\tsolve(0, bs);\n\n\t\t\tSystem.out.println(count);\n\n\t\t} //end while\n\t} //end main\n\n\tstatic void solve(int c, int[] bs) {\n\n\t\tif (c + bs.length <= count) {\n\t\t\treturn;\n\t\t}\n\n\t\tint r = 0;\n\n\t\tfor (int i = 0; i < bs.length - 1; i++) {\n\t\t\tif (Math.abs(bs[i] - bs[i + 1]) < 2) {\n\t\t\t\tint[] _blocks = new int[bs.length - 2];\n\t\t\t\tfor (int j = 0, k = 0; j < bs.length; j++) {\n\t\t\t\t\tif (j != i && j != i + 1) {\n\t\t\t\t\t\t_blocks[k] = bs[j];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsolve(c + 2, _blocks);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tif (r == 0 && c > count) {\n\t\t\tcount = c;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = sc.nextInt();\n      }\n      boolean[][] dp = new boolean[n][n];\n      int w;\n      for (w = 2; w <= n; w += 2) {\n        boolean any = false;\n        for (int l = 0; l + w - 1 < n; l++) {\n          if (w == 2) {\n            dp[l][l + 1] = Math.abs(a[l] - a[l + 1]) <= 1;\n            any = any || dp[l][l + 1];\n//            System.out.printf(\"%3s\", dp[l][l + 1] ? \"1\" : \"0\");\n            continue;\n          }\n          int r = l + w;\n          if (w == 4) {\n            dp[l][r - 1] = (dp[l][l + 1] && dp[r - 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          } else {\n            dp[l][r - 1] = (dp[l][r - 3] && dp[r - 2][r - 1])\n                    || (dp[l][l + 1] && dp[l + 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          }\n          // 0, 1, 2, 3, 4, 5, 6, 7\n//          System.out.printf(\"%3s\", dp[l][r - 1] ? \"1\" : \"0\");\n          any = any || dp[l][r - 1];\n        }\n//        System.out.println();\n        if (!any) {\n          break;\n        }\n      }\n      int[][] dp2 = new int[n][n];\n      for (int i = 0; i < n - 1; i++) {\n        dp2[i][i + 1] = dp[i][i + 1] ? 2 : 0;\n//        System.out.printf(\"%3d\", dp2[i][i + 1]);\n      }\n//      System.out.println();\n\n      for (w = 4; w <= n; w += 2) {\n        for (int l = 0; l + w - 1 < n; l++) {\n          int r = l + w - 1;\n          if (dp[l][r]) {\n            dp2[l][r] = w;\n          } else {\n            for (int d = l + 2; d <= r - 1; d += 2) {\n              dp2[l][r] = Math.max(dp2[l][r], dp2[l][d - 1] + dp2[d][r]);\n            }\n          }\n//          System.out.printf(\"%3d\", dp2[l][r]);\n        }\n//        System.out.println();\n      }\n      if (n % 2 == 1) {\n        System.out.println(Math.max(dp2[0][n - 2], dp2[1][n - 1]));\n      } else {\n        System.out.println(dp2[0][n - 1]);\n      }\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tstatic int[][] dp=new int[301][301];\n\tstatic int[] w=new int[301];\n\tstatic int rec(int l, int r) {\n\t\tif(dp[l][r]<0) {\n\t\t\treturn dp[l][r];\n\t\t}\n\t\tif(l>=r) {\n\t\t\treturn 0;\n\t\t}\n\t\tint res=0;\n\t\tif(Math.abs(w[l]-w[r])<=1 && rec(l+1, r-1)==r-l-1) {\n\t\t\tres = r- l + 1;\n\t\t}\n\t\tfor(int mid=l; mid<r; mid++) {\n\t\t\tres = Math.max(res, rec(l,mid)+rec(mid+1,r));\n\t\t}\n\t\treturn dp[l][r]=res;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tw[i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t\tSystem.out.println(rec(0, n-1));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Daruma Otoshi\n */\npublic class Main {\n\n\tstatic int count;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tint[] bs = new int[n];\n\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbs[i] = parseInt(st.nextToken());\n\t\t\t}\n\n\t\t\tcount = 0;\n\n\t\t\tsolve(0, bs);\n\n\t\t\tSystem.out.println(count);\n\n\t\t} //end while\n\t} //end main\n\n\tstatic void solve(int c, int[] bs) {\n\n\t\tint r = 0;\n\n\t\tfor (int i = 0; i < bs.length - 1; i++) {\n\t\t\tif (Math.abs(bs[i] - bs[i + 1]) < 2) {\n\t\t\t\tint[] _blocks = new int[bs.length - 2];\n\t\t\t\tfor (int j = 0, k = 0; j < bs.length; j++) {\n\t\t\t\t\tif (j != i && j != i + 1) {\n\t\t\t\t\t\t_blocks[k] = bs[j];\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsolve(c + 2, _blocks);\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\n\t\tif (r == 0 && c > count) {\n\t\t\tcount = c;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n    static int n;\n    static int[] a;\n    static int[][] dp;\n\n    static int rec(int l, int r) {\n        if (dp[l][r]!=-1) return dp[l][r];\n        if (Math.abs(r-l)<=1) return 0;\n\n        int res = 0;\n        if (Math.abs(a[r-1]-a[l])<=1 && rec(l+1, r-1)==r-l-2) {\n            res = r-l;\n        }\n\n        for (int mid=l+1;mid<r;mid++) {\n            res = Math.max(res, rec(l, mid)+rec(mid, r));\n        }\n        dp[l][r] = res;\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            n = sc.nextInt();\n            if (n==0) break;\n            a = new int[n];\n            dp = new int[n][n+1];\n            for (int i=0;i<n;i++) {\n                for (int j=0;j<n+1;j++) {\n                    dp[i][j] = -1;\n                }\n            }\n            for (int i=0;i<n;i++) {\n                a[i] = sc.nextInt();\n            }\n            System.out.println(rec(0, n));\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main  {\n\t\tpublic static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\n\t\twhile (true) {\n\t\t\tint n=sc.nextInt();\n\t\t\tif (n==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] w=sc.nextIntArray(n);\n\t\t\tboolean[][] possible=new boolean[n][n];\n\t\t\tfor (int i = 0; i < possible.length-1; i++) {\n\t\t\t\tif (Math.abs(w[i]-w[i+1])<=1) {\n\t\t\t\t\tpossible[i][i+1]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 2; i < possible.length; i++) {\n\t\t\t\tfor (int j = 0; j < possible.length-i; j++) {\n\t\t\t\t\tif (possible[j+1][j+i-1]&&Math.abs(w[j]-w[j+i])<=1) {\n\t\t\t\t\t\tpossible[j][j+i]=true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j2 = j+1; j2 < j+i; j2++) {\n\t\t\t\t\t\tif (possible[j][j2]&&possible[j2+1][j+i]) {\n\t\t\t\t\t\t\tpossible[j][j+i]=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp=new int[n][n];\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < dp.length; j++) {\n\t\t\t\t\tif (possible[i][j]) {\n\t\t\t\t\t\tdp[i][j]=j-i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 2; i < dp.length; i++) {\n\t\t\t\tfor (int j = 0; j < dp.length-i; j++) {\n\t\t\t\t\tfor (int j2 = j; j2 < j+i; j2++) {\n\t\t\t\t\t\tdp[j][j+i]=Math.max(dp[j][j+i], dp[j][j2]+dp[j2+1][j+i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(dp[0][n-1]);\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\tstatic class InputReader { \n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n \n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n \n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n \n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int dfs(int[] dp, int idx, int down) {\n    if (idx >= dp.length) {\n      return down;\n    }\n    int max = 0;\n    max = Math.max(max, dfs(dp, idx + 1, down));\n    if (dp[idx] > 0) {\n      max = Math.max(max, dfs(dp, idx + dp[idx], down + dp[idx]));\n    }\n    return max;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] w = new int[n];\n      for (int i = 0; i < n; ++i) {\n        w[i] = ni();\n      }\n      int[][] dp = new int[n + 1][n];\n      for (int i = 0; i < n - 1; ++i) {\n        if (Math.abs(w[i] - w[i + 1]) < 2) {\n          dp[2][i] = 2;\n        }\n      }\n      for (int i = 2; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (dp[i][j] > 0) {\n            // case 1\n            int left = j - 1;\n            int right = j + dp[i][j];\n            if (0 <= left && right < n) {\n              if (Math.abs(w[left] - w[right]) < 2) {\n                dp[i + 2][left] = Math.max(dp[i + 2][left], dp[i][j] + 2);\n              }\n            }\n            // case 2;\n            if (right < n) {\n              for (int k = 2; k <= i; ++k) {\n                if (dp[k][right] > 0) {\n                  dp[i + dp[k][right]][j] = Math.max(dp[i + dp[k][right]][j], dp[i][j] + dp[k][right]);\n                }\n              }\n            }\n            // ?????????????????£???\n            for (int k = 1; 0 <= j - k; ++k) {\n              if (dp[k][j - k] == k) {\n                dp[i + k][j - k] = Math.max(dp[i + k][j - k], dp[i][j] + dp[k][j - k]);\n              }\n            }\n          }\n        }\n      }\n\n//      int ans = Math.max(dfs(dp[0], 0, 0), dfs(dp[1], 0, 0));\n      int[] dp2 = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        dp2[i + 1] = Math.max(dp2[i + 1], dp2[i]);\n        for (int j = 0; j <= n; ++j) {\n          if (dp[j][i] > 0) {\n            dp2[i + dp[j][i]] = Math.max(dp2[i + dp[j][i]], dp2[i] + dp[j][i]);\n          }\n        }\n      }\n\n      System.out.println(dp2[n]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n    static int[][] dp;\n    public static void main(String[] args){\n        Scanner ir=new Scanner(System.in);\n        outer:\n        for(;;){\n            int n=ir.nextInt();\n            if(n==0){\n                System.exit(0);\n            }\n            int[] a=new int[n];\n            for(int i=0;i<n;i++){\n                a[i]=ir.nextInt();\n            }\n            dp=new int[n][n];\n            int MIN=-(1<<30);\n            for(int i=0;i<n;i++){\n                Arrays.fill(dp[i],MIN);\n                dp[i][i]=0;\n            }\n            System.out.println(dfs(0,n-1,a));\n        }\n    }\n\n    static int dfs(int l,int r,int[] a){\n        if(l>=r){\n            return 0;\n        }\n        if(dp[l][r]>=0){\n            return dp[l][r];\n        }\n        int res=dfs(l+1,r,a);\n        for(int i=l+1;i<=r;i++){\n            if(Math.abs(a[l]-a[i])<=1&&dfs(l+1,i-1,a)==i-l-1){\n                res=Math.max(res,2+dfs(l+1,i-1,a)+dfs(i+1,r,a));\n            }\n        }\n        return dp[l][r]=res;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while(true) {\n            int n=sc.nextInt();\n            if (n == 0) {\n                break;\n            }\n            int[] minN = new int[n];\n            int[] maxN = new int[n];\n            for (int i=0;i<n;i++) {\n                maxN[i] = minN[i] = sc.nextInt();\n            }\n            int maxS = 0, minS = 0;\n            int min,max;\n            int index;\n\n            while(true) {\n                index = -1;\n                max = 0;\n                for (int i = 0; i < n - maxS - 1; i++) {\n                    if (Math.abs(maxN[i] - maxN[i + 1]) > 1) {\n                        continue;\n                    }\n                    if (maxN[i] * maxN[i + 1] > max) {\n                        max = maxN[i] * maxN[i + 1];\n                        index = i;\n                    }\n                }\n                if (index == -1) {\n                    break;\n                }\n                for (int i = index; i < n - maxS - 2; i++) {\n                    maxN[i] = maxN[i + 2];\n                }\n                maxS += 2;\n            }\n\n            while(true) {\n                index = -1;\n                min = 1000001;\n                for (int i = 0; i < n - minS - 1; i++) {\n                    if (Math.abs(minN[i] - minN[i + 1]) > 1) {\n                        continue;\n                    }\n                    if (minN[i] * minN[i + 1] < min) {\n                        min = minN[i] * minN[i + 1];\n                        index = i;\n                    }\n                }\n                if (index == -1) {\n                    break;\n                }\n                for (int i = index; i < n - minS - 2; i++) {\n                    minN[i] = minN[i + 2];\n                }\n                minS += 2;\n            }\n            System.out.println(minS>maxS?minS:maxS);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] darmas;\n\tstatic int[][] memo;\n\tstatic int max(int i, int j) {\n\t\tif(memo[i][j] == -1) {\n\t\t\tint n = j - i;\n\t\t\tif(n == 1) {\n\t\t\t\tmemo[i][j] = 0;\n\t\t\t}\n\t\t\telse if(n == 2) {\n\t\t\t\tassert(j-1 == i+1);\n\t\t\t\tmemo[i][j] = (Math.abs(darmas[i] - darmas[i+1]) <= 1) ? 2 : 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint lmax = 0;\n\t\t\t\tif(n >= 4) {\n\t\t\t\t\tlmax = max(i+1, j-1);\n\t\t\t\t\tlmax += (lmax == n-2) ? ( Math.abs(darmas[i] - darmas[j-1]) <= 1 ? 2 : 0) : 0;\n\t\t\t\t}\n\t\t\t\tfor(int k = i + 1; k + 1 < j; k++) {\n\t\t\t\t\tint top = max(i,k);\n\t\t\t\t\tint bot = max(k, j);\n\t\t\t\t\tif(lmax < top + bot) {\n\t\t\t\t\t\tlmax = top + bot;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemo[i][j] = lmax;\n\t\t\t}\n\t\t}\n\t\treturn memo[i][j];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\tfor(int n = sc.nextInt(); n!= 0; n = sc.nextInt()) {\n\t\t\t\tdarmas = new int[n];\n\t\t\t\tmemo = new int[n][n+1];\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tdarmas[i] = sc.nextInt();\n\t\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max(0, n));\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic int[] daruma;\n\tstatic int[][] memo;\n\tstatic int max(int i, int j) {//番目\n\t\tif(memo[i][j]==-1) {\n\t\t\tint n=j-i;\n\t\t\tif(n==1) {\n\t\t\t\tmemo[i][j]=0;\n\t\t\t}//個数が1個の時\n\t\t\telse if(n==2) {\n\t\t\t\tassert(j-1==i+1);\n\t\t\t\tmemo[i][j]=(Math.abs(daruma[i]-daruma[i+1])<=1)? 2:0;\n\t\t\t}//個数が2個の時\n\t\t\telse {\n\t\t\t\tint lmax=0;\n\t\t\t\tif(n>=4) {//両端のやつが消せるかどうか\n\t\t\t\t\tlmax=max(i+1, j-1);\n\t\t\t\t\tlmax+=(lmax==n-2)?(Math.abs(daruma[i]-daruma[j-1])<=1? 2:0):0;\n\t\t\t\t}//両端以外が消えていたら、両端が条件満たすとき加え、消えてないときは0\n\t\t\t\tfor(int k=i+1; k+1<j; k++) {//二つのブロックにわけていく\n\t\t\t\t\tint top=max(i, k);\n\t\t\t\t\tint bot=max(k, j);\n\t\t\t\t\tif(lmax<top+bot) {\n\t\t\t\t\t\tlmax=top+bot;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemo[i][j]=lmax;\n\t\t\t}\n\t\t}\n\t\treturn memo[i][j];\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0) break;\n\t\t\t\tdaruma=new int[n];\n\t\t\t\tmemo=new int[n][n+1];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tdaruma[i]=sc.nextInt();\n\t\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max(0,n));\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int dfs(int[] dp, int idx, int down) {\n    if (idx >= dp.length) {\n      return down;\n    }\n    int max = 0;\n    max = Math.max(max, dfs(dp, idx + 1, down));\n    if (dp[idx] > 0) {\n      max = Math.max(max, dfs(dp, idx + dp[idx], down + dp[idx]));\n    }\n    return max;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] w = new int[n];\n      for (int i = 0; i < n; ++i) {\n        w[i] = ni();\n      }\n      int[][] dp = new int[2][n];\n      for (int i = 0; i < n - 1; ++i) {\n        if (Math.abs(w[i] - w[i + 1]) < 2) {\n          dp[0][i] = 2;\n        }\n      }\n      for (int _i = 0; _i < n; ++_i) {\n        for (int j = 0; j < n; ++j) {\n          int i = _i % 2;\n          if (dp[i][j] > 0) {\n            // case 1\n            int left = j - 1;\n            int right = j + dp[i][j];\n            if (0 <= left && right < n) {\n              if (Math.abs(w[left] - w[right]) < 2) {\n                dp[1 - i][left] = Math.max(dp[1 - i][left], dp[i][j] + 2);\n              }\n            }\n            // case 2;\n            if (right < n) {\n              if (dp[i][right] > 0) {\n                dp[1 - i][j] = Math.max(dp[1 - i][j], dp[i][j] + dp[i][right]);\n              }\n            }\n            dp[1 - i][j] = Math.max(dp[1 - i][j], dp[i][j]);\n          }\n        }\n      }\n\n//      int ans = Math.max(dfs(dp[0], 0, 0), dfs(dp[1], 0, 0));\n      int[] dp2 = new int[n + 1];\n      for (int i = 0; i < n; ++i) {\n        dp2[i + 1] = Math.max(dp2[i + 1], dp2[i]);\n        for (int j = 0; j < 2; ++j) {\n          if (dp[j][i] > 0) {\n            dp2[i + dp[j][i]] = Math.max(dp2[i + dp[j][i]], dp2[i] + dp[j][i]);\n          }\n        }\n      }\n\n      System.out.println(dp2[n]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int dfs(int[] dp, int idx, int down) {\n    if (idx >= dp.length) {\n      return down;\n    }\n    int max = 0;\n    max = Math.max(max, dfs(dp, idx + 1, down));\n    if (dp[idx] > 0) {\n      max = Math.max(max, dfs(dp, idx + dp[idx], down + dp[idx]));\n    }\n    return max;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      int[] w = new int[n];\n      for (int i = 0; i < n; ++i) {\n        w[i] = ni();\n      }\n      int[][] dp = new int[n + 1][n];\n      for (int i = 0; i < n - 1; ++i) {\n        if (Math.abs(w[i] - w[i + 1]) < 2) {\n          dp[2][i] = 2;\n        }\n      }\n      for (int i = 2; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (dp[i][j] > 0) {\n            // case 1\n            int left = j - 1;\n            int right = j + dp[i][j];\n            if (0 <= left && right < n) {\n              if (Math.abs(w[left] - w[right]) < 2) {\n                dp[dp[i][j] + 2][left] = Math.max(dp[dp[i][j] + 2][left], dp[i][j] + 2);\n              }\n            }\n            // case 2;\n            if (right < n) {\n              if (dp[i][right] > 0) {\n                dp[dp[i][j] + dp[i][right]][j] = Math.max(dp[dp[i][j] + dp[i][right]][j], dp[i][j] + dp[i][right]);\n              }\n            }\n            for (int k = i + 1; k <= n; ++k) {\n              dp[k][j] = Math.max(dp[k][j], dp[i][j]);\n            }\n          }\n        }\n      }\n\n      int ans = dfs(dp[n], 0, 0);\n\n      System.out.println(ans);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static int n;\n    static int[] w;\n    static int[][] dp;\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        while(true){\n            n = fs.nextInt();\n            if (n == 0){\n                break;\n            }else if (n == 1){\n                pw.println(0);\n                continue;\n            }\n\n            w = new int[n];\n            for (int i = 0; i < n; i++){\n                w[i] = fs.nextInt();\n            }\n\n            if (n == 2){\n                if (Math.abs(w[0] - w[1]) <= 1){\n                    pw.println(2);\n                }else{\n                    pw.println(0);\n                }\n                continue;\n            }\n\n            dp = new int[n][n];\n            for (int i = 0;i < n - 1; i++){\n                if (Math.abs(w[i + 1] - w[i]) <= 1){\n                    dp[i][i+1] = 2;\n                }\n            }\n\n            for (int s = 2;s < n;s++){\n                for (int l = 0;l + s < n;l++){\n                    int r = l + s;\n                    if (s % 2 == 1){\n                        if (dp[l + 1][r - 1] == s - 1 && Math.abs(w[l] - w[r]) <= 1){\n                            dp[l][r] = s + 1;\n                            continue;\n                        }\n                    }\n                    for (int i = 0; i < s;i++){\n                        dp[l][r] = Math.max(dp[l][r], dp[l][l + i] + dp[l + i + 1][r]);\n                    }\n                }\n            }\n            if (n % 2 == 0){\n                pw.println(dp[0][n-1]);\n            }else{\n                pw.println(Math.max(dp[0][n-2], dp[1][n-1]));\n            }\n        }\n        pw.flush();\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int[][] dp = new int[300][300];\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\tint[] a = ir.nextIntArray(n);\n\t\t\tout.println(dfs(0, n, a));\n\t\t}\n\t}\n\n\tstatic int dfs(int l, int r, int[] a) {\n\t\tif (dp[l][r] >= 0)\n\t\t\treturn dp[l][r];\n\t\tif (l + 1 >= r)\n\t\t\treturn dp[l][r] = 0;\n\t\tif (l + 2 == r)\n\t\t\treturn dp[l][r] = Math.abs(a[l] - a[l + 1]) <= 1 ? 2 : 0;\n\t\tint ret = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tfor (int j = i + 1; j < r; j += 2) {\n\t\t\t\tif (Math.abs(a[i] - a[j]) <= 1 && dfs(i + 1, j, a) == j - i - 1) {\n\t\t\t\t\tret = Math.max(ret, dfs(l, i, a) + dfs(j + 1, r, a) + j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[l][r] = ret;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while(true) {\n            int n=sc.nextInt();\n            if (n == 0) {\n                break;\n            }\n            int[] minN = new int[n];\n            int[] maxN = new int[n];\n            for (int i=0;i<n;i++) {\n                maxN[i] = minN[i] = sc.nextInt();\n            }\n            int maxS = 0, minS = 0;\n            int min,max;\n            int index;\n            // ?????§????????????\n            while(true) {\n                index = -1;\n                max = 0;\n                for (int i = 0; i < n - maxS - 1; i++) {\n                    if (Math.abs(maxN[i] - maxN[i + 1]) > 1) {\n                        continue;\n                    }\n                    if (maxN[i] * maxN[i + 1] > max) {\n                        max = maxN[i] * maxN[i + 1];\n                        index = i;\n                    }\n                }\n                if (index == -1) {\n                    break;\n                }\n                for (int i = index; i < n - maxS - 2; i++) {\n                    maxN[i] = maxN[i + 2];\n                }\n                maxS += 2;\n            }\n            // ????°?????????????\n            while(true) {\n                index = -1;\n                min = 1000001;\n                for (int i = 0; i < n - minS - 1; i++) {\n                    if (Math.abs(minN[i] - minN[i + 1]) > 1) {\n                        continue;\n                    }\n                    if (minN[i] * minN[i + 1] < min) {\n                        min = minN[i] * minN[i + 1];\n                        index = i;\n                    }\n                }\n                if (index == -1) {\n                    break;\n                }\n                for (int i = index; i < n - minS - 2; i++) {\n                    minN[i] = minN[i + 2];\n                }\n                minS += 2;\n            }\n            System.out.println(minS>maxS?minS:maxS);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte())\n            return buffer[ptr++];\n        else\n            return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n            ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n            throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\npublic class Main {\n    static int MOD = 1000000007;\n\n    public static class Mas {\n        int x;\n        int y;\n        int step;\n\n        Mas(int x, int y, int step) {\n            this.x = x;\n            this.y = y;\n            this.step = step;\n        }\n    }\n\n    static long pow(long l, long i) {\n        if (i == 0)\n            return 1;\n        else {\n            if (i % 2 == 0) {\n                long val = pow(l, i / 2);\n                return val * val % 2019;\n            } else {\n                return pow(l, i - 1) * l % 2019;\n            }\n        }\n    }\n\n    private static final int[] vX = { 1, 0, 0, -1 };\n    private static final int[] vY = { 0, 1, -1, 0 };\n\n    public static void main(String[] args) {\n\n        FastScanner fs = new FastScanner();\n        while (true) {\n            int n = fs.nextInt();\n            if (n == 0)\n                break;\n            int[] W = new int[n];\n            for (int i = 0; i < n; i++) {\n                W[i] = fs.nextInt();\n            }\n            int[][] dp = new int[n][n];\n\n            for (int w = 2; w < n + 1; w++) {\n                for (int i = 0; i < n; i++) {\n                    int j = i + w - 1;\n                    if (j >= n)\n                        break;\n                    if (dp[i + 1][j - 1] == w - 2 && Math.abs(W[i] - W[j]) <= 1)\n                        dp[i][j] = w;\n                    for (int k = i; k < j; k++) {\n                        dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                    }\n                }\n            }\n            System.out.println(dp[0][n - 1]);\n        }\n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew AOJ1611().doIt();\n\t}\n\tclass AOJ1611{\n\t\tvoid doIt(){\n\t\t\twhile(true) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0)break;\n\t\t\t\tint w[] = new int [n];\n\t\t\t\tfor(int i = 0;i < n;i++)w[i] = sc.nextInt();\n\t\t\t\tint dp[][] = new int[n][n];\n\t\t\t\tfor(int W = 2;W < n+1;W++) {\n\t\t\t\t\tfor(int i = 0;i < n;i++) {\n\t\t\t\t\t\tint j = i+W-1;\n\t\t\t\t\t\tif(j >= n) break;\n\t\t\t\t\t\tif(dp[i+1][j-1] == W-2 && Math.abs(w[i] - w[j]) <= 1) dp[i][j] = W;\n\t\t\t\t\t\tfor(int k = i;k < j;k++) {\n\t\t\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k+1][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tfor(int i = 0;i < n;i++) {\n//\t\t\t\t\tfor(int j = 0;j < n;j++) {\n//\t\t\t\t\t\tSystem.out.print(dp[i][j]+\" \");\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n\t\t\t\tSystem.out.println(dp[0][n-1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tstatic int[][] dp=new int[301][301];\n\tstatic int[] w=new int[301];\n\tstatic int rec(int l, int r) {\n\t\tif(dp[l][r]<0) {\n\t\t\treturn dp[l][r];\n\t\t}\n\t\tif(l>=r) {\n\t\t\treturn 0;\n\t\t}//すべてグループわけされたら\n\t\tint res=0;\n\t\tif(Math.abs(w[l]-w[r])<=1 && rec(l+1, r-1)==r-l-1) {//lとrのブロックが対になれるなら\n\t\t\tres = r- l + 1;\n\t\t}//res:出せたブロックの数\n\t\tfor(int mid=l; mid<r; mid++) {\n\t\t\tres = Math.max(res, rec(l,mid)+rec(mid+1,r));\n\t\t}//出せたブロックの数とそのブロック外した後の経路　より多くのブロックが取り出せる方\n\t\treturn dp[l][r]=res;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tw[i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t\tSystem.out.println(rec(0, n-1));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class D {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = sc.nextInt();\n      }\n      boolean[][] dp = new boolean[n][n];\n      int w;\n      for (w = 2; w <= n; w += 2) {\n        boolean any = false;\n        for (int l = 0; l + w - 1 < n; l++) {\n          if (w == 2) {\n            dp[l][l + 1] = Math.abs(a[l] - a[l + 1]) <= 1;\n            any = any || dp[l][l + 1];\n            // System.out.print(dp[l][l + 1] ? \"1\" : \"0\");\n            continue;\n          }\n          int r = l + w;\n          if (w == 4) {\n            dp[l][r - 1] = (dp[l][l + 1] && dp[r - 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          } else {\n            dp[l][r - 1] = (dp[l][r - 3] && dp[r - 2][r - 1])\n                    || (dp[l][l + 1] && dp[l + 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          }\n          // System.out.print(dp[l][r - 1] ? \"1\" : \"0\");\n          any = any || dp[l][r - 1];\n        }\n        // System.out.println();\n        if (!any) {\n          break;\n        }\n      }\n      int[][] dp2 = new int[n][n];\n      for (int i = 0; i < n - 1; i++) {\n        dp2[i][i + 1] = dp[i][i + 1] ? 2 : 0;\n        // System.out.print(dp2[i][i + 1]);\n      }\n      // System.out.println();\n\n      for (w = 3; w <= n; w ++) {\n        for (int l = 0; l + w - 1 < n; l++) {\n          int r = l + w - 1;\n          if (dp[l][r]) {\n            dp2[l][r] = w;\n            continue;\n          }\n          for (int d = l + 1; d < r; d++) {\n            dp2[l][r] = Math.max(dp2[l][r], dp2[l][d] + dp2[d + 1][r]);\n          }\n          // System.out.print(dp2[l][r]);\n        }\n        // System.out.println();\n      }\n      System.out.println(dp2[0][n - 1]);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\n\tprivate int[] d;\n\tprivate int n;\n\t\n\tprivate Pair[] scan() {\n\t\tjava.util.Set<Pair> lis = new java.util.TreeSet<Pair>();\n\t\t\n\t\tfor (int p = 0; p + 1 < n; ++p) {\n\t\t\tif (Math.abs(d[p + 1] - d[p]) <= 1)\n\t\t\t\tlis.add(new Pair(p, p + 1));\n\t\t}\n\t\tfor (int l = 4; l <= n; l += 2) {\n\t\t\tfor (int s = 0; s + l <= n; ++s) {\n\t\t\t\tfinal int e = s + l - 1;\n\t\t\t\tif (lis.contains(new Pair(s + 1, e - 1)) && Math.abs(d[e] - d[s]) <= 1) {\n\t\t\t\t\tlis.add(new Pair(s, e));\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\tfor (int j = s + 1; j + 1 < e; j += 2) {\n\t\t\t\t\tif (lis.contains(new Pair(s, j)) && lis.contains(new Pair(j + 1, e))) {\n\t\t\t\t\t\tlis.add(new Pair(s, e));\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn lis.toArray(new Pair[lis.size()]);\n\t}\n\t\n\tpublic void run(java.io.InputStream in, java.io.PrintStream out) {\n\t\ttry (java.util.Scanner sc = new java.util.Scanner(in)) {\n\t\t\tfor (;;) {\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tif (n == 0) break ;\n\t\t\t\td = new int[n];\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\td[i] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tPair[] seq = scan();\n\t\t\t\tjava.util.Arrays.sort(seq);\n\t\t\t\t\n\t\t\t\tint[] fullSize = new int[n + 1];\n\t\t\t\tfor (int i = 0; i < seq.length; ++i) {\n\t\t\t\t\tfinal Pair p = seq[i];\n\t\t\t\t\tfinal int score = (p.u - 1 < 0 ? 0 : fullSize[p.u - 1]) + p.length;\n\t\t\t\t\tfor (int j = p.v; j <= n; ++j) {\n\t\t\t\t\t\tif (score <= fullSize[j]) break ;\n\t\t\t\t\t\tfullSize[j] = score;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println(fullSize[n]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t(new Main()).run(System.in, System.out);\n\t}\n\n\tprivate static class Pair implements Comparable<Pair> {\n\t\tpublic final int u;\n\t\tpublic final int v;\n\t\tpublic final int length;\n\t\t\n\t\tpublic Pair(int u, int v) {\n\t\t\tthis.u = Math.min(u, v);\n\t\t\tthis.v = Math.max(u, v);\n\t\t\tthis.length = v - u + 1;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (this.u < o.u) return -1;\n\t\t\tif (o.u < this.u) return 1;\n\t\t\tif (this.v < o.v) return -1;\n\t\t\tif (o.v < this.v) return 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + u;\n\t\t\tresult = prime * result + v;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (u != other.u)\n\t\t\t\treturn false;\n\t\t\tif (v != other.v)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + this.u + \", \" + this.v + \")\";\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint[] w = new int[n + 1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][] dp = new int[n + 1][n + 1];\n\t\t\tfor(int i = 1; i < n; i++) {\n\t\t\t\tdp[i][i + 1] = Math.abs(w[i] - w[i + 1]) <= 1 ? 2 : 0;\n\t\t\t}\n\t\t\tfor(int j = 2; j < n; j++) {\n\t\t\t\tfor(int i = 1; i + j <= n; i++) {\n\t\t\t\t\tif(dp[i + 1][i + j - 1] == j - 1 && Math.abs(w[i] - w[i + j]) <= 1) {\n\t\t\t\t\t\tdp[i][i + j] = j - 1 + 2;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < j; k++) {\n\t\t\t\t\t\tdp[i][i + j] = Math.max(dp[i][i + k] + dp[i + k + 1][i + j], dp[i][i + j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dp[1][n]);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int N;\n    static int[] W;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        while(true) {\n            N = sc.nextInt();\n            if( N == 0 ) break;\n            W = sc.nextIntArray(N);\n\n            System.out.println(solve());\n        }\n    }\n\n    static int solve() {\n        int[][] dp = new int[N+1][N+1];\n        for (int d = 2; d <= N; d++) {\n            for (int i = 0; i <= N-d; i++) {\n                int j = i + d;\n                for (int k = i+1; k <= j-1; k++) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j]);\n                }\n                if( dp[i+1][j-1] == (j-i-2) && Math.abs(W[i]-W[j-1]) <= 1 ) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i+1][j-1] + 2);\n                }\n            }\n        }\n        return dp[0][N];\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while(true) {\n            int n=sc.nextInt();\n            if (n == 0) {\n                break;\n            }\n            int[] minN = new int[n];\n            int[] maxN = new int[n];\n            for (int i=0;i<n;i++) {\n                maxN[i] = minN[i] = sc.nextInt();\n            }\n            int maxS = 0, minS = 0;\n            int min,max;\n            int index;\n            // ?????§????????????\n            while(true) {\n                index = -1;\n                max = 0;\n                for (int i = 0; i < n - maxS - 1; i++) {\n                    if (Math.abs(maxN[i] - maxN[i + 1]) > 1) {\n                        continue;\n                    }\n                    if (maxN[i] * maxN[i + 1] > max) {\n                        max = maxN[i] * maxN[i + 1];\n                        index = i;\n                    }\n                }\n                if (index == -1) {\n                    break;\n                }\n                for (int i = index; i < n - maxS - 2; i++) {\n                    maxN[i] = maxN[i + 2];\n                }\n                maxS += 2;\n            }\n            // ????°?????????????\n            while(true) {\n                index = -1;\n                min = 1000001;\n                for (int i = 0; i < n - minS - 1; i++) {\n                    if (Math.abs(minN[i] - minN[i + 1]) > 1) {\n                        continue;\n                    }\n                    if (minN[i] * minN[i + 1] < min) {\n                        min = minN[i] * minN[i + 1];\n                        index = i;\n                    }\n                }\n                if (index == -1) {\n                    break;\n                }\n                for (int i = index; i < n - minS - 2; i++) {\n                    minN[i] = minN[i + 2];\n                }\n                minS += 2;\n            }\n            System.out.println(minS>maxS?minS:maxS);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tint[] w = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tw[i] = scan.nextInt();\n\t\t\tint[][] dp = new int[n][n];\n//\t\t\tint count = 1;\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tfor (int i = 0; i + j < n; i++) {\n\n//\t\t\t\t\tfor (int _i = 0; _i < n; _i++) for (int _j = 0; _j < n; _j++) dp[_i][_j] = 0;\n//\t\t\t\t\tdp[i][i + j] = count++;\n//\t\t\t\t\tint count2 = 1;\n\n\t\t\t\t\t// 区間(i + 1, i + j - 1)のブロックが全て落とされている場合，ブロック i とブロック i + j が落とせるか判定\n//\t\t\t\t\tSystem.out.println((dp[i + 1][i + j - 1]) + \" == \" + ((i + j) - i - 1));\n\t\t\t\t\tif (dp[i + 1][i + j - 1] == (i + j) - i - 1) {\n\t\t\t\t\t\tif (Math.abs(w[i] - w[i + j]) <= 1) {\n\t\t\t\t\t\t\tdp[i][i + j] = dp[i + 1][i + j - 1] + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = i; k < i + j; k++) {\n//\t\t\t\t\t\tdp[i][k] = dp[k + 1][i + j] = count2++;\n\t\t\t\t\t\t// 区間(i, k)と区間(k + 1, i + j)で落とされたブロックをマージする\n\t\t\t\t\t\tdp[i][i + j] = Math.max(dp[i][i + j], dp[i][k] + dp[k + 1][i + j]);\n\t\t\t\t\t}\n\n//\t\t\t\t\tfor (int _i = 0; _i < n; _i++) {\n//\t\t\t\t\t\tfor (int _j = 0; _j < n; _j++) System.out.print(dp[_i][_j] + \" \");\n//\t\t\t\t\t\tSystem.out.println();\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor (int _i = 0; _i < n; _i++) {\n//\t\t\t\tfor (int _j = 0; _j < n; _j++) System.out.print(dp[_i][_j] + \" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(dp[0][n - 1]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] $) throws IOException{\n\t\twhile(true) {\n\t\t\tint n=scan.nextInt();\n\t\t\tif(n==0)return;\n\t\t\tint w[]=setArray(n);\n\t\t\tint dp[][]=new int[n][n];\n\t\t\tboolean can[][]=new boolean[n+10][n+10];\n\t\t\tint ans=0;\n\t\t\tfor(int len=1;len<n;len++) {\n\t\t\t\tfor(int i=0;i+len<n;i++) {\n\t\t\t\t\tif(len==1) {\n\t\t\t\t\t\tif(Math.abs(w[i]-w[i+len])<=1) {\n\t\t\t\t\t\t\tdp[i][i+len]=2;\n\t\t\t\t\t\t\tcan[i][i+len]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(can[i+1][i+len-1]&&Math.abs(w[i]-w[i+len])<=1) {//あたらしくおとす?(|落ちてる|)\n\t\t\t\t\t\t\tdp[i][i+len]=len+1;\n\t\t\t\t\t\t\tcan[i][i+len]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor(int j=i;j<i+len-1;j++) {//あいだ\n\t\t\t\t\t\t\t\tif(can[i][j]&&can[j+1][i+len]) {//((落ちてる)(落ちてる))\n\t\t\t\t\t\t\t\t\tcan[i][i+len]=true;\n\t\t\t\t\t\t\t\t\tdp[i][i+len]=len+1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tdp[i][i+len]=max(dp[i][i+len],dp[i][j]+dp[j+1][i+len]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,dp[i][i+len]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic FastScanner scan = new FastScanner();\n\tstatic Scanner scanner = new Scanner(System.in);\n\tstatic Random rand = new Random();\n\tstatic long mod = 1000000007;\n\tstatic double eps = 1.0E-14;\n\tstatic int big = Integer.MAX_VALUE;\n\tstatic double PI = 3.141592653589793;\n\tstatic long modlcm(long a, long b) {\n\t\treturn a * b * modinv(GCD(a, b), mod);\n\t}\n\tstatic long GCD(long a, long b) {\n\t\treturn b > 0 ? GCD(b, a % b) : a;\n\t}\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / GCD(a, b);\n\t}\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\tstatic long factorial(int i) {\n\t\treturn i == 1 ? 1 : i * factorial(i - 1);\n\t}\n\tstatic int max(int... i) {\n\t\tint x = i[0];\n\t\tfor (int e : i)\n\t\t\tx = Math.max(x, e);\n\t\treturn x;\n\t}\n\tstatic int min(int... i) {\n\t\tint x = i[0];\n\t\tfor (int e : i)\n\t\t\tx = Math.min(x, e);\n\t\treturn x;\n\t}\n\tstatic long gcd(long... i) {\n\t\tlong x = i[0];\n\t\tfor (long e : i)\n\t\t\tx = GCD(x, e);\n\t\treturn x;\n\t}\n\tstatic long lmax(long... i) {\n\t\tlong x = i[0];\n\t\tfor (long e : i)\n\t\t\tx = Math.max(x, e);\n\t\treturn x;\n\t}\n\tstatic long lmin(long... i) {\n\t\tlong x = i[0];\n\t\tfor (long e : i)\n\t\t\tx = Math.min(x, e);\n\t\treturn x;\n\t}\n\tstatic long nCr(long n, long r, long m) {\n\t\tlong ans = 1;\n\t\tfor (long i = 0; i < r; i++) {\n\t\t\tans *= (n - i);\n\t\t\tans %= m;\n\t\t}\n\t\tfor (long i = 0; i <= r; i++) {\n\t\t\tans *= modinv(i, m);\n\t\t\tans %= mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic int lower_bound(int a[], int key) {\n\t\tint ok = a.length;\n\t\tint ng = -1;\n\t\twhile (Math.abs(ok - ng) > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (a[mid] >= key)\n\t\t\t\tok = mid;\n\t\t\telse\n\t\t\t\tng = mid;\n\t\t}\n\t\treturn ok;\n\t}\n\tstatic int upper_bound(int a[], int key) {\n\t\tint ok = a.length;\n\t\tint ng = -1;\n\t\twhile (Math.abs(ok - ng) > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (a[mid] > key)\n\t\t\t\tok = mid;\n\t\t\telse\n\t\t\t\tng = mid;\n\t\t}\n\t\treturn ok;\n\t}\n\tstatic boolean isPrime(long n) {\n\t\tif (n == 2)\n\t\t\treturn true;\n\t\tif (n < 2 || n % 2 == 0)\n\t\t\treturn false;\n\t\tdouble d = Math.sqrt(n);\n\t\tfor (int i = 3; i <= d; i += 2)\n\t\t\tif (n % i == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\treturn true;\n\t}\n\tstatic int upper_division(int a, int b) {\n\t\tif (a % b == 0) {\n\t\t\treturn a / b;\n\t\t} else {\n\t\t\treturn a / b + 1;\n\t\t}\n\t}\n\tstatic long lupper_division(long a, long b) {\n\t\tif (a % b == 0) {\n\t\t\treturn a / b;\n\t\t} else {\n\t\t\treturn a / b + 1;\n\t\t}\n\t}\n\tstatic int[] setArray(int a) {\n\t\tint b[] = new int[a];\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tb[i] = scan.nextInt();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic long[] lsetArray(int a) {\n\t\tlong b[] = new long[a];\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tb[i] = scan.nextLong();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic String reverse(String str) {\n\t\tchar ch[] = new char[str.length()];\n\t\tchar chch[] = str.toCharArray();\n\t\tint a = str.length();\n\t\tfor (int i = 0; i < upper_division(a, 2); i++) {\n\t\t\tch[i] = chch[ch.length - i - 1];\n\t\t\tch[ch.length - 1 - i] = chch[i];\n\t\t}\n\t\treturn String.valueOf(ch);\n\t}\n\tpublic static void printArray(int[] que) {\n\t\tfor (int i = 0; i < que.length - 1; i++) {\n\t\t\tSystem.out.print(que[i] + \" \");\n\t\t}\n\t\tSystem.out.println(que[que.length - 1]);\n\t}\n\tpublic static void lprintArray(long[] que) {\n\t\tfor (int i = 0; i < que.length - 1; i++) {\n\t\t\tSystem.out.print(que[i] + \" \");\n\t\t}\n\t\tSystem.out.println(que[que.length - 1]);\n\t}\n\tpublic static int[][] doublesort(int[][] a) {\n\t\tArrays.sort(a, (x, y) -> Integer.compare(x[0], y[0]));\n\t\treturn a;\n\t}\n\tpublic static long[][] ldoublesort(long[][] a) {\n\t\tArrays.sort(a, (x, y) -> Long.compare(x[0], y[0]));\n\t\treturn a;\n\t}\n\tstatic long modpow(long x, long n, long mo) {\n\t\tlong sum = 1;\n\t\twhile (n > 0) {\n\t\t\tif ((n & 1) == 1) {\n\t\t\t\tsum = sum * x % mo;\n\t\t\t}\n\t\t\tx = x * x % mo;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static char[] revch(char ch[]) {\n\t\tchar ret[] = new char[ch.length];\n\t\tfor (int i = ch.length - 1, j = 0; i >= 0; i--, j++) {\n\t\t\tret[j] = ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[] revint(int ch[]) {\n\t\tint ret[] = new int[ch.length];\n\t\tfor (int i = ch.length - 1, j = 0; i >= 0; i--, j++) {\n\t\t\tret[j] = ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[][] warshall_floyd(int v[][], int n) {\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\treturn v;\n\t}\n\tpublic static long modinv(long a, long m) {\n\t\tlong b = m, u = 1, v = 0;\n\t\twhile (b != 0) {\n\t\t\tlong t = a / b;\n\t\t\ta -= t * b;\n\t\t\tlong x = a;\n\t\t\ta = b;\n\t\t\tb = x;\n\t\t\tu -= t * v;\n\t\t\tx = u;\n\t\t\tu = v;\n\t\t\tv = x;\n\t\t}\n\t\tu %= m;\n\t\tif (u < 0)\n\t\t\tu += m;\n\t\treturn u;\n\t}\n}\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\tpublic char nextchar() {\n\t\treturn next().charAt(0);\n\t}\n}\n\nclass UnionFind {\n\tint Parent[];\n\tUnionFind(int n) {// Initialize by -1\n\t\tParent = new int[n];\n\t\tArrays.fill(Parent, -1);\n\t}\n\tint root(int A) {// In which tree is A?\n\t\tif (Parent[A] < 0)\n\t\t\treturn A;\n\t\treturn Parent[A] = root(Parent[A]);\n\t}\n\tint size(int A) {// size of tree which is include A\n\t\treturn -Parent[root(A)];\n\t}\n\tboolean connect(int A, int B) {// Connect A and B\n\t\tA = root(A);\n\t\tB = root(B);\n\t\tif (A == B)\n\t\t\treturn false;\n\t\tif (size(A) < size(B)) {\n\t\t\tint C = 0;\n\t\t\tC = B;\n\t\t\tB = A;\n\t\t\tA = C;\n\t\t} // SWAP\n\t\tParent[A] += Parent[B];\n\t\tParent[B] = A;\n\t\treturn true;\n\t}\n}\n\nclass Pair<T, E> {\n\tpublic T first;\n\tpublic E second;\n\tvoid set(T x, E y) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t}\n}\n\nclass Pint {\n\tpublic int first;\n\tpublic int second;\n\tPint(int x, int y) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t}\n\tvoid set(int x, int y) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t}\n}\n\nclass Tpair {\n\tpublic int first;\n\tpublic int second;\n\tpublic long third;\n\tTpair(int x, int y, long z) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t\tthird = z;\n\t}\n\tvoid set(int x, int y, long z) {\n\t\tfirst = x;\n\t\tsecond = y;\n\t\tthird = z;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\nstatic Scanner inp=new Scanner(System.in);\nstatic int a[]=new int[100000];\nstatic int ans[][]=new int[1000][1000];\n\tstatic int max(int x,int y){\n\t\tif (x>y)return(x);\n\t\treturn(y);\n\t}\n\tpublic static void main(String[] args) {\n\t\tint n=inp.nextInt();\n\t\twhile (n>0){\n\t\t\tfor(int i=1;i<=n;i++)a[i]=inp.nextInt();\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tfor (int j=i;j<=n;j++)\n\t\t\t\t\tans[i][j]=-10000000;\n\t\t\tfor (int j=1;j<n;j++)\n\t\t\t    for(int i=1;i+j<=n;i++){\n\t\t\t\t\tfor (int h=i+1;h<i+j;h++)\n\t\t\t\t\t\tans[i][j+i]=max(ans[i][h]+ans[h+1][i+j],ans[i][i+j]);\n\t\t\t\t\tif (Math.abs(a[i]-a[i+j])<2) ans[i][i+j]=max(ans[i+1][i+j-1]+2,ans[i][j+i]);\n\t\t\t\t}\n\t\t\tfor (int j=1;j<n;j++)\n\t\t\t    for(int i=1;i+j<=n;i++)\n\t\t\t\t\tfor (int h=i+1;h<i+j;h++){\n\t\t\t\t\t\tans[i][i+j]=max(max(ans[i][i+j],0),max(ans[i+1][i+j],max(ans[i][i+j-1],ans[i][h]+ans[h+1][i+j])));\n\t\t\t\t}\n\t\t\tSystem.out.println(ans[1][n]);\n\t\t\tn=inp.nextInt();\n\t\t}\n\t\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n==0)break;\n\n\t\t\tint[] arr = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n\t\t\tint[][] dp = new int[n][n];\n\n\t\t\tfor(int interval = 0; interval<n; interval += 2) {\n\t\t\t\tfor(int start = 0, end = start + interval + 1; end < n; start++, end++) {\n\n\t\t\t\t\tif(Math.abs(arr[start]-arr[end])<2) {\n\t\t\t\t\t\tif(dp[start+1][end-1]==interval) {\n\t\t\t\t\t\t\tdp[start][end] = interval+2;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int innerInterval = 0; innerInterval<interval; innerInterval+=2) {\n\t\t\t\t\t\tdp[start][end] = Math.max(\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tdp[start][end]\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tdp[start][start+innerInterval+1] +\n\t\t\t\t\t\t\t\tdp[start+innerInterval+2][end]\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint result = 0;\n\t\t\tfor(int i = 0; i < dp.length; i++) {\n\t\t\t\tfor(int j = 0; j < dp[i].length; j++) {\n\t\t\t\t\t//System.out.printf(\"%3d\",dp[i][j]);\n\t\t\t\t\tresult = Math.max(result,dp[i][j]);\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DDarumaOtoshi solver = new DDarumaOtoshi();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DDarumaOtoshi {\n        private static int n;\n        private static int[] a;\n        private static int[][] dp;\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            n = in.nextInt();\n            while (n != 0) {\n                a = new int[n];\n                dp = new int[n][n];\n                for (int i = 0; i < n; i++) {\n                    a[i] = in.nextInt();\n                    Arrays.fill(dp[i], -1);\n                }\n                out.println(2 * calc(0, n - 1));\n\n                //Arrays.stream(dp).map(Arrays::toString).forEach(System.out::println);\n\n                n = in.nextInt();\n            }\n        }\n\n        private static int calc(int i, int j) {\n            if (i >= j || i < 0 || n <= j) return 0;\n            if (dp[i][j] >= 0) return dp[i][j];\n            int res = Math.max(calc(i + 1, j), calc(i, j - 1));\n\n            for (int k = i + 1; k <= j; k++) {\n                if (Math.abs(a[i] - a[k]) <= 1) {\n                    res = Math.max(res, calcAll(i + 1, k - 1) + 1 + calc(k + 1, j));\n                }\n            }\n\n            for (int k = i; k <= j - 1; k++) {\n                if (Math.abs(a[k] - a[j]) <= 1) {\n                    res = Math.max(res, calc(i, k - 1) + calcAll(k + 1, j - 1) + 1);\n                }\n            }\n            return dp[i][j] = res;\n        }\n\n        private static int calcAll(int i, int j) {\n            int count = Math.max(0, j - i + 1);\n            int result = calc(i, j);\n            if (result * 2 == count) {\n                return result;\n            } else {\n                return -1;\n            }\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder sb = new StringBuilder();\n        while(true){\n            int n = sc.nextInt();\n            if(n == 0) break;\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n            }\n            int[][] dp = new int[n][n];\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j+i < n; j++) {\n                    if(Math.abs(a[j] - a[j+i]) <= 1){\n                        if(i == 1 || dp[j+1][j+i-1] == i-1 ) dp[j][j+i] = i+1;\n                    }\n                    for (int k = 0; k < i; k++) {\n                        if(dp[j][j+i] < dp[j][j+k] + dp[j+k+1][j+i])\n                            dp[j][j+i] = dp[j][j+k] + dp[j+k+1][j+i];\n                    }\n                }\n            }\n            sb.append(dp[0][n-1] + \"\\n\");\n        }\n        System.out.print(sb.toString());\n        sc.close();\n\n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while(true) {\n            int n=sc.nextInt();\n            if (n == 0) {\n                break;\n            }\n            int[] minN = new int[n];\n            int[] maxN = new int[n];\n            for (int i=0;i<n;i++) {\n                maxN[i] = minN[i] = sc.nextInt();\n            }\n            int maxS = 0, minS = 0;\n            int min,max;\n            int index;\n            \n            while(true) {\n                index = -1;\n                max = 0;\n                for (int i = 0; i < n - maxS - 1; i++) {\n                    if (Math.abs(maxN[i] - maxN[i + 1]) > 1) {\n                        continue;\n                    }\n                    if (maxN[i] * maxN[i + 1] > max) {\n                        max = maxN[i] * maxN[i + 1];\n                        index = i;\n                    }\n                }\n                if (index == -1) {\n                    break;\n                }\n                for (int i = index; i < n - maxS - 2; i++) {\n                    maxN[i] = maxN[i + 2];\n                }\n                maxS += 2;\n            }\n            \n            while(true) {\n                index = -1;\n                min = 1000001;\n                for (int i = 0; i < n - minS - 1; i++) {\n                    if (Math.abs(minN[i] - minN[i + 1]) > 1) {\n                        continue;\n                    }\n                    if (minN[i] * minN[i + 1] < min) {\n                        min = minN[i] * minN[i + 1];\n                        index = i;\n                    }\n                }\n                if (index == -1) {\n                    break;\n                }\n                for (int i = index; i < n - minS - 2; i++) {\n                    minN[i] = minN[i + 2];\n                }\n                minS += 2;\n            }\n            System.out.println(minS>maxS?minS:maxS);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = sc.nextInt();\n      }\n      boolean[][] dp = new boolean[n][n];\n      int w;\n      for (w = 2; w <= n; w += 2) {\n        boolean any = false;\n        for (int l = 0; l + w - 1 < n; l++) {\n          if (w == 2) {\n            dp[l][l + 1] = Math.abs(a[l] - a[l + 1]) <= 1;\n            any = any || dp[l][l + 1];\n            // System.out.print(dp[l][l + 1] ? \"1\" : \"0\");\n            continue;\n          }\n          int r = l + w;\n          if (w == 4) {\n            dp[l][r - 1] = (dp[l][l + 1] && dp[r - 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          } else {\n            dp[l][r - 1] = (dp[l][r - 3] && dp[r - 2][r - 1])\n                    || (dp[l][l + 1] && dp[l + 2][r - 1])\n                    || (dp[l + 1][r - 2] && Math.abs(a[l] - a[r - 1]) <= 1);\n          }\n          // System.out.print(dp[l][r - 1] ? \"1\" : \"0\");\n          any = any || dp[l][r - 1];\n        }\n        // System.out.println();\n        if (!any) {\n          break;\n        }\n      }\n      int[][] dp2 = new int[n][n];\n      for (int i = 0; i < n - 1; i++) {\n        dp2[i][i + 1] = dp[i][i + 1] ? 2 : 0;\n        // System.out.print(dp2[i][i + 1]);\n      }\n      // System.out.println();\n\n      for (w = 3; w <= n; w ++) {\n        for (int l = 0; l + w - 1 < n; l++) {\n          int r = l + w - 1;\n          if (dp[l][r]) {\n            dp2[l][r] = w;\n            continue;\n          }\n          for (int d = l + 1; d < r; d++) {\n            dp2[l][r] = Math.max(dp2[l][r], dp2[l][d] + dp2[d + 1][r]);\n          }\n          // System.out.print(dp2[l][r]);\n        }\n        // System.out.println();\n      }\n      System.out.println(dp2[0][n - 1]);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\tstatic int[][] dp = new int[300][300];\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\tint[] a = ir.nextIntArray(n);\n\t\t\tout.println(dfs(0, n, a));\n\t\t}\n\t}\n\n\tstatic int dfs(int l, int r, int[] a) {\n\t\tif (dp[l][r] >= 0)\n\t\t\treturn dp[l][r];\n\t\tif (l + 1 >= r)\n\t\t\treturn dp[l][r] = 0;\n\t\tint ret = 0;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tfor (int j = i + 1; j < r; j += 2) {\n\t\t\t\tif (Math.abs(a[i] - a[j]) <= 1 && dfs(i + 1, j, a) == j - i - 1) {\n\t\t\t\t\tret = Math.max(ret, dfs(l, i, a) + dfs(j + 1, r, a) + j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[l][r] = ret;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Aizu\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar answers = new List<int>();\n\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tvar n = int.Parse(ReadLine());\n\t\t\t\tif(n == 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar blocks = ReadLine().Split(' ').Select(value => int.Parse(value)).ToArray();\n\n\t\t\t\tvar maxima = new int[n, n];\n\t\t\t\tfor(var i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(var j = 0; j < n; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxima[i, j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tanswers.Add(Dp(maxima, 0, n - 1, blocks));\n\t\t\t}\n\n\t\t\tanswers.ForEach(value => WriteLine(value));\n\t\t}\n\n\t\tprivate static int Dp(int[,] maxima, int left, int right, int[] blocks)\n\t\t{\n\t\t\tif(maxima[left, right] != -1)\n\t\t\t{\n\t\t\t\treturn maxima[left, right];\n\t\t\t}\n\t\t\tif(right - left < 1)\n\t\t\t{\n\t\t\t\treturn maxima[left, right] = 0;\n\t\t\t}\n\n\t\t\tvar max = 0;\n\n\t\t\tif(Abs(blocks[left] - blocks[right]) <= 1 && Dp(maxima, left + 1, right - 1, blocks) == right - left - 1)\n\t\t\t{\n\t\t\t\tmax = right - left + 1;\n\t\t\t}\n\n\t\t\tfor(var i = left; i < right; i++)\n\t\t\t{\n\t\t\t\tmax = Max(max, Dp(maxima, left, i, blocks) + Dp(maxima, i + 1, right, blocks));\n\t\t\t}\n\n\t\t\treturn maxima[left, right] = max;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static Library.Input;\n\nnamespace AtCoderTemplate {\n    class ProgramF {\n        static int[][] dp;\n        static int[] weight;\n        static int n;\n\n        static void Main () {\n            while (true)\n            {\n                n = NextInt;\n                if (n == 0) return;\n                weight = IntList.ToArray();\n                dp = Enumerable.Range(0, n).Select(_ => Enumerable.Repeat(-1, n).ToArray()).ToArray();\n\n                System.Console.WriteLine(Memo(0, n - 1));\n            }\n        }\n\n        static int Memo(int left, int right) {\n            if (dp[left][right] != -1) return dp[left][right];\n            if (left == right) return dp[left][right] = 0;\n            if (right - left == 1) return dp[left][right] = Math.Abs(weight[right] - weight[left]) <= 1 ? 2 : 0;\n\n            // 中と外で区切る\n            if (Math.Abs(weight[left] - weight[right]) <= 1 && Memo(left + 1, right - 1) == right - left - 1)\n                return dp[left][right] = Memo(left + 1, right - 1) + 2;\n\n            // 左と右で区切る\n            return dp[left][right] = Enumerable.Range(left, right - left).Max(i => Memo(left, i) + Memo(i + 1, right));\n        }\n    }\n\n}\n\nnamespace Library {\n    class Input {\n        static IEnumerator<string> enumerator = new string[] { }.AsEnumerable ().GetEnumerator ();\n\n        public static string Line => Console.ReadLine ();\n\n        public static string[] StrArr => Line.Split (' ');\n\n        public static int NextInt => int.Parse (NextWord ());\n\n        public static long NextLong => long.Parse (NextWord ());\n\n        public static List<int> IntList => StrArr.Select (int.Parse).ToList ();\n\n        public static List<long> LongList => StrArr.Select (long.Parse).ToList ();\n\n        public static IEnumerable<long[]> TakeLine (int N) {\n            return Enumerable.Repeat (0, N).Select (_ => Console.ReadLine ().Split (' ').Select (long.Parse).ToArray ());\n        }\n\n        public static string NextWord () {\n            while (!enumerator.MoveNext ()) {\n                enumerator = StrArr.AsEnumerable ().GetEnumerator ();\n            }\n            return enumerator.Current;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Tool;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int MOD = 1000000007;\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 2;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1 };\n        static readonly int[] dJ = { 1, 0, -1, 0 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>>G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            //Console.SetOut(sw);\n            var cin = new Scanner();\n            while (true)\n            {\n                int n = int.Parse(Console.ReadLine());\n                if (n == 0) { return; }\n                var w = cin.ReadSplitInt();\n                var dp = new long[n, n];\n                for (var i = 0; i < n; i++) dp[i, i] = 0;\n                for(var i = 0; i < n - 1; i++)\n                {\n                    dp[i, i + 1] = Abs(w[i + 1] - w[i]) <= 1 ? 2 : 0;\n                }\n                for (var L = 2; L < n; L++)\n                {\n                    for(var i = 0; i + L < n; i++)\n                    {\n                        if (dp[i + 1, i + L - 1] == L - 1)\n                        {\n                            dp[i, i + L] = Abs(w[i] - w[i + L]) <= 1 ? L + 1 : L - 1;\n                        }\n                        for (var j = i + 1; j < i + L; j++)\n                        {\n                            dp[i, i + L] = Max(dp[i, j] + dp[j + 1, i + L], dp[i, i + L]);\n                        }\n                    }\n                }\n                Console.WriteLine(dp[0, n - 1]);\n            }\n\n            //Console.Out.Flush();\n        }\n        struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n\n        }\n    }\n    public class Scanner\n    {\n        public int[] ReadSplitInt()\n        {\n            return ConvertAll(Console.ReadLine().Split(), int.Parse);\n        }\n        public long[] ReadSplitLong()\n        {\n            return ConvertAll(Console.ReadLine().Split(), long.Parse);\n        }\n        public double[] ReadSplit_Double()\n        {\n            return ConvertAll(Console.ReadLine().Split(), double.Parse);\n        }\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            for (var i = 0; i < array.Length; i++)\n            {\n                array[i] = initialvalue;\n            }\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n\n        static public long LPow(int a, int b)\n        {\n            return (long)Pow(a, b);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJVolume16_1611\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<int> anss = new List<int>();\n            while (true)\n            {\n                var n = int.Parse(Console.ReadLine());\n                if (n == 0) break;\n\n                int[] A = new int[n + 1];\n                var input = ReadInt();\n                for (int i = 0; i < n; i++)\n                {\n                    A[i + 1] = input[i];\n                }\n\n                int[,] dp = new int[n + 2, n + 2];\n                for (int i = n - 1; i > 0; i--)\n                {\n                    for (int j = i + 1; j <= n; j++)\n                    {\n                        int ans = 0;\n                        if (Math.Abs(A[i] - A[j]) <= 1 && dp[i + 1, j - 1] == j - i - 1)//内部消えきる？\n                        {\n                            ans = j - i + 1;\n                        }\n\n                        for (int k = i; k <= j - 1; k++)\n                        {\n                            int cand = dp[i, k] + dp[k + 1, j];\n                            ans = Math.Max(ans, cand);\n                        }\n                        dp[i, j] = ans;\n                    }\n                }\n\n                int a = dp[1, n];\n                anss.Add(a);\n            }\n\n            foreach (var a in anss)\n            {\n                Console.WriteLine(a);\n            }\n            Console.ReadKey();\n        }\n\n        static int[] ReadInt()\n        {\n            int[] ret = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return ret;\n        }\n        static long[] ReadLong()\n        {\n            long[] ret = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return ret;\n        }\n    }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function Main(input) {\n    input = input.trim().split(\"\\n\").map(function(x) { return x.split(\" \")});    \n\tlet ll = 0;\n\twhile (true){\n\t\tif(input[ll][0] === '0') break; \n\t\tvar n = parseInt(input[ll][0],10);\n\t\tvar v_w = input[ll + 1].map(e => parseInt(e, 10));\n\t\tdp = [];\n\t\tfor (var i = 0; i < n; i++){\n\t\t\tdp.push([]);\n\t\t\tfor (var j = 0; j < n; j++){\n\t\t\t\tdp[i].push(-1);\n\t\t\t}\n\t\t}\n\t\tconsole.log(kukanDP(v_w, 0, n - 1));\n\t\t// console.log(dp);\n\n\t\tll += 2;\n\t}\n}\n\nfunction kukanDP(w, l, r){\n\t// console.log(dp);\n\t// console.log(\"lr\", l, r, dp);\n\t// console.log(dp);\n    //既に計算済み？\n    if(dp[l][r] != -1) return dp[l][r];\n\n    //これ以上取り除けない？\n    if(Math.abs(l - r) < 1) {\n\t\t// console.log(\"1\",l,r, dp);\n\t\treturn dp[l][r] = 0;\n\t}\n\n\tif(Math.abs(l - r) === 1 && Math.abs(w[l] - w[r]) <= 1) {\n\t\treturn dp[l][r] = 2;\n\t}\n\n\tlet res = 0;\n\t\n    //パターン1.\n    if (Math.abs(w[l] - w[r]) <= 1 && dp[l + 1] != null && kukanDP(w, l + 1, r - 1) === Math.abs(r - l) - 1){\n\t\t// console.log(\"here\", l, r);\n        //[l , r)がはじき出せるので\n        res = Math.abs(r - l) + 1;\n    }\n\n    //パターン２.区間を分ける\n    for(let mid = l; mid <= r - 1; mid++){\n        res = Math.max(res , kukanDP(w, l, mid) + kukanDP(w, mid + 1, r));\n\t}\n\t// console.log(\"2\",l,r, dp);\n    return dp[l][r] = res;\n};\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n = gets.to_i\n    break if n == 0\n    a = gets.split.map(&:to_i)\n    table = (0..n-1).map { [0] * n }\n    (1..n-1).each do |d|\n        (0..n-1-d).each do |l|\n            r = l + d\n            if d == 1\n                table[l][r] = ( (a[l] - a[r]).abs <= 1 ? 2 : 0 )\n            else \n                table[l][r] = table[l+1][r-1] + 2 if (a[l] - a[r]).abs <= 1 && table[l+1][r-1] == r - l - 1\n                (l..r-1).each do |i|\n                    m = table[l][i] + table[i+1][r]\n                    table[l][r] = m if m > table[l][r]\n                end\n            end\n        end\n    end\n    p table[0][n-1]\nend"
  },
  {
    "language": "Ruby",
    "code": "def encode(i, j)\n    (i << 9) + j\nend\n\ndef f(i, j)\n    code = encode(i, j)\n    cache = $memo[code]\n    return cache if cache\n\n    return 0 if i >= j\n    if j == i + 1\n        if ($a[i] - $a[j]).abs <= 1\n            return $memo[code] = 2\n        else\n            return $memo[code] = 0\n        end\n    end\n    if ($a[i] - $a[j]).abs <= 1 && f(i+1, j-1) == j - i - 1\n        return $memo[code] = j - i + 1 \n    end\n    $memo[code] = (i..j-1).map {|k| f(i, k) + f(k+1, j)}.max\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    $a = gets.split.map(&:to_i)\n    $memo = {}\n    p f(0, n-1)\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n = gets.to_i\n    break if n == 0\n    a = gets.split.map(&:to_i)\n    table = (0..n-1).map { [0] * n }\n    (0..n-2).each do |i|\n        table[i][i+1] = 2 if (a[i] - a[i+1]).abs <= 1\n    end\n    (2..n-1).each do |d|\n        (0..n-1-d).each do |l|\n            r = l + d\n            x = table[l+1][r-1]\n            table[l][r] = x + 2 if (a[l] - a[r]).abs <= 1 && x == r - l - 1\n            (l..r-1).each do |i|\n                m = table[l][i] + table[i+1][r]\n                table[l][r] = m if m > table[l][r]\n            end\n        end\n    end\n    p table[0][n-1]\nend"
  },
  {
    "language": "Ruby",
    "code": "def f(*args)\n    cache = $memo[args]\n    return cache if cache\n    i, j = args\n    return 0 if i >= j\n    if j == i + 1\n        if ($a[i] - $a[j]).abs <= 1\n            return $memo[args] = 2\n        else\n            return $memo[args] = 0\n        end\n    end\n    if ($a[i] - $a[j]).abs <= 1 && f(i+1, j-1) == j - i - 1\n        return $memo[args] = j - i + 1 \n    end\n    $memo[args] = (i..j-1).map {|k| f(i, k) + f(k+1, j)}.max\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    $a = gets.split.map(&:to_i)\n    $memo = {}\n    p f(0, n-1)\nend"
  },
  {
    "language": "Ruby",
    "code": "N = 10\n\ndef encode(i, j)\n    (i << N) + j\nend\n\ndef f(i, j)\n    code = encode(i, j)\n    cache = $memo[code]\n    return cache if cache\n\n    return 0 if i >= j\n    if j == i + 1\n        if ($a[i] - $a[j]).abs <= 1\n            return $memo[code] = 2\n        else\n            return $memo[code] = 0\n        end\n    end\n    if ($a[i] - $a[j]).abs <= 1 && f(i+1, j-1) == j - i - 1\n        return $memo[code] = j - i + 1 \n    end\n    $memo[code] = (i..j-1).map {|k| f(i, k) + f(k+1, j)}.max\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    $a = gets.split.map(&:to_i)\n    $memo = {}\n    p f(0, n-1)\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tinitialBufSize = 10000000\n\tmaxBufSize     = 100000000\n)\n\nvar sc *bufio.Scanner\n\nfunc initScanner(r io.Reader) *bufio.Scanner {\n\tbuf := make([]byte, initialBufSize)\n\n\tsc := bufio.NewScanner(r)\n\tsc.Buffer(buf, maxBufSize)\n\tsc.Split(bufio.ScanWords) // bufio.ScanLines\n\treturn sc\n}\n\nfunc main() {\n\tsc = initScanner(os.Stdin)\n\tresolve()\n}\n\nfunc nextInt(sc *bufio.Scanner) int {\n\tsc.Scan()\n\ta, _ := strconv.Atoi(sc.Text())\n\treturn int(a)\n}\nfunc nextString(sc *bufio.Scanner) string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\nfunc nextIntSlice(sc *bufio.Scanner, n int) (a []int) {\n\ta = make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\ta[i] = nextInt(sc)\n\t}\n\treturn a\n}\n\nvar dp [][]int\n\nfunc initDP(n int) {\n\tdp = make([][]int, n+1)\n\tfor i := 0; i < len(dp); i++ {\n\t\tdp[i] = make([]int, n+1)\n\t\tfor j := 0; j < len(dp[0]); j++ {\n\t\t\tdp[i][j] = -1\n\t\t}\n\t}\n}\n\nfunc resolve() {\n\tans := []int{}\n\tfor true {\n\t\tn := nextInt(sc)\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\tas := nextIntSlice(sc, n)\n\t\tinitDP(n)\n\t\t_rec(as, n, 0, n)\n\t\tans = append(ans, dp[0][n])\n\t}\n\tfor _, v := range ans {\n\t\tfmt.Println(v)\n\t}\n\treturn\n}\n\nfunc _rec(as []int, n, l, r int) int {\n\tif dp[l][r] > -1 {\n\t\treturn dp[l][r]\n\t}\n\tif r-l == 1 { // prevent to hit daruma\n\t\tdp[l][r] = 0\n\t\treturn dp[l][r]\n\t}\n\tif r-l == 2 {\n\t\tif abs(as[l]-as[r-1]) <= 1 {\n\t\t\tdp[l][r] = 2\n\t\t} else {\n\t\t\tdp[l][r] = 0\n\t\t}\n\t\treturn dp[l][r]\n\t}\n\tif abs(as[l]-as[r-1]) <= 1 {\n\t\tv := _rec(as, n, l+1, r-1)\n\t\t// if we can remove internal blocks\n\t\tif (r - 1 - (l + 1)) == v {\n\t\t\tdp[l][r] = v + 2\n\t\t\treturn dp[l][r]\n\t\t} else {\n\t\t\tdp[l][r] = v\n\t\t}\n\t}\n\tfor i := l + 1; i < r; i++ {\n\t\tv := _rec(as, n, l, i) + _rec(as, n, i, r)\n\t\tif dp[l][r] < v {\n\t\t\tdp[l][r] = v\n\t\t}\n\t}\n\treturn dp[l][r]\n}\n\nfunc abs(v int) int {\n\tif v < 0 {\n\t\treturn -v\n\t}\n\treturn v\n}\n\n"
  },
  {
    "language": "OCaml",
    "code": "let dbg = Printf.printf \"[debug]%s\"\n\nlet max_num = 1_000_000_000\n\nlet id = fun x -> x\nlet tuple2 x y = (x,y)\nlet succ x = x + 1\nlet pred x = x - 1\n\nlet (++) n m =\n  let rec aux i =\n    if i = m then [m]\n    else i :: aux (i+1) in\n  if n > m then [] else aux n\n\nlet (++^) n m = n ++ (m-1)\n\nlet scan fmt f = Scanf.sscanf (read_line ()) fmt f\n\nlet scan_line n =\n  let b = Scanf.Scanning.from_string (read_line ()) in\n  List.map (fun _ -> Scanf.bscanf b \" %d\" id) (0++^n)\n\nlet scan_lines n fmt f =\n  List.map (fun _ -> scan fmt f) (0++^n)\n\nlet scan_matrix n m e conv =\n  let arr = Array.make_matrix n m e in\n  Array.iteri (fun i line ->\n      let s = Scanf.Scanning.from_string @@ read_line () in\n      Array.iteri (fun j _ ->\n          arr.(i).(j) <- Scanf.bscanf s \" %s\" conv;\n        ) line) arr; arr\n\nlet between n x m = n <= x && x < m\n\nlet string_to_list s =\n  List.map (String.get s) (0 ++^ String.length s)\n\nlet solve arr =\n  let len = Array.length arr  in\n  let memo = Array.make_matrix len len None in\n  let rec aux n m =\n    if n >= m then 0\n    else\n      match memo.(n).(m) with\n      | Some v -> v\n      | None ->\n        let v =\n          (let x = aux (succ n) (pred m) in\n           (if x + 2 = m - n +1\n            then x + (if abs @@ arr.(n) - arr.(m) <= 1 then 2 else 0)\n            else x))\n          :: List.map (fun i ->\n              aux n i + aux (succ i) m)\n            (n ++^ m) |> List.fold_left max 0 in\n        memo.(n).(m) <- Some v; v\n  in\n  aux 0 @@ pred len\n\nlet () =\n  let rec aux () =\n    let n = scan \"%d\" id in\n    if n = 0 then ()\n    else\n      let arr = Array.of_list @@ scan_line n in\n      solve arr |> Printf.printf \"%d\\n\";\n      aux () in\n  aux ()\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.range;\nimport std.algorithm, std.array, std.typecons, std.container;\nimport std.math, std.numeric, std.random, core.bitop;\n\nenum inf = 1_001_001_001;\nenum infl = 1_001_001_001_001_001_001L;\n\n\nvoid main() {\n    while (true) {\n        int N;\n        scan(N);\n\n        if (N == 0) return;\n\n        auto w = readln.split.to!(int[]);\n        auto ans = solve(N, w);\n        writeln(ans);\n    }\n}\n\nint solve(int N, int[] w) {\n    auto dp = new int[][](N + 1, N + 1);\n    fillAll(dp, -1);\n\n    int rec(int l, int r) {\n        if (r - l <= 1) {\n            return 0;\n        }\n        if (dp[l][r] != -1) {\n            return dp[l][r];\n        }\n        dp[l][r] = 0;\n        foreach (i ; l + 1 .. r) {\n            chmax(dp[l][r], rec(l, i) + rec(i, r));\n        }\n        if (rec(l + 1, r - 1) == r - 1 - (l + 1) && abs(w[l] - w[r - 1]) <= 1) {\n            dp[l][r] = r - l;\n        }\n        return dp[l][r];\n    }\n\n    auto ans = rec(0, N);\n    return ans;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n\nbool chmin(T, U...)(ref T x, U args) {\n    bool isChanged;\n\n    foreach (arg; args) {\n        if (x > arg) {\n            x = arg;\n            isChanged = true;\n        }\n    }\n\n    return isChanged;\n}\n\nbool chmax(T, U...)(ref T x, U args) {\n    bool isChanged;\n\n    foreach (arg; args) {\n        if (x < arg) {\n            x = arg;\n            isChanged = true;\n        }\n    }\n\n    return isChanged;\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric;\n\nvoid main()\n{\n    for (;;) {\n        auto N = readln.chomp.to!int;\n        if (N == 0) return;\n\n        auto ws = readln.split.to!(int[]);\n        auto DP = new int[][](N, N);\n        int max_l;\n        foreach (i; 0..N-1) if (abs(ws[i] - ws[i+1]) <= 1) {\n            DP[i][i+1] = 2;\n        }\n        foreach (jj; 1..N) {\n            foreach (i; 0..N) {\n                auto j = i+jj;\n                if (j >= N) break;\n\n                DP[i][j] = max(DP[i][j-1], DP[i+1][j]);\n                if (abs(ws[i] - ws[j]) <= 1 && DP[i+1][j-1] == j-i-1) {\n                    DP[i][j] = j-i+1;\n                }\n                foreach (k; i+1..j) {\n                    DP[i][j] = max(DP[i][j], DP[i][k] + DP[k+1][j]);\n                }\n            }\n        }\n        writeln(DP[0][N-1]);\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    W = [int(x) for x in input().split()]\n    dp = [[0] * N for _ in range(N)]\n    for i in range(N-1):\n        if abs(W[i] - W[i + 1]) <= 1:\n            dp[i][i + 1] = 2\n    for w in range(3, N + 1):\n        for left in range(N - w + 1):\n            # [left, right]\n            right = left + w - 1\n            if right - left - 1 == dp[left + 1][right - 1] and abs(W[left] - W[right]) <= 1:\n                dp[left][right] = right - left + 1\n                continue\n            for mid in range(left + 1, right):\n                m = dp[left][mid] + dp[mid + 1][right]\n                if m > dp[left][right]:\n                    dp[left][right] = m\n    print(dp[0][N-1])"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip() \n\ndef resolve():\n    while True:\n        n = int(input())\n        w = list(map(int, input().split()))\n        if n==0:\n            break\n        else:\n            dp = [[0]*(n+1) for _ in range(n+2)]\n            # 幅\n            for i in range(2, n+1):\n                for l in range(n-i+1):\n                    r = l+i\n                    if dp[l+1][r-1] == i-2:\n                        if abs(w[l]-w[r-1])<=1:\n                            dp[l][r] = i\n                        else:\n                            dp[l][r] = i-2\n                    for j in range(l, r):\n                        if dp[l][j] + dp[j][r] > dp[l][r]:\n                            dp[l][r] = dp[l][j] + dp[j][r]\n\n            print(dp[0][-1])        \n\nif __name__ == '__main__':\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "def main(n):\n    a = list(map(int, input().split()))\n    dp = [[0] * n for i in range(n)]\n    for i in range(n - 1):\n        if abs(a[i] - a[i + 1]) <= 1:\n            dp[i][i + 1] = 2\n    for i in range(2, n):\n        for l in range(n - i):\n            r = i + l\n            res = 0\n            if abs(a[l] - a[r]) <= 1:\n                if dp[l + 1][r - 1] == r - l - 1:\n                    dp[l][r] = r - l + 1\n                    continue\n            res = dp[l + 1][r - 1]\n            for li in range(l + 1, r):\n                tmp = dp[l][li] + dp[li + 1][r]\n                if res < tmp:\n                    res = tmp\n            dp[l][r] = res\n    print(dp[0][n-1])\n    def dfs(l, r):\n        if l >= r: return 0\n        if dp[l][r] != -1: return dp[l][r]\n        if abs(a[l] - a[r]) <= 1:\n            if dfs(l + 1, r - 1) == r - l - 1:\n                dp[l][r] = r - l + 1\n                return r - l + 1\n        res = 0\n        for li in range(l + 1, r):\n            tmp = 0\n            f = 0\n            if dp[l][li] != -1:\n                tmp += dp[l][li]\n            else:\n                tmp += dfs(l, li)\n            if dp[li + 1][r] != -1:\n                tmp += dp[li + 1][r]\n            else:\n                tmp += dfs(li + 1, r)\n            if res < tmp:\n                res = tmp\n        dp[l][r] = res\n        return res\n    # print(dfs(0, n - 1))\n\n\nif __name__ == \"__main__\":\n    while 1:\n        n = int(input())\n        if n:\n            main(n)\n        else:\n            break\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nwhile n!=0:\n    w=list(map(int,input().split()))\n    check=[[False]*n for i in range(n)]\n    for i in range(n-1):\n        if abs(w[i+1]-w[i])<=1:\n            check[i][i+1]=True\n    for i in range(3,n,2):\n        for j in range(n-i):\n            for k in range(j+1,j+i):\n                if check[j][j+i]==False and check[j][k] and check[k+1][j+i]:\n                    check[j][j+i]=True\n                    break\n            if check[j][j+i]==False and abs(w[j]-w[j+i])<=1 and check[j+1][j+i-1]:\n                check[j][j+i]=True\n    dp=[0]*(n+1)\n    for k in range(n):\n        for m in range(k):\n            if check[m][k]:\n                dp[k]=max(dp[k],dp[m-1]+k-m+1)\n        dp[k]=max(dp[k],dp[k-1])\n    print(dp[n-1])\n    n=int(input())\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\nwhile True:\n    N = int(input())\n    if N==0:\n        break\n    W = list(map(int, input().split()))\n    assert len(W) == N\n\n\n    @lru_cache(maxsize=None)\n    def solve(l, r):\n        assert l<=r\n        if (r-l)%2==1:\n            return False\n        if r-l==2:\n            return abs(W[l]-W[l+1])<=1\n\n        if solve(l+1, r-1) and abs(W[l]-W[r-1])<=1:\n            return True\n        for i in range(l+2, r, 2):\n            if solve(l, i) and solve(i, r):\n                return True\n        return False\n        # return (solve(l, r-2) and solve(r-2, r)) \\\n        #     or (solve(l, l+2) and solve(l+2, r)) \\\n        #     or\n\n\n    dp = [0]*(N+1)\n    for i in range(1, N+1):\n        ma = 0\n        for j in range(i-1, -1, -1):\n            ma = max(ma, dp[j]+solve(j, i)*(i-j))\n            #if (j-i)%2==0:\n            #    print(f\"j={j}, i={i}, dp={solve(j,i)}\")\n        dp[i] = ma\n    #print(dp)\n    print(dp[-1])\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nw = list(map(int, input().split()))\ndp = [[-1 for j in range(n + 1)] for i in range(n + 1)]\n\n\ndef rec(l, r):\n    if dp[l][r] != -1:\n        return dp[l][r]\n\n    if abs(l - r) <= 1:\n        return 0\n\n    res = 0\n    if abs(w[l] - w[r - 1]) <= 1 and rec(l + 1, r - 1) == r - l - 2:\n        res = r - l\n\n    for mid in range(l + 1, r - 1):\n        res = max(res, rec(l, mid) + rec(mid, r))\n\n    dp[l][r] = res\n    return res\n\n\nprint(rec(0, n))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nwhile True:\n    n=int(input())\n    if n==0:\n        break\n    w = [int(x) for x in sys.stdin.readline().split()]\n\n    dp=[[0]*n for i in range(n)] \n\n    for l in range(n-1):\n        r=l+1\n        if abs(w[l]-w[r])<2:\n            dp[l][r]=2\n        \n    for i in range(2,n):\n        if i%2==1:\n            for l in range(n-i):\n                r=l+i\n                if dp[l+1][r-1]==r-l-1 and abs(w[l]-w[r])<2:\n                    dp[l][r]=r-l+1\n                else:\n                    for lr in range(l+1,r):\n                        if dp[l][r]< dp[l][lr]+dp[lr+1][r]:\n                            dp[l][r]=dp[l][lr]+dp[lr+1][r]\n        else:\n            for l in range(n-i):\n                r=l+i\n#                dp[l][r]=max(dp[l][r],dp[l+1][r],dp[l][r-1])\n                if dp[l][r]<dp[l+1][r]:\n                    dp[l][r]=dp[l+1][r]\n                if dp[l][r]<dp[l][r-1]:\n                    dp[l][r]=dp[l][r-1]\n    print(dp[0][n-1])\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\nwhile True:\n    N = int(input())\n    if N==0:\n        break\n    W = list(map(int, input().split()))\n\n\n    @lru_cache(maxsize=None)\n    def solve(l, r):\n        assert l<=r\n        if (r-l)%2==1:\n            return False\n        if r-l==2:\n            return abs(W[l]-W[l+1])<=1\n        return (solve(l, r-2) and solve(r-2, r)) \\\n            or (solve(l, l+2) and solve(l+2, r)) \\\n            or (solve(l+1, r-1) and abs(W[l]-W[r-1])<=1)\n\n\n    dp = [0]*(N+1)\n    for i in range(N+1):\n        ma = 0\n        for j in range(i-1, -1, -1):\n            ma = max(ma, dp[j]+solve(j, i)*(i-j))\n        dp[i] = ma\n\n    print(dp[-1])\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    W = [int(x) for x in input().split()]\n    dp = [[0] * N for _ in range(N)]\n    for w in range(2, N + 1):\n        for left in range(N - w + 1):\n            # [left, right]\n            right = left + w - 1\n            if right - left - 1 == dp[left + 1][right - 1] and abs(W[left] - W[right]) <= 1:\n                dp[left][right] = right - left + 1\n                continue\n            for mid in range(left + 1, right):\n                dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid + 1][right])\n    print(dp[0][N-1])"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef main():\n  while True:\n    n = int(input())\n    if(n == 0):\n      break\n    w = list(map(int, input().split()))\n    dp = [[0] * (n+1) for _ in range(n+2)]\n    for gap in range(2,n+1):\n      for l in range(n-gap+1):\n        r = l+gap\n        if(dp[l+1][r-1] == gap-2):\n          if(abs(w[l]-w[r-1]) <= 1):\n            dp[l][r] = gap\n            continue\n        for k in range(l, r):\n          if(dp[l][r] < dp[l][k]+dp[k][r]):\n            dp[l][r] = dp[l][k]+dp[k][r]\n    print(dp[0][n])\n    \nif __name__ == '__main__':\n  main()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nif n == 0:\n    break\nw = list(map(int, input().split()))\ndp = [[-1 for j in range(n + 1)] for i in range(n + 1)]\n\n\ndef rec(l, r):\n    # 既に計算済み？\n    if dp[l][r] != -1:\n        return dp[l][r]\n\n    # これ以上取り除けない？\n    if abs(l - r) <= 1:\n        return 0\n\n    res = 0\n    # パターン1.\n    if abs(w[l] - w[r - 1]) <= 1 and rec(l + 1, r - 1) == r - l - 2:\n        res = r - l\n\n    # パターン２.区間を分ける\n    for mid in range(l + 1, r - 1):\n        res = max(res, rec(l, mid) + rec(mid, r))\n\n    dp[l][r] = res\n    return res\n\n\nprint(rec(0, n))\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    N = int(input())\n    if not N:\n        break\n    W = [int(x) for x in input().split()]\n    dp = [[0] * N for _ in range(N)]\n    for w in range(2, N + 1):\n        for left in range(N - w + 1):\n            # [left, right]\n            right = left + w - 1\n            for mid in range(left + 1, right):\n                dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid + 1][right])\n            if right - left - 1 == dp[left + 1][right - 1] and abs(W[left] - W[right]) <= 1:\n                dp[left][right] = right - left + 1\n    print(dp[0][N-1])"
  },
  {
    "language": "Python",
    "code": "def main():\n  while True:\n    n = int(input())\n    if n == 0:\n      break\n    wlst = list(map(int, input().split()))\n    connect = [[None] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(n):\n        connect[i][j] = abs(wlst[i] - wlst[j]) <= 1\n    \n    max_lst = [[False] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n      max_lst[0][i] = True\n    \n    dp = [[0] * n for _ in range(n + 1)]\n    \n    def check(length, left):\n      ret = dp[length - 1][left]\n      for k in range(length - 1, 0, -2):\n        if not max_lst[length - k - 1][left + k]:continue\n        if connect[left + k - 1][left + length - 1]:\n          temp = length - k + 1 + dp[k - 1][left]\n          if ret < temp:\n            ret = temp\n      return ret\n    \n    for length in range(2, n + 1):\n      for left in range(n - length + 1):\n        dp[length][left] = check(length, left)\n        if dp[length][left] == length:\n          max_lst[length][left] = True\n    \n    print(dp[n][0])\n\nmain()\n  \n"
  },
  {
    "language": "Python",
    "code": "\nfrom functools import lru_cache\nwhile True:\n    N = int(input())\n    if N==0:\n        break\n    W = list(map(int, input().split()))\n    assert len(W) == N\n\n\n    @lru_cache(maxsize=None)\n    def solve(l, r):\n        assert l<=r\n        if (r-l)%2==1:\n            return False\n        if r-l==2:\n            return abs(W[l]-W[l+1])<=1\n        return (solve(l, r-2) and solve(r-2, r)) \\\n            or (solve(l, l+2) and solve(l+2, r)) \\\n            or (solve(l+1, r-1) and abs(W[l]-W[r-1])<=1)\n\n\n    dp = [0]*(N+1)\n    for i in range(1, N+1):\n        ma = 0\n        for j in range(i-1, -1, -1):\n            ma = max(ma, dp[j]+solve(j, i)*(i-j))\n        dp[i] = ma\n\n    print(dp[-1])\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = LI()\n\n        m = {}\n        def _f(a):\n            l = len(a)\n            if l < 2:\n                return 0\n            k = tuple(a)\n            if k in m:\n                return m[k]\n            r = 0\n            for i in range(len(a)-1):\n                if abs(a[i]-a[i+1]) >= 2:\n                    continue\n                t = _f(a[:i] + a[i+2:]) + 2\n                if r < t:\n                    r = t\n            m[k] = r\n            return r\n\n        return _f(a)\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\n\ndef f(daruma):\n\tglobal flag, min\n\tif (flag):\n\t\treturn\n\n\tlength = len(daruma)\n\tif (daruma == 0 or daruma == 1):\n\t\tprint(n - length)\n\t\tflag = true\n\t\treturn\n\n\tfor i in range(length-1):\n\t\tdiff = abs(daruma[i] - daruma[i+1])\n\t\tif (diff < 2):\n\t\t\tkari_daruma = daruma[:i] + daruma[i+2:]\n\t\t\tf(kari_daruma)\n\telse:\n\t\tmin = (min if min <= length else length)\n\t\treturn\n\nwhile 1:\n\tcount = 0\n\tflag = False\n\t\n\tn = int(input())\n\tif (n == 0):\n\t\tbreak\n\tmin = n\n\tdaruma = list(map(int, input().split()))\n\tf(daruma)\n\tprint(n - min)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef main():\n    while True:\n        n = int(input())\n\n        # nが0なら処理終わり\n        if n == 0:\n            sys.exit()\n\n        arr = list(map(int, input().split()))\n\n        # dpテーブル\n        dp = [[0] * n for _ in range(n)]\n\n        # dはdistance。lとrが1〜n-1離れている場合を順に考えていく\n        for d in range(1, n):\n\n            # distanceに応じてleftのレンジが変化する\n            for l in range(n - d):\n\n                # rは当然left+distance\n                r = l + d\n\n                # もしdistanceが奇数なら、1個内側を見ればいい\n                if d % 2 == 1:\n\n                    # left, rightの内側が全部叩き出せる場合\n                    if dp[l + 1][r - 1] == d - 1 and abs(arr[l] - arr[r]) <= 1:\n                        dp[l][r] = dp[l + 1][r - 1] + 2\n\n                    # 叩けないブロックがある場合はワーシャルフロイドっぽく解く\n                    else:\n                        for k in range(l + 1, r):\n                            tmp = dp[l][k] + dp[k + 1][r]\n                            if tmp > dp[l][r]:\n                                dp[l][r] = tmp\n\n                # もしdistanceが偶数なら、大きい方を採用するだけ\n                else:\n                    dp[l][r] = max(dp[l + 1][r], dp[l][r - 1])\n\n        print(dp[0][-1])\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def solve(n,lst):\n    #i行j列はjから連続したi個のうち落とせる個数の最大値\n    dp=[[0]*n for _ in range(n+1)]\n\n    #initialize\n    for j in range(n-1):\n        if abs(lst[j]-lst[j+1])<=1 : dp[2][j]=2\n    \n\n    #真ん中2*i個が抜けて上下を落とせる場合と2*(i+1)個を複数の部分に分けて落とせる場合の2通りが考えられる\n    for i in range(3,n+1):\n        for j in range(n-i+1):\n            mx=0\n            if i%2==0:\n                if abs(lst[j]-lst[j+i-1])<=1:\n                    if dp[i-2][j+1]==i-2:\n                        dp[i][j]=i\n                        continue\n                mx=dp[i-2][j+1]                \n                for k in range(2,i,2):\n                    if mx<dp[k][j]+dp[i-k][j+k]:\n                        mx=dp[k][j]+dp[i-k][j+k]\n                        if mx==i:break\n            else :\n                for k in range(1,i,2):\n                    if mx<dp[k][j]+dp[i-k][j+k]:\n                        mx=dp[k][j]+dp[i-k][j+k]                \n            dp[i][j]=mx\n    print(dp[n][0])        \n    #print(dp) \n\n                \n\nwhile 1:\n    n=int(input())\n    if n==0 : break\n    lst=tuple(map(int,input().split()))\n    solve(n,lst)  \n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nimport sys\ninput = lambda: sys.stdin.readline().strip()\nsys.setrecursionlimit(10 ** 8)\ndef solve():\n    n = int(input())\n    while n != 0:\n        w = tuple(map(int, input().split()))\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if (j - i + 1) % 2 == 0:\n                    if dp[i + 1][j - 1] == j - i - 1 and abs(w[i] - w[j]) <= 1:\n                        dp[i][j] = dp[i + 1][j - 1] + 2\n                    else:\n                        p = tuple(dp[i][k] + dp[k + 1][j] for k in range(i, j + 1))\n                        dp[i][j] = max(p)\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n        print(dp[0][n - 1])\n        n = int(input())\n\n\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "def main(n):\n    a = list(map(int, input().split()))\n    dp = [[0] * (n+1) for i in range(n)]\n    # 区間[l,r)の最大落とせる個数\n    for i in range(n - 1):\n        if abs(a[i] - a[i + 1]) <= 1:\n            dp[i][i + 2] = 2\n            # 隣り合う達磨weightが1以内のペアをdpに記録\n    for i in range(2, n): # 区間の広さ, 最大で0番目とn-1番目の差\n        for l in range(n-i): # 左側のとれる値は区間の広さに依存\n            r = i+l+1 # 右側は上記2変数から計\n            if abs(a[l] - a[r-1]) <= 1: # 今見ている左端と右端がweight 1以内の時\n                if dp[l+1][r-1] == r-l-2: # 左右1個ずつ内側の最大落とせる個数が「全部落とせる」だったとき\n                    dp[l][r] = r-l # dp[l][r]は左右端を追加して記録\n                    continue\n            res = dp[l+1][r-1] # とりあえず現在の左右1個ずつ内側の値を記録\n            for li in range(l+1, r): # lとrの間のどこかで区切って「lから区切り」「区切りからr」までの和を出す\n                tmp = dp[l][li] + dp[li][r] # 区間[l, li) と 区間[li, r)のdp和\n                if res < tmp: #区切った場所が最大値を更新するのであればresを更新\n                    res = tmp\n            dp[l][r] = res\n    print(dp[0][n]) # 左端 0 から右端 n-1 までの最大値を出す\n\nif __name__ == \"__main__\":\n    while 1:\n        n = int(input())\n        if n:\n            main(n)\n        else:\n            break\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    N = int(input())\n    if not N:\n        break\n    W = [int(x) for x in input().split()]\n    dp = [[0] * N for _ in range(N)]\n    for w in range(2, N + 1):\n        for left in range(N - w + 1):\n            # [left, right]\n            right = left + w - 1\n            if right - left - 1 == dp[left + 1][right - 1] and abs(W[left] - W[right]) <= 1:\n                dp[left][right] = right - left + 1\n                continue\n            for mid in range(left + 1, right):\n                dp[left][right] = max(dp[left][right], dp[left][mid] + dp[mid + 1][right])\n    print(dp[0][N-1])"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\n\ndef f(daruma):\n\tglobal flag, min\n\tif (flag):\n\t\treturn\n\n\tlength = len(daruma)\n\tif (daruma == 0 or daruma == 1):\n\t\tprint(n - length)\n\t\tflag = true\n\t\treturn\n\n\tfor i in range(length-1):\n\t\tdiff = abs(daruma[i] - daruma[i+1])\n\t\tif (diff < 2):\n\t\t\tkari_daruma = daruma[:i] + daruma[i+2:]\n\t\t\tf(kari_daruma)\n\telse:\n\t\tmin = (min if min <= length else length)\n\t\treturn\n\nwhile 1:\n\tcount = 0\n\tflag = False\n\t\n\tn = int(input())\n\tif (n == 0):\n\t\tbreak\n\tmin = n\n\tdaruma = list(map(int, input().split()))\n\tf(daruma)\n\tprint(n - min)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\ndef func():\n    while True:\n        N = int(input())\n        if N == 0: break\n        W = [int(i) for i in input().split()]\n        \n        dp = [[0]*(N+1) for j in range(N+1)]\n\n        for s in range(2, N+1):\n            for l in range(N-s+1):\n                r = l + s\n                if (s - 2) % 2 == 0:\n                    if dp[l+1][r-1] == s-2 and abs(W[l] - W[r-1]) <= 1:\n                        dp[l][r] = s\n                        continue\n                for i in range(l, r+1):\n                    if dp[l][r] < dp[l][i] + dp[i][r]:\n                        dp[l][r] = dp[l][i] + dp[i][r]\n\n        print(dp[0][N])\n\nif __name__ == \"__main__\":\n    func()\n"
  },
  {
    "language": "Python",
    "code": "def solve(n,w):\n    dp=[[0]*(n+1) for _ in range(n+1)]\n    for kukan in range(2,n+1):\n        for l in range(0,n+1-kukan):\n            r=l+kukan\n            #decide dp[l][l+kukan]\n            if (kukan-2)%2==0:\n                if abs(w[l]-w[r-1])<=1 and dp[l+1][r-1]==r-l-2:\n                    dp[l][r]=dp[l+1][r-1]+2\n                    continue\n            for i in range(l+1,r):\n                if dp[l][r]<(dp[l][i]+dp[i][r]):\n                    dp[l][r]=dp[l][i]+dp[i][r]\n    return dp[0][n]\n            \n\nn=int(input())\nwhile(n!=0):\n    w=list(map(int,input().split()))\n    print(solve(n,w))\n    n=int(input())\n"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nans = []\nidx = [x for x in reversed(range(300))]\nfor i in range(299):\n    idx[i + 1] += idx[i]\n\ndef dec(l, r):\n    return idx[l] + r - l\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    W = [int(x) for x in input().split()]\n    dp = [0] * (N * (N + 1) // 2)\n    for i in range(N-1):\n        if abs(W[i] - W[i + 1]) <= 1:\n            dp[dec(i, i + 1)] = 2\n    for w in range(3, N + 1):\n        for left in range(N - w + 1):\n            # [left, right]\n            right = left + w - 1\n            if w - 2 == dp[dec(left + 1, right - 1)] and abs(W[left] - W[right]) <= 1:\n                dp[dec(left, right)] = w\n                continue\n            for mid in range(left + 1, right):\n                m = dp[dec(left, mid)] + dp[dec(mid + 1, right)]\n                if m > dp[dec(left, right)]:\n                    dp[dec(left, right)] = m\n    print(dp[dec(0, N-1)])"
  },
  {
    "language": "Python",
    "code": "# AOJ 1611 ダルマ落とし\n# 貰うdp\n\nimport sys\n\n\ndef main():\n    while True:\n        N = int(input())\n        if N == 0:\n            break\n        w = list(map(int, sys.stdin.readline().strip().split()))\n\n        # dp 初期化 -------------------------------------------------\n        dp = [[0] * N for _ in range(N)]\n\n        for i in range(N - 1):\n            if abs(w[i] - w[i + 1]) <= 1:\n                dp[i][i + 1] = 2\n\n        # dp 更新 ------------------------------------------------------\n        for l in range(2, N):\n            for i in range(N - l):\n                j = i + l\n\n                if l % 2 == 1:\n                    if dp[i + 1][j - 1] == l - 1 and (abs(w[i] - w[j]) <= 1):\n                        dp[i][j] = l + 1\n                        continue\n\n                for k in range(i, j):\n                    if dp[i][j] < dp[i][k] + dp[k + 1][j]:\n                        dp[i][j] = dp[i][k] + dp[k + 1][j]\n                        if dp[i][j] == l:\n                            break\n\n        # for i in range(len(dp)):\n        #     print(dp[i])\n\n        print(dp[0][-1])\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\nwhile True:\n    N = int(input())\n    if N==0:\n        break\n    W = list(map(int, input().split()))\n\n\n    @lru_cache(maxsize=None)\n    def solve(l, r):\n        assert l<=r\n        if (r-l)%2==1:\n            return False\n        if r-l==2:\n            return abs(W[l]-W[l+1])<=1\n        return (solve(l, r-2) and solve(r-2, r)) \\\n            or (solve(l, l+2) and solve(l+2, r)) \\\n            or (solve(l+1, r-1) and abs(W[l]-W[r-1])<=1)\n\n\n    dp = [0]*(N+1)\n    for i in range(N+1):\n        ma = 0\n        for j in range(i-1, -1, -1):\n            ma = max(ma, dp[j]+solve(j, i)*(i-j))\n        dp[i] = ma\n\n    print(dp[-1])\n\n"
  },
  {
    "language": "Python",
    "code": "#2006_D\n\"\"\"\nimport sys\nfrom collections import defaultdict\ndef dfs(d,y,x,f):\n    global ans\n    if d >= 10:\n        return\n    f_ = defaultdict(int)\n    for i in f.keys():\n        f_[i] = f[i]\n    for t,s in vr[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if s == x+1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t,s-1,f_)\n            f_[(t,s)] = 1\n            break\n\n    for t,s in vl[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if s == x-1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t,s+1,f_)\n            f_[(t,s)] = 1\n            break\n\n    for t,s in vd[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if t == y+1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t-1,s,f_)\n            f_[(t,s)] = 1\n            break\n\n    for t,s in vu[(y,x)]:\n        if a[t][s] == 3:\n            ans = min(ans,d+1)\n            break\n        elif f[(t,s)]:\n            if t == y-1:\n                break\n            f_[(t,s)] = 0\n            dfs(d+1,t+1,s,f_)\n            f_[(t,s)] = 1\n            break\n    return\nwhile 1:\n    w,h = map(int, sys.stdin.readline()[:-1].split())\n    if w == h == 0:\n        break\n    a = [list(map(int, sys.stdin.readline()[:-1].split())) for i in range(h)]\n    vr = defaultdict(list)\n    vl = defaultdict(list)\n    vd = defaultdict(list)\n    vu = defaultdict(list)\n    f = defaultdict(int)\n    for y in range(h):\n        for x in range(w):\n            if a[y][x] == 1:\n                f[(y,x)] = 1\n            if a[y][x] in [1,3]:\n                for x_ in range(x):\n                    vr[(y,x_)].append((y,x))\n            elif a[y][x] == 2:\n                sy,sx = y,x\n    for y in range(h):\n        for x in range(w)[::-1]:\n            if a[y][x] in (1,3):\n                for x_ in range(x+1,w):\n                    vl[(y,x_)].append((y,x))\n    for x in range(w):\n        for y in range(h):\n            if a[y][x] in (1,3):\n                for y_ in range(y):\n                    vd[(y_,x)].append((y,x))\n    for x in range(w):\n        for y in range(h)[::-1]:\n            if a[y][x] in (1,3):\n                for y_ in range(y+1,h):\n                    vu[(y_,x)].append((y,x))\n    ind = [[[0]*4 for i in range(w)] for j in range(h)]\n    ans = 11\n    dfs(0,sy,sx,f)\n    ans = ans if ans < 11 else -1\n    print(ans)\n\"\"\"\n\n#2018_D\n\"\"\"\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\n\ndef dfs(d,s,l,v,dic):\n    s_ = tuple(s)\n    if dic[(d,s_)] != None:\n        return dic[(d,s_)]\n    if d == l:\n        dic[(d,s_)] = 1\n        for x in s:\n            if x > (n>>1):\n                dic[(d,s_)] = 0\n                return 0\n        return 1\n    else:\n        res = 0\n        i,j = v[d]\n        if s[i] < (n>>1):\n            s[i] += 1\n            res += dfs(d+1,s,l,v,dic)\n            s[i] -= 1\n        if s[j] < (n>>1):\n            s[j] += 1\n            res += dfs(d+1,s,l,v,dic)\n            s[j] -= 1\n        dic[(d,s_)] = res\n        return res\n\ndef solve(n):\n    dic = defaultdict(lambda : None)\n    m = int(sys.stdin.readline())\n    s = [0]*n\n    f = [[1]*n for i in range(n)]\n    for i in range(n):\n        f[i][i] = 0\n    for i in range(m):\n        x,y = [int(x) for x in sys.stdin.readline().split()]\n        x -= 1\n        y -= 1\n        s[x] += 1\n        f[x][y] = 0\n        f[y][x] = 0\n    v = []\n    for i in range(n):\n        for j in range(i+1,n):\n            if f[i][j]:\n                v.append((i,j))\n    l = len(v)\n    print(dfs(0,s,l,v,dic))\n\nwhile 1:\n    n = int(sys.stdin.readline())\n    if n == 0:\n        break\n    solve(n)\n\"\"\"\n#2011_D\n\"\"\"\nimport sys\ndef dfs(s,d,f,v):\n    global ans\n    if ans == n-n%2:\n        return\n    if d > ans:\n        ans = d\n    for i in range(n):\n        if s[i] == 0:\n            for j in range(i+1,n):\n                if s[j] == 0:\n                    if f[i] == f[j]:\n                        s[i] = -1\n                        s[j] = -1\n                        for k in v[i]:\n                            s[k] -= 1\n                        for k in v[j]:\n                            s[k] -= 1\n                        dfs(s,d+2,f,v)\n                        s[i] = 0\n                        s[j] = 0\n                        for k in v[i]:\n                            s[k] += 1\n                        for k in v[j]:\n                            s[k] += 1\n\ndef solve(n):\n    p = [[int(x) for x in sys.stdin.readline().split()] for i in range(n)]\n    v = [[] for i in range(n)]\n    f = [0]*n\n    s = [0]*n\n    for i in range(n):\n        x,y,r,f[i] = p[i]\n        for j in range(i+1,n):\n            xj,yj,rj,c = p[j]\n            if (x-xj)**2+(y-yj)**2 < (r+rj)**2:\n                v[i].append(j)\n                s[j] += 1\n    dfs(s,0,f,v)\n    print(ans)\nwhile 1:\n    n = int(sys.stdin.readline())\n    ans = 0\n    if n == 0:\n        break\n    solve(n)\n\"\"\"\n\n#2003_D\n\"\"\"\nimport sys\ndef root(x,par):\n    if par[x] == x:\n        return x\n    par[x] = root(par[x],par)\n    return par[x]\n\ndef unite(x,y,par,rank):\n    x = root(x,par)\n    y = root(y,par)\n    if rank[x] < rank[y]:\n        par[x] = y\n    else:\n        par[y] = x\n        if rank[x] == rank[y]:\n            rank[x] += 1\n\ndef solve(n):\n    p = [[float(x) for x in sys.stdin.readline().split()] for i in range(n)]\n    v = []\n    for i in range(n):\n        for j in range(i):\n            xi,yi,zi,ri = p[i]\n            xj,yj,zj,rj = p[j]\n            d = max(0,((xi-xj)**2+(yi-yj)**2+(zi-zj)**2)**0.5-(ri+rj))\n            v.append((i,j,d))\n    par = [i for i in range(n)]\n    rank = [0]*n\n    v.sort(key = lambda x:x[2])\n    ans = 0\n    for x,y,d in v:\n        if root(x,par) != root(y,par):\n            unite(x,y,par,rank)\n            ans += d\n    print(\"{:.3f}\".format(round(ans,3)))\n\nwhile 1:\n    n = int(sys.stdin.readline())\n    if n == 0:\n        break\n    solve(n)\n\"\"\"\n\n#2009_D\n\"\"\"\nimport sys\nfrom heapq import heappop,heappush\nfrom collections import defaultdict\ndef solve(n,m):\n    s,g = [int(x) for x in sys.stdin.readline().split()]\n    s -= 1\n    g -= 1\n    e = [[] for i in range(n)]\n    for i in range(m):\n        a,b,d,c = [int(x) for x in sys.stdin.readline().split()]\n        a -= 1\n        b -= 1\n        e[a].append((b,d,c))\n        e[b].append((a,d,c))\n    dist = defaultdict(lambda : float(\"inf\"))\n    dist[(s,0,-1)] = 0\n    q = [(0,s,0,-1)]\n    while q:\n        dx,x,v,p = heappop(q)\n        if x == g and v == 1:\n            print(dx)\n            return\n        for i in range(-1,2):\n            v_ = v+i\n            if v_ < 1 :continue\n            for y,d,c in e[x]:\n                if p == y:\n                    continue\n                if v_ > c:\n                    continue\n                z = d/v_\n                if dx+z < dist[(y,v_,x)]:\n                    dist[(y,v_,x)] = dx+z\n                    heappush(q,(dist[(y,v_,x)],y,v_,x))\n    print(\"unreachable\")\n    return\n\nwhile 1:\n    n,m = [int(x) for x in sys.stdin.readline().split()]\n    if n == 0:\n        break\n    solve(n,m)\n\"\"\"\n\n#2016_D\nimport sys\ndef solve(n):\n    w = [int(x) for x in sys.stdin.readline().split()]\n    dp = [[0]*(n+1) for i in range(n+1)]\n    for le in range(n+1):\n        for l in range(n):\n            r = l+le\n            if r > n:break\n            if not (r-l)%2 and abs(w[l]-w[r-1]) < 2:\n                if dp[l+1][r-1] == r-l-2:\n                    dp[l][r] = r-l\n                    continue\n            for k in range(l+1,r):\n                if dp[l][k] + dp[k][r] > dp[l][r]:\n                    dp[l][r] = dp[l][k] + dp[k][r]\n    print(dp[0][n])\nwhile 1:\n    n = int(sys.stdin.readline())\n    if not n:\n        break\n    solve(n)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve(n,w):\n    dp=[[0]*(n+1) for _ in range(n+1)]\n    for kukan in range(2,n+1):\n        for l in range(0,n+1-kukan):\n            r=l+kukan\n            #decide dp[l][l+kukan]\n            if (kukan-2)%2==0:\n                if abs(w[l]-w[r-1])<=1 and dp[l+1][r-1]==r-l-2:\n                    dp[l][r]=dp[l+1][r-1]+2\n                    continue\n            for i in range(l+1,r):\n                if dp[l][r]<(dp[l][i]+dp[i][r]):\n                    dp[l][r]=dp[l][i]+dp[i][r]\n    return dp[0][n]\n            \n\nn=int(input())\nwhile(n!=0):\n    w=list(map(int,input().split()))\n    print(solve(n,w))\n    n=int(input())\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = LI()\n        l = len(a)\n        s = set()\n        r = 0\n        for i in range(l-1):\n            if abs(a[i] - a[i+1]) < 2:\n                s.add((i,i+1))\n        for i in range(4, l+1):\n            for j in range(l-i+1):\n                k = j + i - 1\n                if (j+1, k-1) in s and abs(a[j] - a[k]) < 2:\n                    s.add((j,k))\n                    continue\n                for m in range(j+2,k,2):\n                    if (j,m-1) in s and (m,k) in s:\n                        s.add((j,k))\n                        break\n\n        m = {}\n        m[l] = 0\n        def _f(i):\n            if i in m:\n                return m[i]\n            r = 0\n            for j in range(i,l+1):\n                t = _f(j+1)\n                if (i,j) in s:\n                    t += j - i + 1\n                if r < t:\n                    r = t\n            m[i] = r\n            return r\n        return _f(0)\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def shot(i, daruma):\n    if i >= len(daruma):\n        results.append(n - len(daruma))\n        return\n\n    string = \"_\".join(map(str, daruma))\n    if dp[i].get(string):\n        return\n\n    dp[i][string] = True\n    shot(i + 1, daruma[:])\n    if abs(daruma[i - 1] - daruma[i]) <= 1:\n        del daruma[i]\n        del daruma[i - 1]\n        shot(1, daruma[:])\n\ndp = []\nresults = []\nn = 0\ndef resolve():\n    global results\n    global n\n    global dp\n    n = int(input())\n    if n == 0: return False\n\n    dp = [{} for x in range(n)]\n    daruma = list(map(int, input().split()))\n    results = []\n    shot(1, daruma[:])\n    print(max(results))\n    return True\n\n\nwhile resolve(): pass"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    w = list(map(int, input().split()))\n    dp = [[-1 for j in range(n + 1)] for i in range(n + 1)]\n\n    def rec(l, r):\n        # 既に計算済み？\n        if dp[l][r] != -1:\n            return dp[l][r]\n\n        # これ以上取り除けない？\n        if abs(l - r) <= 1:\n            return 0\n\n        res = 0\n        # パターン1.\n        if abs(w[l] - w[r - 1]) <= 1 and rec(l + 1, r - 1) == r - l - 2:\n            res = r - l\n\n        # パターン２.区間を分ける\n        for mid in range(l + 1, r - 1):\n            res = max(res, rec(l, mid) + rec(mid, r))\n\n        dp[l][r] = res\n        return res\n\n    print(rec(0, n))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip() \n\ndef resolve():\n    while True:\n        n = int(input())\n        w = list(map(int, input().split()))\n        if n==0:\n            break\n        else:\n            dp = [[0]*(n+1) for _ in range(n+2)]\n            # 幅\n            for i in range(2, n+1):\n                for l in range(n-i+1):\n                    r = l+i\n                    if dp[l+1][r-1] == i-2:\n                        if abs(w[l]-w[r-1])<=1:\n                            dp[l][r] = i\n                        else:\n                            dp[l][r] = i-2\n                    for j in range(l, r):\n                        if dp[l][j] + dp[j][r] > dp[l][r]:\n                            dp[l][r] = dp[l][j] + dp[j][r]\n\n            print(dp[0][-1])        \n\nif __name__ == '__main__':\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "def f(daruma):\n\tglobal flag, min\n\tif (flag):\n\t\treturn\n\n\tlength = len(daruma)\n\tif (daruma == 0 or daruma == 1):\n\t\tprint(n - length)\n\t\tflag = true\n\t\treturn\n\n\tfor i in range(length-1):\n\t\tdiff = abs(daruma[i] - daruma[i+1])\n\t\tif (diff < 2):\n\t\t\tkari_daruma = daruma[:i] + daruma[i+2:]\n\t\t\tf(kari_daruma)\n\telse:\n\t\tmin = (min if min <= length else length)\n\t\treturn\n\nwhile 1:\n\tcount = 0\n\tflag = False\n\t\n\tn = int(input())\n\tif (n == 0):\n\t\tbreak\n\tmin = n\n\tdaruma = list(map(int, input().split()))\n\tf(daruma)\n\tprint(n - min)\n"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if n == 0:\n    break\n  wlst = list(map(int, input().split()))\n  dp = [[0] * n for _ in range(n + 1)]\n  \n  def check(left1, right1, left2, right2, cnt):\n    if left1 > right1 and left2 > right2: return cnt\n    if left1 > right1:return dp[right2 - left2 + 1][left2] + cnt\n    if left2 > right2:return dp[right1 - left1 + 1][left1] + cnt\n    ret = cnt + dp[right1 - left1 + 1][left1] + dp[right2 - left2 + 1][left2]\n    if abs(wlst[right1] - wlst[left2]) <= 1:\n      ret = max(ret, check(left1, right1 - 1, left2 + 1, right2, cnt + 1))\n    if right1 - left1 + 1 >= 2 and dp[2][right1 - 1]:\n      ret = max(ret, check(left1, right1 - 2, left2, right2, cnt + 1))\n    if right2 - left2 + 1 >= 2 and dp[2][left2]:\n      ret = max(ret, check(left1, right1, left2 + 2, right2, cnt + 1))\n    return ret\n  \n  for length in range(2, n + 1):\n    for left in range(n - length + 1):\n      for k in range(length - 1):\n        dp[length][left] = max(dp[length][left], check(left, left + k, left + k + 1, left + length - 1, 0))\n  \n  print(dp[n][0] * 2)\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nwhile True:\n    l1 = list(map(int,input().split()))\n    c = [[False] * n for i in range(n)]\n    d = [0] * (n + 1)\n    for i in range(n - 1):\n        if abs(l1[i + 1] - l1[i]) <= 1:\n            c[i][i + 1] = True\n            \n    for i in range(3, n, 2):\n        for j in range(n - i):\n            for k in range(j + 1, j + i):\n                if c[j][j + i] == False and c[j][k] and c[k + 1][j + i]:\n                    c[j][j + i] = True\n                    break\n            if c[j][j + i] == False and abs(l1[j] - l1[j + i]) <= 1 and c[j + 1][j + i - 1]:\n                c[j][j + i] = True\n                \n    for i in range(n):\n        for j in range(i):\n            if c[j][i]:\n                d[i] = max(d[i], d[j - 1] + i - j + 1)\n        d[i] = max(d[i], d[i - 1])\n        \n    print(d[n - 1])\n    \n    n = int(input())\n    if n == 0:\n        break\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\ndef f(daruma):\n\tglobal flag, min\n\tif (flag):\n\t\treturn\n\n\tlength = len(daruma)\n\tif (daruma == 0 or daruma == 1):\n\t\tprint(n - length)\n\t\tflag = true\n\t\treturn\n\n\tfor i in range(length-1):\n\t\tdiff = abs(daruma[i] - daruma[i+1])\n\t\tif (diff < 2):\n\t\t\tkari_daruma = daruma[:i] + daruma[i+2:]\n\t\t\tf(kari_daruma)\n\telse:\n\t\tmin = (min if min <= length else length)\n\t\treturn\n\nwhile 1:\n\tcount = 0\n\tflag = False\n\t\n\tn = int(input())\n\tif (n == 0):\n\t\tbreak\n\tmin = n\n\tdaruma = list(map(int, input().split()))\n\tf(daruma)\n\tprint(n - min)\n"
  },
  {
    "language": "Python",
    "code": "# coding:utf-8\n\nimport sys\n\n\ninput = sys.stdin.readline\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\n\ndef inpl(): return list(map(int, input().split()))\n\n\ndef solve(n, W):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for w in range(2, n + 1):\n        for l in range(n):\n            r = l + w\n            if r > n: continue\n\n            if dp[l + 1][r - 1] == w - 2 and abs(W[l] - W[r - 1]) <= 1:\n                dp[l][r] = w\n\n            for mid in range(l, r):\n                dp[l][r] = max(dp[l][r], dp[l][mid] + dp[mid][r])\n            # print(l, r, dp)\n\n    return dp[0][n]\n\n\nwhile 1:\n    n = int(input())\n    W = inpl()\n    if n == 0:\n        exit()\n    print(solve(n, W))\n\n"
  },
  {
    "language": "Python",
    "code": "\nwhile True:\n    n=int(input())\n    if n== 0:\n        break\n    \n    A = list(map(int, input().split()))\n    c = [[0]*n for _ in range(n)]\n    for i in range(n):\n        c[i][i] = 0\n        \n    for i in range(1, n):\n        if i%2==0:\n            continue\n        for j in range(n-i):\n            if i==1 and abs(A[j] - A[j+i])<=1:\n                    c[j][j+i] = 1 \n            else:\n                for k in range(j+1, j+i-1):\n                    #print(f'j:{j}, i:{i}, k:{k}, c[j][k]{c[j][k]} and c[k+1][j+i]{c[k+1][j+i]}')\n                    if c[j][k] and c[k+1][j+i]:\n                        c[j][j+i] = 1\n                        break\n                if c[j+1][j+i-1] and abs(A[j] - A[j+i])<=1:\n                    c[j][j+i] = 1\n    \n    dp = [[0]*n for _ in range(n)]\n    \n    for i in range(1):\n        for j in range(i, n):\n            if c[i][j]:\n                dp[i][j] = j-i+1\n            else:\n                for k in range(i, j):\n                    if c[k+1][j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + j-k)\n                if j>i:\n                    dp[i][j] = max(dp[i][j], dp[i][j-1])\n    \n    print(dp[0][n-1])\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef main():\n    while True:\n        N = int(input())\n        if N == 0:\n            exit()\n        A = list(map(int,input().split()))\n        can_drop = [[False] * N for _ in range(N)]\n        # d[i]: i個のブロック列で最大何個落とせるか\n        d = [0] * (N+1)\n\n        # 隣接するのが落とせるかどうか\n        for i in range(N-1):\n            if abs(A[i] - A[i+1]) <= 1:\n                can_drop[i][i+1] = True\n\n        # 何個分をみるか。一個増えても落とせるやつ個数が増えたりしないので２刻み\n        for i in range(3, N, 2):\n            # どのブロックはじめで見るか。\n            for j in range(N-i):\n                # 間\n                last = j + i\n                for k in range(j+1, j+i):\n                    # j~lastまでで落とせないが、j~k, k+1~lastに分けてみると、両方の部分で結果的にj~lastで落とせる場合\n                    if not can_drop[j][last] and can_drop[j][k] and can_drop[k+1][last]:\n                        can_drop[j][last] = True\n                        break\n                # j ~ lastで落ちないが、j+1~last-1で落とせて、jとlastの差が１以下の場合は、j~lastで落とせると言える\n                if not can_drop[j][last] and can_drop[j+1][last-1] and abs(A[j] - A[last]) <= 1:\n                    can_drop[j][last] = True\n\n        # can_dropのTrueが続いている最長部分を探す\n        for i in range(N):\n            for j in range(N):\n                if can_drop[j][i]:\n                    d[i] = max(d[i], d[j-1] + i - j + 1)\n        \n            d[i] = max(d[i], d[i - 1])\n        print(d[N-1])        \n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n#input = lambda: sys.stdin.readline().rstrip()\n#区間DP\n\ndef main():\n  while True:\n    n = int(input())\n    if(n == 0):\n      break\n    w = list(map(int, input().split()))\n    \n    dp = [[0] * (n+1) for _ in range(n+1)]\n    \n    for gap in range(2,n+1):\n      #gapが小さい方から埋めることで漏れをなくす\n      for l in range(n-gap+1):\n        r = l+gap\n        if(dp[l+1][r-1] == gap-2):\n          if(abs(w[l]-w[r-1]) <= 1):\n            dp[l][r] = gap\n            continue\n        for k in range(l, r):\n          if(dp[l][r] < dp[l][k] + dp[k][r]):\n            dp[l][r] = dp[l][k] + dp[k][r]\n    print(dp[0][n])\n    #print(dp)\n    \nif __name__ == '__main__':\n  main()\n"
  },
  {
    "language": "Python",
    "code": "# coding:utf-8\n\nimport sys\nfrom collections import Counter\n\n\ninput = sys.stdin.readline\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\n\ndef inpl(): return list(map(int, input().split()))\n\n\ndef solve(n, W):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    def rec(l, r):\n        if dp[l][r] != 0:\n            return dp[l][r]\n\n        if abs(r - l) <= 1:\n            return 0\n\n        res = 0\n        if abs(W[l] - W[r - 1]) <= 1 and rec(l + 1, r - 1) == r - l - 2:\n            res = r - l\n\n        for mid in range(l + 1, r - 1):\n            res = max(res, rec(l, mid) + rec(mid, r))\n\n        dp[l][r] = res\n        return res\n\n    return rec(0, n)\n\n\nwhile 1:\n    n = int(input())\n    W = inpl()\n    if n == 0:\n        exit()\n    print(solve(n, W))\n\n"
  },
  {
    "language": "Python",
    "code": "def isvalid(a, b):\n    return abs(a - b) < 2\nwhile 1:\n    n = input()\n    if n==0:\n        break\n    W = map(int, raw_input().split())\n    dp = [[0]*n for i in xrange(n)]\n    for i in xrange(n-1):\n        if isvalid(W[i], W[i+1]):\n            dp[i][i+1] = 1\n    for l in xrange(1, n+1):\n        for j in xrange(n-l):\n            i = j+l\n            # [i,j]\n            if j+2 < i and isvalid(W[j], W[j+1]) and dp[j+2][i]:\n                # ab[...]\n                dp[j][i] = 1\n            elif j < i-2 and isvalid(W[i-1], W[i]) and dp[j][i-2]:\n                # [...]ab\n                dp[j][i] = 1\n            elif j+1 < i-1 and isvalid(W[j], W[i]) and dp[j+1][i-1]:\n                # a[...]b\n                dp[j][i] = 1\n            else:\n                # [...][...]\n                for k in xrange(j+1, i-1):\n                    if dp[j][k] and dp[k+1][i]:\n                        dp[j][i] = 1\n                        print j, k, k+1, i\n                        break\n    res = [0]*n\n    for i in xrange(n):\n        r = res[i-1]\n        for j in xrange(i):\n            if dp[j][i]:\n                r = max(r, res[j-1]+(i-j+1))\n        res[i] = r\n    print res[n-1]"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=int(input())\n    if(n==0):\n        exit()\n    w=list(map(int,input().split()))\n    c=[[False]*n for _ in range(n)]\n    dp=[0]*(n+1)\n    for i in range(n-1):\n        if abs(w[i]-w[i+1])<=1:\n            c[i][i+1]=True\n    for i in range(3,n,2):\n        for l in range(n-i):\n            r=l+i\n            for k in range(l+1,r):\n                if not c[l][r] and c[l][k] and c[k+1][r]:\n                    c[l][r]=True\n                    break\n            if (not c[l][r]) and c[l+1][r-1] and abs(w[l]-w[r])<=1:\n                c[l][r]=True\n    for i in range(n):\n        for j in range(n):\n            if c[j][i]:\n                dp[i]=max(dp[i],dp[j-1]+i-j+1)\n        dp[i]=max(dp[i],dp[i-1])\n    print(dp[n-1])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return map(int, sys.stdin.readline().split())\ndef ti(): return tuple(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\ndef dp3(ini, i, j, k): return [[[ini]*i for _ in range(j)] for _ in range(k)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from itertools import accumulate #list(accumulate(A))\n\n## DP\n\ndef solve(N):\n    A = ti()\n    dp = dp2(0, N, N)\n\n    for i in range(N-1):\n        if abs(A[i]-A[i+1]) < 2:\n            dp[i][i+1] = 2\n    \n    for h in range(2, N): #hは(区間の長さ)-1\n        for i in range(N):\n            if i+h >= N:\n                break\n            j = i+h\n            # 区間の長さが偶数の場合\n            if h % 2:\n                if abs(A[i]-A[j]) < 2 and dp[i+1][j-1] == h-1:\n                    dp[i][j] = h + 1\n                    continue\n                else:\n                    dp[i][j] = max(tuple(dp[i][k]+dp[k+1][j] for k in range(i, j)))\n            # 区間の長さが奇数の場合\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        else:\n            continue\n\n    print(dp[0][N-1])\n\nwhile True:\n    N = ii()\n    if N == 0:\n        exit()\n    solve(N)\n"
  },
  {
    "language": "Python",
    "code": "def isvalid(a, b):\n    return abs(a - b) < 2\nwhile 1:\n    n = input()\n    if n==0:\n        break\n    W = map(int, raw_input().split())\n    dp = [[0]*n for i in xrange(n)]\n    for i in xrange(1, n):\n        if isvalid(W[i], W[i-1]):\n            dp[i-1][i] = 1\n        for j in xrange(i):\n            # [i,j]\n            if j+2 < i and isvalid(W[j], W[j+1]) and dp[j+2][i]:\n                # ab[...]\n                dp[j][i] = 1\n            elif j < i-2 and isvalid(W[i-1], W[i]) and dp[j][i-2]:\n                # [...]ab\n                dp[j][i] = 1\n            elif j+1 < i-1 and isvalid(W[j], W[i]) and dp[j+1][i-1]:\n                # a[...]b\n                dp[j][i] = 1\n            else:\n                # [...][...]\n                for k in xrange(j+1, i-1):\n                    if dp[j][k] and dp[k+1][i]:\n                        dp[j][i] = 1\n                        break\n    res = [0]*n\n    for i in xrange(n):\n        r = res[i-1]\n        for j in xrange(i):\n            if dp[j][i]:\n                r = max(r, res[j-1]+(i-j+1))\n        res[i] = r\n    print res[n-1]"
  },
  {
    "language": "Python",
    "code": "def solve(n,lst):\n    #i行j列はjから連続したi個のうち落とせる個数の最大値\n    dp=[[0]*n for _ in range(n+1)]\n\n    #initialize\n    for j in range(n-1):\n        if abs(lst[j]-lst[j+1])<=1 : dp[2][j]=2\n    \n\n    #真ん中2*i個が抜けて上下を落とせる場合と2*(i+1)個を複数の部分に分けて落とせる場合の2通りが考えられる\n    for i in range(3,n+1):\n        for j in range(n-i+1):\n            mx=0\n            if i%2==0:\n                if abs(lst[j]-lst[j+i-1])<=1:\n                    if dp[i-2][j+1]==i-2:\n                        dp[i][j]=i\n                        continue\n                mx=dp[i-2][j+1]                \n                for k in range(2,i,2):\n                    if mx<dp[k][j]+dp[i-k][j+k]:\n                        mx=dp[k][j]+dp[i-k][j+k]\n                        if mx==i:break\n            else :\n                for k in range(1,i,2):\n                    if mx<dp[k][j]+dp[i-k][j+k]:\n                        mx=dp[k][j]+dp[i-k][j+k]                \n            dp[i][j]=mx\n    print(dp[n][0])        \n    #print(dp) \n\n                \n\nwhile 1:\n    n=int(input())\n    if n==0 : break\n    lst=tuple(map(int,input().split()))\n    solve(n,lst)  \n"
  },
  {
    "language": "Python",
    "code": "# import sys\n# input = lambda: sys.stdin.readline().rstrip()\n\ndef resolve():\n    while True:\n        n = int(input())\n\n        if n == 0:\n            exit()\n        w = list(map(int, input().split()))\n        \n        dp = [[0]*(n+1) for _ in range(n+2)]\n        for gap in range(2,n+1):\n            for l in range(n-gap+1):\n                r = l + gap\n                if dp[l+1][r-1] == gap-2:\n                    if abs(w[l] - w[r-1]) <= 1:\n                        dp[l][r] = gap\n                    else:\n                        dp[l][r] = gap - 2\n                for k in range(l,r):\n                    if dp[l][k] + dp[k][r] > dp[l][r]:\n                            dp[l][r] = dp[l][k] + dp[k][r]\n                    # dp[l][r] = max(dp[l][r], dp[l][k] + dp[k][r])\n        # for i in range(n):\n        #     print(*dp[i])\n        print(dp[0][-1])\nif __name__ == \"__main__\":\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef main():\n  while True:\n    n = int(input())\n    if(n == 0):\n      break\n    w = list(map(int, input().split()))\n    dp = [[0] * (n+1) for _ in range(n+2)]\n    for gap in range(2,n+1):\n      for l in range(n-gap+1):\n        r = l+gap\n        if(dp[l+1][r-1] == gap-2):\n          if(abs(w[l]-w[r-1]) <= 1):\n            dp[l][r] = gap\n            continue\n        for k in range(l, r):\n          if(dp[l][r] < dp[l][k]+dp[k][r]):\n            dp[l][r] = dp[l][k]+dp[k][r]\n    print(dp[0][n])\n    \nif __name__ == '__main__':\n  main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nans = []\nwhile True:\n    N = int(input())\n    if N == 0: break\n    W = list(map(int, input().split()))\n    # dp[i][j]: iからjのブロックを全て除外可能か\n    dp = [[False]*N for _ in range(N)]\n    for i in range(N-1):\n        if abs(W[i]-W[i+1]) <= 1:\n            dp[i][i+1] = True\n    for d in range(4, N+1):\n        for i in range(N-d+1):\n            j = i+d-1\n            for k in range(i, j):\n                if dp[i][k] and dp[k+1][j]:\n                    dp[i][j] = True\n            if abs(W[i]-W[j]) <= 1 and dp[i+1][j-1]:\n                dp[i][j] = True\n    # dp2[i]: iまでで除外可能なブロックの最大値(1-indexed)\n    dp2 = [0]*(N+1)\n    for i in range(N):\n        for j in range(i+1, N):\n            if dp[i][j]:\n                dp2[j+1] = max(dp2[j+1], dp2[i]+j-i+1)\n        dp2[i+1] = max(dp2[i+1], dp2[i])\n    ans.append(dp2[N])\nprint(*ans, sep=\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "def isvalid(a, b):\n    return abs(a - b) < 2\nwhile 1:\n    n = input()\n    if n==0:\n        break\n    W = map(int, raw_input().split())\n    dp = [[0]*n for i in xrange(n)]\n    for i in xrange(n-1):\n        if isvalid(W[i], W[i+1]):\n            dp[i][i+1] = 1\n    for l in xrange(1, n+1):\n        for j in xrange(n-l):\n            i = j+l\n            # [i,j]\n            if j+2 < i and isvalid(W[j], W[j+1]) and dp[j+2][i]:\n                # ab[...]\n                dp[j][i] = 1\n            elif j < i-2 and isvalid(W[i-1], W[i]) and dp[j][i-2]:\n                # [...]ab\n                dp[j][i] = 1\n            elif j+1 < i-1 and isvalid(W[j], W[i]) and dp[j+1][i-1]:\n                # a[...]b\n                dp[j][i] = 1\n            else:\n                # [...][...]\n                for k in xrange(j+1, i-1):\n                    if dp[j][k] and dp[k+1][i]:\n                        dp[j][i] = 1\n                        break\n    res = [0]*n\n    for i in xrange(n):\n        r = res[i-1]\n        for j in xrange(i):\n            if dp[j][i]:\n                r = max(r, res[j-1]+(i-j+1))\n        res[i] = r\n    print res[n-1]"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[macro_export]\nmacro_rules ! chmax { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: max ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! chmin { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: min ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! max { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: max ( $ x , max ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! min { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: min ( $ x , min ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! dvec { ( $ t : expr ; $ len : expr ) => { vec ! [ $ t ; $ len ] } ; ( $ t : expr ; $ len : expr , $ ( $ rest : expr ) ,* ) => { vec ! [ dvec ! ( $ t ; $ ( $ rest ) ,* ) ; $ len ] } ; }\n#[macro_export]\nmacro_rules ! cfor { ( ; $ ( $ rest : tt ) * ) => { cfor ! ( ( ) ; $ ( $ rest ) * ) } ; ( $ ( $ init : stmt ) ,+; ; $ ( $ rest : tt ) * ) => { cfor ! ( $ ( $ init ) ,+; ! false ; $ ( $ rest ) * ) } ; ( $ ( $ init : stmt ) ,+; $ cond : expr ; ; $ body : block ) => { cfor ! { $ ( $ init ) ,+; $ cond ; ( ) ; $ body } } ; ( $ ( $ init : stmt ) ,+; $ cond : expr ; $ ( $ step : expr ) ,+; $ body : block ) => { { $ ( $ init ; ) + while $ cond { let mut _first = true ; let mut _continue = false ; loop { if ! _first { _continue = true ; break } _first = false ; $ body } if ! _continue { break } $ ( $ step ; ) + } } } ; }\n#[doc = \" main\"]\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn incl(x: usize) -> usize {\n    x+1\n}\nfn solve() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    input!{\n        new_stdin_parser = parser,\n    }\n    loop {\n        input!{\n            parser = parser,\n            n: usize,\n            a: [i64; n],\n        }\n        if n==0 { break; }\n        \n        let mut dp = dvec![0;n+1,n+1];\n        for w in 2..incl(n) {\n            for l in 0..incl(n-w) {\n                let r = l+w;\n                for m in l..incl(r) {\n                    chmax!(dp[l][r], dp[l][m]+dp[m][r]);\n                }\n                if w%2==0 {\n                    let x = a[l];\n                    let y = a[r-1];\n                    if (x-y).abs()<=1 && dp[l+1][r-1]==w-2 {\n                        dp[l][r] = w;\n                    }\n                }\n            }\n        }\n        writeln!(out,\"{}\",dp[0][n]);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    loop {\n        let n = read::<usize>();\n        if n == 0 {\n            return;\n        }\n        let w = read_vec::<i64>();\n        let mut dp = vec![vec![0; n + 1]; n + 1];\n\n        for wi in 2..n + 1 {\n            for i in 0..n {\n                let j = i + wi;\n                if j > n {\n                    break;\n                }\n\n                for k in i..j + 1 {\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j]);\n                }\n                if wi >= 2 && dp[i + 1][j - 1] == wi - 2 && (w[i] - w[j - 1]).abs() <= 1 {\n                    dp[i][j] = wi;\n                }\n            }\n        }\n        println!(\"{}\", dp[0][n]);\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::stdin;\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\nfn rec(l: usize, r: usize, seq: &[usize], memo: &mut Vec<Vec<Option<usize>>>) -> usize {\n    if r - l < 2 {\n        return 0;\n    }\n\n    if r - l == 2 {\n        return if (seq[l] as i64 - seq[l + 1] as i64).abs() <= 1 {\n            2\n        } else {\n            0\n        };\n    }\n\n    if let Some(res) = memo[l][r] {\n        return res;\n    }\n\n    let mut res = 0;\n    for i in l..r {\n        for j in i + 1..r {\n            if (seq[i] as i64 - seq[j] as i64).abs() <= 1 {\n                if rec(i + 1, j, seq, memo) == (j - i - 1) {\n                    res = max(\n                        res,\n                        2 + rec(l, i, seq, memo) + rec(i + 1, j, seq, memo)\n                            + rec(j + 1, r, seq, memo),\n                    );\n                }\n            }\n        }\n    }\n\n    memo[l][r] = Some(res);\n    res\n}\n\nfn main() {\n    loop {\n        let n = get!(usize);\n\n        if n == 0 {\n            break;\n        }\n\n        let ws = get!(usize;;);\n\n        let mut memo = vec![vec![None; n + 1]; n + 1];\n        println!(\"{}\", rec(0, n, &ws, &mut memo));\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::stdin;\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\nfn rec(l: usize, r: usize, seq: &[usize], memo: &mut Vec<Vec<Option<usize>>>) -> usize {\n    if r - l < 2 {\n        return 0;\n    }\n\n    if r - l == 2 {\n        return if (seq[l] as i64 - seq[l + 1] as i64).abs() <= 1 {\n            2\n        } else {\n            0\n        };\n    }\n\n    if let Some(res) = memo[l][r] {\n        return res;\n    }\n\n    let mut res = 0;\n    for i in l..r {\n        for j in i + 1..r {\n            if (seq[i] as i64 - seq[j] as i64).abs() <= 1 {\n                if rec(i + 1, j, seq, memo) == (j - i - 1) {\n                    res = max(\n                        res,\n                        2 + rec(l, i, seq, memo) + rec(i + 1, j, seq, memo)\n                            + rec(j + 1, r, seq, memo),\n                    );\n                }\n            }\n        }\n    }\n\n    memo[l][r] = Some(res);\n    res\n}\n\nfn main() {\n    loop {\n        let n = get!(usize);\n\n        if n == 0 {\n            break;\n        }\n\n        let ws = util::gets();\n\n        let mut memo = vec![vec![None; n + 1]; n + 1];\n        println!(\"{}\", rec(0, n, &ws, &mut memo));\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::*;\nuse std::collections::hash_map::Entry;\nuse std::collections::HashMap;\nuse std::io::*;\nuse std::str::FromStr;\nuse std::string::String;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<std::cmp::Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\n\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> std::cmp::Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\nstruct DP {\n    w: Vec<i32>,\n    memo: Vec<Vec<i32>>,\n}\n\nimpl DP {\n    fn new(n: usize, w: Vec<i32>) -> Self {\n        DP {\n            w: w,\n            memo: vec![vec![-1; n + 10]; n + 10],\n        }\n    }\n\n    fn dfs(&mut self, l: usize, r: usize) -> i32 {\n        if self.memo[l][r] != -1 {\n            return self.memo[l][r];\n        }\n\n        if r - l <= 1 {\n            return 0;\n        }\n\n        let mut res = 0i32;\n\n        if (self.w[l] - self.w[r - 1]).abs() <= 1 && self.dfs(l + 1, r - 1) == (r - l - 2) as i32 {\n            res = (r - l) as i32;\n        }\n\n        for mid in l + 1..r {\n            res = max(res, self.dfs(l, mid) + self.dfs(mid, r));\n        }\n\n        self.memo[l][r] = res;\n\n        return self.memo[l][r];\n    }\n}\n\nfn main() {\n    loop {\n        let n: usize = read();\n        if n == 0 {\n            return;\n        }\n\n        let w: Vec<i32> = (0..n).map(|_| read()).collect();\n        let mut dp = DP::new(n, w);\n\n        dp.dfs(0, n);\n\n        println!(\"{}\", dp.memo[0][n]);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::stdin;\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\nfn rec(l: usize, r: usize, seq: &[usize], memo: &mut Vec<Vec<Option<usize>>>) -> usize {\n    if r - l < 2 {\n        return 0;\n    }\n\n    if let Some(res) = memo[l][r] {\n        return res;\n    }\n\n    if (seq[l] as i64 - seq[r - 1] as i64).abs() <= 1 {\n        if rec(l + 1, r - 1, seq, memo) + 2 == r - l {\n            let res = r - l;\n            memo[l][r] = Some(res);\n            return res;\n        }\n    }\n\n    let mut res = 0;\n    for c in l + 1..r {\n        res = max(res, rec(l, c, seq, memo) + rec(c, r, seq, memo));\n    }\n\n    memo[l][r] = Some(res);\n    res\n}\n\nfn main() {\n    loop {\n        let n = get!(usize);\n\n        if n == 0 {\n            break;\n        }\n\n        let ws = util::gets();\n\n        let mut memo = vec![vec![None; n + 1]; n + 1];\n        println!(\"{}\", rec(0, n, &ws, &mut memo));\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n#![allow(dead_code)]\n#![allow(unused_macros)]\n#![allow(unused_imports)]\n\nuse std::str::FromStr;\nuse std::io::*;\nuse std::collections::*;\nuse std::cmp::*;\n\nstruct Scanner<I: Iterator<Item = char>> {\n    iter: std::iter::Peekable<I>,\n}\n\nmacro_rules! exit {\n    () => {{\n        exit!(0)\n    }};\n    ($code:expr) => {{\n        if cfg!(local) {\n            writeln!(std::io::stderr(), \"===== Terminated =====\")\n                .expect(\"failed printing to stderr\");\n        }\n        std::process::exit($code);\n    }}\n}\n\nimpl<I: Iterator<Item = char>> Scanner<I> {\n    pub fn new(iter: I) -> Scanner<I> {\n        Scanner {\n            iter: iter.peekable(),\n        }\n    }\n\n    pub fn safe_get_token(&mut self) -> Option<String> {\n        let token = self.iter\n            .by_ref()\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        if token.is_empty() {\n            None\n        } else {\n            Some(token)\n        }\n    }\n\n    pub fn token(&mut self) -> String {\n        self.safe_get_token().unwrap_or_else(|| exit!())\n    }\n\n    pub fn get<T: FromStr>(&mut self) -> T {\n        self.token().parse::<T>().unwrap_or_else(|_| exit!())\n    }\n\n    pub fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {\n        (0..len).map(|_| self.get()).collect()\n    }\n\n    pub fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {\n        (0..row).map(|_| self.vec(col)).collect()\n    }\n\n    pub fn char(&mut self) -> char {\n        self.iter.next().unwrap_or_else(|| exit!())\n    }\n\n    pub fn chars(&mut self) -> Vec<char> {\n        self.get::<String>().chars().collect()\n    }\n\n    pub fn mat_chars(&mut self, row: usize) -> Vec<Vec<char>> {\n        (0..row).map(|_| self.chars()).collect()\n    }\n\n    pub fn line(&mut self) -> String {\n        if self.peek().is_some() {\n            self.iter\n                .by_ref()\n                .take_while(|&c| !(c == '\\n' || c == '\\r'))\n                .collect::<String>()\n        } else {\n            exit!();\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<&char> {\n        self.iter.peek()\n    }\n}\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin.bytes().map(|c| c.unwrap() as char));\n    loop {\n        let n: usize = sc.get();\n        if n == 0 {\n            break;\n        }\n        let w: Vec<i64> = sc.vec(n);\n        let mut dp = vec![vec![0; n+1]; n+1];\n        for l in 0..n-1 {\n            let r = l + 2;\n            if (w[l] - w[r-1]).abs() < 2 {\n                dp[l][r] = 2;\n            }\n        }\n        for width in 3..n+1 {\n            for l in 0..n {\n                let r = min(l + width, n);\n                if (w[l] - w[r-1]).abs() < 2 && dp[l+1][r-1] == width-2 {\n                    dp[l][r] = max(dp[l][r], width);\n                }\n                for i in l+1..r {\n                    dp[l][r] = max(dp[l][r], dp[l][i] + dp[i][r]);\n                }\n            }\n        }\n        println!(\"{}\", dp[0][n]);\n    }\n}\n\n"
  }
]