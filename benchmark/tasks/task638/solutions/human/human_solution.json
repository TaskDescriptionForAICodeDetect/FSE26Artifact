[
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2020/09/20.\n//\n\n#include <bits/stdc++.h>\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing mti = vector<vector<int>>;\nusing vl = vector<ll>;\nusing mtl = vector<vector<ll>>;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\ntemplate<typename T>\nusing heap = priority_queue<T, vector<T>, function<bool(const T, const T)>>;\n\nusing mint = modint998244353;\n\nmint op(mint a, mint b) {\n    return a + b;\n}\n\nmint e() {\n    return (mint)0;\n}\n\n\nint main() {\n    //CFS;\n    int n, k;\n    cin >> n >> k;\n    segtree<mint, op, e> seg1(n), seg2(n);\n    vi p(n);\n    rep(i, n) {\n        cin >> p[i];\n        p[i]--;\n    }\n    mint ans = 0;\n    mint w = k;\n    w /= k - 1;\n    mint geta = 1;\n    rep(i, n) {\n        if (i >= k) geta *= w;\n        mint l = seg2.prod(0, p[i]) / geta;\n        mint r = seg2.prod(p[i], n) / geta;\n        ans += l - r + seg1.prod(p[i], n);\n        seg1.set(p[i], 1);\n        seg2.set(p[i], geta / 2);\n    }\n    cout << ans.val() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include<bits/extc++.h>\n#define int long long\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define rep(i,n) for (int i=0;i<(int)(n);++i)\n#define rep1(i,n) for (int i=1;i<=(int)(n);++i)\n#define range(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define F first\n#define S second\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> VL;\n\n\nll power(ll u,ll v,ll mod){\n    ll ret=1,t=u%mod;\n    while (v){\n        if (v&1) ret=t*ret%mod;\n        t=t*t%mod, v>>=1;\n    }\n    return ret%mod;\n}\n \n/*\n计算gcd(a,b)并找寻ax+by=gcd(a,b)的一组解\nret=exgcd(a,b,x,y); \n*/\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if (b){\n        ll d=exgcd(b,a%b,y,x);\n        return y-=a/b*x, d;\n    }\n    return x=1,y=0,a;\n}\n \n/*\n计算x=a(mod m), x=b(mod n)的一组解，若无解返回-1\nret=crt(a,m,b,n);\n*/\nll crt(ll a,ll m,ll b,ll n){\n    if (n>m) swap(a,b), swap(n,m);\n    ll x,y,g=exgcd(m,n,x,y);\n    if ((b-a)%g) return -1;\n    x=(b-a)%n*x%n/g*m+a;\n    return x<0?x+m*n/g:x;\n}\n \n/*\n生成<=n的质数\ngen_prime<5000>(ret);\n*/\n \nvoid gen_prime(int n,vi &ret){\n    vector<bool> p;\n    p.resize(n+1,1);\n    p[0]=p[1]=0;\n    for (int i=4;i<=n;i+=2) p[i]=0;\n    for (int i=3;i*i<=n;i+=2){\n        if (p[i]){\n            for (int j=i*i;j<=n;j+=2*i){\n                p[j]=0;\n            }\n        }\n    }\n    for (int i=2;i<=n;++i){\n        if (p[i]) ret.pb(i);\n    }\n}\n \n/*\n生成<=n的phi\ngen_phi<5000>(ret);\n*/\nvoid gen_phi(int n,vi &phi){\n    phi.resize(n+1);\n    for (int i=0;i<=n;++i) phi[i]=i&1?i:i/2;\n    for (int i=3;i<=n;i+=2){\n        if (phi[i]==i){\n            for (int j=i;j<=n;j+=i) phi[j]-=phi[j]/i;\n        }\n    }\n}\n \n/*\n支持更高的快速幂操作\nexpower.mod_pow(a,b,mod);\n*/\n \nstruct expower{\n    ull mod_mul(ull a,ull b,ull M) {\n        ll ret=a*b-M*ull(ld(a)* ld(b)/ld(M));\n        return ret+M*(ret<0)-M*(ret>=(ll)M);\n    }\n    ull mod_pow(ull b,ull e,ull mod) {\n        ull ans=1;\n        for (; e; b=mod_mul(b,b,mod), e/=2)\n            if (e&1) ans=mod_mul(ans,b,mod);\n        return ans%mod;\n    }\n}expower;\n \n/*\nMiller-Rubin素数判别\nis_prime(n);\n*/\nbool is_prime(ull n){ \n    if (n<2||n%6%4!=1) return n-2<2;\n    ull A[]={2,325,9375,28178,450775,9780504,1795265022},\n    s=__builtin_ctzll(n-1), d = n >> s;\n    for (auto a:A){\n        ull p=expower.mod_pow(a,d,n),i=s;\n        while (p!=1&&p!=n-1&&a%n&&i--)\n            p=expower.mod_mul(p,p,n);\n        if (p!=n-1&&i!=s) return 0;\n    }\n    return 1;\n}\n \n/*\n素因数分解\nret=factorization(n);\n*/\null pollard(ull n){\n    auto f=[n](ull x){return (expower.mod_mul(x,x,n)+1)%n;};\n    if (!(n&1)) return 2;\n    for (ull i=2;;i++){\n        ull x=i,y=f(x),p;\n        while ((p=__gcd(n+y-x,n))==1)\n            x=f(x),y=f(f(y));\n        if (p!=n) return p;\n    }\n}\n \nvector<ull> factorization(ull n){\n    if (n==1) return {};\n    if (is_prime(n)) return {n};\n    ull x=pollard(n);\n    auto l=factorization(x),r=factorization(n/x);\n    l.insert(l.end(),range(r));\n    return l;\n}\n \nstruct DSU{\n    //insert info.\n    vector<int> p;\n    DSU(int n){\n        p.resize(n+1);\n        for (int i=1;i<=n;++i) p[i]=i;\n    }\n    int find(int u){\n        if (p[u]==u) return u;\n        return p[u]=find(find(p[u]));\n    } \n    bool unite(int u,int v){\n        int pu=find(u), pv=find(v);\n        if (pu!=pv){\n            p[pu]=pv;\n        }\n        return pu!=pv;\n    }\n};\n \n/* (u,v,w) */\ntemplate<class T> vector<tuple<int,int,T> > MST(int n,vector<tuple<int,int,T> >g){\n    vector<tuple<int,int,T> > ret;\n    ret.clear();\n    DSU dsu(n);\n    auto cmp=[&](tuple<int,int,T> x,tuple<int,int,T> y){\n        int ux,uy,vx,vy;\n        T wx,wy;\n        tie(ux,vx,wx)=x, tie(uy,vy,wy)=y;\n        return wx<wy;\n    };\n    sort(range(g),cmp);\n    for (auto c:g){\n        int u,v;\n        T w;\n        tie(u,v,w)=c;\n        if(dsu.unite(u,v)) ret.push_back(c);\n    }\n    return ret;\n}\n \ntemplate<int n,class T>\nstruct SegmentTree{\n    typedef struct{\n        T lz,mx,mn,sum;\n    }Node;\n    vector<Node> tree;\n    SegmentTree(){\n        tree.resize((n+7)<<2);\n    }  \n    void pushup(int num){\n        tree[num].mx=max(tree[num<<1].mx,tree[num<<1|1].mx);\n        tree[num].mn=min(tree[num<<1].mn,tree[num<<1|1].mn);\n        tree[num].sum=tree[num<<1].sum+tree[num<<1|1].sum;\n    }\n    void pushdown(int num,int l,int r,int md){\n        if (tree[num].lz){\n            tree[num<<1].mx+=tree[num].lz;\n            tree[num<<1|1].mx+=tree[num].lz;\n            tree[num<<1].mn+=tree[num].lz;\n            tree[num<<1|1].mn+=tree[num].lz;\n            tree[num<<1].sum+=tree[num].lz*(md-l+1);\n            tree[num<<1|1].sum+=tree[num].lz*(r-md);\n            tree[num<<1].lz+=tree[num].lz;\n            tree[num<<1|1].lz+=tree[num].lz;\n            tree[num].lz=0;\n        }\n    }\n    void update1(int num,int l,int r,int L,int R,T val){\n        if (L<=l&&r<=R){\n            tree[num].mx+=val;\n            tree[num].mn+=val;\n            tree[num].sum+=val*(r-l+1);\n            tree[num].lz+=val;\n            return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=L) update1(num<<1,l,md,L,R,val);\n        if (md<R) update1(num<<1|1,md+1,r,L,R,val);\n        pushup(num);\n    }\n    tuple<T,T,T> query1(int num,int l,int r,int L,int R){\n        if (L<=l&&r<=R){\n            return {tree[num].mn,tree[num].mx,tree[num].sum};\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=R){\n            return query1(num<<1,l,md,L,R);\n        }\n        else{\n            if (md<L){\n                return query1(num<<1|1,md+1,r,L,R);\n            }\n            else{\n                tuple<T,T,T> ret1=query1(num<<1,l,md,L,R), ret2=query1(num<<1|1,md+1,r,L,R);\n                T a,b,c,d,e,f;\n                tie(a,b,c)=ret1, tie(d,e,f)=ret2;\n                return {min(a,d),max(b,e),c+f};\n            }\n        } \n    }\n    void update(int L,int R,int w){\n        update1(1,1,n,L,R,w);\n    }\n    tuple<T,T,T> query(int L,int R){\n        return query1(1,1,n,L,R);\n    }\n    void debug1(int num,int l,int r){\n        if (l==r){\n            cout<<tree[num].mn<<\" \"; return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        debug1(num<<1,l,md);\n         debug1(num<<1|1,md+1,r);        \n    }\n    void debug(){\n        debug1(1,1,n);\n        cout<<endl;\n    }\n};\n \nstruct XORBasis{\n    int n;\n    vector<ull> p;\n    vector<ull> ans;\n    XORBasis(int k):n(k){\n        p.resize(k+1);\n    }\n    void rebuilt(){\n        ans.clear();\n        for (int i=0;i<=n;++i){\n            if (p[i]) ans.push_back(p[i]);\n        }\n    }\n    void insert(ull u){\n        for (int i=n;i>=0;--i){\n            if (u&(1ull<<i)){\n                if (p[i]) u^=p[i];\n                else{\n                    p[i]=u;\n                    for (int j=i-1;j>=0;--j){\n                        if (p[i]&(1ull<<j)) p[i]^=p[j];\n                    }\n                    for (int j=i+1;j<=n;++j){\n                        if (p[j]&(1ull<<i)) p[j]^=p[i];\n                    }\n                    break;\n                }\n            }\n        }\n        rebuilt();\n    }\n    bool check(ull u){\n        for (int i=n;i>-1;--i){\n            if (u&(1ull<<i)) u^=p[i];\n        }\n        return (u==0);\n    }\n    ull kth(ull t){ // the k-th smallest, excluding 0.\n        if (t>=(1ull<<sz(ans))) return -1;\n        ull ret=0;\n        for (int i=0;i<sz(ans);++i){\n            if (t&(1ull<<i)) ret^=ans[i];\n        }\n        return ret;\n    }\n    ull total(){\n        return (1ull<<sz(ans));\n    }\n};\n \n \nvi pi(const string& s) {\n\tvi p(sz(s));\n\tfor (int i=1;i<=sz(s);++i) {\n\t\tint g = p[i-1];\n\t\twhile (g && s[i] != s[g]) g = p[g-1];\n\t\tp[i] = g + (s[i] == s[g]);\n\t}\n\treturn p;\n}\n \nvi match(const string& s, const string& pat) {\n\tvi p = pi(pat + '\\0' + s), res;\n\tfor(int i=sz(p)-sz(s);i<=sz(p);++i)\n\t\tif (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));\n\treturn res;\n}\n \n \nstruct AhoCorasick {\n\tenum {alpha = 26, first = 'a'};\n\tstruct Node {\n\t\t// (nmatches is optional)\n\t\tint back, next[alpha], start = -1, end = -1;\n        ll nmatches = 0;\n\t\tNode(int v) { memset(next, v, sizeof(next)); }\n\t};\n\tvector<Node> N;\n\tvector<int> backp;\n\tvoid insert(string& s, int j,ll val) {\n\t\tassert(!s.empty());\n\t\tint n = 0;\n\t\tfor(auto c:s) {\n\t\t\tint& m = N[n].next[c - first];\n\t\t\tif (m == -1) { n = m = sz(N); N.emplace_back(-1); }\n\t\t\telse n = m;\n\t\t}\n\t\tif (N[n].end == -1) N[n].start = j;\n\t\tbackp.push_back(N[n].end);\n\t\tN[n].end = j;\n\t\tN[n].nmatches+=val;\n\t}\n\tAhoCorasick(vector<string>& pat,vi val) {\n\t\tN.emplace_back(-1);\n\t\tfor (int i=0;i<sz(pat);++i) insert(pat[i], i, val[i]);\n\t\tN[0].back = sz(N);\n\t\tN.emplace_back(0);\n \n\t\tqueue<int> q;\n\t\tfor (q.push(0); !q.empty(); q.pop()) {\n\t\t\tint n = q.front(), prev = N[n].back;\n\t\t\tfor (int i=0;i<alpha;++i) {\n\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];\n\t\t\t\tif (ed == -1) ed = y;\n\t\t\t\telse {\n\t\t\t\t\tN[ed].back = y;\n\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])\n\t\t\t\t\t\t= N[y].end;\n\t\t\t\t\tN[ed].nmatches += N[y].nmatches;\n\t\t\t\t\tq.push(ed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvi find(string& word,ll& ans) {\n\t\tint n = 0;\n\t\tvi res;\n\t\tfor(auto c:word) {\n\t\t\tn = N[n].next[c - first];\n\t\t\tres.push_back(N[n].end);\n\t\t\tans += N[n].nmatches;\n\t\t}\n\t\treturn res;\n\t}\n\tvector<vi> findAll(vector<string>& pat, string word) {\n\t\tll ans=0;\n        vi r = find(word,ans);\n\t\tvector<vi> res(sz(word));\n\t\tfor (int i=0;i<sz(word);++i) {\n\t\t\tint ind = r[i];\n\t\t\twhile (ind != -1) {\n\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);\n\t\t\t\tind = backp[ind];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n \nstruct HLD{\n    int n,cnt=0;\n    vector<vi> G;\n    vi par,dep,siz,son,top,dfn,rk; \n    //父亲节点，深度，子树大小，重子节点，重链头部，dfs序，dfs序对应的节点编号\n    HLD(vector<vi> g,int root=1):n(sz(g)),G(g),par(n+7),dep(n+7),siz(n+7,1),son(n+7,-1),top(n+7),dfn(n+7),rk(n+7){\n        dep[0]=-1, dfs1(root,0), dfs2(root,0,root);\n    }\n    void dfs1(int u,int p){\n        for (auto c:G[u]){\n            if (c==p) continue;\n            dep[c]=dep[u]+1, par[c]=u;\n            dfs1(c,u);\n            siz[u]+=siz[c];\n            if (son[u]==-1||siz[son[u]]<siz[c]) son[u]=c;\n        }\n    }\n    void dfs2(int u,int p,int tp){\n        top[u]=tp;\n        dfn[u]=++cnt;\n        rk[cnt]=u;\n        if (son[u]==-1) return;\n        dfs2(son[u],u,tp);\n        for (auto c:G[u]){\n            if (c==p||c==son[u]) continue;\n            dfs2(c,u,c);\n        }\n    }\n    int lca(int u,int v){\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                u=par[top[u]];\n            }\n            else{\n                v=par[top[v]];\n            }\n        }\n        return dep[u]>dep[v]?v:u;\n    }\n    vector<pii> find_seg(int u,int v){\n        vector<pii> ft,bk,res;\n        ft.clear(), bk.clear(), res.clear();\n//        cout<<top[u]<<\" \"<<top[v]<<endl;\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                ft.pb({u,top[u]});\n                u=par[top[u]];\n            }\n            else{\n                bk.pb({top[v],v});\n                v=par[top[v]];\n            }\n        }\n        ft.pb({u,v});\n        for (int i=0;i<sz(ft);++i) res.pb(ft[i]);\n        for (int i=sz(bk);i>0;--i) res.pb(bk[i-1]);\n        return res;\n    }\n};\n \nstruct BIT{\n    vi C; int n;\n    BIT(int n):n(n){C.resize(n+7,0);}\n    void update(int u,int w){\n        for (;u<=n;u+=u&(-u)) C[u]+=w;\n    }\n    int query(int u){\n        int res=0;\n        for (;u>0;u-=u&(-u)) res+=C[u];\n        return res; \n    }\n};\n\nvi topoSort(const vector<vi>& gr) {\n\tvi indeg(sz(gr)), ret;\n\tfor (auto& li : gr) for (int x : li) indeg[x]++;\n\tqueue<int> q; // use priority queue for lexic. smallest ans.\n\trep(i,sz(gr)) if (indeg[i] == 0) q.push(-i);\n\twhile (!q.empty()) {\n\t\tint i = -q.front(); // top() for priority queue\n\t\tret.push_back(i);\n\t\tq.pop();\n\t\tfor (int x : gr[i])\n\t\t\tif (--indeg[x] == 0) q.push(-x);\n\t}\n\treturn ret;\n}\n\nvi path;\nnamespace Eulerian {\n    const int N = 3, M = 3;\n    int t, n, m, tot, cc, hd[N], nxt[M], to[M], bh[M], vis[M], in[N], out[N], ans[M];\n    void add(int x, int y, int id) {\n        nxt[++tot] = hd[x];\n        hd[x] = tot;\n        to[tot] = y;\n        bh[tot] = id;\n        in[y]++;\n        out[x]++;\n    }\n    void dfs(int x) {\n        for (int i = hd[x]; i; i = hd[x]) {\n            while (i && vis[abs(bh[i])]) i = nxt[i];\n            hd[x] = i;\n            if (!i) break;\n            vis[abs(bh[i])] = 1;\n            dfs(to[i]), ans[++cc] = bh[i];\n        }\n    }\n \n    void init() {\n        memset(hd, 0, sizeof(hd));\n        memset(nxt, 0, sizeof(nxt));\n        memset(to, 0, sizeof(to));\n        memset(bh, 0, sizeof(bh));\n        memset(vis, 0, sizeof(vis));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n        memset(ans, 0, sizeof(ans));\n        t = 1;\n        n = 0;\n        m = 0;\n        tot = 0;\n        cc = 0;\n    }\n    bool solve() {\n        for (int i = 1; i <= n; i++)\n            if ((t == 1 && in[i] & 1)) {\n                return false;\n            }\n        dfs(to[1]);\n        if (cc < m) return false;\n        else {\n            path.clear();\n            for (int i = cc; i >= 1; i--) path.push_back(ans[i]);\n            return true;\n        }\n    }\n} // namespace Eulerian\n\nnamespace FWT{\n    //mod=-1 (no mod)\n    const int mod=-1;\n\n    inline int modadd(int a,int b){\n        a+=b;\n        if (mod==-1) return a;\n        a%=mod, a+=mod, a%=mod;\n        return a;\n    }\n\n    vi OR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j]=modadd(b[j],b[j^(1<<i)]*mode); \n            }\n        }\n        return b;\n    }\n    vi AND(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]*mode);\n            }\n        }\n        return b;\n    }\n    vi XOR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1){\n                    b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]);\n                    b[j]=modadd(b[j^(1<<i)],-2*b[j]);\n                    if (mode<0) {\n                        if (mod>0) b[j]=b[j]*power(2,mod-2,mod)%mod, b[j^(1<<i)]=b[j^(1<<i)]*power(2,mod-2,mod)%mod;\n                        else b[j]/=2, b[j^(1<<i)]/=2;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n}\n\nconst int maxn=200007;\nconst int mod=998244353;\n\nint inv(int u){\n    return power(u,mod-2,mod);\n}\nint mult(int u,int v){\n    return u*v%mod;\n}\nint n,k;\nint a[maxn],p[maxn],q[maxn];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin>>n>>k;\n    rep1(i,n) cin>>a[i],p[i]=i;\n    sort(p+1,p+n+1,[&](int u,int v){return a[u]<a[v];});\n    rep1(i,n) q[p[i]]=1;\n    BIT C(n),C0(n);\n    int ans=0,ans0=0;\n    rep1(i,n){\n        C.update(a[i],power(1+inv(k-1),max(0ll,i-k),mod));\n        C0.update(a[i],1);\n        int r=C.query(n)-C.query(a[i]);\n        ans=(ans+mult(r,power(1-inv(k)+mod,max(0ll,i-k),mod)))%mod;\n //       cout<<ans<<endl;\n        ans0=(ans0+C0.query(n)-C0.query(a[i]))%mod;\n    }\n    ans=(ans0-ans+mod)%mod;\n    int tmp=0;\n    tmp=k*(k-1)/2;\n    tmp%=mod;\n    for (int i=1;i<=n-k;++i){\n        tmp=(tmp+mult(k,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    for (int i=1;i<n-k;++i){\n        int w=n-k-i;\n        tmp=(tmp+mult(w,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    tmp=mult(tmp,inv(2));\n    cout<<((ans+tmp)%mod+mod)%mod;\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\nint N, K;\nmod_int inv_K, H;\nvector<mod_int> H_pow;\n\nstruct segment_change {\n    mod_int h_add;\n\n    segment_change(mod_int _h_add = 0) : h_add(_h_add) {}\n\n    void reset() {\n        h_add = 0;\n    }\n\n    bool has_change() const {\n        return h_add != 0;\n    }\n\n    // Return the combined result of applying this segment change followed by `other`.\n    segment_change combine(const segment_change &other) const {\n        return segment_change(h_add + other.h_add);\n    }\n};\n\nstruct segment {\n    mod_int sum, h_sum;\n    int length = 0;\n\n    segment(mod_int _sum = 0, mod_int _h_sum = 0, int _length = 0) : sum(_sum), h_sum(_h_sum), length(_length) {}\n\n    void apply(int _length, const segment_change &change) {\n        // dbg(length, _length);\n        assert(length <= _length);\n\n        if (change.h_add != 0) {\n            sum += change.h_add * (1 - H_pow[length]) / (1 - H);\n            h_sum += change.h_add * (1 - H_pow[2 * length]) / (1 - H * H);\n        }\n    }\n\n    void join(const segment &other) {\n        sum += other.sum;\n        h_sum += H_pow[length] * other.h_sum;\n        length += other.length;\n    }\n\n    void join(const segment &a, const segment &b) {\n        *this = a;\n        join(b);\n    }\n};\n\npair<int, int> right_half[32];\n\nstruct seg_tree {\n    int tree_n = 0;\n    vector<segment> tree;\n    vector<segment_change> changes;\n\n    seg_tree(int n = -1) {\n        if (n >= 0)\n            init(n);\n    }\n\n    void init(int n) {\n        tree_n = 1;\n\n        while (tree_n < n)\n            tree_n *= 2;\n\n        tree.assign(2 * tree_n, segment());\n        changes.assign(tree_n, segment_change());\n    }\n\n    // Builds our tree from an array in O(n).\n    void build(const vector<segment> &initial) {\n        int n = int(initial.size());\n        init(n);\n        assert(n <= tree_n);\n\n        for (int i = 0; i < n; i++)\n            tree[tree_n + i] = initial[i];\n\n        for (int position = tree_n - 1; position > 0; position--)\n            tree[position].join(tree[2 * position], tree[2 * position + 1]);\n    }\n\n    void apply_and_combine(int position, int length, const segment_change &change) {\n        tree[position].apply(length, change);\n        if (position < tree_n) changes[position] = changes[position].combine(change);\n    }\n\n    void push_down(int position, int length) {\n        if (changes[position].has_change()) {\n            apply_and_combine(2 * position, length / 2, changes[position]);\n            changes[position].h_add *= H_pow[length / 2];\n            apply_and_combine(2 * position + 1, length / 2, changes[position]);\n            changes[position].reset();\n        }\n    }\n\n    // Calls push_down for all necessary nodes in order to query the range [a, b).\n    void push_all(int a, int b) {\n        assert(0 <= a && a < b && b <= tree_n);\n        a += tree_n;\n        b += tree_n - 1;\n\n        for (int up = 31 - __builtin_clz(tree_n); up > 0; up--) {\n            int x = a >> up, y = b >> up;\n            push_down(x, 1 << up);\n            if (x != y) push_down(y, 1 << up);\n        }\n    }\n\n    void join_and_apply(int position, int length) {\n        tree[position].join(tree[2 * position], tree[2 * position + 1]);\n        tree[position].apply(length, changes[position]);\n    }\n\n    // Calls join for all necessary nodes after updating the range [a, b).\n    void join_all(int a, int b) {\n        assert(0 <= a && a < b && b <= tree_n);\n        a += tree_n;\n        b += tree_n - 1;\n        int length = 1;\n\n        while (a > 1) {\n            a /= 2;\n            b /= 2;\n            length *= 2;\n            join_and_apply(a, length);\n            if (a != b) join_and_apply(b, length);\n        }\n    }\n\n    template<typename T_range_op>\n    void process_range(int a, int b, bool needs_join, T_range_op &&range_op) {\n        if (a == b) return;\n        push_all(a, b);\n        int original_a = a, original_b = b;\n        int length = 1, r_size = 0;\n\n        for (a += tree_n, b += tree_n; a < b; a /= 2, b /= 2, length *= 2) {\n            if (a & 1)\n                range_op(a++, length);\n\n            if (b & 1)\n                right_half[r_size++] = {--b, length};\n        }\n\n        for (int i = r_size - 1; i >= 0; i--)\n            range_op(right_half[i].first, right_half[i].second);\n\n        if (needs_join)\n            join_all(original_a, original_b);\n    }\n\n    segment query(int a, int b) {\n        assert(0 <= a && a <= b && b <= tree_n);\n        segment answer;\n\n        process_range(a, b, false, [&](int position, int) {\n            answer.join(tree[position]);\n        });\n\n        return answer;\n    }\n\n    void update(int a, int b, const segment_change &change) {\n        assert(0 <= a && a <= b && b <= tree_n);\n\n        process_range(a, b, true, [&](int position, int length) {\n            int start = length * (position - (1 << (31 - __builtin_clz(position))));\n            apply_and_combine(position, length, segment_change(change.h_add * H_pow[start - a]));\n        });\n    }\n\n    vector<segment> to_array() {\n        for (int i = 1; i < tree_n; i++)\n            push_down(i, tree_n >> (31 - __builtin_clz(i)));\n\n        vector<segment> segs(tree_n);\n\n        for (int i = 0; i < tree_n; i++)\n            segs[i] = tree[tree_n + i];\n\n        return segs;\n    }\n};\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> N >> K;\n    inv_K = mod_int(K).inv();\n    H = 1 - inv_K;\n    H_pow.assign(10 * N + 1, 1);\n\n    for (int i = 1; i <= 10 * N; i++)\n        H_pow[i] = H * H_pow[i - 1];\n\n    vector<int> P(N);\n    vector<int> location(N + 1, -1);\n\n    for (int i = 0; i < N; i++) {\n        cin >> P[i];\n        location[P[i]] = i;\n    }\n\n    seg_tree tree(N - K);\n    tree.build(vector<segment>(N - K, segment(0, 0, 1)));\n    mod_int last_K = 0;\n\n    auto add = [&](int start) {\n        start -= K - 1;\n        start = max(start, 0);\n        assert(0 <= start && start <= N - K);\n        tree.update(start, N - K, segment_change(inv_K));\n        last_K += inv_K * H_pow[N - K - start];\n    };\n\n    auto query_sum = [&](int start) {\n        start -= K - 1;\n        start = max(start, 0);\n        assert(0 <= start && start <= N - K);\n        mod_int sum = tree.query(0, start).sum;\n        sum += H * tree.query(start, N - K).h_sum;\n        sum += last_K * H_pow[N - K - start + 1] / 2 * K;\n        return sum;\n    };\n\n    auto query_here = [&](int start) {\n        start -= K - 1;\n        start = max(start, 0);\n        assert(0 <= start && start <= N - K);\n        mod_int sum = inv_K * tree.query(start, N - K).h_sum;\n        sum += last_K * K * H_pow[N - K - start] * inv_K;\n        return sum;\n    };\n\n    mod_int answer = 0;\n\n    for (int x = N; x > 0; x--) {\n        int start = location[x];\n        // dbg(start, query_sum(start), query_here(start) / 2);\n        answer += query_sum(start);\n        answer += query_here(start) / 2;\n        add(start);\n\n        // auto arr = tree.to_array();\n        // for (int i = 0; i < N - K; i++)\n        //     cerr << arr[i].sum << ' ';\n        // cerr << last_K << endl;\n    }\n\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\n// modint\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() const { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b, swap(a, b);\n            u -= t * v, swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        is >> x.val;\n        x.val %= MOD;\n        if (x.val < 0) x.val += MOD;\n        return is;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nnamespace NTT {\n    long long modpow(long long a, long long n, int mod) {\n        long long res = 1;\n        while (n > 0) {\n            if (n & 1) res = res * a % mod;\n            a = a * a % mod;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    long long modinv(long long a, int mod) {\n        long long b = mod, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b, swap(a, b);\n            u -= t * v, swap(u, v);\n        }\n        u %= mod;\n        if (u < 0) u += mod;\n        return u;\n    }\n\n    int calc_primitive_root(int mod) {\n        if (mod == 2) return 1;\n        if (mod == 167772161) return 3;\n        if (mod == 469762049) return 3;\n        if (mod == 754974721) return 11;\n        if (mod == 998244353) return 3;\n        int divs[20] = {};\n        divs[0] = 2;\n        int cnt = 1;\n        long long x = (mod - 1) / 2;\n        while (x % 2 == 0) x /= 2;\n        for (long long i = 3; i * i <= x; i += 2) {\n            if (x % i == 0) {\n                divs[cnt++] = i;\n                while (x % i == 0) x /= i;\n            }\n        }\n        if (x > 1) divs[cnt++] = x;\n        for (int g = 2;; g++) {\n            bool ok = true;\n            for (int i = 0; i < cnt; i++) {\n                if (modpow(g, (mod - 1) / divs[i], mod) == 1) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) return g;\n        }\n    }\n\n    int get_fft_size(int N, int M) {\n        int size_a = 1, size_b = 1;\n        while (size_a < N) size_a <<= 1;\n        while (size_b < M) size_b <<= 1;\n        return max(size_a, size_b) << 1;\n    }\n\n    // number-theoretic transform\n    template<class mint> void trans(vector<mint> &v, bool inv = false) {\n        if (v.empty()) return;\n        int N = (int)v.size();\n        int MOD = v[0].getmod();\n        int PR = calc_primitive_root(MOD);\n        static bool first = true;\n        static vector<long long> vbw(30), vibw(30);\n        if (first) {\n            first = false;\n            for (int k = 0; k < 30; ++k) {\n                vbw[k] = modpow(PR, (MOD - 1) >> (k + 1), MOD);\n                vibw[k] = modinv(vbw[k], MOD);\n            }\n        }\n        for (int i = 0, j = 1; j < N - 1; j++) {\n            for (int k = N >> 1; k > (i ^= k); k >>= 1);\n            if (i > j) swap(v[i], v[j]);\n        }\n        for (int k = 0, t = 2; t <= N; ++k, t <<= 1) {\n            long long bw = vbw[k];\n            if (inv) bw = vibw[k];\n            for (int i = 0; i < N; i += t) {\n                mint w = 1;\n                for (int j = 0; j < t/2; ++j) {\n                    int j1 = i + j, j2 = i + j + t/2;\n                    mint c1 = v[j1], c2 = v[j2] * w;\n                    v[j1] = c1 + c2;\n                    v[j2] = c1 - c2;\n                    w *= bw;\n                }\n            }\n        }\n        if (inv) {\n            long long invN = modinv(N, MOD);\n            for (int i = 0; i < N; ++i) v[i] = v[i] * invN;\n        }\n    }\n\n    // for garner\n    static constexpr int MOD0 = 754974721;\n    static constexpr int MOD1 = 167772161;\n    static constexpr int MOD2 = 469762049;\n    using mint0 = Fp<MOD0>;\n    using mint1 = Fp<MOD1>;\n    using mint2 = Fp<MOD2>;\n    static const mint1 imod0 = 95869806; // modinv(MOD0, MOD1);\n    static const mint2 imod1 = 104391568; // modinv(MOD1, MOD2);\n    static const mint2 imod01 = 187290749; // imod1 / MOD0;\n\n    // small case (T = mint, long long)\n    template<class T> vector<T> naive_mul \n    (const vector<T> &A, const vector<T> &B) {\n        if (A.empty() || B.empty()) return {};\n        int N = (int)A.size(), M = (int)B.size();\n        vector<T> res(N + M - 1);\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < M; ++j)\n                res[i + j] += A[i] * B[j];\n        return res;\n    }\n\n    // mint\n    template<class mint> vector<mint> mul\n    (const vector<mint> &A, const vector<mint> &B) {\n        if (A.empty() || B.empty()) return {};\n        int N = (int)A.size(), M = (int)B.size();\n        if (min(N, M) < 30) return naive_mul(A, B);\n        int MOD = A[0].getmod();\n        int size_fft = get_fft_size(N, M);\n        if (MOD == 998244353) {\n            vector<mint> a(size_fft), b(size_fft), c(size_fft);\n            for (int i = 0; i < N; ++i) a[i] = A[i];\n            for (int i = 0; i < M; ++i) b[i] = B[i];\n            trans(a), trans(b);\n            vector<mint> res(size_fft);\n            for (int i = 0; i < size_fft; ++i) res[i] = a[i] * b[i];\n            trans(res, true);\n            res.resize(N + M - 1);\n            return res;\n        }\n        vector<mint0> a0(size_fft, 0), b0(size_fft, 0), c0(size_fft, 0);\n        vector<mint1> a1(size_fft, 0), b1(size_fft, 0), c1(size_fft, 0);\n        vector<mint2> a2(size_fft, 0), b2(size_fft, 0), c2(size_fft, 0);\n        for (int i = 0; i < N; ++i)\n            a0[i] = A[i].val, a1[i] = A[i].val, a2[i] = A[i].val;\n        for (int i = 0; i < M; ++i)\n            b0[i] = B[i].val, b1[i] = B[i].val, b2[i] = B[i].val;\n        trans(a0), trans(a1), trans(a2), trans(b0), trans(b1), trans(b2);\n        for (int i = 0; i < size_fft; ++i) {\n            c0[i] = a0[i] * b0[i];\n            c1[i] = a1[i] * b1[i];\n            c2[i] = a2[i] * b2[i];\n        }\n        trans(c0, true), trans(c1, true), trans(c2, true);\n        static const mint mod0 = MOD0, mod01 = mod0 * MOD1;\n        vector<mint> res(N + M - 1);\n        for (int i = 0; i < N + M - 1; ++i) {\n            int y0 = c0[i].val;\n            int y1 = (imod0 * (c1[i] - y0)).val;\n            int y2 = (imod01 * (c2[i] - y0) - imod1 * y1).val;\n            res[i] = mod01 * y2 + mod0 * y1 + y0;\n        }\n        return res;\n    }\n\n    // long long\n    vector<long long> mul_ll\n    (const vector<long long> &A, const vector<long long> &B) {\n        if (A.empty() || B.empty()) return {};\n        int N = (int)A.size(), M = (int)B.size();\n        if (min(N, M) < 30) return naive_mul(A, B);\n        int size_fft = get_fft_size(N, M);\n        vector<mint0> a0(size_fft, 0), b0(size_fft, 0), c0(size_fft, 0);\n        vector<mint1> a1(size_fft, 0), b1(size_fft, 0), c1(size_fft, 0);\n        vector<mint2> a2(size_fft, 0), b2(size_fft, 0), c2(size_fft, 0);\n        for (int i = 0; i < N; ++i)\n            a0[i] = A[i], a1[i] = A[i], a2[i] = A[i];\n        for (int i = 0; i < M; ++i)\n            b0[i] = B[i], b1[i] = B[i], b2[i] = B[i];\n        trans(a0), trans(a1), trans(a2), trans(b0), trans(b1), trans(b2);\n        for (int i = 0; i < size_fft; ++i) {\n            c0[i] = a0[i] * b0[i];\n            c1[i] = a1[i] * b1[i];\n            c2[i] = a2[i] * b2[i];\n        }\n        trans(c0, true), trans(c1, true), trans(c2, true);\n        static const long long mod0 = MOD0, mod01 = mod0 * MOD1;\n        vector<long long> res(N + M - 1);\n        for (int i = 0; i < N + M - 1; ++i) {\n            int y0 = c0[i].val;\n            int y1 = (imod0 * (c1[i] - y0)).val;\n            int y2 = (imod01 * (c2[i] - y0) - imod1 * y1).val;\n            res[i] = mod01 * y2 + mod0 * y1 + y0;\n        }\n        return res;\n    }\n};\n\ntemplate <class Abel> struct BIT {\n    Abel UNITY_SUM = 0;\n    vector<Abel> dat;\n    \n    // [0, n)\n    BIT(int n, Abel unity = 0) : UNITY_SUM(unity), dat(n, unity) { }\n    void init(int n) {\n        dat.assign(n, UNITY_SUM);\n    }\n    \n    // a is 0-indexed\n    inline void add(int a, Abel x) {\n        for (int i = a; i < (int)dat.size(); i |= i + 1)\n            dat[i] = dat[i] + x;\n    }\n    \n    // [0, a), a is 0-indexed\n    inline Abel sum(int a) {\n        Abel res = UNITY_SUM;\n        for (int i = a - 1; i >= 0; i = (i & (i + 1)) - 1)\n            res = res + dat[i];\n        return res;\n    }\n    \n    // [a, b), a and b are 0-indexed\n    inline Abel sum(int a, int b) {\n        return sum(b) - sum(a);\n    }\n    \n    // debug\n    void print() {\n        for (int i = 0; i < (int)dat.size(); ++i)\n            cout << sum(i, i + 1) << \",\";\n        cout << endl;\n    }\n};\n\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nusing namespace NTT;\n\n\nmint naive(int K, int N, const vector<int> &p) {\n    mint res = 0;\n    mint fac = mint(K-1) / K;\n    mint itwo = mint(1) / 2;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int ni = (i < K ? 0 : i - K + 1);\n            int nj = (j < K ? 0 : j - K + 1);\n            int d = nj - ni;\n            mint tmp = 0;\n            if (p[i] > p[j]) {\n                tmp = mint(1) - itwo * modpow(fac, d);\n            }\n            else {\n                tmp = itwo * modpow(fac, d);\n            }\n            res += tmp;\n\n            //cout << i << \", \" << j << \": \" << d << \", \" << tmp << \"(\" << (p[i] > p[j]) << \")\" << endl;\n        }\n    }\n    return res;\n}\n\n\nmint solve(int K, int N, const vector<int> &p) {\n    mint res = 0;\n    mint fac = mint(K-1) / K;\n    mint itwo = mint(1) / 2;\n    vector<long long> invnum(N, 0), junnum(N, 0);\n\n    for (long long d = 0; d < N; ++d) {\n\n    }\n\n    for (long long d = 0; d < N; ++d) {\n        mint invfac = mint(1) - itwo * modpow(fac, d);\n        mint junfac = itwo * modpow(fac, d);\n        mint tmp = invfac * invnum[d] + junfac * junnum[d];\n        res += tmp;\n    }\n    return res;\n}\n\nint main() {\n    int N, K;\n    while (cin >> N >> K) {\n        vector<int> p(N);\n        for (int i = 0; i < N; ++i) cin >> p[i], --p[i];\n        \n        \n        cout << naive(K, N, p) << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconstexpr int inf=1e9+7;\nconstexpr ll longinf=1LL<<60 ;\nconstexpr ll mod=998244353 ;\n\ntemplate<typename T, typename S>\nstruct LazySegmentTree{\nprivate:\n    int n;\n    vector<T> node;\n    vector<S> lazy;\n    T E0;\n    S E1;\n\n    inline void updatef(S& lazy,S& value){\n        lazy.first = lazy.first * value.first % mod;\n        lazy.second = (value.first * lazy.second + value.second) % mod;\n    }\n    inline void calculatef(T& node,S& lazy,int len){\n        //node += lazy * len; //区間sumはこっち\n        // node += lazy ; //区間maxとか\n        node = (node * lazy.first + lazy.second)%mod;\n    }\n    inline T queryf(T& x,T& y){\n        return (x + y)%mod;\n    }\npublic:\n    LazySegmentTree(int sz,T nodeE,S lazyE ):E0(nodeE), E1(lazyE){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E0);\n        lazy.resize(2*n-1,E1);\n    }\n\n    LazySegmentTree(vector<T>& v,T E0,S E1 ):E0(E0),E1(E1){\n        n=1;\n        int sz=v.size();\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E0);\n        lazy.resize(2*n-1,E1);\n        rep(i,sz)node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; --i){\n            node[i] = queryf(node[2*i+1],node[2*i+2]);\n        }\n    }\n\n    void eval(int k,int l,int r){\n        if(lazy[k]==E1)return ;\n        calculatef(node[k], lazy[k], r-l);\n        if(r-l>1){\n            updatef(lazy[2*k+1], lazy[k]);\n            updatef(lazy[2*k+2], lazy[k]);\n        }\n        lazy[k]=E1;\n    }\n\n    void update(int a, int b, S x,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        eval(k,l,r);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            updatef(lazy[k], x);\n            eval(k,l,r);\n        }\n        else {\n            update(a,b,x,2*k+1,l,(l+r)/2);\n            update(a,b,x,2*k+2,(l+r)/2,r);\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    T query(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        eval(k,l,r);\n        if(r<=a||b<=l)return E0;\n        if(a<=l&&r<=b)return node[k];\n        T xl=query(a,b,2*k+1,l,(l+r)/2);\n        T xr=query(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        x = y;\n        //x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        return x+y;\n        //return x+y;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    mod_build(n+1);\n    vector<int> p(n);\n    rep(i,n)cin>>p[i];\n    rep(i,n)--p[i];\n    LazySegmentTree<ll,pair<ll,ll>> lsg(n, 0,{1,0});\n    SegmentTree<int> sg(n,0);\n    ll ans = 0;\n    ll half = inv[2];\n    ll res = mod + 1 - inv[k];\n    rep(i,n){\n        ans += lsg.query(0, n) * half % mod;\n        ans += sg.get(p[i], n) + mod - lsg.query(p[i], n);\n        lsg.update(p[i],p[i]+1, {0, 1});\n        sg.update(p[i], 1);\n        if(i>=k-1)lsg.update(0,n,{res,0});\n        ans %= mod;\n    }\n    cout << ans % mod <<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nmt19937_64 rnd(228);\nconst int mod = 998244353;\n\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nstruct Fenwick {\n    vector<int> f;\n    int n;\n\n    Fenwick(int _n) {\n        n = _n;\n        f.resize(_n + 1);\n    }\n\n    void upd(int pos, int v) {\n        while (pos <= n) {\n            f[pos] = sum(f[pos], v);\n            pos = (pos | (pos - 1)) + 1;\n        }\n    }\n\n    int get(int r) {\n        int ans = 0;\n        while (r > 0) {\n            ans = sum(ans, f[r]);\n            r &= (r - 1);\n        }\n        return ans;\n    }\n\n    int get(int l, int r) {\n        return sub(get(r), get(l - 1));\n    }\n};\n\nconst int maxN = 2e5 + 10;\nint n, k;\nint invK[maxN];\nint pwK[maxN];\nint p[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> p[i];\n    }\n    int nk = mult(k, pw(k - 1, mod - 2));\n    for (int i = 0; i <= n; i++) {\n        invK[i] = pw(pw(nk, i), mod - 2);\n        pwK[i] = pw(nk, i);\n    }\n    int ans = mult((k - 1), mult(k - 2, pw(4, mod - 2)));\n    Fenwick f_sum(n);\n    Fenwick cnt(n);\n    for (int i = 1; i <= k - 1; i++) {\n        f_sum.upd(p[i], pwK[k]);\n        cnt.upd(p[i], +1);\n    }\n    for (int i = k; i <= n; i++) {\n        int cnt_smaller = f_sum.get(p[i] - 1);\n        ans = sum(ans, mult((mod + 1) / 2, mult(cnt_smaller, invK[i])));\n        int cnt_bigger = f_sum.get(p[i] + 1, n);\n        int tot_bigger = cnt.get(p[i] + 1, n);\n        ans = sum(ans, sub(tot_bigger, mult(invK[i], mult((mod + 1) / 2, cnt_bigger))));\n        f_sum.upd(p[i], pwK[i]);\n        cnt.upd(p[i], +1);\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<atcoder/modint>\n#include<atcoder/fenwicktree>\nusing namespace std;\nusing namespace atcoder;\nusing mint=modint998244353;\nint N,K,p;\nmain()\n{\n\tcin>>N>>K>>p;\n\tfenwick_tree<mint>A(N);\n\tfenwick_tree<int>B(N);\n\tmint ans=0,X=mint(K-1)/K;\n\tfor(int j=1;j<N;j++)\n\t{\n\t\t--p;\n\t\tA.add(p,1/X.pow(max(j,K)-1));\n\t\tB.add(p,1);\n\t\tcin>>p;\n\t\tans+=(A.sum(0,p)-A.sum(p,N))*X.pow(max(j,K-1))/2+B.sum(p,N);\n\t}\n\tcout<<ans.val()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define per(i, b) per2(i, 0, b)\n#define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SZ(x) ((int)(x).size())\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\nusing Mint = modint998244353;\n\nconst int maxv = 1000010;\n\nV<Mint> fact(maxv), ifact(maxv), inv(maxv);\n\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < maxv; ++i) {\n        fact[i] = fact[i - 1] * i;\n    }\n\n    ifact[maxv - 1] = fact[maxv - 1].inv();\n\n    for (int i = maxv - 2; i >= 0; --i) {\n        ifact[i] = ifact[i + 1] * (i + 1);\n    }\n\n    for (int i = 1; i < maxv; ++i) {\n        inv[i] = ifact[i] * fact[i - 1];\n    }\n}\n\nMint comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return Mint(0);\n    return fact[n] * ifact[r] * ifact[n - r];\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    init();\n\n    int N, K;\n    cin >> N >> K;\n    V<int> p(N);\n    rep(i, N) cin >> p[i], --p[i];\n\n    V<Mint> ik(N + 1);\n    ik[0] = 1;\n    rep(i, N) { ik[i + 1] = ik[i] * (1 - inv[K]); }\n\n    Mint ans;\n    /*\n     rep(i, N) {\n         rep(j, i) {\n             int x = p[j], y = p[i];\n             int l = max(0, j - K + 1);\n             int r = max(0, i - K + 1);\n             debug(j, i, l, r);\n             Mint w = ik[r - l];\n             ans += w * inv[2];\n             if (l < r && x > y) ans += 1 - w;\n         }\n     }\n     cout << ans.val() << endl;*/\n\n    ans = Mint(K * ll(K - 1) / 2) * inv[2];\n\n    fenwick_tree<Mint> t(N + 1);\n    fenwick_tree<int> tc(N + 1);\n\n    Mint su;\n\n    rep(i, K) {\n        tc.add(p[i], 1);\n        su += 1 / ik[0];\n        t.add(p[i], 1 / ik[0]);\n    }\n\n    for (int i = K; i < N; ++i) {\n        int x = i - K + 1;\n        int u = tc.sum(p[i], N);\n        ans += u;\n        ans += ik[x] * inv[2] * su;\n        su += 1 / ik[x];\n        tc.add(p[i], 1);\n\n        ans -= ik[x] * t.sum(p[i], N);\n        /*\n                rep(j, i) {\n                    int l = max(0, j - K + 1);\n\n                    if (p[j] > p[i]) {\n                        ans -= ik[x - l];\n                    }\n                }*/\n\n        t.add(p[i], 1 / ik[x]);\n    }\n    cout << ans.val() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 998244353;\n\nint add(int a, int b)\n{\n    a += b;\n    if (a >= MOD)\n    {\n        return a - MOD;\n    }\n    if (a < 0)\n    {\n        return a + MOD;\n    }\n    return a;\n}\n\nint mul(int a, int b)\n{\n    return a * (ll) b % MOD;\n}\n\nint pw(int a, int b)\n{\n    int r = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            r = mul(r, a);\n        }\n        a = mul(a, a);\n        b /= 2;\n    }\n    return r;\n}\n\nint dv(int a, int b)\n{\n    return mul(a, pw(b, MOD - 2));\n}\n\nconst int N = (int) 2e5 + 7;\nint n;\nint k;\nint a[N];\nint enter[N];\nint kek;\nint val[N];\nint inv_val[N];\nint inv2;\nint aib[N];\n\nvoid clr()\n{\n    for (int i = 1; i <= n; i++)\n    {\n        aib[i] = 0;\n    }\n}\n\nvoid op(int i, int x)\n{\n    while (i <= n)\n    {\n        aib[i] = add(aib[i], x);\n        i += i & (-i);\n    }\n}\n\nint get(int i)\n{\n    int sol = 0;\n    while (i)\n    {\n        sol = add(sol, aib[i]);\n        i -= i & (-i);\n    }\n    return sol;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> k;\n    inv2 = dv(1, 2);\n    kek = dv(k - 1, k);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        enter[i] = max(0, i - k);\n        val[i] = pw(kek, enter[i]);\n        inv_val[i] = dv(1, val[i]);\n    }\n    int inversion_count = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        inversion_count = add(inversion_count, i - 1 - get(a[i]));\n        op(a[i], 1);\n    }\n    clr();\n    int invs = 0, tot = 0;\n    for (int i = n; i >= 1; i--)\n    {\n        int x, y;\n        y = get(a[i]);\n        x = add(tot, -y);\n        tot = add(tot, val[i]);\n        op(a[i], val[i]);\n        x = mul(x, inv2);\n        y = mul(y, inv2);\n        x = mul(x, inv_val[i]);\n        y = mul(y, inv_val[i]);\n        invs = add(invs, add(x, -y));\n    }\n    invs = add(invs, inversion_count);\n    cout << invs << \"\\n\";\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define range2(i,a,b) ((a)<=(i) && (i)<=(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<1>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\nvec fact,inv;\nvoid init(int n){\n  fact.assign(n+1,1);\n  inv.assign(n+1,1);\n  REP(i,n) fact[i+1] = fact[i]*(i+1), inv[i+1] /= fact[i+1];\n}\n\nmint cmb(int n, int r){\n  if(n < r || r < 0) return 0;\n  return fact[n]*inv[r]*inv[n-r];\n}\n\ntemplate <typename T>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  int n,n_;\n  F f;\n  T ti;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(F f,T ti):f(f),ti(ti){}\n\n  void init(){\n    n=1;\n    while(n<n_) n<<=1;\n    dat.assign(n<<1,ti);\n  }\n\n  void build(const vector<T> &v){\n    n_=v.size();\n    init();\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n\n  void update(int k,T x){\n    assert(0 <= k && k < n_);\n    dat[k+=n]=x;\n    while(k>>=1)\n      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n  }\n\n  void add(int k,T x){\n    assert(0 <= k && k < n_);\n    dat[k+=n]+=x;\n    while(k>>=1)\n      dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n  }\n\n  T get(int k){\n    assert(0 <= k && k < n_);\n    return dat[n+k];\n  }\n\n  T query(int a,int b){\n    assert(0 <= a && a <= b && b <= n_);\n    T vl=ti, vr=ti;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[l++]);\n      if(r&1) vr=f(dat[--r],vr);\n    }\n    return f(vl,vr);\n  }\n\n  template <class C> int max_right(int l, C check) {\n    assert(0 <= l && l <= n_);\n    if (l == n_) return n_;\n    l += n;\n    T sm = ti;\n    do {\n      while (l % 2 == 0) l >>= 1;\n      if (!check(f(sm, dat[l]))) {\n        while (l < n) {\n          l = (2 * l);\n          if (check(f(sm, dat[l]))) {\n            sm = f(sm, dat[l]);\n            l++;\n          }\n        }\n        return l - n;\n      }\n      sm = f(sm, dat[l]);\n      l++;\n    } while ((l & -l) != l);\n    return n_;\n  }\n\n  template <class C> int min_left(int r, C check) {\n    assert(0 <= r && r <= n_);\n    if (r == 0) return 0;\n    r += n;\n    T sm = ti;\n    do {\n      r--;\n      while (r > 1 && (r % 2)) r >>= 1;\n      if (!check(f(dat[r], sm))) {\n        while (r < n) {\n          r = (2 * r + 1);\n          if (check(f(dat[r], sm))) {\n            sm = f(dat[r], sm);\n            r--;\n          }\n        }\n        return r + 1 - n;\n      }\n      sm = f(dat[r], sm);\n    } while ((r & -r) != r);\n    return 0;\n  }\n};\n\nvoid solve(){\n  int N,K;\n  cin >> N >> K;\n\n  vector<int> a(N);\n  REP(i,N){\n    int x; cin >> x;\n    a[x-1] = i;\n  }\n  \n  auto f = [](mint a, mint b){\n    return a+b;\n  };\n  SegmentTree<mint> seg(f,0),seg2(f,0);\n  seg.build(vec(N,0));\n  seg2.build(vec(N,0));\n\n  mint ans = 0, p = (mint)(K-1)/K;\n  // 非転倒->転倒\n  RREP(i,N){\n    int f = max(0LL,a[i]-K+1);\n    mint tmp = seg.query(a[i],N);\n    mint q = modpow(p,f);\n    ans += tmp/q/2;\n    seg.update(a[i],q);\n  }\n\n  seg.build(vec(N,0));\n  // 転倒->転倒\n  REP(i,N){\n    int f = max(0LL,a[i]-K+1);\n    mint tmp = seg.query(a[i],N), cnt = seg2.query(a[i],N);\n    mint q = modpow(p,f);\n    ans += cnt - tmp/q/2;\n    seg.update(a[i],q);\n    seg2.update(a[i],1);\n  }\n\n  cout << ans << endl;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\ntemplate<class T>bool chmax(T &a, const T &b) {if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a, const T &b) {if(b<a){a=b;return 1;}return 0;}\n\ntemplate<int mod>\nstruct ModInt {\n    long long x;\n \n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    explicit operator int() const {return x;}\n \n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n \n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n \n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n \n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt power(long long p) const{\n        int a = x;\n        if (p==0) return 1;\n        if (p==1) return ModInt(a);\n        if (p%2==1) return (ModInt(a)*ModInt(a)).power(p/2)*ModInt(a);\n        else return (ModInt(a)*ModInt(a)).power(p/2);\n    }\n\n    ModInt power(const ModInt p) const{\n        return ((ModInt)x).power(p.x);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\nusing modint = ModInt<mod>;\n\n\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct SegmentTree {\n  public:\n    SegmentTree() : SegmentTree(0) {}\n    SegmentTree(int n) : SegmentTree(std::vector<S>(n, e())) {}\n    SegmentTree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set_val(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S query(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_query() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {//f(op([l,r)))==trueを満たす最大のr\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {//f(op([l,r)))==trueを満たす最小のl\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\n    int ceil_pow2(int n) {\n        int x = 0;\n        while ((1U << x) < (unsigned int)(n)) x++;\n        return x;\n    }\n};\n\nint n,k;\nint p[200010];\nint f1(int a,int b){return a+b;}\nint e1(){return 0;};\nmodint f2(modint a,modint b){return a+b;}\nmodint e2(){return 0;};\n\nvoid solve(){\n    cin >> n >> k;\n    rep(i,n){\n        cin >> p[i];p[i]--;\n    }\n    SegmentTree<int,f1,e1> seg1(n);\n    rep(i,k) seg1.set_val(p[i],1);\n    modint inv2=((modint)2).inverse();\n    modint Z=(modint)(k-1)/(modint)k;\n    modint invZ=Z.inverse();\n    modint ans=0;\n    Rep(i,k,n){\n        int num=seg1.query(p[i],n);\n        modint powZ=Z.power(i-k+1);\n        ans+=((modint)1-powZ)*num;\n        ans+=powZ*inv2*k;\n    }\n    SegmentTree<int,f1,e1> seg2(n);\n    SegmentTree<modint,f2,e2> seg3(n);\n    Rep(i,k,n){\n        int num=seg2.query(p[i],n);\n        modint D=seg3.query(p[i],n);\n        ans+=num;\n        ans+=-D*Z.power(i);\n        seg2.set_val(p[i],1);\n        seg3.set_val(p[i],invZ.power(i));\n    }\n    ans+=(modint)k*(modint)(k-1)*inv2*inv2;\n    Rep(i,1,n-k){\n        ans+=(modint)(n-k-i)*inv2*Z.power(i);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region kyopro_template\n#define Nyaan_template\n#include <immintrin.h>\n#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x, v) for (auto &x : v)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define mem(a, val) memset(a, val, sizeof(a))\n#define ini(...)   \\\n  int __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inl(...)         \\\n  long long __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define ins(...)      \\\n  string __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inc(...)    \\\n  char __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define in2(s, t)                           \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i]);                         \\\n  }\n#define in3(s, t, u)                        \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i]);                   \\\n  }\n#define in4(s, t, u, v)                     \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i], v[i]);             \\\n  }\n#define rep(i, N) for (long long i = 0; i < (long long)(N); i++)\n#define repr(i, N) for (long long i = (long long)(N)-1; i >= 0; i--)\n#define rep1(i, N) for (long long i = 1; i <= (long long)(N); i++)\n#define repr1(i, N) for (long long i = (N); (long long)(i) > 0; i--)\n#define reg(i, a, b) for (long long i = (a); i < (b); i++)\n#define die(...)      \\\n  do {                \\\n    out(__VA_ARGS__); \\\n    return;           \\\n  } while (0)\nusing namespace std;\nusing ll = long long;\ntemplate <class T>\nusing V = vector<T>;\nusing vi = vector<int>;\nusing vl = vector<long long>;\nusing vvi = vector<vector<int>>;\nusing vd = V<double>;\nusing vs = V<string>;\nusing vvl = vector<vector<long long>>;\nusing P = pair<long long, long long>;\nusing vp = vector<P>;\nusing pii = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nconstexpr int inf = 1001001001;\nconstexpr long long infLL = (1LL << 61) - 1;\ntemplate <typename T, typename U>\ninline bool amin(T &x, U y) {\n  return (y < x) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\ninline bool amax(T &x, U y) {\n  return (x < y) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  int s = (int)v.size();\n  for (int i = 0; i < s; i++) os << (i ? \" \" : \"\") << v[i];\n  return os;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (auto &x : v) is >> x;\n  return is;\n}\nvoid in() {}\ntemplate <typename T, class... U>\nvoid in(T &t, U &... u) {\n  cin >> t;\n  in(u...);\n}\nvoid out() { cout << \"\\n\"; }\ntemplate <typename T, class... U>\nvoid out(const T &t, const U &... u) {\n  cout << t;\n  if (sizeof...(u)) cout << \" \";\n  out(u...);\n}\n\n#ifdef NyaanDebug\n#define trc(...)                   \\\n  do {                             \\\n    cerr << #__VA_ARGS__ << \" = \"; \\\n    dbg_out(__VA_ARGS__);          \\\n  } while (0)\n#define trca(v, N)       \\\n  do {                   \\\n    cerr << #v << \" = \"; \\\n    array_out(v, N);     \\\n  } while (0)\n#define trcc(v)                             \\\n  do {                                      \\\n    cerr << #v << \" = {\";                   \\\n    each(x, v) { cerr << \" \" << x << \",\"; } \\\n    cerr << \"}\" << endl;                    \\\n  } while (0)\ntemplate <typename T>\nvoid _cout(const T &c) {\n  cerr << c;\n}\nvoid _cout(const int &c) {\n  if (c == 1001001001)\n    cerr << \"inf\";\n  else if (c == -1001001001)\n    cerr << \"-inf\";\n  else\n    cerr << c;\n}\nvoid _cout(const unsigned int &c) {\n  if (c == 1001001001)\n    cerr << \"inf\";\n  else\n    cerr << c;\n}\nvoid _cout(const long long &c) {\n  if (c == 1001001001 || c == (1LL << 61) - 1)\n    cerr << \"inf\";\n  else if (c == -1001001001 || c == -((1LL << 61) - 1))\n    cerr << \"-inf\";\n  else\n    cerr << c;\n}\nvoid _cout(const unsigned long long &c) {\n  if (c == 1001001001 || c == (1LL << 61) - 1)\n    cerr << \"inf\";\n  else\n    cerr << c;\n}\ntemplate <typename T, typename U>\nvoid _cout(const pair<T, U> &p) {\n  cerr << \"{ \";\n  _cout(p.fi);\n  cerr << \", \";\n  _cout(p.se);\n  cerr << \" } \";\n}\ntemplate <typename T>\nvoid _cout(const vector<T> &v) {\n  int s = v.size();\n  cerr << \"{ \";\n  for (int i = 0; i < s; i++) {\n    cerr << (i ? \", \" : \"\");\n    _cout(v[i]);\n  }\n  cerr << \" } \";\n}\ntemplate <typename T>\nvoid _cout(const vector<vector<T>> &v) {\n  cerr << \"[ \";\n  for (const auto &x : v) {\n    cerr << endl;\n    _cout(x);\n    cerr << \", \";\n  }\n  cerr << endl << \" ] \";\n}\nvoid dbg_out() { cerr << endl; }\ntemplate <typename T, class... U>\nvoid dbg_out(const T &t, const U &... u) {\n  _cout(t);\n  if (sizeof...(u)) cerr << \", \";\n  dbg_out(u...);\n}\ntemplate <typename T>\nvoid array_out(const T &v, int s) {\n  cerr << \"{ \";\n  for (int i = 0; i < s; i++) {\n    cerr << (i ? \", \" : \"\");\n    _cout(v[i]);\n  }\n  cerr << \" } \" << endl;\n}\ntemplate <typename T>\nvoid array_out(const T &v, int H, int W) {\n  cerr << \"[ \";\n  for (int i = 0; i < H; i++) {\n    cerr << (i ? \", \" : \"\");\n    array_out(v[i], W);\n  }\n  cerr << \" ] \" << endl;\n}\n#else\n#define trc(...)\n#define trca(...)\n#define trcc(...)\n#endif\n\ninline int popcnt(unsigned long long a) { return __builtin_popcountll(a); }\ninline int lsb(unsigned long long a) { return __builtin_ctzll(a); }\ninline int msb(unsigned long long a) { return 63 - __builtin_clzll(a); }\ntemplate <typename T>\ninline int getbit(T a, int i) {\n  return (a >> i) & 1;\n}\ntemplate <typename T>\ninline void setbit(T &a, int i) {\n  a |= (1LL << i);\n}\ntemplate <typename T>\ninline void delbit(T &a, int i) {\n  a &= ~(1LL << i);\n}\ntemplate <typename T>\nint lb(const vector<T> &v, const T &a) {\n  return lower_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nint ub(const vector<T> &v, const T &a) {\n  return upper_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nint btw(T a, T x, T b) {\n  return a <= x && x < b;\n}\ntemplate <typename T, typename U>\nT ceil(T a, U b) {\n  return (a + b - 1) / b;\n}\nconstexpr long long TEN(int n) {\n  long long ret = 1, x = 10;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x;\n    n >>= 1;\n  }\n  return ret;\n}\ntemplate <typename T>\nvector<T> mkrui(const vector<T> &v) {\n  vector<T> ret(v.size() + 1);\n  for (int i = 0; i < int(v.size()); i++) ret[i + 1] = ret[i] + v[i];\n  return ret;\n};\ntemplate <typename T>\nvector<T> mkuni(const vector<T> &v) {\n  vector<T> ret(v);\n  sort(ret.begin(), ret.end());\n  ret.erase(unique(ret.begin(), ret.end()), ret.end());\n  return ret;\n}\ntemplate <typename F>\nvector<int> mkord(int N, F f) {\n  vector<int> ord(N);\n  iota(begin(ord), end(ord), 0);\n  sort(begin(ord), end(ord), f);\n  return ord;\n}\ntemplate <typename T = int>\nvector<T> mkiota(int N) {\n  vector<T> ret(N);\n  iota(begin(ret), end(ret), 0);\n  return ret;\n}\ntemplate <typename T>\nvector<int> mkinv(vector<T> &v) {\n  vector<int> inv(v.size());\n  for (int i = 0; i < (int)v.size(); i++) inv[v[i]] = i;\n  return inv;\n}\n\nstruct IoSetupNya {\n  IoSetupNya() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cerr << fixed << setprecision(7);\n  }\n} iosetupnya;\n\nvoid solve();\nint main() { solve(); }\n\n#pragma endregion\nusing namespace std;\n\ntemplate <uint32_t mod>\nstruct LazyMontgomeryModInt {\n  using mint = LazyMontgomeryModInt;\n  using i32 = int32_t;\n  using u32 = uint32_t;\n  using u64 = uint64_t;\n\n  static constexpr u32 get_r() {\n    u32 ret = mod;\n    for (i32 i = 0; i < 4; ++i) ret *= 2 - mod * ret;\n    return ret;\n  }\n\n  static constexpr u32 r = get_r();\n  static constexpr u32 n2 = -u64(mod) % mod;\n  static_assert(r * mod == 1, \"invalid, r * mod != 1\");\n  static_assert(mod < (1 << 30), \"invalid, mod >= 2 ^ 30\");\n  static_assert((mod & 1) == 1, \"invalid, mod % 2 == 0\");\n\n  u32 a;\n\n  constexpr LazyMontgomeryModInt() : a(0) {}\n  constexpr LazyMontgomeryModInt(const int64_t &b)\n      : a(reduce(u64(b % mod + mod) * n2)){};\n\n  static constexpr u32 reduce(const u64 &b) {\n    return (b + u64(u32(b) * u32(-r)) * mod) >> 32;\n  }\n\n  constexpr mint &operator+=(const mint &b) {\n    if (i32(a += b.a - 2 * mod) < 0) a += 2 * mod;\n    return *this;\n  }\n\n  constexpr mint &operator-=(const mint &b) {\n    if (i32(a -= b.a) < 0) a += 2 * mod;\n    return *this;\n  }\n\n  constexpr mint &operator*=(const mint &b) {\n    a = reduce(u64(a) * b.a);\n    return *this;\n  }\n\n  constexpr mint &operator/=(const mint &b) {\n    *this *= b.inverse();\n    return *this;\n  }\n\n  constexpr mint operator+(const mint &b) const { return mint(*this) += b; }\n  constexpr mint operator-(const mint &b) const { return mint(*this) -= b; }\n  constexpr mint operator*(const mint &b) const { return mint(*this) *= b; }\n  constexpr mint operator/(const mint &b) const { return mint(*this) /= b; }\n  constexpr bool operator==(const mint &b) const {\n    return (a >= mod ? a - mod : a) == (b.a >= mod ? b.a - mod : b.a);\n  }\n  constexpr bool operator!=(const mint &b) const {\n    return (a >= mod ? a - mod : a) != (b.a >= mod ? b.a - mod : b.a);\n  }\n  constexpr mint operator-() const { return mint() - mint(*this); }\n\n  constexpr mint pow(u64 n) const {\n    mint ret(1), mul(*this);\n    while (n > 0) {\n      if (n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  \n  constexpr mint inverse() const { return pow(mod - 2); }\n\n  friend ostream &operator<<(ostream &os, const mint &b) {\n    return os << b.get();\n  }\n\n  friend istream &operator>>(istream &is, mint &b) {\n    int64_t t;\n    is >> t;\n    b = LazyMontgomeryModInt<mod>(t);\n    return (is);\n  }\n  \n  constexpr u32 get() const {\n    u32 ret = reduce(a);\n    return ret >= mod ? ret - mod : ret;\n  }\n\n  static constexpr u32 get_mod() { return mod; }\n};\nusing namespace std;\n\ntemplate <typename T, typename F>\nstruct SegmentTree {\n  int size;\n  vector<T> seg;\n  const F func;\n  const T UNIT;\n\n  SegmentTree(int N, F func, T UNIT) : func(func), UNIT(UNIT) {\n    size = 1;\n    while (size < N) size <<= 1;\n    seg.assign(2 * size, UNIT);\n  }\n\n  SegmentTree(const vector<T> &v, F func, T UNIT) : func(func), UNIT(UNIT) {\n    int N = (int)v.size();\n    size = 1;\n    while (size < N) size <<= 1;\n    seg.assign(2 * size, UNIT);\n    for (int i = 0; i < N; i++) {\n      seg[i + size] = v[i];\n    }\n    build();\n  }\n\n  void set(int k, T x) { seg[k + size] = x; }\n\n  void build() {\n    for (int k = size - 1; k > 0; k--) {\n      seg[k] = func(seg[2 * k], seg[2 * k + 1]);\n    }\n  }\n\n  void update(int k, T x) {\n    k += size;\n    seg[k] = x;\n    while (k >>= 1) {\n      seg[k] = func(seg[2 * k], seg[2 * k + 1]);\n    }\n  }\n\n  void add(int k, T x) {\n    k += size;\n    seg[k] += x;\n    while (k >>= 1) {\n      seg[k] = func(seg[2 * k], seg[2 * k + 1]);\n    }\n  }\n\n  // query to [a, b)\n  T query(int a, int b) {\n    T L = UNIT, R = UNIT;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1) {\n      if (a & 1) L = func(L, seg[a++]);\n      if (b & 1) R = func(seg[--b], R);\n    }\n    return func(L, R);\n  }\n\n  T &operator[](const int &k) { return seg[k + size]; }\n\n  template <typename C>\n  int find_subtree(int a, const C &check, T &M, bool type) {\n    while (a < size) {\n      T nxt = type ? func(seg[2 * a + type], M) : func(M, seg[2 * a + type]);\n      if (check(nxt))\n        a = 2 * a + type;\n      else\n        M = nxt, a = 2 * a + 1 - type;\n    }\n    return a - size;\n  }\n\n  template <typename C>\n  int find_first(int a, const C &check) {\n    T L = UNIT;\n    if (a <= 0) {\n      if (check(func(L, seg[1]))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    int b = size;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1) {\n      if (a & 1) {\n        T nxt = func(L, seg[a]);\n        if (check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n\n  template <typename C>\n  int find_last(int b, const C &check) {\n    T R = UNIT;\n    if (b >= size) {\n      if (check(func(seg[1], R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    int a = size;\n    for (b += size; a < b; a >>= 1, b >>= 1) {\n      if (b & 1) {\n        T nxt = func(seg[--b], R);\n        if (check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n};\n\nvoid solve() {\n  using mint = LazyMontgomeryModInt<998244353>;\n\n  ini(N, K);\n  vi a(N);\n  in(a);\n\n  auto f = [](mint a, mint b) { return a + b; };\n  SegmentTree<mint, decltype(f)> seg1(N, f, mint(0)), seg2(N, f, mint(0)),\n      seg3(N, f, mint(0));\n\n  auto ord = mkord(N, [&](int i, int j) { return a[i] < a[j]; });\n\n  V<mint> pw(N + 1), ipw(N + 1);\n  pw[0] = ipw[0] = 1;\n  mint k1 = mint(1) - mint(1) / K;\n  mint k2 = k1.inverse();\n  rep1(i, N) pw[i] = pw[i - 1] * k1, ipw[i] = ipw[i - 1] * k2;\n\n  mint ans = 0;\n\n  each(i, ord) {\n    int j = max(K - 1, i);\n    // usiro\n    {\n      mint m = seg1.query(j + 1, N);\n      m *= ipw[j];\n      mint cnt = seg3.query(j + 1, N);\n      // mの確率で1/2\n      ans += m * mint(2).inverse();\n      // それ以外は1\n      ans += cnt - m;\n      trc(m, cnt, ans);\n    }\n    // 前\n    {\n      mint m = seg2.query(0, j);\n      m *= pw[j];\n      mint cnt = seg3.query(0, j);\n      // mの確率で1/2\n      ans += m * mint(2).inverse();\n      // それ以外は0\n      trc(m, cnt, ans);\n    }\n\n    // inplace\n    mint m = seg3[j];\n    ans += m * mint(2).inverse();\n    trc(m, ans);\n\n    seg1.add(j, pw[j]);\n    seg2.add(j, ipw[j]);\n    seg3.add(j, 1);\n  }\n\n  out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 200005, mod = 998244353;\nint n, k, p[MX], a[MX];\nll ft[MX], res;\n\nvoid update (int i, int k) {\n\twhile (i < MX) {\n\t\t(ft[i] += k) %= mod;\n\t\ti += i & -i;\n\t}\n}\n\nll query (int i) {\n\tll s = 0;\n\twhile (i) {\n\t\t(s += ft[i]) %= mod;\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nll pot (ll b, int p) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= b) %= mod;\n\t\t(b *= b) %= mod;\n\t\tp /= 2;\n\t}\n\treturn res;\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\t\n\tcin >> n >> k;\n\tforn (i, n) cin >> p[i];\n\tforn (i, n) a[i] = max(0, i - k + 1);\n\n\tforn (i, n) {\n\t\tres += i - query(p[i]);\n\t\tupdate(p[i], 1);\n\t}\n\n\tres %= mod;\n\n\tmemset(ft, 0, sizeof(ft));\n\n\tll f = (k - 1) * pot(k, mod - 2) % mod;\n\tll inv2 = pot(2, mod - 2);\n\n\tforn (i, n) {\n\t\tll x = query(p[i]);\n\t\tll y = query(n) - x;\n\n\t\t(res += pot(f, a[i]) * x % mod * inv2) %= mod;\n\t\t(res -= pot(f, a[i]) * y % mod * inv2) %= mod;\n\n\t\tupdate(p[i], pot(pot(f, mod - 2), a[i]));\n\t}\n\n\tcout << MOD(res, mod) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=998244353,MAX=55,INF=1<<20;\n\nusing mint=atcoder::modint998244353;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    mint ans=0;\n    \n    int N;\n    ll k;cin>>N>>k;\n    vector<pair<int,int>> p(N);\n    for(int i=0;i<N;i++){\n        cin>>p[i].fi;\n        p[i].se=i;\n    }\n    \n    sort(all(p),[](auto a,auto b){\n        return a.fi>b.fi;\n    });\n    \n    mint K=k;\n    \n    atcoder::fenwick_tree<mint> fw(N),fwinv(N);\n    atcoder::fenwick_tree<int> cnt(N);\n    \n    for(int i=0;i<N;i++){\n        \n        mint ppp=(K-1)*K.inv();\n        mint x=ppp.pow(max(0LL,p[i].se+1-k));\n        mint y=x.inv();\n        ans+=y*fw.sum(p[i].se,N)/2;\n        \n        ans+=mint(cnt.sum(0,p[i].se));\n        \n        ans-=x*fwinv.sum(0,p[i].se)/2;\n        \n        cnt.add(p[i].se,1);\n        fw.add(p[i].se,x);\n        fwinv.add(p[i].se,y);\n        \n        //cout<<x.val()<<\" \"<<y.val()<<\" \"<<p[i].se<<\" \"<<ans.val()<<endl;\n        \n    }\n    \n    cout<<ans.val()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,a,n) for(int i=a;i<=n;i++)\n#define per(i,a,n) for(int i=n;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define FI first\n#define SE second\n#define maxn 200000\n#define mod 998244353\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef double db;\n\nll qp(ll a,ll k)\n{\n    ll res=1;\n    while(k)\n    {\n        if(k&1) res=res*a%mod;\n        a=a*a%mod;\n        k>>=1;\n    }\n    return res;\n}\nint p[maxn+5];\n\nstruct BIT\n{\n    ll a[maxn+5];\n    void init()\n    {\n        memset(a,0,sizeof a);\n    }\n    void add(int x,ll v)\n    {\n        for(;x<=maxn;x+=x&-x) a[x]=(a[x]+v+mod)%mod;\n    }\n    ll ask(int x)\n    {\n        ll res=0;\n        for(;x;x-=x&-x) res=(res+a[x])%mod;\n        return res;\n    }\n}A,B;\n\nint id[maxn+5];\n\nint main()\n{\n    int n,k; scanf(\"%d%d\",&n,&k);\n    rep(i,1,n) scanf(\"%d\",&p[i]),id[i]=i;\n    ll invk=qp(k,mod-2),inv2=qp(2,mod-2);\n    sort(id+1,id+n+1,[](int a,int b){return p[a]>p[b];});\n    ll ans=0;\n    ll pr=(1-invk+mod)%mod;\n    rep(I,1,n)\n    {\n        int i=id[I];\n        if(i<=k) ans=(ans+inv2*(i-1))%mod;\n        if(i>k)\n        {\n            ans=(ans+A.ask(i))%mod;\n            ll tmp=(B.ask(i)-B.ask(k)+mod)*qp(pr,i)%mod;\n            ll tmp2=A.ask(k)*qp(pr,i-k)%mod;\n            ans=(ans-tmp*inv2%mod+mod)%mod;\n            ans=(ans-tmp2*inv2%mod+mod)%mod;\n        }\n        A.add(i,1);\n        B.add(i,qp(qp(pr,i),mod-2));\n    }\n    A.init(); B.init();\n    per(I,1,n)\n    {\n        int i=id[I];\n        if(i>k)\n        {\n            ll tmp=(B.ask(i)-B.ask(k)+mod)*qp(pr,i)%mod;\n            ll tmp2=A.ask(k)*qp(pr,i-k)%mod;\n            ans=(ans+tmp*inv2%mod)%mod;\n            ans=(ans+tmp2*inv2%mod)%mod;\n        }\n        A.add(i,1);\n        B.add(i,qp(qp(pr,i),mod-2));\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\n\n#ifdef LOCAL\n#define Gene template< class\n#define Rics printer& operator,\nGene c> struct rge{c b, e;};\nGene c> rge<c> range(c i, c j){ return {i, j};}\nstruct printer{\n    ~printer(){cerr<<endl;}\n    Gene c >Rics(c x){ cerr<<boolalpha<<x; return *this;}\n    Rics(string x){cerr<<x;return *this;}\n    Gene c, class d >Rics(pair<c, d> x){ return *this,\"(\",x.first,\", \",x.second,\")\";}\n    Gene ... d, Gene ...> class c >Rics(c<d...> x){ return *this, range(begin(x), end(x));}\n    Gene c >Rics(rge<c> x){\n        *this,\"[\"; for(auto it = x.b; it != x.e; ++it)\n            *this,(it==x.b?\"\":\", \"),*it; return *this,\"]\";}\n};\n#define debug() cerr<<\"LINE \"<<__LINE__<<\" >> \", printer()\n#define dbg(x) \"[\",#x,\": \",(x),\"] \"\n#define bits(x) bitset<22>(x)\n#define tham getchar()\n#endif\n\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define eq(x, y) (fabs((x)-(y))<error)\n#define bt(i) (1LL<<(i))\n\nmt19937_64 rng((unsigned)chrono::system_clock::now().time_since_epoch().count());\nconst ll mod = 998244353;\n//const ld error = ;\nconst ld PI = acosl(-1);\n\n//inline ll MOD(ll x, ll m = mod){\n//    ll y = x % m;\n//    return (y >= 0) ? y: y+m;\n//}\n\n//const int/ll inf = ;\nconst int nmax = 2e5+10;\n///===========================================  template  =======================================================\n\ninline ll add(ll x, ll y){\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n}\n\ninline ll sub(ll x, ll y){\n    x -= y;\n    if(x < 0) x += mod;\n    return x;\n}\n\nll modexpo(ll x, ll n, ll m = mod){\n\tx %= m;\n\tll ret = 1;\n    while(n){\n        if(n & 1LL) ret = (ret*x) % m;\n        x = (x*x) % m;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint N;\t//N is size\nint bit1[nmax];\nll bit2[nmax];\n\npair<int, ll> prefix(int i)\n{\n    pair<int, ll> ret = {0, 0ll};\t//identity\n    while(i >= 1) {\n        ret.first += bit1[i];\n        ret.second = add(ret.second, bit2[i]);\n        i -= i&-i;\n    }\n    return ret;\n}\n\nvoid update(int i, ll x)\n{\n    while(i<=N && i) {\n        bit1[i] += 1;\n        bit2[i] = add(bit2[i], x);\n        i += i&-i;\n    }\n}\n\npair<int, ll> query(int l, int r){\n    if(l > r) return {0, 0ll};\n\n    pair<int, ll> ret;\n    ret = prefix(r);\n    if(l != 1){\n        auto tmp = prefix(l-1);\n        ret.first -= tmp.first;\n        ret.second = sub(ret.second, tmp.second);\n    }\n    return ret;\n}\n\nint main(){\n    FASTIO;\n\n    int n;\n    ll k;\n    cin>>n>>k;\n    N = n;\n    vector<int> v(n);\n\n    ll inv2 = (mod+1)/2;\n\n    for(int i = 0; i<n; i++){\n        cin>>v[i];\n    }\n\n    ll ans = k*(k-1) % mod;\n    ans = ans * inv2 % mod;\n    ans = ans * inv2 % mod;\n\n//    debug(), dbg(ans*4%mod);\n\n    ll prob = (k-1) * modexpo(k, mod-2) % mod;\n\n//    debug(), dbg(prob*2%mod);\n\n    for(int i = n-1; i>=0; i--){\n\n        ll invP = modexpo(prob, mod-1-max(i-(k-1), 0ll));\n\n//        debug(), dbg(invP);\n\n        auto q = query(v[i], n);\n\n        ans += (q.second * invP) % mod * inv2;\n        ans %= mod;\n\n        q = query(1, v[i]);\n\n        ans += q.first - q.second * invP % mod * inv2;\n        ans %= mod;\n        if(ans < 0) ans += mod;\n\n//        debug(), dbg(ans*4%mod);\n\n        if(i >= k){\n            ll p = modexpo(prob, i-(k-1));\n            update(v[i], p);\n        }\n    }\n\n\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\n\nstruct Fenwick {\n\tvector<ll> fenv;\n\n\tFenwick() : fenv() {}\n\tFenwick(int n) : fenv(vector<ll>(n, 0)) {}\n\n\tvoid fadd(int p, ll x) {\n\t\tfor(; p < (int)fenv.size(); p |= p + 1)\n\t\t\tfenv[p] = add(fenv[p], x);\n\t}\n\tint get(int r) {\n\t\tint res = 0;\n\t\tfor(; r >= 0; r = (r & (r + 1)) - 1)\n\t\t\tres = add(res, fenv[r]);\n\t\treturn res;\n\t}\n\tint getSum(int l, int r) {\n\t\tif (l >= r) return 0;\n\t\treturn sub(get(r - 1), get(l - 1));\n\t}\n};\n\nconst int N = 200200;\nint n, k;\nll pw[N], rpw[N];\npii ord[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &k);\n\tpw[0] = 1;\n\tpw[1] = sub(1, rev(k));\n\tfor (int i = 2; i < N; i++)\n\t\tpw[i] = mult(pw[i - 1], pw[1]);\n\trpw[1] = rev(pw[1]);\n\tfor (int i = 2; i < N; i++)\n\t\trpw[i] = mult(rpw[i - 1], rpw[1]);\n\n\tFenwick F1 = Fenwick(n), F2 = Fenwick(n), F3 = Fenwick(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tord[i] = mp(x, i);\n\t}\n\tsort(ord, ord + n);\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = ord[i].second;\n\t\tll sumL = F1.getSum(0, x), sumR = F1.getSum(x + 1, n);\n\t\tll sumRevL = F2.getSum(0, x), sumRevR = F2.getSum(x + 1, n);\n\t\tll cntL = F3.getSum(0, x), cntR = F3.getSum(x + 1, n);\n\t\tans = add(ans, mult(rev(2), mult(sumRevL, pw[max(k - 1, x)])));\n\t\tans = add(ans, cntR);\n\t\tans = sub(ans, mult(rev(2), mult(sumR, rpw[max(k - 1, x)])));\n\t\tF1.fadd(x, pw[max(k - 1, x)]);\n\t\tF2.fadd(x, rpw[max(k - 1, x)]);\n\t\tF3.fadd(x, 1);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"main.cpp\"\n\n/**\n * @title Template\n */\n\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n#include <cassert>\n\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/chmin_chmax.cpp\"\n\ntemplate <class T, class U>\nconstexpr bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) { lhs = rhs; return true; }\n  return false;\n}\n\ntemplate <class T, class U>\nconstexpr bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) { lhs = rhs; return true; }\n  return false;\n}\n\n/**\n * @title Chmin/Chmax\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/range.cpp\"\n\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/range.cpp\"\n\nclass range {\npublic:\n  class iterator {\n  private:\n    int64_t M_position;\n\n  public:\n    constexpr iterator(int64_t position) noexcept: M_position(position) { }\n    constexpr void operator ++ () noexcept { ++M_position; }\n    constexpr bool operator != (iterator other) const noexcept { return M_position != other.M_position; }\n    constexpr int64_t operator * () const noexcept { return M_position; }\n  };\n\n  class reverse_iterator {\n  private:\n    int64_t M_position;\n  \n  public:\n    constexpr reverse_iterator(int64_t position) noexcept: M_position(position) { }\n    constexpr void operator ++ () noexcept { --M_position; }\n    constexpr bool operator != (reverse_iterator other) const noexcept { return M_position != other.M_position; }\n    constexpr int64_t operator * () const noexcept { return M_position; }\n  };\n  \nprivate:\n  const iterator M_first, M_last;\n\npublic:\n  constexpr range(int64_t first, int64_t last) noexcept: M_first(first), M_last(std::max(first, last)) { }\n  constexpr iterator begin() const noexcept { return M_first; }\n  constexpr iterator end() const noexcept { return M_last; }\n  constexpr reverse_iterator rbegin() const noexcept { return reverse_iterator(*M_last - 1); } \n  constexpr reverse_iterator rend() const noexcept { return reverse_iterator(*M_first - 1); } \n};\n\n/**\n * @title Range\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/rev.cpp\"\n\n#include <type_traits>\n#include <iterator>\n#line 6 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/rev.cpp\"\n\ntemplate <class T>\nclass rev_impl {\npublic:\n  using iterator = decltype(std::rbegin(std::declval<T>()));\n\nprivate:\n  const iterator M_begin;\n  const iterator M_end;\n\npublic:\n  constexpr rev_impl(T &&cont) noexcept: M_begin(std::rbegin(cont)), M_end(std::rend(cont)) { }\n  constexpr iterator begin() const noexcept { return M_begin; }\n  constexpr iterator end() const noexcept { return M_end; }\n};\n\ntemplate <class T>\nconstexpr decltype(auto) rev(T &&cont) {\n  return rev_impl<T>(std::forward<T>(cont));\n}\n\n/**\n * @title Reverser\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/modular.cpp\"\n\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/ext_gcd.cpp\"\n\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/ext_gcd.cpp\"\n#include <cstdint>\n\nconstexpr std::pair<int64_t, int64_t> ext_gcd(int64_t a, int64_t b) {\n  if ((a %= b) == 0) return { b, 0 };\n  int64_t s = b, t = (a < 0 ? a + b : a);\n  int64_t m0 = 0, m1 = 1, tmp = 0;\n  while (t > 0) {\n    const auto u = s / t;\n    s -= t * u; m0 -= m1 * u;\n    tmp = s; s = t; t = tmp; tmp = m0; m0 = m1; m1 = tmp;\n  }\n  return { s, (m0 < 0 ? m0 + b / s : m0) };\n}\n\n/**\n * @title Extended GCD\n */\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/modular.cpp\"\n\n#line 8 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/modular.cpp\"\n#include <type_traits>\n\ntemplate <class Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using cover_type = uint64_t;\n \n  template <class T>\n  static constexpr value_type normalize(T value_) noexcept {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= Modulus::mod();\n      if (value_ == 0) return 0;\n      return Modulus::mod() - value_;\n    }\n    return value_ % Modulus::mod();\n  }\n\nprivate:\n  value_type value;\n\n  template <bool IsPrime, std::enable_if_t<IsPrime>* = nullptr>\n  constexpr modular inverse_helper() const noexcept { return power(*this, Modulus::mod() - 2); }\n  template <bool IsPrime, std::enable_if_t<!IsPrime>* = nullptr>\n  constexpr modular inverse_helper() const noexcept {\n    const auto tmp = ext_gcd(value, Modulus::mod());\n    assert(tmp.first == 1);\n    return modular(tmp.second);\n  }\n\npublic:\n  constexpr modular() noexcept : value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_) noexcept : value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() const noexcept { return static_cast<T>(value); }\n \n  constexpr value_type get() const noexcept { return value; }\n  constexpr value_type &extract() noexcept { return value; }\n  constexpr modular operator - () const noexcept { return modular(Modulus::mod() - value); }\n  constexpr modular operator ~ () const noexcept { return inverse(*this); }\n \n  constexpr modular operator + (const modular &rhs) const noexcept { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) noexcept { \n    if ((value += rhs.value) >= Modulus::mod()) value -= Modulus::mod(); \n    return *this; \n  }\n \n  constexpr modular operator - (const modular &rhs) const noexcept { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) noexcept { \n    if ((value += Modulus::mod() - rhs.value) >= Modulus::mod()) value -= Modulus::mod(); \n    return *this; \n  }\n \n  constexpr modular operator * (const modular &rhs) const noexcept { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) noexcept { \n    value = (cover_type) value * rhs.value % Modulus::mod();\n    return *this;\n  }\n \n  constexpr modular operator / (const modular &rhs) const noexcept { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) noexcept { return (*this) *= inverse(rhs); }\n \n  constexpr bool zero() const noexcept { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const noexcept { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const noexcept { return value != rhs.value; }\n \n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) { return stream << rhs.value; }\n  friend constexpr modular inverse(const modular &val) noexcept { return val.inverse_helper<Modulus::is_prime>(); }\n  friend constexpr modular power(modular val, cover_type exp) noexcept { \n    modular res(1);\n    for (; exp > 0; exp >>= 1, val *= val) if (exp & 1) res *= val;\n    return res;\n  }\n \n};\n \ntemplate <uint32_t Mod, bool IsPrime = true>\nstruct static_modulus { \n  static constexpr uint32_t mod() noexcept { return Mod; } \n  static constexpr bool is_prime = IsPrime;\n};\n\ntemplate <uint32_t Id = 0, bool IsPrime = false>\nstruct dynamic_modulus {\n  static uint32_t &mod() noexcept { static uint32_t val = 0; return val; }\n  static constexpr bool is_prime = IsPrime;\n};\n\ntemplate <uint32_t Mod>\nusing mint32_t = modular<static_modulus<Mod>>;\nusing rmint32_t = modular<dynamic_modulus<>>;\n\n/*\n * @title Modint\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/container/lazy_propagation_segment_tree.cpp\"\n\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/bit_operation.cpp\"\n\n#include <cstddef>\n#line 5 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/bit_operation.cpp\"\n\nconstexpr size_t bit_ppc(const uint64_t x) { return __builtin_popcountll(x); }\nconstexpr size_t bit_ctzr(const uint64_t x) { return x == 0 ? 64 : __builtin_ctzll(x); }\nconstexpr size_t bit_ctzl(const uint64_t x) { return x == 0 ? 64 : __builtin_clzll(x); }\nconstexpr size_t bit_width(const uint64_t x) { return 64 - bit_ctzl(x); }\nconstexpr uint64_t bit_msb(const uint64_t x) { return x == 0 ? 0 : uint64_t(1) << (bit_width(x) - 1); }\nconstexpr uint64_t bit_lsb(const uint64_t x) { return x & (-x); }\nconstexpr uint64_t bit_cover(const uint64_t x) { return x == 0 ? 0 : bit_msb(2 * x - 1); }\n\nconstexpr uint64_t bit_rev(uint64_t x) {\n  x = ((x >> 1) & 0x5555555555555555) | ((x & 0x5555555555555555) << 1);\n  x = ((x >> 2) & 0x3333333333333333) | ((x & 0x3333333333333333) << 2);\n  x = ((x >> 4) & 0x0F0F0F0F0F0F0F0F) | ((x & 0x0F0F0F0F0F0F0F0F) << 4);\n  x = ((x >> 8) & 0x00FF00FF00FF00FF) | ((x & 0x00FF00FF00FF00FF) << 8);\n  x = ((x >> 16) & 0x0000FFFF0000FFFF) | ((x & 0x0000FFFF0000FFFF) << 16);\n  x = (x >> 32) | (x << 32);\n  return x;\n}\n\n/**\n * @title Bit Operations\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/monoid.cpp\"\n\n#include <type_traits>\n#line 5 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/monoid.cpp\"\n#include <stdexcept>\n\ntemplate <class T, class = void>\nclass has_identity: public std::false_type { };\n\ntemplate <class T>\nclass has_identity<T, typename std::conditional<false, decltype(T::identity()), void>::type>: public std::true_type { };\n\ntemplate <class T>\nconstexpr typename std::enable_if<has_identity<T>::value, typename T::type>::type empty_exception() {\n  return T::identity();\n}\ntemplate <class T>\n[[noreturn]] typename std::enable_if<!has_identity<T>::value, typename T::type>::type empty_exception() {\n  throw std::runtime_error(\"type T has no identity\");\n}\n\ntemplate <class T, bool HasIdentity>\nclass fixed_monoid_impl: public T {\npublic:\n  using type = typename T::type;\n\n  static constexpr type convert(const type &value) { return value; }\n  static constexpr type revert(const type &value) { return value; }\n\n  template <class Mapping, class Value, class... Args>\n  static constexpr void operate(Mapping &&func, Value &value, const type &op, Args&&... args) {\n    value = func(value, op, std::forward<Args>(args)...);\n  }\n  template <class Constraint>\n  static constexpr bool satisfies(Constraint &&func, const type &value) {\n    return func(value);\n  }\n};\n\ntemplate <class T>\nclass fixed_monoid_impl<T, false> {\npublic:\n  class type {\n  public:\n    typename T::type value;\n    bool state;\n  \n    explicit constexpr type(): value(typename T::type { }), state(false) { }\n    explicit constexpr type(const typename T::type &value): value(value), state(true) { }\n  };\n\n  static constexpr type convert(const typename T::type &value) { return type(value); }\n  static constexpr typename T::type revert(const type &value) { \n    if (!value.state) throw std::runtime_error(\"attempted to revert identity to non-monoid\"); \n    return value.value; \n  }\n\n  static constexpr type identity() { return type(); }\n  static constexpr type operation(const type &v1, const type &v2) {\n    if (!v1.state) return v2;\n    if (!v2.state) return v1;\n    return type(T::operation(v1.value, v2.value));\n  }\n\n  template <class Mapping, class Value, class... Args>\n  static constexpr void operate(Mapping &&func, Value &value, const type &op, Args&&... args) {\n    if (!op.state) return;\n    value = func(value, op.value, std::forward<Args>(args)...);\n  }\n  template <class Constraint>\n  static constexpr bool satisfies(Constraint &&func, const type &value) {\n    if (!value.state) return false;\n    return func(value.value);\n  }\n};\n\ntemplate <class T>\nusing fixed_monoid = fixed_monoid_impl<T, has_identity<T>::value>;\n\n/**\n * @title Monoid Utility\n */\n#line 5 \"/Users/kodamankod/Desktop/cpp_programming/Library/container/lazy_propagation_segment_tree.cpp\"\n\n#line 11 \"/Users/kodamankod/Desktop/cpp_programming/Library/container/lazy_propagation_segment_tree.cpp\"\n\ntemplate <class CombinedMonoid>\nclass lazy_propagation_segment_tree {\npublic:\n  using structure       = CombinedMonoid;\n  using value_monoid    = typename CombinedMonoid::value_structure;\n  using operator_monoid = typename CombinedMonoid::operator_structure;\n  using value_type      = typename CombinedMonoid::value_structure::type;\n  using operator_type   = typename CombinedMonoid::operator_structure::type;\n  using size_type       = size_t;\n\nprivate:\n  using fixed_operator_monoid = fixed_monoid<operator_monoid>;\n  using fixed_operator_type   = typename fixed_operator_monoid::type;\n\n  class node_type {\n  public:\n    value_type    value;\n    fixed_operator_type lazy;\n    node_type(\n      const value_type    &value = value_monoid::identity(),\n      const fixed_operator_type &lazy = fixed_operator_monoid::identity()\n    ): value(value), lazy(lazy) { }\n  };\n\n  static void S_apply(node_type &node, const fixed_operator_type &op, const size_type length) {\n    fixed_operator_monoid::operate(structure::operation, node.value, op, length);\n    node.lazy = fixed_operator_monoid::operation(node.lazy, op);\n  }\n\n  void M_propagate(const size_type index, const size_type length) {\n    S_apply(M_tree[index << 1 | 0], M_tree[index].lazy, length);\n    S_apply(M_tree[index << 1 | 1], M_tree[index].lazy, length);\n    M_tree[index].lazy = fixed_operator_monoid::identity();\n  }\n  void M_fix_change(const size_type index) {\n    M_tree[index].value = \n      value_monoid::operation(M_tree[index << 1 | 0].value, M_tree[index << 1 | 1].value);\n  }\n\n  void M_pushdown(const size_type index) {\n    const size_type lsb = bit_ctzr(index);\n    for (size_type story = bit_width(index); story != lsb; --story) {\n      M_propagate(index >> story, 1 << (story - 1));\n    }\n  }\n  void M_pullup(size_type index) {\n    index >>= bit_ctzr(index);\n    while (index != 1) {\n      index >>= 1;\n      M_fix_change(index);\n    }\n  }\n\n  std::vector<node_type> M_tree;\n\npublic:\n  lazy_propagation_segment_tree() = default;\n  explicit lazy_propagation_segment_tree(const size_type size) { initialize(size); }\n  template <class InputIterator>\n  explicit lazy_propagation_segment_tree(InputIterator first, InputIterator last) { construct(first, last); }\n\n  void initialize(const size_type size) {\n    clear();\n    M_tree.assign(size << 1, node_type());\n  }\n\n  template <class InputIterator>\n  void construct(InputIterator first, InputIterator last) {\n    clear();\n    const size_type size = std::distance(first, last);\n    M_tree.reserve(size << 1);\n    M_tree.assign(size, node_type());\n    for (; first != last; ++first) {\n      M_tree.emplace_back(*first, fixed_operator_monoid::identity());\n    }\n    for (size_type index = size - 1; index != 0; --index) {\n      M_fix_change(index);\n    }\n  }\n\n  value_type fold(size_type first, size_type last) {\n    assert(first <= last);\n    assert(last <= size());\n    first += size();\n    last  += size();\n    M_pushdown(first);\n    M_pushdown(last);\n    value_type fold_l = value_monoid::identity();\n    value_type fold_r = value_monoid::identity();\n    while (first != last) {\n      if (first & 1) {\n        fold_l = value_monoid::operation(fold_l, M_tree[first].value);\n        ++first;\n      }\n      if (last & 1) {\n        --last;\n        fold_r = value_monoid::operation(M_tree[last].value, fold_r);\n      }\n      first >>= 1;\n      last  >>= 1;\n    }\n    return value_monoid::operation(fold_l, fold_r);\n  }\n\n  void operate(size_type first, size_type last, const operator_type &op_) {\n    assert(first <= last);\n    assert(last <= size());\n    const auto op = fixed_operator_monoid::convert(op_);\n    first += size();\n    last  += size();\n    M_pushdown(first);\n    M_pushdown(last);\n    const size_type first_c = first;\n    const size_type last_c  = last;\n    for (size_type story = 0; first != last; ++story) {\n      if (first & 1) {\n        S_apply(M_tree[first], op, 1 << story);\n        ++first;\n      }\n      if (last & 1) {\n        --last;\n        S_apply(M_tree[last], op, 1 << story);\n      }\n      first >>= 1;\n      last  >>= 1;\n    }\n    M_pullup(first_c);\n    M_pullup(last_c);\n  }\n\n  void assign(size_type index, const value_type &val) {\n    assert(index < size());\n    index += size();\n    for (size_type story = bit_width(index); story != 0; --story) {\n      M_propagate(index >> story, 1 << (story - 1));\n    }\n    M_tree[index].value = val;\n    M_tree[index].lazy  = fixed_operator_monoid::identity();\n    while (index != 1) {\n      index >>= 1;\n      M_fix_change(index);\n    }\n  }\n\n  template <bool ToRight = true, class Constraint, std::enable_if_t<ToRight>* = nullptr> \n  size_type satisfies(const size_type left, Constraint &&func) {\n    assert(left <= size());\n    if (func(value_monoid::identity())) return left;\n    size_type first = left + size();\n    size_type last = 2 * size();\n    M_pushdown(first);\n    M_pushdown(last);\n    const size_type last_c = last;\n    value_type fold = value_monoid::identity();\n    const auto try_merge = [&](const size_type index) {\n      value_type tmp = value_monoid::operation(fold, M_tree[index].value);\n      if (func(tmp)) return true;\n      fold = std::move(tmp);\n      return false;\n    };\n    const auto subtree = [&](size_type index, size_type story) {\n      while (index < size()) {\n        M_propagate(index, 1 << (story - 1));\n        index <<= 1;\n        if (!try_merge(index)) ++index;\n        --story;\n      }\n      return index - size() + 1;\n    };\n    size_type story = 0;\n    while (first < last) {\n      if (first & 1) {\n        if (try_merge(first)) return subtree(first, story);\n        ++first;\n      }\n      first >>= 1;\n      last >>= 1;\n      ++story;\n    }\n    while (story--) {\n      last = last_c >> story;\n      if (last & 1) {\n        --last;\n        if (try_merge(last)) return subtree(last, story);\n      }\n    }\n    return size() + 1;\n  }\n\n  template <bool ToRight = true, class Constraint, std::enable_if_t<!ToRight>* = nullptr> \n  size_type satisfies(const size_type right, Constraint &&func) {\n    assert(right <= size());\n    if (func(value_monoid::identity())) return right;\n    size_type first = size();\n    size_type last = right + size();\n    M_pushdown(first);\n    M_pushdown(last);\n    const size_type first_c = first;\n    value_type fold = value_monoid::identity();\n    const auto try_merge = [&](const size_type index) {\n      value_type tmp = value_monoid::operation(M_tree[index].value, fold);\n      if (func(tmp)) return true;\n      fold = std::move(tmp);\n      return false;\n    };\n    const auto subtree = [&](size_type index, size_type story) {\n      while (index < size()) {\n        M_propagate(index, 1 << (story - 1));\n        index <<= 1;\n        if (try_merge(index + 1)) ++index;\n        --story;\n      }\n      return index - size();\n    };\n    size_type story = 0;\n    while (first < last) {\n      if (first & 1) ++first;\n      if (last & 1) {\n        --last;\n        if (try_merge(last)) return subtree(last, story);\n      }\n      first >>= 1;\n      last >>= 1;\n      ++story;\n    }\n    const size_type cover = bit_cover(first_c);\n    while (story--) {\n      first = (cover >> story) - ((cover - first_c) >> story);\n      if (first & 1) {\n        if (try_merge(first)) return subtree(first, story);\n      }\n    }\n    return size_type(-1);\n  }\n\n  void clear() {\n    M_tree.clear();\n    M_tree.shrink_to_fit();\n  }\n  size_type size() const { \n    return M_tree.size() >> 1;\n  }\n};\n\n/**\n * @title Lazy Propagation Segment Tree\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/container/fenwick_tree.cpp\"\n\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/container/fenwick_tree.cpp\"\n\n#line 8 \"/Users/kodamankod/Desktop/cpp_programming/Library/container/fenwick_tree.cpp\"\n#include <type_traits>\n\ntemplate <class T>\nclass fenwick_tree {\npublic:\n  using value_type = T;\n  using size_type = size_t;\n\nprivate:\n  std::vector<value_type> M_tree;\n\npublic:\n  fenwick_tree() = default;\n  explicit fenwick_tree(size_type size) { initialize(size); }\n\n  void initialize(size_type size) {\n    M_tree.assign(size + 1, value_type { });\n  }\n\n  void add(size_type index, const value_type& x) {\n    assert(index < size());\n    ++index;\n    while (index <= size()) {\n      M_tree[index] += x;\n      index += bit_lsb(index);\n    }\n  }\n\n  template <size_type Indexed = 1>\n  value_type get(size_type index) const {\n    assert(index < size());\n    index += Indexed;\n    value_type res{ };\n    while (index > 0) {\n      res += M_tree[index];\n      index -= bit_lsb(index);\n    }\n    return res;\n  }\n  value_type fold(size_type first, size_type last) const {\n    assert(first <= last);\n    assert(last <= size());\n    value_type res{};\n    while (first < last) {\n      res += M_tree[last];\n      last -= bit_lsb(last);\n    }\n    while (last < first) {\n      res -= M_tree[first];\n      first -= bit_lsb(first);\n    }\n    return res;\n  }\n\n  template <class Func>\n  size_type satisfies(const size_type left, Func &&func) const {\n    assert(left <= size());\n    if (func(value_type { })) return left;\n    value_type val = -get<0>(left);\n    size_type res = 0;\n    for (size_type cur = bit_cover(size() + 1) >> 1; cur > 0; cur >>= 1) {\n      if ((res + cur <= left) || (res + cur <= size() && !func(val + M_tree[res + cur]))) {\n        val += M_tree[res + cur];\n        res += cur;\n      }\n    }\n    return res + 1;\n  }\n\n  void clear() {\n    M_tree.clear();\n    M_tree.shrink_to_fit();\n  }\n  size_type size() const {\n    return M_tree.size() - 1;\n  }\n};\n\n/**\n * @title Fenwick Tree\n */\n#line 20 \"main.cpp\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\nconstexpr i32 inf32 = (i32(1) << 30) - 1;\nconstexpr i64 inf64 = (i64(1) << 62) - 1;\n\nusing m32 = mint32_t<998244353>;\n\nstruct lst_monoid {\n  struct value_structure {\n    using type = m32;\n    static type identity() { return m32(0); }\n    static type operation(const type& v1, const type& v2) { \n      return v1 + v2;\n    }\n  };\n  struct operator_structure {\n    using type = m32;\n    static type identity() { return m32(1); }\n    static type operation(const type& v1, const type& v2) { \n      return v1 * v2;\n    }\n  };\n  static typename value_structure::type operation(\n    const typename value_structure::type    &val,\n    const typename operator_structure::type &op,\n    const size_t = 1) {\n    return val * op;\n  }\n};\n\nint main() {\n  i32 N, K;\n  std::cin >> N >> K;\n  std::vector<i32> P(N);\n  for (auto &x: P) {\n    std::cin >> x;\n    --x;\n  }\n  m32 ans = m32(K) * m32(K - 1) / m32(4);\n  lazy_propagation_segment_tree<lst_monoid> seg(N);\n  fenwick_tree<i32> fen(N);\n  const auto half = m32(1) / m32(2);\n  const auto coeff = m32(K - 1) / m32(K);\n  for (auto i: range(0, K)) {\n    seg.assign(P[i], m32(1));\n    fen.add(P[i], 1);\n  }\n  for (auto i: range(K, N)) {\n    seg.operate(0, N, coeff);\n    ans += half * seg.fold(0, P[i]);\n    ans += m32(fen.fold(P[i], N)) - half * seg.fold(P[i], N);\n    seg.assign(P[i], m32(1));\n    fen.add(P[i], 1);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#include <atcoder/all>\n#define popcount __builtin_popcount\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntemplate<typename Monoid, typename OperatorMonoid=Monoid>\nstruct LazySegmentTree{\n\tusing F=function<Monoid(Monoid, Monoid)>;\n\tusing G=function<Monoid(Monoid, OperatorMonoid, int)>;\n\tusing H=function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\tint sz;\n\tvector<Monoid> data;\n\tvector<OperatorMonoid> lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst Monoid e1;\n\tconst OperatorMonoid e0;\n\n\tLazySegmentTree(int n, const F f, const G g, const H h, const Monoid &e1, const OperatorMonoid &e0): f(f), g(g), h(h), e1(e1), e0(e0){\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t\tdata.resize(2*sz-1, e1);\n\t\tlazy.resize(2*sz-1, e0);\n\t}\n\n\tvoid build(vector<Monoid> v){\n\t\tfor(int i=0; i<v.size(); i++) data[i+sz-1]=v[i];\n\t\tfor(int i=sz-2; i>=0; i--) data[i]=f(data[2*i+1], data[2*i+2]);\n\t}\n\n\tvoid eval(int k, int l, int r){\n\t\tif(lazy[k]!=e0){\n\t\t\tdata[k]=g(data[k], lazy[k], r-l);\n\t\t\tif(k<sz-1){\n\t\t\t\tlazy[2*k+1]=h(lazy[2*k+1], lazy[k]);\n\t\t\t\tlazy[2*k+2]=h(lazy[2*k+2], lazy[k]);\n\t\t\t}\n\t\t}\n\t\tlazy[k]=e0;\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r){\n\t\teval(k, l, r);\n\t\tif(r<=a || b<=l) return;\n\t\tif(a<=l && r<=b){\n\t\t\tlazy[k]=h(lazy[k], x);\n\t\t\teval(k, l, r);\n\t\t}else{\n\t\t\tupdate(a, b, x, 2*k+1, l, (l+r)/2);\n\t\t\tupdate(a, b, x, 2*k+2, (l+r)/2, r);\n\t\t\tdata[k]=f(data[2*k+1], data[2*k+2]);\n\t\t}\n\t}\n\tvoid update(int a, int b, const OperatorMonoid &x){\n\t\treturn update(a, b, x, 0, 0, sz);\n\t}\n\n\tMonoid find(int a, int b, int k, int l, int r){\n\t\teval(k, l, r);\n\t\tif(b<=l || r<=a) return e1;\n\t\tif(a<=l && r<=b) return data[k];\n\t\telse return f(find(a, b, 2*k+1, l, (l+r)/2), find(a, b, 2*k+2, (l+r)/2, r));\n\t}\n\tMonoid find(int a, int b){\n\t\treturn find(a, b, 0, 0, sz);\n\t}\n\tMonoid operator[](const int &k){\n\t\treturn find(k, k+1);\n\t}\n};\ntemplate<typename T>\nstruct BIT{\n    vector<T> bit;\n    int size;\n    BIT(int n):size(n), bit(n+1, 0){}\n    T sum(int i){ //[0, i)\n        T s=0;\n        while(i>0){\n            s+=bit[i];\n            i-=(i&(-i));\n        }\n        return s;\n    }\n    T sum(int l, int r){ //[l, r)\n        return sum(r)-sum(l);\n    }\n    void add(int i, T x){\n        i++;\n        while(i<=size){\n            bit[i]+=x;\n            i+=(i&(-i));\n        }\n    }\n};\nint main()\n{\n    int n, k; cin>>n>>k;\n    int p[200020];\n    for(int i=0; i<n; i++){\n        cin>>p[i]; p[i]--;\n    }\n    using mint=modint998244353;\n    mint q=mint(1)-mint(1)/mint(k);\n    mint q2=mint(1)/mint(2);\n    auto f=[&](mint a, mint b){\n        return a+b;\n    };\n    using pmint=pair<mint, mint>;\n    auto g=[&](mint a, pmint x, int len){\n        return a*x.first+x.second*mint(len);\n    };\n    auto h=[&](pmint x, pmint y){\n        return pmint(x.first*y.first, y.first*x.second+y.second);\n    };\n    LazySegmentTree<mint, pmint> seg(n, f, g, h, 0, pmint(1, 0));\n    mint ans(0);\n    for(int i=0; i<n; i++){\n        auto res1=seg.find(0, p[i]), res2=seg.find(p[i], n);\n        ans+=res1-res2;\n        seg.update(p[i],p[i]+1, pmint(0, q2));\n        if(i>=k-1) seg.update(0, n, pmint(q, 0));\n    }\n    BIT<mint> bit(n);\n    for(int i=0; i<n; i++){\n        ans+=mint(i)-bit.sum(p[i]);\n        bit.add(p[i], mint(1));\n    }\n    cout<<ans.val()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __SEGMENT_TREE_H__\n#define __SEGMENT_TREE_H__\n\n/* updated: 2020-07-23 */\n\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <limits>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <sstream>\n\n/*-- てんぷれ --*/\nstruct HogeMonoid {\n\tusing Type = int;\n\tstatic Type identity() {\n\t\treturn Type();\n\t}\n\tstatic Type operate(const Type& left, const Type& right) {\n\t\treturn Type();\n\t}\n};\n\n/*--------------*/\n\nnamespace Monoid {\n\ttemplate <class T>\n\tstruct Sum {\n\t\tusing Type = T;\n\t\tstatic Type identity() {\n\t\t\treturn T();\n\t\t}\n\t\tstatic Type operate(const Type& left, const Type& right) {\n\t\t\treturn left + right;\n\t\t}\n\t};\n\n\ttemplate <class T>\n\tstruct Minimum {\n\t\tusing Type = T;\n\t\tstatic Type identity() {\n\t\t\treturn std::numeric_limits<Type>::max();\n\t\t}\n\t\tstatic Type operate(const Type& left, const Type& right) {\n\t\t\treturn std::min(left, right);\n\t\t}\n\t};\n\n\ttemplate <class T>\n\tstruct Maximum {\n\t\tusing Type = T;\n\t\tstatic Type identity() {\n\t\t\treturn std::numeric_limits<Type>::lowest();\n\t\t}\n\t\tstatic Type operate(const Type& left, const Type& right) {\n\t\t\treturn std::max(left, right);\n\t\t}\n\t};\n}\n\n/* 注意: コンストラクタの引数は size でない */\ntemplate <class Monoid>\nclass SegmentTree {\n\tusing T = typename Monoid::Type;\n\n\tconst int level_m;\t\t// 段数 - 1\n\tconst size_t size_m;\t// 1 << level_m\n\tstd::vector<T> arr_m;\n\n\tstatic T identity();\n\tstatic T operate(const T& left, const T& right);\n\tbool isValidIndex(size_t pos) const;\n\t\n\tstatic const int Default = -1;\n\npublic:\n\texplicit SegmentTree(int level);\n\texplicit SegmentTree(int level, const T& init_val);\n\tvoid construct();\n\n\tvoid update(size_t pos, const T& value);\n\tT query(size_t left, size_t right) const;\n\tT get(size_t pos) const;\n\n\ttemplate <class Function>\n\tint findBoundary(Function func);\n\n\tvoid debug(int level = Default, int cell_width = 4) const;\n};\n\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::identity() {\n\treturn Monoid::identity();\n}\n\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::operate(const T& left, const T& right) {\n\treturn Monoid::operate(left, right);\n}\n\ntemplate<class Monoid>\ninline bool SegmentTree<Monoid>::isValidIndex(size_t pos) const {\n\treturn pos >= 0 && pos < size_m;\n}\n\n/* 1 << level 要素の segment tree_m を作成 */\ntemplate<class Monoid>\nSegmentTree<Monoid>::SegmentTree(int level)\n\t: level_m(level), size_m(1 << level) {\n\tassert(level < 32);\n\tarr_m.resize(size_m * 2, identity());\n}\n\ntemplate<class Monoid>\ninline SegmentTree<Monoid>::SegmentTree(int level, const T& init_val)\n\t: level_m(level), size_m(1 << level) {\n\tassert(level < 32);\n\n\tarr_m.resize(size_m * 2, init_val);\n\tconstruct();\n}\n\n/*\n// 次が成立するように木を構築する, 初期化用 O(N)\n// arr[i] = operate(arr[i * 2], arr[i * 2 + 1])\n*/\ntemplate<class Monoid>\nvoid SegmentTree<Monoid>::construct() {\n\tfor (int i = size_m - 1; i > 0; --i) {\n\t\tarr_m[i] = operate(arr_m[i * 2], arr_m[i * 2 + 1]);\n\t}\n}\n\n/* pos 番目の要素を value に書き換える */\ntemplate<class Monoid>\nvoid SegmentTree<Monoid>::update(size_t pos, const T& value) {\n\tpos += size_m;\n\tarr_m[pos] = value;\n\tpos >>= 1;\n\twhile (pos > 0) {\n\t\tarr_m[pos] = operate(arr_m[pos * 2], arr_m[pos * 2 + 1]);\n\t\tpos >>= 1;\n\t}\n}\n\n/* [left, right) に存在する全要素の(指定した演算に関する)積をとる */\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::query(size_t left, size_t right) const {\n\tassert(left <= right);\n\n\tT tmp_left = identity();\n\tT tmp_right = identity();\n\tleft += size_m;\n\tright += size_m;\n\twhile (left < right) {\n\t\tif (left & 1) tmp_left = operate(tmp_left, arr_m[left++]);\n\t\tif (right & 1) tmp_right = operate(arr_m[--right], tmp_right);\n\t\tleft >>= 1;\n\t\tright >>= 1;\n\t}\n\n\treturn operate(tmp_left, tmp_right);\n}\n\n/* pos 番目の要素を直接取得 */\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::get(size_t pos) const {\n\treturn arr_m[size_m + pos];\n}\n\n/*\n// SegmentTree 上の二分探索 O(log N)\n// func(query(0, i - 1)) == true かつ func(query(0, i)) == false となる i を(1つ)返す (0 <= i <= size)\n*/\ntemplate<class Monoid>\ntemplate<class Function>\nint SegmentTree<Monoid>::findBoundary(Function func) {\n\tif (func(arr_m[1])) return size_m;\t\t// 全要素 true のときは先に除外\n\n\tT cumul = identity();\n\tint right = 1;\n\twhile (right < size_m) {\n\t\tright <<= 1;\n\t\tT cumul_next = operate(cumul, arr_m[right]);\n\t\tif (func(cumul_next)) {\n\t\t\t++right;\n\t\t\tcumul = cumul_next;\n\t\t}\n\t}\n\treturn right - size_m;\n}\n\n/* デバッグ出力用; level = -1 とすると全要素出力 */\ntemplate<class Monoid>\nvoid SegmentTree<Monoid>::debug(int level, int cell_width) const {\n\t/* 値 value を幅 max_length になるように成形して文字列化 */\n\tauto to_str_fixed = [](const T& value, int max_length) -> std::string {\n\t\tstd::ostringstream osst;\n\t\tosst << value;\n\n\t\tstd::string str = osst.str();\n\t\tstd::string output;\n\t\tif (str.size() > max_length) {\n\t\t\tfor (int i = 0; i < max_length; ++i) {\n\t\t\t\toutput += '#';\n\t\t\t}\n\t\t} else {\n\t\t\tconst int remain_length = max_length - str.size();\n\t\t\tconst int right_blank = remain_length / 2;\n\t\t\tconst int left_blank = remain_length - right_blank;\n\t\t\tfor (int i = 0; i < left_blank; ++i) {\n\t\t\t\toutput += ' ';\n\t\t\t}\n\t\t\toutput += str;\n\t\t\tfor (int i = 0; i < right_blank; ++i) {\n\t\t\t\toutput += ' ';\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t};\n\n\tif (level == Default) {\t\t\t// デフォルト値への対処\n\t\tlevel = level_m;\n\t}\n\n\tif (level > level_m) {\n\t\tlevel = level_m;\n\t}\n\n\tstd::vector<std::string> output_strs;\n\n\tfor (int lev = 0; lev <= level; ++lev) {\n\t\tstd::string output;\n\t\tconst int front = size_m >> lev;\n\n\t\toutput += '|';\n\t\tfor (int i = 0; i < (1 << (level - lev)); ++i) {\n\t\t\toutput += to_str_fixed(arr_m[front + i], cell_width);\n\t\t\toutput += '|';\n\t\t}\n\t\toutput_strs.push_back(output);\n\n\t\tcell_width = cell_width * 2 + 1;\n\t}\n\n\treverse(output_strs.begin(), output_strs.end());\n\tfor (const std::string& output : output_strs) {\n\t\tstd::cout << output << std::endl;\n\t}\n}\n\n#endif\n#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2020-06-24 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h&& j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DiscreteLog.h\"\n#include \"DynamicMod.h\"\n#include \"Exponential.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Geometric2D.h\"\n#include \"Geometric2DFloat.h\"\n#include \"Geometric3D.h\"\n#include \"Geometric3DFloat.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"Interpolation.h\"\n#include \"IntMod.h\"\n#include \"KDTree.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"List.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Random.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"RollingHash.h\"\n#include \"RuntimeMod.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Timer.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#include <cctype>\n#include <bitset>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n, k;\nint a[200000];\nint main() {\n\tcin >> n >> k;\n\tREP(i, 0, n) {\n\t\tcin >> a[i];\n\t\t--a[i];\n\t}\n\n\n\tMF base = 1;\n\tSegmentTree<Monoid::Sum<MF>> seg(18);\n\tSegmentTree<Monoid::Sum<MF>> cnt(18);\n\tMF sum = MF(k) * (k - 1) / 2 / 2;\n\tREP(i, 0, k) {\n\t\tseg.update(a[i], base);\n\t\tcnt.update(a[i], 1);\n\t}\n\n\tREP(i, k, n) {\n\t\tMF res = seg.query(0, a[i]);\n\t\tMF tmp = res / k / base;\n\t\tMF ttl = cnt.query(a[i], n);\n\t\tsum += tmp * (k - 1) / 2;\n\t\tsum += ttl - (1 - tmp) * (k - 1) / 2;\n\t\tbase *= MF(k) / (k - 1);\n\t\tseg.update(a[i], base);\n\t\tcnt.update(a[i], 1);\n\t}\n\n\tcout << sum << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n,k,p[200005],pw[200005],tr[2][200005],ans=0,alr,ty=0;\nconst int mod=998244353;\nint mypow(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint lowbit(int p){return p&-p;}\nint M(int x){return x>=mod?x-mod:x;}\nvoid modify(int p,int v)\n{\n\twhile(p<=n)\n\t{\n\t\ttr[ty][p]=M(tr[ty][p]+v);\n\t\tp+=lowbit(p);\n\t}\n}\nint ask(int p)\n{\n\t//printf(\"%d %d %d\\n\",p,ty,tr[0][2]);\n\tint ans=0;\n\twhile(p)\n\t{\n\t\tans=M(ans+tr[ty][p]);\n\t\t//printf(\"!%d %d %d\\n\",ans,p,tr[0][p]);\n\t\tp-=lowbit(p);\n\t}\n\treturn ans;\n}\nint main()\n{\n\tty=0;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tpw[0]=1;\n\tpw[1]=1ll*(k)*mypow(k-1,mod-2);\n\tfor(int i=2;i<=n;i++)pw[i]=1ll*pw[i-1]*pw[1]%mod;\n\tans=1ll*k*(k-1)/2%mod*mypow(2,mod-2)%mod;\n\talr=1ll*(k-1)*mypow(k,mod-2)%mod*mypow(2,mod-2)%mod;\n\t//printf(\"%d\\n\",ans);\n\tfor(int i=1;i<=k;i++)modify(p[i],1),ty=1,modify(p[i],1),ty=0;\n\tfor(int i=k+1;i<=n;i++)\n\t{\n\t\tans=(1ll*ans+1ll*ask(p[i])*alr%mod)%mod;\n\t\t//printf(\"%d %d %d %d %d %d\\n\",ask(p[i]),alr,ans,mypow(4,mod-2),ask(n),ask(p[i]));\n\t\tans=(1ll*ans-1ll*(ask(n)-ask(p[i])+mod)*alr%mod+mod)%mod;\n\t\t//printf(\"@%d\\n\",ans);\n\t\tty=1;\n\t\tans=(1ll*ans+ask(n)-ask(p[i]))%mod;\n\t\tmodify(p[i],1);\n\t\t//printf(\"@%d %d %d %d\\n\",ans,ask(p[i]),ask(n));\n\t\tty=0;\n\t\tmodify(p[i],pw[i-k]);\n\t\talr=1ll*alr*(k-1)%mod*mypow(k,mod-2)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\nconst char newl = '\\n';\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntemplate<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}\ntemplate<typename T=int>\nvector<T> read(size_t n){\n  vector<T> ts(n);\n  for(size_t i=0;i<n;i++) cin>>ts[i];\n  return ts;\n}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename T>\nclass BIT{\nprivate:\n  // \\sum_{j < i}  v[j]\n  T sum(int i){\n    T s(0);\n    for(int x=i;x>0;x-=(x&-x))\n      s+=bit[x];\n    return s;\n  }\npublic:\n  int n;\n  vector<T> bit;\n  BIT(int n_):n(n_+1),bit(n+1,0){}\n\n  // v[i] += a\n  void add(int i,T a){\n    for(int x=++i;x<=n;x+=(x&-x))\n      bit[x]+=a;\n  }\n  // \\sum_{l <= i < r} v[i]\n  T query(int l,int r){return sum(r)-sum(l);}\n\n  // min({x | sum(x) >= w})\n  int lower_bound(const T w){\n    if(w<=0) return 0;\n    T r=w;\n    int x=0,p=1;\n    while(p<n) p<<=1;\n    for(int k=p;k>0;k>>=1){\n      if(x+k<=n&&bit[x+k]<r){\n        r-=bit[x+k];\n        x+=k;\n      }\n    }\n    x++;\n    assert(sum(x-1)<w and sum(x)>=w);\n    return x;\n  }\n\n  // min({x | sum(x) > w})\n  int upper_bound(T w){return lower_bound(w+1);}\n};\n\n\ntemplate<typename M_>\nclass Enumeration{\n  using M = M_;\nprotected:\n  static vector<M> fact,finv,invs;\npublic:\n  static void init(int n){\n    n=min<decltype(M::mod)>(n,M::mod-1);\n\n    int m=fact.size();\n    if(n<m) return;\n\n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n\n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static M Fact(int n){\n    init(n);\n    return fact[n];\n  }\n  static M Finv(int n){\n    init(n);\n    return finv[n];\n  }\n  static M Invs(int n){\n    init(n);\n    return invs[n];\n  }\n\n  static M C(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n\n  // put n identical balls into k distinct boxes\n  static M H(int n,int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k);\n    return C(n+k-1,n);\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact=vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv=vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs=vector<M>();\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n,k;\n  cin>>n>>k;\n  auto ps=read(n);\n  for(int &p:ps) p--;\n\n  using M = Mint<int, 998244353>;\n  using E = Enumeration<M>;\n  E::init(3e5);\n\n  M ans{0};\n\n  // init\n  ans+=M(k*(k-1)/2)/M(2);\n\n  BIT<M> bit(n),cnt(n);\n  for(int i=0;i<k;i++){\n    int p=ps[i];\n    bit.add(p,M(1));\n    cnt.add(p,M(1));\n  }\n\n  M ofs{1};\n  M ratio=M(k-1)/M(k);\n  for(int i=k;i<n;i++){\n    ofs*=ratio;\n    int p=ps[i];\n    ans+=(bit.query(0,n))*ofs/M(2);\n    ans+=(cnt.query(p,n)-bit.query(p,n)*ofs);\n    bit.add(p,M(1)/ofs);\n    cnt.add(p,M(1));\n  }\n\n  // ans/=E::Fact(k).pow(n-k+1);\n  cout<<ans<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 998244353;\n\nint add(int a, int b)\n{\n    a += b;\n    if (a >= MOD)\n    {\n        return a - MOD;\n    }\n    if (a < 0)\n    {\n        return a + MOD;\n    }\n    return a;\n}\n\nint mul(int a, int b)\n{\n    return a * (ll) b % MOD;\n}\n\nint pw(int a, int b)\n{\n    int r = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            r = mul(r, a);\n        }\n        a = mul(a, a);\n        b /= 2;\n    }\n    return r;\n}\n\nint dv(int a, int b)\n{\n    return mul(a, pw(b, MOD - 2));\n}\n\nconst int N = (int) 2e5 + 7;\nint n;\nint k;\nint a[N];\nint enter[N];\nint val;\n\nint prob_swap(int i, int j)\n{\n    /// i < j\n    return dv(pw(val, enter[j] - enter[i]), 2);\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    freopen (\"input\", \"r\", stdin);\n\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        enter[i] = max(0, i - k);\n    }\n    val = dv(k - 1, k);\n    int invs = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = i + 1; j <= n; j++)\n        {\n            if (a[i] < a[j])\n            {\n                invs = add(invs, prob_swap(i, j));\n            }\n            else\n            {\n                invs = add(invs, add(1, -prob_swap(i, j)));\n            }\n        }\n    }\n    cout << invs << \"\\n\";\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <cstdio>\n#define rep(i, n) for(int i=0; i<n; ++i)\nusing namespace std;\n\nconst unsigned int mod = 998244353;\n\nstruct mint {\n  unsigned int x;\n  mint():x(0) {}\n  mint(int64_t x_) {\n    int64_t v = int64_t(x_ % mod);\n    if(v < 0) v += mod;\n    x = (unsigned int)v;\n  }\n  static mint row(int v) {\n    mint v_;\n    v_.x = v;\n    return v_;\n  }\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    u_int64_t z = x;\n    z *= a.x;\n    x = (unsigned int)(z % mod);\n    return *this;\n  }\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  friend bool operator==(const mint &a, const mint &b) {return a.x == b.x;}\n  friend bool operator!=(const mint &a, const mint &b) {return a.x != b.x;}\n  mint &operator++() {\n    x++;\n    if(x == mod) x = 0;\n    return *this;\n  }\n  mint &operator--() {\n    if(x == 0) x = mod;\n    x--;\n    return *this;\n  }\n  mint operator++(int) {\n    mint result = *this;\n    ++*this;\n    return result;\n  }\n  mint operator--(int) {\n    mint result = *this;\n    --*this;\n    return result;\n  }\n  mint pow(int64_t t) const {\n    mint x_ = *this, r = 1;\n    while(t) {\n      if(t&1) r *= x_;\n      x_ *= x_;\n      t >>= 1;\n    }\n    return r;\n  }\n  //for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) {return mint(*this) /= a;}\n};\n\n#define N 200100\n\n//head\n\nint n, k;\nint p[N];\nmint u[N], _u[N];\nmint ans;\nmint bit1[N], bit2[N];\nvoid add(int i, mint x, mint *bit) {\n  while(i <= n) {\n    bit[i] += x;\n    i += i&-i;\n  }\n}\nmint sum(int i, mint *bit) {\n  mint res;\n  while(i) {\n    res += bit[i];\n    i &= i-1;\n  }\n  return res;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  rep(i, n) scanf(\"%d\", p+i);\n  const mint g = mint(k-1)/k, _g = g.inv(), gg = mint(2).inv();\n  u[0] = _u[0] = 1;\n  rep(i, n-1) {\n    if(i < k-1) {\n      u[i+1] = u[i];\n      _u[i+1] = _u[i];\n    }\n    else {\n      u[i+1] = u[i]*g;\n      _u[i+1] = _u[i]*_g;\n    }\n  }\n  rep(i, n) {\n    ans += sum(p[i], bit1)*gg*u[i];\n    ans -= sum(p[i], bit2)-i;\n    ans -= (sum(n, bit1)-sum(p[i], bit1))*gg*u[i];\n    add(p[i], _u[i], bit1);\n    add(p[i], 1, bit2);\n  }\n  printf(\"%d\\n\", ans.x);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nclass Add_Segment_Tree {\n\tvector<long long int>v;\n\tlong long int ret;\n\tint num;\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = Update(place * 2) + Update(place * 2 + 1);\n\t\treturn v[place];\n\t}\npublic:\n\tAdd_Segment_Tree(int n) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2)num *= 2;\n\t\tv.resize(num, 0);\n\t}\n\tvoid Add(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] += num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tv[place] = v[place * 2] + v[place * 2 + 1];\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid TopDown() {\n\t\tUpdate(1);\n\t}\n\tlong long int Sum(int a, int b) {\n\t\tret = 0;\n\t\tb++;\n\t\tfor (a += num / 2, b += num / 2; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1)ret += v[a++];\n\t\t\tif (b & 1)ret += v[--b];\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tlong long int ans = 0;\n\tvector<int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tAdd_Segment_Tree asg(N);\n\tAdd_Segment_Tree num(N);\n\tvector<long long int>by(N - K + 2, 1);\n\tby.back() = 1;\n\tfor (int i = by.size() - 2; i >= 0; i--) {\n\t\tby[i] = by[i + 1] * (K - 1);\n\t\tby[i] %= MOD;\n\t\tby[i] *= power(K, MOD - 2, MOD);\n\t\tby[i] %= MOD;\n\t}\n\tans += (K - 1)*K / 2 * power(2, MOD - 2, MOD);\n\tans %= MOD;\n\tfor (int i = 0; i < K; i++) {\n\t\tasg.Add(v[i], by[1], true);\n\t\tnum.Add(v[i], 1, true);\n\t}\n\tfor (int i = K; i < N; i++) {\n\t\tans -= asg.Sum(v[i] + 1, N)*power(by[i - K + 2], MOD - 2, MOD) % MOD*power(2, MOD - 2, MOD) % MOD;\n\t\tans += num.Sum(v[i] + 1, N);\n\t\tans += asg.Sum(1, v[i] - 1)*power(by[i - K + 2], MOD - 2, MOD) % MOD*power(2, MOD - 2, MOD) % MOD;\n\t\tnum.Add(v[i], 1, true);\n\t\tasg.Add(v[i], by[i - K + 2], true);\n\t\tans += MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nconstexpr int64 P = 998244353;\n\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 raw_x) : x(raw_x) {\n    if (x >= P || x < 0) {\n    x %= P;\n    if (x < 0) x += P;\n  }\n}\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\nostream& operator<<(ostream& s, const FiniteField& x) { s << x.Value(); return s; }\n\ntemplate <typename T>\nclass SegmentTree {\n private:\n  function<T(T, T)> merge_fn;\n  T empty_value;\n  vector<T> nodes;\n  int num_nodes;\n\n  // Returns the fold of overwrap between [node_l, node_r) and [l, r).\n  // nodes[node_index] needs to correspond to [node_l, node_r).\n  T GetRangeInternal(int node_index, int node_l, int node_r, int l, int r) {\n    if (node_r <= l || r <= node_l) return empty_value;\n    if (l <= node_l && node_r <= r) return nodes[node_index];\n    int node_m = (node_l + node_r) / 2;\n    return merge_fn(\n        GetRangeInternal(2 * node_index, node_l, node_m, l, r),\n        GetRangeInternal(2 * node_index + 1, node_m, node_r, l, r));\n  }\n\n public:\n  // Arguments:\n  // in_merge: The function to merge two values. It should be a monoid.\n  // in_empty_value: The identity of the monoid.\n  // xs: The initial values.\n  SegmentTree(\n      function<T(T, T)> merge_fn, T empty_value, const vector<T>& xs) :\n          merge_fn(merge_fn), empty_value(empty_value) {\n    int n = xs.size();\n    num_nodes = 1;\n    while (num_nodes < n) num_nodes *= 2;\n    num_nodes *= 2;\n    nodes = vector<T>(num_nodes, empty_value);\n    for (int i = 0; i < xs.size(); ++i) {\n      nodes[num_nodes / 2 + i] = xs[i];\n    }\n    for (int i = num_nodes / 2 - 1; i >= 1; i--) {\n      nodes[i] = merge_fn(nodes[2 * i], nodes[2 * i + 1]);\n    }\n  }\n\n  // Updates the i-th element to x.\n  void Update(int i, T x) {\n    nodes[num_nodes / 2 + i] = x;\n    for (int cur = (num_nodes / 2 + i) / 2; cur > 0; cur /= 2) {\n      nodes[cur] = merge_fn(nodes[2 * cur], nodes[2 * cur + 1]);\n    }\n  }\n\n  // Returns the value of the range [l, r) merged by merge_fn.\n  T GetRange(int l, int r) {\n    return GetRangeInternal(1, 0, num_nodes / 2, l, r);\n  }\n\n  T Get(int i) {\n    return nodes[num_nodes / 2 + i];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  const FiniteField half = FiniteField(1) / FiniteField(2);\n\n  auto add_fn = [](FiniteField x1, FiniteField x2) -> FiniteField {\n    return x1 + x2;\n  };\n\n  int n, k;\n  cin >> n >> k;\n\n  FiniteField p = FiniteField(k - 1) / FiniteField(k);\n\n  vector<FiniteField> powers(n + 2);\n  powers[0] = 1;\n  for (int i = 1; i <= n + 1; i++) {\n    powers[i] = powers[i - 1] * p;\n  }\n\n  vector<int> ps(n);\n  vector<int> v_to_position(n);\n  for (int i = 0; i < n; i++) {\n    cin >> ps[i];\n    ps[i]--;\n    v_to_position[ps[i]] = i;\n  }\n\n  FiniteField ans = 0;\n  SegmentTree<FiniteField> tree1(add_fn, 0, vector<FiniteField>(n, 0));\n  SegmentTree<FiniteField> tree2(add_fn, 0, vector<FiniteField>(n, 0));\n  for (int i = 0; i < n; i++) {\n    int position = v_to_position[i];\n    // cout << \"position: \" << position << endl;\n\n    int s = max(position + 1, k);\n    if (s >= n) {\n      tree1.Update(position, 1);\n      tree2.Update(position, powers[position]);\n      continue;\n    }\n\n    int count = n - s;\n    FiniteField base = half * p * (FiniteField(1) - powers[count]) / (FiniteField(1) - p);\n\n    // cout << base * FiniteField(4) << endl;\n\n    base += tree1.GetRange(s, n);\n    base -= tree2.GetRange(s, n) / powers[s - 1];\n\n    ans += base;\n\n    tree1.Update(position, 1);\n    tree2.Update(position, powers[position]);\n\n    // cout << base * FiniteField(4) << endl;\n  }\n\n  // cout << half * 2 << endl;\n  // cout << half * FiniteField(k) << endl;\n  // cout << half * FiniteField(k) * FiniteField(k - 1) << endl;\n  ans += half * half * FiniteField(k) * FiniteField(k - 1);\n  // cout << ans * FiniteField(4) << endl;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#line 2 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/other/template.hpp\"\n#define _CRT_SECURE_NO_WARNINGS\n#pragma target(\"avx2\")\n#pragma optimize(\"O3\")\n#pragma optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef unsigned int uint;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef std::pair<int, int> P;\ntypedef std::pair<lint, lint> LP;\nconstexpr int INF = INT_MAX/2;\nconstexpr lint LINF = LLONG_MAX/2;\nconstexpr double eps = DBL_EPSILON;\nconstexpr double PI=3.141592653589793238462643383279;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\ntemplate<typename T>\nT mypow(T a, lint b) {\n\tT res(1);\n\twhile(b){\n\t\tif(b&1)res*=a;\n\t\ta*=a;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nlint modpow(lint a, lint b, lint m) {\n\tlint res(1);\n\twhile(b){\n\t\tif(b&1){\n\t\t\tres*=a;res%=m;\n\t\t}\n\t\ta*=a;a%=m;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size()){\n\t\tstd::cout << vec[i];\n\t\tstd::cout<<(i==(int)vec.size()-1?\"\\n\":\" \");\n\t}\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = std::prev(r);\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nLP extGcd(lint a,lint b) {\n\tif(b==0)return {1,0};\n\tLP s=extGcd(b,a%b);\n\tstd::swap(s.first,s.second);\n\ts.second-=a/b*s.first;\n\treturn s;\n}\nLP ChineseRem(const lint& b1,const lint& m1,const lint& b2,const lint& m2) {\n\tlint p=extGcd(m1,m2).first;\n\tlint tmp=(b2-b1)*p%m2;\n\tlint r=(b1+m1*tmp+m1*m2)%(m1*m2);\n\treturn std::make_pair(r,m1*m2);\n}\ntemplate<typename F>\ninline constexpr decltype(auto) lambda_fix(F&& f){\n\treturn [f=std::forward<F>(f)](auto&&... args){\n\t\treturn f(f,std::forward<decltype(args)>(args)...);\n\t};\n}\n#line 3 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/algebraic/DynamicModInt.hpp\"\nclass DynamicModInt {\n\tlint value;\npublic:\n\tstatic unsigned int modulo;\n\tDynamicModInt() : value(0) {}\n\ttemplate<typename T>\n\tDynamicModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tstatic inline void setMod(const unsigned int& mod){modulo=mod;}\n\tinline DynamicModInt inv()const{return mypow(*this,modulo-2);}\n\tinline operator int()const { return value; }\n\tinline DynamicModInt& operator+=(const DynamicModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt operator++(int){\n\t\tDynamicModInt res=*this;\n\t\t--*this;\n\t\treturn res;\n\t}\n\tinline DynamicModInt operator-()const {\n\t\treturn DynamicModInt(0) -= *this;\n\t}\n\tinline DynamicModInt& operator-=(const DynamicModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt operator--(int){\n\t\tDynamicModInt res=*this;\n\t\t--*this;\n\t\treturn res;\n\t}\n\tinline DynamicModInt& operator*=(const DynamicModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt& operator/=(const DynamicModInt& rhs) {\n\t\treturn *this*=rhs.inv();\n\t}\n\ttemplate<typename T> DynamicModInt operator+(const T& rhs)const { return DynamicModInt(*this) += rhs; }\n\ttemplate<typename T> DynamicModInt& operator+=(const T& rhs) { return operator+=(DynamicModInt(rhs)); }\n\ttemplate<typename T> DynamicModInt operator-(const T& rhs)const { return DynamicModInt(*this) -= rhs; }\n\ttemplate<typename T> DynamicModInt& operator-=(const T& rhs) { return operator-=(DynamicModInt(rhs)); }\n\ttemplate<typename T> DynamicModInt operator*(const T& rhs)const { return DynamicModInt(*this) *= rhs; }\n\ttemplate<typename T> DynamicModInt& operator*=(const T& rhs) { return operator*=(DynamicModInt(rhs)); }\n\ttemplate<typename T> DynamicModInt operator/(const T& rhs)const { return DynamicModInt(*this) /= rhs; }\n\ttemplate<typename T> DynamicModInt& operator/=(const T& rhs) { return operator/=(DynamicModInt(rhs)); }\n};\nunsigned int DynamicModInt::modulo=1000000007;\nstd::istream& operator>>(std::istream& ist, DynamicModInt& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\n#line 4 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/algebraic/StaticModInt.hpp\"\ntemplate<unsigned int modulo>\nclass StaticModInt {\n\tlint value;\npublic:\n\tStaticModInt() : value(0) {}\n\ttemplate<typename T>\n\tStaticModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline StaticModInt inv()const{return mypow(*this,modulo-2);}\n\tinline operator int()const { return value; }\n\tinline StaticModInt& operator+=(const StaticModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline StaticModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline StaticModInt operator++(int){\n\t\tStaticModInt res=*this;\n\t\t--*this;\n\t\treturn res;\n\t}\n\tinline StaticModInt operator-()const {\n\t\treturn StaticModInt(0) -= *this;\n\t}\n\tinline StaticModInt& operator-=(const StaticModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline StaticModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline StaticModInt operator--(int){\n\t\tStaticModInt res=*this;\n\t\t--*this;\n\t\treturn res;\n\t}\n\tinline StaticModInt& operator*=(const StaticModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline StaticModInt& operator/=(const StaticModInt& rhs) {\n\t\treturn *this*=rhs.inv();\n\t}\n\ttemplate<typename T> StaticModInt operator+(const T& rhs)const { return StaticModInt(*this) += rhs; }\n\ttemplate<typename T> StaticModInt& operator+=(const T& rhs) { return operator+=(StaticModInt(rhs)); }\n\ttemplate<typename T> StaticModInt operator-(const T& rhs)const { return StaticModInt(*this) -= rhs; }\n\ttemplate<typename T> StaticModInt& operator-=(const T& rhs) { return operator-=(StaticModInt(rhs)); }\n\ttemplate<typename T> StaticModInt operator*(const T& rhs)const { return StaticModInt(*this) *= rhs; }\n\ttemplate<typename T> StaticModInt& operator*=(const T& rhs) { return operator*=(StaticModInt(rhs)); }\n\ttemplate<typename T> StaticModInt operator/(const T& rhs)const { return StaticModInt(*this) /= rhs; }\n\ttemplate<typename T> StaticModInt& operator/=(const T& rhs) { return operator/=(StaticModInt(rhs)); }\n};\ntemplate<unsigned int modulo>\nstd::istream& operator>>(std::istream& ist, StaticModInt<modulo>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\n#line 3 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/data-structure/BIT.hpp\"\ntemplate<typename T>\nclass BIT {\n\tint n;\n\tstd::vector<T> bit;\nprivate:\n\tT query(int a) {\n\t\tT cnt = 0;\n\t\twhile (a > 0) {\n\t\t\tcnt += bit[a];\n\t\t\ta -= a & -a;\n\t\t}\n\t\treturn cnt;\n\t}\npublic:\n\tBIT(int n) :n(n) {bit.resize(n + 1);}\n\tvoid add(int a, T x) {\n\t\ta++;\n\t\twhile (a <= n) {\n\t\t\tbit[a] += x;\n\t\t\ta += a & -a;\n\t\t}\n\t}\n\tT query(int l, int r) {return query(r) - query(l);}\n\tvoid clear() {bit.assign(n + 1, 0);}\n\tint lower_bound(T x){\n\t\tint p=0,k=1;\n\t\twhile(k*2<=n)k*=2;\n\t\twhile(k>0){\n\t\t\tif(p+k<=n&&bit[p+k]<x){\n\t\t\t\tx-=bit[p+k];\n\t\t\t\tp+=k;\n\t\t\t}\n\t\t\tk/=2;\n\t\t}\n\t\treturn p;\n\t}\n\tint upper_bound(T x){\n\t\tint p=0,k=1;\n\t\twhile(k*2<=n)k*=2;\n\t\twhile(k>0){\n\t\t\tif(p+k<=n&&bit[p+k]<=x){\n\t\t\t\tx-=bit[p+k];\n\t\t\t\tp+=k;\n\t\t\t}\n\t\t\tk/=2;\n\t\t}\n\t\treturn p;\n\t}\n};\n#line 4 \"main.cpp\"\nusing ModInt=StaticModInt<998244353>;\nint N,K,p[200010];\nint main(){\n\tstd::cin>>N>>K;\n\trep(i,N)std::cin>>p[i];\n\tModInt ans=ModInt(K)*(K-1)/4;\n\n\tstd::vector<int> vec(N+1);\n\trep(i,K)vec[p[i]]++;\n\tREP(i,N)vec[i]+=vec[i-1];\n\tModInt co=ModInt(K-1)/K,now=co;\n\tfor(int i=K;i<N;i++){\n\t\tans+=(1-now/2)*(vec[N]-vec[p[i]]);\n\t\tans+=now/2*vec[p[i]];\n\t\tnow*=co;\n\t}\n\n\tBIT<ModInt> bit1(N+1),bit2(N+1);\n\tnow=mypow(co,K);\n\tModInt co2=ModInt(1)/co,now2=mypow(co2,K)/2;\n\tfor(int i=K;i<N;i++){\n\t\tans+=bit1.query(0,p[i])*now;\n\t\tans+=bit2.query(p[i],N+1)*now;\n\t\tbit1.add(p[i],now2);\n\t\tbit2.add(p[i],-now2);\n\t\tnow*=co;now2*=co2;\n\t}\n\n\tbit1.clear();\n\tfor(int i=K;i<N;i++){\n\t\tans+=bit1.query(p[i],N+1);\n\t\tbit1.add(p[i],1);\n\t}\n\tstd::cout<<ans<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n#define RREP(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T>\nusing reverse_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nusing mint = modint998244353;\n\nstruct S{\n    ll num;\n    mint psum;\n};\nS e(){ return S{0, 0}; }\nS op(S x, S y){ return S{x.num + y.num, x.psum + y.psum}; }\n\nint main(){\n    ll n, k;\n    cin >> n >> k;\n\n    vector<ll> p(n);\n    REP(i, n){\n        cin >> p.at(i);\n        p.at(i)--;\n    }\n\n    const mint q = mint(k - 1) / mint(k);\n    const mint qinv = q.inv();\n\n    // cerr << \"q=\" << q.val() << \", qinv=\" << qinv.val() << endl;\n\n    segtree<S, op, e> st(n);\n\n    mint ans = 0;\n\n    REP(i, n){\n        const ll pi = p.at(i);\n        const ll fi = max(i - k + 1, 0LL);\n\n        const auto sd = st.prod(0, pi);\n        mint tmp1 = q.pow(fi) * sd.psum / 2;\n\n        const auto su = st.prod(pi + 1, n);\n        mint tmp2 = su.num - q.pow(fi) * su.psum / 2;\n\n        mint tmp = tmp1 + tmp2;\n\n        // cerr << \"i=\" << i << \", tmp=\" << tmp.val() << \", tmp1=\" << tmp1.val() << \", tmp2=\" << tmp2.val() << endl;\n        ans += tmp;\n\n        st.set(pi, S{1, qinv.pow(fi)});\n    }\n\n    cout << ans.val() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <chrono>\n//#pragma GCC optimize(\"Ofast\")\nusing namespace std;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\n#define ALL(a) a.begin(), a.end()\n#define fi first\n#define se second\n\nusing ll = long long;\nusing vec = vector<ll>;\nusing mat = vector<vec>;\n\nll N,M,H,W,Q,K,A,B;\nstring S;\ntypedef pair<ll, ll> P;\nconst ll INF = (1LL<<60);\n\ntemplate <unsigned long long mod > class modint{\npublic:\n    ll x;\n    constexpr modint(){x = 0;}\n    constexpr modint(ll _x) : x((_x < 0 ? ((_x += (LLONG_MAX / mod) * mod) < 0 ? _x + (LLONG_MAX / mod) * mod : _x) : _x)%mod){}\n    constexpr void set_raw(ll _x){\n        //_x in [0, mod)\n        x = _x;\n    }\n    constexpr modint operator-(){\n        return x == 0 ? 0 : mod - x;\n    }\n    constexpr modint& operator+=(const modint& a){\n        if((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    constexpr modint operator+(const modint& a) const{\n        return modint(*this) += a;\n    }\n    constexpr modint& operator-=(const modint& a){\n        if((x -= a.x) < 0) x += mod;\n        return *this;\n    }\n    constexpr modint operator-(const modint& a) const{\n        return modint(*this) -= a;\n    }\n    constexpr modint& operator*=(const modint& a){\n        (x *= a.x)%=mod;\n        return *this;\n    }\n    constexpr modint operator*(const modint& a) const{\n        return modint(*this) *= a;\n    }\n    constexpr modint pow(unsigned long long pw) const{\n        modint res(1), comp(*this);\n        while(pw){\n            if(pw&1) res *= comp;\n            comp *= comp;\n            pw >>= 1;\n        }\n        return res;\n    }\n    //以下、modが素数のときのみ\n    constexpr modint inv() const{\n        return modint(*this).pow(mod - 2);\n    }\n    constexpr modint& operator/=(const modint &a){\n        (x *= a.inv().x)%=mod;\n        return *this;\n    }\n    constexpr modint operator/(const modint &a) const{\n        return modint(*this) /= a;\n    }\n};\n#define mod1 998244353\nusing mint = modint<mod1>;\n\nostream& operator<<(ostream& os, const mint& a){\n    os << a.x;\n    return os;\n}\nusing vm = vector<mint>;\n\ntemplate <class T> class BIT {\n    //T has operator \"+=\" and can be initialized with 0.\n    unsigned int n;\n    vector<T> bitree;\npublic:\n    BIT(unsigned long _n) : bitree(_n + 1, 0) {\n        n = _n;\n    }\n\n    void add(int id, T x) {\n        ++id;\n        while (id <= n) {\n            bitree[id] += x;\n            id += id & -id;\n        }\n    }\n\n    T sum(int id) {\n        ++id;\n        T temp(0);\n        while (id > 0) {\n            temp += bitree[id];\n            id -= id & -id;\n        }\n        return temp;\n    }\n};\n\nint main() {\n    cin>>N>>K;\n    mint p(K - 1), ppow(1), inv2(mint(2).inv()), res(0);\n    p /= K;\n    res += inv2 * (K * (K - 1) / 2);\n    reps(i, 1, N - K + 1) {\n        ppow *= p;\n        res += ppow * (N - i) * inv2;\n    }\n    //cout<<res<<endl;\n    BIT<mint> num(N), p_fi(N);\n    ppow = 1;\n    rep(i, N){\n        cin>>A;\n        --A;\n        res += num.sum(N - 1) - num.sum(A);\n        num.add(A, 1);\n        if(i >= K) ppow *= p;\n        res -= ppow * (p_fi.sum(N - 1) - p_fi.sum(A));\n        p_fi.add(A, ppow.inv());\n    }\n    cout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<61;\nint iinf=1<<30;\ndouble pi=3.14159265358979323846;\ndouble pi2=pi/2.0;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,0,-1,0};\nint dw[4]={0,1,0,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<0)a=-a;\n    if(b<0)b=-b;\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\n\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder {\nnamespace internal {\n\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n   \n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n   \n    unsigned int umod() const { return _m; }\n   \n    unsigned int mul(unsigned int a, unsigned int b) const {\n        \n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    \n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;\n        \n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n   \n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n    int num_vertices() { return _n; }\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n    \n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder {\nnamespace internal {\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n#else\ntemplate <class T> using is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n#endif\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n}\n}\n#endif\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\nnamespace internal {\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n}\n}\n#endif\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_e[30];\n    if (first) {\n        first = false;\n        mint es[30], ies[30];\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            \n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_ie[30];\n    if (first) {\n        first = false;\n        mint es[30], ies[30];\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            \n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    static constexpr unsigned long long MOD1 = 754974721;\n    static constexpr unsigned long long MOD2 = 167772161;\n    static constexpr unsigned long long MOD3 = 469762049;\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        \n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n    return c;\n}\n}\n#endif\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n  private:\n    int _n;\n    \n    std::vector<int> parent_or_size;\n};\n}\n#endif\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n    void change(int p,T x){\n        add(p,x-data[p]);\n    }\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n  private:\n    int _n;\n    std::vector<U> data;\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\nstruct fenwickd{\nprivate:\n    ll u;\n    vector<double> bit;\npublic:\n    fenwickd(ll n){\n        u=1;while(u<n)u*=2;\n        bit.resize(u+10,0);\n        \n    }\n    void add(ll n,double x){\n        ll i=n;\n        bit[i]+=x;\n        //bit[i]%=mod;\n        while(i<u){\n            i+=i&(-i);\n            bit[i]+=x;\n            //bit[i]%=mod;\n        }\n\n    }\n    void change(ll n,double x){\n        add(n,x-bit[n]);\n    }\n    double sum(ll n){\n        ll i=n;\n        double ret=0;\n        while(i>0){\n            ret+=bit[i];\n            i-=i&(-i);\n            //ret%=mod;\n        }\n        return ret;\n    }\n    ll lb(double w){\n        if(w<=0)return 0;\n        ll x=0;\n        for(ll k=u;k>0;k/=2){\n            if(x+k<=u&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n};\n//vector<BIT> b(26,n+1);\n}\n#endif\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n}\n#endif\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder {\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    \n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        \n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n        long long u1 = (m1 / g);\n        \n        if ((r1 - r0) % g) return {0, 0};\n        \n        long long x = (r1 - r0) / g % u1 * im % u1;\n        \n        r0 += x * m0;\n        m0 *= u1;\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n}\n#endif\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}\n#endif\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n       \n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                \n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    \n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                \n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}\n#endif\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n  private:\n    internal::scc_graph internal;\n};\n}\n#endif\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n}\n#endif\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n    induce(lms);\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n}\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\ntemplate <class T> std::vector<int> z_algo(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\nstd::vector<int> z_algo(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algo(s2);\n}\n}\n#endif\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n    void add(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satis() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n}\n#endif\nusing namespace atcoder;\n//dsu d(n) d.merge d.same d.leader d.size vector<vector<int>> d.groups()\n//fenwick_tree<ll> fw(n) fw.add(p,x) fw.sum(l,r) [l,r)\n// pll crt(vector<ll> r,vector<ll> m)   x≡y (modz) {y,z}\n// floor_sum(n,m,a,b) Σi=0:i=n-1 floor((a*i+b)/m) O(log)\n// mf_graph<int/ll> graph(n) int graph.add_edge(from,to,cap) (the number of edge) graph.flow(s,t)\n//graph.flow(s,t,flow_limit) if(allcap==1) O(min(n^(2/3)m,m^(3/2)) else O(mnn)\n//graph.change_cap(i,new_cap,new_flow) (can change)\n//mf_graph<cap>::edge graph.get_edge(i) from,to,cap,flow\n//vector<mf_graph<cap>::edge> graph.edges()\n//mcf_graph<cap,cost> graph(n) int graph.add_edge(from,to,cap,cost) (the number of edge)\n//pair<cap,cost> graph.flow(s,t,(flow_limit)) vector<pair<cap,cost>> graph.slope(s,t) ??\n//O(FV^2)or O(FElogV)\n// using mint=static_modint<mod> or modint998244353; int x.val();\n//scc_graph g(n) g.add_edge(from,to) vector<vector<int>> v=g.scc();\n//vector<ll> convolution<prime>(vector<ll> a,vector<ll> b)\n//vector<ll> convolution_ll(vector<ll> a,vector<ll> b) no mod\n//two_sat ts(n) ts.add(i,bool f,j,bool g)\n//bool ts.satis() vector<bool> ts.answer()\n//vector<int> suffix_array(s) suffix_array<int>(vector<int> s)\n//vector<int> lcp_array(or <int>)(s or vector<int> s,vector<int> sa)\n// vector<int> z_algo(or <int>)(s or vector<int> s)\n//segtree<S,op,e> seg(n or vector<S> v)\n// seg.set(place,S x) S seg.get(place) S seg.prod(l,r) op(a[l],...,a[r-1])\n//S seg.all_prod() op(a[0],...,a[n-1])\n//int seg.max_right<f>(l) define bool f(S x) output one r binary search\n//int seg.min_left<f>(r)\n// ST...op,e(),(f)\n//lazy_segtree<S,op,e,F,mapping,composition,id> seg(n or vector<T> v);\n// set get prod all_prod max_right min_left\n// seg.apply(place,T x) a[p]=op(a[p],x) seg.apply(l,r,T x) l~r-1 a[i]=op(a[i],x)\nusing mint=static_modint<998244353>;\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n  ll n,k;cin>>n>>k;\n  ll a[n];vector<pll> v;\n  rep(i,0,n){cin>>a[i];v.push_back({a[i],i});}\n    fenwick_tree<mint> fw(n),fw2(n);\nsort(v.begin(),v.end(),greater<pll>());\n mint ans=0;\n  mint l=k-1;\n  (l/=k);\n  ll lk=l.val();\nrep(i,0,n){\n    ll num=v[i].second;\n ll num2=max(num,k-1);\n  ll be=beki(lk,num2,mod2);\n  ll be2=gyaku(be,mod2);\n  mint wa=fw.sum(num,n);\n  mint wa2=fw2.sum(0,num);\n  mint bee=be,bee2=be2;\n  ans+=bee*wa2+bee2*wa;\n  fw.add(num,bee);\n  fw2.add(num,bee2);\n  }\n  ans/=2;\n  cout<<ans.val()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 998244353;\n\nint add(int a, int b)\n{\n    a += b;\n    if (a >= MOD)\n    {\n        return a - MOD;\n    }\n    if (a < 0)\n    {\n        return a + MOD;\n    }\n    return a;\n}\n\nint mul(int a, int b)\n{\n    return a * (ll) b % MOD;\n}\n\nint pw(int a, int b)\n{\n    int r = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            r = mul(r, a);\n        }\n        a = mul(a, a);\n        b /= 2;\n    }\n    return r;\n}\n\nint dv(int a, int b)\n{\n    return mul(a, pw(b, MOD - 2));\n}\n\nconst int N = (int) 2e5 + 7;\nint n;\nint k;\nint a[N];\nint enter[N];\nint kek;\nint val[N];\nint inv_val[N];\nint inv2;\n\nint prob_swap(int i, int j)\n{\n    /// i < j\n    return mul(inv2, mul(val[j], inv_val[i]));\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> k;\n    inv2 = dv(1, 2);\n    kek = dv(k - 1, k);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        enter[i] = max(0, i - k);\n        val[i] = pw(kek, enter[i]);\n        inv_val[i] = dv(1, val[i]);\n    }\n    int invs = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = i + 1; j <= n; j++)\n        {\n            if (a[i] < a[j])\n            {\n                invs = add(invs, prob_swap(i, j));\n            }\n            else\n            {\n                invs = add(invs, add(1, -prob_swap(i, j)));\n            }\n        }\n    }\n    cout << invs << \"\\n\";\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<61;\nint iinf=1<<30;\ndouble pi=3.14159265358979323846;\ndouble pi2=pi/2.0;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,0,-1,0};\nint dw[4]={0,1,0,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<0)a=-a;\n    if(b<0)b=-b;\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\n\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder {\nnamespace internal {\n\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n   \n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n   \n    unsigned int umod() const { return _m; }\n   \n    unsigned int mul(unsigned int a, unsigned int b) const {\n        \n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    \n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;\n        \n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n   \n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n    int num_vertices() { return _n; }\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n    \n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder {\nnamespace internal {\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n#else\ntemplate <class T> using is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n#endif\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n}\n}\n#endif\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\nnamespace internal {\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n}\n}\n#endif\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_e[30];\n    if (first) {\n        first = false;\n        mint es[30], ies[30];\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            \n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_ie[30];\n    if (first) {\n        first = false;\n        mint es[30], ies[30];\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            \n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    static constexpr unsigned long long MOD1 = 754974721;\n    static constexpr unsigned long long MOD2 = 167772161;\n    static constexpr unsigned long long MOD3 = 469762049;\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        \n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n    return c;\n}\n}\n#endif\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n  private:\n    int _n;\n    \n    std::vector<int> parent_or_size;\n};\n}\n#endif\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n    void change(int p,T x){\n        add(p,x-data[p]);\n    }\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n  private:\n    int _n;\n    std::vector<U> data;\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\nstruct fenwickd{\nprivate:\n    ll u;\n    vector<double> bit;\npublic:\n    fenwickd(ll n){\n        u=1;while(u<n)u*=2;\n        bit.resize(u+10,0);\n        \n    }\n    void add(ll n,double x){\n        ll i=n;\n        bit[i]+=x;\n        //bit[i]%=mod;\n        while(i<u){\n            i+=i&(-i);\n            bit[i]+=x;\n            //bit[i]%=mod;\n        }\n\n    }\n    void change(ll n,double x){\n        add(n,x-bit[n]);\n    }\n    double sum(ll n){\n        ll i=n;\n        double ret=0;\n        while(i>0){\n            ret+=bit[i];\n            i-=i&(-i);\n            //ret%=mod;\n        }\n        return ret;\n    }\n    ll lb(double w){\n        if(w<=0)return 0;\n        ll x=0;\n        for(ll k=u;k>0;k/=2){\n            if(x+k<=u&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n};\n//vector<BIT> b(26,n+1);\n}\n#endif\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n}\n#endif\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder {\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    \n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        \n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n        long long u1 = (m1 / g);\n        \n        if ((r1 - r0) % g) return {0, 0};\n        \n        long long x = (r1 - r0) / g % u1 * im % u1;\n        \n        r0 += x * m0;\n        m0 *= u1;\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n}\n#endif\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}\n#endif\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n       \n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                \n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    \n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                \n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}\n#endif\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n  private:\n    internal::scc_graph internal;\n};\n}\n#endif\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n}\n#endif\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n    induce(lms);\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n}\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\ntemplate <class T> std::vector<int> z_algo(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\nstd::vector<int> z_algo(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algo(s2);\n}\n}\n#endif\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n    void add(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satis() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n}\n#endif\nusing namespace atcoder;\n//dsu d(n) d.merge d.same d.leader d.size vector<vector<int>> d.groups()\n//fenwick_tree<ll> fw(n) fw.add(p,x) fw.sum(l,r) [l,r)\n// pll crt(vector<ll> r,vector<ll> m)   x≡y (modz) {y,z}\n// floor_sum(n,m,a,b) Σi=0:i=n-1 floor((a*i+b)/m) O(log)\n// mf_graph<int/ll> graph(n) int graph.add_edge(from,to,cap) (the number of edge) graph.flow(s,t)\n//graph.flow(s,t,flow_limit) if(allcap==1) O(min(n^(2/3)m,m^(3/2)) else O(mnn)\n//graph.change_cap(i,new_cap,new_flow) (can change)\n//mf_graph<cap>::edge graph.get_edge(i) from,to,cap,flow\n//vector<mf_graph<cap>::edge> graph.edges()\n//mcf_graph<cap,cost> graph(n) int graph.add_edge(from,to,cap,cost) (the number of edge)\n//pair<cap,cost> graph.flow(s,t,(flow_limit)) vector<pair<cap,cost>> graph.slope(s,t) ??\n//O(FV^2)or O(FElogV)\n// using mint=static_modint<mod> or modint998244353; int x.val();\n//scc_graph g(n) g.add_edge(from,to) vector<vector<int>> v=g.scc();\n//vector<ll> convolution<prime>(vector<ll> a,vector<ll> b)\n//vector<ll> convolution_ll(vector<ll> a,vector<ll> b) no mod\n//two_sat ts(n) ts.add(i,bool f,j,bool g)\n//bool ts.satis() vector<bool> ts.answer()\n//vector<int> suffix_array(s) suffix_array<int>(vector<int> s)\n//vector<int> lcp_array(or <int>)(s or vector<int> s,vector<int> sa)\n// vector<int> z_algo(or <int>)(s or vector<int> s)\n//segtree<S,op,e> seg(n or vector<S> v)\n// seg.set(place,S x) S seg.get(place) S seg.prod(l,r) op(a[l],...,a[r-1])\n//S seg.all_prod() op(a[0],...,a[n-1])\n//int seg.max_right<f>(l) define bool f(S x) output one r binary search\n//int seg.min_left<f>(r)\n// ST...op,e(),(f)\n//lazy_segtree<S,op,e,F,mapping,composition,id> seg(n or vector<T> v);\n// set get prod all_prod max_right min_left\n// seg.apply(place,T x) a[p]=op(a[p],x) seg.apply(l,r,T x) l~r-1 a[i]=op(a[i],x)\nusing mint=static_modint<998244353>;\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n  ll n,k;cin>>n>>k;\n  ll a[n];vector<pll> v;\n  rep(i,0,n){cin>>a[i];v.push_back({a[i],i});}\n    fenwick_tree<mint> fw(n),fw2(n),fw3(n);\nsort(v.begin(),v.end(),greater<pll>());\n mint ans=0;\n  mint l=k-1;\n  (l/=k);\n  ll lk=l.val();\nrep(i,0,n){\n    ll num=v[i].second;\n ll num2=max(num,k-1);\n  ll be=beki(lk,num2,mod2);\n  ll be2=gyaku(be,mod2);\n  mint wa=fw.sum(num,n);\n  mint wa2=fw2.sum(0,num);\n  mint bee=be,bee2=be2;\n    mint ka=fw3.sum(0,num);\n  ans+=ka-bee*wa2/2+bee2*wa/2;\n  fw.add(num,bee);\n  fw2.add(num,bee2);\n    fw3.add(num,1);\n  }\n  cout<<ans.val()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <atcoder/all>\nusing namespace atcoder;\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing mint = modint998244353;\n\nostream& operator<<(ostream& out, mint m){\n  out << m.val();\n  return out;\n}\n\nstruct node{\n  mint sum,evinv;\n  int sumzw;\n};\n\nnode empty(){\n  return {0,0,0};\n}\n\nint n,k;\n\nnode lacz(node a,node b){\n  return { a.sum + b.sum, \n    a.evinv + b.evinv + a.sumzw * b.sum,\n    a.sumzw + b.sumzw};\n}\n\nnode mapping(mint x, node a){\n  return {a.sum * x, a.evinv * x, a.sumzw};\n}\nmint composition(mint x,mint y){\n  return x * y;\n}\nmint jeden(){\n  return 1;\n}\n\nlazy_segtree<node, lacz, empty , mint, mapping, composition, jeden> tree;\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> k;\n  tree = {vector<node>(n,{0,0,1})};\n  \n  vector<int> p(n);\n  R(i,n){\n    cin >> p[i];\n    p[i]--;\n  }\n  R(i,k)tree.set(p[i], {1,0,0});\n  \n  mint kinv = mint(1) / k;\n  mint res = 0;\n  R(i,n-k){\n    res += tree.all_prod().evinv * kinv;\n    res += mint(k-1) / 2;\n    tree.apply(0, n, (k-1) * kinv);\n    tree.set(p[i+k], {1,0,0});\n  } \n  res += mint(k) * (k - 1) / 4;\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include<bits/extc++.h>\n#define int long long\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define rep(i,n) for (int i=0;i<(int)(n);++i)\n#define rep1(i,n) for (int i=1;i<=(int)(n);++i)\n#define range(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define F first\n#define S second\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> VL;\n\n\nll power(ll u,ll v,ll mod){\n    ll ret=1,t=u%mod;\n    while (v){\n        if (v&1) ret=t*ret%mod;\n        t=t*t%mod, v>>=1;\n    }\n    return ret%mod;\n}\n \n/*\n计算gcd(a,b)并找寻ax+by=gcd(a,b)的一组解\nret=exgcd(a,b,x,y); \n*/\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if (b){\n        ll d=exgcd(b,a%b,y,x);\n        return y-=a/b*x, d;\n    }\n    return x=1,y=0,a;\n}\n \n/*\n计算x=a(mod m), x=b(mod n)的一组解，若无解返回-1\nret=crt(a,m,b,n);\n*/\nll crt(ll a,ll m,ll b,ll n){\n    if (n>m) swap(a,b), swap(n,m);\n    ll x,y,g=exgcd(m,n,x,y);\n    if ((b-a)%g) return -1;\n    x=(b-a)%n*x%n/g*m+a;\n    return x<0?x+m*n/g:x;\n}\n \n/*\n生成<=n的质数\ngen_prime<5000>(ret);\n*/\n \nvoid gen_prime(int n,vi &ret){\n    vector<bool> p;\n    p.resize(n+1,1);\n    p[0]=p[1]=0;\n    for (int i=4;i<=n;i+=2) p[i]=0;\n    for (int i=3;i*i<=n;i+=2){\n        if (p[i]){\n            for (int j=i*i;j<=n;j+=2*i){\n                p[j]=0;\n            }\n        }\n    }\n    for (int i=2;i<=n;++i){\n        if (p[i]) ret.pb(i);\n    }\n}\n \n/*\n生成<=n的phi\ngen_phi<5000>(ret);\n*/\nvoid gen_phi(int n,vi &phi){\n    phi.resize(n+1);\n    for (int i=0;i<=n;++i) phi[i]=i&1?i:i/2;\n    for (int i=3;i<=n;i+=2){\n        if (phi[i]==i){\n            for (int j=i;j<=n;j+=i) phi[j]-=phi[j]/i;\n        }\n    }\n}\n \n/*\n支持更高的快速幂操作\nexpower.mod_pow(a,b,mod);\n*/\n \nstruct expower{\n    ull mod_mul(ull a,ull b,ull M) {\n        ll ret=a*b-M*ull(ld(a)* ld(b)/ld(M));\n        return ret+M*(ret<0)-M*(ret>=(ll)M);\n    }\n    ull mod_pow(ull b,ull e,ull mod) {\n        ull ans=1;\n        for (; e; b=mod_mul(b,b,mod), e/=2)\n            if (e&1) ans=mod_mul(ans,b,mod);\n        return ans%mod;\n    }\n}expower;\n \n/*\nMiller-Rubin素数判别\nis_prime(n);\n*/\nbool is_prime(ull n){ \n    if (n<2||n%6%4!=1) return n-2<2;\n    ull A[]={2,325,9375,28178,450775,9780504,1795265022},\n    s=__builtin_ctzll(n-1), d = n >> s;\n    for (auto a:A){\n        ull p=expower.mod_pow(a,d,n),i=s;\n        while (p!=1&&p!=n-1&&a%n&&i--)\n            p=expower.mod_mul(p,p,n);\n        if (p!=n-1&&i!=s) return 0;\n    }\n    return 1;\n}\n \n/*\n素因数分解\nret=factorization(n);\n*/\null pollard(ull n){\n    auto f=[n](ull x){return (expower.mod_mul(x,x,n)+1)%n;};\n    if (!(n&1)) return 2;\n    for (ull i=2;;i++){\n        ull x=i,y=f(x),p;\n        while ((p=__gcd(n+y-x,n))==1)\n            x=f(x),y=f(f(y));\n        if (p!=n) return p;\n    }\n}\n \nvector<ull> factorization(ull n){\n    if (n==1) return {};\n    if (is_prime(n)) return {n};\n    ull x=pollard(n);\n    auto l=factorization(x),r=factorization(n/x);\n    l.insert(l.end(),range(r));\n    return l;\n}\n \nstruct DSU{\n    //insert info.\n    vector<int> p;\n    DSU(int n){\n        p.resize(n+1);\n        for (int i=1;i<=n;++i) p[i]=i;\n    }\n    int find(int u){\n        if (p[u]==u) return u;\n        return p[u]=find(find(p[u]));\n    } \n    bool unite(int u,int v){\n        int pu=find(u), pv=find(v);\n        if (pu!=pv){\n            p[pu]=pv;\n        }\n        return pu!=pv;\n    }\n};\n \n/* (u,v,w) */\ntemplate<class T> vector<tuple<int,int,T> > MST(int n,vector<tuple<int,int,T> >g){\n    vector<tuple<int,int,T> > ret;\n    ret.clear();\n    DSU dsu(n);\n    auto cmp=[&](tuple<int,int,T> x,tuple<int,int,T> y){\n        int ux,uy,vx,vy;\n        T wx,wy;\n        tie(ux,vx,wx)=x, tie(uy,vy,wy)=y;\n        return wx<wy;\n    };\n    sort(range(g),cmp);\n    for (auto c:g){\n        int u,v;\n        T w;\n        tie(u,v,w)=c;\n        if(dsu.unite(u,v)) ret.push_back(c);\n    }\n    return ret;\n}\n \ntemplate<int n,class T>\nstruct SegmentTree{\n    typedef struct{\n        T lz,mx,mn,sum;\n    }Node;\n    vector<Node> tree;\n    SegmentTree(){\n        tree.resize((n+7)<<2);\n    }  \n    void pushup(int num){\n        tree[num].mx=max(tree[num<<1].mx,tree[num<<1|1].mx);\n        tree[num].mn=min(tree[num<<1].mn,tree[num<<1|1].mn);\n        tree[num].sum=tree[num<<1].sum+tree[num<<1|1].sum;\n    }\n    void pushdown(int num,int l,int r,int md){\n        if (tree[num].lz){\n            tree[num<<1].mx+=tree[num].lz;\n            tree[num<<1|1].mx+=tree[num].lz;\n            tree[num<<1].mn+=tree[num].lz;\n            tree[num<<1|1].mn+=tree[num].lz;\n            tree[num<<1].sum+=tree[num].lz*(md-l+1);\n            tree[num<<1|1].sum+=tree[num].lz*(r-md);\n            tree[num<<1].lz+=tree[num].lz;\n            tree[num<<1|1].lz+=tree[num].lz;\n            tree[num].lz=0;\n        }\n    }\n    void update1(int num,int l,int r,int L,int R,T val){\n        if (L<=l&&r<=R){\n            tree[num].mx+=val;\n            tree[num].mn+=val;\n            tree[num].sum+=val*(r-l+1);\n            tree[num].lz+=val;\n            return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=L) update1(num<<1,l,md,L,R,val);\n        if (md<R) update1(num<<1|1,md+1,r,L,R,val);\n        pushup(num);\n    }\n    tuple<T,T,T> query1(int num,int l,int r,int L,int R){\n        if (L<=l&&r<=R){\n            return {tree[num].mn,tree[num].mx,tree[num].sum};\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=R){\n            return query1(num<<1,l,md,L,R);\n        }\n        else{\n            if (md<L){\n                return query1(num<<1|1,md+1,r,L,R);\n            }\n            else{\n                tuple<T,T,T> ret1=query1(num<<1,l,md,L,R), ret2=query1(num<<1|1,md+1,r,L,R);\n                T a,b,c,d,e,f;\n                tie(a,b,c)=ret1, tie(d,e,f)=ret2;\n                return {min(a,d),max(b,e),c+f};\n            }\n        } \n    }\n    void update(int L,int R,int w){\n        update1(1,1,n,L,R,w);\n    }\n    tuple<T,T,T> query(int L,int R){\n        return query1(1,1,n,L,R);\n    }\n    void debug1(int num,int l,int r){\n        if (l==r){\n            cout<<tree[num].mn<<\" \"; return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        debug1(num<<1,l,md);\n         debug1(num<<1|1,md+1,r);        \n    }\n    void debug(){\n        debug1(1,1,n);\n        cout<<endl;\n    }\n};\n \nstruct XORBasis{\n    int n;\n    vector<ull> p;\n    vector<ull> ans;\n    XORBasis(int k):n(k){\n        p.resize(k+1);\n    }\n    void rebuilt(){\n        ans.clear();\n        for (int i=0;i<=n;++i){\n            if (p[i]) ans.push_back(p[i]);\n        }\n    }\n    void insert(ull u){\n        for (int i=n;i>=0;--i){\n            if (u&(1ull<<i)){\n                if (p[i]) u^=p[i];\n                else{\n                    p[i]=u;\n                    for (int j=i-1;j>=0;--j){\n                        if (p[i]&(1ull<<j)) p[i]^=p[j];\n                    }\n                    for (int j=i+1;j<=n;++j){\n                        if (p[j]&(1ull<<i)) p[j]^=p[i];\n                    }\n                    break;\n                }\n            }\n        }\n        rebuilt();\n    }\n    bool check(ull u){\n        for (int i=n;i>-1;--i){\n            if (u&(1ull<<i)) u^=p[i];\n        }\n        return (u==0);\n    }\n    ull kth(ull t){ // the k-th smallest, excluding 0.\n        if (t>=(1ull<<sz(ans))) return -1;\n        ull ret=0;\n        for (int i=0;i<sz(ans);++i){\n            if (t&(1ull<<i)) ret^=ans[i];\n        }\n        return ret;\n    }\n    ull total(){\n        return (1ull<<sz(ans));\n    }\n};\n \n \nvi pi(const string& s) {\n\tvi p(sz(s));\n\tfor (int i=1;i<=sz(s);++i) {\n\t\tint g = p[i-1];\n\t\twhile (g && s[i] != s[g]) g = p[g-1];\n\t\tp[i] = g + (s[i] == s[g]);\n\t}\n\treturn p;\n}\n \nvi match(const string& s, const string& pat) {\n\tvi p = pi(pat + '\\0' + s), res;\n\tfor(int i=sz(p)-sz(s);i<=sz(p);++i)\n\t\tif (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));\n\treturn res;\n}\n \n \nstruct AhoCorasick {\n\tenum {alpha = 26, first = 'a'};\n\tstruct Node {\n\t\t// (nmatches is optional)\n\t\tint back, next[alpha], start = -1, end = -1;\n        ll nmatches = 0;\n\t\tNode(int v) { memset(next, v, sizeof(next)); }\n\t};\n\tvector<Node> N;\n\tvector<int> backp;\n\tvoid insert(string& s, int j,ll val) {\n\t\tassert(!s.empty());\n\t\tint n = 0;\n\t\tfor(auto c:s) {\n\t\t\tint& m = N[n].next[c - first];\n\t\t\tif (m == -1) { n = m = sz(N); N.emplace_back(-1); }\n\t\t\telse n = m;\n\t\t}\n\t\tif (N[n].end == -1) N[n].start = j;\n\t\tbackp.push_back(N[n].end);\n\t\tN[n].end = j;\n\t\tN[n].nmatches+=val;\n\t}\n\tAhoCorasick(vector<string>& pat,vi val) {\n\t\tN.emplace_back(-1);\n\t\tfor (int i=0;i<sz(pat);++i) insert(pat[i], i, val[i]);\n\t\tN[0].back = sz(N);\n\t\tN.emplace_back(0);\n \n\t\tqueue<int> q;\n\t\tfor (q.push(0); !q.empty(); q.pop()) {\n\t\t\tint n = q.front(), prev = N[n].back;\n\t\t\tfor (int i=0;i<alpha;++i) {\n\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];\n\t\t\t\tif (ed == -1) ed = y;\n\t\t\t\telse {\n\t\t\t\t\tN[ed].back = y;\n\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])\n\t\t\t\t\t\t= N[y].end;\n\t\t\t\t\tN[ed].nmatches += N[y].nmatches;\n\t\t\t\t\tq.push(ed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvi find(string& word,ll& ans) {\n\t\tint n = 0;\n\t\tvi res;\n\t\tfor(auto c:word) {\n\t\t\tn = N[n].next[c - first];\n\t\t\tres.push_back(N[n].end);\n\t\t\tans += N[n].nmatches;\n\t\t}\n\t\treturn res;\n\t}\n\tvector<vi> findAll(vector<string>& pat, string word) {\n\t\tll ans=0;\n        vi r = find(word,ans);\n\t\tvector<vi> res(sz(word));\n\t\tfor (int i=0;i<sz(word);++i) {\n\t\t\tint ind = r[i];\n\t\t\twhile (ind != -1) {\n\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);\n\t\t\t\tind = backp[ind];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n \nstruct HLD{\n    int n,cnt=0;\n    vector<vi> G;\n    vi par,dep,siz,son,top,dfn,rk; \n    //父亲节点，深度，子树大小，重子节点，重链头部，dfs序，dfs序对应的节点编号\n    HLD(vector<vi> g,int root=1):n(sz(g)),G(g),par(n+7),dep(n+7),siz(n+7,1),son(n+7,-1),top(n+7),dfn(n+7),rk(n+7){\n        dep[0]=-1, dfs1(root,0), dfs2(root,0,root);\n    }\n    void dfs1(int u,int p){\n        for (auto c:G[u]){\n            if (c==p) continue;\n            dep[c]=dep[u]+1, par[c]=u;\n            dfs1(c,u);\n            siz[u]+=siz[c];\n            if (son[u]==-1||siz[son[u]]<siz[c]) son[u]=c;\n        }\n    }\n    void dfs2(int u,int p,int tp){\n        top[u]=tp;\n        dfn[u]=++cnt;\n        rk[cnt]=u;\n        if (son[u]==-1) return;\n        dfs2(son[u],u,tp);\n        for (auto c:G[u]){\n            if (c==p||c==son[u]) continue;\n            dfs2(c,u,c);\n        }\n    }\n    int lca(int u,int v){\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                u=par[top[u]];\n            }\n            else{\n                v=par[top[v]];\n            }\n        }\n        return dep[u]>dep[v]?v:u;\n    }\n    vector<pii> find_seg(int u,int v){\n        vector<pii> ft,bk,res;\n        ft.clear(), bk.clear(), res.clear();\n//        cout<<top[u]<<\" \"<<top[v]<<endl;\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                ft.pb({u,top[u]});\n                u=par[top[u]];\n            }\n            else{\n                bk.pb({top[v],v});\n                v=par[top[v]];\n            }\n        }\n        ft.pb({u,v});\n        for (int i=0;i<sz(ft);++i) res.pb(ft[i]);\n        for (int i=sz(bk);i>0;--i) res.pb(bk[i-1]);\n        return res;\n    }\n};\n \nstruct BIT{\n    vi C; int n;\n    BIT(int n):n(n){C.resize(n+7,0);}\n    void update(int u,int w){\n        for (;u<=n;u+=u&(-u)) C[u]+=w;\n    }\n    int query(int u){\n        int res=0;\n        for (;u>0;u-=u&(-u)) res+=C[u];\n        return res; \n    }\n};\n\nvi topoSort(const vector<vi>& gr) {\n\tvi indeg(sz(gr)), ret;\n\tfor (auto& li : gr) for (int x : li) indeg[x]++;\n\tqueue<int> q; // use priority queue for lexic. smallest ans.\n\trep(i,sz(gr)) if (indeg[i] == 0) q.push(-i);\n\twhile (!q.empty()) {\n\t\tint i = -q.front(); // top() for priority queue\n\t\tret.push_back(i);\n\t\tq.pop();\n\t\tfor (int x : gr[i])\n\t\t\tif (--indeg[x] == 0) q.push(-x);\n\t}\n\treturn ret;\n}\n\nvi path;\nnamespace Eulerian {\n    const int N = 3, M = 3;\n    int t, n, m, tot, cc, hd[N], nxt[M], to[M], bh[M], vis[M], in[N], out[N], ans[M];\n    void add(int x, int y, int id) {\n        nxt[++tot] = hd[x];\n        hd[x] = tot;\n        to[tot] = y;\n        bh[tot] = id;\n        in[y]++;\n        out[x]++;\n    }\n    void dfs(int x) {\n        for (int i = hd[x]; i; i = hd[x]) {\n            while (i && vis[abs(bh[i])]) i = nxt[i];\n            hd[x] = i;\n            if (!i) break;\n            vis[abs(bh[i])] = 1;\n            dfs(to[i]), ans[++cc] = bh[i];\n        }\n    }\n \n    void init() {\n        memset(hd, 0, sizeof(hd));\n        memset(nxt, 0, sizeof(nxt));\n        memset(to, 0, sizeof(to));\n        memset(bh, 0, sizeof(bh));\n        memset(vis, 0, sizeof(vis));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n        memset(ans, 0, sizeof(ans));\n        t = 1;\n        n = 0;\n        m = 0;\n        tot = 0;\n        cc = 0;\n    }\n    bool solve() {\n        for (int i = 1; i <= n; i++)\n            if ((t == 1 && in[i] & 1)) {\n                return false;\n            }\n        dfs(to[1]);\n        if (cc < m) return false;\n        else {\n            path.clear();\n            for (int i = cc; i >= 1; i--) path.push_back(ans[i]);\n            return true;\n        }\n    }\n} // namespace Eulerian\n\nnamespace FWT{\n    //mod=-1 (no mod)\n    const int mod=-1;\n\n    inline int modadd(int a,int b){\n        a+=b;\n        if (mod==-1) return a;\n        a%=mod, a+=mod, a%=mod;\n        return a;\n    }\n\n    vi OR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j]=modadd(b[j],b[j^(1<<i)]*mode); \n            }\n        }\n        return b;\n    }\n    vi AND(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]*mode);\n            }\n        }\n        return b;\n    }\n    vi XOR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1){\n                    b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]);\n                    b[j]=modadd(b[j^(1<<i)],-2*b[j]);\n                    if (mode<0) {\n                        if (mod>0) b[j]=b[j]*power(2,mod-2,mod)%mod, b[j^(1<<i)]=b[j^(1<<i)]*power(2,mod-2,mod)%mod;\n                        else b[j]/=2, b[j^(1<<i)]/=2;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n}\n\nconst int maxn=200007;\nconst int mod=998244353;\n\nint inv(int u){\n    return power(u,mod-2,mod);\n}\nint mult(int u,int v){\n    return u*v%mod;\n}\nint n,k;\nint a[maxn],p[maxn],q[maxn];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin>>n>>k;\n    rep1(i,n) cin>>a[i],p[i]=i;\n    sort(p+1,p+n+1,[&](int u,int v){return a[u]<a[v];});\n    rep1(i,n) q[p[i]]=1;\n    BIT C(n),C0(n);\n    int ans=0,ans0=0;\n    rep1(i,n){\n        C.update(a[i],power(1+inv(k-1),max(0ll,i-k),mod));\n        C0.update(a[i],1);\n        int r=(C.query(n)-C.query(a[i])+mod)%mod;\n        ans=(ans+mult(r,power(1-inv(k)+mod,max(0ll,i-k),mod)))%mod;\n //       cout<<ans<<endl;\n        ans0=(ans0+C0.query(n)-C0.query(a[i]))%mod;\n    }\n    ans=(ans0-ans+mod)%mod;\n    int tmp=0;\n    tmp=k*(k-1)/2;\n    tmp%=mod;\n    for (int i=1;i<=n-k;++i){\n        tmp=(tmp+mult(k,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    for (int i=1;i<n-k;++i){\n        int w=n-k-i;\n        tmp=(tmp+mult(w,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    tmp=mult(tmp,inv(2));\n    cout<<((ans+tmp)%mod+mod)%mod;\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/extc++.h>\n\ntemplate <uint32_t Modulus>\nstruct modular {\n  static_assert(int(Modulus) > 0, \"Modulus must be in the range [1, 2^31)\");\n  static constexpr int modulus() { return Modulus; }\n\n  modular() : v(0) {}\n  modular(int64_t x) : v(x % Modulus) {\n    if (int(v) < 0) v += Modulus;\n  }\n\n  explicit operator int() const { return v; }\n  modular& operator++() { return ++v == Modulus ? v = 0 : 0, *this; }\n  modular& operator--() { return --(v ? v : v = Modulus), *this; }\n  modular operator+() const { return *this; }\n  modular operator-() const {\n    modular res;\n    res.v = v ? Modulus - v : 0;\n    return res;\n  }\n  modular& operator*=(modular b) {\n    v = uint64_t(v) * b.v % Modulus;\n    return *this;\n  }\n  modular& operator/=(modular b) {\n    auto [x, gcd] = extgcd(b.v, Modulus);\n    assert(gcd == 1);\n    return *this *= x;\n  }\n  modular& operator+=(modular b) {\n    v += b.v - Modulus;\n    if (int(v) < 0) v += Modulus;\n    return *this;\n  }\n  modular& operator-=(modular b) {\n    v -= b.v;\n    if (int(v) < 0) v += Modulus;\n    return *this;\n  }\n\n  friend modular operator++(modular& a, int) {\n    return std::exchange(a, ++modular(a));\n  }\n  friend modular operator--(modular& a, int) {\n    return std::exchange(a, --modular(a));\n  }\n  friend modular operator*(modular a, modular b) { return a *= b; }\n  friend modular operator/(modular a, modular b) { return a /= b; }\n  friend modular operator+(modular a, modular b) { return a += b; }\n  friend modular operator-(modular a, modular b) { return a -= b; }\n  friend std::istream& operator>>(std::istream& is, modular& b) {\n    int64_t x;\n    return is >> x, b = x, is;\n  }\n  friend std::ostream& operator<<(std::ostream& os, modular b) {\n    return os << b.v;\n  }\n  friend bool operator==(modular a, modular b) { return a.v == b.v; }\n  friend bool operator!=(modular a, modular b) { return a.v != b.v; }\n\n private:\n  static std::pair<int, int> extgcd(int a, int b) {\n    std::array x{1, 0};\n    while (b) {\n      int q = a / b;\n      std::swap(x[0] -= q * x[1], x[1]);\n      std::swap(a -= q * b, b);\n    }\n    return {x[0], a};\n  }\n\n  uint32_t v;\n};\n\nstruct segment_tree_base {\n  virtual int size() const = 0;\n\n protected:\n  template <class F>\n  void forward(int l, int r, F f) const {\n    int h = h1(l += size() - 1, r += size());\n    for (int s = 0; s < h; ++s)\n      if (int i = l >> s; ~i & 1) f(i + 1);\n    for (int s = h; s--;)\n      if (int i = r >> s; i & 1) f(i - 1);\n  }\n  template <class F>\n  void forward(int l, int r, F f) {\n    const_cast<const segment_tree_base*>(this)->forward(l, r, f);\n  }\n  template <class F>\n  void backward(int l, int r, F f) const {\n    int h = h1(l += size() - 1, r += size());\n    for (int s = 0; s < h; ++s)\n      if (int i = r >> s; i & 1) f(i - 1);\n    for (int s = h; s--;)\n      if (int i = l >> s; ~i & 1) f(i + 1);\n  }\n  template <class F>\n  void backward(int l, int r, F f) {\n    const_cast<const segment_tree_base*>(this)->backward(l, r, f);\n  }\n  template <class F>\n  void downward(int l, int r, F f) const {\n    if (l == r or (l == 0 and r == size())) return;\n    int h = h2(l += size(), r += size());\n    for (int s = std::__lg(l); s > h; --s) f(l >> s);\n    for (int s = h; s > __builtin_ctz(l); --s) f(l >> s);\n    for (int s = h; s > __builtin_ctz(r); --s) f(r >> s);\n  }\n  template <class F>\n  void downward(int l, int r, F f) {\n    const_cast<const segment_tree_base*>(this)->downward(l, r, f);\n  }\n  template <class F>\n  void upward(int l, int r, F f) const {\n    if (l == r or (l == 0 and r == size())) return;\n    int h = h2(l += size(), r += size());\n    for (int s = __builtin_ctz(r); s++ < h;) f(r >> s);\n    for (int s = __builtin_ctz(l); s++ < h;) f(l >> s);\n    for (int s = h; s++ < std::__lg(l);) f(l >> s);\n  }\n  template <class F>\n  void upward(int l, int r, F f) {\n    const_cast<const segment_tree_base*>(this)->upward(l, r, f);\n  }\n\n private:\n  static int h1(int l, int r) {\n    for (int h = 0;; ++h)\n      if ((r >> h) - (l >> h) == 1) return h;\n  }\n  static int h2(int l, int r) {\n    l <<= std::__lg(l) < std::__lg(r);\n    return std::__lg(l ^ r);\n  }\n};\n\ntemplate <class T, class Action>\nstruct lazy_segment_tree : segment_tree_base {\n  lazy_segment_tree() {}\n  template <class Generator>\n  lazy_segment_tree(int n, Generator gen) : tree(2 * n), lazy(n) {\n    for (int i = 0; i < n; ++i) tree[n + i] = gen(i);\n    for (int i = n; i-- > 1;) pull(i);\n  }\n\n  int size() const override { return std::size(lazy); }\n  T fold(int l, int r) {\n    assert(0 <= l), assert(l <= r), assert(r <= size());\n    downward(l, r, [&](int i) { push(i); });\n    T res{};\n    forward(l, r, [&](int i) { res = res * tree[i]; });\n    return res;\n  }\n  T get(int i) {\n    assert(0 <= i), assert(i < size());\n    return fold(i, i + 1);\n  }\n  template <class Function>\n  void update(int i, Function func) {\n    assert(0 <= i), assert(i < size());\n    downward(i, i + 1, [&](int j) { push(j); });\n    tree[size() + i] = func(tree[size() + i]);\n    upward(i, i + 1, [&](int j) { pull(j); });\n  }\n  void act(int l, int r, const Action& f) {\n    assert(0 <= l), assert(l <= r), assert(r <= size());\n    downward(l, r, [&](int i) { push(i); });\n    forward(l, r, [&](int i) { apply(i, f); });\n    upward(l, r, [&](int i) { pull(i); });\n  }\n  template <class Predicate>\n  int forward_search(int l, int r, Predicate pred) {\n    assert(0 <= l), assert(l <= r), assert(r <= size());\n    downward(l, r, [&](int i) { push(i); });\n    T a{};\n    assert(pred(a));\n    int res = r;\n    forward(l, r, [&](int i) {\n      if (res < r) return;\n      if (T na = a * tree[i]; pred(na)) {\n        a = na;\n        return;\n      }\n      while (i < size()) {\n        push(i);\n        if (T na = a * tree[i *= 2]; pred(na)) a = na, ++i;\n      }\n      res = i - size();\n    });\n    return res;\n  }\n  template <class Predicate>\n  int backward_search(int l, int r, Predicate pred) {\n    assert(0 <= l), assert(l <= r), assert(r <= size());\n    downward(l, r, [&](int i) { push(i); });\n    T a{};\n    assert(pred(a));\n    int res = l - 1;\n    backward(l, r, [&](int i) {\n      if (res >= l) return;\n      if (T na = a * tree[i]; pred(na)) {\n        a = na;\n        return;\n      }\n      while (i < size()) {\n        push(i);\n        if (T na = a * tree[i = 2 * i + 1]; pred(na)) a = na, --i;\n      }\n      res = i - size();\n    });\n    return res;\n  }\n\n private:\n  std::vector<T> tree;\n  std::vector<Action> lazy;\n\n  void apply(int i, const Action& f) {\n    tree[i] = f(tree[i]);\n    if (i < size()) lazy[i] = lazy[i] * f;\n  }\n  void push(int i) {\n    apply(2 * i, lazy[i]), apply(2 * i + 1, lazy[i]);\n    lazy[i] = Action{};\n  }\n  void pull(int i) { tree[i] = tree[2 * i] * tree[2 * i + 1]; }\n};\n\nusing mint = modular<998244353>;\n// using mint = double;\n\nstruct node {\n  mint sum, len;\n  friend node operator*(const node& a, const node& b) {\n    return {a.sum + b.sum, a.len + b.len};\n  }\n};\nstruct action {\n  mint a = 1, b = 0;\n  node operator()(node x) const {\n    x.sum *= a, x.len *= a;\n    x.sum += b * x.len;\n    return x;\n  }\n  friend action operator*(const action& f, const action& g) {\n    return {f.a * g.a, f.b * g.a + g.b};\n  }\n};\n\ntemplate <class T>\nstruct fenwick {\n  fenwick() {}\n  template <class Generator>\n  fenwick(int n, Generator gen) : tree(n) {\n    for (int i = 0; i < n; ++i) tree[i] = gen(i);\n    for (int i = 0; i < n; ++i)\n      if (int j = i | (i + 1); j < n) tree[j] += tree[i];\n  }\n\n  int size() const { return std::size(tree); }\n  void add(int i, T a) {\n    assert(0 <= i), assert(i < size());\n    for (; i < size(); i |= i + 1) tree[i] += a;\n  }\n  T sum(int i) const {\n    assert(0 <= i), assert(i <= size());\n    T res{};\n    for (; i; i &= i - 1) res += tree[i - 1];\n    return res;\n  }\n\n private:\n  std::vector<T> tree;\n};\n\ntemplate <class T, class Action>\nstruct _lazy_segment_tree : segment_tree_base {\n  _lazy_segment_tree() {}\n  template <class Generator>\n  _lazy_segment_tree(int n, Generator gen) : tree(n) {\n    for (int i = 0; i < n; ++i) tree[i] = gen(i);\n  }\n\n  int size() const override { return std::size(tree); }\n  T fold(int l, int r) {\n    assert(0 <= l), assert(l <= r), assert(r <= size());\n    T res{};\n    for (int i = l; i < r; ++i) res = res * tree[i];\n    return res;\n  }\n  T get(int i) {\n    assert(0 <= i), assert(i < size());\n    return fold(i, i + 1);\n  }\n  template <class Function>\n  void update(int i, Function func) {\n    assert(0 <= i), assert(i < size());\n    tree[i] = func(tree[i]);\n  }\n  void act(int l, int r, const Action& f) {\n    assert(0 <= l), assert(l <= r), assert(r <= size());\n    for (int i = l; i < r; ++i) tree[i] = f(tree[i]);\n  }\n\n private:\n  std::vector<T> tree;\n};\n\n#ifdef _MSC_VER\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n  int x = 0;\n  while ((1U << x) < (unsigned int)(n)) x++;\n  return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n  unsigned long index;\n  _BitScanForward(&index, n);\n  return index;\n#else\n  return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S),\n          F (*composition)(F, F), F (*id)()>\nstruct lazy_segtree {\n public:\n  lazy_segtree() : lazy_segtree(0) {}\n  lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n  lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n    log = internal::ceil_pow2(_n);\n    size = 1 << log;\n    d = std::vector<S>(2 * size, e());\n    lz = std::vector<F>(size, id());\n    for (int i = 0; i < _n; i++) d[size + i] = v[i];\n    for (int i = size - 1; i >= 1; i--) {\n      update(i);\n    }\n  }\n\n  void set(int p, S x) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for (int i = log; i >= 1; i--) push(p >> i);\n    d[p] = x;\n    for (int i = 1; i <= log; i++) update(p >> i);\n  }\n\n  S get(int p) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for (int i = log; i >= 1; i--) push(p >> i);\n    return d[p];\n  }\n\n  S prod(int l, int r) {\n    assert(0 <= l && l <= r && r <= _n);\n    if (l == r) return e();\n\n    l += size;\n    r += size;\n\n    for (int i = log; i >= 1; i--) {\n      if (((l >> i) << i) != l) push(l >> i);\n      if (((r >> i) << i) != r) push(r >> i);\n    }\n\n    S sml = e(), smr = e();\n    while (l < r) {\n      if (l & 1) sml = op(sml, d[l++]);\n      if (r & 1) smr = op(d[--r], smr);\n      l >>= 1;\n      r >>= 1;\n    }\n\n    return op(sml, smr);\n  }\n\n  S all_prod() { return d[1]; }\n\n  void apply(int p, F f) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for (int i = log; i >= 1; i--) push(p >> i);\n    d[p] = mapping(f, d[p]);\n    for (int i = 1; i <= log; i++) update(p >> i);\n  }\n  void apply(int l, int r, F f) {\n    assert(0 <= l && l <= r && r <= _n);\n    if (l == r) return;\n\n    l += size;\n    r += size;\n\n    for (int i = log; i >= 1; i--) {\n      if (((l >> i) << i) != l) push(l >> i);\n      if (((r >> i) << i) != r) push((r - 1) >> i);\n    }\n\n    {\n      int l2 = l, r2 = r;\n      while (l < r) {\n        if (l & 1) all_apply(l++, f);\n        if (r & 1) all_apply(--r, f);\n        l >>= 1;\n        r >>= 1;\n      }\n      l = l2;\n      r = r2;\n    }\n\n    for (int i = 1; i <= log; i++) {\n      if (((l >> i) << i) != l) update(l >> i);\n      if (((r >> i) << i) != r) update((r - 1) >> i);\n    }\n  }\n\n  template <bool (*g)(S)>\n  int max_right(int l) {\n    return max_right(l, [](S x) { return g(x); });\n  }\n  template <class G>\n  int max_right(int l, G g) {\n    assert(0 <= l && l <= _n);\n    assert(g(e()));\n    if (l == _n) return _n;\n    l += size;\n    for (int i = log; i >= 1; i--) push(l >> i);\n    S sm = e();\n    do {\n      while (l % 2 == 0) l >>= 1;\n      if (!g(op(sm, d[l]))) {\n        while (l < size) {\n          push(l);\n          l = (2 * l);\n          if (g(op(sm, d[l]))) {\n            sm = op(sm, d[l]);\n            l++;\n          }\n        }\n        return l - size;\n      }\n      sm = op(sm, d[l]);\n      l++;\n    } while ((l & -l) != l);\n    return _n;\n  }\n\n  template <bool (*g)(S)>\n  int min_left(int r) {\n    return min_left(r, [](S x) { return g(x); });\n  }\n  template <class G>\n  int min_left(int r, G g) {\n    assert(0 <= r && r <= _n);\n    assert(g(e()));\n    if (r == 0) return 0;\n    r += size;\n    for (int i = log; i >= 1; i--) push((r - 1) >> i);\n    S sm = e();\n    do {\n      r--;\n      while (r > 1 && (r % 2)) r >>= 1;\n      if (!g(op(d[r], sm))) {\n        while (r < size) {\n          push(r);\n          r = (2 * r + 1);\n          if (g(op(d[r], sm))) {\n            sm = op(d[r], sm);\n            r--;\n          }\n        }\n        return r + 1 - size;\n      }\n      sm = op(d[r], sm);\n    } while ((r & -r) != r);\n    return 0;\n  }\n\n private:\n  int _n, size, log;\n  std::vector<S> d;\n  std::vector<F> lz;\n\n  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n  void all_apply(int k, F f) {\n    d[k] = mapping(f, d[k]);\n    if (k < size) lz[k] = composition(f, lz[k]);\n  }\n  void push(int k) {\n    all_apply(2 * k, lz[k]);\n    all_apply(2 * k + 1, lz[k]);\n    lz[k] = id();\n  }\n};\n\n}  // namespace atcoder\n\nnode op(node a, node b) { return a * b; }\nnode e() { return {}; }\nnode mapping(action f, node x) { return f(x); }\naction composition(action f, action g) { return g * f; }\naction id() { return {}; }\n\nint main() {\n  using namespace std;\n  cin.tie(nullptr)->sync_with_stdio(false);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n), pos(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    --a[i];\n    pos[a[i]] = i;\n  }\n\n  // lazy_segment_tree<node, action> seg(12, [&](int v) -> node {\n  //   if (v < n and pos[v] < k) {\n  //     return {0, mint(1) / k};\n  //   }\n  //   return {};\n  // });\n  atcoder::lazy_segtree<node, op, e, action, mapping, composition, id> seg(n);\n  for (int v = 0; v < n; ++v)\n    if (pos[v] < k) seg.set(v, {0, mint(1) / k});\n\n  fenwick<int> f(n, [](int) { return 0; });\n  for (int i = k; i < n; ++i) {\n    seg.apply(a[i] + 1, n, {1, 1});\n    f.add(a[i], 1);\n  }\n\n  mint ans{};\n  for (int i = 0; i <= n - k; ++i) {\n    if (i) {\n      seg.apply(0, n, {mint(k - 1) / k, 0});\n      // seg.update(a[i + k - 1], [&](const node&) -> node {\n      //   return {f.sum(a[i + k - 1]) / mint(k), mint(1) / k};\n      // });\n      seg.set(a[i + k - 1], {f.sum(a[i + k - 1]) / mint(k), mint(1) / k});\n    }\n    ans += seg.prod(0, n).sum;\n    ans += mint(k - 1) / 2;\n    if (i + k < n) {\n      seg.apply(a[i + k] + 1, n, {1, -1});\n      f.add(a[i + k], -1);\n    }\n    for (int j = 0; j < n; ++j) seg.get(j);\n  }\n  ans += mint(k - 1) * (k - 2) / 2 / 2;\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <atcoder/all>\nusing namespace std;\n// using namespace atcoder;\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n#ifdef __LOCAL\n#define debug(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << '\\n'\n#define debugArray(x, n)                                      \\\n  cerr << __LINE__ << \": \" << #x << \" = {\";                   \\\n  for (long long hoge = 0; (hoge) < (long long)(n); ++(hoge)) \\\n    cerr << ((hoge) ? \",\" : \"\") << x[hoge];                   \\\n  cerr << \"}\" << '\\n'\n#define debugMatrix(x, h, w)                                         \\\n  cerr << __LINE__ << \": \" << #x << \" =\\n\";                          \\\n  for (long long hoge = 0; (hoge) < (long long)(h); ++(hoge)) {      \\\n    cerr << ((hoge ? \" {\" : \"{{\"));                                  \\\n    for (long long fuga = 0; (fuga) < (long long)(w); ++(fuga))      \\\n      cerr << ((fuga ? \", \" : \"\")) << x[hoge][fuga];                 \\\n    cerr << \"}\" << (hoge + 1 == (long long)(h) ? \"}\" : \",\") << '\\n'; \\\n  }\n#else\n#define debug(x) (void(0))\n#define debugArray(x, n) (void(0))\n#define debugMatrix(x, h, w) (void(0))\n#endif\n\ntemplate <int mod>\nstruct ModInt {\n  int64_t x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod)) {}\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) { return *this *= p.inverse(); }\n  ModInt operator-() const { return ModInt() - *this; }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b) t = a / b, swap(a -= t * b, b), swap(u -= t * v, v);\n    return ModInt(u);\n  }\n  ModInt pow(int64_t e) const {\n    ModInt ret(1);\n    for (ModInt b = *this; e; e >>= 1, b *= b)\n      if (e & 1) ret *= b;\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int modulo() { return mod; }\n  int get() const { return x; }\n};\n\ntemplate <typename T>\nstruct BinaryIndexedTree {\n  vector<T> dat;\n  BinaryIndexedTree(int n) : dat(n + 1, 0) {}\n  BinaryIndexedTree(int n, T a) : BinaryIndexedTree(vector<T>(n, a)) {}\n  BinaryIndexedTree(vector<T> y) : dat(y.size() + 1, 0) {\n    for (size_t i = 0; i < y.size(); ++i) dat[i + 1] = y[i];\n    for (int i = 1; i < (int)dat.size(); ++i)\n      if (i + (i & -i) < (int)dat.size()) dat[i + (i & -i)] += dat[i];\n  }\n  void add(int i, T a = 1) {\n    for (++i; i < (int)dat.size(); i += i & -i) dat[i] += a;\n  }\n  T sum(int i) {  // sum [0,i)\n    T s = 0;\n    for (; i > 0; i &= i - 1) s += dat[i];\n    return s;\n  }\n  // sum [l,r)\n  T sum(int l, int r) { return sum(r) - sum(l); }\n  T operator[](size_t k) { return sum(k + 1) - sum(k); }\n  // min { i : sum(i+1) > k } -> kth element(0-indexed)\n  int find(T k) const {\n    int i = 0;\n    for (int p = 1 << (__lg(dat.size() - 1) + 1); p > 0; p >>= 1)\n      if (i + p < (int)dat.size() && dat[i + p] <= k) k -= dat[i += p];\n    return i + 1 == (int)dat.size() ? -1 : i;  // -1 -> no solutions\n  }\n};\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  using Mint = ModInt<998244353>;\n  int N, K;\n  cin >> N >> K;\n  int p[N];\n  for (int i = 0; i < N; i++) {\n    cin >> p[i];\n    p[i]--;\n  }\n  BinaryIndexedTree<Mint> bit1(N), bit2(N);\n  Mint ans = 0;\n  Mint P = Mint(K - 1) / Mint(K);\n  for (int i = 0; i < N; i++) {\n    int f = max(0, i - (K - 1));\n    Mint tmp = P.pow(f);\n    ans += bit2.sum(p[i], N) - bit1.sum(p[i], N) * tmp / 2\n           + bit1.sum(0, p[i]) * tmp / 2;\n    bit1.add(p[i], tmp.inverse());\n    bit2.add(p[i], 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing M=modint998244353;\nint N,K,p;\nmain()\n{\n\tcin>>N>>K>>p;\n\tfenwick_tree<M>A(N),B(N);\n\tM s=0,X=M(K-1)/K;\n\tfor(int j=1;j<N;j++)\n\t{\n\t\tA.add(--p,X/X.pow(max(j,K)));\n\t\tB.add(p,1);\n\t\tcin>>p;\n\t\ts+=(A.sum(0,p)-A.sum(p,N))*X.pow(max(j,K-1))/2+B.sum(p,N);\n\t}\n\tcout<<s.val();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 998244353\n#define N_MAX 10000000\nll fac[N_MAX+1], inv[N_MAX+1], finv[N_MAX+1];\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nll perm(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (fac[n]*finv[n-k])%P;\n}\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){ return (a * b)%P;}\nll mpow(ll a, ll b, ll p = -1){\n  ll ret = 1, num = a;\n  while(b>0){\n    if(b&1) ret = (ret*num)%p;\n    num = (num*num)%p;\n    b /= 2;\n  }\n  return ret;\n}\n\n\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = (node[i*2+1] + node[i*2+2])%P;\n    }\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] = (node[k] * lazy[k])%P;\n            if(r - l > 1) {\n                lazy[2*k+1] = (lazy[2*k+1] + lazy[k])%P;\n                lazy[2*k+2] = (lazy[2*k+2] + lazy[k])%P;\n            }\n            lazy[k] = 0;\n        }\n    }\n    void ml(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = (lazy[k] + x)%P;\n            eval(k, l, r);\n        }\n        else {\n            ml(a, b, x, 2*k+1, l, (l+r)/2);\n            ml(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = (node[2*k+1] + node[2*k+2])%P;\n        }\n    }\n\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n          eval(k, l, r);\n          if(k<n-1) add(a, b, x, 2*k+1, l, (l+r)/2);\n          if(k<n-1) add(a, b, x, 2*k+2, (l+r)/2, r);\n          node[k] = (node[k] + x)%P;\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = (node[2*k+1] + node[2*k+2])%P;\n        }\n    }\n\n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr)%P;\n    }\n};\nstruct BIT{\n  ll M=1;\n  vector<ll> dat;\n  BIT(ll N){\n    if(N<=1) N = 2;\n    while(N>M) M*=2;\n    dat.resize(M*2-1, 0);\n  }\n  void update(ll x, ll k){\n    for(int i=k+1;i<=M;i+=(i&(-i))){\n      dat[i] += x;\n    }\n  }\n  ll sum(ll r){\n    ll ret = 0;\n    for(int k=r;k>0;k-=(k&(-k))) ret += dat[k];\n    return ret;\n  }\n\n  ll query(ll l, ll r){\n    return sum(r) - sum(l);\n  }\n};\nint main(){\n  ll n, k;std::cin >> n >> k;\n  init();\n  vll p(n);\n  re(i, n) {\n    scanf(\"%lld\", &p[i]);\n    p[i]--;\n  }\n  BIT bt(n);\n  LazySegmentTree seg(vll(n, 0));\n\n  ll ans = 0;\n  for(int i=0;i<k;i++){\n    //iまで到達する確率\n    ll lef = seg.getsum(0, p[i]);//巻き込まれて1/2   -> i<kなら1/2 異なれば\n    ll ri  = seg.getsum(p[i], n);//巻き込まれない or 巻き込まれて1/2\n    ll num = bt.query(p[i], n);\n    // psum = lef/2 + ri / 2 + (num - ri)\n    ll psum = ((lef * inv[2])%P + (ri * inv[2])%P + (num - ri + P)%P)%P;\n    ans = (ans + psum)%P;\n    seg.add(p[i], p[i]+1, 1);\n    bt.update(1, p[i]);\n  }\n\n  ll x = ((k-1) * inv[k])%P;\n  for(int i=k;i<n;i++){\n    seg.ml(0, n, x);\n    //iまで到達する確率\n    ll lef = seg.getsum(0, p[i]);//巻き込まれて1/2   -> i<kなら1/2 異なれば\n    ll ri  = seg.getsum(p[i], n);//巻き込まれない or 巻き込まれて1/2\n    ll num = bt.query(p[i], n);\n    // psum = lef/2 + ri / 2 + (num - ri)\n    ll psum = ((lef * inv[2])%P + (ri * inv[2])%P + (num - ri + P)%P)%P;\n    //std::cout << i << \" \" << lef << \" \" << ri << \" \" << psum << '\\n';\n    //for(int j=0;j<n;j++) std::cout << seg.getsum(j, j+1) << (j==n-1?\"\\n\":\" \");\n    ans = (ans + psum)%P;\n    seg.add(p[i], p[i]+1, 1);\n    bt.update(1, p[i]);\n  }\n  std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp make_pair\n\ntypedef tree<\n        pair<int, int>,\n        null_type,\n        less<pair<int, int>>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n\nconst int p = 998244353;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+p-b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int N = 1200000;\n\nvector<int> facs(N), invfacs(N);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<N; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[N-1] = inv(facs[N-1]);\n    for (int i = N-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\nstruct SegTree\n{\n    vector<int> t;\n    int n;\n\n    int sum(int v, int tl, int tr, int l, int r) {\n        if (l > r)\n            return 0;\n        if (l == tl && r == tr) {\n            return t[v];\n        }\n        int tm = (tl + tr) / 2;\n        return add(sum(v*2, tl, tm, l, min(r, tm)), sum(v*2+1, tm+1, tr, max(l, tm+1), r));\n    }\n\n    void update(int v, int tl, int tr, int pos, int new_val) {\n        if (tl == tr) {\n            t[v] = new_val;\n        } else {\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                update(v*2, tl, tm, pos, new_val);\n            else\n                update(v*2+1, tm+1, tr, pos, new_val);\n            t[v] = add(t[v*2], t[v*2+1]);\n        }\n    }\n\n    SegTree(int N)\n    {\n        n = N;\n        t.resize(1<<19);\n    }\n\n    int sum(int l, int r)\n    {\n        return sum(1, 0, n-1, l, r);\n    }\n\n    void upd(int pos, int new_val)\n    {\n        update(1, 0, n-1, pos, new_val);\n    }\n};\n\nint P;\n\nvector<int> deg;\nvector<int> invdeg;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int n, k;\n    cin>>n>>k;\n    vector<int> a(n);\n    for (int i = 0; i<n; i++) {cin>>a[i]; a[i]--;}\n\n    vector<int> pos(n);\n    for (int i = 0; i<n; i++) pos[a[i]] = i;\n\n    P = mul(k-1, inv(k));\n    deg.resize(n);\n    deg[0] = 1;\n    for (int i = 1; i<n; i++) deg[i] = mul(deg[i-1], P);\n    invdeg.resize(n);\n    invdeg[0] = 1;\n    for (int i = 1; i<n; i++) invdeg[i] = mul(invdeg[i-1], inv(P));\n\n    ll res = 0;\n\n\n    reverse(pos.begin(), pos.end());\n\n    SegTree decr(n);\n    for (auto x: pos)\n    {\n        int sum = decr.sum(x+1, n-1);\n        res = add(res, mul(mul(sum, invdeg[max(x, k-1)]), inv(2)));\n        decr.upd(x, deg[max(x, k-1)]);\n    }\n\n    //cout<<res<<endl;\n\n    reverse(pos.begin(), pos.end());\n    SegTree incr(n);\n    SegTree cnt(n);\n\n    for (auto x: pos)\n    {\n        int L = max(x+1, k);\n        int sum = incr.sum(x+1, n-1);\n        int tot = cnt.sum(x+1, n-1);\n        res = add(res, tot);\n        res = sub(res, mul(mul(sum, invdeg[max(x, k-1)]), inv(2)));\n        incr.upd(x, deg[max(x, k-1)]);\n        cnt.upd(x, 1);\n    }\n\n    cout<<res;\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n#define cauto const auto\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\ntemplate<class A,class B> pair<A,B> operator+(const pair<A,B> &p,const pair<A,B> &q){ return {p.X+q.X,p.Y+q.Y};}\ntemplate<class A,class B,class C,class D> pair<A,B>& operator+=(pair<A,B> &p,const pair<C,D> &q){ p.X+=q.X; p.Y+=q.Y; return p;}\ntemplate<class A,class B> pair<A,B> operator-(const pair<A,B> &p,const pair<A,B> &q){ return {p.X-q.X,p.Y-q.Y};}\ntemplate<class A,class B,class C,class D> pair<A,B>& operator-=(pair<A,B> &p,const pair<C,D> &q){ p.X-=q.X; p.Y-=q.Y; return p;}\ntemplate<class A,class B> istream& operator>>(istream &is, pair<A,B> &p){ is>>p.X>>p.Y; return is;}\ntemplate<class T=ll> T read(){ T re; cin>>re; return move(re);}\ntemplate<class T=ll> T read(const T &dec){ T re; cin>>re; return re-dec;}\ntemplate<class T=ll> vector<T> readV(const int sz){ vector<T> re(sz); for(auto &x:re) x=read<T>(); return move(re);}\ntemplate<class T=ll> vector<T> readV(const int sz, const T &dec){ vector<T> re(sz); for(auto &x:re) x=read<T>(dec); return move(re);}\nvv<int> readG(const int &n,const int &m){ vv<int> g(n); rep(_,m){ cauto a=read<int>(1),b=read<int>(1); g[a].pb(b); g[b].pb(a);} return move(g);}\nvv<int> readG(const int &n){ return readG(n,n-1);}\nconst ll MOD=998244353;\n\nll modpow_(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct ModInt{\n  int v;\n  ModInt(int v=0):v(v){}\n  ModInt operator+(const ModInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  ModInt operator-(const ModInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  ModInt operator*(const ModInt &n)const{return ll(v)*n.v%mod;}\n  ModInt operator/(const ModInt &n)const{return ll(v)*modpow_(n.v%mod,-1,mod)%mod;}\n  ModInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  ModInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  ModInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  ModInt operator/(const ll &n)const{return ll(v)*modpow_(n%mod,-1,mod)%mod;}\n  ModInt& operator+=(const ModInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  ModInt& operator-=(const ModInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  ModInt& operator*=(const ModInt &n){v=ll(v)*n.v%mod; return *this;}\n  ModInt& operator/=(const ModInt &n){v=ll(v)*modpow_(n.v,-1,mod)%mod; return *this;}\n  ModInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  ModInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  ModInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  ModInt& operator/=(const ll &n){v=ll(v)*modpow_(n,-1,mod)%mod; return *this;}\n\tbool operator==(const ModInt &n)const{return v==n.v;};\n\tbool operator!=(const ModInt &n)const{return v!=n.v;};\n\tModInt& operator++(){ return operator+=(1); }\n\tModInt& operator--(){ return operator-=(1); }\n\tModInt operator++(int i){ ModInt tmp(*this); operator++(); return tmp; }\n\tModInt operator--(int i){ ModInt tmp(*this); operator--(); return tmp; }\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow_(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow_(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const ModInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const ModInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> ModInt<mod> operator+(const ll &n,const ModInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> ModInt<mod> operator-(const ll &n,const ModInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> ModInt<mod> operator*(const ll &n,const ModInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> ModInt<mod> operator/(const ll &n,const ModInt<mod> &m){return ModInt<mod>(n%mod)/m;}\ntypedef ModInt<MOD> mint;\ntemplate <int mod> ModInt<mod> modpow(ModInt<mod> r,ll n){ ModInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(1123456);\nusing pmm=pair<mint,mint>;\nmint modpow(ll r,ll n){ return modpow_(r,n);}\n\nconst int nn=212345;\nmint bit[nn+1];\nint cnts[nn+1];\n\npair<mint,int> sum(int i){ ++i;\n\tmint s=0;\n\tint c=0;\n  while(i>0){\n    s+=bit[i];\n\t\tc+=cnts[i];\n    i-=i&-i;\n  }\n  return {s,c};\n}\n\nvoid add(int i,mint x){ ++i; ++i;\n  while(i<=nn){\n    bit[i]+=x;\n\t\tcnts[i]+=1;\n    i+=i&-i;\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tcauto n=read();\n\tcauto w=read();\n\tcauto p=readV(n,1);\n\tvector<int> ind(n); iota(all(ind),0);\n\tsort(all(ind),[&](cauto i,cauto j){return p[i]<p[j];});\n\tvector<int> ts(n);\n\trep(i,n) ts[i]=max<int>(0,i-(w-1));\n\tout(ts,1);\n\tmint re=0;\n\tmint rem=(w-1)*inv[w];\n\tvector<mint> pw(n+1); pw[0]=1;\n\trep(i,n) pw[i+1]=pw[i]*rem;\n\tvector<mint> sums(n);\n\trreps(i,1,n) sums[i-1]=sums[i]+pw[ts[i]];\n\tfor(cauto i:ind){\n\t\tmint div=inv[2]/pw[ts[i]];\n\t\tcauto [lt,c]=sum(n)-sum(i);\n\t\tmint gt=sums[i]-lt;\n\t\tout(i,c,lt,gt,div,1);\n\t\tre+=c-lt*div;\n\t\tre+=gt*div;\n\t\tadd(i,pw[ts[i]]);\n\t\t// reps(j,i+1,n){\n\t\t// \tmint prob=pw[ts[j]-ts[i]]*inv[2];\n\t\t// \tout(i,j,ts[j]-ts[i],prob,1);\n\t\t// \tif(p[i]>p[j]){\n\t\t// \t\tre+=1-prob;\n\t\t// \t}else{\n\t\t// \t\tre+=prob;\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<re NL;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nconst int M = 998244353;\n\nlong long modinv(long long a, long long m) {\n    long long x = m, y = a, p = 1, q = 0, r = 0, s = 1;\n    while (y != 0) {\n        long long u = x / y;\n        long long x0 = y; y = x - y * u; x = x0;\n        long long r0 = p - r * u, s0 = q - s * u;\n        p = r; r = r0; q = s; s = s0;\n    }\n    return q < 0 ? q + m : q;\n}\n\nlong long modexp(int x, long long e, int m) {\n    long long ans = 1, p = x % m;\n    while (e > 0) {\n        if (e % 2 != 0) ans = (ans * p) % m;\n        p = (p * p) % m;\n        e >>= 1;\n    }\n    return ans;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    int p[n]; for (int i = 0; i < n; i++) cin >> p[i];\n    vector<long long> ft(n+1, 0);\n    long long ans = 0;\n    long long b = (long long)(k - 1) * modinv(k, M) % M;\n    long long total = 0;\n    for (int i = 0; i < n; i++) {\n        long long sum = 0;\n        for (int x = p[i]; x > 0; x -= x&-x) sum += ft[x];\n        ans += (2 * sum - total) % M * modexp(b, max(i, k-1), M) % M;\n        long long add = modexp(b, M - max(i, k-1) - 1, M) * ((M + 1) / 2) % M;\n        // cerr << \"add \" << i << \" \" << add << endl;\n        for (int x = p[i]; x <= n; x += x&-x) ft[x] += add;\n        total += add;\n        // for (int i = 0; i < n; i++) cerr << ft[i+1] << ' ' ; cerr << endl;\n        // cerr << \"total = \" << total << endl;\n    }\n    fill(ft.begin(), ft.end(), 0);\n    for (int i = 0; i < n; i++) {\n        int s = 0;\n        for (int x = p[i]; x <= n; x += x&-x) s += ft[x];\n        for (int x = p[i]; x > 0; x -= x&-x) ft[x]++;\n        ans += s;\n    }\n    cout << (ans % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\nconst char newl = '\\n';\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntemplate<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}\ntemplate<typename T=Int>\nvector<T> read(size_t n){\n  vector<T> ts(n);\n  for(size_t i=0;i<n;i++) cin>>ts[i];\n  return ts;\n}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,Int k){\n    Mint num(1),dom(1);\n    for(Int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename T>\nclass BIT{\nprivate:\n  // \\sum_{j < i}  v[j]\n  T sum(Int i){\n    T s(0);\n    for(Int x=i;x>0;x-=(x&-x))\n      s+=bit[x];\n    return s;\n  }\npublic:\n  Int n;\n  vector<T> bit;\n  BIT(Int n_):n(n_+1),bit(n+1,0){}\n\n  // v[i] += a\n  void add(Int i,T a){\n    for(Int x=++i;x<=n;x+=(x&-x))\n      bit[x]+=a;\n  }\n  // \\sum_{l <= i < r} v[i]\n  T query(Int l,Int r){return sum(r)-sum(l);}\n\n  // min({x | sum(x) >= w})\n  Int lower_bound(const T w){\n    if(w<=0) return 0;\n    T r=w;\n    Int x=0,p=1;\n    while(p<n) p<<=1;\n    for(Int k=p;k>0;k>>=1){\n      if(x+k<=n&&bit[x+k]<r){\n        r-=bit[x+k];\n        x+=k;\n      }\n    }\n    x++;\n    assert(sum(x-1)<w and sum(x)>=w);\n    return x;\n  }\n\n  // min({x | sum(x) > w})\n  Int upper_bound(T w){return lower_bound(w+1);}\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,k;\n  cin>>n>>k;\n  auto ps=read(n);\n  // for(Int &p:ps) p--;\n\n  using M = Mint<Int, 998244353>;\n\n  M ans=M(k*(k-1)/2)/M(2);\n\n  BIT<M> bit(n+10),cnt(n+10);\n  for(Int i=0;i<k;i++){\n    Int p=ps[i];\n    bit.add(p,M(1));\n    cnt.add(p,M(1));\n  }\n\n  // assert(n!=k);\n\n  M ofs{1};\n  M ratio=M(k-1)/M(k);\n  for(Int i=k;i<n;i++){\n    ofs*=ratio;\n    Int p=ps[i];\n    ans+=(bit.query(0,n+10)*ofs)/M(2);\n    ans+=(cnt.query(p,n+10)-bit.query(p,n+10)*ofs);\n    bit.add(p,M(1)/ofs);\n    cnt.add(p,M(1));\n  }\n\n  cout<<ans<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<atcoder/modint>\nusing namespace std;\nusing namespace atcoder;\nusing mint=modint998244353;\nint N,K;\nint P[2<<17];\nmain()\n{\n\tcin>>N>>K;\n\tfor(int i=0;i<N;i++)cin>>P[i];\n\tmint ans=0;\n\tmint invK=mint(1)/K;\n\tmint X=mint(K-1)*invK;\n\tmint Y=mint(K-2)*invK;\n\tfor(int i=0;i<N;i++)for(int j=i+1;j<N;j++)\n\t{\n\t\tmint a=X.pow(max(0,j-max(K-1,i)))*invK;\n\t\tint  t=min(N-j,N-K);\n\t\tmint now=a*(1-Y.pow(t))/(1-Y)+a*Y.pow(t)/2*K;\n\t\tif(P[i]<P[j])ans+=now;\n\t\telse ans+=1-now;\n\t}\n\tcout<<ans.val()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Generated by powerful Codeforces Tool\n * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)\n * Author: alireza_kaviani\n * Time: 2020-09-20 17:31:24\n**/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\n\n#define all(x)                      (x).begin(),(x).end()\n#define Sort(x)                     sort(all((x)))\n#define X                           first\n#define Y                           second\n#define sep                         ' '\n#define endl                        '\\n'\n#define SZ(x)                       ll(x.size())\n#define lc\t\t\t\t\t\t\tid << 1\n#define rc\t\t\t\t\t\t\tlc | 1\n\nll poww(ll a, ll b, ll md) {\n    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));\n}\n\nconst ll MAXN = 2e5 + 10;\nconst ll LOG = 22;\nconst ll INF = 8e18;\nconst ll MOD = 998244353; // 1e9 + 9;\n\nint n , k , P[MAXN] , fen[MAXN];\nll seg[MAXN << 2] , lz[MAXN << 2];\n\nvoid shift(int id){\n\tlz[lc] = lz[lc] * lz[id] % MOD;\n\tlz[rc] = lz[rc] * lz[id] % MOD;\n\tseg[lc] = seg[lc] * lz[id] % MOD;\n\tseg[rc] = seg[rc] * lz[id] % MOD;\n\tlz[id] = 1;\n}\n\nvoid modify(int x , int v , int id = 1 , int l = 0 , int r = MAXN){\n\tif(r - l == 1){\n\t\tseg[id] = 1;\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tshift(id);\n\tif(x < mid)\tmodify(x , v , lc , l , mid);\n\telse\tmodify(x , v , rc , mid , r);\n\tseg[id] = (seg[lc] + seg[rc]) % MOD;\n}\n\nint get(int ql , int qr , int id = 1 , int l = 0 , int r = MAXN){\n\tif(qr <= l || r <= ql)\treturn 0;\n\tif(ql <= l && r <= qr)\treturn seg[id];\n\tint mid = l + r >> 1;\n\tshift(id);\n\treturn (get(ql , qr , lc , l , mid) + get(ql , qr , rc , mid , r)) % MOD;\n}\n\nvoid add(int x){\n\tfor( ; x < MAXN ; x += x & -x)\tfen[x]++;\n}\n\nint get(int x){\n\tint ans = 0;\n\tfor( ; x > 0 ; x -= x & -x)\tans += fen[x];\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tfill(lz , lz + MAXN * 4 , 1);\n\n\tcin >> n >> k;\n\tll inv2 = poww(2 , MOD - 2 , MOD) , invk = poww(k , MOD - 2 , MOD);\n\tfor(int i = 1 ; i <= n ; i++){\n\t\tcin >> P[i];\n\t}\n\tfor(int i = 1 ; i <= k ; i++){\n\t\tmodify(P[i] , 1);\n\t\tadd(P[i]);\n\t}\n\tll ans = 1ll * k * (k - 1) / 2 % MOD * inv2 % MOD;\n\tfor(int i = k + 1 ; i <= n ; i++){\n\t\tll x = 1ll * (k - 1) * invk % MOD;\n\t\tlz[1] = lz[1] * x % MOD;\n\t\tseg[1] = seg[1] * x % MOD;\n\t\tans = (ans + seg[1] * inv2) % MOD;\n//\t\tcout << ans << sep << x << endl;\n\t\tx = (get(n) - get(P[i]) - get(P[i] + 1 , MAXN) + MOD) % MOD;\n\t\tans = (ans + x) % MOD;\n//\t\tcout << i << sep << ans << endl;\n\t\tmodify(P[i] , 1);\n\t\tadd(P[i]);\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __SEGMENT_TREE_H__\n#define __SEGMENT_TREE_H__\n\n/* updated: 2020-07-23 */\n\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <limits>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <sstream>\n\n/*-- てんぷれ --*/\nstruct HogeMonoid {\n\tusing Type = int;\n\tstatic Type identity() {\n\t\treturn Type();\n\t}\n\tstatic Type operate(const Type& left, const Type& right) {\n\t\treturn Type();\n\t}\n};\n\n/*--------------*/\n\nnamespace Monoid {\n\ttemplate <class T>\n\tstruct Sum {\n\t\tusing Type = T;\n\t\tstatic Type identity() {\n\t\t\treturn T();\n\t\t}\n\t\tstatic Type operate(const Type& left, const Type& right) {\n\t\t\treturn left + right;\n\t\t}\n\t};\n\n\ttemplate <class T>\n\tstruct Minimum {\n\t\tusing Type = T;\n\t\tstatic Type identity() {\n\t\t\treturn std::numeric_limits<Type>::max();\n\t\t}\n\t\tstatic Type operate(const Type& left, const Type& right) {\n\t\t\treturn std::min(left, right);\n\t\t}\n\t};\n\n\ttemplate <class T>\n\tstruct Maximum {\n\t\tusing Type = T;\n\t\tstatic Type identity() {\n\t\t\treturn std::numeric_limits<Type>::lowest();\n\t\t}\n\t\tstatic Type operate(const Type& left, const Type& right) {\n\t\t\treturn std::max(left, right);\n\t\t}\n\t};\n}\n\n/* 注意: コンストラクタの引数は size でない */\ntemplate <class Monoid>\nclass SegmentTree {\n\tusing T = typename Monoid::Type;\n\n\tconst int level_m;\t\t// 段数 - 1\n\tconst size_t size_m;\t// 1 << level_m\n\tstd::vector<T> arr_m;\n\n\tstatic T identity();\n\tstatic T operate(const T& left, const T& right);\n\tbool isValidIndex(size_t pos) const;\n\t\n\tstatic const int Default = -1;\n\npublic:\n\texplicit SegmentTree(int level);\n\texplicit SegmentTree(int level, const T& init_val);\n\tvoid construct();\n\n\tvoid update(size_t pos, const T& value);\n\tT query(size_t left, size_t right) const;\n\tT get(size_t pos) const;\n\n\ttemplate <class Function>\n\tint findBoundary(Function func);\n\n\tvoid debug(int level = Default, int cell_width = 4) const;\n};\n\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::identity() {\n\treturn Monoid::identity();\n}\n\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::operate(const T& left, const T& right) {\n\treturn Monoid::operate(left, right);\n}\n\ntemplate<class Monoid>\ninline bool SegmentTree<Monoid>::isValidIndex(size_t pos) const {\n\treturn pos >= 0 && pos < size_m;\n}\n\n/* 1 << level 要素の segment tree_m を作成 */\ntemplate<class Monoid>\nSegmentTree<Monoid>::SegmentTree(int level)\n\t: level_m(level), size_m(1 << level) {\n\tassert(level < 32);\n\tarr_m.resize(size_m * 2, identity());\n}\n\ntemplate<class Monoid>\ninline SegmentTree<Monoid>::SegmentTree(int level, const T& init_val)\n\t: level_m(level), size_m(1 << level) {\n\tassert(level < 32);\n\n\tarr_m.resize(size_m * 2, init_val);\n\tconstruct();\n}\n\n/*\n// 次が成立するように木を構築する, 初期化用 O(N)\n// arr[i] = operate(arr[i * 2], arr[i * 2 + 1])\n*/\ntemplate<class Monoid>\nvoid SegmentTree<Monoid>::construct() {\n\tfor (int i = size_m - 1; i > 0; --i) {\n\t\tarr_m[i] = operate(arr_m[i * 2], arr_m[i * 2 + 1]);\n\t}\n}\n\n/* pos 番目の要素を value に書き換える */\ntemplate<class Monoid>\nvoid SegmentTree<Monoid>::update(size_t pos, const T& value) {\n\tpos += size_m;\n\tarr_m[pos] = value;\n\tpos >>= 1;\n\twhile (pos > 0) {\n\t\tarr_m[pos] = operate(arr_m[pos * 2], arr_m[pos * 2 + 1]);\n\t\tpos >>= 1;\n\t}\n}\n\n/* [left, right) に存在する全要素の(指定した演算に関する)積をとる */\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::query(size_t left, size_t right) const {\n\tassert(left <= right);\n\n\tT tmp_left = identity();\n\tT tmp_right = identity();\n\tleft += size_m;\n\tright += size_m;\n\twhile (left < right) {\n\t\tif (left & 1) tmp_left = operate(tmp_left, arr_m[left++]);\n\t\tif (right & 1) tmp_right = operate(arr_m[--right], tmp_right);\n\t\tleft >>= 1;\n\t\tright >>= 1;\n\t}\n\n\treturn operate(tmp_left, tmp_right);\n}\n\n/* pos 番目の要素を直接取得 */\ntemplate<class Monoid>\ntypename SegmentTree<Monoid>::T SegmentTree<Monoid>::get(size_t pos) const {\n\treturn arr_m[size_m + pos];\n}\n\n/*\n// SegmentTree 上の二分探索 O(log N)\n// func(query(0, i - 1)) == true かつ func(query(0, i)) == false となる i を(1つ)返す (0 <= i <= size)\n*/\ntemplate<class Monoid>\ntemplate<class Function>\nint SegmentTree<Monoid>::findBoundary(Function func) {\n\tif (func(arr_m[1])) return size_m;\t\t// 全要素 true のときは先に除外\n\n\tT cumul = identity();\n\tint right = 1;\n\twhile (right < size_m) {\n\t\tright <<= 1;\n\t\tT cumul_next = operate(cumul, arr_m[right]);\n\t\tif (func(cumul_next)) {\n\t\t\t++right;\n\t\t\tcumul = cumul_next;\n\t\t}\n\t}\n\treturn right - size_m;\n}\n\n/* デバッグ出力用; level = -1 とすると全要素出力 */\ntemplate<class Monoid>\nvoid SegmentTree<Monoid>::debug(int level, int cell_width) const {\n\t/* 値 value を幅 max_length になるように成形して文字列化 */\n\tauto to_str_fixed = [](const T& value, int max_length) -> std::string {\n\t\tstd::ostringstream osst;\n\t\tosst << value;\n\n\t\tstd::string str = osst.str();\n\t\tstd::string output;\n\t\tif (str.size() > max_length) {\n\t\t\tfor (int i = 0; i < max_length; ++i) {\n\t\t\t\toutput += '#';\n\t\t\t}\n\t\t} else {\n\t\t\tconst int remain_length = max_length - str.size();\n\t\t\tconst int right_blank = remain_length / 2;\n\t\t\tconst int left_blank = remain_length - right_blank;\n\t\t\tfor (int i = 0; i < left_blank; ++i) {\n\t\t\t\toutput += ' ';\n\t\t\t}\n\t\t\toutput += str;\n\t\t\tfor (int i = 0; i < right_blank; ++i) {\n\t\t\t\toutput += ' ';\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t};\n\n\tif (level == Default) {\t\t\t// デフォルト値への対処\n\t\tlevel = level_m;\n\t}\n\n\tif (level > level_m) {\n\t\tlevel = level_m;\n\t}\n\n\tstd::vector<std::string> output_strs;\n\n\tfor (int lev = 0; lev <= level; ++lev) {\n\t\tstd::string output;\n\t\tconst int front = size_m >> lev;\n\n\t\toutput += '|';\n\t\tfor (int i = 0; i < (1 << (level - lev)); ++i) {\n\t\t\toutput += to_str_fixed(arr_m[front + i], cell_width);\n\t\t\toutput += '|';\n\t\t}\n\t\toutput_strs.push_back(output);\n\n\t\tcell_width = cell_width * 2 + 1;\n\t}\n\n\treverse(output_strs.begin(), output_strs.end());\n\tfor (const std::string& output : output_strs) {\n\t\tstd::cout << output << std::endl;\n\t}\n}\n\n#endif\n#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2020-06-24 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h&& j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DiscreteLog.h\"\n#include \"DynamicMod.h\"\n#include \"Exponential.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Geometric2D.h\"\n#include \"Geometric2DFloat.h\"\n#include \"Geometric3D.h\"\n#include \"Geometric3DFloat.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"Interpolation.h\"\n#include \"IntMod.h\"\n#include \"KDTree.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"List.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Random.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"RollingHash.h\"\n#include \"RuntimeMod.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Timer.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#include <cctype>\n#include <bitset>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n//#define MF double\nint n, k;\nint a[200000];\nint main() {\n\tcin >> n >> k;\n\tREP(i, 0, n) {\n\t\tcin >> a[i];\n\t\t--a[i];\n\t}\n\n\n\tMF base = 1;\n\tSegmentTree<Monoid::Sum<MF>> seg(18);\n\tMF sum = MF(k) * (k - 1) / 2 / 2;\n\tREP(i, 0, k) {\n\t\tseg.update(a[i], base);\n\t}\n\n\tREP(i, k, n) {\n\t\tMF res = seg.query(a[i], n);\n\t\tMF tmp = res / k / base;\n\t\tsum += tmp * (k - 1) / 2;\n\t\tsum += (1 - tmp) * (i - MF(k - 1) / 2);\n\t\tbase *= MF(k) / (k - 1);\n\t\tseg.update(a[i], base);\n\t}\n\n\tcout << sum << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define debug(x) cerr << #x << \" == \" << (x) << '\\n';\n#define all(X) (X).begin(), (X).end()\n#define sz(X) (int)X.size()\n\nusing ll = long long;\n\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\n\ntemplate<typename T>\nT power(T x, ll p)\n{\n    T res = 1;\n    while (p)\n    {\n        if (p & 1) res *= x;\n        p >>= 1;\n        x *= x;\n    }\n    return res;\n}\n\ntemplate<ll MOD>\nstruct Mint\n{\n    ll x;\n    Mint(ll x = 0) : x(x % MOD) {};\n    Mint inv() const { assert(x != 0); return power(*this, MOD - 2); }\n    Mint& operator+=(const Mint& rhs) { x = (x + rhs.x) % MOD; return *this; }\n    Mint& operator-=(const Mint& rhs) { x = (x + MOD - rhs.x) % MOD; return *this; }\n    Mint& operator*=(const Mint& rhs) { x = (x * rhs.x) % MOD; return *this; }\n    Mint& operator/=(const Mint& rhs) { return *this *= rhs.inv(); }\n    Mint operator+(const Mint& rhs) const { return Mint(*this) += rhs; }\n    Mint operator-(const Mint& rhs) const { return Mint(*this) -= rhs; }\n    Mint operator*(const Mint& rhs) const { return Mint(*this) *= rhs; }\n    Mint operator/(const Mint& rhs) const { return Mint(*this) /= rhs; }\n    bool operator==(const Mint& rhs) const { return x == rhs.x; }\n    bool operator<(const Mint& rhs) const { return x < rhs.x; }\n};\n\ntemplate<typename T>\nclass BIT\n{\nprivate:\n    T op(T x, T y) { return x + y; }\n    T inv(T x) { return id - x; }\n    int b(int p) { return p & (-p); }\n    const int n; const T id;\n    vector<T> ft;\n    T query(int p)\n    {\n        T res = id;\n        for (int i = p; i >= 1; i -= b(i)) res = op(ft[i], res);\n        return res;\n    }\npublic:\n    BIT(int n, T id) : n(n), id(id) { ft.assign(n + 1, id); }\n    T query(int l, int r) { return op(inv(query(l)), query(r + 1)); }\n    void update(int p, T value)\n    {\n        for (int i = p + 1; i <= n; i += b(i)) ft[i] = op(ft[i], value);\n    }\n};\n\nint main()\n{ _\n    int n, k; cin >> n >> k;\n\n    constexpr ll MOD = 998244353LL;\n    using Mint = Mint<MOD>;\n\n    vector p(n, 0);\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> p[i]; --p[i];\n    }\n\n    auto P = Mint(k - 1) / k;\n\n    BIT bit(n, Mint(0));\n    BIT cnt(n, 0);\n\n    auto f = [&k](int i) { return max(i + 1 - k, 0); };\n\n    Mint ans = 0;\n\n    for (int i = 0; i < n; ++i)\n    {\n        auto cur = power(P, f(i));\n\n        ans += cur * bit.query(0, n - 1) / 2;\n        ans += Mint(cnt.query(p[i], n - 1)) - cur * bit.query(p[i], n - 1);\n\n        bit.update(p[i], cur.inv());\n        cnt.update(p[i], 1);\n    }\n\n    cout << ans.x << endl;\n\n    exit(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void chOut(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n    bool operator==(const ModInt &x) const { return (*this).val == x.val; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nstruct SegmentTree\n{\n    using T = mint;\n\n    int N;\n    vector<T> dat;\n\n    T id = 0;\n    T F(T &a, T &b) { return a + b; }\n    \n    SegmentTree(int n){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n    }\n\n    SegmentTree(int n, vector<T> &v){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n        for(int i = 0; i < n; i++) dat[i + N - 1] = v[i];\n        for(int i = N - 2; i >= 0; i--) dat[i] = F(dat[i * 2 + 1], dat[i * 2 + 2]); \n    }\n\n    SegmentTree(){}\n\n\n    void update(int k, T a){\n        k += N - 1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1) / 2;\n            dat[k] = F(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n\n    void reset() { fill(dat.begin(), dat.end(), id); }\n\n    T get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return id;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n            return F(vl, vr);\n        }\n    }\n    T get(int a, int b) { return get(a, b, 0, 0, N); }\n\n    T val(int k){ return dat[k + N - 1]; }\n};\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    vec p(N); cin >> p;\n    REP(i, N) p[i]--;\n\n    mint q0 = (mint)(K - 1) / K, r0 = (mint)K / (K - 1);\n    mint ans = (mint)K * (K - 1) / 4;\n\n    SegmentTree ST1(N), ST2(N);\n    mint qnow = 1, rnow = 1;\n    REP(i, K){\n        ST1.update(p[i], 1);\n        ST2.update(p[i], 1);\n    }\n    FOR(i, K, N){\n        qnow *= q0; rnow *= r0;\n        mint s1 = ST1.get(0, p[i]) * qnow, s2 = ST1.get(p[i], N) * qnow;\n        mint n1 = ST2.get(0, p[i]), n2 = ST2.get(p[i], N);\n        ans += (s1 - s2) / 2 + n2;\n        \n        ST1.update(p[i], rnow);\n        ST2.update(p[i], 1);\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 200000, md = 998244353, ti = 499122177;\nint p[N + 1], n, k;\n\nvoid ad(int &x, int y) { if ((x += y) >= md)x -= md; }\n\nstruct S{\n\tint pr, s, z;\n\tS():pr(), s(), z(1) {}\n\tS operator +(S const &o)const {\n\t\tS an;\n\t\tad(an.pr = pr, o.pr);\n\t\tan.s = s + o.s;\n\t\treturn an;\n\t}\n\tvoid up(int v){\n\t\tpr = (ll)pr * v % md;\n\t\tz = (ll)z * v % md;\n\t}\n}s[N << 2];\n\nvoid sl(int id, int a, int b){\n\tif (s[id].z != 1){\n\t\ts[a].up(s[id].z);\n\t\ts[b].up(s[id].z);\n\t\ts[id].z = 1;\n\t}\n}\n\nvoid st(int i, int l = 1, int r = n, int id = 1){\n\tif (l == r){\n\t\ts[id].pr = 1;\n\t\ts[id].s = 1;\n\t\treturn;\n\t}\n\tint m = l + r >> 1, a = id << 1, b = a | 1;\n\tsl(id, a, b);\n\tif (i <= m)st(i, l, m, a);\n\telse st(i, m + 1, r, b);\n\ts[id] = s[a] + s[b];\n}\n\nvoid up(int x, int y, int v, int l = 1, int r = n, int id = 1){\n\tif (l > y || r < x)return;\n\tif (l >= x && r <= y)return s[id].up(v);\n\tint m = l + r >> 1, a = id << 1, b = a | 1;\n\tsl(id, a, b);\n\tup(x, y, v, l, m, a);\n\tup(x, y, v, m + 1, r, b);\n\ts[id] = s[a] + s[b];\n}\n\nS gt(int x, int y, int l = 1, int r = n, int id = 1){\n\tif (l > y || r < x)return S();\n\tif (l >= x && r <= y)return s[id];\n\tint m = l + r >> 1, a = id << 1, b = a | 1;\n\tsl(id, a, b);\n\treturn gt(x, y, l, m, a) + gt(x, y, m + 1, r, b);\n}\n\nint pw(int x, int p){\n\tint an = 1;\n\twhile (p){\n\t\tif (p & 1)an = (ll)an * x % md;\n\t\tx = (ll)x * x % md;\n\t\tp >>= 1;\n\t}\n\treturn an;\n}\n\nint inv(int x) { return pw(x, md - 2); }\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tf(i, 1, n + 1)scanf(\"%d\", p + i);\n\tf(i, 1, k)st(p[i]);\n\tint an = (ll)(k - 2) * (k - 1) / 2 % md * ti % md, ki = inv(k);\n\tf(i, k, n + 1){\n\t\tad(an, (ll)s[1].pr * ti % md);\n\t\tS t = gt(p[i], n);\n\t\tad(an, t.s - t.pr);\n\t\tad(an, md);\n\t\tst(p[i]);\n\t\tup(1, n, (ll)(k - 1) * ki % md);\n\t}\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n//const int MOD = 1000000007;\nconst int MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst double pi = acos(-1.0);\nconst double EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<int mod>\nstruct Mod_Int{\n    ll x;\n\n    Mod_Int() : x(0) {}\n\n    Mod_Int(ll y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    Mod_Int &operator += (const Mod_Int &p){\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p){\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p){\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p){\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int &operator ++ () {return *this += Mod_Int(1);}\n\n    Mod_Int operator ++ (int){\n        Mod_Int tmp = *this;\n        ++*this;\n        return tmp;\n    }\n\n    Mod_Int &operator -- () {return *this -= Mod_Int(1);}\n\n    Mod_Int operator -- (int){\n        Mod_Int tmp = *this;\n        --*this;\n        return tmp;\n    }\n\n    Mod_Int operator - () const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int inverse() const {\n        assert(*this != Mod_Int(0));\n        return pow(mod-2);\n    }\n\n    Mod_Int pow(ll k) const{\n        Mod_Int now = *this, ret = 1;\n        while(k){\n            if(k&1) ret *= now;\n            now *= now, k >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator << (ostream &os, const Mod_Int &p){\n        return os << p.x;\n    }\n\n    friend istream &operator >> (istream &is, Mod_Int &p){\n        ll a;\n        is >> a;\n        p = Mod_Int<mod>(a);\n        return is;\n    }\n};\n\nusing mint = Mod_Int<MOD>;\n\ntemplate<typename Monoid>\nstruct Segment_Tree{\n    vector<Monoid> seg;\n    const Monoid e;\n    const int n;\n\n    Monoid f(const Monoid &a, const Monoid &b) const {return a + b;}\n    \n    Segment_Tree(int N, const Monoid &e) : e(e), n(1<<(32-__builtin_clz(N-1))){\n        seg.assign(2*n, e);\n    }\n    \n    void change(int i, const Monoid &x){\n        seg[i += n] = x;\n        while(i > 0){\n            i /= 2;\n            seg[i] = f(seg[2*i], seg[2*i+1]);\n        }\n    }\n\n    Monoid query(int a, int b, int i, int l, int r) const{\n        if(a >= r || b <= l) return e;\n        if(a <= l && r <= b) return seg[i];\n        Monoid vl = query(a, b, 2*i, l, (l+r)/2);\n        Monoid vr = query(a, b, 2*i+1, (l+r)/2, r);\n        return f(vl, vr);\n    }\n\n    Monoid query(int a, int b) {return query(a, b, 1, 0, n);}\n\n    bool check(const Monoid &a, const Monoid & b) const {return a <= b;}\n\n    int find_first(int a, int b, const Monoid &x, int i, int l, int r) const{\n        if(a >= b || a >= r || b <= l || !check(seg[i], x)) return -1;\n        if(r-l == 1) return l;\n        int m = (l+r)/2;\n        if(b <= m) return find_first(a, b, x, 2*i, l, m);\n        if(a >= m) return find_first(a, b, x, 2*i+1, m, r);\n        int tmp = find_first(a, m, x, 2*i, l, m);\n        return (tmp == -1? find_first(m, b, x, 2*i+1, m, r) : tmp);\n    }\n\n    int find_first(int a, int b, const Monoid &x) const {return find_first(a, b, x, 1, 0, n);}\n\n    int find_last(int a, int b, const Monoid &x, int i, int l, int r) const{\n        if(a >= b || a >= r || b <= l || !check(seg[i], x)) return -1;\n        if(r-l == 1) return l;\n        int m = (l+r)/2;\n        if(b <= m) return find_last(a, b, x, 2*i, l, m);\n        if(a >= m) return find_last(a, b, x, 2*i+1, m, r);\n        int tmp = find_last(m, b, x, 2*i+1, m, r);\n        return (tmp == -1? find_last(a, m, x, 2*i, l, m) : tmp);\n    }\n\n    int find_last(int a, int b, const Monoid &x) const {return find_last(a, b, x, 1, 0, n);}\n\n    Monoid operator [] (int i) const {return seg[n+i];}\n    \n    void clear(){\n        fill(all(seg), e);\n    }\n};\n\nint main(){\n    int N, K;\n    cin >> N >> K;\n    int p[N];\n    rep(i, N){\n        int x; cin >> x; x--;\n        p[x] = i;\n    }\n    Segment_Tree<mint> seg1(N, 0), seg2(N, 0);\n    mint r = mint(K-1)/mint(K);\n    mint pw[N];\n    rep(i, N){\n        if(i < K) pw[i] = 1;\n        else pw[i] = pw[i-1]*r;\n        seg1.change(i, 0), seg2.change(i, pw[i]);\n    }\n    mint ans = 0;\n    rep(i, N){\n        int j = p[i];\n        ans += seg1.query(j+1, N)*2;\n        ans += seg2.query(j+1, N)/pw[j];\n        seg1.change(j, 1), seg2.change(j, -seg2.query(j, j+1));\n    }\n    cout << ans/2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\n#include<atcoder/all>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\n\nusing mint = atcoder::modint998244353;\n\nmint bit[220000], bit2[220000];\n\nvoid add(mint* bit, int pos, mint x){\n    pos++;\n    while(pos < 220000){\n        bit[pos] += x;\n        pos += pos & -pos;\n    }\n}\n\nmint sum(mint* bit, int pos){\n    pos++;\n    mint ans = 0;\n    while(pos){\n        ans += bit[pos];\n        pos -= pos & -pos;\n    }\n    return ans;\n}\n\nint pos[220000];\nmint all_sum[220000];\n\n\nint main(){\n    int n, k;\n    cin >> n >> k;\n    mint P = mint(k-1) / mint(k);\n    mint Pinv = P.inv();\n    for(int i = 0;i < n;i++){\n        int x;\n        cin >> x;x--;\n        pos[x] = i;\n        all_sum[i] = Pinv.pow(max(i, k-1));\n        all_sum[i] += all_sum[i-1];\n    }\n    mint ans = 0;\n    for(int i = 0;i < n;i++){\n        int p = pos[i];\n        ans += p - sum(bit2, p);\n        add(bit2, p, 1);\n                \n        mint smaller = sum(bit, p);\n        \n        mint bigger = 0;\n        if(p)bigger = all_sum[p-1] - smaller;\n\n        ans += P.pow(max(p, k-1)) * smaller / mint(2);\n        ans -= P.pow(max(p, k-1)) * bigger / mint(2);\n\n        add(bit, p, Pinv.pow(max(p, k-1)));        \n    }\n    cout << ans.val() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nnamespace io {\n#define File(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\n  const int SIZE = (1 << 21) + 1;\n  char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1;\n  inline char getc () {return (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++);}\n  inline void flush () {fwrite (obuf, 1, oS - obuf, stdout); oS = obuf;}\n  inline void putc (char x) {*oS ++ = x; if (oS == oT) flush ();}\n  template<class T>\n  inline void read(T &x) {\n    char ch; int f = 1;\n    x = 0;\n    while(isspace(ch = getc()));\n    if(ch == '-') ch = getc(), f = -1;\n    do x = x * 10 + ch - '0'; while(isdigit(ch = getc()));\n    x *= f;\n  }\n  template<class T, class ...Args>\n  inline void read(T &x, Args&... args) {read(x); read(args...);}\n  template<class T>\n  inline void write(T x) {\n    static char stk[128];\n    int top = 0;\n    if(x == 0) {putc('0'); return;}\n    if(x < 0) putc('-'), x = -x;\n    while(x) stk[top++] = x % 10, x /= 10;\n    while(top) putc(stk[--top] + '0');\n  }\n  template<class T, class ...Args>\n  inline void write(T x, Args... args) {write(x); putc(' '); write(args...);}\n  inline void space() {putc(' ');}\n  inline void endl() {putc('\\n');}\n  struct _flush {~_flush() {flush();}} __flush;\n};\nusing io::read; using io::write; using io::flush; using io::space; using io::endl; using io::getc; using io::putc;\n\nconst int M = 998244353;\ninline int add(int x, int y) {return x+y>=M ? x+y-M : x+y;}\ntemplate<class ...Args> inline int add(int x, int y, Args... args) {return add(add(x, y), args...);}\ninline int sub(int x, int y) {return x-y<0 ? x-y+M : x-y;}\ninline int mul(int x, int y) {return 1LL * x * y % M;}\ntemplate<class ...Args> inline int mul(int x, int y, Args... args) {return mul(mul(x, y), args...);}\ninline void inc(int &x, int y=1) {x += y; if(x >= M) x -= M;}\ninline void dec(int &x, int y=1) {x -= y; if(x < 0) x += M;}\ninline int power(int x, int y){\n  int res = 1;\n  for(; y; y>>=1, x = mul(x, x)) if(y & 1) res = mul(res, x);\n  return res;\n}\ninline int inv(int x){return power(x, M - 2);}\n\nconst int N = 200005;\nint tr[N];\nint cnt[N];\nint n, tot = 0, totc = 0;\nvoid modify(int p, int v) {\n  inc(tot, v); ++totc;\n  for (; p <= n; p += p & -p) inc(tr[p], v), ++cnt[p];\n}\npair<int, int> query(int p) {\n  ll s = 0;\n  int c = 0;\n  for (; p; p ^= p & -p) s += tr[p], c += cnt[p];\n  return make_pair(int(s % M), c);\n}\n\nint p[N], Pk[N], iPk[N];\n\nint main() {\n  int k;\n  read(n, k);\n  for (int i = 1; i <= n; ++i)\n    read(p[i]);\n  int s1 = mul(k, k - 1, inv(4)), s2 = 0;\n  Pk[0] = 1; iPk[0] = 1;\n  Pk[1] = mul(k - 1, inv(k)); iPk[1] = inv(Pk[1]);\n  for (int i = 2; i <= n; ++i) Pk[i] = mul(Pk[i - 1], Pk[1]);\n  for (int i = 2; i <= n; ++i) iPk[i] = mul(iPk[i - 1], iPk[1]);\n  for (int i = 1; i <= k; ++i)\n    modify(p[i], iPk[k]);\n  for (int i = k + 1; i <= n; ++i) {\n    pair<int, int> q = query(p[i] - 1);\n    int lt = q.first, gt = sub(tot, lt);\n    int gtc = totc - q.second;\n    inc(s2, mul(lt, Pk[i]));\n    inc(s2, sub(add(gtc, gtc), mul(gt, Pk[i])));\n    modify(p[i], iPk[i]);\n  }\n  write(add(s1, mul(s2, (M + 1) / 2))), endl();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define REP(i, n) FOR(i, 0, (n))\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define LAR(a, b) ((a)=max((a),(b)))\n#define SML(a, b) ((a)=min((a),(b)))\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing pii = pair<int, int>;\nusing vpii = vector<pair<int, int>>;\ntemplate<typename T>\nusing pque = priority_queue<T, vector<T>, greater<T>>;\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define ALL(a) (a).begin(), (a).end()\n#ifdef LOCAL_DEBUG\n#define DEBUG(...) printf(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\nusing mint = modint998244353;\n#define N 212345\nint p[N];\n\nint main(){\n\tint n, k; scanf(\"%d%d\", &n, &k);\n\tREP(i, n) scanf(\"%d\", p+i);\n\tmint k1k = mint(k-1) / k;\n\tmint ans = 0;\n\tREP(i, n){\n\t\tFOR(j, i+1, n){\n\t\t\tint h = max(j-(k-1), 0) - max(i-(k-1), 0);\n\t\t\tDEBUG(\"(%d, %d) => %d\\n\", i, j, h);\n\t\t\tmint q = k1k.pow(h) * 1/2;\n\t\t\tif(p[i] > p[j]) q = 1-q;\n\t\t\tans += q;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.val());\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) begin(x), end(x)\n#define allR(x) rbegin(x), rend(x)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) {\n    using S = typename iterator_traits<It>::value_type;\n    using T = conditional_t<is_signed_v<S>,i64,u64>;\n    return accumulate(b,e,T{});\n}\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\ni64 irand(i64 a, i64 b) { return rand<i64>(a,b); }\nu64 urand(u64 a, u64 b) { return rand<u64>(a,b); }\n// <<<\n// >>> BIT\n\nstruct BIT {\n    int n;\n    vector<int> v; // use v[1..n]\n    BIT(int n = 0) : n(n), v(n+1) {}\n    int size() const { return n; }\n    int operator[](int i) const { return get(i); }\n    int get(int i) const { return sum(i+1)-sum(i); }\n    void set(int i, int x) { add(i,x-get(i)); }\n    void add(int i, int x) {\n        assert(0 <= i); assert(i < n);\n        for (i++; i <= n; i += i&(-i)) v[i] += x;\n    }\n    int sum(int r) const { // [0,r)\n        assert(0 <= r); assert(r <= n);\n        int s = 0;\n        for (int i = r; i > 0; i -= i&(-i)) s += v[i];\n        return s;\n    }\n    int sum(int l, int r) const { // [l,r)\n        return sum(r)-sum(l);\n    }\n    // lower_bound({sum(0),sum(1),...,sum(n)}, x)\n    int lower_bound(int x) const {\n        if (x <= 0) return 0;\n        int s = 0, i = 0, w = 1;\n        while (2*w <= n) w *= 2;\n        for ( ; w; w >>= 1) {\n            if (i+w <= n && s+v[i+w] < x) {\n                s += v[i+w];\n                i += w;\n            }\n        }\n        return i+1;\n    }\n    int upper_bound(int x) const {\n        int s = 0, i = 0, w = 1;\n        while (2*w <= n) w *= 2;\n        for ( ; w; w >>= 1) {\n            if (i+w <= n && s+v[i+w] <= x) {\n                s += v[i+w];\n                i += w;\n            }\n        }\n        return i+1;\n    }\n};\n\n// <<<\n// >>> modint\ntemplate <uint32_t md>\nclass modint {\n    static_assert(md < (1u<<31), \"\");\n    using M = modint;\n    using i64 = int64_t;\n    uint32_t x;\npublic:\n    static constexpr uint32_t mod = md;\n    constexpr modint(i64 x = 0) : x((x%=md) < 0 ? x+md : x) { }\n    constexpr i64 val() const { return x; }\n    constexpr explicit operator i64() const { return x; }\n    constexpr bool operator==(M r) const { return x == r.x; }\n    constexpr bool operator!=(M r) const { return x != r.x; }\n    constexpr M operator+() const { return *this; }\n    constexpr M operator-() const { return M()-*this; }\n    constexpr M& operator+=(M r) { x += r.x; x = (x < md ? x : x-md); return *this; }\n    constexpr M& operator-=(M r) { x += md-r.x; x = (x < md ? x : x-md); return *this; }\n    constexpr M& operator*=(M r) { x = (uint64_t(x)*r.x)%md; return *this; }\n    constexpr M& operator/=(M r) { return *this *= r.inv(); }\n    constexpr M operator+(M r) const { return M(*this) += r; }\n    constexpr M operator-(M r) const { return M(*this) -= r; }\n    constexpr M operator*(M r) const { return M(*this) *= r; }\n    constexpr M operator/(M r) const { return M(*this) /= r; }\n    friend constexpr M operator+(i64 x, M y) { return M(x)+y; }\n    friend constexpr M operator-(i64 x, M y) { return M(x)-y; }\n    friend constexpr M operator*(i64 x, M y) { return M(x)*y; }\n    friend constexpr M operator/(i64 x, M y) { return M(x)/y; }\n    constexpr M inv() const { assert(x > 0); return pow(md-2); }\n    constexpr M pow(i64 n) const {\n        assert(not (x == 0 && n == 0));\n        if (n < 0) return inv().pow(-n);\n        M v = *this, r = 1;\n        for (; n > 0; n >>= 1, v *= v) if (n&1) r *= v;\n        return r;\n    }\n#ifdef LOCAL\n    friend string to_s(M r) { return to_s(r.val(), mod); }\n#endif\n    friend ostream& operator<<(ostream& os, M r) { return os << r.val(); }\n    friend istream& operator>>(istream& is, M &r) { i64 x; is >> x; r = x; return is; }\n};\n// <<<\nconstexpr int64_t MOD = 998244353;\n//constexpr int64_t MOD = 1e9+7;\nusing mint = modint<MOD>;\n\n// >>> lazy segment tree\ntemplate <class Handler>\nstruct LazySegtree : Handler {\n    static int32_t btmbit(int64_t x) { return x ? __builtin_ctzll(x) : -1; }\n//    static int32_t btmbit(int32_t x) { return x ? __builtin_ctz(x) : -1; }\n\n    using Value = typename Handler::Value;\n    using Lazy = typename Handler::Lazy;\n    using Handler::unit_value; // () -> Value\n    using Handler::unit_action; // () -> Lazy\n    using Handler::merge; // (Value,Value) -> Value\n    using Handler::act; // (Lazy,Lazy&,Value&) -> void\n\n    vector<Value> v;\n    vector<Lazy> lz;\n    int n;\n    mutable Lazy tmp;\n\n    LazySegtree() {}\n    template <class... T> LazySegtree(T&&... x) { init(forward<T>(x)...); }\n\n    template <class F, class = decltype(declval<F>()(0))>\n    void init(int n, F gen)  {\n        assert(n >= 0); this->n = n;\n        v.resize(2*n); lz.assign(n, unit_action());\n        for (int i = 0; i < n; i++) v[n+i] = gen(i);\n        for (int i = n-1; i >= 1; i--) v[i] = merge(v[2*i],v[2*i+1]);\n    }\n    void init(int n) { init(n, [&](int) { return unit_value(); }); }\n    void init(int n, Value const& x) { init(n, [&](int) { return x; }); }\n    void init(vector<Value> const& v) { init(v.size(), [&](int i) { return v[i]; }); }\n    int size() const { return n; }\n\n\n    void act(Lazy const& x, int i) { act(x, (i < n ? lz[i] : tmp), v[i]); }\n    void flush(int k) {\n        if (n <= k || lz[k] == unit_action()) return;\n        act(lz[k], 2*k);\n        act(lz[k], 2*k+1);\n        lz[k] = unit_action();\n    }\n    void flush(int l, int r) {\n        for (int p = __lg(l += n), q = __lg(r += n-1); q; --p,--q) {\n            flush(l >> p); flush(r >> q);\n        }\n    }\n    void build(int i) {\n        i += n; i >>= btmbit(i);\n        while (i >>= 1) v[i] = merge(v[2*i],v[2*i+1]);\n    }\n    Value get(int l, int r) {\n        assert(0 <= l); assert(l <= r); assert(r <= n);\n        flush(l,r);\n        Value x = unit_value(), y = unit_value();\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l&1) x = merge(x,v[l++]);\n            if (r&1) y = merge(v[--r],y);\n        }\n        return merge(x,y);\n    }\n    void apply(int l, int r, Lazy const& x) {\n        assert(0 <= l); assert(l <= r); assert(r <= n);\n        flush(l,r);\n        for (int a = l+n, b = r+n; a < b; a >>= 1, b >>= 1) {\n            if (a&1) act(x, a++);\n            if (b&1) act(x, --b);\n        }\n        build(l); build(r);\n    }\n    Value operator[](int i) const { return get(i); }\n    Value get(int i) const {\n        assert(0 <= i); assert(i < n);\n        Value x = v[i += n];\n        while (i >>= 1) act(lz[i], tmp, x);\n        return x;\n    }\n    void set(int i, Value const& x) {\n        assert(0 <= i); assert(i < n);\n        for (int p = __lg(i += n); p; --p) flush(i >> p);\n        for (v[i] = x; i >>= 1; ) v[i] = merge(v[2*i],v[2*i+1]);\n    }\n    vector<Value> dat() const {\n        vector<Value> ret(size());\n        for (int i = 0; i < size(); i++) ret[i] = get(i);\n        return ret;\n    }\n};\n// <<<\nstruct H {\n    using Value = mint;\n    using Lazy = mint;\n    constexpr static Value unit_value() { return 0; }\n    constexpr static Lazy unit_action() { return 1; }\n    constexpr static Value merge(Value x, Value y) { return x+y; }\n    static void act(Lazy x, Lazy &y, Value &z) {\n        y *= x;\n        z *= x;\n    }\n};\n\nint32_t main() {\n    int n,k; cin >> n >> k;\n    vector<int> p(n);\n    rep (i,n) cin >> p[i], --p[i];\n\n    BIT bit(n);\n    rep (i,k) bit.add(p[i],1);\n\n    vector<mint> dp(n+1);\n    dp[k] = mint(1)*k*(k-1)/4;\n\n    LazySegtree<H> seg(n);\n    rep (i,k) seg.set(p[i],1);\n\n    loop (i,k,<n) {\n        seg.apply(0,seg.size(),mint(k-1)/k);\n        seg.set(p[i],1);\n\n        mint large = bit.sum(p[i]+1,n);\n        bit.add(p[i],1);\n\n        mint right_small = seg.get(0,p[i])/2;\n        mint right_large = seg.get(p[i]+1,n)/2;\n        mint left_large = large-right_large;\n\n        dp[i+1] = dp[i] + left_large + right_small;\n    }\n    dump(dp);\n\n    cout << dp[n] << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<db,db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a: x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\"; }\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\"); }\n    template<class T> void pr(const T& x) {\n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n        pr(\"}\"); }\n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        // cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\nconst int MOD = 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\ntemplate<class T> struct Seg { // comb(ID,b) = b\n\tconst T ID = 0; T comb(T a, T b) { return a+b; }\n\tint n; vector<T> seg;\n\tvoid init(int _n) { n = _n; seg.assign(2*n,ID); }\n\tvoid pull(int p) { seg[p] = comb(seg[2*p],seg[2*p+1]); }\n\tvoid upd(int p, T val) { // set val at position p\n\t\tseg[p += n] = val; for (p /= 2; p; p /= 2) pull(p); }\n\tT query(int l, int r) {\t// sum on interval [l, r]\n\t    if(l>r) return 0;\n\t\tT ra = ID, rb = ID;\n\t\tfor (l += n, r += n+1; l < r; l /= 2, r /= 2) {\n\t\t\tif (l&1) ra = comb(ra,seg[l++]);\n\t\t\tif (r&1) rb = comb(seg[--r],rb);\n\t\t}\n\t\treturn comb(ra,rb);\n\t}\n\tvoid add(int p, T val){\n        upd(p, query(p,p)+val);\n\t}\n};\n\nconst int MAX = 2e5 + 5;\nSeg<mi> orig;\nSeg<int> cnt;\nSeg<mi> make;\nmi po[MAX];\nmi ipo[MAX];\nint id[MAX];\nmi over[MAX];\nint main(){\n//    setIO(\"\");\n    ll n, k; re(n, k);\n    vi a(n);\n    f0r(i, n) re(a[i]), a[i]--;\n    mi p = 1-1/mi(k); //live\n    mi q = 1-p;\n    f0r(i, n+5){\n        if(i==0)po[i]=1;\n        else po[i]=po[i-1]*p;\n        if(i!=0) over[i] = 1/mi(i);\n        ipo[i] = 1/po[i];\n    }\n    f0r(i,n){\n        if(i<=k-1) id[i]=0;\n        else id[i] = i-k+1;\n    }\n    //make it\n    auto frac = [&](ll a, int b) -> mi{\n        return a*over[b];\n    };\n    mi ans = 0;\n    ans += k*(k-1)/2*over[2];\n    make.init(n);\n    orig.init(n);\n    cnt.init(n);\n    f0r(i, n){\n        make.add(id[i], po[id[i]]);\n    }\n    f0r(i, n){\n        ans += make.query(id[i]+1, n-1)*ipo[id[i]]*over[2];\n    }\n    f1r(i, k, n){\n        orig.add(a[i], po[id[i]]);\n        cnt.add(a[i], 1);\n    }\n    f0r(i, k){\n        ans += cnt.query(0,a[i]-1)-orig.query(0,a[i]-1)*ipo[id[i]];\n    }\n    f1r(i, k, n){\n        orig.add(a[i], -po[id[i]]);\n        cnt.add(a[i], -1);\n        ans += cnt.query(0,a[i]-1)-orig.query(0,a[i]-1)*ipo[id[i]];\n    }\n    ps(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include<bits/extc++.h>\n#define int long long\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define rep(i,n) for (int i=0;i<(int)(n);++i)\n#define rep1(i,n) for (int i=1;i<=(int)(n);++i)\n#define range(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define F first\n#define S second\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> VL;\n\n\nll power(ll u,ll v,ll mod){\n    ll ret=1,t=u%mod;\n    while (v){\n        if (v&1) ret=t*ret%mod;\n        t=t*t%mod, v>>=1;\n    }\n    return ret%mod;\n}\n \n/*\n计算gcd(a,b)并找寻ax+by=gcd(a,b)的一组解\nret=exgcd(a,b,x,y); \n*/\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if (b){\n        ll d=exgcd(b,a%b,y,x);\n        return y-=a/b*x, d;\n    }\n    return x=1,y=0,a;\n}\n \n/*\n计算x=a(mod m), x=b(mod n)的一组解，若无解返回-1\nret=crt(a,m,b,n);\n*/\nll crt(ll a,ll m,ll b,ll n){\n    if (n>m) swap(a,b), swap(n,m);\n    ll x,y,g=exgcd(m,n,x,y);\n    if ((b-a)%g) return -1;\n    x=(b-a)%n*x%n/g*m+a;\n    return x<0?x+m*n/g:x;\n}\n \n/*\n生成<=n的质数\ngen_prime<5000>(ret);\n*/\n \nvoid gen_prime(int n,vi &ret){\n    vector<bool> p;\n    p.resize(n+1,1);\n    p[0]=p[1]=0;\n    for (int i=4;i<=n;i+=2) p[i]=0;\n    for (int i=3;i*i<=n;i+=2){\n        if (p[i]){\n            for (int j=i*i;j<=n;j+=2*i){\n                p[j]=0;\n            }\n        }\n    }\n    for (int i=2;i<=n;++i){\n        if (p[i]) ret.pb(i);\n    }\n}\n \n/*\n生成<=n的phi\ngen_phi<5000>(ret);\n*/\nvoid gen_phi(int n,vi &phi){\n    phi.resize(n+1);\n    for (int i=0;i<=n;++i) phi[i]=i&1?i:i/2;\n    for (int i=3;i<=n;i+=2){\n        if (phi[i]==i){\n            for (int j=i;j<=n;j+=i) phi[j]-=phi[j]/i;\n        }\n    }\n}\n \n/*\n支持更高的快速幂操作\nexpower.mod_pow(a,b,mod);\n*/\n \nstruct expower{\n    ull mod_mul(ull a,ull b,ull M) {\n        ll ret=a*b-M*ull(ld(a)* ld(b)/ld(M));\n        return ret+M*(ret<0)-M*(ret>=(ll)M);\n    }\n    ull mod_pow(ull b,ull e,ull mod) {\n        ull ans=1;\n        for (; e; b=mod_mul(b,b,mod), e/=2)\n            if (e&1) ans=mod_mul(ans,b,mod);\n        return ans%mod;\n    }\n}expower;\n \n/*\nMiller-Rubin素数判别\nis_prime(n);\n*/\nbool is_prime(ull n){ \n    if (n<2||n%6%4!=1) return n-2<2;\n    ull A[]={2,325,9375,28178,450775,9780504,1795265022},\n    s=__builtin_ctzll(n-1), d = n >> s;\n    for (auto a:A){\n        ull p=expower.mod_pow(a,d,n),i=s;\n        while (p!=1&&p!=n-1&&a%n&&i--)\n            p=expower.mod_mul(p,p,n);\n        if (p!=n-1&&i!=s) return 0;\n    }\n    return 1;\n}\n \n/*\n素因数分解\nret=factorization(n);\n*/\null pollard(ull n){\n    auto f=[n](ull x){return (expower.mod_mul(x,x,n)+1)%n;};\n    if (!(n&1)) return 2;\n    for (ull i=2;;i++){\n        ull x=i,y=f(x),p;\n        while ((p=__gcd(n+y-x,n))==1)\n            x=f(x),y=f(f(y));\n        if (p!=n) return p;\n    }\n}\n \nvector<ull> factorization(ull n){\n    if (n==1) return {};\n    if (is_prime(n)) return {n};\n    ull x=pollard(n);\n    auto l=factorization(x),r=factorization(n/x);\n    l.insert(l.end(),range(r));\n    return l;\n}\n \nstruct DSU{\n    //insert info.\n    vector<int> p;\n    DSU(int n){\n        p.resize(n+1);\n        for (int i=1;i<=n;++i) p[i]=i;\n    }\n    int find(int u){\n        if (p[u]==u) return u;\n        return p[u]=find(find(p[u]));\n    } \n    bool unite(int u,int v){\n        int pu=find(u), pv=find(v);\n        if (pu!=pv){\n            p[pu]=pv;\n        }\n        return pu!=pv;\n    }\n};\n \n/* (u,v,w) */\ntemplate<class T> vector<tuple<int,int,T> > MST(int n,vector<tuple<int,int,T> >g){\n    vector<tuple<int,int,T> > ret;\n    ret.clear();\n    DSU dsu(n);\n    auto cmp=[&](tuple<int,int,T> x,tuple<int,int,T> y){\n        int ux,uy,vx,vy;\n        T wx,wy;\n        tie(ux,vx,wx)=x, tie(uy,vy,wy)=y;\n        return wx<wy;\n    };\n    sort(range(g),cmp);\n    for (auto c:g){\n        int u,v;\n        T w;\n        tie(u,v,w)=c;\n        if(dsu.unite(u,v)) ret.push_back(c);\n    }\n    return ret;\n}\n \ntemplate<int n,class T>\nstruct SegmentTree{\n    typedef struct{\n        T lz,mx,mn,sum;\n    }Node;\n    vector<Node> tree;\n    SegmentTree(){\n        tree.resize((n+7)<<2);\n    }  \n    void pushup(int num){\n        tree[num].mx=max(tree[num<<1].mx,tree[num<<1|1].mx);\n        tree[num].mn=min(tree[num<<1].mn,tree[num<<1|1].mn);\n        tree[num].sum=tree[num<<1].sum+tree[num<<1|1].sum;\n    }\n    void pushdown(int num,int l,int r,int md){\n        if (tree[num].lz){\n            tree[num<<1].mx+=tree[num].lz;\n            tree[num<<1|1].mx+=tree[num].lz;\n            tree[num<<1].mn+=tree[num].lz;\n            tree[num<<1|1].mn+=tree[num].lz;\n            tree[num<<1].sum+=tree[num].lz*(md-l+1);\n            tree[num<<1|1].sum+=tree[num].lz*(r-md);\n            tree[num<<1].lz+=tree[num].lz;\n            tree[num<<1|1].lz+=tree[num].lz;\n            tree[num].lz=0;\n        }\n    }\n    void update1(int num,int l,int r,int L,int R,T val){\n        if (L<=l&&r<=R){\n            tree[num].mx+=val;\n            tree[num].mn+=val;\n            tree[num].sum+=val*(r-l+1);\n            tree[num].lz+=val;\n            return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=L) update1(num<<1,l,md,L,R,val);\n        if (md<R) update1(num<<1|1,md+1,r,L,R,val);\n        pushup(num);\n    }\n    tuple<T,T,T> query1(int num,int l,int r,int L,int R){\n        if (L<=l&&r<=R){\n            return {tree[num].mn,tree[num].mx,tree[num].sum};\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=R){\n            return query1(num<<1,l,md,L,R);\n        }\n        else{\n            if (md<L){\n                return query1(num<<1|1,md+1,r,L,R);\n            }\n            else{\n                tuple<T,T,T> ret1=query1(num<<1,l,md,L,R), ret2=query1(num<<1|1,md+1,r,L,R);\n                T a,b,c,d,e,f;\n                tie(a,b,c)=ret1, tie(d,e,f)=ret2;\n                return {min(a,d),max(b,e),c+f};\n            }\n        } \n    }\n    void update(int L,int R,int w){\n        update1(1,1,n,L,R,w);\n    }\n    tuple<T,T,T> query(int L,int R){\n        return query1(1,1,n,L,R);\n    }\n    void debug1(int num,int l,int r){\n        if (l==r){\n            cout<<tree[num].mn<<\" \"; return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        debug1(num<<1,l,md);\n         debug1(num<<1|1,md+1,r);        \n    }\n    void debug(){\n        debug1(1,1,n);\n        cout<<endl;\n    }\n};\n \nstruct XORBasis{\n    int n;\n    vector<ull> p;\n    vector<ull> ans;\n    XORBasis(int k):n(k){\n        p.resize(k+1);\n    }\n    void rebuilt(){\n        ans.clear();\n        for (int i=0;i<=n;++i){\n            if (p[i]) ans.push_back(p[i]);\n        }\n    }\n    void insert(ull u){\n        for (int i=n;i>=0;--i){\n            if (u&(1ull<<i)){\n                if (p[i]) u^=p[i];\n                else{\n                    p[i]=u;\n                    for (int j=i-1;j>=0;--j){\n                        if (p[i]&(1ull<<j)) p[i]^=p[j];\n                    }\n                    for (int j=i+1;j<=n;++j){\n                        if (p[j]&(1ull<<i)) p[j]^=p[i];\n                    }\n                    break;\n                }\n            }\n        }\n        rebuilt();\n    }\n    bool check(ull u){\n        for (int i=n;i>-1;--i){\n            if (u&(1ull<<i)) u^=p[i];\n        }\n        return (u==0);\n    }\n    ull kth(ull t){ // the k-th smallest, excluding 0.\n        if (t>=(1ull<<sz(ans))) return -1;\n        ull ret=0;\n        for (int i=0;i<sz(ans);++i){\n            if (t&(1ull<<i)) ret^=ans[i];\n        }\n        return ret;\n    }\n    ull total(){\n        return (1ull<<sz(ans));\n    }\n};\n \n \nvi pi(const string& s) {\n\tvi p(sz(s));\n\tfor (int i=1;i<=sz(s);++i) {\n\t\tint g = p[i-1];\n\t\twhile (g && s[i] != s[g]) g = p[g-1];\n\t\tp[i] = g + (s[i] == s[g]);\n\t}\n\treturn p;\n}\n \nvi match(const string& s, const string& pat) {\n\tvi p = pi(pat + '\\0' + s), res;\n\tfor(int i=sz(p)-sz(s);i<=sz(p);++i)\n\t\tif (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));\n\treturn res;\n}\n \n \nstruct AhoCorasick {\n\tenum {alpha = 26, first = 'a'};\n\tstruct Node {\n\t\t// (nmatches is optional)\n\t\tint back, next[alpha], start = -1, end = -1;\n        ll nmatches = 0;\n\t\tNode(int v) { memset(next, v, sizeof(next)); }\n\t};\n\tvector<Node> N;\n\tvector<int> backp;\n\tvoid insert(string& s, int j,ll val) {\n\t\tassert(!s.empty());\n\t\tint n = 0;\n\t\tfor(auto c:s) {\n\t\t\tint& m = N[n].next[c - first];\n\t\t\tif (m == -1) { n = m = sz(N); N.emplace_back(-1); }\n\t\t\telse n = m;\n\t\t}\n\t\tif (N[n].end == -1) N[n].start = j;\n\t\tbackp.push_back(N[n].end);\n\t\tN[n].end = j;\n\t\tN[n].nmatches+=val;\n\t}\n\tAhoCorasick(vector<string>& pat,vi val) {\n\t\tN.emplace_back(-1);\n\t\tfor (int i=0;i<sz(pat);++i) insert(pat[i], i, val[i]);\n\t\tN[0].back = sz(N);\n\t\tN.emplace_back(0);\n \n\t\tqueue<int> q;\n\t\tfor (q.push(0); !q.empty(); q.pop()) {\n\t\t\tint n = q.front(), prev = N[n].back;\n\t\t\tfor (int i=0;i<alpha;++i) {\n\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];\n\t\t\t\tif (ed == -1) ed = y;\n\t\t\t\telse {\n\t\t\t\t\tN[ed].back = y;\n\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])\n\t\t\t\t\t\t= N[y].end;\n\t\t\t\t\tN[ed].nmatches += N[y].nmatches;\n\t\t\t\t\tq.push(ed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvi find(string& word,ll& ans) {\n\t\tint n = 0;\n\t\tvi res;\n\t\tfor(auto c:word) {\n\t\t\tn = N[n].next[c - first];\n\t\t\tres.push_back(N[n].end);\n\t\t\tans += N[n].nmatches;\n\t\t}\n\t\treturn res;\n\t}\n\tvector<vi> findAll(vector<string>& pat, string word) {\n\t\tll ans=0;\n        vi r = find(word,ans);\n\t\tvector<vi> res(sz(word));\n\t\tfor (int i=0;i<sz(word);++i) {\n\t\t\tint ind = r[i];\n\t\t\twhile (ind != -1) {\n\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);\n\t\t\t\tind = backp[ind];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n \nstruct HLD{\n    int n,cnt=0;\n    vector<vi> G;\n    vi par,dep,siz,son,top,dfn,rk; \n    //父亲节点，深度，子树大小，重子节点，重链头部，dfs序，dfs序对应的节点编号\n    HLD(vector<vi> g,int root=1):n(sz(g)),G(g),par(n+7),dep(n+7),siz(n+7,1),son(n+7,-1),top(n+7),dfn(n+7),rk(n+7){\n        dep[0]=-1, dfs1(root,0), dfs2(root,0,root);\n    }\n    void dfs1(int u,int p){\n        for (auto c:G[u]){\n            if (c==p) continue;\n            dep[c]=dep[u]+1, par[c]=u;\n            dfs1(c,u);\n            siz[u]+=siz[c];\n            if (son[u]==-1||siz[son[u]]<siz[c]) son[u]=c;\n        }\n    }\n    void dfs2(int u,int p,int tp){\n        top[u]=tp;\n        dfn[u]=++cnt;\n        rk[cnt]=u;\n        if (son[u]==-1) return;\n        dfs2(son[u],u,tp);\n        for (auto c:G[u]){\n            if (c==p||c==son[u]) continue;\n            dfs2(c,u,c);\n        }\n    }\n    int lca(int u,int v){\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                u=par[top[u]];\n            }\n            else{\n                v=par[top[v]];\n            }\n        }\n        return dep[u]>dep[v]?v:u;\n    }\n    vector<pii> find_seg(int u,int v){\n        vector<pii> ft,bk,res;\n        ft.clear(), bk.clear(), res.clear();\n//        cout<<top[u]<<\" \"<<top[v]<<endl;\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                ft.pb({u,top[u]});\n                u=par[top[u]];\n            }\n            else{\n                bk.pb({top[v],v});\n                v=par[top[v]];\n            }\n        }\n        ft.pb({u,v});\n        for (int i=0;i<sz(ft);++i) res.pb(ft[i]);\n        for (int i=sz(bk);i>0;--i) res.pb(bk[i-1]);\n        return res;\n    }\n};\n \nstruct BIT{\n    vi C; int n;\n    BIT(int n):n(n){C.resize(n+7,0);}\n    void update(int u,int w){\n        for (;u<=n;u+=u&(-u)) C[u]+=w;\n    }\n    int query(int u){\n        int res=0;\n        for (;u>0;u-=u&(-u)) res+=C[u];\n        return res; \n    }\n};\n\nvi topoSort(const vector<vi>& gr) {\n\tvi indeg(sz(gr)), ret;\n\tfor (auto& li : gr) for (int x : li) indeg[x]++;\n\tqueue<int> q; // use priority queue for lexic. smallest ans.\n\trep(i,sz(gr)) if (indeg[i] == 0) q.push(-i);\n\twhile (!q.empty()) {\n\t\tint i = -q.front(); // top() for priority queue\n\t\tret.push_back(i);\n\t\tq.pop();\n\t\tfor (int x : gr[i])\n\t\t\tif (--indeg[x] == 0) q.push(-x);\n\t}\n\treturn ret;\n}\n\nvi path;\nnamespace Eulerian {\n    const int N = 3, M = 3;\n    int t, n, m, tot, cc, hd[N], nxt[M], to[M], bh[M], vis[M], in[N], out[N], ans[M];\n    void add(int x, int y, int id) {\n        nxt[++tot] = hd[x];\n        hd[x] = tot;\n        to[tot] = y;\n        bh[tot] = id;\n        in[y]++;\n        out[x]++;\n    }\n    void dfs(int x) {\n        for (int i = hd[x]; i; i = hd[x]) {\n            while (i && vis[abs(bh[i])]) i = nxt[i];\n            hd[x] = i;\n            if (!i) break;\n            vis[abs(bh[i])] = 1;\n            dfs(to[i]), ans[++cc] = bh[i];\n        }\n    }\n \n    void init() {\n        memset(hd, 0, sizeof(hd));\n        memset(nxt, 0, sizeof(nxt));\n        memset(to, 0, sizeof(to));\n        memset(bh, 0, sizeof(bh));\n        memset(vis, 0, sizeof(vis));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n        memset(ans, 0, sizeof(ans));\n        t = 1;\n        n = 0;\n        m = 0;\n        tot = 0;\n        cc = 0;\n    }\n    bool solve() {\n        for (int i = 1; i <= n; i++)\n            if ((t == 1 && in[i] & 1)) {\n                return false;\n            }\n        dfs(to[1]);\n        if (cc < m) return false;\n        else {\n            path.clear();\n            for (int i = cc; i >= 1; i--) path.push_back(ans[i]);\n            return true;\n        }\n    }\n} // namespace Eulerian\n\nnamespace FWT{\n    //mod=-1 (no mod)\n    const int mod=-1;\n\n    inline int modadd(int a,int b){\n        a+=b;\n        if (mod==-1) return a;\n        a%=mod, a+=mod, a%=mod;\n        return a;\n    }\n\n    vi OR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j]=modadd(b[j],b[j^(1<<i)]*mode); \n            }\n        }\n        return b;\n    }\n    vi AND(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]*mode);\n            }\n        }\n        return b;\n    }\n    vi XOR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1){\n                    b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]);\n                    b[j]=modadd(b[j^(1<<i)],-2*b[j]);\n                    if (mode<0) {\n                        if (mod>0) b[j]=b[j]*power(2,mod-2,mod)%mod, b[j^(1<<i)]=b[j^(1<<i)]*power(2,mod-2,mod)%mod;\n                        else b[j]/=2, b[j^(1<<i)]/=2;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n}\n\nconst int maxn=200007;\nconst int mod=998244353;\n\nint inv(int u){\n    return power(u,mod-2,mod);\n}\nint mult(int u,int v){\n    return u*v%mod;\n}\nint n,k;\nint a[maxn],p[maxn],q[maxn];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin>>n>>k;\n    rep1(i,n) cin>>a[i],p[i]=i;\n    sort(p+1,p+n+1,[&](int u,int v){return a[u]<a[v];});\n    rep1(i,n) q[p[i]]=1;\n    BIT C(n),C0(n);\n    int ans=0,ans0=0;\n    rep1(i,n){\n        C.update(a[i],power(1+inv(k-1),max(0ll,i-k),mod));\n        C0.update(a[i],1);\n        int r=C.query(n)-C.query(a[i]);\n        if (r>0) ans=(ans+mult(r,power(1-inv(k)+mod,max(0ll,i-k),mod)))%mod;\n //       cout<<ans<<endl;\n        ans0=(ans0+C0.query(n)-C0.query(a[i]))%mod;\n    }\n    ans=(ans0-ans+mod)%mod;\n    int tmp=0;\n    tmp=k*(k-1)/2;\n    tmp%=mod;\n    for (int i=1;i<=n-k;++i){\n        tmp=(tmp+mult(k,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    for (int i=1;i<n-k;++i){\n        int w=n-k-i;\n        tmp=(tmp+mult(w,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    tmp=mult(tmp,inv(2));\n    cout<<(ans+tmp)%mod;\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <atcoder/all>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace atcoder;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N = 3000000;\nconst int K = 100000;\n//const int mod = 998244353;\n\nusing mint = modint998244353;\n\nmint p[N], s[N];\npair <int, int> a[N];\nmint op (mint x, mint y){\n    return x + y;\n}\nmint e (){\n    mint x = 0;\n    return x;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int n, k;\n    cin >> n >> k;\n    mint q = 0;\n    segtree <mint, op, e> t0(2 * n);\n    for (int i = 1; i <= n; i++){\n        cin >> a[i].F;\n        t0.set(a[i].F, 1);\n        if (i > k)\n        q += t0.prod(a[i].F + 1, n + n);\n        a[i].S = max(i - k + 1, 1LL);\n    }\n    mint x = k;\n    mint y = (x - 1) / x;\n    mint ans = x * (x - 1) / 2;\n    p[0] = 1;\n    for (int i = 1; i <= n; i++) p[i] = p[i - 1] * y;\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + p[i];\n    for (int i = 1; n - i - k + 1 > 0; i++){\n        ans += s[n - i - k + 1] ;\n        if (i == 1){\n            ans += (x - 1) * s[n - i - k + 1];\n        }\n    }\n    ans /= 2;\n    segtree <mint, op, e> t(2 * n);\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++){\n        mint z = t.get(a[i].S);\n        mint q = y.pow(a[i].S);\n        t.set(a[i].S, q + z);\n        z = t.prod(a[i].S + 1, n + n);\n        z *= y.pow(998244353 - a[i].S - 1);\n        ans -= z;\n    }\n    ans += q;\n    cout << ans.val();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<int, int>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << '\\n'\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 998244353;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\n\nusing mint = static_modint<mod>;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int n, k;\n    cin >> n >> k;\n    vi p(n);\n    rep(i, n) {\n        cin >> p[i];\n        p[i]--;\n    }\n\n    mint sum1 = 0;\n    mint sum2 = 0;\n    mint z = mint(k-1)/mint(k);\n    mint zinv = z.inv();\n    mint x = 1;\n    mint xinv = 1;\n    fenwick_tree<int> t(n);\n    fenwick_tree<mint> tw(n);\n    rep(i, n) {\n        if (i>=k) {\n            x *= z;\n            xinv *= zinv;\n        }\n        sum1 += tw.sum(0, p[i])*x/mint(2);\n        sum2 += t.sum(p[i]+1, n)-tw.sum(p[i]+1, n)*x/mint(2);\n        t.add(p[i], 1);\n        tw.add(p[i], xinv);\n    }\n    mint ans = sum1 + sum2;\n    pr(ans.val());\n\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for (ll i = a; i <= b; ++i)\n#define rep(i, n) for (ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for (ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size) \\\n    vector<type> name(size);  \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                       \\\n    vector<vector<type>> name(h, vector<type>(w)); \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...) \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)     \\\n    int __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define LL(...)     \\\n    ll __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define STR(...)        \\\n    string __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define CHR(...)      \\\n    char __VA_ARGS__; \\\n    IN(__VA_ARGS__)\n#define DBL(...)        \\\n    double __VA_ARGS__; \\\n    IN(__VA_ARGS__)\nint scan()\n{\n    return getchar();\n}\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S>\nvoid scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T>\nvoid scan(vector<T> &);\ntemplate <class T>\nvoid scan(vector<T> &a)\n{\n    for (auto &i : a)\n        scan(i);\n}\ntemplate <class T>\nvoid scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail>\nvoid IN(Head &head, Tail &... tail)\n{\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S>\ninline bool chmax(T &a, S b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S>\ninline bool chmin(T &a, S b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n)\n{\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <typename T>\nvi iota(vector<T> &a, bool greater = false)\n{\n    vi res(a.size());\n    iota(all(res), 0);\n    sort(all(res), [&](int i, int j) {\n        if (greater)\n            return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x)\n{\n    vector<pll> ans;\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.push_back({i, 1});\n            while ((x /= i) % i == 0)\n                ans.back().second++;\n        }\n    if (x != 1)\n        ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T>\nvector<T> divisor(T x)\n{\n    vector<T> ans;\n    for (T i = 1; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            ans.pb(i);\n            if (i * i != x)\n                ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T>\nvoid zip(vector<T> &x)\n{\n    vector<T> y = x;\n    sort(all(y));\n    for (int i = 0; i < x.size(); ++i)\n    {\n        x[i] = lb(y, x[i]);\n    }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io\n{\n    Setup_io()\n    {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in()\n{\n    int x;\n    cin >> x;\n    return x;\n}\nll lin()\n{\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T>\nstruct edge\n{\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x)\n    {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T>\nusing Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Tree res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if (!directed)\n            res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T>\nWgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1)\n{\n    Wgraph<T> res(n);\n    if (m == -1)\n        m = n - 1;\n    while (m--)\n    {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if (!directed)\n            res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST        \\\n    INT(testcases); \\\n    while (testcases--)\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v)\n{\n    for (auto &e : v)\n        cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S>\nostream &operator<<(ostream &os, const pair<T, S> &p)\n{\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T>\nstring to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A>\nstring to_string(A v)\n{\n    if (v.empty())\n        return \"{}\";\n    string ret = \"{\";\n    for (auto &x : v)\n        ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump(Head head, Tail... tail)\n{\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)        \\\n    cout << #x << \": \"; \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T>\nstatic constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\nnamespace modular\n{\n    constexpr ll MOD = 998244353;\n    const int MAXN = 1100000;\n    template <ll Modulus>\n    class modint\n    {\n        using u64 = ll;\n\n    public:\n        u64 a;\n\n        constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus) % Modulus) {}\n        constexpr u64 &value() noexcept { return a; }\n        constexpr const u64 &value() const noexcept { return a; }\n        constexpr modint operator+(const modint rhs) const noexcept { return modint(*this) += rhs; }\n        constexpr modint operator-(const modint rhs) const noexcept { return modint(*this) -= rhs; }\n        constexpr modint operator*(const modint rhs) const noexcept { return modint(*this) *= rhs; }\n        template <typename T>\n        constexpr modint operator^(T rhs) const noexcept { return modint(*this) ^= rhs; }\n        constexpr modint operator-() const noexcept { return modint() - *this; }\n        constexpr modint &operator+=(const modint rhs) noexcept\n        {\n            a += rhs.a;\n            if (a >= Modulus)\n            {\n                a -= Modulus;\n            }\n            return *this;\n        }\n        constexpr modint &operator-=(const modint rhs) noexcept\n        {\n            if (a < rhs.a)\n            {\n                a += Modulus;\n            }\n            a -= rhs.a;\n            return *this;\n        }\n        constexpr modint &operator*=(const modint rhs) noexcept\n        {\n            a = a * rhs.a % Modulus;\n            return *this;\n        }\n        constexpr bool operator==(const modint rhs) const noexcept { return a == rhs.a; }\n        template <typename T>\n        constexpr modint &operator^=(T n) noexcept\n        {\n            modint<Modulus> res = 1;\n            modint<Modulus> x = a;\n            while (n)\n            {\n                if (n & 1)\n                    res *= x;\n                x *= x;\n                n >>= 1;\n            }\n            a = res.a;\n            return *this;\n        }\n    };\n#define mint modint<MOD>\n#define vmint vector<mint>\n    vmint Inv{0, 1}, Prd{1, 1}, Invprd{1, 1};\n    mint inv(int n)\n    {\n        if (n > MAXN)\n            return mint(n) ^ (MOD - 2);\n        if (Inv.size() > n)\n            return Inv[n];\n        else\n        {\n            for (int i = Inv.size(); i <= n; ++i)\n                Inv.emplace_back(Inv[MOD % i] * (-MOD / i));\n            return Inv[n];\n        }\n    }\n    mint inv(mint x) { return inv(x.a); }\n    mint prd(int n)\n    {\n        if (Prd.size() > n)\n            return Prd[n];\n        else\n            for (int i = Prd.size(); i <= n; ++i)\n                Prd.emplace_back(Prd[i - 1] * i);\n        return Prd[n];\n    }\n    mint invprd(int n)\n    {\n        if (Invprd.size() > n)\n            return Invprd[n];\n        else\n            for (int i = Invprd.size(); i <= n; ++i)\n                Invprd.emplace_back(Invprd[i - 1] * inv(i));\n        return Invprd[n];\n    }\n    mint modpow(ll a, ll n)\n    {\n        mint x = a;\n        return x ^= n;\n    }\n    mint operator/(mint l, mint r) { return l * inv(r); }\n    mint &operator/=(mint &l, mint r) { return l = l / r; }\n    mint C(int a, int b)\n    {\n        if (a < 0 || b < 0)\n            return 0;\n        if (a < b)\n            return 0;\n        return prd(a) * invprd(b) * invprd(a - b);\n    }\n    mint P(int a, int b)\n    {\n        if (a < 0 || b < 0)\n            return 0;\n        if (a < b)\n            return 0;\n        return prd(a) * invprd(a - b);\n    }\n    ostream &operator<<(ostream &os, mint a)\n    {\n        os << a.a;\n        return os;\n    }\n    template <typename T>\n    ostream &operator<<(ostream &os, vector<T> a)\n    {\n        for (auto &e : a)\n            os << e << \" \";\n        return os;\n    }\n    mint operator*(ll x, mint y) { return y * x; }\n    istream &operator>>(istream &is, mint &a)\n    {\n        ll x;\n        is >> x;\n        a = x;\n        return is;\n    }\n    mint proot = 3;\n\n    void FMT(vmint &f, const bool is_inv = false)\n    {\n        const int n = f.size();\n        const mint root = is_inv ? inv(proot) : proot;\n        vmint g(n);\n        for (int b = n >> 1; b > 0; b >>= 1)\n        {\n            mint a = root ^ ((MOD - 1) / (n / b)), p = 1;\n            for (int i = 0; i < n; i += b << 1)\n            {\n                rep(j, b)\n                {\n                    f[i + j + b] *= p;\n                    g[(i >> 1) + j] = f[i + j] + f[i + b + j];\n                    g[(n >> 1) + (i >> 1) + j] = f[i + j] - f[i + b + j];\n                }\n                p *= a;\n            }\n            swap(f, g);\n        }\n        if (is_inv)\n            rep(i, n) f[i] *= inv(n);\n    }\n\n    vmint mul(vmint x, const vmint &y)\n    {\n        int n = x.size() + y.size() - 1;\n        int s = 1;\n        while (s < n)\n            s <<= 1;\n        x.resize(s);\n        FMT(x);\n        vmint z(s);\n        rep(i, y.size()) z[i] = y[i];\n        FMT(z);\n        rep(i, s) x[i] *= z[i];\n        FMT(x, true);\n        x.resize(n);\n        return x;\n    }\n\n    using Poly = vmint;\n    Poly operator-(Poly f)\n    {\n        for (auto &&e : f)\n            e = -e;\n        return f;\n    }\n    Poly &operator+=(Poly &l, const Poly &r)\n    {\n        l.resize(max(l.size(), r.size()));\n        rep(i, r.size()) l[i] += r[i];\n        return l;\n    }\n    Poly operator+(Poly l, const Poly &r) { return l += r; }\n    Poly &operator-=(Poly &l, const Poly &r)\n    {\n        l.resize(max(l.size(), r.size()));\n        rep(i, r.size()) l[i] -= r[i];\n        return l;\n    }\n    Poly operator-(Poly l, const Poly &r) { return l -= r; }\n    Poly &operator<<=(Poly &f, size_t n) { return f.insert(f.begin(), n, 0), f; }\n    Poly operator<<(Poly f, size_t n) { return f <<= n; }\n    Poly &operator>>=(Poly &f, size_t n) { return f.erase(f.begin(), f.begin() + min(f.size(), n)), f; }\n    Poly operator>>(Poly f, size_t n) { return f >>= n; }\n    Poly operator*(const Poly &l, const Poly &r) { return mul(l, r); }\n    Poly &operator*=(Poly &l, const Poly &r) { return l = l * r; }\n    Poly inv(const Poly &f)\n    {\n        Poly g{1 / f[0]};\n        while (g.size() < f.size())\n        {\n            Poly x(f.begin(), f.begin() + min(f.size(), g.size() << 1)), y = g;\n            x.resize(g.size() << 1), FMT(x);\n            y.resize(g.size() << 1), FMT(y);\n            rep(i, x.size()) x[i] *= y[i];\n            FMT(x, true);\n            x >>= g.size();\n            x.resize(g.size() << 1), FMT(x);\n            rep(i, x.size()) x[i] *= -y[i];\n            FMT(x, true);\n            g.insert(g.end(), x.begin(), x.begin() + g.size());\n        }\n        return Poly{begin(g), begin(g) + f.size()};\n    }\n    Poly integ(const Poly &f)\n    {\n        Poly res(f.size() + 1);\n        for (int i = 1; i < (int)res.size(); ++i)\n            res[i] = f[i - 1] / i;\n        return res;\n    }\n    Poly deriv(const Poly &f)\n    {\n        if (f.size() == 0)\n            return Poly();\n        Poly res(f.size() - 1);\n        rep(i, res.size()) res[i] = f[i + 1] * (i + 1);\n        return res;\n    }\n    Poly log(const Poly &f)\n    {\n        Poly g = integ(inv(f) * deriv(f));\n        return Poly{g.begin(), g.begin() + f.size()};\n    }\n    Poly exp(const Poly &f)\n    {\n        Poly g{1};\n        while (g.size() < f.size())\n        {\n            Poly x(f.begin(), f.begin() + min(f.size(), g.size() * 2));\n            x[0] += 1;\n            g.resize(2 * g.size());\n            x -= log(g);\n            x *= {g.begin(), g.begin() + g.size() / 2};\n            rep2(i, g.size() / 2, min<int>(x.size(), g.size()) - 1) g[i] = x[i];\n        }\n        return {g.begin(), g.begin() + f.size()};\n    }\n\n} // namespace modular\nusing namespace modular;\n\ntemplate <typename T = long long>\nstruct SegmentTree\n{\n    using F = function<T(T, T)>;\n#define clz(x) __builtin_clz(x)\n\n    SegmentTree(int n, const F f, const T &unit) : f(f), unit(unit), sz(n - 1 ? 1 << (32 - clz(n - 1)) : 1)\n    {\n        seg.assign(2 * sz, unit);\n    }\n\n    SegmentTree(vector<T> &a, const F f, const T &unit) : f(f), sz((int)a.size() > 1 ? 1 << (32 - clz(a.size() - 1)) : 1), unit(unit)\n    {\n        int n0 = a.size();\n        seg.assign(2 * sz, unit);\n        for (int i = 0; i < n0; ++i)\n            seg[i + sz] = a[i];\n        for (int i = sz - 1; i > 0; --i)\n            seg[i] = f(seg[i << 1], seg[(i << 1) | 1]);\n    }\n    const int sz;\n    vector<T> seg;\n    const F f;\n    const T unit;\n\n    void set(int k, T x) { seg[k + sz] = x; }\n\n    void build()\n    {\n        for (int i = sz - 1; i > 0; --i)\n            seg[i] = f(seg[i << 1], seg[(i << 1) | 1]);\n    }\n\n    T query(int l, int r)\n    {\n        T x = unit;\n        for (int d = r - l; d >= 1; d = r - l)\n        {\n            int L = l | ((1U << 31) >> clz(d));\n            int k = __builtin_ctz(L);\n            x = f(x, seg[(sz | l) >> k]);\n            l += L & (-L);\n        }\n        return x;\n    }\n\n    void update(int i, T x)\n    {\n        int k = i + sz;\n        seg[k] = x;\n        for (k = k >> 1; k > 0; k >>= 1)\n        {\n            seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);\n        }\n    }\n\n    void add(int i, T x)\n    {\n        int k = i + sz;\n        seg[k] += x;\n        for (k = k >> 1; k > 0; k >>= 1)\n        {\n            seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);\n        }\n    }\n    SegmentTree() = default;\n    T operator[](int k) const { return seg[sz + k]; }\n};\n\ntemplate <typename T>\nstruct RMQ : SegmentTree<T>\n{\n    RMQ(int n)\n        : SegmentTree<T>(\n              n, [](T i, T j) { return max(i, j); }, numeric_limits<T>::min())\n    {\n    }\n    RMQ(vector<T> &a)\n        : SegmentTree<T>(\n              a, [](T i, T j) { return max(i, j); }, numeric_limits<T>::min())\n    {\n    }\n};\n\ntemplate <typename T>\nstruct RmQ : SegmentTree<T>\n{\n    RmQ(int n)\n        : SegmentTree<T>(\n              n, [](T i, T j) { return min(i, j); }, numeric_limits<T>::max())\n    {\n    }\n    RmQ(vector<T> &a)\n        : SegmentTree<T>(\n              a, [](T i, T j) { return min(i, j); }, numeric_limits<T>::max())\n    {\n    }\n};\n\ntemplate <typename T>\nstruct RAQ : SegmentTree<T>\n{\n    RAQ(int n) : SegmentTree<T>(n, plus<T>(), 0) {}\n    RAQ(vector<T> &a) : SegmentTree<T>(a, plus<T>(), 0) {}\n};\nint main()\n{\n    INT(n, k);\n    VEC(int, a, n);\n    rep(i, n) a[i]--;\n    RAQ<mint> seg(n);\n    RAQ<mint> seg2(n);\n    rep(i, k) seg.update(a[i], 1), seg2.update(a[i], 1);\n    mint ans = (mint)k * (k - 1) * inv(4);\n    mint P = (mint)1 - inv(k);\n    mint Q = P;\n    rep2(i, k, n - 1)\n    {\n        mint c = seg.query(0, a[i]) * Q;\n        ans += seg2.query(a[i] + 1, n);\n        mint d = seg.query(a[i] + 1, n) * Q;\n        seg.update(a[i], inv(Q));\n        seg2.update(a[i], 1);\n        ans += (c - d) * inv(k) * ((mint)k * (k - 1) * inv(2)) * inv(k - 1);\n        Q *= P;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace/acl1/e/e.cpp\"\n#include <bits/extc++.h>\n\n#line 7 \"Library/alias.hpp\"\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i32 = int_least32_t;\nusing i64 = int_least64_t;\nusing i128 = __int128_t;\nusing u32 = uint_least32_t;\nusing u64 = uint_least64_t;\nusing u128 = __uint128_t;\ntemplate <class T, class Comp = less<T>>\nusing priority_queue = std::priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, vector<T>>;\nconstexpr i32 clz32(const u32 &n) noexcept { return __builtin_clz(n); }\nconstexpr i32 clz64(const u64 &n) noexcept { return __builtin_clzll(n); }\nconstexpr i32 ctz(const u64 &n) noexcept { return __builtin_ctzll(n); }\nconstexpr i32 popcnt(const u64 &n) noexcept { return __builtin_popcountll(n); }\n}  // namespace workspace\n#line 5 \"Library/config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 2 \"Library/option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library/utils/binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library/utils/casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library/utils/chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 4 \"Library/utils/coordinate_compression.hpp\"\n\ntemplate <class T>\nclass coordinate_compression\n{\n    std::vector<T> uniquely;\n    std::vector<size_t> compressed;\n\npublic:\n    coordinate_compression(const std::vector<T> &raw) : uniquely(raw), compressed(raw.size())\n    {\n        std::sort(uniquely.begin(), uniquely.end());\n        uniquely.erase(std::unique(uniquely.begin(), uniquely.end()), uniquely.end());\n        for(size_t i = 0; i != size(); ++i)\n            compressed[i] = std::lower_bound(uniquely.begin(), uniquely.end(), raw[i]) - uniquely.begin();\n    }\n\n    size_t operator[](const size_t idx) const\n    {\n        assert(idx < size());\n        return compressed[idx];\n    }\n\n    size_t size() const { return compressed.size(); }\n\n    size_t count() const { return uniquely.size(); }\n\n    T value_of(const size_t ord) const\n    {\n        assert(ord < count());\n        return uniquely[ord];\n    }\n\n    size_t order_of(const T &val) const { return std::lower_bound(uniquely.begin(), uniquely.end(), val) - uniquely.begin(); }\n\n    std::vector<size_t>::iterator begin() { return compressed.begin(); }\n    std::vector<size_t>::iterator end() { return compressed.end(); }\n    std::vector<size_t>::reverse_iterator rbegin() { return compressed.rbegin(); }\n    std::vector<size_t>::reverse_iterator rend() { return compressed.rend(); }\n};\n#line 3 \"Library/utils/fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 6 \"Library/utils/hash.hpp\"\n\n#line 3 \"Library/utils/sfinae.hpp\"\n#include <type_traits>\n\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\n\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n\ntemplate <class T, class = int> struct mapped_of {\n  using type = element_type<T>;\n};\ntemplate <class T>\nstruct mapped_of<T,\n                 typename std::pair<int, typename T::mapped_type>::first_type> {\n  using type = typename T::mapped_type;\n};\ntemplate <class T> using mapped_type = typename mapped_of<T>::type;\n\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#if __cplusplus >= 201402\ntemplate <class T>\nconstexpr static bool is_integral_ext_v = is_integral_ext<T>::value;\n#endif\n\ntemplate <typename T, typename = void> struct multiplicable_uint {\n  using type = uint_least32_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(2 < sizeof(T))>::type> {\n  using type = uint_least64_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(4 < sizeof(T))>::type> {\n  using type = __uint128_t;\n};\n#line 8 \"Library/utils/hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void> struct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type,\n            enable_if_trait_type<Unique_bits_type,\n                                 std::has_unique_object_representations>> {\n  size_t operator()(uint64_t x) const {\n    static const uint64_t m = std::random_device{}();\n    x ^= x >> 23;\n    x ^= m;\n    x ^= x >> 47;\n    return x - (x >> 32);\n  }\n};\ntemplate <class Key> size_t hash_combine(const size_t &seed, const Key &key) {\n  return seed ^\n         (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */);\n}\ntemplate <class T1, class T2> struct hash<std::pair<T1, T2>> {\n  size_t operator()(const std::pair<T1, T2> &pair) const {\n    return hash_combine(hash<T1>()(pair.first), pair.second);\n  }\n};\ntemplate <class... T> class hash<std::tuple<T...>> {\n  template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1>\n  struct tuple_hash {\n    static uint64_t apply(const Tuple &t) {\n      return hash_combine(tuple_hash<Tuple, index - 1>::apply(t),\n                          std::get<index>(t));\n    }\n  };\n  template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> {\n    static uint64_t apply(const Tuple &t) { return 0; }\n  };\n\n public:\n  uint64_t operator()(const std::tuple<T...> &t) const {\n    return tuple_hash<std::tuple<T...>>::apply(t);\n  }\n};\ntemplate <class hash_table> struct hash_table_wrapper : hash_table {\n  using key_type = typename hash_table::key_type;\n  size_t count(const key_type &key) const {\n    return hash_table::find(key) != hash_table::end();\n  }\n  template <class... Args> auto emplace(Args &&... args) {\n    return hash_table::insert(typename hash_table::value_type(args...));\n  }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table =\n    hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table =\n    hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key> using unordered_set = std::unordered_set<Key, hash<Key>>;\n}  // namespace workspace\n#line 3 \"Library/utils/make_vector.hpp\"\nnamespace workspace {\ntemplate <typename T, size_t N>\nconstexpr auto make_vector(size_t* sizes, T const& init = T()) {\n  if constexpr (N)\n    return std::vector(*sizes, make_vector<T, N - 1>(std::next(sizes), init));\n  else\n    return init;\n}\ntemplate <typename T, size_t N>\nconstexpr auto make_vector(const size_t (&sizes)[N], T const& init = T()) {\n  return make_vector<T, N>((size_t*)sizes, init);\n}\n}  // namespace workspace\n#line 3 \"Library/utils/random_number_generator.hpp\"\ntemplate <typename num_t>\nclass random_number_generator\n{\n    template <bool is_int, class = void>\n    struct unif_t\n    {\n        std::uniform_int_distribution<num_t> unif;\n        unif_t(num_t lower, num_t upper) : unif(lower, upper) {}\n        num_t operator()(std::mt19937 &engine) { return unif(engine); }\n    };\n    template <class void_t>\n    struct unif_t<false, void_t>\n    {\n        std::uniform_real_distribution<num_t> unif;\n        unif_t(num_t lower, num_t upper) : unif(lower, upper) {}\n        num_t operator()(std::mt19937 &engine) { return unif(engine); }\n    };\n    unif_t<std::is_integral<num_t>::value> unif;\n    std::mt19937 engine;\n  public:\n    // generate random number in [lower, upper].\n    random_number_generator(num_t lower = std::numeric_limits<num_t>::min(), num_t upper = std::numeric_limits<num_t>::max()) : unif(lower, upper), engine(std::random_device{}()) {}\n    num_t operator()() { return unif(engine); }\n}; // class random_number_generator\n#line 3 \"Library/utils/read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library/utils/stream.hpp\"\n\n#line 6 \"Library/utils/stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 4 \"Library/utils/trinary_search.hpp\"\n// trinary search on discrete range.\ntemplate <class iter_type, class comp_type>\niter_type trinary(iter_type first, iter_type last, comp_type comp)\n{\n    assert(first < last);\n    intmax_t dist(last - first);\n    while(dist > 2)\n    {\n        iter_type left(first + dist / 3), right(first + dist * 2 / 3);\n        if(comp(left, right)) last = right, dist = dist * 2 / 3;\n        else first = left, dist -= dist / 3;\n    }\n    if(dist > 1 && comp(first + 1, first)) ++first;\n    return first;\n}\n// trinary search on real numbers.\ntemplate <class comp_type>\nlong double trinary(long double first, long double last, const long double eps, comp_type comp)\n{\n    assert(first < last);\n    while(last - first > eps)\n    {\n        long double left{(first * 2 + last) / 3}, right{(first + last * 2) / 3};\n        if(comp(left, right)) last = right;\n        else first = left;\n    }\n    return first;\n}\n#line 2 \"Library/utils/wrapper.hpp\"\ntemplate <class Container> class reversed {\n  Container &ref, copy;\n\n public:\n  reversed(Container &ref) : ref(ref) {}\n  reversed(Container &&ref = Container()) : ref(copy), copy(ref) {}\n  auto begin() const { return ref.rbegin(); }\n  auto end() const { return ref.rend(); }\n};\n#line 7 \"atcoder-workspace/acl1/e/e.cpp\"\nnamespace workspace {\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // unspecified\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library/data_structure/segment_tree/basic.hpp\"\n\n#line 3 \"Library/algebra/system/monoid.hpp\"\ntemplate <class T> struct min_monoid {\n  using value_type = T;\n  static T min, max;\n  T value;\n  min_monoid() : value(max) {}\n  min_monoid(const T &value) : value(value) {}\n  operator T() const { return value; }\n  min_monoid operator+(const min_monoid &rhs) const {\n    return value < rhs.value ? *this : rhs;\n  }\n};\ntemplate <class T> T min_monoid<T>::min = std::numeric_limits<T>::min();\ntemplate <class T> T min_monoid<T>::max = std::numeric_limits<T>::max();\ntemplate <class T> struct max_monoid : min_monoid<T> {\n  using base = min_monoid<T>;\n  using base::min_monoid;\n  max_monoid() : base(base::min) {}\n  max_monoid operator+(const max_monoid &rhs) const {\n    return !(base::value < rhs.value) ? *this : rhs;\n  }\n};\n#line 7 \"Library/data_structure/segment_tree/basic.hpp\"\ntemplate <class Monoid, class Container = std::vector<Monoid>>\nclass segment_tree {\n  static_assert(std::is_same<Monoid, mapped_type<Container>>::value);\n\n  class unique_queue {\n    size_t *que, *begin, *end;\n    bool *in;\n\n   public:\n    unique_queue(size_t n)\n        : que(new size_t[n]), begin(que), end(que), in(new bool[n]{}) {}\n    ~unique_queue() {\n      delete[] que;\n      delete[] in;\n    }\n    void clear() { begin = end = que; }\n    bool empty() const { return begin == end; }\n    bool push(size_t index) {\n      if (in[index]) return false;\n      return in[*end++ = index] = true;\n    }\n    size_t pop() { return in[*begin] = false, *begin++; }\n  };  // struct unique_queue\n\n  size_t size_orig, height, size_ext;\n  Container data;\n  unique_queue que;\n\n  void recalc(const size_t node) {\n    data[node] = data[node << 1] + data[node << 1 | 1];\n  }\n\n  void repair() {\n    while (!que.empty()) {\n      const size_t index = que.pop() >> 1;\n      if (index && que.push(index)) recalc(index);\n    }\n    que.clear();\n  }\n\n  template <class Pred>\n  size_t left_search_subtree(size_t index, const Pred pred, Monoid mono) const {\n    assert(index);\n    while (index < size_ext) {\n      const Monoid tmp = data[(index <<= 1) | 1] + mono;\n      if (pred(tmp))\n        mono = tmp;\n      else\n        ++index;\n    }\n    return ++index -= size_ext;\n  }\n\n  template <class Pred>\n  size_t right_search_subtree(size_t index, const Pred pred,\n                              Monoid mono) const {\n    assert(index);\n    while (index < size_ext) {\n      const Monoid tmp = mono + data[index <<= 1];\n      if (pred(tmp)) ++index, mono = tmp;\n    }\n    return (index -= size_ext) < size_orig ? index : size_orig;\n  }\n\n public:\n  using value_type = Monoid;\n\n  segment_tree(const size_t n = 0)\n      : size_orig{n},\n        height(n > 1 ? 32 - __builtin_clz(n - 1) : 0),\n        size_ext{1u << height},\n        data(size_ext << 1),\n        que(size_ext << 1) {}\n\n  segment_tree(const size_t n, const Monoid &init) : segment_tree(n) {\n    std::fill(std::next(std::begin(data), size_ext), std::end(data), init);\n    for (size_t i{size_ext}; --i;) recalc(i);\n  }\n\n  template <class iter_type, class value_type = typename std::iterator_traits<\n                                 iter_type>::value_type>\n  segment_tree(iter_type first, iter_type last)\n      : size_orig(std::distance(first, last)),\n        height(size_orig > 1 ? 32 - __builtin_clz(size_orig - 1) : 0),\n        size_ext{1u << height},\n        data(size_ext << 1),\n        que(size_ext << 1) {\n    static_assert(std::is_constructible<Monoid, value_type>::value,\n                  \"Monoid(iter_type::value_type) is not constructible.\");\n    for (auto iter{std::next(std::begin(data), size_ext)};\n         iter != std::end(data) && first != last; ++iter, ++first)\n      *iter = Monoid{*first};\n    for (size_t i{size_ext}; --i;) recalc(i);\n  }\n\n  template <class Cont, typename = typename Cont::value_type>\n  segment_tree(const Cont &cont)\n      : segment_tree(std::begin(cont), std::end(cont)) {}\n\n  size_t size() const { return size_orig; }\n  size_t capacity() const { return size_ext; }\n\n  // reference to the element at the index.\n  Monoid &operator[](size_t index) {\n    assert(index < size_orig);\n    que.push(index |= size_ext);\n    return data[index];\n  }\n\n  // const reference to the element at the index.\n  const Monoid &operator[](size_t index) const {\n    assert(index < size_orig);\n    return data[index |= size_orig];\n  }\n\n  Monoid fold(size_t first, size_t last) {\n    assert(last <= size_orig);\n    repair();\n    Monoid leftval{}, rightval{};\n    first += size_ext, last += size_ext;\n    while (first < last) {\n      if (first & 1) leftval = leftval + data[first++];\n      if (last & 1) rightval = data[--last] + rightval;\n      first >>= 1, last >>= 1;\n    }\n    return leftval + rightval;\n  }\n\n  Monoid fold() { return fold(0, size_orig); }\n\n  template <class Pred> size_t left_search(size_t right, Pred pred) {\n    assert(right <= size_orig);\n    repair();\n    right += size_ext;\n    Monoid mono{};\n    for (size_t left{size_ext}; left != right; left >>= 1, right >>= 1) {\n      if ((left & 1) != (right & 1)) {\n        const Monoid tmp = data[--right] + mono;\n        if (!pred(tmp)) return left_search_subtree(right, pred, mono);\n        mono = tmp;\n      }\n    }\n    return 0;\n  }\n\n  template <class Pred> size_t right_search(size_t left, Pred pred) {\n    assert(left <= size_orig);\n    repair();\n    left += size_ext;\n    Monoid mono{};\n    for (size_t right{size_ext << 1}; left != right; left >>= 1, right >>= 1) {\n      if ((left & 1) != (right & 1)) {\n        const Monoid tmp = mono + data[left];\n        if (!pred(tmp)) return right_search_subtree(left, pred, mono);\n        mono = tmp;\n        ++left;\n      }\n    }\n    return size_orig;\n  }\n};  // class segment_tree\n#line 4 \"Library/modulus/modint.hpp\"\n\n#line 6 \"Library/modulus/modint.hpp\"\n\ntemplate <auto Mod = 0, typename Mod_type = decltype(Mod)> struct modint {\n  static_assert(is_integral_ext<decltype(Mod)>::value,\n                \"Mod must be integral type.\");\n  static_assert(!(Mod < 0), \"Mod must be non-negative.\");\n\n  using mod_type = typename std::conditional<\n      Mod != 0, typename std::add_const<Mod_type>::type, Mod_type>::type;\n  static mod_type mod;\n\n  using value_type = typename std::decay<mod_type>::type;\n\n  constexpr operator value_type() const noexcept { return value; }\n\n  constexpr static modint one() noexcept { return 1; }\n\n  constexpr modint() noexcept = default;\n\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n\n  constexpr modint(bool n) noexcept : modint(int(n)) {}\n\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (typename multiplicable_uint<value_type>::type)value *\n                   rhs.value % mod,\n           *this;\n  }\n\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      power(int_type e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    for (modint p{value}; e; e >>= 1, p *= p) {\n      if (e & 1) res *= p;\n    }\n    return res;\n  }\n\n  template <class int_type>\n  friend constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      pow(modint b, int_type e) noexcept {\n    modint res{1};\n    for ((e %= mod - 1) < 0 ? e += mod - 1 : 0; e; e >>= 1, b *= b)\n      if (e & 1) res *= b;\n    return res;\n  }\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    intmax_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\n\ntemplate <auto Mod, typename Mod_type>\ntypename modint<Mod, Mod_type>::mod_type modint<Mod, Mod_type>::mod = Mod;\n\nusing modint_runtime = modint<0>;\n#line 19 \"atcoder-workspace/acl1/e/e.cpp\"\n\nstruct workspace::solver {\n  using mint = modint<998244353>;\n\n  solver() {\n    // start here!\n    int n, k;\n    cin >> n >> k;\n    vector<int> p(n);\n    segment_tree<mint> seg(n), seg2(n);\n    segment_tree<int> seg3(n);\n    auto r = mint(k - 1) / k;\n    mint ans;\n    for (auto i = 0; i < n; ++i) {\n      cin >> p[i];\n      p[i]--;\n      if (i >= k) ans += seg3.fold(p[i], n) - pow(r, i) * seg.fold(p[i], n);\n      seg[p[i]] = pow(r, -max(k - 1, i));\n      seg3[p[i]] = 1;\n      ans += mint(min<int>(k - 1, i)) / 2;\n    }\n    cout << ans << eol;\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,P=998244353,inv2=(P+1)/2;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nint n,K,a[N],id[N];\nint fpow(int k1,int k2){\n\tint k3=1;\n\tfor(;k2;k2>>=1,k1=1LL*k1*k1%P)if(k2&1)k3=1LL*k3*k1%P;\n\treturn k3;\n}\nstruct BIT{\n\tint t[N];\n\tvoid upd(int k1,int k2){\n\t\tfor(int i=k1;i<=n;i+=i&-i)(t[i]+=k2)%=P;\n\t}\n\tint qry(int k1){\n\t\tint k2=0;\n\t\tfor(int i=k1;i;i&=i-1)(k2+=t[i])%=P;\n\t\treturn k2;\n\t}\n\tint qry(int l,int r){\n\t\tif(l>r)return 0;\n\t\treturn (qry(r)+P-(l<=1?0:qry(l-1)))%P;\n\t}\n}T1,T2,T3;\nbool cmp(int k1,int k2){return a[k1]>a[k2];}\nint main(){\n\trd(n),rd(K);\n\trep(i,1,n)rd(a[i]),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tint ans=0;\n\tint p=1LL*(K-1)*fpow(K,P-2)%P;\n\tint ip=fpow(p,P-2);\n\trep(_,1,n){\n\t\tint i=id[_];\n\t\tif(i<=K){\n\t\t\tint sumr=1LL*inv2*T1.qry(K+1,n)%P*fpow(ip,K)%P;\n\t\t\t(ans+=sumr)%=P;\n\t\t\tint suml=1LL*inv2*T3.qry(1,K)%P;\n\t\t\t(ans+=suml)%=P;\n\t\t}else{\n\t\t\tint sumr=1LL*inv2*T1.qry(i+1,n)%P*fpow(ip,i)%P;\n\t\t\t(ans+=sumr)%=P;\n\t\t\tint summ=(P+T3.qry(K+1,i-1)-1LL*inv2*T2.qry(K+1,i-1)%P*fpow(ip,n-i+1)%P)%P;\n\t\t\t(ans+=summ)%=P;\n\t\t\tint suml=(P+T3.qry(1,K)-1LL*inv2*T3.qry(1,K)%P*fpow(p,i-K)%P)%P;\n\t\t\t(ans+=suml)%=P;\n\t\t}\n\t\tT1.upd(i,fpow(p,i));\n\t\tT2.upd(i,fpow(p,n-i+1));\n\t\tT3.upd(i,1);\n\t}\n\tpt(ans,'\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << __LINE__ << ' ' << #x << ':' << x << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\ntemplate<class T> using pque = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr int mod1e9 = 1000000007;\nconstexpr int mod998 = 998244353;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\nconstexpr ll ten(int n) { return n ? 10 * ten(n - 1) : 1; };\nint dx[] = { 1,0,-1,0,1,1,-1,-1 }; int dy[] = { 0,1,0,-1,1,-1,1,-1 };\nvoid fail() { cout << \"-1\\n\"; exit(0); } void no() { cout << \"No\\n\"; exit(0); }\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> istream &operator >> (istream &s, vector<T> &v) { for (auto &e : v) s >> e; return s; }\ntemplate<class T> ostream &operator << (ostream &s, const vector<T> &v) { for (auto &e : v) s << e << ' '; return s; }\n\nstruct fastio {\n\tfastio() {\n\t\tcin.tie(0); cout.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(20);\n\t\tcerr << fixed << setprecision(20);\n\t}\n}fastio_;\n\ntemplate <int mod> class modint {\n\tint n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(ll n_) {\n\t\tn = n_ % mod;\n\t\tif (n < 0) n += mod;\n\t}\n\tmodint operator -() const { return n > 0 ? mod - n : -n; }\n\tbool operator == (const modint &m) const { return n == m.n; }\n\tbool operator != (const modint &m) const { return n != m.n; }\n\tmodint &operator += (const modint &m) { n += m.n; if (n >= mod) n -= mod; return *this; }\n\tmodint &operator -= (const modint &m) { n -= m.n; if (n < 0) n += mod; return *this; }\n\tmodint &operator *= (const modint &m) { n = ll(n) * m.n % mod; return *this; }\n\tmodint &operator /= (const modint &m) { n = ll(n) * m.inv().n % mod; return *this; }\n\tmodint operator +(modint m) const { return modint(*this) += m; }\n\tmodint operator -(modint m) const { return modint(*this) -= m; }\n\tmodint operator *(modint m) const { return modint(*this) *= m; }\n\tmodint operator /(modint m) const { return modint(*this) /= m; }\n\tmodint &operator ++ () { *this += 1; return *this; }\n\tmodint operator ++ (int) { *this += 1; return *this - 1; }\n\tmodint &operator -- () { *this -= 1; return *this; }\n\tmodint operator -- (int) { *this -= 1; return *this + 1; }\n\tmodint inv() const {\n\t\treturn (*this).pow(mod - 2);\n\t}\n\tmodint pow(ll b) const {\n\t\tmodint res = 1, a = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) res *= a;\n\t\t\ta *= a;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tfriend istream &operator >> (istream &s, modint<mod> &a) { s >> a.n; return s; }\n\tfriend ostream &operator << (ostream &s, modint<mod> &a) { s << a.n; return s; }\n};\n\nusing mint = modint<mod998>;\n\ntemplate<class T> class segtree {\n\tint n;\n\tvector<T> data;\n\tT id = 0;\n\tT operation(T a, T b) { return a + b; };\npublic:\n\tsegtree(int _n) {\n\t\tn = 1;\n\t\twhile (n < _n + 2) n <<= 1;\n\t\tdata = vector<T>(2 * n, id);\n\t}\n\tsegtree(vector<T> vec) {\n\t\tint _n = vec.size();\n\t\tn = 1;\n\t\twhile (n < _n + 2) n <<= 1;\n\t\tdata = vector<T>(2 * n, id);\n\t\tfor (int i = 0; i < _n; i++) data[i + n] = vec[i];\n\t\tfor (int i = n - 1; i >= 1; i--) data[i] = operation(data[i << 1], data[i << 1 | 1]);\n\t}\n\tvoid change(int i, T x) {\n\t\ti += n;\n\t\tdata[i] = x;\n\t\twhile (i > 1) {\n\t\t\ti >>= 1;\n\t\t\tdata[i] = operation(data[i << 1], data[i << 1 | 1]);\n\t\t}\n\t}\n\tvoid add(int i, T x) { change(i, data[i + n] + x); }\n\tT get(int a, int b) {\n\t\tT left = id; T right = id;\n\t\ta += n; b += n;\n\t\twhile (a < b) {\n\t\t\tif (a & 1) left = operation(left, data[a++]);\n\t\t\tif (b & 1) right = operation(data[--b], right);\n\t\t\ta >>= 1; b >>= 1;\n\t\t}\n\t\treturn operation(left, right);\n\t}\n\tT get_all() { return data[1]; }\n\tT operator[](int i) { return data[i + n]; }\n};\n\nint main() {\n\tll n, k;\n\tcin >> n >> k;\n\tvector<ll> p(n);\n\trep(i, n) {\n\t\tcin >> p[i];\n\t\tp[i]--;\n\t}\n\tsegtree<mint> left(n), right(n), cnt(n);\n\tmint ans = k * (k - 1);\n\tans /= 4;\n\tmint r = (mint)1 - (mint)1 / (mint)k;\n\tr = (mint)1 / r;\n\trep(i, k) {\n\t\tleft.add(p[i], 1);\n\t\tright.add(p[i], 1);\n\t\tcnt.add(p[i], 1);\n\t}\n\tfor (int i = k; i < n; i++) {\n\t\tint c = i - k + 1;\n\t\tmint x = left.get(0, p[i]);\n\t\tx /= r.pow(c);\n\t\tx /= 2;\n\t\tans += x;\n\t\tmint y = right.get(p[i] + 1, n + 1);\n\t\ty /= r.pow(c);\n\t\ty /= 2;\n\t\ty = cnt.get(p[i] + 1, n + 1) - y;\n\t\tans += y;\n\t\tleft.add(p[i], r.pow(c));\n\t\tright.add(p[i], r.pow(c));\n\t\tcnt.add(p[i], 1);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/fenwicktree>\n#include <atcoder/modint>\nusing namespace std;\nusing namespace atcoder;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf (INT_MAX/2-100)\n#define infl (LLONG_MAX/3)\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>bool chmax(t&a,u b){if(a<b)a=b;return a<b;}\ntemplate<class t,class u>bool chmin(t&a,u b){if(b<a)a=b;return b<a;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n\tint size(){\n\t\treturn v.size();\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\n\nusing mint = modint;\n\nll n,k;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tmint::set_mod(998244353);\n\tcin>>n>>k;\n\tmint p=mint(k-1)/mint(k),ans=0,q=p.inv();\n\tfenwick_tree<mint>bit(n),bit2(n);\n\trep(i,n){\n\t\tll a,t=max(k-1,ll(i));\n\t\tcin>>a;\n\t\ta--;\n\t\tans+=bit.sum(0,a)*p.pow(t)/(mint(2LL));\n\t\tans-=bit.sum(a,n)*p.pow(t)/(mint(2LL));\n\t\tans+=bit2.sum(a,n);\n\t\tbit.add(a,q.pow(t));\n\t\tbit2.add(a,mint(1LL));\n\t}\n\tprint(ans.val());\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace/acl1/e/e.cpp\"\n#include <bits/extc++.h>\n\n#line 7 \"Library/alias.hpp\"\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i32 = int_least32_t;\nusing i64 = int_least64_t;\nusing i128 = __int128_t;\nusing u32 = uint_least32_t;\nusing u64 = uint_least64_t;\nusing u128 = __uint128_t;\ntemplate <class T, class Comp = less<T>>\nusing priority_queue = std::priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, vector<T>>;\nconstexpr i32 clz32(const u32 &n) noexcept { return __builtin_clz(n); }\nconstexpr i32 clz64(const u64 &n) noexcept { return __builtin_clzll(n); }\nconstexpr i32 ctz(const u64 &n) noexcept { return __builtin_ctzll(n); }\nconstexpr i32 popcnt(const u64 &n) noexcept { return __builtin_popcountll(n); }\n}  // namespace workspace\n#line 5 \"Library/config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 2 \"Library/option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library/utils/binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library/utils/casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library/utils/chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 4 \"Library/utils/coordinate_compression.hpp\"\n\ntemplate <class T>\nclass coordinate_compression\n{\n    std::vector<T> uniquely;\n    std::vector<size_t> compressed;\n\npublic:\n    coordinate_compression(const std::vector<T> &raw) : uniquely(raw), compressed(raw.size())\n    {\n        std::sort(uniquely.begin(), uniquely.end());\n        uniquely.erase(std::unique(uniquely.begin(), uniquely.end()), uniquely.end());\n        for(size_t i = 0; i != size(); ++i)\n            compressed[i] = std::lower_bound(uniquely.begin(), uniquely.end(), raw[i]) - uniquely.begin();\n    }\n\n    size_t operator[](const size_t idx) const\n    {\n        assert(idx < size());\n        return compressed[idx];\n    }\n\n    size_t size() const { return compressed.size(); }\n\n    size_t count() const { return uniquely.size(); }\n\n    T value_of(const size_t ord) const\n    {\n        assert(ord < count());\n        return uniquely[ord];\n    }\n\n    size_t order_of(const T &val) const { return std::lower_bound(uniquely.begin(), uniquely.end(), val) - uniquely.begin(); }\n\n    std::vector<size_t>::iterator begin() { return compressed.begin(); }\n    std::vector<size_t>::iterator end() { return compressed.end(); }\n    std::vector<size_t>::reverse_iterator rbegin() { return compressed.rbegin(); }\n    std::vector<size_t>::reverse_iterator rend() { return compressed.rend(); }\n};\n#line 3 \"Library/utils/fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type> class fixed_point {\n  lambda_type func;\n\n public:\n  fixed_point(lambda_type &&f) : func(std::move(f)) {}\n  template <class... Args> auto operator()(Args &&... args) const {\n    return func(*this, std::forward<Args>(args)...);\n  }\n};\n}  // namespace workspace\n#line 6 \"Library/utils/hash.hpp\"\n\n#line 3 \"Library/utils/sfinae.hpp\"\n#include <type_traits>\n\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\n\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n\ntemplate <class T, class = int> struct mapped_of {\n  using type = element_type<T>;\n};\ntemplate <class T>\nstruct mapped_of<T,\n                 typename std::pair<int, typename T::mapped_type>::first_type> {\n  using type = typename T::mapped_type;\n};\ntemplate <class T> using mapped_type = typename mapped_of<T>::type;\n\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#if __cplusplus >= 201402\ntemplate <class T>\nconstexpr static bool is_integral_ext_v = is_integral_ext<T>::value;\n#endif\n\ntemplate <typename T, typename = void> struct multiplicable_uint {\n  using type = uint_least32_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(2 < sizeof(T))>::type> {\n  using type = uint_least64_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(4 < sizeof(T))>::type> {\n  using type = __uint128_t;\n};\n#line 8 \"Library/utils/hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void> struct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type,\n            enable_if_trait_type<Unique_bits_type,\n                                 std::has_unique_object_representations>> {\n  size_t operator()(uint64_t x) const {\n    static const uint64_t m = std::random_device{}();\n    x ^= x >> 23;\n    x ^= m;\n    x ^= x >> 47;\n    return x - (x >> 32);\n  }\n};\ntemplate <class Key> size_t hash_combine(const size_t &seed, const Key &key) {\n  return seed ^\n         (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */);\n}\ntemplate <class T1, class T2> struct hash<std::pair<T1, T2>> {\n  size_t operator()(const std::pair<T1, T2> &pair) const {\n    return hash_combine(hash<T1>()(pair.first), pair.second);\n  }\n};\ntemplate <class... T> class hash<std::tuple<T...>> {\n  template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1>\n  struct tuple_hash {\n    static uint64_t apply(const Tuple &t) {\n      return hash_combine(tuple_hash<Tuple, index - 1>::apply(t),\n                          std::get<index>(t));\n    }\n  };\n  template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> {\n    static uint64_t apply(const Tuple &t) { return 0; }\n  };\n\n public:\n  uint64_t operator()(const std::tuple<T...> &t) const {\n    return tuple_hash<std::tuple<T...>>::apply(t);\n  }\n};\ntemplate <class hash_table> struct hash_table_wrapper : hash_table {\n  using key_type = typename hash_table::key_type;\n  size_t count(const key_type &key) const {\n    return hash_table::find(key) != hash_table::end();\n  }\n  template <class... Args> auto emplace(Args &&... args) {\n    return hash_table::insert(typename hash_table::value_type(args...));\n  }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table =\n    hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table =\n    hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key> using unordered_set = std::unordered_set<Key, hash<Key>>;\n}  // namespace workspace\n#line 3 \"Library/utils/make_vector.hpp\"\nnamespace workspace {\ntemplate <typename T, size_t N>\nconstexpr auto make_vector(size_t* sizes, T const& init = T()) {\n  if constexpr (N)\n    return std::vector(*sizes, make_vector<T, N - 1>(std::next(sizes), init));\n  else\n    return init;\n}\ntemplate <typename T, size_t N>\nconstexpr auto make_vector(const size_t (&sizes)[N], T const& init = T()) {\n  return make_vector<T, N>((size_t*)sizes, init);\n}\n}  // namespace workspace\n#line 3 \"Library/utils/random_number_generator.hpp\"\ntemplate <typename num_t>\nclass random_number_generator\n{\n    template <bool is_int, class = void>\n    struct unif_t\n    {\n        std::uniform_int_distribution<num_t> unif;\n        unif_t(num_t lower, num_t upper) : unif(lower, upper) {}\n        num_t operator()(std::mt19937 &engine) { return unif(engine); }\n    };\n    template <class void_t>\n    struct unif_t<false, void_t>\n    {\n        std::uniform_real_distribution<num_t> unif;\n        unif_t(num_t lower, num_t upper) : unif(lower, upper) {}\n        num_t operator()(std::mt19937 &engine) { return unif(engine); }\n    };\n    unif_t<std::is_integral<num_t>::value> unif;\n    std::mt19937 engine;\n  public:\n    // generate random number in [lower, upper].\n    random_number_generator(num_t lower = std::numeric_limits<num_t>::min(), num_t upper = std::numeric_limits<num_t>::max()) : unif(lower, upper), engine(std::random_device{}()) {}\n    num_t operator()() { return unif(engine); }\n}; // class random_number_generator\n#line 3 \"Library/utils/read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library/utils/stream.hpp\"\n\n#line 6 \"Library/utils/stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 4 \"Library/utils/trinary_search.hpp\"\n// trinary search on discrete range.\ntemplate <class iter_type, class comp_type>\niter_type trinary(iter_type first, iter_type last, comp_type comp)\n{\n    assert(first < last);\n    intmax_t dist(last - first);\n    while(dist > 2)\n    {\n        iter_type left(first + dist / 3), right(first + dist * 2 / 3);\n        if(comp(left, right)) last = right, dist = dist * 2 / 3;\n        else first = left, dist -= dist / 3;\n    }\n    if(dist > 1 && comp(first + 1, first)) ++first;\n    return first;\n}\n// trinary search on real numbers.\ntemplate <class comp_type>\nlong double trinary(long double first, long double last, const long double eps, comp_type comp)\n{\n    assert(first < last);\n    while(last - first > eps)\n    {\n        long double left{(first * 2 + last) / 3}, right{(first + last * 2) / 3};\n        if(comp(left, right)) last = right;\n        else first = left;\n    }\n    return first;\n}\n#line 2 \"Library/utils/wrapper.hpp\"\ntemplate <class Container> class reversed {\n  Container &ref, copy;\n\n public:\n  reversed(Container &ref) : ref(ref) {}\n  reversed(Container &&ref = Container()) : ref(copy), copy(ref) {}\n  auto begin() const { return ref.rbegin(); }\n  auto end() const { return ref.rend(); }\n};\n#line 7 \"atcoder-workspace/acl1/e/e.cpp\"\nnamespace workspace {\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // unspecified\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library/data_structure/segment_tree/basic.hpp\"\n\n#line 3 \"Library/algebra/system/monoid.hpp\"\ntemplate <class T> struct min_monoid {\n  using value_type = T;\n  static T min, max;\n  T value;\n  min_monoid() : value(max) {}\n  min_monoid(const T &value) : value(value) {}\n  operator T() const { return value; }\n  min_monoid operator+(const min_monoid &rhs) const {\n    return value < rhs.value ? *this : rhs;\n  }\n};\ntemplate <class T> T min_monoid<T>::min = std::numeric_limits<T>::min();\ntemplate <class T> T min_monoid<T>::max = std::numeric_limits<T>::max();\ntemplate <class T> struct max_monoid : min_monoid<T> {\n  using base = min_monoid<T>;\n  using base::min_monoid;\n  max_monoid() : base(base::min) {}\n  max_monoid operator+(const max_monoid &rhs) const {\n    return !(base::value < rhs.value) ? *this : rhs;\n  }\n};\n#line 7 \"Library/data_structure/segment_tree/basic.hpp\"\ntemplate <class Monoid, class Container = std::vector<Monoid>>\nclass segment_tree {\n  static_assert(std::is_same<Monoid, mapped_type<Container>>::value);\n\n  class unique_queue {\n    size_t *que, *begin, *end;\n    bool *in;\n\n   public:\n    unique_queue(size_t n)\n        : que(new size_t[n]), begin(que), end(que), in(new bool[n]{}) {}\n    ~unique_queue() {\n      delete[] que;\n      delete[] in;\n    }\n    void clear() { begin = end = que; }\n    bool empty() const { return begin == end; }\n    bool push(size_t index) {\n      if (in[index]) return false;\n      return in[*end++ = index] = true;\n    }\n    size_t pop() { return in[*begin] = false, *begin++; }\n  };  // struct unique_queue\n\n  size_t size_orig, height, size_ext;\n  Container data;\n  unique_queue que;\n\n  void recalc(const size_t node) {\n    data[node] = data[node << 1] + data[node << 1 | 1];\n  }\n\n  void repair() {\n    while (!que.empty()) {\n      const size_t index = que.pop() >> 1;\n      if (index && que.push(index)) recalc(index);\n    }\n    que.clear();\n  }\n\n  template <class Pred>\n  size_t left_search_subtree(size_t index, const Pred pred, Monoid mono) const {\n    assert(index);\n    while (index < size_ext) {\n      const Monoid tmp = data[(index <<= 1) | 1] + mono;\n      if (pred(tmp))\n        mono = tmp;\n      else\n        ++index;\n    }\n    return ++index -= size_ext;\n  }\n\n  template <class Pred>\n  size_t right_search_subtree(size_t index, const Pred pred,\n                              Monoid mono) const {\n    assert(index);\n    while (index < size_ext) {\n      const Monoid tmp = mono + data[index <<= 1];\n      if (pred(tmp)) ++index, mono = tmp;\n    }\n    return (index -= size_ext) < size_orig ? index : size_orig;\n  }\n\n public:\n  using value_type = Monoid;\n\n  segment_tree(const size_t n = 0)\n      : size_orig{n},\n        height(n > 1 ? 32 - __builtin_clz(n - 1) : 0),\n        size_ext{1u << height},\n        data(size_ext << 1),\n        que(size_ext << 1) {}\n\n  segment_tree(const size_t n, const Monoid &init) : segment_tree(n) {\n    std::fill(std::next(std::begin(data), size_ext), std::end(data), init);\n    for (size_t i{size_ext}; --i;) recalc(i);\n  }\n\n  template <class iter_type, class value_type = typename std::iterator_traits<\n                                 iter_type>::value_type>\n  segment_tree(iter_type first, iter_type last)\n      : size_orig(std::distance(first, last)),\n        height(size_orig > 1 ? 32 - __builtin_clz(size_orig - 1) : 0),\n        size_ext{1u << height},\n        data(size_ext << 1),\n        que(size_ext << 1) {\n    static_assert(std::is_constructible<Monoid, value_type>::value,\n                  \"Monoid(iter_type::value_type) is not constructible.\");\n    for (auto iter{std::next(std::begin(data), size_ext)};\n         iter != std::end(data) && first != last; ++iter, ++first)\n      *iter = Monoid{*first};\n    for (size_t i{size_ext}; --i;) recalc(i);\n  }\n\n  template <class Cont, typename = typename Cont::value_type>\n  segment_tree(const Cont &cont)\n      : segment_tree(std::begin(cont), std::end(cont)) {}\n\n  size_t size() const { return size_orig; }\n  size_t capacity() const { return size_ext; }\n\n  // reference to the element at the index.\n  Monoid &operator[](size_t index) {\n    assert(index < size_orig);\n    que.push(index |= size_ext);\n    return data[index];\n  }\n\n  // const reference to the element at the index.\n  const Monoid &operator[](size_t index) const {\n    assert(index < size_orig);\n    return data[index |= size_orig];\n  }\n\n  Monoid fold(size_t first, size_t last) {\n    assert(last <= size_orig);\n    repair();\n    Monoid leftval{}, rightval{};\n    first += size_ext, last += size_ext;\n    while (first < last) {\n      if (first & 1) leftval = leftval + data[first++];\n      if (last & 1) rightval = data[--last] + rightval;\n      first >>= 1, last >>= 1;\n    }\n    return leftval + rightval;\n  }\n\n  Monoid fold() { return fold(0, size_orig); }\n\n  template <class Pred> size_t left_search(size_t right, Pred pred) {\n    assert(right <= size_orig);\n    repair();\n    right += size_ext;\n    Monoid mono{};\n    for (size_t left{size_ext}; left != right; left >>= 1, right >>= 1) {\n      if ((left & 1) != (right & 1)) {\n        const Monoid tmp = data[--right] + mono;\n        if (!pred(tmp)) return left_search_subtree(right, pred, mono);\n        mono = tmp;\n      }\n    }\n    return 0;\n  }\n\n  template <class Pred> size_t right_search(size_t left, Pred pred) {\n    assert(left <= size_orig);\n    repair();\n    left += size_ext;\n    Monoid mono{};\n    for (size_t right{size_ext << 1}; left != right; left >>= 1, right >>= 1) {\n      if ((left & 1) != (right & 1)) {\n        const Monoid tmp = mono + data[left];\n        if (!pred(tmp)) return right_search_subtree(left, pred, mono);\n        mono = tmp;\n        ++left;\n      }\n    }\n    return size_orig;\n  }\n};  // class segment_tree\n#line 4 \"Library/modulus/modint.hpp\"\n\n#line 6 \"Library/modulus/modint.hpp\"\n\ntemplate <auto Mod = 0, typename Mod_type = decltype(Mod)> struct modint {\n  static_assert(is_integral_ext<decltype(Mod)>::value,\n                \"Mod must be integral type.\");\n  static_assert(!(Mod < 0), \"Mod must be non-negative.\");\n\n  using mod_type = typename std::conditional<\n      Mod != 0, typename std::add_const<Mod_type>::type, Mod_type>::type;\n  static mod_type mod;\n\n  using value_type = typename std::decay<mod_type>::type;\n\n  constexpr operator value_type() const noexcept { return value; }\n\n  constexpr static modint one() noexcept { return 1; }\n\n  constexpr modint() noexcept = default;\n\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n\n  constexpr modint(bool n) noexcept : modint(int(n)) {}\n\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (typename multiplicable_uint<value_type>::type)value *\n                   rhs.value % mod,\n           *this;\n  }\n\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      power(int_type e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    for (modint p{value}; e; e >>= 1, p *= p) {\n      if (e & 1) res *= p;\n    }\n    return res;\n  }\n\n  template <class int_type>\n  friend constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      pow(modint b, int_type e) noexcept {\n    modint res{1};\n    for ((e %= mod - 1) < 0 ? e += mod - 1 : 0; e; e >>= 1, b *= b)\n      if (e & 1) res *= b;\n    return res;\n  }\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    intmax_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\n\ntemplate <auto Mod, typename Mod_type>\ntypename modint<Mod, Mod_type>::mod_type modint<Mod, Mod_type>::mod = Mod;\n\nusing modint_runtime = modint<0>;\n#line 19 \"atcoder-workspace/acl1/e/e.cpp\"\n\nstruct workspace::solver {\n  using mint = modint<998244353>;\n\n  solver() {\n    // start here!\n    int n, k;\n    cin >> n >> k;\n    vector<int> p(n);\n    segment_tree<mint> seg(n);\n    segment_tree<int> seg2(n);\n    auto r = mint(k - 1) / k;\n    auto ir = r.inverse();\n    mint rp = 1, irp = pow(ir, k - 1);\n    mint ans;\n    for (auto i = 0; i < n; ++i) {\n      cin >> p[i];\n      p[i]--;\n      if (i >= k) {\n        ans += seg2.fold(p[i], n) - rp * seg.fold(p[i], n);\n        irp *= ir;\n      }\n      seg[p[i]] = irp;\n      seg2[p[i]] = 1;\n      ans += mint(min<int>(k - 1, i)) / 2;\n      rp *= r;\n    }\n    cout << ans << eol;\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#define CPP17\n#include <limits>\n#include <initializer_list>\n#include <utility>\n#include <bitset>\n#include <tuple>\n#include <type_traits>\n#include <functional>\n#include <string>\n#include <array>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <iterator>\n#include <algorithm>\n#include <complex>\n#include <random>\n#include <numeric>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <regex>\n#include <cassert>\n#include <cstddef>\n#ifdef CPP17\n#include <variant>\n#endif\n\n#define endl codeforces\n\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\n\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pii = std::pair<int, int>;\nusing tii = std::tuple<int, int, int>;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\nusing size_type = ssize_t;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\n\ntemplate <typename T, std::size_t Head, std::size_t... Tail> \nstruct multi_dim_array { using type = std::array<typename multi_dim_array<T, Tail...>::type, Head>; };\n\ntemplate <typename T, std::size_t Head> \nstruct multi_dim_array<T, Head> { using type = std::array<T, Head>; };\n\ntemplate <typename T, std::size_t... Args> using mdarray = typename multi_dim_array<T, Args...>::type;\n\n#ifdef CPP17\ntemplate <typename T, typename F, typename... Args> \nvoid fill_seq(T &t, F f, Args... args) { \n    if constexpr (std::is_invocable<F, Args...>::value) { \n        t = f(args...); \n    } else { \n        for (size_type i = 0; i < t.size(); i++) fill_seq(t[i], f, args..., i); \n    } \n}\n#endif\n\ntemplate <typename T> vec<T> make_v(size_type sz) { return vec<T>(sz); }\n\ntemplate <typename T, typename... Tail> \nauto make_v(size_type hs, Tail&&... ts) { \n    auto v = std::move(make_v<T>(std::forward<Tail>(ts)...)); \n    return vec<decltype(v)>(hs, v); \n}\n\nnamespace init__ { \nstruct InitIO { \n    InitIO() { \n        std::cin.tie(nullptr); \n        std::ios_base::sync_with_stdio(false); \n        std::cout << std::fixed << std::setprecision(30); \n    } \n} init_io; \n}\ntemplate <typename T>\nT ceil_pow2(T bound) {\n    T ret = 1;\n    while (ret < bound) ret *= 2;\n    return ret;\n}\ntemplate <typename T>\nT ceil_div(T a, T b) { return a / b + !!(a % b); }\n#define CPP17\n\n\nnamespace math {\n\ntemplate <typename T>\nconstexpr T pow(const T &n, ll k) {\n    T ret = n.mul_id_ele();\n    T cur = n;\n    while (k) {\n        if (k & 1) ret *= cur;\n        cur *= cur;\n        k /= 2;\n    }\n    return ret;\n}\n\n\nll gcd(ll a, ll b) { return b ? gcd(a % b, b) : a; }\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nstruct Modint {\n\n    constexpr Modint(ll x) noexcept : x(static_cast<ll>((Mod + x % Mod) % Mod)) { }\n    \n    constexpr Modint() noexcept : Modint(0) { }\n    \n    constexpr Modint<Mod> add_id_ele() const noexcept { \n        return Modint<Mod>(0); \n    }\n    \n    constexpr Modint<Mod> mul_id_ele() const noexcept {\n        return Modint<Mod>(1); \n    }\n    \n    constexpr ll value() const noexcept {\n        return static_cast<ll>(x); \n    }\n\n    constexpr Modint& operator+=(const Modint &oth) noexcept {\n        x += oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator-=(const Modint &oth) noexcept {\n        x += Mod - oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator*=(const Modint &oth) noexcept {\n        x *= oth.value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator/=(const Modint &oth) noexcept {\n        x *= oth.inv().value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint operator+(const Modint &oth) const noexcept {\n        return Modint(x) += oth;\n    }\n\n    constexpr Modint operator-(const Modint &oth) const noexcept {\n        return Modint(x) -= oth;\n    }\n\n    constexpr Modint operator*(const Modint &oth) const noexcept {\n        return Modint(x) *= oth;\n    }\n\n    constexpr Modint operator/(const Modint &oth) const noexcept {\n        return Modint(x) /= oth;\n    }\n\n    constexpr Modint operator-() const noexcept {\n        return Modint((x != 0) * (Mod - x)); \n    }\n\n    constexpr bool operator==(const Modint &oth) const noexcept {\n        return value() == oth.value();\n    }\n\n    template <typename T>\n    constexpr typename std::enable_if<std::is_integral<T>::value, const Modint&>::type\n    operator=(T t) noexcept {\n        (*this) = Modint(std::forward<T>(t)); \n        return *this;\n    }\n\n    constexpr Modint inv() const noexcept {\n        return ::math::pow(*this, Mod - 2);\n    }\n\n    constexpr ll mod() const noexcept {\n        return static_cast<ll>(Mod);\n    }\n\nprivate:\n    ll x;\n};\n\ntemplate <ll Mod>\nModint<Mod> inv(Modint<Mod> m) {\n    m.inv();\n    return m;\n}\n\ntemplate <ll Mod>\nstd::istream& operator>>(std::istream &is, Modint<Mod> &m) {\n    ll v;\n    is >> v;\n    m = v;\n    return is;\n}\n\ntemplate <ll Mod>\nstd::ostream& operator<<(std::ostream &os, Modint<Mod> m) {\n    os << m.value();\n    return os;\n}\n\n}\n\nnamespace utility {\n\ntemplate <typename T>\nusing validate_integer = typename std::enable_if<std::is_integral<T>::value, ll>::type;\n\ntemplate <typename T>\nauto popcount(T n) -> validate_integer<T> {\n    return __builtin_popcountll(n);\n}\n\n// 0 indexed\ntemplate <typename T>\nauto msb(T n) -> validate_integer<T> {\n    return 64 - __builtin_clzll(n) - 1;\n}\n\n}\n\nnamespace tree {\n\ntemplate <typename T>\nstruct BIT {\n    using size_type = ssize_t;\n    vec<T> data;\n    T id_ele;\n\n    BIT(size_type sz, T id_ele) : id_ele(id_ele) {\n        data = vec<T>(ceil_pow2(sz) + 1, id_ele);\n    }\n\n    // [0, pos)\n    T sum(size_type pos) const {\n        T ret = id_ele;\n        for (; 0 < pos; pos -= pos & -pos) ret += data[pos];\n        return ret;\n    }\n\n    // [l, r)\n    T sum(size_type l, size_type r) const { \n        return sum(r) - sum(l); \n    }\n\n    void add(ll pos, T delta) {\n        for (++pos; pos < data.size(); pos += pos & -pos) data[pos] += delta;\n    }\n\n    // sum(ret) < bound <= sum(ret+1)\n    size_type lower_bound(T bound) const {\n        if (data.back() < bound) return data.size();\n        T sum = id_ele;\n        size_type ret = 0;\n        for (size_type i = (data.size() - 1) / 2; 0 < i; i /= 2) {\n            if (sum + data[ret + i] < bound) {\n                ret += i;\n                sum += data[ret];\n            }\n        }\n        return ret;\n    }\n};\n\n}\n\nint main() {\n    constexpr ll mod = 998244353;\n    using mint = math::Modint<mod>;\n\n    ll n, k;\n    std::cin >> n >> k;\n    vec<ll> pv(n);\n    for (ll &e : pv) {\n        std::cin >> e;\n        e--;\n    }\n\n    vec<ll> rpv(n);\n    for (ll i = 0; i < n; i++) rpv[pv[i]] = i;\n\n    mint ans = 0;\n    mint inv2 = mint(2).inv();\n    mint p = mint(k - 1) / k;\n\n    tree::BIT<mint> bt(n + 1, 0);\n    tree::BIT<mint> bti(n + 1, 0);\n    tree::BIT<ll> bcnt(n + 1, 0);\n    for (ll idx : rpv) {\n        ll i = std::max<ll>(0, idx - k + 1);\n        auto powp = pow(p, i);\n        auto powp_inv = powp.inv();\n        ans += mint(bcnt.sum(i + 1, n + 1)) - (bt.sum(i + 1, n + 1) * powp_inv * inv2);\n        ans += bti.sum(0, i + 1) * powp * inv2;\n        bt.add(i, powp);\n        bti.add(i, powp_inv);\n        bcnt.add(i, 1);\n    }\n\n    std::cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\n#include <utility>\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\n    constexpr long long safe_mod(long long x, long long m) {\n      x %= m;\n      if (x < 0) x += m;\n      return x;\n    }\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\n    struct barrett {\n        unsigned int _m;\n        unsigned long long im;\n\n        // @param m `1 <= m`\n        barrett(unsigned int m) : _m(m), im((unsigned long long) (-1) / m + 1) {}\n\n        // @return m\n        unsigned int umod() const { return _m; }\n\n        // @param a `0 <= a < m`\n        // @param b `0 <= b < m`\n        // @return `a * b % m`\n        unsigned int mul(unsigned int a, unsigned int b) const {\n          // [1] m = 1\n          // a = b = im = 0, so okay\n\n          // [2] m >= 2\n          // im = ceil(2^64 / m)\n          // -> im * m = 2^64 + r (0 <= r < m)\n          // let z = a*b = c*m + d (0 <= c, d < m)\n          // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n          // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n          // ((ab * im) >> 64) == c or c + 1\n          unsigned long long z = a;\n          z *= b;\n#ifdef _MSC_VER\n          unsigned long long x;\n            _umul128(z, im, &x);\n#else\n          unsigned long long x =\n              (unsigned long long) (((unsigned __int128) (z) * im) >> 64);\n#endif\n          unsigned int v = (unsigned int) (z - x * _m);\n          if (_m <= v) v += _m;\n          return v;\n        }\n    };\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\n    constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n      if (m == 1) return 0;\n      unsigned int _m = (unsigned int) (m);\n      unsigned long long r = 1;\n      unsigned long long y = safe_mod(x, m);\n      while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n      }\n      return r;\n    }\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\n    constexpr bool is_prime_constexpr(int n) {\n      if (n <= 1) return false;\n      if (n == 2 || n == 7 || n == 61) return true;\n      if (n % 2 == 0) return false;\n      long long d = n - 1;\n      while (d % 2 == 0) d /= 2;\n      for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n          y = y * y % n;\n          t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    template<int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\n    constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n      a = safe_mod(a, b);\n      if (a == 0) return {b, 0};\n\n      // Contracts:\n      // [1] s - m0 * a = 0 (mod b)\n      // [2] t - m1 * a = 0 (mod b)\n      // [3] s * |m1| + t * |m0| <= b\n      long long s = b, t = a;\n      long long m0 = 0, m1 = 1;\n\n      while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n      }\n      // by [3]: |m0| <= b/g\n      // by g != b: |m0| < b/g\n      if (m0 < 0) m0 += b / s;\n      return {s, m0};\n    }\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\n    constexpr int primitive_root_constexpr(int m) {\n      if (m == 2) return 1;\n      if (m == 167772161) return 3;\n      if (m == 469762049) return 3;\n      if (m == 754974721) return 11;\n      if (m == 998244353) return 3;\n      int divs[20] = {};\n      divs[0] = 2;\n      int cnt = 1;\n      int x = (m - 1) / 2;\n      while (x % 2 == 0) x /= 2;\n      for (int i = 3; (long long) (i) * i <= x; i += 2) {\n        if (x % i == 0) {\n          divs[cnt++] = i;\n          while (x % i == 0) {\n            x /= i;\n          }\n        }\n      }\n      if (x > 1) {\n        divs[cnt++] = x;\n      }\n      for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n          if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) return g;\n      }\n    }\n\n    template<int m> constexpr int primitive_root = primitive_root_constexpr(m);\n}\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace internal {\n\n#ifndef _MSC_VER\n    template <class T>\n    using is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                              std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n\n    template <class T>\n    using is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                              std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n\n    template <class T>\n    using make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n\n    template <class T>\n    using is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n\n    template <class T>\n    using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                     std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n\n    template <class T>\n    using is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                              is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n\n    template <class T>\n    using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n            std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n\n#else\n    template <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n#endif\n\n    template <class T>\n    using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\n    template <class T>\n    using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\n    template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}\n\n\n\n\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace internal {\n\n    struct modint_base {};\n    struct static_modint_base : modint_base {};\n\n    template <class T> using is_modint = std::is_base_of<modint_base, T>;\n    template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\npublic:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n      mint x;\n      x._v = v;\n      return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n      long long x = (long long)(v % (long long)(umod()));\n      if (x < 0) x += umod();\n      _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n      _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n      _v++;\n      if (_v == umod()) _v = 0;\n      return *this;\n    }\n    mint& operator--() {\n      if (_v == 0) _v = umod();\n      _v--;\n      return *this;\n    }\n    mint operator++(int) {\n      mint result = *this;\n      ++*this;\n      return result;\n    }\n    mint operator--(int) {\n      mint result = *this;\n      --*this;\n      return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n      _v += rhs._v;\n      if (_v >= umod()) _v -= umod();\n      return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n      _v -= rhs._v;\n      if (_v >= umod()) _v += umod();\n      return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n      unsigned long long z = _v;\n      z *= rhs._v;\n      _v = (unsigned int)(z % umod());\n      return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n      assert(0 <= n);\n      mint x = *this, r = 1;\n      while (n) {\n        if (n & 1) r *= x;\n        x *= x;\n        n >>= 1;\n      }\n      return r;\n    }\n    mint inv() const {\n      if (prime) {\n        assert(_v);\n        return pow(umod() - 2);\n      } else {\n        auto eg = internal::inv_gcd(_v, m);\n        assert(eg.first == 1);\n        return eg.second;\n      }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n      return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n      return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n      return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n      return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n      return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n      return lhs._v != rhs._v;\n    }\n\nprivate:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\npublic:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n      assert(1 <= m);\n      bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n      mint x;\n      x._v = v;\n      return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n      long long x = (long long)(v % (long long)(mod()));\n      if (x < 0) x += mod();\n      _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n      _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n      _v++;\n      if (_v == umod()) _v = 0;\n      return *this;\n    }\n    mint& operator--() {\n      if (_v == 0) _v = umod();\n      _v--;\n      return *this;\n    }\n    mint operator++(int) {\n      mint result = *this;\n      ++*this;\n      return result;\n    }\n    mint operator--(int) {\n      mint result = *this;\n      --*this;\n      return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n      _v += rhs._v;\n      if (_v >= umod()) _v -= umod();\n      return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n      _v += mod() - rhs._v;\n      if (_v >= umod()) _v -= umod();\n      return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n      _v = bt.mul(_v, rhs._v);\n      return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n      assert(0 <= n);\n      mint x = *this, r = 1;\n      while (n) {\n        if (n & 1) r *= x;\n        x *= x;\n        n >>= 1;\n      }\n      return r;\n    }\n    mint inv() const {\n      auto eg = internal::inv_gcd(_v, mod());\n      assert(eg.first == 1);\n      return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n      return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n      return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n      return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n      return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n      return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n      return lhs._v != rhs._v;\n    }\n\nprivate:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n    template <class T>\n    using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\n    template <class T>\n    using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\n    template <class> struct is_dynamic_modint : public std::false_type {};\n    template <int id>\n    struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\n    template <class T>\n    using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n}\n// Original: https://img.atcoder.jp/practice2/ac-library.zip\n\n\n\n\n/*\n// Sample Usages (copy-and-paste it!)\n\n// RangeSumQuery\nauto f = [](ll a, ll b) { return a+b; };\nauto e = []() { return 0; };\n\n// RangeMaximumQuery:\nauto f = [](ll a, ll b) { return max(a, b); };\nauto e = []() { return LLONG_MIN/2 };\n\n// RangeMinimumQuery:\nauto f = [](ll a, ll b) { return min(a, b); };\nauto e = []() { return LLONG_MAX/2 };\n\nauto seg = segtree<ll, f, e>(v);\n*/\n\ntemplate<class S, S (*op)(S, S), S (*e)()>\nstruct segtree {\npublic:\n    segtree() : segtree(0) {}\n\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n\n    segtree(const std::vector<S> &v) : _n(int(v.size())) {\n      log = 0;\n      while((1U << log) < (unsigned int)(_n)) log++; // ceil_pow2(_n)\n      size = 1 << log;\n      d = std::vector<S>(2 * size, e());\n      for (int i = 0; i < _n; i++) d[size + i] = v[i];\n      for (int i = size - 1; i >= 1; i--) {\n        update(i);\n      }\n    }\n\n    void set(int p, S x) {\n      assert(0 <= p && p < _n);\n      p += size;\n      d[p] = x;\n      for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n      assert(0 <= p && p < _n);\n      return d[p + size];\n    }\n\n    S prod(int l, int r) {\n      assert(0 <= l && l <= r && r <= _n);\n      S sml = e(), smr = e();\n      l += size;\n      r += size;\n\n      while (l < r) {\n        if (l & 1) sml = op(sml, d[l++]);\n        if (r & 1) smr = op(d[--r], smr);\n        l >>= 1;\n        r >>= 1;\n      }\n      return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template<bool (*f)(S)>\n    int max_right(int l) {\n      return max_right(l, [](S x) { return f(x); });\n    }\n\n    // return the largest r such that f(op(a[l], ... ,a[r-1])) is still true\n    // f(e()) must return true\n    template<class F>\n    int max_right(int l, F f) {\n      assert(0 <= l && l <= _n);\n      assert(f(e()));\n      if (l == _n) return _n;\n      l += size;\n      S sm = e();\n      do {\n        while (l % 2 == 0) l >>= 1;\n        if (!f(op(sm, d[l]))) {\n          while (l < size) {\n            l = (2 * l);\n            if (f(op(sm, d[l]))) {\n              sm = op(sm, d[l]);\n              l++;\n            }\n          }\n          return l - size;\n        }\n        sm = op(sm, d[l]);\n        l++;\n      } while ((l & -l) != l);\n      return _n;\n    }\n\n    template<bool (*f)(S)>\n    int min_left(int r) {\n      return min_left(r, [](S x) { return f(x); });\n    }\n\n    // return the smallest l such that f(op(a[l], ... ,a[r-1])) is still true\n    // f(e()) must return true\n    template<class F>\n    int min_left(int r, F f) {\n      assert(0 <= r && r <= _n);\n      assert(f(e()));\n      if (r == 0) return 0;\n      r += size;\n      S sm = e();\n      do {\n        r--;\n        while (r > 1 && (r % 2)) r >>= 1;\n        if (!f(op(d[r], sm))) {\n          while (r < size) {\n            r = (2 * r + 1);\n            if (f(op(d[r], sm))) {\n              sm = op(d[r], sm);\n              r--;\n            }\n          }\n          return r + 1 - size;\n        }\n        sm = op(d[r], sm);\n      } while ((r & -r) != r);\n      return 0;\n    }\n\nprivate:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\nclass EShuffleWindow {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, k; cin >> n >> k;\n      vector<int> p(n);\n      rep(i, n) {\n        int x; cin >> x; x--;\n        p[x] = i;\n        p[x] = max(0, i-k+1);\n      }\n      using mint = modint998244353;\n\n      vector<mint> q(n), qv(n);\n      q[0] = 1; qv[0] = 1;\n      mint r = mint(k-1)/k;\n      mint rv = mint(k)/(k-1);\n\n      rep(i, n-1) {\n        q[i+1] = q[i]*r;\n        qv[i+1] = qv[i]*rv;\n      }\n\n      auto f = [](mint a, mint b) { return a+b; };\n      auto e = []() { return mint(0); };\n      auto seg = segtree<mint, f, e>(n);\n      auto segv = segtree<mint, f, e>(n);\n\n      auto f2 = [](int a, int b) { return a+b;};\n      auto e2 = []() { return 0; };\n      auto seg2 = segtree<int, f2, e2>(n);\n\n      mint ret = 0;\n      mint half = mint(1)/2;\n\n      for(int i=0; i<n; i++) {\n        int pos = p[i];\n        debug(i, pos);\n        mint low = segv.prod(0, pos);\n\n        mint high = seg.prod(pos, n);\n        int highcnt = seg2.prod(pos, n);\n        low *= qv[n-1-pos];\n        debug(low.val());\n\n        high *= qv[pos];\n        ret += low*half;\n        debug(ret.val());\n        ret += -high*half+highcnt;\n\n        seg.set(pos, seg.get(pos)+q[pos]);\n        segv.set(pos, segv.get(pos)+q[n-1-pos]);\n        seg2.set(pos, seg2.get(pos)+1);\n      }\n\n      cout << ret.val() << endl;\n    }\n};\n\nsigned main() {\n  EShuffleWindow solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 998244353;\n\nint add(int a, int b)\n{\n    a += b;\n    if (a >= MOD)\n    {\n        return a - MOD;\n    }\n    if (a < 0)\n    {\n        return a + MOD;\n    }\n    return a;\n}\n\nint mul(int a, int b)\n{\n    return a * (ll) b % MOD;\n}\n\nint pw(int a, int b)\n{\n    int r = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            r = mul(r, a);\n        }\n        a = mul(a, a);\n        b /= 2;\n    }\n    return r;\n}\n\nint dv(int a, int b)\n{\n    return mul(a, pw(b, MOD - 2));\n}\n\nconst int N = (int) 2e5 + 7;\nint n;\nint k;\nint a[N];\nint enter[N];\nint kek;\nint val[N];\nint inv_val[N];\nint inv2;\nint aib[N];\n\nvoid clr()\n{\n    for (int i = 1; i <= n; i++)\n    {\n        aib[i] = 0;\n    }\n}\n\nvoid op(int i, int x)\n{\n    while (i <= n)\n    {\n        aib[i] += x;\n        i += i & (-i);\n    }\n}\n\nint get(int i)\n{\n    int sol = 0;\n    while (i)\n    {\n        sol += aib[i];\n        i -= i & (-i);\n    }\n    return sol;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> k;\n    inv2 = dv(1, 2);\n    kek = dv(k - 1, k);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        enter[i] = max(0, i - k);\n        val[i] = pw(kek, enter[i]);\n        inv_val[i] = dv(1, val[i]);\n    }\n    int inversion_count = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        inversion_count = add(inversion_count, i - 1 - get(a[i]));\n        op(a[i], 1);\n    }\n    clr();\n    int invs = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        int x = 0, y = 0;\n        for (int j = i + 1; j <= n; j++)\n        {\n            if (a[i] < a[j])\n            {\n                x = add(x, val[j]);\n            }\n            else\n            {\n                y = add(y, val[j]);\n            }\n        }\n        x = mul(x, inv2);\n        y = mul(y, inv2);\n        x = mul(x, inv_val[i]);\n        y = mul(y, inv_val[i]);\n        invs = add(invs, add(x, -y));\n    }\n    invs = add(invs, inversion_count);\n    cout << invs << \"\\n\";\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <atcoder/all>\nusing namespace atcoder;\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing mint = modint998244353;\n\nostream& operator<<(ostream& out, mint m){\n  out << m.val();\n  return out;\n}\n\nstruct node{\n  mint sum,evinv;\n  int sumzw;\n};\n\nnode empty(){\n  return {0,0,0};\n}\nint n,k;\n\nnode lacz(node a,node b){\n  return { a.sum + b.sum, \n    a.evinv + b.evinv + a.sumzw * b.sum,\n    a.sumzw + b.sumzw};\n}\nsegtree<node, lacz, empty> tree;\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> k;\n  tree = {vector<node>(n,{0,0,1})};\n  \n  vector<int> p(n);\n  R(i,n){\n    cin >> p[i];\n    p[i]--;\n  }\n  R(i,k)tree.set(p[i], {1,0,0});\n  mint kinv = mint(1) / k;\n  mint res = 0;\n  mint mno = 1;\n  R(i,n-k){\n    res += tree.all_prod().evinv * kinv * mno;\n    res += mint(k-1) / 2;\n    mno *= (k-1) * kinv;\n    tree.set(p[i+k], {1 / mno,0,0});\n  } \n  res += mint(k) * (k - 1) / 4;\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=998244353,MAX=55,INF=1<<20;\n\nusing mint=atcoder::modint998244353;\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    mint ans=0;\n    \n    int N,k;cin>>N>>k;\n    vector<pair<int,int>> p(N);\n    for(int i=0;i<N;i++){\n        cin>>p[i].fi;\n        p[i].se=i;\n    }\n    \n    sort(all(p),[](auto a,auto b){\n        return a.fi>b.fi;\n    });\n    \n    mint K=k;\n    \n    atcoder::fenwick_tree<mint> fw(N),fwinv(N);\n    atcoder::fenwick_tree<int> cnt(N);\n    \n    for(int i=0;i<N;i++){\n        \n        ll ppp=(k-1)*rui(k,mod-2)%mod;\n        mint x=atcoder::pow_mod(ppp,max(0,p[i].se-k),mod);\n        ll y=x.val();\n        ans+=atcoder::inv_mod(y,mod)*fw.sum(p[i].se,N)/2;\n        \n        ans+=mint(cnt.sum(0,p[i].se));\n        \n        ans-=x*fwinv.sum(0,p[i].se)/2;\n        \n        cnt.add(p[i].se,1);\n        fw.add(p[i].se,x);\n        fw.add(p[i].se,y);\n    }\n    \n    cout<<ans.val()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nclass Add_Segment_Tree {\n\tvector<long long int>v;\n\tlong long int ret;\n\tint num;\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = Update(place * 2) + Update(place * 2 + 1);\n\t\treturn v[place];\n\t}\npublic:\n\tAdd_Segment_Tree(int n) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2)num *= 2;\n\t\tv.resize(num, 0);\n\t}\n\tvoid Add(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] += num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tv[place] = v[place * 2] + v[place * 2 + 1];\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid TopDown() {\n\t\tUpdate(1);\n\t}\n\tlong long int Sum(int a, int b) {\n\t\tret = 0;\n\t\tb++;\n\t\tfor (a += num / 2, b += num / 2; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1)ret += v[a++];\n\t\t\tif (b & 1)ret += v[--b];\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tlong long int ans = 0;\n\tvector<int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tAdd_Segment_Tree asg(N);\n\tAdd_Segment_Tree num(N);\n\tvector<long long int>by(N - K + 2, 1);\n\tby.back() = 1;\n\tfor (int i = by.size() - 2; i >= 0; i--) {\n\t\tby[i] = by[i + 1] * (K - 1);\n\t\tby[i] %= MOD;\n\t\tby[i] *= power(K, MOD - 2, MOD);\n\t\tby[i] %= MOD;\n\t}\n\tans += (K - 1)*K / 2 %MOD* power(2, MOD - 2, MOD);\n\tans %= MOD;\n\tfor (int i = 0; i < K; i++) {\n\t\tasg.Add(v[i], by[1], true);\n\t\tnum.Add(v[i], 1, true);\n\t}\n\tfor (int i = K; i < N; i++) {\n\t\tans -= asg.Sum(v[i] + 1, N)%MOD*power(by[i - K + 2], MOD - 2, MOD) % MOD*power(2, MOD - 2, MOD) % MOD;\n\t\tans += num.Sum(v[i] + 1, N);\n\t\tans += asg.Sum(1, v[i] - 1)%MOD*power(by[i - K + 2], MOD - 2, MOD) % MOD*power(2, MOD - 2, MOD) % MOD;\n\t\tnum.Add(v[i], 1, true);\n\t\tasg.Add(v[i], by[i - K + 2], true);\n\t\tans += MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n,k,p[200005],pw[200005],tr[2][200005],ans=0,alr,ty=0;\nconst int mod=998244353;\nint mypow(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*a%mod;\n\t\ta=1ll*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint lowbit(int p){return p&-p;}\nint M(int x){return x>=mod?x-mod:x;}\nvoid modify(int p,int v)\n{\n\twhile(p<=n)\n\t{\n\t\ttr[ty][p]=M(tr[ty][p]+v);\n\t\tp+=lowbit(p);\n\t}\n}\nint ask(int p)\n{\n\t//printf(\"%d %d %d\\n\",p,ty,tr[0][2]);\n\tint ans=0;\n\twhile(p)\n\t{\n\t\tans=M(ans+tr[ty][p]);\n\t\t//printf(\"!%d %d %d\\n\",ans,p,tr[0][p]);\n\t\tp-=lowbit(p);\n\t}\n\treturn ans;\n}\nint main()\n{\n\tty=0;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&p[i]);\n\tpw[0]=1;\n\tpw[1]=1ll*(k)*mypow(k-1,mod-2)%mod;\n\tfor(int i=2;i<=n;i++)pw[i]=1ll*pw[i-1]*pw[1]%mod;\n\tans=1ll*k*(k-1)/2ll%mod*mypow(2,mod-2)%mod;\n\talr=1ll*(k-1)*mypow(k,mod-2)%mod*mypow(2,mod-2)%mod;\n\t//printf(\"%d\\n\",ans);\n\tfor(int i=1;i<=k;i++)modify(p[i],1),ty=1,modify(p[i],1),ty=0;\n\tfor(int i=k+1;i<=n;i++)\n\t{\n\t\tans=(1ll*ans+1ll*ask(p[i])*alr%mod)%mod;\n\t\t//printf(\"%d %d %d %d %d %d\\n\",ask(p[i]),alr,ans,mypow(4,mod-2),ask(n),ask(p[i]));\n\t\tans=(1ll*ans-1ll*(ask(n)-ask(p[i])+mod)*alr%mod+mod)%mod;\n\t\t//printf(\"@%d\\n\",ans);\n\t\tty=1;\n\t\tans=(1ll*ans+ask(n)-ask(p[i]))%mod;\n\t\tmodify(p[i],1);\n\t\t//printf(\"@%d %d %d %d\\n\",ans,ask(p[i]),ask(n));\n\t\tty=0;\n\t\tmodify(p[i],pw[i-k]);\n\t\talr=1ll*alr*(k-1)%mod*mypow(k,mod-2)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 998244353;\nconst ll INF = 1000000010;\nconst ll LOG = 20;\n\nint fen[2][N], n, k, a[N], ans, Fac;\n\nint POW(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1) res = res * 1ll * a % MOD;\n\t\tb >>= 1;\n\t\ta = a * 1ll * a % MOD;\n\t}\n\treturn res;\n}\n\ninline int add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\ninline int mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\ninline int minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\ninline void Add(int ind, int id, int x){\n\tfor (; id < N; id += id & (-id)) fen[ind][id] = (fen[ind][id] + x) % MOD;\n\treturn;\n}\n\ninline int get(int ind, int id){\n\tint res = 0;\n\tfor (; id > 0; id -= id & (-id)) res = (res + fen[ind][id]) % MOD;\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> k;\n\tFac = 1;\n//\tcout << POW(2, 4) << '\\n';\n\tfor (int i = 3; i <= k; i++) Fac = Fac * 1ll * i % MOD;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tint tot = mul(POW(k, n - k), Fac * 2 % MOD);\n//\tcout << tot << '\\n';\n\tfor (int i = 1; i <= n; i++){\n\t\tint x = max(k, i);\n\t\tint res = get(0, a[i]);\n//\t\tcout << res << '\\n';\n\t\tans = add(ans, mul(res,mul(mul(POW(k - 1, x), POW(k, n - x)), Fac)));\n\t\tres = minu(get(0, n), get(0, a[i]));\n//\t\tcout << ans << '\\n';\n\t\tint ted = minu(get(1, n), get(1, a[i]));\n\t\tted = ted * 1ll * tot % MOD;\n\t\tted = minu(ted, mul(res,mul(mul(POW(k - 1, x), POW(k, n - x)), Fac)));\n\t\tans = add(ans, ted);\n//\t\tcout << ans << '\\n';\n\t\tAdd(1, a[i], 1);\n\t\tAdd(0, a[i], mul(POW(k, x - k), POW(k - 1, MOD - 1 - x)));\n\t}\n//\tcout << ans << '\\n';\n\tcout << mul(ans, POW(tot, MOD - 2));\n\treturn 0;\n}\n\n/*\n4 2\n4 2 1 3\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nclass FenwickTree {\npublic:\n\tvoid init(int nn) {\n\t\tthis->n = nn;\n\t\tbit.assign(n + 1, 0);\n\t}\n\n\tvoid init(const std::vector<T> &a) {\n\t\tn = a.size();\n\t\tbit.assign(n + 1, 0);\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tbit[i] += a[i - 1];\n\t\t\tif(i + (i & -i) <= n) {\n\t\t\t\tbit[i + (i & -i)] += bit[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tT qry(int x) {\n\t\tx = std::min(x, (int)bit.size() - 1);\n\t\tT ans = 0;\n\t\tfor(; x > 0; x -= x & -x) {\n\t\t\tans += bit[x];\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid upd(int x, T v) {\n\t\tif(x <= 0) return;\n\t\tfor(; x <= n; x += x & -x) {\n\t\t\tbit[x] += v;\n\t\t}\n\t}\nprivate:\n\tint n;\n\tstd::vector<T> bit;\n};\n\nconst int MOD = 998244353;\ntemplate <class T>\nT fexp(T x, long long e) {\n\tT ans(1);\n\tfor(; e > 0; e /= 2) {\n\t\tif(e & 1) ans = ans * x;\n\t\tx = x * x;\n\t}\n\treturn ans;\n}\n\ntemplate <int mod = MOD>\nstruct modBase {\n\tmodBase(int v = 0) : val(v < 0 ? v + mod : v) {}\n\tint val;\n \n\tvoid operator += (modBase<mod> o) { *this = *this + o; }\n\tvoid operator -= (modBase<mod> o) { *this = *this - o; }\n\tvoid operator *= (modBase<mod> o) { *this = *this * o; }\n\tmodBase<mod> operator * (modBase<mod> o) { return (int)((long long) val * o.val % mod); }\n\tmodBase<mod> operator / (modBase<mod> o) { return *this * fexp(o, mod - 2); }\n\tmodBase<mod> operator + (modBase<mod> o) { return val + o.val >= mod ? val + o.val - mod : val + o.val; }\n\tmodBase<mod> operator - (modBase<mod> o) { return val - o.val < 0 ? val - o.val + mod : val - o.val; }\n\n\tfriend std::ostream& operator << (std::ostream &os, const modBase<mod> &p) {\n\t\treturn os << p.val;\n\t}\n\tfriend std::istream& operator >> (std::istream &is, modBase<mod> &p) {\n\t\treturn is >> p.val;\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tint n, k;\n\tstd::cin >> n >> k;\n\tFenwickTree<modBase<>> tree;\n\ttree.init(n);\n\tFenwickTree<int> freq;\n\tfreq.init(n);\n\tmodBase<> prob = modBase<>(k-1) / k;\n\tmodBase<> ans(0);\n\tfor(int i = 0; i < n; i++) {\n\t\tint x;\n\t\tstd::cin >> x;\n\t\tauto curProb = fexp(prob, std::max(0, i - k + 1));\n\t\tmodBase<> low = tree.qry(x);\n\t\tmodBase<> high = tree.qry(n) - low;\n\t\tlow = low * curProb;\n\t\thigh = high * curProb;\n\t\t// for low to be an inversion, it needs to pass the probability\n\t\tans += low / 2;\n\t\t// fow high to be an inversion, it needs to either pass the probability or continue there\n\t\tans += high / 2;\n\t\tans += (modBase<>(i) - freq.qry(x) - high);\n\t\ttree.upd(x, modBase<>(1) / curProb);\n\t\tfreq.upd(x, 1);\n\t}\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define MD (998244353U)\nvoid*wmem;\nchar memarr[96000000];\ntemplate<class S, class T> inline S min_L(S a,T b){\n  return a<=b?a:b;\n}\ntemplate<class S, class T> inline S max_L(S a,T b){\n  return a>=b?a:b;\n}\ntemplate<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){\n  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\nstruct Modint{\n  unsigned val;\n  Modint(){\n    val=0;\n  }\n  Modint(int a){\n    val = ord(a);\n  }\n  Modint(unsigned a){\n    val = ord(a);\n  }\n  Modint(long long a){\n    val = ord(a);\n  }\n  Modint(unsigned long long a){\n    val = ord(a);\n  }\n  inline unsigned ord(unsigned a){\n    return a%MD;\n  }\n  inline unsigned ord(int a){\n    a %= (int)MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned ord(unsigned long long a){\n    return a%MD;\n  }\n  inline unsigned ord(long long a){\n    a %= (int)MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned get(){\n    return val;\n  }\n  inline Modint &operator+=(Modint a){\n    val += a.val;\n    if(val >= MD){\n      val -= MD;\n    }\n    return *this;\n  }\n  inline Modint &operator-=(Modint a){\n    if(val < a.val){\n      val = val + MD - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  inline Modint &operator*=(Modint a){\n    val = ((unsigned long long)val*a.val)%MD;\n    return *this;\n  }\n  inline Modint &operator/=(Modint a){\n    return *this *= a.inverse();\n  }\n  inline Modint operator+(Modint a){\n    return Modint(*this)+=a;\n  }\n  inline Modint operator-(Modint a){\n    return Modint(*this)-=a;\n  }\n  inline Modint operator*(Modint a){\n    return Modint(*this)*=a;\n  }\n  inline Modint operator/(Modint a){\n    return Modint(*this)/=a;\n  }\n  inline Modint operator+(int a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(int a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(int a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(int a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator+(long long a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(long long a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(long long a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(long long a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator-(void){\n    Modint res;\n    if(val){\n      res.val=MD-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  inline operator bool(void){\n    return val!=0;\n  }\n  inline operator int(void){\n    return get();\n  }\n  inline operator long long(void){\n    return get();\n  }\n  inline Modint inverse(){\n    int a = val;\n    int b = MD;\n    int u = 1;\n    int v = 0;\n    int t;\n    Modint res;\n    while(b){\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    if(u < 0){\n      u += MD;\n    }\n    res.val = u;\n    return res;\n  }\n  inline Modint pw(unsigned long long b){\n    Modint a(*this);\n    Modint res;\n    res.val = 1;\n    while(b){\n      if(b&1){\n        res *= a;\n      }\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n  inline bool operator==(int a){\n    return ord(a)==val;\n  }\n  inline bool operator!=(int a){\n    return ord(a)!=val;\n  }\n}\n;\ninline Modint operator+(int a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(int a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(int a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(int a, Modint b){\n  return Modint(a)/=b;\n}\ninline Modint operator+(long long a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(long long a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(long long a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(long long a, Modint b){\n  return Modint(a)/=b;\n}\ninline int my_getchar_unlocked(){\n  static char buf[1048576];\n  static int s = 1048576;\n  static int e = 1048576;\n  if(s == e && e == 1048576){\n    e = fread_unlocked(buf, 1, 1048576, stdin);\n    s = 0;\n  }\n  if(s == e){\n    return EOF;\n  }\n  return buf[s++];\n}\ninline void rd(int &x){\n  int k;\n  int m=0;\n  x=0;\n  for(;;){\n    k = my_getchar_unlocked();\n    if(k=='-'){\n      m=1;\n      break;\n    }\n    if('0'<=k&&k<='9'){\n      x=k-'0';\n      break;\n    }\n  }\n  for(;;){\n    k = my_getchar_unlocked();\n    if(k<'0'||k>'9'){\n      break;\n    }\n    x=x*10+k-'0';\n  }\n  if(m){\n    x=-x;\n  }\n}\nstruct MY_WRITER{\n  char buf[1048576];\n  int s;\n  int e;\n  MY_WRITER(){\n    s = 0;\n    e = 1048576;\n  }\n  ~MY_WRITER(){\n    if(s){\n      fwrite_unlocked(buf, 1, s, stdout);\n    }\n  }\n}\n;\nMY_WRITER MY_WRITER_VAR;\nvoid my_putchar_unlocked(int a){\n  if(MY_WRITER_VAR.s == MY_WRITER_VAR.e){\n    fwrite_unlocked(MY_WRITER_VAR.buf, 1, MY_WRITER_VAR.s, stdout);\n    MY_WRITER_VAR.s = 0;\n  }\n  MY_WRITER_VAR.buf[MY_WRITER_VAR.s++] = a;\n}\ninline void wt_L(char a){\n  my_putchar_unlocked(a);\n}\ninline void wt_L(int x){\n  int s=0;\n  int m=0;\n  char f[10];\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    my_putchar_unlocked('-');\n  }\n  while(s--){\n    my_putchar_unlocked(f[s]+'0');\n  }\n}\ninline void wt_L(Modint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\ntemplate<class T, class S> inline T pow_L(T a, S b){\n  T res = 1;\n  res = 1;\n  for(;;){\n    if(b&1){\n      res *= a;\n    }\n    b >>= 1;\n    if(b==0){\n      break;\n    }\n    a *= a;\n  }\n  return res;\n}\ninline double pow_L(double a, double b){\n  return pow(a,b);\n}\ntemplate<class T> struct fenwick{\n  int size;\n  int memory;\n  T*data;\n  void malloc(int mem);\n  void malloc(int mem, int fg);\n  void walloc(int mem, void **workMemory = &wmem);\n  void walloc(int mem, int fg, void **workMemory = &wmem);\n  void free(void);\n  void init(int N);\n  void add(int k, T val);\n  T get(int k);\n  T range(int a, int b);\n  int kth(T k);\n}\n;\ntemplate<class T> long long inversion(int N, T A[], void *mem=wmem){\n  int i;\n  int j;\n  int k;\n  int p;\n  int n1;\n  int n2;\n  T*x;\n  T*y;\n  long long res = 0;\n  walloc1d(&x, N, &mem);\n  walloc1d(&y, N, &mem);\n  for(i=(0);i<(N);i++){\n    x[i] = A[i];\n  }\n  for(k=0;k<N;k+=4){\n    n1 =min_L(4, N-k);\n    for(j=n1;j;j--){\n      int X9Iss0pP = j;\n      for(i=(1);i<(X9Iss0pP);i++){\n        if(x[k+i-1] > x[k+i]){\n          swap(x[k+i-1], x[k+i]);\n          res++;\n        }\n      }\n    }\n  }\n  p = 4;\n  while(p<N){\n    for(k=0;k<N;k+=2*p){\n      n1 =min_L(p, N-k);\n      n2 =min_L(p, N-k-n1);\n      i = j = 0;\n      while(i<n1 && j<n2){\n        if(x[k+i] <= x[k+n1+j]){\n          y[k+i+j] = x[k+i];\n          i++;\n        }\n        else{\n          y[k+i+j] = x[k+n1+j];\n          res += n1-i;\n          j++;\n        }\n      }\n      while(i<n1){\n        y[k+i+j] = x[k+i];\n        i++;\n      }\n      while(j<n2){\n        y[k+i+j] = x[k+n1+j];\n        j++;\n      }\n    }\n    swap(x,y);\n    p *= 2;\n  }\n  return res;\n}\nint N;\nint K;\nint P[200000];\nint rv[200000];\nint main(){\n  int RZTsC2BF, WYIGIcGE, i;\n  wmem = memarr;\n  Modint res = 0;\n  Modint prob;\n  Modint pinv;\n  fenwick<Modint> t;\n  rd(N);\n  rd(K);\n  {\n    int Lj4PdHRW;\n    for(Lj4PdHRW=(0);Lj4PdHRW<(N);Lj4PdHRW++){\n      rd(P[Lj4PdHRW]);P[Lj4PdHRW] += (-1);\n    }\n  }\n  for(i=(0);i<(N);i++){\n    rv[P[i]] = i;\n  }\n  prob = Modint(K-1) / K;\n  pinv = 1 / prob;\n  t.walloc(N);\n  t.init(N);\n  for(RZTsC2BF=(N)-1;RZTsC2BF>=(0);RZTsC2BF--){\n    auto &i = rv[RZTsC2BF];\n    if(i < K-1){\n      i = K-1;\n    }\n    res += t.range(i, N-1) *(pow_L(pinv,i));\n    t.add(i,(pow_L(prob,i))/ 2);\n  }\n  res += inversion(N, P);\n  res -= inversion(K, P);\n  t.walloc(N);\n  t.init(N);\n  for(WYIGIcGE=(0);WYIGIcGE<(N);WYIGIcGE++){\n    auto &i = rv[WYIGIcGE];\n    if(i < K-1){\n      i = K-1;\n    }\n    res -= t.range(max_L(i, K), N-1) *(pow_L(pinv,i));\n    t.add(i,(pow_L(prob,i))/ 2);\n  }\n  wt_L(res);\n  wt_L('\\n');\n  return 0;\n}\ntemplate<class T> void fenwick<T>::malloc(int mem){\n  memory = mem;\n  data = (T*)std::malloc(sizeof(T)*mem);\n}\ntemplate<class T> void fenwick<T>::malloc(int mem, int fg){\n  memory = mem;\n  data = (T*)std::malloc(sizeof(T)*mem);\n  if(fg){\n    init(mem);\n  }\n}\ntemplate<class T> void fenwick<T>::walloc(int mem, void **workMemory /* = &wmem*/){\n  memory = mem;\n  walloc1d(&data, mem, workMemory);\n}\ntemplate<class T> void fenwick<T>::walloc(int mem, int fg, void **workMemory /* = &wmem*/){\n  memory = mem;\n  walloc1d(&data, mem, workMemory);\n  if(fg){\n    init(mem);\n  }\n}\ntemplate<class T> void fenwick<T>::free(void){\n  memory = 0;\n  free(data);\n}\ntemplate<class T> void fenwick<T>::init(int N){\n  size = N;\n  memset(data,0,sizeof(T)*N);\n}\ntemplate<class T> void fenwick<T>::add(int k, T val){\n  while(k < size){\n    data[k] += val;\n    k |= k+1;\n  }\n}\ntemplate<class T> T fenwick<T>::get(int k){\n  T res = 0;\n  while(k>=0){\n    res += data[k];\n    k = (k&(k+1))-1;\n  }\n  return res;\n}\ntemplate<class T> T fenwick<T>::range(int a, int b){\n  if(b==-1){\n    b=size-1;\n  }\n  return get(b) - get(a-1);\n}\ntemplate<class T> int fenwick<T>::kth(T k){\n  int i=0;\n  int j=size;\n  int c;\n  T v;\n  while(i<j){\n    c = (i+j)/2;\n    v = get(c);\n    if(v <= k){\n      i=c+1;\n    }\n    else{\n      j=c;\n    }\n  }\n  return i==size?-1:i;\n}\n// cLay varsion 20200920-1\n\n// --- original code ---\n// #define MD 998244353\n// int N, K, P[2d5], rv[2d5];\n// {\n//   Modint res = 0, prob, pinv;\n//   fenwick<Modint> t;\n//   rd(N,K,(P--)(N));\n//   rep(i,N) rv[P[i]] = i;\n// \n//   prob = Modint(K-1) / K;\n//   pinv = 1 / prob;\n// \n//   t.walloc(N);\n//   t.init(N);\n//   rrep[rv](i,N){\n//     if(i < K-1) i = K-1;\n//     res += t.range(i, N-1) * pinv ** i;\n//     t.add(i, prob**i / 2);\n//   }\n// \n//   res += inversion(N, P);\n//   res -= inversion(K, P);\n// \n//   t.walloc(N);\n//   t.init(N);\n//   rep[rv](i,N){\n//     if(i < K-1) i = K-1;\n//     res -= t.range(max(i,K), N-1) * pinv ** i;\n//     t.add(i, prob**i / 2);\n//   }\n// \n//   wt(res);\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int MAX>\nstruct Combination {\n    vector<long long> _inv, _fac, _ifac;\n    const long long MOD;\n    Combination(long long mod) : _inv(MAX+1), _fac(MAX+1), _ifac(MAX+1), MOD(mod) { init(); }\n    inline void init() { init_inv(), init_fac(); }\n\n    inline void init_inv() {\n        _inv[0] = 0;\n        for (int i = 1; i <= MAX; i++) {\n            if (i == 1) _inv[i] = 1;\n            else {\n                _inv[i] = (MOD - (MOD / i) * _inv[MOD % i]) % MOD;\n                if (_inv[i] < 0) _inv[i] += MOD;\n            }\n        }\n    }\n    inline void init_fac() {\n        _fac[0] = _ifac[0] = 1;\n        for (int i = 1; i <= MAX; i++) {\n            _fac[i] = _fac[i-1] * i % MOD;\n            _ifac[i] = _ifac[i-1] * _inv[i] % MOD;\n        }\n    }\n\n    inline long long modpow(long long n, long long r) {\n        n %= MOD, r %= (MOD-1);\n        if (!n) return 0;\n        long long ret = 1; long long tmp = n;\n        while (r != 0) {\n            if (r % 2) ret *= tmp;\n            tmp *= tmp; tmp %= MOD; ret %= MOD;\n            r /= 2;\n        }\n        return ret;\n    }\n    inline long long invb(int i) const { return (i <= MAX) ? _inv[i] : this->modpow(i, MOD-2); }\n    inline long long inv(int i) const { return _inv[i]; }\n    inline long long fac(int i) const { return _fac[i]; }\n    inline long long ifac(int i) const { return _ifac[i]; }\n\n    long long operator()(int n, int r) const {\n        if (n < r) return 0;\n        return fac(n) * ifac(r) % MOD * ifac(n-r) % MOD;\n    }\n};\n\nconstexpr long long mod = 998244353;\n\n// zero-based numbering\ntemplate<class T> struct Fenwick {\n    vector<T> bit; int N;\n    Fenwick(int n) : N(n) { bit.assign(n+1, 0); }\n    // add w to a\n    void add(int a, T w) {\n        for (int x = ++a; x <= N; x += x & -x) bit[x] = (bit[x]+w) % mod;\n    }\n    // sum [0, a)\n    T sum(int a) {\n        T ret = 0;\n        for (int x = a; x > 0; x -= x & -x) ret = (ret + bit[x]) % mod;\n        return ret;\n    }\n    // sum [a, b)\n    T sum(int a, int b) { return (sum(b) - sum(a) + mod) % mod; }\n};\n\nlong long invsum(vector<int> v, int n){\n    vector<pair<int, int>> v_sort;\n    for (int i = 0; i < n; i++) {\n        v_sort.push_back(make_pair(v[i]-1, i));\n    }\n    sort(v_sort.begin(), v_sort.end());\n    for (int i = 0; i < n; i++) {\n        v[v_sort[i].second] = i;\n    }\n    Fenwick<long long> b(n);\n    long long num = 0;\n    for (int i = 0; i < n; i++) {\n        num += b.sum(n) - b.sum(v[i]);\n        b.add(v[i], 1);\n    }\n    return num;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    Combination<500000> C(mod);\n    long long N, K; cin >> N >> K;\n    vector<int> V(N);\n    for (int i = 0; i < N; i++) cin >> V[i];\n    // cout << invsum(V, N) << \" \" << invsum(V, K) << \"\\n\";\n    long long Rw = (K - 1) * C.inv(K) % mod;\n    long long inv = K * C.inv(K - 1) % mod;\n    Fenwick<long long> F(N+1);\n    long long Cur = 1, CurInv = 1;\n    long long Ans = 0;\n    for (int i = 0; i < N; i++) {\n        if (i >= K) Cur = Cur * Rw % mod, CurInv = CurInv * inv % mod;\n        Ans += F.sum(V[i]) * Cur % mod;\n        Ans -= F.sum(V[i], N + 1) * Cur % mod;\n        Ans = (Ans % mod + mod) % mod;\n        assert(Ans >= 0);\n        // cout << F.sum(V[i]) * Cur % mod << \" \" << F.sum(V[i + K - 1], N + 1) * Cur % mod << \"\\n\";\n        F.add(V[i], CurInv);\n        // cout << i << \": \" << Ans << \" \" << Cur << \" \" << CurInv << \"\\n\";\n    }\n    Ans = Ans * C.inv(2) % mod;\n    Ans += invsum(V, N);\n    cout << Ans % mod << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a, b)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define lscan(x) scanf(\"%I64d\", &x)\n#define lprint(x) printf(\"%I64d\", x)\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define rep2(i, n) for (ll i = n - 1; i >= 0; i--)\nconst int mod = 998244353;\nll gcd(ll a, ll b)\n{\n\tll c = a % b;\n\twhile (c != 0)\n\t{\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\nstruct UnionFind\n{\n\tvector<ll> data;\n\n\tUnionFind(int sz)\n\t{\n\t\tdata.assign(sz, -1);\n\t}\n\n\tbool unite(int x, int y)\n\t{\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)\n\t\t\treturn (false);\n\t\tif (data[x] > data[y])\n\t\t\tswap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn (true);\n\t}\n\n\tint find(int k)\n\t{\n\t\tif (data[k] < 0)\n\t\t\treturn (k);\n\t\treturn (data[k] = find(data[k]));\n\t}\n\n\tll size(int k)\n\t{\n\t\treturn (-data[find(k)]);\n\t}\n};\n\nll M = 1000000007;\n\nvector<ll> fac(2000011);  //n!(mod M)\nvector<ll> ifac(2000011); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nll mpow2(ll x, ll n, ll mod)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % mod;\n\t\tx = x * x % mod;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb()\n{\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000010; i++)\n\t{\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[2000010] = mpow(fac[2000010], M - 2);\n\tfor (ll i = 2000010; i > 0; i--)\n\t{\n\t\tifac[i - 1] = ifac[i] * i % M;\n\t}\n}\nll comb(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\nlong long modinv(long long a)\n{\n\tlong long b = M, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0)\n\t\tu += M;\n\treturn u;\n}\nll modinv2(ll a, ll mod)\n{\n\tll b = mod, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tll t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0)\n\t\tu += mod;\n\treturn u;\n}\n\ntemplate <int mod>\nstruct ModInt\n{\n\tint x;\n\n\tModInt() : x(0) {}\n\n\tModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n\tModInt &operator+=(const ModInt &p)\n\t{\n\t\tif ((x += p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator-=(const ModInt &p)\n\t{\n\t\tif ((x += mod - p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator*=(const ModInt &p)\n\t{\n\t\tx = (int)(1LL * x * p.x % mod);\n\t\treturn *this;\n\t}\n\n\tModInt &operator/=(const ModInt &p)\n\t{\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\n\tModInt operator-() const { return ModInt(-x); }\n\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\n\tModInt inverse() const\n\t{\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\n\tModInt pow(int64_t n) const\n\t{\n\t\tModInt ret(1), mul(x);\n\t\twhile (n > 0)\n\t\t{\n\t\t\tif (n & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const ModInt &p)\n\t{\n\t\treturn os << p.x;\n\t}\n\n\tfriend istream &operator>>(istream &is, ModInt &a)\n\t{\n\t\tint64_t t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n\n\tstatic int get_mod() { return mod; }\n};\n\nusing mint = ModInt<mod>;\n\nvector<vector<mint>> mul(vector<vector<mint>> a, vector<vector<mint>> b)\n{\n\tint i, j, k;\n\tmint t;\n\tint n = a.size(), m = b[0].size(), l = a[0].size();\n\tvector<vector<mint>> c(n,vector<mint>(m));\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < l; k++)\n\t\t\t\tt += a[i][k] * b[k][j];\n\t\t\tc[i][j] = t;\n\t\t}\n\t}\n\treturn c;\n}\n\nvector<vector<mint>> mat_pow(vector<vector<mint>> x, ll n)\n{\n\tll k = x.size();\n\tvector<vector<mint>> ans(k, vector<mint>(k, 0));\n\tfor (int i = 0; i < k; i++)\n\t\tans[i][i] = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = mul(ans, x);\n\t\tx = mul(x, x);\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\n\ntemplate <typename Monoid>\nstruct SegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\n\tint sz;\n\tvector<Monoid> seg;\n\n\tconst F f;\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1)\n\t{\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x)\n\t{\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t\tL = f(L, seg[a++]);\n\t\t\tif (b & 1)\n\t\t\t\tR = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k) const\n\t{\n\t\treturn seg[k + sz];\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tMonoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, seg[1])))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, seg[a]);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(seg[1], R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(seg[--b], R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\ntemplate <unsigned mod>\nstruct RollingHash\n{\n\tvector<unsigned> hashed, power;\n\n\tinline unsigned mul(unsigned a, unsigned b) const\n\t{\n\t\tunsigned long long x = (unsigned long long)a * b;\n\t\tunsigned xh = (unsigned)(x >> 32), xl = (unsigned)x, d, m;\n\t\tasm(\"divl %4; \\n\\t\"\n\t\t\t: \"=a\"(d), \"=d\"(m)\n\t\t\t: \"d\"(xh), \"a\"(xl), \"r\"(mod));\n\t\treturn m;\n\t}\n\n\tRollingHash(const string &s, unsigned base = 10007)\n\t{\n\t\tint sz = (int)s.size();\n\t\thashed.assign(sz + 1, 0);\n\t\tpower.assign(sz + 1, 0);\n\t\tpower[0] = 1;\n\t\tfor (int i = 0; i < sz; i++)\n\t\t{\n\t\t\tpower[i + 1] = mul(power[i], base);\n\t\t\thashed[i + 1] = mul(hashed[i], base) + s[i];\n\t\t\tif (hashed[i + 1] >= mod)\n\t\t\t\thashed[i + 1] -= mod;\n\t\t}\n\t}\n\n\tunsigned get(int l, int r) const\n\t{\n\t\tunsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tunsigned connect(unsigned h1, int h2, int h2len) const\n\t{\n\t\tunsigned ret = mul(h1, power[h2len]) + h2;\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tint LCP(const RollingHash<mod> &b, int l1, int r1, int l2, int r2)\n\t{\n\t\tint len = min(r1 - l1, r2 - l2);\n\t\tint low = -1, high = len + 1;\n\t\twhile (high - low > 1)\n\t\t{\n\t\t\tint mid = (low + high) / 2;\n\t\t\tif (get(l1, l1 + mid) == b.get(l2, l2 + mid))\n\t\t\t\tlow = mid;\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\t\treturn (low);\n\t}\n};\n\nusing RH = RollingHash<1000000007>;\n\ntemplate <typename T>\nstruct edge\n{\n\tint src, to;\n\tT cost;\n\n\tedge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n\tedge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n\tedge &operator=(const int &x)\n\t{\n\t\tto = x;\n\t\treturn *this;\n\t}\n\n\toperator int() const { return to; }\n};\n\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate <typename T>\nusing Matrix = vector<vector<T>>;\n\ntemplate <typename G>\nstruct DoublingLowestCommonAncestor\n{\n\tconst int LOG;\n\tvector<int> dep;\n\tconst G &g;\n\tvector<vector<int>> table;\n\n\tDoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size()))\n\t{\n\t\ttable.assign(LOG, vector<int>(g.size(), -1));\n\t}\n\n\tvoid dfs(int idx, int par, int d)\n\t{\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor (auto &to : g[idx])\n\t\t{\n\t\t\tif (to != par)\n\t\t\t\tdfs(to, idx, d + 1);\n\t\t}\n\t}\n\n\tvoid build()\n\t{\n\t\tdfs(0, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG; k++)\n\t\t{\n\t\t\tfor (int i = 0; i < table[k].size(); i++)\n\t\t\t{\n\t\t\t\tif (table[k][i] == -1)\n\t\t\t\t\ttable[k + 1][i] = -1;\n\t\t\t\telse\n\t\t\t\t\ttable[k + 1][i] = table[k][table[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v)\n\t{\n\t\tif (dep[u] > dep[v])\n\t\t\tswap(u, v);\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (((dep[v] - dep[u]) >> i) & 1)\n\t\t\t\tv = table[i][v];\n\t\t}\n\t\tif (u == v)\n\t\t\treturn u;\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (table[i][u] != table[i][v])\n\t\t\t{\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid>\nstruct LazySegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\tusing G = function<Monoid(Monoid, OperatorMonoid)>;\n\tusing H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n\tint sz, height;\n\tvector<Monoid> data;\n\tvector<OperatorMonoid> lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst Monoid M1;\n\tconst OperatorMonoid OM0;\n\n\tLazySegmentTree(int n, const F f, const G g, const H h,\n\t\t\t\t\tconst Monoid &M1, const OperatorMonoid OM0)\n\t\t: f(f), g(g), h(h), M1(M1), OM0(OM0)\n\t{\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1, height++;\n\t\tdata.assign(2 * sz, M1);\n\t\tlazy.assign(2 * sz, OM0);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tdata[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tdata[k] = f(data[2 * k + 0], data[2 * k + 1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k)\n\t{\n\t\tif (lazy[k] != OM0)\n\t\t{\n\t\t\tlazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n\t\t\tlazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = OM0;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k)\n\t{\n\t\treturn lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n\t}\n\n\tinline void recalc(int k)\n\t{\n\t\twhile (k >>= 1)\n\t\t\tdata[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n\t}\n\n\tinline void thrust(int k)\n\t{\n\t\tfor (int i = height; i > 0; i--)\n\t\t\tpropagate(k >> i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tlazy[l] = h(lazy[l], x), ++l;\n\t\t\tif (r & 1)\n\t\t\t\t--r, lazy[r] = h(lazy[r], x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tMonoid L = M1, R = M1;\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tL = f(L, reflect(l++));\n\t\t\tif (r & 1)\n\t\t\t\tR = f(reflect(--r), R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k)\n\t{\n\t\treturn query(k, k + 1);\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tpropagate(a);\n\t\t\tMonoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, reflect(1))))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(a + sz);\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, reflect(a));\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(reflect(1), R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(b + sz - 1);\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(reflect(--b), R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\ntemplate <typename T>\nstruct mat\n{\n\t// 行列m\n\tvector<vector<T>> m;\n\t// コンストラクタ:第1引数⇒行数、第2引数⇒列数、第3引数⇒初期値\n\tmat() : m(vector<vector<T>>()) {}\n\tmat(int h, int w) : m(vector<vector<T>>(h, vector<T>(w))) {}\n\tmat(int h, int w, T d) : m(vector<vector<T>>(h, vector<T>(w, d))) {}\n\t// 添字演算子\n\tvector<T> operator[](const int i) const { return m[i]; } //読み取り\n\tvector<T> &operator[](const int i) { return m[i]; }\t\t //書き込み\n\t// 行数・列数\n\tint nrow = sz(m);\n\tint ncol = sz(m[0]);\n\t// 行列同士の演算\n\tmat &operator=(const mat &a) { return *a; }\n\tmat &operator+=(const mat &a)\n\t{\n\t\tassert(ncol == a.ncol && nrow == a.nrow);\n\t\trep(i, nrow) rep(j, ncol) m[i][j] += a[i][j];\n\t\treturn *this;\n\t}\n\tmat &operator-=(const mat &a)\n\t{\n\t\tassert(ncol == a.ncol && nrow == a.nrow);\n\t\trep(i, nrow) rep(j, ncol) m[i][j] -= a[i][j];\n\t\treturn *this;\n\t}\n\tmat &operator*=(const mat &a)\n\t{\n\t\tassert(ncol == a.nrow);\n\t\tmat<T> m2(nrow, a.ncol, 0);\n\t\trep(i, nrow) rep(j, a.ncol) rep(k, ncol) m2[i][j] += m[i][k] * a[k][j];\n\t\tncol = a.ncol;\n\t\trep(i, nrow) m[i].resize(ncol);\n\t\trep(i, nrow) rep(j, ncol) m[i][j] = m2[i][j];\n\t\treturn *this;\n\t}\n\tmat operator+(const mat &a) const { return mat(*this) += a; }\n\tmat operator-(const mat &a) const { return mat(*this) -= a; }\n\tmat operator*(const mat &a) const { return mat(*this) *= a; }\n\tbool operator==(const mat &a)\n\t{\n\t\tassert(ncol == a.ncol && nrow == a.nrow);\n\t\tbool flg = true;\n\t\trep(i, nrow) rep(j, ncol) if (m[i][j] != a[i][j]) flg = false;\n\t\treturn flg;\n\t}\n\t// 行列とスカラの演算\n\tmat &operator+=(const T &a)\n\t{\n\t\trep(i, nrow) rep(j, ncol) m[i][j] += a;\n\t\treturn *this;\n\t}\n\tmat &operator-=(const T &a)\n\t{\n\t\trep(i, nrow) rep(j, ncol) m[i][j] -= a;\n\t\treturn *this;\n\t}\n\tmat &operator*=(const T &a)\n\t{\n\t\trep(i, nrow) rep(j, ncol) m[i][j] *= a;\n\t\treturn *this;\n\t}\n\tmat &operator/=(const T &a)\n\t{\n\t\trep(i, nrow) rep(j, ncol) m[i][j] /= a;\n\t\treturn *this;\n\t}\n\tmat operator+(const T &a) const { return mat(*this) += a; }\n\tmat operator-(const T &a) const { return mat(*this) -= a; }\n\tmat operator*(const T &a) const { return mat(*this) *= a; }\n\tmat operator/(const T &a) const { return mat(*this) /= a; }\n\t// 回転（degの数だけ時計回りに90度回転）\n\tmat &rot(int deg)\n\t{\n\t\tmat<T> m2(ncol, nrow);\n\t\tif (deg == 1 || deg == 3)\n\t\t{\n\t\t\tif (deg == 1)\n\t\t\t\trep(i, nrow) rep(j, ncol) m2[j][nrow - i - 1] = m[i][j];\n\t\t\tif (deg == 3)\n\t\t\t\trep(i, nrow) rep(j, ncol) m2[ncol - j - 1][i] = m[i][j];\n\t\t\tswap(ncol, nrow); // 列数と行数を入れ替える\n\t\t\tm.resize(nrow);\n\t\t\trep(i, nrow) m[i].resize(ncol); //リサイズ\n\t\t}\n\t\tif (deg == 2)\n\t\t\trep(i, nrow) rep(j, ncol) m2[nrow - i - 1][ncol - j - 1] = m[i][j];\n\t\trep(i, nrow) rep(j, ncol) m[i][j] = m2[i][j];\n\t\treturn *this;\n\t}\n\t// 標準出力\n\tvoid show()\n\t{\n\t\trep(i, nrow) rep(j, ncol)\n\t\t{\n\t\t\tif (j != 0)\n\t\t\t\tcout << \" \";\n\t\t\tcout << m[i][j];\n\t\t\tif (j == ncol - 1)\n\t\t\t\tcout << endl;\n\t\t}\n\t\treturn;\n\t}\n};\n\nint main()\n{\n\tM = 998244353;\n\tll n, k, p[222222];\n\tcin >> n >> k;\n\trep(i, n) cin >> p[i];\n\tll r = k - 1;\n\tr *= modinv(k);\n\tmint ans = k * (k - 1);\n\tans /= 4;\n\tmat<mint> v(3,3,0);\n\tv[0][2] = 1;\n\tv[1][2] = 1;\n\tv[2][2] = 1;\n\tmat<mint> u(3,3,0);\n\tu[0][0] = 1;\n\tu[1][1] = r;\n\tu[2][2] = 1;\n\tmat<mint> t(3,3,0);\n\tt[0][0] = 1;\n\tt[1][1] = 1;\n\tt[2][2] = 1;\n\tmat<mint> z(1, 3, 0);\n\tz[0][2] = 1;\n\tmat<mint> o(1, 3, 1);\n\tfunction<mat<mint>(mat<mint>, mat<mint>)> f = [](mat<mint> a, mat<mint> b) { return a + b; };\n\tfunction<mat<mint>(mat<mint>, mat<mint>)> g = [](mat<mint> a, mat<mint> x) { return x * a; };\n\tfunction<mat<mint>(mat<mint>, mat<mint>)> h = [](mat<mint> v1, mat<mint> v2) { return v2 * v1; };\n\tLazySegmentTree<mat<mint>, mat<mint>> seg(n + 1, f, g, h, z, t);\n\trep(i, k) seg.set(p[i], o);\n\tseg.build();\n\tfor (int i = 1; i < n - k + 1; i++){\n\t\tans += (k - 1) * modinv(2);\n\t\tseg.update(0, n + 1, u);\n\t\tmat<mint> ret = seg.query(p[i + k - 1], n + 1);\n\t\tans += ret[0][0];\n\t\tans -= ret[0][1];\n\t\tseg.update(p[i + k - 1], p[i + k - 1] + 1, v);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a, b)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define lscan(x) scanf(\"%I64d\", &x)\n#define lprint(x) printf(\"%I64d\", x)\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define rep2(i, n) for (ll i = n - 1; i >= 0; i--)\nconst int mod = 998244353;\nll gcd(ll a, ll b)\n{\n\tll c = a % b;\n\twhile (c != 0)\n\t{\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\nstruct UnionFind\n{\n\tvector<ll> data;\n\n\tUnionFind(int sz)\n\t{\n\t\tdata.assign(sz, -1);\n\t}\n\n\tbool unite(int x, int y)\n\t{\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)\n\t\t\treturn (false);\n\t\tif (data[x] > data[y])\n\t\t\tswap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn (true);\n\t}\n\n\tint find(int k)\n\t{\n\t\tif (data[k] < 0)\n\t\t\treturn (k);\n\t\treturn (data[k] = find(data[k]));\n\t}\n\n\tll size(int k)\n\t{\n\t\treturn (-data[find(k)]);\n\t}\n};\n\nll M = 1000000007;\n\nvector<ll> fac(2000011);  //n!(mod M)\nvector<ll> ifac(2000011); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nll mpow2(ll x, ll n, ll mod)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % mod;\n\t\tx = x * x % mod;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb()\n{\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000010; i++)\n\t{\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[2000010] = mpow(fac[2000010], M - 2);\n\tfor (ll i = 2000010; i > 0; i--)\n\t{\n\t\tifac[i - 1] = ifac[i] * i % M;\n\t}\n}\nll comb(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\nlong long modinv(long long a)\n{\n\tlong long b = M, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0)\n\t\tu += M;\n\treturn u;\n}\nll modinv2(ll a, ll mod)\n{\n\tll b = mod, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tll t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0)\n\t\tu += mod;\n\treturn u;\n}\n\ntemplate <int mod>\nstruct ModInt\n{\n\tint x;\n\n\tModInt() : x(0) {}\n\n\tModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n\tModInt &operator+=(const ModInt &p)\n\t{\n\t\tif ((x += p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator-=(const ModInt &p)\n\t{\n\t\tif ((x += mod - p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator*=(const ModInt &p)\n\t{\n\t\tx = (int)(1LL * x * p.x % mod);\n\t\treturn *this;\n\t}\n\n\tModInt &operator/=(const ModInt &p)\n\t{\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\n\tModInt operator-() const { return ModInt(-x); }\n\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\n\tModInt inverse() const\n\t{\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\n\tModInt pow(int64_t n) const\n\t{\n\t\tModInt ret(1), mul(x);\n\t\twhile (n > 0)\n\t\t{\n\t\t\tif (n & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const ModInt &p)\n\t{\n\t\treturn os << p.x;\n\t}\n\n\tfriend istream &operator>>(istream &is, ModInt &a)\n\t{\n\t\tint64_t t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n\n\tstatic int get_mod() { return mod; }\n};\n\nusing mint = ModInt<mod>;\n\nvector<vector<mint>> mul(vector<vector<mint>> a, vector<vector<mint>> b)\n{\n\tint i, j, k;\n\tmint t;\n\tint n = a.size(), m = b[0].size(), l = a[0].size();\n\tvector<vector<mint>> c(n,vector<mint>(m));\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < l; k++)\n\t\t\t\tt += a[i][k] * b[k][j];\n\t\t\tc[i][j] = t;\n\t\t}\n\t}\n\treturn c;\n}\n\nvector<vector<mint>> mat_pow(vector<vector<mint>> x, ll n)\n{\n\tll k = x.size();\n\tvector<vector<mint>> ans(k, vector<mint>(k, 0));\n\tfor (int i = 0; i < k; i++)\n\t\tans[i][i] = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = mul(ans, x);\n\t\tx = mul(x, x);\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\n\ntemplate <typename Monoid>\nstruct SegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\n\tint sz;\n\tvector<Monoid> seg;\n\n\tconst F f;\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1)\n\t{\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x)\n\t{\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t\tL = f(L, seg[a++]);\n\t\t\tif (b & 1)\n\t\t\t\tR = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k) const\n\t{\n\t\treturn seg[k + sz];\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tMonoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, seg[1])))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, seg[a]);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(seg[1], R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(seg[--b], R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\ntemplate <unsigned mod>\nstruct RollingHash\n{\n\tvector<unsigned> hashed, power;\n\n\tinline unsigned mul(unsigned a, unsigned b) const\n\t{\n\t\tunsigned long long x = (unsigned long long)a * b;\n\t\tunsigned xh = (unsigned)(x >> 32), xl = (unsigned)x, d, m;\n\t\tasm(\"divl %4; \\n\\t\"\n\t\t\t: \"=a\"(d), \"=d\"(m)\n\t\t\t: \"d\"(xh), \"a\"(xl), \"r\"(mod));\n\t\treturn m;\n\t}\n\n\tRollingHash(const string &s, unsigned base = 10007)\n\t{\n\t\tint sz = (int)s.size();\n\t\thashed.assign(sz + 1, 0);\n\t\tpower.assign(sz + 1, 0);\n\t\tpower[0] = 1;\n\t\tfor (int i = 0; i < sz; i++)\n\t\t{\n\t\t\tpower[i + 1] = mul(power[i], base);\n\t\t\thashed[i + 1] = mul(hashed[i], base) + s[i];\n\t\t\tif (hashed[i + 1] >= mod)\n\t\t\t\thashed[i + 1] -= mod;\n\t\t}\n\t}\n\n\tunsigned get(int l, int r) const\n\t{\n\t\tunsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tunsigned connect(unsigned h1, int h2, int h2len) const\n\t{\n\t\tunsigned ret = mul(h1, power[h2len]) + h2;\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tint LCP(const RollingHash<mod> &b, int l1, int r1, int l2, int r2)\n\t{\n\t\tint len = min(r1 - l1, r2 - l2);\n\t\tint low = -1, high = len + 1;\n\t\twhile (high - low > 1)\n\t\t{\n\t\t\tint mid = (low + high) / 2;\n\t\t\tif (get(l1, l1 + mid) == b.get(l2, l2 + mid))\n\t\t\t\tlow = mid;\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\t\treturn (low);\n\t}\n};\n\nusing RH = RollingHash<1000000007>;\n\ntemplate <typename T>\nstruct edge\n{\n\tint src, to;\n\tT cost;\n\n\tedge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n\tedge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n\tedge &operator=(const int &x)\n\t{\n\t\tto = x;\n\t\treturn *this;\n\t}\n\n\toperator int() const { return to; }\n};\n\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate <typename T>\nusing Matrix = vector<vector<T>>;\n\ntemplate <typename G>\nstruct DoublingLowestCommonAncestor\n{\n\tconst int LOG;\n\tvector<int> dep;\n\tconst G &g;\n\tvector<vector<int>> table;\n\n\tDoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size()))\n\t{\n\t\ttable.assign(LOG, vector<int>(g.size(), -1));\n\t}\n\n\tvoid dfs(int idx, int par, int d)\n\t{\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor (auto &to : g[idx])\n\t\t{\n\t\t\tif (to != par)\n\t\t\t\tdfs(to, idx, d + 1);\n\t\t}\n\t}\n\n\tvoid build()\n\t{\n\t\tdfs(0, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG; k++)\n\t\t{\n\t\t\tfor (int i = 0; i < table[k].size(); i++)\n\t\t\t{\n\t\t\t\tif (table[k][i] == -1)\n\t\t\t\t\ttable[k + 1][i] = -1;\n\t\t\t\telse\n\t\t\t\t\ttable[k + 1][i] = table[k][table[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v)\n\t{\n\t\tif (dep[u] > dep[v])\n\t\t\tswap(u, v);\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (((dep[v] - dep[u]) >> i) & 1)\n\t\t\t\tv = table[i][v];\n\t\t}\n\t\tif (u == v)\n\t\t\treturn u;\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (table[i][u] != table[i][v])\n\t\t\t{\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid>\nstruct LazySegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\tusing G = function<Monoid(Monoid, OperatorMonoid)>;\n\tusing H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n\tint sz, height;\n\tvector<Monoid> data;\n\tvector<OperatorMonoid> lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst Monoid M1;\n\tconst OperatorMonoid OM0;\n\n\tLazySegmentTree(int n, const F f, const G g, const H h,\n\t\t\t\t\tconst Monoid &M1, const OperatorMonoid OM0)\n\t\t: f(f), g(g), h(h), M1(M1), OM0(OM0)\n\t{\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1, height++;\n\t\tdata.assign(2 * sz, M1);\n\t\tlazy.assign(2 * sz, OM0);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tdata[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tdata[k] = f(data[2 * k + 0], data[2 * k + 1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k)\n\t{\n\t\tif (lazy[k] != OM0)\n\t\t{\n\t\t\tlazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n\t\t\tlazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = OM0;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k)\n\t{\n\t\treturn lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n\t}\n\n\tinline void recalc(int k)\n\t{\n\t\twhile (k >>= 1)\n\t\t\tdata[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n\t}\n\n\tinline void thrust(int k)\n\t{\n\t\tfor (int i = height; i > 0; i--)\n\t\t\tpropagate(k >> i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tlazy[l] = h(lazy[l], x), ++l;\n\t\t\tif (r & 1)\n\t\t\t\t--r, lazy[r] = h(lazy[r], x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tMonoid L = M1, R = M1;\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tL = f(L, reflect(l++));\n\t\t\tif (r & 1)\n\t\t\t\tR = f(reflect(--r), R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k)\n\t{\n\t\treturn query(k, k + 1);\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tpropagate(a);\n\t\t\tMonoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, reflect(1))))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(a + sz);\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, reflect(a));\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(reflect(1), R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(b + sz - 1);\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(reflect(--b), R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nvector<vector<mint>> vsum(vector<vector<mint>> a, vector<vector<mint>> b){\n\tint n = a.size(), m = a[0].size();\n\tvector<vector<mint>> v(n, vector<mint>(m));\n\trep(i, n) rep(j, m) v[i][j] = a[i][j] + b[i][j];\n\treturn v;\n}\n\nint main()\n{\n\tM = 998244353;\n\tll n, k, p[222222];\n\tcin >> n >> k;\n\trep(i, n) cin >> p[i];\n\tll r = k - 1;\n\tr *= modinv(k);\n\tmint ans = k * (k - 1);\n\tans /= 4;\n\tvector<vector<mint>> v(3,vector<mint>(3,0));\n\tv[0][2] = 1;\n\tv[1][2] = 1;\n\tv[2][2] = 1;\n\tvector<vector<mint>> u(3, vector<mint>(3, 0));\n\tu[0][0] = 1;\n\tu[1][1] = r;\n\tu[2][2] = 1;\n\tvector<vector<mint>> t(3, vector<mint>(3, 0));\n\tt[0][0] = 1;\n\tt[1][1] = 1;\n\tt[2][2] = 1;\n\tvector<vector<mint>> z(3, vector<mint>(1, 0));\n\tz[2][0] = 1;\n\tvector<vector<mint>> o(3, vector<mint>(1, 1));\n\tfunction<vector<vector<mint>>(vector<vector<mint>>, vector<vector<mint>>)> f = [](vector<vector<mint>> a, vector<vector<mint>> b) { return vsum(a, b); };\n\tfunction<vector<vector<mint>>(vector<vector<mint>>, vector<vector<mint>>)> g = [](vector<vector<mint>> a, vector<vector<mint>> x) { return mul(x, a); };\n\tfunction<vector<vector<mint>>(vector<vector<mint>>, vector<vector<mint>>)> h = [](vector<vector<mint>> v1, vector<vector<mint>> v2) { return mul(v2, v1); };\n\tLazySegmentTree<Matrix<mint>, Matrix<mint>> seg(n + 1, f, g, h, z, t);\n\trep(i, k) seg.set(p[i], o);\n\tseg.build();\n\tfor (int i = 1; i < n - k + 1; i++){\n\t\tans += (k - 1) * modinv(2);\n\t\tseg.update(0, n + 1, u);\n\t\tvector<vector<mint>> ret = seg.query(p[i + k - 1], n + 1);\n\t\tans += ret[0][0];\n\t\tans -= ret[1][0];\n\t\tseg.update(p[i + k - 1], p[i + k - 1] + 1, v);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define gc getchar()//(p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++)\n#define mk make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define IT iterator \n#define vi vector<int>\n#define TP template<class o>\n#define SZ(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\nconst int N=2e5+10,size=1<<20,mod=998244353,inf=2e9;\n\n//char buf[size],*p1=buf,*p2=buf;\ntemplate<class o> void qr(o &x) {\n    char c=gc; x=0; int f=1;\n    while(!isdigit(c)){if(c=='-')f=-1; c=gc;}\n    while(isdigit(c)) x=x*10+c-'0',c=gc;\n    x*=f;\n}\ntemplate<class o> void qw(o x) {\n    if(x/10) qw(x/10);\n    putchar(x%10+'0');\n}\ntemplate<class o> void pr1(o x) {\n    if(x<0)x=-x,putchar('-');\n    qw(x); putchar(' ');\n}\ntemplate<class o> void pr2(o x) {\n    if(x<0)x=-x,putchar('-');\n    qw(x); putchar('\\n');\n}\n\nll p[N],np[N],n,k,s,cnt,ans;\nint c[N],a[N];\n\nTP void upd(o &x,int y) {x += y; if(x>=mod) x -= mod;}\nvoid add(int x,int y) {upd(s,y); for( ;x<=n;x += x&-x) upd(c[x],y); }\nint ask(int x) {ll y=0; for( ; x;x -= x&-x) y += c[x]; return y%mod; }\nvoid clear() {memset(c+1,0,sizeof(int)*n); s=0;}\n\nll mult(ll a,ll b,ll p) {\n    a=(a%p+p)%p; b=(b%p+p)%p;\n    ll c=(ld)a*b/p;\n    return a*b-c*p;\n}\nll gcd(ll a,ll b) {return !a?b:gcd(b%a,a);}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\nll power(ll a,ll b=mod-2) {\n    ll c=1;\n    while(b) {\n        if(b&1) c=c*a%mod;\n        b /= 2; a=a*a%mod;\n    }\n    return c;\n}\nll Power(ll a,ll b=mod-2) {\n    ll c=1;\n    while(b) {\n        if(b&1) c=mult(c,a,mod);\n        b /= 2; a=mult(a,a,mod);\n    }\n    return c;\n}\n\nint main() {\n    qr(n); qr(k);\n    for(int i=1;i<=n;i++) \n\t\tqr(a[i]),add(a[i],1),cnt += i-ask(a[i]);\n    p[0]=np[0]=1; p[1]=(k-1)*power(k)%mod; np[1]=power(p[1]); clear();\n    for(int i=2;i<=n;i++) p[i]=p[i-1]*p[1]%mod,np[i]=np[i-1]*np[1]%mod;\n    for(int i=1;i<=n;i++) {\n        int f=max(i-k,0LL);\n        ans += p[f]*(2*ask(a[i])-s+mod)%mod;\n        add(a[i],np[f]);\n    }\n    pr2((cnt+ans%mod*(mod+1)/2%mod)%mod); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<atcoder/modint>\n#include<atcoder/fenwicktree>\nusing namespace std;\nusing namespace atcoder;\nusing mint=modint998244353;\nint N,K;\nint P[2<<17];\nlong calc()\n{\n\tfenwick_tree<int>A(N+1);\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tans+=i-A.sum(0,P[i]);\n\t\tA.add(P[i],1);\n\t}\n\treturn ans;\n}\nmain()\n{\n\tcin>>N>>K;\n\tfor(int i=0;i<N;i++)cin>>P[i];\n\tmint ans=calc();\n\tans*=K;\n\tmint invK=mint(1)/K;\n\tmint X=mint(K-1)*invK;\n\tmint Y=mint(K-2)*invK;\n\tmint invY=mint(1)/(1-Y);\n\tmint Kinv2=mint(1)/2*K;\n\tfenwick_tree<int>Q(N+1);\n\tfenwick_tree<int>R(N+1);\n\tfor(int j=1;j<N;j++)\n\t{\n\t\tQ.add(P[j-1],1);\n\t\tif(j<=K)R.add(P[j-1],1);\n\t\tint t=min(N-j,N-K);\n\t\tmint Yt=Y.pow(t);\n\t\tmint T=(1-Yt)*invY+Yt*Kinv2;\n\t\tmint tmp=0;\n\t\tif(j<=K-1)\n\t\t{\n\t\t\ttmp=2*Q.sum(0,P[j])-j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp=X.pow(j-(K-1))*(2*R.sum(0,P[j])-K);\n\t\t\tmint a=X;\n\t\t\tfor(int i=j;--i>=K;)\n\t\t\t{\n\t\t\t\tif(P[i]<P[j])tmp+=a;\n\t\t\t\telse tmp-=a;\n\t\t\t\ta*=X;\n\t\t\t}\n\t\t}\n\t\tans+=tmp*T;\n\t}\n\tcout<<(ans*invK).val()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define FORR2(x,y,arr) for(auto& [x,y]:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[202020];\n\nll mo=998244353;\ntemplate<class V, int ME> class BIT_mod {\npublic:\n\tV bit[1<<ME];\n\tBIT_mod(){ZERO(bit);};\n\tV operator()(int e) {ll s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s%mo;}\n\tvoid add(int e,V v) { e++; while(e<=1<<ME) { bit[e-1]+=v; bit[e-1] -= (bit[e-1]>=mo)?mo:0; e+=e&-e;}}\n};\nBIT_mod<ll,20> bt,num;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\tFOR(i,N) cin>>A[i];\n\t\n\tll r2=(mo+1)/2;\n\tll ret=0;\n\tFOR(i,K) {\n\t\tbt.add(A[i],1);\n\t\tnum.add(A[i],1);\n\t}\n\t\n\tret=K*(K-1)*r2%mo*r2%mo;\n\t\n\tll p=(K-1)*modpow(K)%mo;\n\tll rp=1;\n\tll c=1;\n\tfor(i=K;i<N;i++) {\n\t\tc=c*p%mo;\n\t\t// less\n\t\t(ret+=bt(A[i])*(c*r2%mo))%=mo;\n\t\t// more\n\t\t(ret+=(mo+bt(N)-bt(A[i]))*(mo-c*r2%mo))%=mo;\n\t\t(ret+=(mo+num(N)-num(A[i])))%=mo;\n\t\tbt.add(A[i],modpow(c));\n\t\tnum.add(A[i],1);\n\t}\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include<bits/extc++.h>\n#define int long long\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define rep(i,n) for (int i=0;i<(int)(n);++i)\n#define rep1(i,n) for (int i=1;i<=(int)(n);++i)\n#define range(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define F first\n#define S second\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> VL;\n\n\nll power(ll u,ll v,ll mod){\n    ll ret=1,t=u%mod;\n    while (v){\n        if (v&1) ret=t*ret%mod;\n        t=t*t%mod, v>>=1;\n    }\n    return ret%mod;\n}\n \n/*\n计算gcd(a,b)并找寻ax+by=gcd(a,b)的一组解\nret=exgcd(a,b,x,y); \n*/\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if (b){\n        ll d=exgcd(b,a%b,y,x);\n        return y-=a/b*x, d;\n    }\n    return x=1,y=0,a;\n}\n \n/*\n计算x=a(mod m), x=b(mod n)的一组解，若无解返回-1\nret=crt(a,m,b,n);\n*/\nll crt(ll a,ll m,ll b,ll n){\n    if (n>m) swap(a,b), swap(n,m);\n    ll x,y,g=exgcd(m,n,x,y);\n    if ((b-a)%g) return -1;\n    x=(b-a)%n*x%n/g*m+a;\n    return x<0?x+m*n/g:x;\n}\n \n/*\n生成<=n的质数\ngen_prime<5000>(ret);\n*/\n \nvoid gen_prime(int n,vi &ret){\n    vector<bool> p;\n    p.resize(n+1,1);\n    p[0]=p[1]=0;\n    for (int i=4;i<=n;i+=2) p[i]=0;\n    for (int i=3;i*i<=n;i+=2){\n        if (p[i]){\n            for (int j=i*i;j<=n;j+=2*i){\n                p[j]=0;\n            }\n        }\n    }\n    for (int i=2;i<=n;++i){\n        if (p[i]) ret.pb(i);\n    }\n}\n \n/*\n生成<=n的phi\ngen_phi<5000>(ret);\n*/\nvoid gen_phi(int n,vi &phi){\n    phi.resize(n+1);\n    for (int i=0;i<=n;++i) phi[i]=i&1?i:i/2;\n    for (int i=3;i<=n;i+=2){\n        if (phi[i]==i){\n            for (int j=i;j<=n;j+=i) phi[j]-=phi[j]/i;\n        }\n    }\n}\n \n/*\n支持更高的快速幂操作\nexpower.mod_pow(a,b,mod);\n*/\n \nstruct expower{\n    ull mod_mul(ull a,ull b,ull M) {\n        ll ret=a*b-M*ull(ld(a)* ld(b)/ld(M));\n        return ret+M*(ret<0)-M*(ret>=(ll)M);\n    }\n    ull mod_pow(ull b,ull e,ull mod) {\n        ull ans=1;\n        for (; e; b=mod_mul(b,b,mod), e/=2)\n            if (e&1) ans=mod_mul(ans,b,mod);\n        return ans%mod;\n    }\n}expower;\n \n/*\nMiller-Rubin素数判别\nis_prime(n);\n*/\nbool is_prime(ull n){ \n    if (n<2||n%6%4!=1) return n-2<2;\n    ull A[]={2,325,9375,28178,450775,9780504,1795265022},\n    s=__builtin_ctzll(n-1), d = n >> s;\n    for (auto a:A){\n        ull p=expower.mod_pow(a,d,n),i=s;\n        while (p!=1&&p!=n-1&&a%n&&i--)\n            p=expower.mod_mul(p,p,n);\n        if (p!=n-1&&i!=s) return 0;\n    }\n    return 1;\n}\n \n/*\n素因数分解\nret=factorization(n);\n*/\null pollard(ull n){\n    auto f=[n](ull x){return (expower.mod_mul(x,x,n)+1)%n;};\n    if (!(n&1)) return 2;\n    for (ull i=2;;i++){\n        ull x=i,y=f(x),p;\n        while ((p=__gcd(n+y-x,n))==1)\n            x=f(x),y=f(f(y));\n        if (p!=n) return p;\n    }\n}\n \nvector<ull> factorization(ull n){\n    if (n==1) return {};\n    if (is_prime(n)) return {n};\n    ull x=pollard(n);\n    auto l=factorization(x),r=factorization(n/x);\n    l.insert(l.end(),range(r));\n    return l;\n}\n \nstruct DSU{\n    //insert info.\n    vector<int> p;\n    DSU(int n){\n        p.resize(n+1);\n        for (int i=1;i<=n;++i) p[i]=i;\n    }\n    int find(int u){\n        if (p[u]==u) return u;\n        return p[u]=find(find(p[u]));\n    } \n    bool unite(int u,int v){\n        int pu=find(u), pv=find(v);\n        if (pu!=pv){\n            p[pu]=pv;\n        }\n        return pu!=pv;\n    }\n};\n \n/* (u,v,w) */\ntemplate<class T> vector<tuple<int,int,T> > MST(int n,vector<tuple<int,int,T> >g){\n    vector<tuple<int,int,T> > ret;\n    ret.clear();\n    DSU dsu(n);\n    auto cmp=[&](tuple<int,int,T> x,tuple<int,int,T> y){\n        int ux,uy,vx,vy;\n        T wx,wy;\n        tie(ux,vx,wx)=x, tie(uy,vy,wy)=y;\n        return wx<wy;\n    };\n    sort(range(g),cmp);\n    for (auto c:g){\n        int u,v;\n        T w;\n        tie(u,v,w)=c;\n        if(dsu.unite(u,v)) ret.push_back(c);\n    }\n    return ret;\n}\n \ntemplate<int n,class T>\nstruct SegmentTree{\n    typedef struct{\n        T lz,mx,mn,sum;\n    }Node;\n    vector<Node> tree;\n    SegmentTree(){\n        tree.resize((n+7)<<2);\n    }  \n    void pushup(int num){\n        tree[num].mx=max(tree[num<<1].mx,tree[num<<1|1].mx);\n        tree[num].mn=min(tree[num<<1].mn,tree[num<<1|1].mn);\n        tree[num].sum=tree[num<<1].sum+tree[num<<1|1].sum;\n    }\n    void pushdown(int num,int l,int r,int md){\n        if (tree[num].lz){\n            tree[num<<1].mx+=tree[num].lz;\n            tree[num<<1|1].mx+=tree[num].lz;\n            tree[num<<1].mn+=tree[num].lz;\n            tree[num<<1|1].mn+=tree[num].lz;\n            tree[num<<1].sum+=tree[num].lz*(md-l+1);\n            tree[num<<1|1].sum+=tree[num].lz*(r-md);\n            tree[num<<1].lz+=tree[num].lz;\n            tree[num<<1|1].lz+=tree[num].lz;\n            tree[num].lz=0;\n        }\n    }\n    void update1(int num,int l,int r,int L,int R,T val){\n        if (L<=l&&r<=R){\n            tree[num].mx+=val;\n            tree[num].mn+=val;\n            tree[num].sum+=val*(r-l+1);\n            tree[num].lz+=val;\n            return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=L) update1(num<<1,l,md,L,R,val);\n        if (md<R) update1(num<<1|1,md+1,r,L,R,val);\n        pushup(num);\n    }\n    tuple<T,T,T> query1(int num,int l,int r,int L,int R){\n        if (L<=l&&r<=R){\n            return {tree[num].mn,tree[num].mx,tree[num].sum};\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=R){\n            return query1(num<<1,l,md,L,R);\n        }\n        else{\n            if (md<L){\n                return query1(num<<1|1,md+1,r,L,R);\n            }\n            else{\n                tuple<T,T,T> ret1=query1(num<<1,l,md,L,R), ret2=query1(num<<1|1,md+1,r,L,R);\n                T a,b,c,d,e,f;\n                tie(a,b,c)=ret1, tie(d,e,f)=ret2;\n                return {min(a,d),max(b,e),c+f};\n            }\n        } \n    }\n    void update(int L,int R,int w){\n        update1(1,1,n,L,R,w);\n    }\n    tuple<T,T,T> query(int L,int R){\n        return query1(1,1,n,L,R);\n    }\n    void debug1(int num,int l,int r){\n        if (l==r){\n            cout<<tree[num].mn<<\" \"; return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        debug1(num<<1,l,md);\n         debug1(num<<1|1,md+1,r);        \n    }\n    void debug(){\n        debug1(1,1,n);\n        cout<<endl;\n    }\n};\n \nstruct XORBasis{\n    int n;\n    vector<ull> p;\n    vector<ull> ans;\n    XORBasis(int k):n(k){\n        p.resize(k+1);\n    }\n    void rebuilt(){\n        ans.clear();\n        for (int i=0;i<=n;++i){\n            if (p[i]) ans.push_back(p[i]);\n        }\n    }\n    void insert(ull u){\n        for (int i=n;i>=0;--i){\n            if (u&(1ull<<i)){\n                if (p[i]) u^=p[i];\n                else{\n                    p[i]=u;\n                    for (int j=i-1;j>=0;--j){\n                        if (p[i]&(1ull<<j)) p[i]^=p[j];\n                    }\n                    for (int j=i+1;j<=n;++j){\n                        if (p[j]&(1ull<<i)) p[j]^=p[i];\n                    }\n                    break;\n                }\n            }\n        }\n        rebuilt();\n    }\n    bool check(ull u){\n        for (int i=n;i>-1;--i){\n            if (u&(1ull<<i)) u^=p[i];\n        }\n        return (u==0);\n    }\n    ull kth(ull t){ // the k-th smallest, excluding 0.\n        if (t>=(1ull<<sz(ans))) return -1;\n        ull ret=0;\n        for (int i=0;i<sz(ans);++i){\n            if (t&(1ull<<i)) ret^=ans[i];\n        }\n        return ret;\n    }\n    ull total(){\n        return (1ull<<sz(ans));\n    }\n};\n \n \nvi pi(const string& s) {\n\tvi p(sz(s));\n\tfor (int i=1;i<=sz(s);++i) {\n\t\tint g = p[i-1];\n\t\twhile (g && s[i] != s[g]) g = p[g-1];\n\t\tp[i] = g + (s[i] == s[g]);\n\t}\n\treturn p;\n}\n \nvi match(const string& s, const string& pat) {\n\tvi p = pi(pat + '\\0' + s), res;\n\tfor(int i=sz(p)-sz(s);i<=sz(p);++i)\n\t\tif (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));\n\treturn res;\n}\n \n \nstruct AhoCorasick {\n\tenum {alpha = 26, first = 'a'};\n\tstruct Node {\n\t\t// (nmatches is optional)\n\t\tint back, next[alpha], start = -1, end = -1;\n        ll nmatches = 0;\n\t\tNode(int v) { memset(next, v, sizeof(next)); }\n\t};\n\tvector<Node> N;\n\tvector<int> backp;\n\tvoid insert(string& s, int j,ll val) {\n\t\tassert(!s.empty());\n\t\tint n = 0;\n\t\tfor(auto c:s) {\n\t\t\tint& m = N[n].next[c - first];\n\t\t\tif (m == -1) { n = m = sz(N); N.emplace_back(-1); }\n\t\t\telse n = m;\n\t\t}\n\t\tif (N[n].end == -1) N[n].start = j;\n\t\tbackp.push_back(N[n].end);\n\t\tN[n].end = j;\n\t\tN[n].nmatches+=val;\n\t}\n\tAhoCorasick(vector<string>& pat,vi val) {\n\t\tN.emplace_back(-1);\n\t\tfor (int i=0;i<sz(pat);++i) insert(pat[i], i, val[i]);\n\t\tN[0].back = sz(N);\n\t\tN.emplace_back(0);\n \n\t\tqueue<int> q;\n\t\tfor (q.push(0); !q.empty(); q.pop()) {\n\t\t\tint n = q.front(), prev = N[n].back;\n\t\t\tfor (int i=0;i<alpha;++i) {\n\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];\n\t\t\t\tif (ed == -1) ed = y;\n\t\t\t\telse {\n\t\t\t\t\tN[ed].back = y;\n\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])\n\t\t\t\t\t\t= N[y].end;\n\t\t\t\t\tN[ed].nmatches += N[y].nmatches;\n\t\t\t\t\tq.push(ed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvi find(string& word,ll& ans) {\n\t\tint n = 0;\n\t\tvi res;\n\t\tfor(auto c:word) {\n\t\t\tn = N[n].next[c - first];\n\t\t\tres.push_back(N[n].end);\n\t\t\tans += N[n].nmatches;\n\t\t}\n\t\treturn res;\n\t}\n\tvector<vi> findAll(vector<string>& pat, string word) {\n\t\tll ans=0;\n        vi r = find(word,ans);\n\t\tvector<vi> res(sz(word));\n\t\tfor (int i=0;i<sz(word);++i) {\n\t\t\tint ind = r[i];\n\t\t\twhile (ind != -1) {\n\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);\n\t\t\t\tind = backp[ind];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n \nstruct HLD{\n    int n,cnt=0;\n    vector<vi> G;\n    vi par,dep,siz,son,top,dfn,rk; \n    //父亲节点，深度，子树大小，重子节点，重链头部，dfs序，dfs序对应的节点编号\n    HLD(vector<vi> g,int root=1):n(sz(g)),G(g),par(n+7),dep(n+7),siz(n+7,1),son(n+7,-1),top(n+7),dfn(n+7),rk(n+7){\n        dep[0]=-1, dfs1(root,0), dfs2(root,0,root);\n    }\n    void dfs1(int u,int p){\n        for (auto c:G[u]){\n            if (c==p) continue;\n            dep[c]=dep[u]+1, par[c]=u;\n            dfs1(c,u);\n            siz[u]+=siz[c];\n            if (son[u]==-1||siz[son[u]]<siz[c]) son[u]=c;\n        }\n    }\n    void dfs2(int u,int p,int tp){\n        top[u]=tp;\n        dfn[u]=++cnt;\n        rk[cnt]=u;\n        if (son[u]==-1) return;\n        dfs2(son[u],u,tp);\n        for (auto c:G[u]){\n            if (c==p||c==son[u]) continue;\n            dfs2(c,u,c);\n        }\n    }\n    int lca(int u,int v){\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                u=par[top[u]];\n            }\n            else{\n                v=par[top[v]];\n            }\n        }\n        return dep[u]>dep[v]?v:u;\n    }\n    vector<pii> find_seg(int u,int v){\n        vector<pii> ft,bk,res;\n        ft.clear(), bk.clear(), res.clear();\n//        cout<<top[u]<<\" \"<<top[v]<<endl;\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                ft.pb({u,top[u]});\n                u=par[top[u]];\n            }\n            else{\n                bk.pb({top[v],v});\n                v=par[top[v]];\n            }\n        }\n        ft.pb({u,v});\n        for (int i=0;i<sz(ft);++i) res.pb(ft[i]);\n        for (int i=sz(bk);i>0;--i) res.pb(bk[i-1]);\n        return res;\n    }\n};\n \nstruct BIT{\n    vi C; int n;\n    BIT(int n):n(n){C.resize(n+7,0);}\n    void update(int u,int w){\n        for (;u<=n;u+=u&(-u)) C[u]+=w;\n    }\n    int query(int u){\n        int res=0;\n        for (;u>0;u-=u&(-u)) res+=C[u];\n        return res; \n    }\n};\n\nvi topoSort(const vector<vi>& gr) {\n\tvi indeg(sz(gr)), ret;\n\tfor (auto& li : gr) for (int x : li) indeg[x]++;\n\tqueue<int> q; // use priority queue for lexic. smallest ans.\n\trep(i,sz(gr)) if (indeg[i] == 0) q.push(-i);\n\twhile (!q.empty()) {\n\t\tint i = -q.front(); // top() for priority queue\n\t\tret.push_back(i);\n\t\tq.pop();\n\t\tfor (int x : gr[i])\n\t\t\tif (--indeg[x] == 0) q.push(-x);\n\t}\n\treturn ret;\n}\n\nvi path;\nnamespace Eulerian {\n    const int N = 3, M = 3;\n    int t, n, m, tot, cc, hd[N], nxt[M], to[M], bh[M], vis[M], in[N], out[N], ans[M];\n    void add(int x, int y, int id) {\n        nxt[++tot] = hd[x];\n        hd[x] = tot;\n        to[tot] = y;\n        bh[tot] = id;\n        in[y]++;\n        out[x]++;\n    }\n    void dfs(int x) {\n        for (int i = hd[x]; i; i = hd[x]) {\n            while (i && vis[abs(bh[i])]) i = nxt[i];\n            hd[x] = i;\n            if (!i) break;\n            vis[abs(bh[i])] = 1;\n            dfs(to[i]), ans[++cc] = bh[i];\n        }\n    }\n \n    void init() {\n        memset(hd, 0, sizeof(hd));\n        memset(nxt, 0, sizeof(nxt));\n        memset(to, 0, sizeof(to));\n        memset(bh, 0, sizeof(bh));\n        memset(vis, 0, sizeof(vis));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n        memset(ans, 0, sizeof(ans));\n        t = 1;\n        n = 0;\n        m = 0;\n        tot = 0;\n        cc = 0;\n    }\n    bool solve() {\n        for (int i = 1; i <= n; i++)\n            if ((t == 1 && in[i] & 1)) {\n                return false;\n            }\n        dfs(to[1]);\n        if (cc < m) return false;\n        else {\n            path.clear();\n            for (int i = cc; i >= 1; i--) path.push_back(ans[i]);\n            return true;\n        }\n    }\n} // namespace Eulerian\n\nnamespace FWT{\n    //mod=-1 (no mod)\n    const int mod=-1;\n\n    inline int modadd(int a,int b){\n        a+=b;\n        if (mod==-1) return a;\n        a%=mod, a+=mod, a%=mod;\n        return a;\n    }\n\n    vi OR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j]=modadd(b[j],b[j^(1<<i)]*mode); \n            }\n        }\n        return b;\n    }\n    vi AND(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]*mode);\n            }\n        }\n        return b;\n    }\n    vi XOR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1){\n                    b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]);\n                    b[j]=modadd(b[j^(1<<i)],-2*b[j]);\n                    if (mode<0) {\n                        if (mod>0) b[j]=b[j]*power(2,mod-2,mod)%mod, b[j^(1<<i)]=b[j^(1<<i)]*power(2,mod-2,mod)%mod;\n                        else b[j]/=2, b[j^(1<<i)]/=2;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n}\n\nconst int maxn=200007;\nconst int mod=998244353;\n\nint inv(int u){\n    return power(u,mod-2,mod);\n}\nint mult(int u,int v){\n    return u*v%mod;\n}\nint n,k;\nint a[maxn],p[maxn],q[maxn];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin>>n>>k;\n    rep1(i,n) cin>>a[i],p[i]=i;\n    sort(p+1,p+n+1,[&](int u,int v){return a[u]<a[v];});\n    rep1(i,n) q[p[i]]=1;\n    BIT C(n),C0(n);\n    int ans=0,ans0=0;\n    rep1(i,n){\n        C.update(a[i],power(1+inv(k-1),max(0ll,i-k),mod));\n        C0.update(a[i],1);\n        int r=C.query(n)-C.query(a[i]);\n        if (r>0) ans=(ans+mult(r,power(1-inv(k)+mod,max(0ll,i-k),mod)))%mod;\n //       cout<<ans<<endl;\n        ans0=(ans0+C0.query(n)-C0.query(a[i]))%mod;\n    }\n    ans=(ans0-ans+mod)%mod;\n    int tmp=0;\n    tmp=k*(k-1)/2;\n    tmp%=mod;\n    for (int i=1;i<=n-k;++i){\n        tmp=(tmp+mult(k,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    for (int i=1;i<n-k;++i){\n        int w=n-k-i;\n        tmp=(tmp+mult(w,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    tmp=mult(tmp,inv(2));\n    cout<<(ans+tmp)%mod;\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 998244353\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\n#include<atcoder/all>\nusing namespace atcoder;\n\nusing S = mod;\nusing F = mod;\n\n\nS op(S l, S r) { return l+r; }\n\nS e() { return 0; }\n\nS mapping(F l, S r) { return l*r; }\n\nF composition(F l, F r) { return l*r; }\n\nF id() { return 1; }\n\nint main(){\n    mod res = 0;\n    int n,K;\n    cin >> n >> K;\n    mod k = K;\n    vector<int> a(n);\n    rep(i,n){\n        cin >> a[i];\n        a[i]--;\n    }\n    lazy_segtree<S, op, e, F, mapping, composition, id> seg(n);\n    fenwick_tree<int> fw(n);\n    for(int i=0;i<n-K+1;i++){\n        if(i==0){\n            for(int j=0;j<K;j++){\n                fw.add(a[j],1);  \n                seg.set(a[j],(k-1)/k);\n            }\n            res += k*(k-1)/4;\n        }else if(i==n-K){\n            int X = a[i+K-1];\n            mod P = 0;\n            res -= seg.prod(X,n);\n            res += fw.sum(X,n);\n            res += (k-1)/2;\n        }else{\n            int X = a[i+K-1];\n            mod P = 0;\n            res -= seg.prod(X,n);\n            res += fw.sum(X,n);\n            res += (k-1)/2;\n            seg.set(X,1);\n            seg.apply(0,n,(k-1)/k);\n            fw.add(X,1);\n        }\n        // cerr << i << \" \" << res << endl;\n    }\n    // cerr << (mod)3/(mod)(2) << endl;\n    // cerr << (mod)5/(mod)(2) << endl;\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//By TheOneYouWant\n#pragma GCC optimize (\"-O2\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define memreset(a) memset(a,0,sizeof(a))\n#define testcase(t) int t;cin>>t;while(t--)\n#define forstl(i,v) for(auto &i: v)\n#define forn(i,e) for(int i=0;i<e;++i)\n#define forsn(i,s,e) for(int i=s;i<e;++i)\n#define rforn(i,s) for(int i=s;i>=0;--i)\n#define rforsn(i,s,e) for(int i=s;i>=e;--i)\n#define bitcount(a) __builtin_popcount(a) // set bits (add ll)\n#define ln '\\n'\n#define getcurrtime() cerr<<\"Time = \"<<((double)clock()/CLOCKS_PER_SEC)<<endl\n#define dbgarr(v,s,e) cerr<<#v<<\" = \"; forsn(i,s,e) cerr<<v[i]<<\", \"; cerr<<endl\n#define inputfile freopen(\"input.txt\", \"r\", stdin)\n#define outputfile freopen(\"output.txt\", \"w\", stdout)\n#define dbg(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); \\\nstringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) { cerr<<endl; }\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << \"\\t\"; err(++it, args...);\n}\ntemplate<typename T1,typename T2>\nostream& operator <<(ostream& c,pair<T1,T2> &v){\n    c<<\"(\"<<v.fi<<\",\"<<v.se<<\")\"; return c;\n}\ntemplate <template <class...> class TT, class ...T>\nostream& operator<<(ostream& out,TT<T...>& c){\n    out<<\"{ \";\n    forstl(x,c) out<<x<<\" \";\n    out<<\"}\"; return out;\n}\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> p64;\ntypedef pair<int,int> p32;\ntypedef pair<int,p32> p96;\ntypedef vector<ll> v64;\ntypedef vector<int> v32; \ntypedef vector<v32> vv32;\ntypedef vector<v64> vv64;\ntypedef vector<p32> vp32;\ntypedef vector<p64> vp64;\ntypedef vector<vp32> vvp32;\ntypedef map<int,int> m32;\nconst int LIM=2e5+5,MOD=998244353;\nconst ld EPS = 1e-9;\n\nint read(){\n    int xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=(xx<<3)+(xx<<1)+ch-'0';ch=getchar();}\n    return xx*ff;\n}\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll add(ll a, ll b){\n    return (a+b)%MOD;\n}\n\nll mul(ll a, ll b){\n    return (a*b)%MOD;\n}\n\nll fastpow(ll a, ll p){\n    if(p == 0) return 1;\n    ll z = fastpow(a, p/2);\n    z = mul(z,z);\n    if(p%2) z = mul(z, a);\n    return z;\n}\n\nint main(){\n    fastio;\n\n    int n, k; cin>>n>>k;\n    ll ans = 0;\n    int a[n]; forn(i,n) cin>>a[i];\n\n    forn(j,n){\n        forn(i,j){\n            ll rat = mul(k-1, fastpow(k,MOD-2));\n            rat = fastpow(rat, max(0, j-max(k-1,i)));\n            rat = mul(rat, fastpow(2,MOD-2));\n            \n            if(a[i]<a[j]) ans = add(ans,rat);\n            else{\n                ll num = mul(2,fastpow(k,max(0, j-max(k-1,i)))) - fastpow(k-1,max(0, j-max(k-1,i)));\n                num %= MOD;\n                if(num<0) num += MOD;\n                ll denom = mul(2,fastpow(k,max(0, j-max(k-1,i))));\n                num = mul(num, fastpow(denom, MOD-2));\n                num %= MOD;\n                ans = add(ans, num);\n            }\n        }\n    }\n    cout<<ans<<ln;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace/acl1/e/e.cpp\"\n#include <bits/extc++.h>\n\n#line 7 \"Library/alias.hpp\"\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i32 = int_least32_t;\nusing i64 = int_least64_t;\nusing i128 = __int128_t;\nusing u32 = uint_least32_t;\nusing u64 = uint_least64_t;\nusing u128 = __uint128_t;\ntemplate <class T, class Comp = less<T>>\nusing priority_queue = std::priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, vector<T>>;\nconstexpr i32 clz32(const u32 &n) noexcept { return __builtin_clz(n); }\nconstexpr i32 clz64(const u64 &n) noexcept { return __builtin_clzll(n); }\nconstexpr i32 ctz(const u64 &n) noexcept { return __builtin_ctzll(n); }\nconstexpr i32 popcnt(const u64 &n) noexcept { return __builtin_popcountll(n); }\n}  // namespace workspace\n#line 5 \"Library/config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 2 \"Library/option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library/utils/binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library/utils/casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library/utils/chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 4 \"Library/utils/coordinate_compression.hpp\"\n\ntemplate <class T>\nclass coordinate_compression\n{\n    std::vector<T> uniquely;\n    std::vector<size_t> compressed;\n\npublic:\n    coordinate_compression(const std::vector<T> &raw) : uniquely(raw), compressed(raw.size())\n    {\n        std::sort(uniquely.begin(), uniquely.end());\n        uniquely.erase(std::unique(uniquely.begin(), uniquely.end()), uniquely.end());\n        for(size_t i = 0; i != size(); ++i)\n            compressed[i] = std::lower_bound(uniquely.begin(), uniquely.end(), raw[i]) - uniquely.begin();\n    }\n\n    size_t operator[](const size_t idx) const\n    {\n        assert(idx < size());\n        return compressed[idx];\n    }\n\n    size_t size() const { return compressed.size(); }\n\n    size_t count() const { return uniquely.size(); }\n\n    T value_of(const size_t ord) const\n    {\n        assert(ord < count());\n        return uniquely[ord];\n    }\n\n    size_t order_of(const T &val) const { return std::lower_bound(uniquely.begin(), uniquely.end(), val) - uniquely.begin(); }\n\n    std::vector<size_t>::iterator begin() { return compressed.begin(); }\n    std::vector<size_t>::iterator end() { return compressed.end(); }\n    std::vector<size_t>::reverse_iterator rbegin() { return compressed.rbegin(); }\n    std::vector<size_t>::reverse_iterator rend() { return compressed.rend(); }\n};\n#line 3 \"Library/utils/fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type> class fixed_point {\n  lambda_type func;\n\n public:\n  fixed_point(lambda_type &&f) : func(std::move(f)) {}\n  template <class... Args> auto operator()(Args &&... args) const {\n    return func(*this, std::forward<Args>(args)...);\n  }\n};\n}  // namespace workspace\n#line 6 \"Library/utils/hash.hpp\"\n\n#line 3 \"Library/utils/sfinae.hpp\"\n#include <type_traits>\n\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\n\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n\ntemplate <class T, class = int> struct mapped_of {\n  using type = element_type<T>;\n};\ntemplate <class T>\nstruct mapped_of<T,\n                 typename std::pair<int, typename T::mapped_type>::first_type> {\n  using type = typename T::mapped_type;\n};\ntemplate <class T> using mapped_type = typename mapped_of<T>::type;\n\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#if __cplusplus >= 201402\ntemplate <class T>\nconstexpr static bool is_integral_ext_v = is_integral_ext<T>::value;\n#endif\n\ntemplate <typename T, typename = void> struct multiplicable_uint {\n  using type = uint_least32_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(2 < sizeof(T))>::type> {\n  using type = uint_least64_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(4 < sizeof(T))>::type> {\n  using type = __uint128_t;\n};\n#line 8 \"Library/utils/hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void> struct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type,\n            enable_if_trait_type<Unique_bits_type,\n                                 std::has_unique_object_representations>> {\n  size_t operator()(uint64_t x) const {\n    static const uint64_t m = std::random_device{}();\n    x ^= x >> 23;\n    x ^= m;\n    x ^= x >> 47;\n    return x - (x >> 32);\n  }\n};\ntemplate <class Key> size_t hash_combine(const size_t &seed, const Key &key) {\n  return seed ^\n         (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */);\n}\ntemplate <class T1, class T2> struct hash<std::pair<T1, T2>> {\n  size_t operator()(const std::pair<T1, T2> &pair) const {\n    return hash_combine(hash<T1>()(pair.first), pair.second);\n  }\n};\ntemplate <class... T> class hash<std::tuple<T...>> {\n  template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1>\n  struct tuple_hash {\n    static uint64_t apply(const Tuple &t) {\n      return hash_combine(tuple_hash<Tuple, index - 1>::apply(t),\n                          std::get<index>(t));\n    }\n  };\n  template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> {\n    static uint64_t apply(const Tuple &t) { return 0; }\n  };\n\n public:\n  uint64_t operator()(const std::tuple<T...> &t) const {\n    return tuple_hash<std::tuple<T...>>::apply(t);\n  }\n};\ntemplate <class hash_table> struct hash_table_wrapper : hash_table {\n  using key_type = typename hash_table::key_type;\n  size_t count(const key_type &key) const {\n    return hash_table::find(key) != hash_table::end();\n  }\n  template <class... Args> auto emplace(Args &&... args) {\n    return hash_table::insert(typename hash_table::value_type(args...));\n  }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table =\n    hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table =\n    hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key> using unordered_set = std::unordered_set<Key, hash<Key>>;\n}  // namespace workspace\n#line 3 \"Library/utils/make_vector.hpp\"\nnamespace workspace {\ntemplate <typename T, size_t N>\nconstexpr auto make_vector(size_t* sizes, T const& init = T()) {\n  if constexpr (N)\n    return std::vector(*sizes, make_vector<T, N - 1>(std::next(sizes), init));\n  else\n    return init;\n}\ntemplate <typename T, size_t N>\nconstexpr auto make_vector(const size_t (&sizes)[N], T const& init = T()) {\n  return make_vector<T, N>((size_t*)sizes, init);\n}\n}  // namespace workspace\n#line 3 \"Library/utils/random_number_generator.hpp\"\ntemplate <typename num_t>\nclass random_number_generator\n{\n    template <bool is_int, class = void>\n    struct unif_t\n    {\n        std::uniform_int_distribution<num_t> unif;\n        unif_t(num_t lower, num_t upper) : unif(lower, upper) {}\n        num_t operator()(std::mt19937 &engine) { return unif(engine); }\n    };\n    template <class void_t>\n    struct unif_t<false, void_t>\n    {\n        std::uniform_real_distribution<num_t> unif;\n        unif_t(num_t lower, num_t upper) : unif(lower, upper) {}\n        num_t operator()(std::mt19937 &engine) { return unif(engine); }\n    };\n    unif_t<std::is_integral<num_t>::value> unif;\n    std::mt19937 engine;\n  public:\n    // generate random number in [lower, upper].\n    random_number_generator(num_t lower = std::numeric_limits<num_t>::min(), num_t upper = std::numeric_limits<num_t>::max()) : unif(lower, upper), engine(std::random_device{}()) {}\n    num_t operator()() { return unif(engine); }\n}; // class random_number_generator\n#line 3 \"Library/utils/read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library/utils/stream.hpp\"\n\n#line 6 \"Library/utils/stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 4 \"Library/utils/trinary_search.hpp\"\n// trinary search on discrete range.\ntemplate <class iter_type, class comp_type>\niter_type trinary(iter_type first, iter_type last, comp_type comp)\n{\n    assert(first < last);\n    intmax_t dist(last - first);\n    while(dist > 2)\n    {\n        iter_type left(first + dist / 3), right(first + dist * 2 / 3);\n        if(comp(left, right)) last = right, dist = dist * 2 / 3;\n        else first = left, dist -= dist / 3;\n    }\n    if(dist > 1 && comp(first + 1, first)) ++first;\n    return first;\n}\n// trinary search on real numbers.\ntemplate <class comp_type>\nlong double trinary(long double first, long double last, const long double eps, comp_type comp)\n{\n    assert(first < last);\n    while(last - first > eps)\n    {\n        long double left{(first * 2 + last) / 3}, right{(first + last * 2) / 3};\n        if(comp(left, right)) last = right;\n        else first = left;\n    }\n    return first;\n}\n#line 2 \"Library/utils/wrapper.hpp\"\ntemplate <class Container> class reversed {\n  Container &ref, copy;\n\n public:\n  reversed(Container &ref) : ref(ref) {}\n  reversed(Container &&ref = Container()) : ref(copy), copy(ref) {}\n  auto begin() const { return ref.rbegin(); }\n  auto end() const { return ref.rend(); }\n};\n#line 7 \"atcoder-workspace/acl1/e/e.cpp\"\nnamespace workspace {\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // unspecified\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library/data_structure/segment_tree/basic.hpp\"\n\n#line 3 \"Library/algebra/system/monoid.hpp\"\ntemplate <class T> struct min_monoid {\n  using value_type = T;\n  static T min, max;\n  T value;\n  min_monoid() : value(max) {}\n  min_monoid(const T &value) : value(value) {}\n  operator T() const { return value; }\n  min_monoid operator+(const min_monoid &rhs) const {\n    return value < rhs.value ? *this : rhs;\n  }\n};\ntemplate <class T> T min_monoid<T>::min = std::numeric_limits<T>::min();\ntemplate <class T> T min_monoid<T>::max = std::numeric_limits<T>::max();\ntemplate <class T> struct max_monoid : min_monoid<T> {\n  using base = min_monoid<T>;\n  using base::min_monoid;\n  max_monoid() : base(base::min) {}\n  max_monoid operator+(const max_monoid &rhs) const {\n    return !(base::value < rhs.value) ? *this : rhs;\n  }\n};\n#line 7 \"Library/data_structure/segment_tree/basic.hpp\"\ntemplate <class Monoid, class Container = std::vector<Monoid>>\nclass segment_tree {\n  static_assert(std::is_same<Monoid, mapped_type<Container>>::value);\n\n  class unique_queue {\n    size_t *que, *begin, *end;\n    bool *in;\n\n   public:\n    unique_queue(size_t n)\n        : que(new size_t[n]), begin(que), end(que), in(new bool[n]{}) {}\n    ~unique_queue() {\n      delete[] que;\n      delete[] in;\n    }\n    void clear() { begin = end = que; }\n    bool empty() const { return begin == end; }\n    bool push(size_t index) {\n      if (in[index]) return false;\n      return in[*end++ = index] = true;\n    }\n    size_t pop() { return in[*begin] = false, *begin++; }\n  };  // struct unique_queue\n\n  size_t size_orig, height, size_ext;\n  Container data;\n  unique_queue que;\n\n  void recalc(const size_t node) {\n    data[node] = data[node << 1] + data[node << 1 | 1];\n  }\n\n  void repair() {\n    while (!que.empty()) {\n      const size_t index = que.pop() >> 1;\n      if (index && que.push(index)) recalc(index);\n    }\n    que.clear();\n  }\n\n  template <class Pred>\n  size_t left_search_subtree(size_t index, const Pred pred, Monoid mono) const {\n    assert(index);\n    while (index < size_ext) {\n      const Monoid tmp = data[(index <<= 1) | 1] + mono;\n      if (pred(tmp))\n        mono = tmp;\n      else\n        ++index;\n    }\n    return ++index -= size_ext;\n  }\n\n  template <class Pred>\n  size_t right_search_subtree(size_t index, const Pred pred,\n                              Monoid mono) const {\n    assert(index);\n    while (index < size_ext) {\n      const Monoid tmp = mono + data[index <<= 1];\n      if (pred(tmp)) ++index, mono = tmp;\n    }\n    return (index -= size_ext) < size_orig ? index : size_orig;\n  }\n\n public:\n  using value_type = Monoid;\n\n  segment_tree(const size_t n = 0)\n      : size_orig{n},\n        height(n > 1 ? 32 - __builtin_clz(n - 1) : 0),\n        size_ext{1u << height},\n        data(size_ext << 1),\n        que(size_ext << 1) {}\n\n  segment_tree(const size_t n, const Monoid &init) : segment_tree(n) {\n    std::fill(std::next(std::begin(data), size_ext), std::end(data), init);\n    for (size_t i{size_ext}; --i;) recalc(i);\n  }\n\n  template <class iter_type, class value_type = typename std::iterator_traits<\n                                 iter_type>::value_type>\n  segment_tree(iter_type first, iter_type last)\n      : size_orig(std::distance(first, last)),\n        height(size_orig > 1 ? 32 - __builtin_clz(size_orig - 1) : 0),\n        size_ext{1u << height},\n        data(size_ext << 1),\n        que(size_ext << 1) {\n    static_assert(std::is_constructible<Monoid, value_type>::value,\n                  \"Monoid(iter_type::value_type) is not constructible.\");\n    for (auto iter{std::next(std::begin(data), size_ext)};\n         iter != std::end(data) && first != last; ++iter, ++first)\n      *iter = Monoid{*first};\n    for (size_t i{size_ext}; --i;) recalc(i);\n  }\n\n  template <class Cont, typename = typename Cont::value_type>\n  segment_tree(const Cont &cont)\n      : segment_tree(std::begin(cont), std::end(cont)) {}\n\n  size_t size() const { return size_orig; }\n  size_t capacity() const { return size_ext; }\n\n  // reference to the element at the index.\n  Monoid &operator[](size_t index) {\n    assert(index < size_orig);\n    que.push(index |= size_ext);\n    return data[index];\n  }\n\n  // const reference to the element at the index.\n  const Monoid &operator[](size_t index) const {\n    assert(index < size_orig);\n    return data[index |= size_orig];\n  }\n\n  Monoid fold(size_t first, size_t last) {\n    assert(last <= size_orig);\n    repair();\n    Monoid leftval{}, rightval{};\n    first += size_ext, last += size_ext;\n    while (first < last) {\n      if (first & 1) leftval = leftval + data[first++];\n      if (last & 1) rightval = data[--last] + rightval;\n      first >>= 1, last >>= 1;\n    }\n    return leftval + rightval;\n  }\n\n  Monoid fold() { return fold(0, size_orig); }\n\n  template <class Pred> size_t left_search(size_t right, Pred pred) {\n    assert(right <= size_orig);\n    repair();\n    right += size_ext;\n    Monoid mono{};\n    for (size_t left{size_ext}; left != right; left >>= 1, right >>= 1) {\n      if ((left & 1) != (right & 1)) {\n        const Monoid tmp = data[--right] + mono;\n        if (!pred(tmp)) return left_search_subtree(right, pred, mono);\n        mono = tmp;\n      }\n    }\n    return 0;\n  }\n\n  template <class Pred> size_t right_search(size_t left, Pred pred) {\n    assert(left <= size_orig);\n    repair();\n    left += size_ext;\n    Monoid mono{};\n    for (size_t right{size_ext << 1}; left != right; left >>= 1, right >>= 1) {\n      if ((left & 1) != (right & 1)) {\n        const Monoid tmp = mono + data[left];\n        if (!pred(tmp)) return right_search_subtree(left, pred, mono);\n        mono = tmp;\n        ++left;\n      }\n    }\n    return size_orig;\n  }\n};  // class segment_tree\n#line 4 \"Library/modulus/modint.hpp\"\n\n#line 6 \"Library/modulus/modint.hpp\"\n\ntemplate <auto Mod = 0, typename Mod_type = decltype(Mod)> struct modint {\n  static_assert(is_integral_ext<decltype(Mod)>::value,\n                \"Mod must be integral type.\");\n  static_assert(!(Mod < 0), \"Mod must be non-negative.\");\n\n  using mod_type = typename std::conditional<\n      Mod != 0, typename std::add_const<Mod_type>::type, Mod_type>::type;\n  static mod_type mod;\n\n  using value_type = typename std::decay<mod_type>::type;\n\n  constexpr operator value_type() const noexcept { return value; }\n\n  constexpr static modint one() noexcept { return 1; }\n\n  constexpr modint() noexcept = default;\n\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n\n  constexpr modint(bool n) noexcept : modint(int(n)) {}\n\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (typename multiplicable_uint<value_type>::type)value *\n                   rhs.value % mod,\n           *this;\n  }\n\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      power(int_type e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    for (modint p{value}; e; e >>= 1, p *= p) {\n      if (e & 1) res *= p;\n    }\n    return res;\n  }\n\n  template <class int_type>\n  friend constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      pow(modint b, int_type e) noexcept {\n    modint res{1};\n    for ((e %= mod - 1) < 0 ? e += mod - 1 : 0; e; e >>= 1, b *= b)\n      if (e & 1) res *= b;\n    return res;\n  }\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    intmax_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\n\ntemplate <auto Mod, typename Mod_type>\ntypename modint<Mod, Mod_type>::mod_type modint<Mod, Mod_type>::mod = Mod;\n\nusing modint_runtime = modint<0>;\n#line 19 \"atcoder-workspace/acl1/e/e.cpp\"\n\nstruct workspace::solver {\n  using mint = modint<998244353>;\n\n  solver() {\n    // start here!\n    int n, k;\n    cin >> n >> k;\n    segment_tree<mint> seg(n);\n    segment_tree<int> seg2(n);\n    auto r = mint(k - 1) / k;\n    auto ir = r.inverse();\n    mint rp = 1, irp = pow(ir, k - 1);\n    mint ans;\n    for (auto i = 0; i < n; ++i) {\n      int p;\n      cin >> p;\n      p--;\n      if (i >= k) {\n        ans += seg2.fold(p, n) - rp * seg.fold(p, n);\n        irp *= ir;\n      }\n      seg[p] = irp;\n      seg2[p] = 1;\n      ans += mint(min<int>(k - 1, i)) / 2;\n      rp *= r;\n    }\n    cout << ans << eol;\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n#define cauto const auto\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\ntemplate<class A,class B> pair<A,B> operator+(const pair<A,B> &p,const pair<A,B> &q){ return {p.X+q.X,p.Y+q.Y};}\ntemplate<class A,class B,class C,class D> pair<A,B>& operator+=(pair<A,B> &p,const pair<C,D> &q){ p.X+=q.X; p.Y+=q.Y; return p;}\ntemplate<class A,class B> pair<A,B> operator-(const pair<A,B> &p,const pair<A,B> &q){ return {p.X-q.X,p.Y-q.Y};}\ntemplate<class A,class B,class C,class D> pair<A,B>& operator-=(pair<A,B> &p,const pair<C,D> &q){ p.X-=q.X; p.Y-=q.Y; return p;}\ntemplate<class A,class B> istream& operator>>(istream &is, pair<A,B> &p){ is>>p.X>>p.Y; return is;}\ntemplate<class T=ll> T read(){ T re; cin>>re; return move(re);}\ntemplate<class T=ll> T read(const T &dec){ T re; cin>>re; return re-dec;}\ntemplate<class T=ll> vector<T> readV(const int sz){ vector<T> re(sz); for(auto &x:re) x=read<T>(); return move(re);}\ntemplate<class T=ll> vector<T> readV(const int sz, const T &dec){ vector<T> re(sz); for(auto &x:re) x=read<T>(dec); return move(re);}\nvv<int> readG(const int &n,const int &m){ vv<int> g(n); rep(_,m){ cauto a=read<int>(1),b=read<int>(1); g[a].pb(b); g[b].pb(a);} return move(g);}\nvv<int> readG(const int &n){ return readG(n,n-1);}\nconst ll MOD=998244353;\n\nll modpow_(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct ModInt{\n  int v;\n  ModInt(int v=0):v(v){}\n  ModInt operator+(const ModInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  ModInt operator-(const ModInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  ModInt operator*(const ModInt &n)const{return ll(v)*n.v%mod;}\n  ModInt operator/(const ModInt &n)const{return ll(v)*modpow_(n.v%mod,-1,mod)%mod;}\n  ModInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  ModInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  ModInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  ModInt operator/(const ll &n)const{return ll(v)*modpow_(n%mod,-1,mod)%mod;}\n  ModInt& operator+=(const ModInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  ModInt& operator-=(const ModInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  ModInt& operator*=(const ModInt &n){v=ll(v)*n.v%mod; return *this;}\n  ModInt& operator/=(const ModInt &n){v=ll(v)*modpow_(n.v,-1,mod)%mod; return *this;}\n  ModInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  ModInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  ModInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  ModInt& operator/=(const ll &n){v=ll(v)*modpow_(n,-1,mod)%mod; return *this;}\n\tbool operator==(const ModInt &n)const{return v==n.v;};\n\tbool operator!=(const ModInt &n)const{return v!=n.v;};\n\tModInt& operator++(){ return operator+=(1); }\n\tModInt& operator--(){ return operator-=(1); }\n\tModInt operator++(int i){ ModInt tmp(*this); operator++(); return tmp; }\n\tModInt operator--(int i){ ModInt tmp(*this); operator--(); return tmp; }\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow_(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow_(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const ModInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const ModInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> ModInt<mod> operator+(const ll &n,const ModInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> ModInt<mod> operator-(const ll &n,const ModInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> ModInt<mod> operator*(const ll &n,const ModInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> ModInt<mod> operator/(const ll &n,const ModInt<mod> &m){return ModInt<mod>(n%mod)/m;}\ntypedef ModInt<MOD> mint;\ntemplate <int mod> ModInt<mod> modpow(ModInt<mod> r,ll n){ ModInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(1123456);\nusing pmm=pair<mint,mint>;\nmint modpow(ll r,ll n){ return modpow_(r,n);}\n\nconst int nn=112345;\nmint bit[nn+1];\nint cnts[nn+1];\n\npair<mint,int> sum(int i){ ++i;\n\tmint s=0;\n\tint c=0;\n  while(i>0){\n    s+=bit[i];\n\t\tc+=cnts[i];\n    i-=i&-i;\n  }\n  return {s,c};\n}\n\nvoid add(int i,mint x){ ++i; ++i;\n  while(i<=nn){\n    bit[i]+=x;\n\t\tcnts[i]+=1;\n    i+=i&-i;\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tcauto n=read();\n\tcauto w=read();\n\tcauto p=readV(n,1);\n\tvector<int> ind(n); iota(all(ind),0);\n\tsort(all(ind),[&](cauto i,cauto j){return p[i]<p[j];});\n\tvector<int> ts(n);\n\trep(i,n) ts[i]=max<int>(0,i-(w-1));\n\tout(ts,1);\n\tmint re=0;\n\tmint rem=(w-1)*inv[w];\n\tvector<mint> pw(n+1); pw[0]=1;\n\trep(i,n) pw[i+1]=pw[i]*rem;\n\tvector<mint> sums(n);\n\trreps(i,1,n) sums[i-1]=sums[i]+pw[ts[i]];\n\tfor(cauto i:ind){\n\t\tmint div=inv[2]/pw[ts[i]];\n\t\tcauto [lt,c]=sum(n)-sum(i);\n\t\tmint gt=sums[i]-lt;\n\t\tout(i,c,lt,gt,div,1);\n\t\tre+=c-lt*div;\n\t\tre+=gt*div;\n\t\tadd(i,pw[ts[i]]);\n\t\t// reps(j,i+1,n){\n\t\t// \tmint prob=pw[ts[j]-ts[i]]*inv[2];\n\t\t// \tout(i,j,ts[j]-ts[i],prob,1);\n\t\t// \tif(p[i]>p[j]){\n\t\t// \t\tre+=1-prob;\n\t\t// \t}else{\n\t\t// \t\tre+=prob;\n\t\t// \t}\n\t\t// }\n\t}\n\tcout<<re NL;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 2 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/other/template.hpp\"\n#define _CRT_SECURE_NO_WARNINGS\n#pragma target(\"avx2\")\n#pragma optimize(\"O3\")\n#pragma optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef unsigned int uint;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef std::pair<int, int> P;\ntypedef std::pair<lint, lint> LP;\nconstexpr int INF = INT_MAX/2;\nconstexpr lint LINF = LLONG_MAX/2;\nconstexpr double eps = DBL_EPSILON;\nconstexpr double PI=3.141592653589793238462643383279;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\ntemplate<typename T>\nT mypow(T a, lint b) {\n\tT res(1);\n\twhile(b){\n\t\tif(b&1)res*=a;\n\t\ta*=a;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nlint modpow(lint a, lint b, lint m) {\n\tlint res(1);\n\twhile(b){\n\t\tif(b&1){\n\t\t\tres*=a;res%=m;\n\t\t}\n\t\ta*=a;a%=m;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size()){\n\t\tstd::cout << vec[i];\n\t\tstd::cout<<(i==(int)vec.size()-1?\"\\n\":\" \");\n\t}\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = std::prev(r);\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nLP extGcd(lint a,lint b) {\n\tif(b==0)return {1,0};\n\tLP s=extGcd(b,a%b);\n\tstd::swap(s.first,s.second);\n\ts.second-=a/b*s.first;\n\treturn s;\n}\nLP ChineseRem(const lint& b1,const lint& m1,const lint& b2,const lint& m2) {\n\tlint p=extGcd(m1,m2).first;\n\tlint tmp=(b2-b1)*p%m2;\n\tlint r=(b1+m1*tmp+m1*m2)%(m1*m2);\n\treturn std::make_pair(r,m1*m2);\n}\ntemplate<typename F>\ninline constexpr decltype(auto) lambda_fix(F&& f){\n\treturn [f=std::forward<F>(f)](auto&&... args){\n\t\treturn f(f,std::forward<decltype(args)>(args)...);\n\t};\n}\n#line 3 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/algebraic/DynamicModInt.hpp\"\nclass DynamicModInt {\n\tlint value;\npublic:\n\tstatic unsigned int modulo;\n\tDynamicModInt() : value(0) {}\n\ttemplate<typename T>\n\tDynamicModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tstatic inline void setMod(const unsigned int& mod){modulo=mod;}\n\tinline DynamicModInt inv()const{return mypow(*this,modulo-2);}\n\tinline operator int()const { return value; }\n\tinline DynamicModInt& operator+=(const DynamicModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt operator++(int){\n\t\tDynamicModInt res=*this;\n\t\t--*this;\n\t\treturn res;\n\t}\n\tinline DynamicModInt operator-()const {\n\t\treturn DynamicModInt(0) -= *this;\n\t}\n\tinline DynamicModInt& operator-=(const DynamicModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt operator--(int){\n\t\tDynamicModInt res=*this;\n\t\t--*this;\n\t\treturn res;\n\t}\n\tinline DynamicModInt& operator*=(const DynamicModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline DynamicModInt& operator/=(const DynamicModInt& rhs) {\n\t\treturn *this*=rhs.inv();\n\t}\n\ttemplate<typename T> DynamicModInt operator+(const T& rhs)const { return DynamicModInt(*this) += rhs; }\n\ttemplate<typename T> DynamicModInt& operator+=(const T& rhs) { return operator+=(DynamicModInt(rhs)); }\n\ttemplate<typename T> DynamicModInt operator-(const T& rhs)const { return DynamicModInt(*this) -= rhs; }\n\ttemplate<typename T> DynamicModInt& operator-=(const T& rhs) { return operator-=(DynamicModInt(rhs)); }\n\ttemplate<typename T> DynamicModInt operator*(const T& rhs)const { return DynamicModInt(*this) *= rhs; }\n\ttemplate<typename T> DynamicModInt& operator*=(const T& rhs) { return operator*=(DynamicModInt(rhs)); }\n\ttemplate<typename T> DynamicModInt operator/(const T& rhs)const { return DynamicModInt(*this) /= rhs; }\n\ttemplate<typename T> DynamicModInt& operator/=(const T& rhs) { return operator/=(DynamicModInt(rhs)); }\n};\nunsigned int DynamicModInt::modulo=1000000007;\nstd::istream& operator>>(std::istream& ist, DynamicModInt& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\n#line 4 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/algebraic/StaticModInt.hpp\"\ntemplate<unsigned int modulo>\nclass StaticModInt {\n\tlint value;\npublic:\n\tStaticModInt() : value(0) {}\n\ttemplate<typename T>\n\tStaticModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline StaticModInt inv()const{return mypow(*this,modulo-2);}\n\tinline operator int()const { return value; }\n\tinline StaticModInt& operator+=(const StaticModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline StaticModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline StaticModInt operator++(int){\n\t\tStaticModInt res=*this;\n\t\t--*this;\n\t\treturn res;\n\t}\n\tinline StaticModInt operator-()const {\n\t\treturn StaticModInt(0) -= *this;\n\t}\n\tinline StaticModInt& operator-=(const StaticModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline StaticModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline StaticModInt operator--(int){\n\t\tStaticModInt res=*this;\n\t\t--*this;\n\t\treturn res;\n\t}\n\tinline StaticModInt& operator*=(const StaticModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline StaticModInt& operator/=(const StaticModInt& rhs) {\n\t\treturn *this*=rhs.inv();\n\t}\n\ttemplate<typename T> StaticModInt operator+(const T& rhs)const { return StaticModInt(*this) += rhs; }\n\ttemplate<typename T> StaticModInt& operator+=(const T& rhs) { return operator+=(StaticModInt(rhs)); }\n\ttemplate<typename T> StaticModInt operator-(const T& rhs)const { return StaticModInt(*this) -= rhs; }\n\ttemplate<typename T> StaticModInt& operator-=(const T& rhs) { return operator-=(StaticModInt(rhs)); }\n\ttemplate<typename T> StaticModInt operator*(const T& rhs)const { return StaticModInt(*this) *= rhs; }\n\ttemplate<typename T> StaticModInt& operator*=(const T& rhs) { return operator*=(StaticModInt(rhs)); }\n\ttemplate<typename T> StaticModInt operator/(const T& rhs)const { return StaticModInt(*this) /= rhs; }\n\ttemplate<typename T> StaticModInt& operator/=(const T& rhs) { return operator/=(StaticModInt(rhs)); }\n};\ntemplate<unsigned int modulo>\nstd::istream& operator>>(std::istream& ist, StaticModInt<modulo>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\n#line 3 \"/Users/kaage/Desktop/ProgrammingWorkspace/library/data-structure/BIT.hpp\"\ntemplate<typename T>\nclass BIT {\n\tint n;\n\tstd::vector<T> bit;\nprivate:\n\tT query(int a) {\n\t\tT cnt = 0;\n\t\twhile (a > 0) {\n\t\t\tcnt += bit[a];\n\t\t\ta -= a & -a;\n\t\t}\n\t\treturn cnt;\n\t}\npublic:\n\tBIT(int n) :n(n) {bit.resize(n + 1);}\n\tvoid add(int a, T x) {\n\t\ta++;\n\t\twhile (a <= n) {\n\t\t\tbit[a] += x;\n\t\t\ta += a & -a;\n\t\t}\n\t}\n\tT query(int l, int r) {return query(r) - query(l);}\n\tvoid clear() {bit.assign(n + 1, 0);}\n\tint lower_bound(T x){\n\t\tint p=0,k=1;\n\t\twhile(k*2<=n)k*=2;\n\t\twhile(k>0){\n\t\t\tif(p+k<=n&&bit[p+k]<x){\n\t\t\t\tx-=bit[p+k];\n\t\t\t\tp+=k;\n\t\t\t}\n\t\t\tk/=2;\n\t\t}\n\t\treturn p;\n\t}\n\tint upper_bound(T x){\n\t\tint p=0,k=1;\n\t\twhile(k*2<=n)k*=2;\n\t\twhile(k>0){\n\t\t\tif(p+k<=n&&bit[p+k]<=x){\n\t\t\t\tx-=bit[p+k];\n\t\t\t\tp+=k;\n\t\t\t}\n\t\t\tk/=2;\n\t\t}\n\t\treturn p;\n\t}\n};\n#line 4 \"main.cpp\"\nusing ModInt=StaticModInt<998244353>;\nint N,K,p[200010];\nint main(){\n\tstd::cin>>N>>K;\n\trep(i,N)std::cin>>p[i];\n\tModInt ans=ModInt(K)*(K-1)/4;\n\n\tstd::vector<int> vec(N+1);\n\trep(i,K)vec[p[i]]++;\n\tREP(i,N)vec[i]+=vec[i-1];\n\tModInt co=ModInt(K-1)/K,now=co;\n\tfor(int i=K;i<N;i++){\n\t\tans+=ModInt(1-now/2)*(vec[N]-vec[p[i]]);\n\t\tans+=now/2*vec[p[i]];\n\t\tnow*=co;\n\t}\n\n\tBIT<ModInt> bit1(N+1),bit2(N+1);\n\tnow=mypow(co,K);\n\tModInt co2=ModInt(1)/co,now2=mypow(co2,K)/2;\n\tfor(int i=K;i<N;i++){\n\t\tans+=bit1.query(0,p[i])*now;\n\t\tans+=bit2.query(p[i],N+1)*now;\n\t\tbit1.add(p[i],now2);\n\t\tbit2.add(p[i],-now2);\n\t\tnow*=co;now2*=co2;\n\t}\n\n\tbit1.clear();\n\tfor(int i=K;i<N;i++){\n\t\tans+=bit1.query(p[i],N+1);\n\t\tbit1.add(p[i],1);\n\t}\n\tstd::cout<<ans<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cerr<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\nint getInt(){int x;scanf(\"%d\",&x);return x;}\ntemplate<typename T>istream& operator>>(istream&i,v(T)&v){rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v){stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,const v(T)&v){if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v){return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,const pair<T1,T2>&v){return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>bool mins(T& x,const T&y){if(x>y){x=y;return true;}else return false;}\ntemplate<typename T>bool maxs(T& x,const T&y){if(x<y){x=y;return true;}else return false;}\ntemplate<typename T>ll suma(const v(T)&a){ll res(0);for(auto&&x:a)res+=x;return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n#include <atcoder/all>\nusing namespace atcoder;\nusing mint = modint998244353;\n\n\nint main() {\n  int n,w;\n  scanf(\"%d%d\",&n,&w);\n  vi a(n);\n  cin>>a;\n  rep(i,n) a[i]--;\n  fenwick_tree<int> ts(n);\n  fenwick_tree<mint> t(n);\n  mint e, es, x = 1;\n  mint p = mint(w-1)/w;\n  rep(i,n) {\n    if (i >= w) {\n      x *= p;\n      e += ts.sum(a[i],n) - x*t.sum(a[i],n);\n      es += ts.sum(0,n) - x*t.sum(0,n);\n    }\n\n    ts.add(a[i],1);\n    t.add(a[i],1/x);\n  }\n\n  mint ans = mint(n)*(n-1)/2;\n  ans -= es;\n  ans = ans/2 + e;\n  cout<<ans.val()<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int P = 998244353; int poww(long long a , int b){int tms = 1; while(b){if(b & 1) tms = tms * a % P; a = a * a % P; b >>= 1;} return tms;}\nint pot[200003] , N , K;\n#define lowbit(x) ((x) & -(x))\nstruct bit{\n\tint arr[200003];\n\tvoid add(int x , int v){while(x <= N){arr[x] = (arr[x] + v) % P; x += lowbit(x);}}\n\tint qry(int x){int sum = 0; while(x){sum = (sum + arr[x]) % P; x -= lowbit(x);} return sum;}\n}sum1 , sum2;\n\nint main(){\n\tint ans = 0; cin >> N >> K; for(int i = 1 ; i <= N ; ++i) cin >> pot[i];\n\tint lft1 = 1ll * (K - 1) * poww(K , P - 2) % P , lft2 = 1ll * (K - 2) * poww(K , P - 2) % P;\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\tint p1 = sum1.qry(pot[i]) , p2 = i - 1 - sum1.qry(pot[i]) , r2 = max(i - K , 0);\n\t\tint q1 = sum2.qry(pot[i]) , q2 = (sum2.qry(N) - sum2.qry(pot[i]) + P) % P;\n\t\tsum1.add(pot[i] , 1); sum2.add(pot[i] , poww(lft1 , P - 1 - r2)); ans = (ans + p2 - 1ll * q2 * poww(lft1 , r2)) % P;\n\n\t\tint prob = 1ll * (q1 + q2) * poww(lft1 , r2) % P;\n\t\tans = (ans + 1ll * prob * (P + 1 - lft1) % P * (P + 1 - poww(lft2 , N - K - r2)) % P * poww(P + 1 - lft2 , P - 2)) % P;\n\t\tans = (ans + 1ll * prob * poww(lft2 , N - K - r2) % P * (P + 1) / 2) % P;\n\t}\n\tcout << ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing mint = atcoder::modint998244353;\nstruct S {\n    mint val;\n    int sz;\n};\nstruct F {\n    mint a, b;\n};\nS e() {\n    return {mint(0), 0};\n}\n\nS mapping(F f, S x) {\n    x.val = x.val * f.a + f.b * x.sz;\n    return x;\n}\n\nF composition(F l, F r) {\n    return {r.a * l.a, r.b * l.a + l.b};\n}\n\nF id() {\n    return {1, 0};\n}\n\nS op(S a, S b) {\n    return {a.val + b.val, a.sz + b.sz};\n}\nll N, K;\nll p[201000];\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<int> node;\n \npublic:\n    SegmentTree() {\n        int sz = 201000;\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = 0;\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n \n    void update(int x, int val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = (node[2*x+1] + node[2*x+2]);\n        }\n    }\n    // hannkaikukann \n    int getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return node[k];\n \n        int vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        int vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr);\n    }\n};\n\nconst ll mod = 998244353;\nll beki(ll a, ll b){\n    a %= mod;\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> K;\n    for(int i = 0; i < N; i++) {\n        cin >> p[i];\n        p[i]--;\n    }\n    vector<S> a(N);\n    for(int i = 0; i < N; i++) {\n        a[i].val = mint(1);\n        a[i].sz = 1;\n    }\n    ll Kinv = beki(K, mod - 2);\n    atcoder::lazy_segtree<S, op, e, F, mapping, composition, id> seg(a);\n    SegmentTree segnum;\n    for(int i = 0; i < N; i++) {\n        segnum.update(i, 1);\n    }\n    for(int i = 0; i < K; i++) {\n        seg.apply(p[i], {0, Kinv});\n        segnum.update(p[i], 0);\n    }\n    ll one = 0;\n    ll zero = 0;\n    for(int i = K; i < N; i++) {\n        /*\n        cerr << \"-----\" << i << \"------\" << endl;\n        for(int i = 0; i < N; i++) {\n            cerr << seg.prod(i, i + 1).val.val() << \" \";\n        }\n        cerr << endl;\n        */\n        ll tmpone = seg.prod(p[i], N).val.val();\n        tmpone += mod - segnum.getsum(p[i], N);\n        one += tmpone;\n        ll tmpzero = seg.prod(0, p[i]).val.val();\n        tmpzero += mod - segnum.getsum(0, p[i]);\n        tmpzero %= mod;\n        tmpone %= mod;\n        zero += tmpzero;\n        //cerr << i << \" \" << tmpzero << \" \" << tmpone << endl;\n        one %= mod;\n        zero %= mod;\n        seg.apply(0, N, {(K - 1) * Kinv % mod, Kinv});\n        seg.apply(p[i], {0, Kinv});\n        segnum.update(p[i], 0);\n    }\n    ll total = N * (N - 1) / 2;\n    ll rest = total - zero - one + 2 * mod;\n    rest %= mod;\n    //cerr << zero << \" \" << one << \" \" << rest << endl; \n    ll ans = one + rest * beki(2, mod - 2);\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\nconst char newl = '\\n';\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntemplate<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}\ntemplate<typename T=int>\nvector<T> read(size_t n){\n  vector<T> ts(n);\n  for(size_t i=0;i<n;i++) cin>>ts[i];\n  return ts;\n}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename T>\nclass BIT{\nprivate:\n  // \\sum_{j < i}  v[j]\n  T sum(int i){\n    T s(0);\n    for(int x=i;x>0;x-=(x&-x))\n      s+=bit[x];\n    return s;\n  }\npublic:\n  int n;\n  vector<T> bit;\n  BIT(int n_):n(n_+1),bit(n+1,0){}\n\n  // v[i] += a\n  void add(int i,T a){\n    for(int x=++i;x<=n;x+=(x&-x))\n      bit[x]+=a;\n  }\n  // \\sum_{l <= i < r} v[i]\n  T query(int l,int r){return sum(r)-sum(l);}\n\n  // min({x | sum(x) >= w})\n  int lower_bound(const T w){\n    if(w<=0) return 0;\n    T r=w;\n    int x=0,p=1;\n    while(p<n) p<<=1;\n    for(int k=p;k>0;k>>=1){\n      if(x+k<=n&&bit[x+k]<r){\n        r-=bit[x+k];\n        x+=k;\n      }\n    }\n    x++;\n    assert(sum(x-1)<w and sum(x)>=w);\n    return x;\n  }\n\n  // min({x | sum(x) > w})\n  int upper_bound(T w){return lower_bound(w+1);}\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n,k;\n  cin>>n>>k;\n  auto ps=read(n);\n  // for(int &p:ps) p--;\n\n  using M = Mint<int, 998244353>;\n\n  M ans=M(k*(k-1)/2)/M(2);\n\n  BIT<M> bit(n+10),cnt(n+10);\n  for(int i=0;i<k;i++){\n    int p=ps[i];\n    bit.add(p,M(1));\n    cnt.add(p,M(1));\n  }\n\n  // assert(n!=k);\n\n  M ofs{1};\n  M ratio=M(k-1)/M(k);\n  for(int i=k;i<n;i++){\n    ofs*=ratio;\n    int p=ps[i];\n    ans+=(bit.query(0,n+10)*ofs)/M(2);\n    ans+=(cnt.query(p,n+10)-bit.query(p,n+10)*ofs);\n    bit.add(p,M(1)/ofs);\n    cnt.add(p,M(1));\n  }\n\n  cout<<ans<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\nconst char newl = '\\n';\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntemplate<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}\ntemplate<typename T=int>\nvector<T> read(size_t n){\n  vector<T> ts(n);\n  for(size_t i=0;i<n;i++) cin>>ts[i];\n  return ts;\n}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename T>\nclass BIT{\nprivate:\n  // \\sum_{j < i}  v[j]\n  T sum(int i){\n    T s(0);\n    for(int x=i;x>0;x-=(x&-x))\n      s+=bit[x];\n    return s;\n  }\npublic:\n  int n;\n  vector<T> bit;\n  BIT(int n_):n(n_+1),bit(n+1,0){}\n\n  // v[i] += a\n  void add(int i,T a){\n    for(int x=++i;x<=n;x+=(x&-x))\n      bit[x]+=a;\n  }\n  // \\sum_{l <= i < r} v[i]\n  T query(int l,int r){return sum(r)-sum(l);}\n\n  // min({x | sum(x) >= w})\n  int lower_bound(const T w){\n    if(w<=0) return 0;\n    T r=w;\n    int x=0,p=1;\n    while(p<n) p<<=1;\n    for(int k=p;k>0;k>>=1){\n      if(x+k<=n&&bit[x+k]<r){\n        r-=bit[x+k];\n        x+=k;\n      }\n    }\n    x++;\n    assert(sum(x-1)<w and sum(x)>=w);\n    return x;\n  }\n\n  // min({x | sum(x) > w})\n  int upper_bound(T w){return lower_bound(w+1);}\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n,k;\n  cin>>n>>k;\n  auto ps=read(n);\n  for(int &p:ps) p--;\n\n  using M = Mint<int, 998244353>;\n\n  M ans=M(k*(k-1)/2)/M(2);\n\n  BIT<M> bit(n),cnt(n);\n  for(int i=0;i<k;i++){\n    int p=ps[i];\n    bit.add(p,M(1));\n    cnt.add(p,M(1));\n  }\n\n  assert(n!=k);\n\n  M ofs{1};\n  M ratio=M(k-1)/M(k);\n  for(int i=k;i<n;i++){\n    ofs*=ratio;\n    int p=ps[i];\n    ans+=(bit.query(0,n)*ofs)/M(2);\n    ans+=(cnt.query(p,n)-bit.query(p,n)*ofs);\n    bit.add(p,M(1)/ofs);\n    cnt.add(p,M(1));\n  }\n\n  cout<<ans<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\ntemplate<typename T>\nstruct fenwick_tree {\n    int tree_n = 0;\n    T tree_sum = 0;\n    vector<T> tree;\n\n    fenwick_tree(int n = -1) {\n        if (n >= 0)\n            init(n);\n    }\n\n    static int largest_bit(int x) {\n        return x == 0 ? -1 : 31 - __builtin_clz(x);\n    }\n\n    void init(int n) {\n        tree_n = n;\n        tree_sum = 0;\n        tree.assign(tree_n + 1, 0);\n    }\n\n    // O(n) initialization of the Fenwick tree.\n    template<typename T_array>\n    void build(const T_array &initial) {\n        assert(int(initial.size()) == tree_n);\n        tree_sum = 0;\n\n        for (int i = 1; i <= tree_n; i++) {\n            tree[i] = initial[i - 1];\n            tree_sum += initial[i - 1];\n\n            for (int k = (i & -i) >> 1; k > 0; k >>= 1)\n                tree[i] += tree[i - k];\n        }\n    }\n\n    // index is in [0, tree_n).\n    void update(int index, const T &change) {\n        assert(0 <= index && index < tree_n);\n        tree_sum += change;\n\n        for (int i = index + 1; i <= tree_n; i += i & -i)\n            tree[i] += change;\n    }\n\n    // Returns the sum of the range [0, count).\n    T query(int count) const {\n        count = min(count, tree_n);\n        T sum = 0;\n\n        for (int i = count; i > 0; i -= i & -i)\n            sum += tree[i];\n\n        return sum;\n    }\n\n    // Returns the sum of the range [start, tree_n).\n    T query_suffix(int start) const {\n        return tree_sum - query(start);\n    }\n\n    // Returns the sum of the range [a, b).\n    T query(int a, int b) const {\n        return query(b) - query(a);\n    }\n\n    // Returns the element at index a in O(1) amortized across every index. Equivalent to query(a, a + 1).\n    T get(int a) const {\n        assert(0 <= a && a < tree_n);\n        int above = a + 1;\n        T sum = tree[above];\n        above -= above & -above;\n\n        while (a != above) {\n            sum -= tree[a];\n            a -= a & -a;\n        }\n\n        return sum;\n    }\n\n    bool set(int index, T value) {\n        assert(0 <= index && index < tree_n);\n        T current = get(index);\n\n        if (current == value)\n            return false;\n\n        update(index, value - current);\n        return true;\n    }\n\n    // Returns the largest p in `[0, tree_n]` such that `query(p) <= sum`. Returns -1 if no such p exists (`sum < 0`).\n    // Can be used as an ordered set/multiset on indices in `[0, tree_n)` by using the tree as a 0/1 or frequency array:\n    // `set(index, 1)` is equivalent to insert(index). `update(index, +1)` is equivalent to multiset.insert(index).\n    // `set(index, 0)` or `update(index, -1)` are equivalent to erase(index).\n    // `get(index)` provides whether index is present or not, or the count of index (if multiset).\n    // `query(index)` provides the count of elements < index.\n    // `find_last_prefix(k)` finds the k-th smallest element (0-indexed). Returns `tree_n` for `sum >= set.size()`.\n    int find_last_prefix(T sum) const {\n        if (sum < 0)\n            return -1;\n\n        int prefix = 0;\n\n        for (int k = largest_bit(tree_n); k >= 0; k--)\n            if (prefix + (1 << k) <= tree_n && tree[prefix + (1 << k)] <= sum) {\n                prefix += 1 << k;\n                sum -= tree[prefix];\n            }\n\n        return prefix;\n    }\n};\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, K;\n    cin >> N >> K;\n    mod_int R = 1 - mod_int(1) / K;\n    fenwick_tree<mod_int> tree(N), p_tree(N);\n    mod_int pow_sum = 0;\n    mod_int total = 0;\n\n    for (int i = 0; i < N; i++) {\n        int p;\n        cin >> p;\n        p--;\n\n        int start = max(i - (K - 1), 0);\n\n        mod_int power = R.pow(start);\n        mod_int inv_pow = power.inv();\n        total += power * pow_sum / 2;\n        pow_sum += inv_pow;\n\n        total += tree.query_suffix(p) - power * p_tree.query_suffix(p);\n\n        tree.update(p, +1);\n        p_tree.update(p, inv_pow);\n    }\n\n    cout << total << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\n//const int MOD = (int) 1e9 + 7;\nconst int MOD = 119 << 23 | 1;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\ntemplate<class num_t> struct SegmentTree {\n    int n;\n    vector<num_t> st;\n    vector<num_t> st2;\n    vector<num_t> lz;\n    vector<num_t> lz2;\n    void init(int n_) {\n        n = n_;\n        st.resize(n << 2);\n        st2.resize(n << 2);\n        lz.resize(n << 2, 1);\n        lz2.resize(n << 2);\n    }\n    void pushdown(int p, int L, int R) {\n        if (lz[p] != 1) {\n            st[p] = mult(st[p], lz[p]);\n            st2[p] = mult(st2[p], lz[p]);\n            if (L < R) {\n                FOR(i, p << 1, p + 1 << 1) {\n                    lz[i] = mult(lz[i], lz[p]);\n                }\n            }\n            lz[p] = 1;\n        }\n        if (lz2[p]) {\n            addmod(st[p], mult(st2[p], lz2[p]));\n            if (L < R) {\n                FOR(i, p << 1, p + 1 << 1) {\n                    addmod(lz2[i], lz2[p]);\n                }\n            }\n            lz2[p] = 0;\n        }\n    }\n    void upd(int p, int i, int L, int R) {\n        pushdown(p, L, R);\n        if (i < L || R < i) return;\n        if (L == R) {\n            st2[p] = 1;\n            return;\n        }\n        upd(p << 1, i, L, L + R >> 1);\n        upd(p << 1 | 1, i, (L + R >> 1) + 1, R);\n        st[p] = (st[p << 1] + st[p << 1 | 1]) % MOD;\n        st2[p] = (st2[p << 1] + st2[p << 1 | 1]) % MOD;\n    }\n    void upd(int p, int l, int r, int L, int R, num_t val) {\n        pushdown(p, L, R);\n        if (r < L || R < l) return;\n        if (l <= L && R <= r) {\n            lz[p] = val;\n            pushdown(p, L, R);\n            return;\n        }\n        upd(p << 1, l, r, L, L + R >> 1, val);\n        upd(p << 1 | 1, l, r, (L + R >> 1) + 1, R, val);\n        st[p] = (st[p << 1] + st[p << 1 | 1]) % MOD;\n        st2[p] = (st2[p << 1] + st2[p << 1 | 1]) % MOD;\n    }\n    void upd2(int p, int l, int r, int L, int R, num_t val) {\n        pushdown(p, L, R);\n        if (r < L || R < l) return;\n        if (l <= L && R <= r) {\n            lz2[p] = val;\n            pushdown(p, L, R);\n            return;\n        }\n        upd2(p << 1, l, r, L, L + R >> 1, val);\n        upd2(p << 1 | 1, l, r, (L + R >> 1) + 1, R, val);\n        st[p] = (st[p << 1] + st[p << 1 | 1]) % MOD;\n        st2[p] = (st2[p << 1] + st2[p << 1 | 1]) % MOD;\n    }\n    num_t query(int p, int l, int r, int L, int R) {\n        pushdown(p, L, R);\n        if (r < L || R < l) return 0;\n        if (l <= L && R <= r) return st[p];\n        return (query(p << 1, l, r, L, L + R >> 1) + query(p << 1 | 1, l, r, (L + R >> 1) + 1, R)) % MOD;\n    }\n    void upd(int i) {\n        upd(1, i, 0, n - 1);\n    }\n    void upd(int l, int r, num_t val) {\n        upd(1, l, r, 0, n - 1, val);\n    }\n    void upd2(int l, int r, num_t val) {\n        upd2(1, l, r, 0, n - 1, val);\n    }\n    num_t query(int l, int r) {\n        return query(1, l, r, 0, n - 1);\n    }\n};\nSegmentTree<int> seg;\n\nvoid chemthan() {\n    int n, k; cin >> n >> k;\n    vi fen(n + 1);\n    auto upd = [&] (int p, int v) {\n        p++;\n        for (; p < sz(fen); p += p & -p) {\n            fen[p] += v;\n        }\n    };\n    auto query = [&] (int p) {\n        p++;\n        int res = 0;\n        for (; 0 < p; p -= p & -p) {\n            res += fen[p];\n        }\n        return res;\n    };\n    vi a(n);\n    FOR(i, 0, n) cin >> a[i], a[i]--;\n    seg.init(n);\n    FOR(i, 0, k) {\n        seg.upd(a[i]);\n    }\n    FOR(i, k, n) {\n        seg.upd2(a[i] + 1, n - 1, 1);\n    }\n    FOR(i, k, n) upd(a[i], 1);\n    int ik = inv(k);\n    int c = mult(k - 1, inv(k));\n    int res = mult((long long) k * (k - 1) / 2 % MOD, inv(2));\n    addmod(res, mult(seg.st[1], ik));\n    FOR(i, k, n) {\n        upd(a[i], -1);\n        seg.upd(0, n - 1, c);\n        seg.upd2(a[i] + 1, n - 1, MOD - 1);\n        seg.upd(a[i]);\n        int t = query(a[i] - 1);\n        seg.upd2(a[i], a[i], t);\n        addmod(res, mult(k - 1, inv(2)));\n        addmod(res, mult(seg.st[1], ik));\n    }\n    cout << res << \"\\n\";\n}\n\nint32_t main(int32_t argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n//#include \"atcoder/all\"\n//using namespace atcoder;\n#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) (((n) >> (k)) & 1) /*nのk bit目*/\nnamespace mydef {\nconst int INF = 1ll << 60;\nconst int MOD = 998244353;\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T& val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\nbool dbg = true;\n}  // namespace mydef\nusing namespace mydef;\n#define pb push_back\n//#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vp vector<pair<int, int>>\n#define vvp vector<vector<pair<int, int>>>\n#define pi pair<int, int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define asn ans\n\n//SegmentTree\n//How to use\n//SegmentTree(n, f, M1):= サイズ n の初期化。ここで f は2つの区間の要素をマージする二項演算, M1はモノイドの単位元である。\n//set(k , x):= k 番目の要素に x を代入する。\n//build():= セグメント木を構築する。\n//query(a , b):= 区間 [a,b) に対して二項演算した結果を返す。\n//update(k , x):= k 番目の要素を x に変更する。\n//operator[k] : = k 番目の要素を返す。\ntemplate <typename Monoid>\nstruct SegmentTree {\n    using F = function<Monoid(Monoid, Monoid)>;\n\n    int sz;\n    vector<Monoid> seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n)\n            sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1)\n                L = f(L, seg[a++]);\n            if (b & 1)\n                R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n};\n//example\n/*\nint main() {\n  int N, Q;\n  scanf(\"%d %d\", &N, &Q);\n  SegmentTree< int > seg(N, [](int a, int b) { return min(a, b); }, INT_MAX);\n  while(Q--) {\n    int T, X, Y;\n    scanf(\"%d %d %d\", &T, &X, &Y);\n    if(T == 0) seg.update(X, Y);\n    else printf(\"%d\\n\", seg.query(X, Y + 1));\n  }\n}\n*/\ntemplate <uint MD>\nstruct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1)\n                r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    /*\n    M inv() const {\n        long long b = MD, u = 1, v = 0;\n        long long a = (*this).v;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        u %= MD;\n        if (u < 0)\n            u += MD;\n        return M{u};\n    }\n    */\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n    friend istream& operator>>(istream& is, M& r) { return is >> r.v; }\n};\nusing Mint = ModInt<MOD>;\n\n\nint N, K, p[202020], q[202020];\n\nMint dat[202020];\nMint datrev[202020];\n\nvoid solve() {\n    SegmentTree<Mint> seg1(N, [](Mint a, Mint b) { return a + b; }, Mint{0});\n    SegmentTree<Mint> seg2(N, [](Mint a, Mint b) { return a + b; }, Mint{0});\n    SegmentTree<Mint> seg3(N, [](Mint a, Mint b) { return a + b; }, Mint{0});\n    seg1.build();\n    seg2.build();\n    seg3.build();\n    dat[0] = 1;\n    Mint tmp = K - 1;\n    tmp /= K;\n    for (int i = 1; i < N + 10; i++) {\n        dat[i] = dat[i - 1] * tmp;\n    }\n    for (int i = 0; i < N + 10; i++) {\n        datrev[i] = Mint{1} / dat[i];\n    }\n    Mint ans = 0;\n    ans += Mint{1} * K * (K - 1) / 4;\n    for (int j = 0; j < N; j++) {\n        int i = q[j];\n        if (i >= K) {\n            ans += seg1.query(0, i) * dat[i] / 2;\n            ans -= seg2.query(i, N) * datrev[i] / 2;\n            ans += seg3.query(i, N);\n        } else {\n            ans -= seg2.query(K, N) * datrev[K - 1] / 2;\n            ans += seg3.query(K, N);\n        }\n        if (i < K) {\n            seg1.update(i, datrev[K - 1]);\n            seg2.update(i, dat[K - 1]);\n        } else {\n            seg1.update(i, datrev[i]);\n            seg2.update(i, dat[i]);\n            seg3.update(i, Mint{1});\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> K;\n    for (int i = 0; i < N; i++) {\n        cin >> p[i];\n        p[i]--;\n        q[p[i]] = i;\n    }\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a, b)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define lscan(x) scanf(\"%I64d\", &x)\n#define lprint(x) printf(\"%I64d\", x)\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define rep2(i, n) for (ll i = n - 1; i >= 0; i--)\nconst int mod = 998244353;\nll gcd(ll a, ll b)\n{\n\tll c = a % b;\n\twhile (c != 0)\n\t{\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\nstruct UnionFind\n{\n\tvector<ll> data;\n\n\tUnionFind(int sz)\n\t{\n\t\tdata.assign(sz, -1);\n\t}\n\n\tbool unite(int x, int y)\n\t{\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)\n\t\t\treturn (false);\n\t\tif (data[x] > data[y])\n\t\t\tswap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn (true);\n\t}\n\n\tint find(int k)\n\t{\n\t\tif (data[k] < 0)\n\t\t\treturn (k);\n\t\treturn (data[k] = find(data[k]));\n\t}\n\n\tll size(int k)\n\t{\n\t\treturn (-data[find(k)]);\n\t}\n};\n\nll M = 1000000007;\n\nvector<ll> fac(2000011);  //n!(mod M)\nvector<ll> ifac(2000011); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nll mpow2(ll x, ll n, ll mod)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % mod;\n\t\tx = x * x % mod;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb()\n{\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000010; i++)\n\t{\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[2000010] = mpow(fac[2000010], M - 2);\n\tfor (ll i = 2000010; i > 0; i--)\n\t{\n\t\tifac[i - 1] = ifac[i] * i % M;\n\t}\n}\nll comb(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\nlong long modinv(long long a)\n{\n\tlong long b = M, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0)\n\t\tu += M;\n\treturn u;\n}\nll modinv2(ll a, ll mod)\n{\n\tll b = mod, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tll t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0)\n\t\tu += mod;\n\treturn u;\n}\n\ntemplate <int mod>\nstruct ModInt\n{\n\tint x;\n\n\tModInt() : x(0) {}\n\n\tModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n\tModInt &operator+=(const ModInt &p)\n\t{\n\t\tif ((x += p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator-=(const ModInt &p)\n\t{\n\t\tif ((x += mod - p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator*=(const ModInt &p)\n\t{\n\t\tx = (int)(1LL * x * p.x % mod);\n\t\treturn *this;\n\t}\n\n\tModInt &operator/=(const ModInt &p)\n\t{\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\n\tModInt operator-() const { return ModInt(-x); }\n\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\n\tModInt inverse() const\n\t{\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\n\tModInt pow(int64_t n) const\n\t{\n\t\tModInt ret(1), mul(x);\n\t\twhile (n > 0)\n\t\t{\n\t\t\tif (n & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const ModInt &p)\n\t{\n\t\treturn os << p.x;\n\t}\n\n\tfriend istream &operator>>(istream &is, ModInt &a)\n\t{\n\t\tint64_t t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n\n\tstatic int get_mod() { return mod; }\n};\n\nusing mint = ModInt<mod>;\n\nvector<vector<mint>> mul(vector<vector<mint>> a, vector<vector<mint>> b)\n{\n\tint i, j, k;\n\tmint t;\n\tint n = a.size(), m = b[0].size(), l = a[0].size();\n\tvector<vector<mint>> c(n,vector<mint>(m));\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < l; k++)\n\t\t\t\tt += a[i][k] * b[k][j];\n\t\t\tc[i][j] = t;\n\t\t}\n\t}\n\treturn c;\n}\n\nvector<vector<mint>> mat_pow(vector<vector<mint>> x, ll n)\n{\n\tll k = x.size();\n\tvector<vector<mint>> ans(k, vector<mint>(k, 0));\n\tfor (int i = 0; i < k; i++)\n\t\tans[i][i] = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = mul(ans, x);\n\t\tx = mul(x, x);\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\n\ntemplate <typename Monoid>\nstruct SegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\n\tint sz;\n\tvector<Monoid> seg;\n\n\tconst F f;\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1)\n\t{\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x)\n\t{\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t\tL = f(L, seg[a++]);\n\t\t\tif (b & 1)\n\t\t\t\tR = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k) const\n\t{\n\t\treturn seg[k + sz];\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tMonoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, seg[1])))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, seg[a]);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(seg[1], R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(seg[--b], R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\ntemplate <unsigned mod>\nstruct RollingHash\n{\n\tvector<unsigned> hashed, power;\n\n\tinline unsigned mul(unsigned a, unsigned b) const\n\t{\n\t\tunsigned long long x = (unsigned long long)a * b;\n\t\tunsigned xh = (unsigned)(x >> 32), xl = (unsigned)x, d, m;\n\t\tasm(\"divl %4; \\n\\t\"\n\t\t\t: \"=a\"(d), \"=d\"(m)\n\t\t\t: \"d\"(xh), \"a\"(xl), \"r\"(mod));\n\t\treturn m;\n\t}\n\n\tRollingHash(const string &s, unsigned base = 10007)\n\t{\n\t\tint sz = (int)s.size();\n\t\thashed.assign(sz + 1, 0);\n\t\tpower.assign(sz + 1, 0);\n\t\tpower[0] = 1;\n\t\tfor (int i = 0; i < sz; i++)\n\t\t{\n\t\t\tpower[i + 1] = mul(power[i], base);\n\t\t\thashed[i + 1] = mul(hashed[i], base) + s[i];\n\t\t\tif (hashed[i + 1] >= mod)\n\t\t\t\thashed[i + 1] -= mod;\n\t\t}\n\t}\n\n\tunsigned get(int l, int r) const\n\t{\n\t\tunsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tunsigned connect(unsigned h1, int h2, int h2len) const\n\t{\n\t\tunsigned ret = mul(h1, power[h2len]) + h2;\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tint LCP(const RollingHash<mod> &b, int l1, int r1, int l2, int r2)\n\t{\n\t\tint len = min(r1 - l1, r2 - l2);\n\t\tint low = -1, high = len + 1;\n\t\twhile (high - low > 1)\n\t\t{\n\t\t\tint mid = (low + high) / 2;\n\t\t\tif (get(l1, l1 + mid) == b.get(l2, l2 + mid))\n\t\t\t\tlow = mid;\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\t\treturn (low);\n\t}\n};\n\nusing RH = RollingHash<1000000007>;\n\ntemplate <typename T>\nstruct edge\n{\n\tint src, to;\n\tT cost;\n\n\tedge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n\tedge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n\tedge &operator=(const int &x)\n\t{\n\t\tto = x;\n\t\treturn *this;\n\t}\n\n\toperator int() const { return to; }\n};\n\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate <typename T>\nusing Matrix = vector<vector<T>>;\n\ntemplate <typename G>\nstruct DoublingLowestCommonAncestor\n{\n\tconst int LOG;\n\tvector<int> dep;\n\tconst G &g;\n\tvector<vector<int>> table;\n\n\tDoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size()))\n\t{\n\t\ttable.assign(LOG, vector<int>(g.size(), -1));\n\t}\n\n\tvoid dfs(int idx, int par, int d)\n\t{\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor (auto &to : g[idx])\n\t\t{\n\t\t\tif (to != par)\n\t\t\t\tdfs(to, idx, d + 1);\n\t\t}\n\t}\n\n\tvoid build()\n\t{\n\t\tdfs(0, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG; k++)\n\t\t{\n\t\t\tfor (int i = 0; i < table[k].size(); i++)\n\t\t\t{\n\t\t\t\tif (table[k][i] == -1)\n\t\t\t\t\ttable[k + 1][i] = -1;\n\t\t\t\telse\n\t\t\t\t\ttable[k + 1][i] = table[k][table[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v)\n\t{\n\t\tif (dep[u] > dep[v])\n\t\t\tswap(u, v);\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (((dep[v] - dep[u]) >> i) & 1)\n\t\t\t\tv = table[i][v];\n\t\t}\n\t\tif (u == v)\n\t\t\treturn u;\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (table[i][u] != table[i][v])\n\t\t\t{\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid>\nstruct LazySegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\tusing G = function<Monoid(Monoid, OperatorMonoid)>;\n\tusing H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n\tint sz, height;\n\tvector<Monoid> data;\n\tvector<OperatorMonoid> lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst Monoid M1;\n\tconst OperatorMonoid OM0;\n\n\tLazySegmentTree(int n, const F f, const G g, const H h,\n\t\t\t\t\tconst Monoid &M1, const OperatorMonoid OM0)\n\t\t: f(f), g(g), h(h), M1(M1), OM0(OM0)\n\t{\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1, height++;\n\t\tdata.assign(2 * sz, M1);\n\t\tlazy.assign(2 * sz, OM0);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tdata[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tdata[k] = f(data[2 * k + 0], data[2 * k + 1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k)\n\t{\n\t\tif (lazy[k] != OM0)\n\t\t{\n\t\t\tlazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n\t\t\tlazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = OM0;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k)\n\t{\n\t\treturn lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n\t}\n\n\tinline void recalc(int k)\n\t{\n\t\twhile (k >>= 1)\n\t\t\tdata[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n\t}\n\n\tinline void thrust(int k)\n\t{\n\t\tfor (int i = height; i > 0; i--)\n\t\t\tpropagate(k >> i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tlazy[l] = h(lazy[l], x), ++l;\n\t\t\tif (r & 1)\n\t\t\t\t--r, lazy[r] = h(lazy[r], x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tMonoid L = M1, R = M1;\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tL = f(L, reflect(l++));\n\t\t\tif (r & 1)\n\t\t\t\tR = f(reflect(--r), R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k)\n\t{\n\t\treturn query(k, k + 1);\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tpropagate(a);\n\t\t\tMonoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, reflect(1))))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(a + sz);\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, reflect(a));\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(reflect(1), R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(b + sz - 1);\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(reflect(--b), R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main()\n{\n\tM = 998244353;\n\tll n, k, p[222222];\n\tcin >> n >> k;\n\trep(i, n) cin >> p[i];\n\tll r = k - 1;\n\tr *= modinv(k);\n\tmint ans = k * (k - 1);\n\tans /= 4;\n\tmint s = 1, t = 1;\n\tSegmentTree<pair<mint, mint>> seg(n + 1, [](pair<mint, mint> a, pair<mint, mint> b) { return mp(a.first + b.first, a.second + b.second); }, mp(0,0));\n\trep(i, k) seg.set(p[i], mp(1,1));\n\tseg.build();\n\tfor (int i = 1; i < n - k + 1; i++){\n\t\tans += (k - 1) * modinv(2);\n\t\ts *= r;\n\t\tt /= r;\n\t\tpair<mint, mint> ret = seg.query(p[i + k - 1], n + 1);\n\t\tans += ret.first;\n\t\tans -= ret.second * s;\n\t\tseg.update(p[i + k - 1], mp(1, t));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    bool operator<(const ModInt& b) const { return val < b.val; }\n    bool operator<=(const ModInt& b) const { return val <= b.val; }\n    bool operator>(const ModInt& b) const { return val > b.val; }\n    bool operator>=(const ModInt& b) const { return val >= b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept {\n        lint v;\n        is >> v;\n        x = v;\n        return is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\ntemplate <class T>\nstruct SegmentTree {\n    using Merger = std::function<T(T, T)>;\n\n    int length;\n    std::vector<T> dat;\n    T unit;\n    Merger merge;\n\n    SegmentTree() = default;\n\n    SegmentTree(int n, const T& unit, const Merger& merge)\n        : length(1), unit(unit), merge(merge) {\n        while (length < n) length <<= 1;\n        dat.assign(length * 2, unit);\n    }\n\n    template <class Container>\n    SegmentTree(const Container& elems, const T& unit, const Merger& merge)\n        : length(1), unit(unit), merge(merge) {\n        int n = elems.size();\n        while (length < n) length <<= 1;\n\n        dat.assign(length * 2, unit);\n\n        std::copy(elems.begin(), elems.end(), dat.begin() + length);\n\n        for (int nidx = length - 1; nidx >= 1; --nidx) {\n            T vl = dat[nidx * 2 + 0];\n            T vr = dat[nidx * 2 + 1];\n            dat[nidx] = merge(vl, vr);\n        }\n    }\n\n    void update(int nidx, const T& elem) {\n        nidx += length;\n        dat[nidx] = elem;\n\n        while (nidx > 0) {\n            nidx >>= 1;\n            T vl = dat[nidx * 2 + 0];\n            T vr = dat[nidx * 2 + 1];\n            dat[nidx] = merge(vl, vr);\n        }\n    }\n\n    T fold(int ql, int qr) const {\n        ql = std::max(ql, 0);\n        qr = std::min(qr, length);\n        ql += length, qr += length;\n\n        T lacc = unit, racc = unit;\n        while (ql < qr) {\n            if (ql & 1) {\n                lacc = merge(lacc, dat[ql]);\n                ++ql;\n            }\n            if (qr & 1) {\n                --qr;\n                racc = merge(dat[qr], racc);\n            }\n            ql >>= 1, qr >>= 1;\n        }\n\n        return merge(lacc, racc);\n    }\n\n    T get(int idx) const { return dat[idx + length]; }\n    T fold_all() const { return dat[1]; }\n};\n\nconstexpr int MOD = 998244353;\nusing mint = ModInt<MOD>;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n\n    std::vector<int> pos(n);\n    for (int i = 0; i < n; ++i) {\n        int p;\n        std::cin >> p;\n        pos[--p] = i;\n    }\n\n    mint p = mint(k - 1) / k;\n\n    mint ans = 0;\n    SegmentTree<mint> seg(n, 0, [](auto a, auto b) { return a + b; });\n    auto pseg = seg;\n\n    for (int i = 0; i < n; ++i) {\n        int t = std::max(0, pos[i] - (k - 1));\n\n        ans += seg.fold(t, n) - pseg.fold(t, n) / p.pow(t);\n\n        seg.update(t, seg.get(t) + 1);\n        pseg.update(t, pseg.get(t) + p.pow(t));\n    }\n\n    for (int t = 0; t <= n - k; ++t) {\n        mint pat = (t == 0 ? mint(k) * (k - 1) / 2 : k + (n - k - t));\n        ans += pat * p.pow(t) / 2;\n    }\n\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll, ll> P;\nusing VP = vector<P>;\nusing VVP = vector<VP>;\nusing VI = vector<ll>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\nconst int inf = 1e9 + 7;\nconst ll INF = 1LL << 61;\nconst ll mod = 998244353;\n\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid>\nstruct LazySegmentTree {\n  using F = function<Monoid(Monoid, Monoid)>;\n  using G = function<Monoid(Monoid, OperatorMonoid)>;\n  using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n  int sz, height;\n  vector<Monoid> data;\n  vector<OperatorMonoid> lazy;\n  const F f;\n  const G g;\n  const H h;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n  LazySegmentTree(int n, const F f, const G g, const H h, const Monoid &M1,\n                  const OperatorMonoid OM0)\n      : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n    sz = 1;\n    height = 0;\n    while (sz < n) sz <<= 1, height++;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n\n  void set(int k, const Monoid &x) { data[k + sz] = x; }\n\n  void build() {\n    for (int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n\n  inline void propagate(int k) {\n    if (lazy[k] != OM0) {\n      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      data[k] = reflect(k);\n      lazy[k] = OM0;\n    }\n  }\n\n  inline Monoid reflect(int k) {\n    return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n  }\n\n  inline void recalc(int k) {\n    while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n  }\n\n  inline void thrust(int k) {\n    for (int i = height; i > 0; i--) propagate(k >> i);\n  }\n\n  void update(int a, int b, const OperatorMonoid &x) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if (r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  Monoid query(int a, int b) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    Monoid L = M1, R = M1;\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) L = f(L, reflect(l++));\n      if (r & 1) R = f(reflect(--r), R);\n    }\n    return f(L, R);\n  }\n\n  Monoid operator[](const int &k) { return query(k, k + 1); }\n\n  template <typename C>\n  int find_subtree(int a, const C &check, Monoid &M, bool type) {\n    while (a < sz) {\n      propagate(a);\n      Monoid nxt =\n          type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n      if (check(nxt))\n        a = 2 * a + type;\n      else\n        M = nxt, a = 2 * a + 1 - type;\n    }\n    return a - sz;\n  }\n\n  template <typename C>\n  int find_first(int a, const C &check) {\n    Monoid L = M1;\n    if (a <= 0) {\n      if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    thrust(a + sz);\n    int b = sz;\n    for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if (a & 1) {\n        Monoid nxt = f(L, reflect(a));\n        if (check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n\n  template <typename C>\n  int find_last(int b, const C &check) {\n    Monoid R = M1;\n    if (b >= sz) {\n      if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    thrust(b + sz - 1);\n    int a = sz;\n    for (b += sz; a < b; a >>= 1, b >>= 1) {\n      if (b & 1) {\n        Monoid nxt = f(reflect(--b), R);\n        if (check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n};\n\nint n, k;\nint cal(int p) { return max(0, p - k + 1); }\n\nint main() {\n  ios::sync_with_stdio(false);\n  int i, j;\n  cin >> n >> k;\n  VI p(n);\n  for (i = 0; i < n; i++) {\n    cin >> p[i];\n    p[i]--;\n  }\n  LazySegmentTree<ll> seg(\n      n, [](ll a, ll b) { return (a + b) % mod; },\n      [](ll a, ll b) { return (a + b) % mod; },\n      [](ll a, ll b) { return (a + b) % mod; }, 0ll, 0ll);\n  LazySegmentTree<ll> seg2(\n      n, [](ll a, ll b) { return (a + b) % mod; },\n      [](ll a, ll b) { return (a + b) % mod; },\n      [](ll a, ll b) { return (a + b) % mod; }, 0ll, 0ll);\n  // for (i = 0; i < n; i++) cout << seg.query(i, i + 1) << endl;\n  ll ans = 0, ans2 = 0;\n  ll r = (k - 1) * inv_mod(k, mod) % mod;\n  for (i = 0; i < n; i++) {\n    ans += inv_mod(2, mod) * seg.query(p[i], p[i] + 1) % mod *\n           pow_mod(r, cal(i), mod) % mod;\n\n    seg.update(0, p[i], mod - pow_mod(r, mod - 1 - cal(i), mod));\n    seg.update(p[i] + 1, n, pow_mod(r, mod - 1 - cal(i), mod));\n    ans %= mod;\n    seg2.update(0, p[i], 1);\n    ans2 += seg2.query(p[i], p[i] + 1);\n    ans2 %= mod;\n  }\n  // cout << ans2 << endl;\n  cout << (ans + ans2) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#line 2 \"cpplib/util/template.hpp\"\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx\")\n#include<bits/stdc++.h>\nusing namespace std;\nstruct __INIT__{__INIT__(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}}__INIT__;\ntypedef long long lint;\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define endl ('\\n')\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(lint i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(lint i=0;i<t.size();i++)output(t[i]);}\n#define rep(i,...) for(auto i:range(__VA_ARGS__)) \n#define rrep(i,...) for(auto i:reversed(range(__VA_ARGS__)))\n#define repi(i,a,b) for(lint i=lint(a);i<(lint)(b);++i)\n#define rrepi(i,a,b) for(lint i=lint(b)-1;i>=lint(a);--i)\n#define irep(i) for(lint i=0;;++i)\ninline vector<long long> range(long long n){if(n<=0)return vector<long long>();vector<long long>v(n);iota(v.begin(),v.end(),0LL);return v;}\ninline vector<long long> range(long long a,long long b){if(b<=a)return vector<long long>();vector<long long>v(b-a);iota(v.begin(),v.end(),a);return v;}\ninline vector<long long> range(long long a,long long b,long long c){if((b-a+c-1)/c<=0)return vector<long long>();vector<long long>v((b-a+c-1)/c);for(int i=0;i<(int)v.size();++i)v[i]=i?v[i-1]+c:a;return v;}\ntemplate<typename T>inline T reversed(T v){reverse(v.begin(),v.end());return v;}\n#define all(n) begin(n),end(n)\ntemplate<typename T,typename E>bool chmin(T& s,const E& t){bool res=s>t;s=min<T>(s,t);return res;}\ntemplate<typename T,typename E>bool chmax(T& s,const E& t){bool res=s<t;s=max<T>(s,t);return res;}\nconst vector<lint> dx={1,0,-1,0,1,1,-1,-1};\nconst vector<lint> dy={0,1,0,-1,1,-1,1,-1};\n#define SUM(v) accumulate(all(v),0LL)\ntemplate<typename T,typename ...Args>auto make_vector(T x,int arg,Args ...args){if constexpr(sizeof...(args)==0)return vector<T>(arg,x);else return vector(arg,make_vector<T>(x,args...));}\n#line 5 \"cpplib/graph_tree/graph_template.hpp\"\n/**\n * @brief グラフテンプレート\n */\n\nusing graph=std::vector<std::vector<int>>;\ntemplate<typename T>\nusing graph_w=std::vector<std::vector<std::pair<int,T>>>;\n\ngraph load_graph(int n,int m){\n    graph g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        std::cin>>s>>t;\n        --s;--t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    return g;\n}\ngraph load_digraph(int n,int m){\n    graph g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        std::cin>>s>>t;\n        --s;--t;\n        g[s].push_back(t);\n    }\n    return g;\n}\ngraph load_graph0(int n,int m){\n    graph g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        std::cin>>s>>t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    return g;\n}\ngraph load_digraph0(int n,int m){\n    graph g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        std::cin>>s>>t;\n        g[s].push_back(t);\n    }\n    return g;\n}\ngraph load_tree(int n){\n    graph g(n);\n    for(int i=0;i<n-1;++i){\n        int s,t;\n        std::cin>>s>>t;\n        --s;--t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    return g;\n}\ngraph load_tree0(int n){\n    graph g(n);\n    for(int i=0;i<n-1;++i){\n        int s,t;\n        std::cin>>s>>t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    return g;\n}\ngraph load_treep(int n){\n    graph g(n);\n    for(int i=0;i<n-1;++i){\n        int t;\n        std::cin>>t;\n        g[i+1].push_back(t);\n        g[t].push_back(i+1);\n    }\n    return g;\n}\n\ntemplate<typename T>\ngraph_w<T> load_graph_weight(int n,int m){\n    graph_w<T> g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        --s;--t;\n        g[s].emplace_back(t,u);\n        g[t].emplace_back(s,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_digraph_weight(int n,int m){\n    graph_w<T> g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        --s;--t;\n        g[s].emplace_back(t,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_graph0_weight(int n,int m){\n    graph_w<T> g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        g[s].emplace_back(t,u);\n        g[t].emplace_back(s,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_digraph0_weight(int n,int m){\n    graph_w<T> g(n);\n    for(int i=0;i<m;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        g[s].emplace_back(t,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_tree_weight(int n){\n    graph_w<T> g(n);\n    for(int i=0;i<n-1;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        --s;--t;\n        g[s].emplace_back(t,u);\n        g[t].emplace_back(s,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_tree0_weight(int n){\n    graph_w<T> g(n);\n    for(int i=0;i<n-1;++i){\n        int s,t;\n        T u;\n        std::cin>>s>>t>>u;\n        g[s].emplace_back(t,u);\n        g[t].emplace_back(s,u);\n    }\n    return g;\n}\ntemplate<typename T>\ngraph_w<T> load_treep_weight(int n){\n    graph_w<T> g(n);\n    for(int i=0;i<n-1;++i){\n        int t;\n        T u;\n        std::cin>>t>>u;\n        g[i+1].emplace_back(t,u);\n        g[t].emplace_back(i+1,u);\n    }\n    return g;\n}\n#line 5 \"cpplib/math/mod_int.hpp\"\n\n/**\n * @brief ModInt\n */\n\ntemplate<int MOD>\nstruct mod_int {\n    using mint=mod_int<MOD>;\n    using u64 = std::uint_fast64_t;\n    u64 a;\n    constexpr mod_int(const long long x = 0)noexcept:a(x>=0?x%get_mod():get_mod()-(-x)%get_mod()){}\n    constexpr u64 &value()noexcept{return a;}\n    constexpr const u64 &value() const noexcept {return a;}\n    constexpr mint operator+(const mint rhs)const noexcept{return mint(*this) += rhs;}\n    constexpr mint operator-(const mint rhs)const noexcept{return mint(*this)-=rhs;}\n    constexpr mint operator*(const mint rhs) const noexcept {return mint(*this) *= rhs;}\n    constexpr mint operator/(const mint rhs) const noexcept {return mint(*this) /= rhs;}\n    constexpr mint &operator+=(const mint rhs) noexcept {\n        a += rhs.a;\n        if (a >= get_mod())a -= get_mod();\n        return *this;\n    }\n    constexpr mint &operator-=(const mint rhs) noexcept {\n        if (a<rhs.a)a += get_mod();\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr mint &operator*=(const mint rhs) noexcept {\n        a = a * rhs.a % get_mod();\n        return *this;\n    }\n    constexpr mint operator++(int) noexcept {\n        a += 1;\n        if (a >= get_mod())a -= get_mod();\n        return *this;\n    }\n    constexpr mint operator--(int) noexcept {\n        if (a<1)a += get_mod();\n        a -= 1;\n        return *this;\n    }\n    constexpr mint &operator/=(mint rhs) noexcept {\n        u64 exp=get_mod()-2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr bool operator==(mint x) noexcept {\n        return a==x.a;\n    }\n    constexpr bool operator!=(mint x) noexcept {\n        return a!=x.a;\n    }\n    constexpr bool operator<(mint x) noexcept {\n        return a<x.a;\n    }\n    constexpr bool operator>(mint x) noexcept {\n        return a>x.a;\n    }\n    constexpr bool operator<=(mint x) noexcept {\n        return a<=x.a;\n    }\n    constexpr bool operator>=(mint x) noexcept {\n        return a>=x.a;\n    }\n    constexpr static int root(){\n        mint root = 2;\n        while(root.pow((get_mod()-1)>>1).a==1)root++;\n        return root.a;\n    }\n    constexpr mint pow(long long n){\n        long long x=a;\n        mint ret = 1;\n        while(n>0) {\n            if(n&1)(ret*=x);\n            (x*=x)%=get_mod();\n            n>>=1;\n        }\n        return ret;\n    }\n    constexpr mint inv(){\n        return pow(get_mod()-2);\n    }\n    static std::vector<mint> fac;\n    static std::vector<mint> ifac;\n    static bool init;\n    constexpr static int mx=10000001;\n    void build(){\n        init=0;\n        fac.resize(mx);\n        ifac.resize(mx);\n        fac[0]=1,ifac[0]=1;\n        for(int i=1;i<mx;i++)fac[i]=fac[i-1]*i;\n        ifac[mx-1]=fac[mx-1].inv();\n        for(int i=mx-2;i>=0;i--)ifac[i]=ifac[i+1]*(i+1);\n    }\n    mint comb(long long b){\n        if(init)build();\n        if(a==0&&b==0)return 1;\n        if((long long)a<b)return 0;\n        return fac[a]*ifac[a-b]*ifac[b];\n    }\n    mint fact(){\n        if(init)build();\n        return fac[a];\n    }\n    mint fact_inv(){\n        if(init)build();\n        return ifac[a];\n    }\n    friend std::ostream& operator<<(std::ostream& lhs, const mint& rhs) noexcept {\n        lhs << rhs.a;\n        return lhs;\n    }\n    friend std::istream& operator>>(std::istream& lhs,mint& rhs) noexcept {\n        lhs >> rhs.a;\n        return lhs;\n    }\n    constexpr static u64 get_mod(){\n        return MOD;\n    }\n};\ntemplate<int MOD>std::vector<mod_int<MOD>> mod_int<MOD>::fac;\ntemplate<int MOD>std::vector<mod_int<MOD>> mod_int<MOD>::ifac;\ntemplate<int MOD>bool mod_int<MOD>::init=1;\n#line 3 \"cpplib/math/mod_int998244353.hpp\"\nusing mint=mod_int<998'244'353>;\n\n/**\n * @brief ModInt(998'244'353)\n */\n#line 3 \"cpplib/alga/maybe.hpp\"\n\n/**\n * @brief Maybe\n * @see https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8A%E3%83%89_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)#Maybe%E3%83%A2%E3%83%8A%E3%83%89\n */\n\ntemplate<typename T>\nstruct maybe{\n    bool _is_none;\n    T val;\n    maybe():_is_none(true){}\n    maybe(T val):_is_none(false),val(val){}\n    T unwrap()const{\n        assert(!_is_none);\n        return val;\n    }\n    T unwrap_or(T e)const{\n        return _is_none?e:val;\n    }\n    bool is_none()const{return _is_none;}\n    bool is_some()const{return !_is_none;}\n};\n\ntemplate<typename T,typename F>\nauto expand(F op){\n    return [&op](const maybe<T>& s,const maybe<T>& t){\n        if(s.is_none())return t;\n        if(t.is_none())return s;\n        return maybe<T>(op(s.unwrap(),t.unwrap()));\n    };\n}\n#line 4 \"cpplib/segment_tree/segment_tree.hpp\"\n\n/**\n * @brief セグメント木\n * @see https://en.wikipedia.org/wiki/Segment_tree\n */\n\ntemplate<typename T,typename F>\nclass segment_tree{\n\tmaybe<T>* node;\n    F op;\n\tint n=1;\n\tpublic:\n    segment_tree(){}\n\tsegment_tree(int sz,F op=F()):op(op){\n\t\twhile(n<=sz)n<<=1;\n\t\tnode=new maybe<T>[n*2];\n\t\tfor(int i=0;i<n*2;i++)node[i]=maybe<T>();\n\t}\n    segment_tree(const std::vector<T>&v,F op=F()):op(op){\n        auto f=expand<T,F>(op);\n        const int sz=v.size();\n\t\twhile(n<=sz)n<<=1;\n\t\tnode=new maybe<T>[n*2]();\n        for(int i=0;i<sz;i++)node[i+n]=maybe<T>(v[i]);\n        for(int i=n-1;i>=1;i--)node[i]=f(node[i*2],node[i*2+1]);\n\t}\n    maybe<T> get(int l,int r){\n        auto f=expand<T,F>(op);\n        l+=n;r+=n;\n        maybe<T> s,t;\n        while(l<r){\n            if(l&1)s=f(s,node[l++]);\n            if(r&1)t=f(node[--r],t);\n            l>>=1;r>>=1;\n        }\n        return f(s,t);\n    }\n    void apply(int t,T _val){\n        auto f=expand<T,F>(op);\n        t+=n;\n        maybe<T> val=maybe<T>(_val);\n        while(t){\n            node[t]=f(node[t],val);\n            t=t>>1;\n        }\n    }\n    void apply_left(int t,T _val){\n        auto f=expand<T,F>(op);\n        t+=n;\n        maybe<T> val=maybe<T>(_val);\n        while(t){\n            node[t]=f(val,node[t]);\n            t=t>>1;\n        }\n    }\n    void change(int t,T val){\n        auto f=expand<T,F>(op);\n        t+=n;\n        node[t]=maybe<T>(val);\n        while(t>1){\n            t=t>>1;\n            node[t]=f(node[t*2],node[t*2+1]);\n        }\n    }\n};\n#line 4 \"code.cpp\"\n\nint main(){\n    lint n,k;\n    cin>>n>>k;\n    vec a(n);\n    rep(i,n){\n        cin>>a[i];\n        a[i]--;\n    }\n    segment_tree<mint,plus<mint>>seg(n);\n    segment_tree<mint,plus<mint>>cnt(n);\n    mint tmp=1;\n    mint ans=0;\n    rep(i,n){\n        if(i>=k)tmp*=mint(k-1)/k;\n        ans+=seg.get(0,a[i]).unwrap_or(0)*tmp/2;\n        ans+=cnt.get(a[i],n).unwrap_or(0)-seg.get(a[i],n).unwrap_or(0)*tmp/2;\n        seg.apply(a[i],mint(1)/tmp);\n        cnt.apply(a[i],1);\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// #include <atcoder/all>\n\nusing namespace std;\n// using namespace atcoder;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 555555;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = 1;\n  for (ll i = 1; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n  }\n  rfact[n] = mod_inverse(fact[n], M);\n  for (ll i = n - 1; i >= 0; i--) {\n      rfact[i] = (i + 1) * rfact[i + 1] % M;\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\n\ntemplate <typename T>\nclass SegmentTree {\npublic:\n  using F = function<T(T&, T&)>;\n  int n;\n  vector<T > dat;\n  T e; // �P�ʌ�\n  F query_func;\n  F update_func;\n  \n  SegmentTree(vector<T> a, F query_func, F update_func, T e) :n(a.size()), query_func(query_func), update_func(update_func), e(e) {\n    if (n == 0) {\n      a.push_back(e);\n      n++;\n    }\n    dat.resize(4 * n);\n    init(0, 0, n, a);\n  }\n\n  void init(int k, int l, int r, vector<T> &a) {\n    if (r - l == 1) {\n      dat[k] = a[l];\n    }\n    else {\n      int lch = 2 * k + 1, rch = 2 * k + 2;\n      init(lch, l, (l + r) / 2, a);\n      init(rch, (l + r) / 2, r, a);\n      dat[k] = query_func(dat[lch], dat[rch]);\n    }\n  }\n\n  //k�Ԗڂ̒l��a�ɕύX\n  void update(int k, T a, int v, int l, int r) {\n    if (r - l == 1) {\n      dat[v] = update_func(dat[v], a);\n    }\n    else {\n      if (k < (l + r) / 2)\n        update(k, a, 2 * v + 1, l, (l + r) / 2);\n      else {\n        update(k, a, 2 * v + 2, (l + r) / 2, r);\n      }\n      dat[v] = query_func(dat[v * 2 + 1], dat[v * 2 + 2]);\n    }\n  }\n    \n\n  //[a,b)�̍ŏ��l�����߂�\n  //���̂ق��̈����͌v�Z�̊ȒP�̂��߂̈���\n  //k�͐ړ_�̔ԍ�,l,r�͂��̐ړ_��[l,r)�ɑΉ����Ă��邱�Ƃ�\\��\n  //�]���āA�O�����query(a,b,0,0,n)�Ƃ��Ă��\n  T query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) {\n      return e;\n    }\n    if (a <= l && r <= b) {\n      return dat[k];\n    }\n    else {\n      T ul = query(a, b, k * 2 + 1, l, (l + r) / 2);\n      T ur = query(a, b, k * 2 + 2, (l + r) / 2, r);\n      return query_func(ul, ur);\n    }\n  }\n\n  // �����𖞂����ĉE��T��\n  int find(int a, int b, int k, int l, int r, int x) {\n    // �����𒼂�\n    if (dat[k] < x || r <= a || b <= l) return -1;\n    if (l + 1 == r) {\n      // �����𒼂�\n      if (dat[k] >= x) return l;\n      else return -1;\n    }\n    int rv = find(a, b, 2 * k + 2, (l + r) / 2, r, x);\n    if (rv != -1) return rv;\n    return find(a, b, 2 * k + 1, l, (l + r) / 2, x);\n  }\n};\n\nll f(ll a, ll b) {return (a + b) % MOD;}\nll g(ll a, ll b) {return b;}\n\n\nsigned main() {\n    fio();\n    int n, k;\n    cin >> n >> k;\n\n    ll L = (k - 1) * mod_inverse(k) % MOD;\n\n    vi p(n);\n    rep (i, n) cin >> p[i];\n    ll inv2 = mod_inverse(2);\n    ll invL = mod_inverse(L);\n    // DEBUG(invL);\n\n    vl temp(n), temp2(n);\n    // SegmentTree<ll> low(temp, f, g, 0);\n    vi kata(n);\n    rep (i, n) {\n        if (i < k) {\n            kata[i] = 0;\n            temp[i] = 1;\n            temp2[i] = 1;\n        }\n        else {\n            kata[i] = i - k + 1;\n            temp[i] = mod_pow(L, i - k + 1);\n            temp2[i] = mod_pow(invL, i - k + 1);\n        }\n    }\n    SegmentTree<ll> high(temp, f, g, 0);\n    SegmentTree<ll> high2(temp2, f, g, 0);\n    temp = vl(n, 1);\n    SegmentTree<ll> num(temp, f, g, 0);\n    // DEBUG_VEC(temp2);\n    // rep (i, n) {\n    //     cout << high2.query(i, i + 1, 0, 0, high2.n) << \" \";\n    // }\n    // cout << endl;\n\n    vector<pii> pi(n);\n    rep (i, n) pi[i] = pii(p[i], i);\n    sort(all(pi));\n\n    // DEBUG_VEC(pi);\n    ll ans = 0;\n    rep (i, n) {\n        int idx = pi[i].second;\n        ll s = high.query(idx + 1, n, 0, 0, high.n);\n        // DEBUG(s);        \n        s = s * inv2 % MOD * mod_pow(invL, kata[idx]) % MOD;\n        // DEBUG(s);\n        ans += s;\n        ans %= MOD;\n\n        s = high2.query(0, idx, 0, 0, high.n);\n        // DEBUG(s);\n        s = s * inv2 % MOD * mod_pow(L, kata[idx]) % MOD;\n        // DEBUG(s);\n        ll nu = num.query(0, idx, 0, 0, num.n);\n        // DEBUG(nu);\n        ans += nu - s;\n        ans %= MOD;\n\n        high.update(idx, 0, 0, 0, high.n);\n        high2.update(idx, 0, 0, 0, high2.n);\n        num.update(idx, 0, 0, 0, num.n);\n    }\n    ans = (ans % MOD + MOD) % MOD;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll=long long;\ntemplate<class T,class U> inline bool chmin(T&x,U y){if(x>y){x=y;return true;}return false;}\ntemplate<class T,class U> inline bool chmax(T&x,U y){if(x<y){x=y;return true;}return false;}\n\nusing mint = modint998244353;\n\nmint op(mint a,mint b){\n    return a+b;\n}\n\nmint e(){\n    return 0;\n}\n\nvoid solve(){\n    int n,k,l;\n    cin>>n>>k;\n    l=n-k+1;\n    vector<int> p(n),q(n);\n    iota(q.begin(),q.end(),0);\n    for(auto&i:p) cin>>i;\n    vector<mint> pw(l,1);\n    for(int i{1};i<l;++i){\n        pw[i]=pw[i-1]*(k-1)/k;\n    }\n    mint ans=0;\n    {\n        fenwick_tree<mint> fw(l);\n        segtree<mint,op,e> seg(l),SEG(l);\n        sort(q.begin(),q.end(),[&](int i,int j){\n            return p[i]>p[j];\n        });\n        for(auto&i:q){\n            int I=i-k+1;\n            if(I<0) I=0;\n            ans+=fw.sum(0,I);\n            ans-=seg.prod(0,I)/pw[l-I-1]/2;\n            ans+=SEG.prod(I,l)/pw[I]/2;\n            fw.add(I,1);\n            seg.set(I,seg.get(I)+pw[l-I-1]);\n            SEG.set(I,SEG.get(I)+pw[I]);\n        }\n    }\n    cout<<ans.val()<<'\\n';\n\n\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "\nusing namespace std;\n\n#define visual\n\n#ifdef visual\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <assert.h>\n#include <functional>\n#include <math.h>\n#include <string>\n#include <ctime>\n#endif\n#ifndef visual\n#include <bits/stdc++.h>\n#endif\n\ntypedef long long ll;\n\n\ntemplate< int mod >\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt& operator+=(const ModInt& p) {\n        if ((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt& operator-=(const ModInt& p) {\n        if ((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt& operator*=(const ModInt& p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt& operator/=(const ModInt& p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt& p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt& p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt& p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt& p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt& p) const { return x == p.x; }\n\n    bool operator!=(const ModInt& p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while (b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while (n > 0) {\n            if (n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream& operator<<(ostream& os, const ModInt& p) {\n        return os << p.x;\n    }\n\n    friend istream& operator>>(istream& is, ModInt& a) {\n        int64_t t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt< 998244353 >;\n\n\n\nstruct segt {\n\n\tstruct node {\n\t\tmint t, mx, lazyby, lazyto, num, ex, lazytimes;\n\t\tll length, s, e;\n\t\tbool set;\n\t\tnode* l;\n\t\tnode* r;\n\t};\n\n\tnode* rt;\n\n\tvoid build(int i, int j, node* v) {\n\t\tv->mx = v->t = v->lazyby = v->lazyto = 0;\n\t\tv->length = j - i + 1;\n\t\tv->num = 0;\n\t\tv->lazytimes = 1;\n\t\tv->ex = 0;\n\t\tv->s = i;\n\t\tv->e = j;\n\t\tif (i == j) return;\n\t\tv->l = new node();\n\t\tv->r = new node();\n\t\tbuild(i, (i + j) / 2, v->l);\n\t\tbuild((i + j) / 2 + 1, j, v->r);\n\t}\n\n\tsegt() {}\n\tsegt(int n) {\n\t\trt = new node();\n\t\tbuild(0, n - 1, rt);\n\t}\n\n\tinline void prop(node* v) {\n\t\tif (v->l != nullptr) {\n\n\t\t\tv->l->lazytimes *= v->lazytimes;\n\t\t\tv->r->lazytimes *= v->lazytimes;\n\n\t\t}\n\t\tv->ex *= v->lazytimes;\n\t\tv->lazytimes = 1;\n\t}\n\n\tvoid update(int i, int j, mint val, bool prod, node* v) {\n\t\tif (j < v->s || v->e < i) return;\n\t\tif (i <= v->s && v->e <= j) {\n\t\t\tprop(v);\n\t\t\tif (prod) v->lazytimes *= val;\n\t\t\telse {\n\t\t\t\tv->num = 1;\n\t\t\t\tv->ex = val;\n\t\t\t}\n\t\t\tprop(v);\n\t\t\treturn;\n\t\t}\n\t\tprop(v);\n\t\tupdate(i, j, val, prod, v->l);\n\t\tupdate(i, j, val, prod, v->r);\n\t\tprop(v->l);\n\t\tprop(v->r);\n\t\tv->num = v->l->num + v->r->num;\n\t\tv->ex = v->l->ex + v->r->ex;\n\n\t}\n\n\tvoid updateprod(int i, int j, mint val) { update(i, j, val, true, rt); }\n\tvoid updateonce(int i, int j, mint val) { update(i, j, val, false, rt); }\n\n\n\tmint query(int i, int j, bool nums, node* v) {\n\t\tif (j < v->s || v->e < i) {\n\n\t\t\treturn 0;\n\t\t}\n\t\tprop(v);\n\t\tif (i <= v->s && v->e <= j) {\n\t\t\tif (nums) return v->num;\n\t\t\treturn v->ex;\n\t\t}\n\t\tmint l = query(i, j, nums, v->l);\n\t\tmint r = query(i, j, nums, v->r);\n\t\treturn l + r;\n\t}\n\n\tmint querynum(int i, int j) { return query(i, j, true, rt); }\n\tmint queryex(int i, int j) { return query(i, j, false, rt); }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n, k;\n\tcin >> n >> k;\n\tsegt s(n+1);\n\n\tmint ans;\n\tvector<int> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\t\n\t\tif (i >= k) {\n\t\t\ts.updateprod(0, n, ((mint)(k-1))/k);\n\t\t}\n\t\tans += s.queryex(1, x - 1);\n\t\tans += s.querynum(x + 1, n) - s.queryex(x + 1, n);\n\t\ts.updateonce(x, x, ((mint)1)/2);\n\t}\n\tcout << ans << endl;\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int MAX>\nstruct Combination {\n    vector<long long> _inv, _fac, _ifac;\n    const long long MOD;\n    Combination(long long mod) : _inv(MAX+1), _fac(MAX+1), _ifac(MAX+1), MOD(mod) { init(); }\n    inline void init() { init_inv(), init_fac(); }\n\n    inline void init_inv() {\n        _inv[0] = 0;\n        for (int i = 1; i <= MAX; i++) {\n            if (i == 1) _inv[i] = 1;\n            else {\n                _inv[i] = (MOD - (MOD / i) * _inv[MOD % i]) % MOD;\n                if (_inv[i] < 0) _inv[i] += MOD;\n            }\n        }\n    }\n    inline void init_fac() {\n        _fac[0] = _ifac[0] = 1;\n        for (int i = 1; i <= MAX; i++) {\n            _fac[i] = _fac[i-1] * i % MOD;\n            _ifac[i] = _ifac[i-1] * _inv[i] % MOD;\n        }\n    }\n\n    inline long long modpow(long long n, long long r) {\n        n %= MOD, r %= (MOD-1);\n        if (!n) return 0;\n        long long ret = 1; long long tmp = n;\n        while (r != 0) {\n            if (r % 2) ret *= tmp;\n            tmp *= tmp; tmp %= MOD; ret %= MOD;\n            r /= 2;\n        }\n        return ret;\n    }\n    inline long long invb(int i) const { return (i <= MAX) ? _inv[i] : this->modpow(i, MOD-2); }\n    inline long long inv(int i) const { return _inv[i]; }\n    inline long long fac(int i) const { return _fac[i]; }\n    inline long long ifac(int i) const { return _ifac[i]; }\n\n    long long operator()(int n, int r) const {\n        if (n < r) return 0;\n        return fac(n) * ifac(r) % MOD * ifac(n-r) % MOD;\n    }\n};\n\nconstexpr long long mod = 998244353;\n\n// zero-based numbering\ntemplate<class T> struct Fenwick {\n    vector<T> bit; int N;\n    Fenwick(int n) : N(n) { bit.assign(n+1, 0); }\n    // add w to a\n    void add(int a, T w) {\n        for (int x = ++a; x <= N; x += x & -x) bit[x] = (bit[x]+w) % mod;\n    }\n    // sum [0, a)\n    T sum(int a) {\n        T ret = 0;\n        for (int x = a; x > 0; x -= x & -x) ret = (ret + bit[x]) % mod;\n        return ret;\n    }\n    // sum [a, b)\n    T sum(int a, int b) { return (sum(b) - sum(a) + mod) % mod; }\n};\n\nint invsum(vector<int> v, int n){\n    vector<pair<int, int> > v_sort;\n    for (int i = 0; i < n; i++) {\n        v_sort.push_back(make_pair(v[i]-1, i));\n    }\n    sort(v_sort.begin(), v_sort.end());\n    for (int i = 0; i < n; i++) {\n        v[v_sort[i].second] = i;\n    }\n    Fenwick<int> b(n);\n    long long num = 0;\n    for (int i = 0; i < n; i++) {\n        num += b.sum(n) - b.sum(v[i]);\n        b.add(v[i], 1);\n    }\n    return num;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    Combination<500000> C(mod);\n    long long N, K; cin >> N >> K;\n    vector<int> V(N);\n    for (int i = 0; i < N; i++) cin >> V[i];\n    // cout << invsum(V, N) << \" \" << invsum(V, K) << \"\\n\";\n    long long Rw = (K - 1) * C.inv(K) % mod;\n    long long inv = K * C.inv(K - 1) % mod;\n    Fenwick<long long> F(N+1);\n    long long Cur = 1, CurInv = 1;\n    long long Ans = 0;\n    for (int i = 0; i < N; i++) {\n        if (i >= K) Cur = Cur * Rw % mod, CurInv = CurInv * inv % mod;\n        Ans += F.sum(V[i]) * Cur % mod;\n        Ans -= F.sum(V[i], N + 1) * Cur % mod;\n        Ans = (Ans % mod + mod) % mod;\n        // cout << F.sum(V[i]) * Cur % mod << \" \" << F.sum(V[i + K - 1], N + 1) * Cur % mod << \"\\n\";\n        F.add(V[i], CurInv);\n        // cout << i << \": \" << Ans << \" \" << Cur << \" \" << CurInv << \"\\n\";\n    }\n    cout << (Ans * C.inv(2) % mod + invsum(V, N)) % mod << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n_/_/_/_/    _/_/_/_/_/  _/_/_/\n_/      _/      _/    _/      _/\n_/      _/      _/    _/      _/\n_/      _/      _/    _/      _/\n_/      _/      _/    _/  _/  _/\n_/      _/  _/  _/    _/    _/_/\n_/_/_/_/      _/_/     _/_/_/_/_/\n\n_/_/_/_/    _/    _/  _/      _/\n_/      _/   _/  _/   _/_/  _/_/\n_/      _/    _/_/    _/ _/_/ _/\n_/      _/     _/     _/  _/  _/\n_/      _/    _/_/    _/      _/\n_/      _/   _/  _/   _/      _/\n_/_/_/_/    _/    _/  _/      _/\n\n_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/\n    _/         _/     _/\n    _/         _/     _/\n    _/         _/     _/_/_/_/\n    _/         _/     _/\n    _/         _/     _/\n    _/     _/_/_/_/_/ _/_/_/_/_/\n\n_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/\n    _/         _/     _/\n    _/         _/     _/\n    _/         _/     _/_/_/_/\n    _/         _/     _/\n    _/         _/     _/\n    _/     _/_/_/_/_/ _/_/_/_/_/\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (T &x : v)\n    is >> x;\n  return is;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int P = 998244353;\n\nint norm(int x) { return x >= P ? (x - P) : x; }\n\nvoid add(int &x, int y) { if ((x += y) >= P) x -= P; }\n\nvoid sub(int &x, int y) { if ((x -= y) < 0) x += P; }\n\nvoid exGcd(int a, int b, int &x, int &y) {\n  if (!b) {\n    x = 1;\n    y = 0;\n    return;\n  }\n  exGcd(b, a % b, y, x);\n  y -= a / b * x;\n}\n\nint inv(int a) {\n  int x, y;\n  exGcd(a, P, x, y);\n  return norm(x + P);\n}\n\nconst int N = 200010;\n\nstruct Node {\n  int p, s;\n} Q[N << 2];\n\nvoid apply(int o, int x) {\n  Q[o].p = Q[o].p * (ll) x % P;\n  Q[o].s = Q[o].s * (ll) x % P;\n}\n\nvoid pd(int o) {\n  if (Q[o].p != 1) {\n    apply(o << 1, Q[o].p);\n    apply(o << 1 | 1, Q[o].p);\n    Q[o].p = 1;\n  }\n}\n\nvoid upd(int o) {\n  Q[o].s = norm(Q[o << 1].s + Q[o << 1 | 1].s);\n}\n\nvoid sval(int o, int l, int r, int k, int x) {\n  if (l == r) {\n    Q[o].s = x;\n    return;\n  }\n  pd(o);\n  int mid = (l + r) >> 1;\n  if (k <= mid)sval(o << 1, l, mid, k, x); else sval(o << 1 | 1, mid + 1, r, k, x);\n  upd(o);\n}\n\nint qry(int o, int l, int r, int ql, int qr) {\n  if (l == ql && r == qr)return Q[o].s;\n  pd(o);\n  int mid = (l + r) >> 1;\n  if (qr <= mid)return qry(o << 1, l, mid, ql, qr);\n  if (ql > mid)return qry(o << 1 | 1, mid + 1, r, ql, qr);\n  return norm(qry(o << 1, l, mid, ql, mid) + qry(o << 1 | 1, mid + 1, r, mid + 1, qr));\n}\n\nint fw[N];\n\nint n;\n\nvoid ad(int k, int x) {\n  for (; k <= n; k += k & -k)fw[k] += x;\n}\n\nint qry(int k) {\n  int ret = 0;\n  for (; k; k &= k - 1)ret += fw[k];\n  return ret;\n}\n\nint p[N];\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) cin >> p[i];\n  int ans = 0;\n  int I2 = inv(2);\n  for (int i = 1; i < k; ++i) {\n    ad(p[i], 1);add(ans, (i - 1) * (ll) I2 % P);\n    sval(1, 1, n, p[i], 1);\n  }\n  int mu = (k - 1LL) * inv(k) % P;\n  for (int i = k; i <= n; ++i) {\n    int lcnt = qry(p[i]);\n    int lsum = qry(1, 1, n, 1, p[i]);\n    int rcnt = i - 1 - lcnt, rsum = norm(P + (k - 1) - lsum);\n    add(ans, (k - 1) * (ll) I2 % P);\n    add(ans, norm(P + rcnt - rsum));\n    ad(p[i], 1);\n    sval(1, 1, n, p[i], 1);\n    apply(1, mu);\n  }\n  cout << ans << '\\n';\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <atcoder/all>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <sys/types.h>\n#include <unistd.h>\n#include <vector>\n\n#pragma region macros\n#define _overload(_1, _2, _3, name, ...) name\n#define _rep(i, n) _range(i, 0, n)\n#define _range(i, a, b) for (int i = int(a); i < int(b); ++i)\n#define rep(...) _overload(__VA_ARGS__, _range, _rep, )(__VA_ARGS__)\n#define _rrep(i, n) _rrange(i, n, 0)\n#define _rrange(i, a, b) for (int i = int(a) - 1; i >= int(b); --i)\n#define rrep(...) _overload(__VA_ARGS__, _rrange, _rrep, )(__VA_ARGS__)\n#pragma endregion macros\n\nusing namespace std;\nusing namespace atcoder;\n\ntemplate <class T> bool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\n\nusing ll    = long long;\nusing R     = long double;\nconst R EPS = 1e-9L;  // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R &r) {\n    return (r > EPS) - (r < -EPS);\n}\ninline R sq(R x) {\n    return sqrt(max(x, 0.0L));\n}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nusing mint = modint998244353;\n\nint main(void) {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> p(n);\n    rep(i, n) cin >> p[i], p[i]--;\n\n    vector<int> coef(n);\n    rep(i, n) coef[i] = max(i - k + 1, 0);\n\n    mint ans = mint::raw(0);\n\n\n    vector<int> idx(n);\n    rep(i, n) idx[p[i]] = i;\n\n    fenwick_tree<mint> small(n), large(n), num(n);\n\n    const mint a = mint::raw(k - 1) / mint::raw(k);\n\n    rep(i, n) {\n        const int pos  = idx[i];\n        const mint val = a.pow(coef[pos]);\n        ans += val * small.sum(0, pos) / mint::raw(2);\n        small.add(pos, val.inv());\n    }\n\n    rrep(i, n) {\n        const int pos  = idx[i];\n        const mint val = a.pow(coef[pos]);\n        ans += num.sum(0, pos);\n        ans -= val * large.sum(0, pos) / mint::raw(2);\n        num.add(pos, mint::raw(1));\n        large.add(pos, val.inv());\n    }\n\n    cout << ans.val() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/fenwicktree>\n\nusing namespace std;\nusing namespace atcoder;\n\nconst int max_n = 200222, mod = 998244353;\n\nint mul(int x, int y) {\n    return (1LL * x * y) % mod;\n}\n\nint power(int a, int b) {\n    int res = 1 % mod;\n    while (b) {\n        if (b % 2) {\n            res = mul(res, a);\n        }\n        b /= 2;\n        a = mul(a, a);\n    }\n    return res;\n}\n\nint inv(int x) {\n    return power(x, mod - 2);\n}\n\nint n, k, a[max_n];\n\nint solve() {\n    fenwick_tree<long long> t1(n), t2(n);\n    const int rk = inv(k);\n    const int r2 = inv(2);\n    const int A = mul(k - 1, rk), B = mul(k - 2, rk);\n    const int RA = inv(A);\n    const int C = inv((B + mod - 1) % mod);\n    const int D = (r2 + mul(rk, C)) % mod;\n    const int E = (mod - mul(rk, C)) % mod;\n    int ans = 0;\n    for (int j = 0; j < n; ++j) {\n        const int F = (mul(power(B, n - j - 1), D) + E) % mod;\n        int sum = 0;\n        if (j < k) {\n            sum = t1.sum(0, a[j]) % mod;\n            /*for (int i = 0; i < j; ++i) {\n                sum += a[i] < a[j];\n            }*/\n        } else {\n            /*for (int i = 0; i < j; ++i) {\n                if (a[i] > a[j]) {\n                    continue;\n                }\n                sum += power(RA, max(i, k - 1));\n                sum %= mod;\n            }*/\n            sum = t2.sum(0, a[j]) % mod;\n            sum = mul(sum, power(A, j));\n        }\n        ans += mul(F, sum);\n        ans %= mod;\n        t1.add(a[j], 1);\n        t2.add(a[j], power(RA, max(j, k - 1)));\n    }\n    return ans;\n}\n\nint cinv() {\n    fenwick_tree<long long> t(n);\n    long long res = 0;\n    for (int i = 0; i < n; ++i) {\n        res += t.sum(a[i], n);\n        t.add(a[i], 1);\n    }\n    return res % mod;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    if (0) {\n        n = 200000;\n        k = 100000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = i;\n        }\n        random_shuffle(a, a + n);\n    } else {\n        scanf(\"%d%d\", &n, &k);\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d\", &a[i]);\n            --a[i];\n        }\n    }\n    int ans = cinv();\n    ans += solve();\n    ans %= mod;\n    for (int i = 0; i < n; ++i) {\n        a[i] = n - 1 - a[i];\n    }\n    ans += mod - solve();\n    ans %= mod;\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n\n\nll modpower(ll a, ll r, ll mod){ //a^r\n    ll x = 1;\n    a %= mod;\n    while (r > 0) {\n        if (r & 1) x = x * a % mod;\n        r >>= 1;\n        a = a * a % mod;\n    }\n    return x;\n}\n\nll modinv(ll a, ll mod){\n    return modpower(a, mod-2, mod);\n}\n\nclass BIT{\n    public:\n    int size;\n    vector<ll> tree;\n    \n    void set(int n){\n        size = n;\n        tree = vector<ll>(n+1, 0);\n        return;\n    }\n    \n    void add(int n, ll a) {\n        int x = n;\n        while (x <= size){\n            tree[x] += a;\n            x += (x & -x);\n        }\n        return;\n    }\n    \n    ll getsum(int n) {\n        int x = n;\n        ll sum = 0;\n        while (x > 0) {\n            sum += tree[x];\n            x -= (x & -x);\n        }\n        return sum;\n    }\n    \n};\n\nint main() {\n    ll N, K;\n    cin >> N >> K;\n    ll mod = 998244353;\n    vector<ll> p(N+1, 0);\n    for (int i = 1; i <= N; i++) cin >> p[i];\n    \n    vector<ll> pow(N+1, 1);\n    pow[1] = K*modinv(K-1, mod) % mod;\n    for (int i = 2; i <= N; i++) {\n        pow[i] = pow[i-1]*pow[1]%mod;\n    }\n    \n    ll inv2 = modinv(2, mod);\n    \n    BIT bit1, bit2;\n    bit1.set(N+1);\n    bit2.set(N+1);\n    ll ans = 0;\n    for (ll i = 1; i <= N; i++) {\n        if (i <= K) {\n            ans += (i-1)*inv2%mod;\n            bit1.add(p[i], 1);\n            bit2.add(p[i], 1);\n            continue;\n        }\n        \n        ans += bit2.getsum(p[i]) % mod * modinv(pow[i-K], mod) % mod * inv2 % mod;\n        \n        ans += i-1-bit1.getsum(p[i]);\n        ans += mod-(bit2.getsum(N)-bit2.getsum(p[i])) % mod * modinv(pow[i-K], mod) % mod * inv2 % mod;\n        ans %= mod;\n        \n        bit1.add(p[i], 1);\n        bit2.add(p[i], pow[i-K]);\n    }\n    \n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <atcoder/all>\n// #include <bits/stdc++.h> \n#include <complex>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <list>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n\nusing namespace std;\nusing namespace atcoder;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> p32;\ntypedef pair<ll,ll> p64;\ntypedef pair<double,double> pdd;\ntypedef vector<ll> v64;\ntypedef vector<int> v32;\ntypedef vector<vector<int> > vv32;\ntypedef vector<vector<ll> > vv64;\ntypedef vector<vector<p64> > vvp64;\ntypedef vector<p64> vp64;\ntypedef vector<p32> vp32;\nll MOD = 998244353;\ndouble eps = 1e-12;\n#define forn(i,e) for(ll i = 0; i < e; i++)\n#define forsn(i,s,e) for(ll i = s; i < e; i++)\n#define rforn(i,s) for(ll i = s; i >= 0; i--)\n#define rforsn(i,s,e) for(ll i = s; i >= e; i--)\n#define ln '\\n'\n#define dbg(x) cout<<#x<<\" = \"<<x<<ln\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF 101\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n#define zero ll(0)\n#define set_bits(x) __builtin_popcountll(x)\n \nll mpow(ll a, ll b){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2);\n\tt1 *= t1;\n\tt1 %= MOD;\n\tif(b%2) t1 *= a;\n\tt1 %= MOD;\n\treturn t1;\n}\n \nll mpow(ll a, ll b, ll p){\n\tif(a==0) return 0;\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2,p);\n\tt1 *= t1;\n\tt1 %= p;\n\tif(b%2) t1 *= a;\n\tt1 %= p;\n\treturn t1;\n}\n \nll modinverse(ll a, ll m){\n\tll m0 = m; \n    ll y = 0, x = 1; \n    if (m == 1) return 0; \n    while (a > 1){\n        ll q = a / m; \n        ll t = m; \n        m = a % m, a = t; \n        t = y; \n        y = x - q * y; \n        x = t; \n    }\n    if (x < 0) x += m0; \n    return x; \n}\n\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n \nll range(ll l, ll r){\n\treturn l + mt()%(r-l+1);\n}\n \nll rev(ll v){\n\treturn mpow(v,MOD-2);\n}\n\n\nvoid solve(){\n\tll n,k;\n\tcin >> n >> k;\n\tfenwick_tree<long long> fw1(n),fw2(n);\n\tll sum = 0;\n\tll cur = 1;\n\tll fact = (k-1)*rev(k);\n\tfact %= MOD;\n\tv64 val(n,0);\n\tv64 den(n,k);\n\tforsn(i,k,n){\n\t\tsum += cur;\n\t\tsum %= MOD;\n\t\tcur *= fact;\n\t\tcur %= MOD;\n\t\tden[i]*=cur;\n\t\tden[i]%=MOD;\n\t\tfw1.add(i,sum);\n\t\tval[i]=sum;\n\t}\n\tforn(i,n){\n\t\tden[i]=rev(den[i]);\n\t\tfw2.add(i,1);\n\t}\n\tll ans = (n*(n-1))/2;\n\tans %= MOD;\n\tll pr[n];\n\tforn(i,n){\n\t\tll t;\n\t\tcin >> t;\n\t\tpr[t-1]=i;\n\t}\n\trforn(i,n-1){\n\t\tll cur = pr[i];\n\t\tll sum = fw1.sum(cur+1,n);\n\t\tll cnt = fw2.sum(cur+1,n);\n\t\tll cans = sum - cnt*val[cur];\n\t\tcans %= MOD;\n\t\tcans *= den[cur];\n\t\tcans %= MOD;\n\t\tans += cans;\n\t\tfw1.add(cur,-2*val[cur]);\n\t\tfw2.add(cur,-2);\n\t}\n\tans %= MOD;\n\tif(ans<0) ans+=MOD;\n\tans *= rev(2);\n\tans %= MOD;\n\tcout << ans << ln;\n}\n \nint main()\n{\n\tfast_cin();\n\tll t=1;\n    // cin >> t;\n    forn(i,t) {\n    \t// cout << \"Case #\" << i+1 << \": \";\n    \tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include<bits/extc++.h>\n#define int long long\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define rep(i,n) for (int i=0;i<(int)(n);++i)\n#define rep1(i,n) for (int i=1;i<=(int)(n);++i)\n#define range(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define F first\n#define S second\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> VL;\n\n\nll power(ll u,ll v,ll mod){\n    ll ret=1,t=u%mod;\n    while (v){\n        if (v&1) ret=t*ret%mod;\n        t=t*t%mod, v>>=1;\n    }\n    return ret%mod;\n}\n \n/*\n计算gcd(a,b)并找寻ax+by=gcd(a,b)的一组解\nret=exgcd(a,b,x,y); \n*/\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if (b){\n        ll d=exgcd(b,a%b,y,x);\n        return y-=a/b*x, d;\n    }\n    return x=1,y=0,a;\n}\n \n/*\n计算x=a(mod m), x=b(mod n)的一组解，若无解返回-1\nret=crt(a,m,b,n);\n*/\nll crt(ll a,ll m,ll b,ll n){\n    if (n>m) swap(a,b), swap(n,m);\n    ll x,y,g=exgcd(m,n,x,y);\n    if ((b-a)%g) return -1;\n    x=(b-a)%n*x%n/g*m+a;\n    return x<0?x+m*n/g:x;\n}\n \n/*\n生成<=n的质数\ngen_prime<5000>(ret);\n*/\n \nvoid gen_prime(int n,vi &ret){\n    vector<bool> p;\n    p.resize(n+1,1);\n    p[0]=p[1]=0;\n    for (int i=4;i<=n;i+=2) p[i]=0;\n    for (int i=3;i*i<=n;i+=2){\n        if (p[i]){\n            for (int j=i*i;j<=n;j+=2*i){\n                p[j]=0;\n            }\n        }\n    }\n    for (int i=2;i<=n;++i){\n        if (p[i]) ret.pb(i);\n    }\n}\n \n/*\n生成<=n的phi\ngen_phi<5000>(ret);\n*/\nvoid gen_phi(int n,vi &phi){\n    phi.resize(n+1);\n    for (int i=0;i<=n;++i) phi[i]=i&1?i:i/2;\n    for (int i=3;i<=n;i+=2){\n        if (phi[i]==i){\n            for (int j=i;j<=n;j+=i) phi[j]-=phi[j]/i;\n        }\n    }\n}\n \n/*\n支持更高的快速幂操作\nexpower.mod_pow(a,b,mod);\n*/\n \nstruct expower{\n    ull mod_mul(ull a,ull b,ull M) {\n        ll ret=a*b-M*ull(ld(a)* ld(b)/ld(M));\n        return ret+M*(ret<0)-M*(ret>=(ll)M);\n    }\n    ull mod_pow(ull b,ull e,ull mod) {\n        ull ans=1;\n        for (; e; b=mod_mul(b,b,mod), e/=2)\n            if (e&1) ans=mod_mul(ans,b,mod);\n        return ans%mod;\n    }\n}expower;\n \n/*\nMiller-Rubin素数判别\nis_prime(n);\n*/\nbool is_prime(ull n){ \n    if (n<2||n%6%4!=1) return n-2<2;\n    ull A[]={2,325,9375,28178,450775,9780504,1795265022},\n    s=__builtin_ctzll(n-1), d = n >> s;\n    for (auto a:A){\n        ull p=expower.mod_pow(a,d,n),i=s;\n        while (p!=1&&p!=n-1&&a%n&&i--)\n            p=expower.mod_mul(p,p,n);\n        if (p!=n-1&&i!=s) return 0;\n    }\n    return 1;\n}\n \n/*\n素因数分解\nret=factorization(n);\n*/\null pollard(ull n){\n    auto f=[n](ull x){return (expower.mod_mul(x,x,n)+1)%n;};\n    if (!(n&1)) return 2;\n    for (ull i=2;;i++){\n        ull x=i,y=f(x),p;\n        while ((p=__gcd(n+y-x,n))==1)\n            x=f(x),y=f(f(y));\n        if (p!=n) return p;\n    }\n}\n \nvector<ull> factorization(ull n){\n    if (n==1) return {};\n    if (is_prime(n)) return {n};\n    ull x=pollard(n);\n    auto l=factorization(x),r=factorization(n/x);\n    l.insert(l.end(),range(r));\n    return l;\n}\n \nstruct DSU{\n    //insert info.\n    vector<int> p;\n    DSU(int n){\n        p.resize(n+1);\n        for (int i=1;i<=n;++i) p[i]=i;\n    }\n    int find(int u){\n        if (p[u]==u) return u;\n        return p[u]=find(find(p[u]));\n    } \n    bool unite(int u,int v){\n        int pu=find(u), pv=find(v);\n        if (pu!=pv){\n            p[pu]=pv;\n        }\n        return pu!=pv;\n    }\n};\n \n/* (u,v,w) */\ntemplate<class T> vector<tuple<int,int,T> > MST(int n,vector<tuple<int,int,T> >g){\n    vector<tuple<int,int,T> > ret;\n    ret.clear();\n    DSU dsu(n);\n    auto cmp=[&](tuple<int,int,T> x,tuple<int,int,T> y){\n        int ux,uy,vx,vy;\n        T wx,wy;\n        tie(ux,vx,wx)=x, tie(uy,vy,wy)=y;\n        return wx<wy;\n    };\n    sort(range(g),cmp);\n    for (auto c:g){\n        int u,v;\n        T w;\n        tie(u,v,w)=c;\n        if(dsu.unite(u,v)) ret.push_back(c);\n    }\n    return ret;\n}\n \ntemplate<int n,class T>\nstruct SegmentTree{\n    typedef struct{\n        T lz,mx,mn,sum;\n    }Node;\n    vector<Node> tree;\n    SegmentTree(){\n        tree.resize((n+7)<<2);\n    }  \n    void pushup(int num){\n        tree[num].mx=max(tree[num<<1].mx,tree[num<<1|1].mx);\n        tree[num].mn=min(tree[num<<1].mn,tree[num<<1|1].mn);\n        tree[num].sum=tree[num<<1].sum+tree[num<<1|1].sum;\n    }\n    void pushdown(int num,int l,int r,int md){\n        if (tree[num].lz){\n            tree[num<<1].mx+=tree[num].lz;\n            tree[num<<1|1].mx+=tree[num].lz;\n            tree[num<<1].mn+=tree[num].lz;\n            tree[num<<1|1].mn+=tree[num].lz;\n            tree[num<<1].sum+=tree[num].lz*(md-l+1);\n            tree[num<<1|1].sum+=tree[num].lz*(r-md);\n            tree[num<<1].lz+=tree[num].lz;\n            tree[num<<1|1].lz+=tree[num].lz;\n            tree[num].lz=0;\n        }\n    }\n    void update1(int num,int l,int r,int L,int R,T val){\n        if (L<=l&&r<=R){\n            tree[num].mx+=val;\n            tree[num].mn+=val;\n            tree[num].sum+=val*(r-l+1);\n            tree[num].lz+=val;\n            return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=L) update1(num<<1,l,md,L,R,val);\n        if (md<R) update1(num<<1|1,md+1,r,L,R,val);\n        pushup(num);\n    }\n    tuple<T,T,T> query1(int num,int l,int r,int L,int R){\n        if (L<=l&&r<=R){\n            return {tree[num].mn,tree[num].mx,tree[num].sum};\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=R){\n            return query1(num<<1,l,md,L,R);\n        }\n        else{\n            if (md<L){\n                return query1(num<<1|1,md+1,r,L,R);\n            }\n            else{\n                tuple<T,T,T> ret1=query1(num<<1,l,md,L,R), ret2=query1(num<<1|1,md+1,r,L,R);\n                T a,b,c,d,e,f;\n                tie(a,b,c)=ret1, tie(d,e,f)=ret2;\n                return {min(a,d),max(b,e),c+f};\n            }\n        } \n    }\n    void update(int L,int R,int w){\n        update1(1,1,n,L,R,w);\n    }\n    tuple<T,T,T> query(int L,int R){\n        return query1(1,1,n,L,R);\n    }\n    void debug1(int num,int l,int r){\n        if (l==r){\n            cout<<tree[num].mn<<\" \"; return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        debug1(num<<1,l,md);\n         debug1(num<<1|1,md+1,r);        \n    }\n    void debug(){\n        debug1(1,1,n);\n        cout<<endl;\n    }\n};\n \nstruct XORBasis{\n    int n;\n    vector<ull> p;\n    vector<ull> ans;\n    XORBasis(int k):n(k){\n        p.resize(k+1);\n    }\n    void rebuilt(){\n        ans.clear();\n        for (int i=0;i<=n;++i){\n            if (p[i]) ans.push_back(p[i]);\n        }\n    }\n    void insert(ull u){\n        for (int i=n;i>=0;--i){\n            if (u&(1ull<<i)){\n                if (p[i]) u^=p[i];\n                else{\n                    p[i]=u;\n                    for (int j=i-1;j>=0;--j){\n                        if (p[i]&(1ull<<j)) p[i]^=p[j];\n                    }\n                    for (int j=i+1;j<=n;++j){\n                        if (p[j]&(1ull<<i)) p[j]^=p[i];\n                    }\n                    break;\n                }\n            }\n        }\n        rebuilt();\n    }\n    bool check(ull u){\n        for (int i=n;i>-1;--i){\n            if (u&(1ull<<i)) u^=p[i];\n        }\n        return (u==0);\n    }\n    ull kth(ull t){ // the k-th smallest, excluding 0.\n        if (t>=(1ull<<sz(ans))) return -1;\n        ull ret=0;\n        for (int i=0;i<sz(ans);++i){\n            if (t&(1ull<<i)) ret^=ans[i];\n        }\n        return ret;\n    }\n    ull total(){\n        return (1ull<<sz(ans));\n    }\n};\n \n \nvi pi(const string& s) {\n\tvi p(sz(s));\n\tfor (int i=1;i<=sz(s);++i) {\n\t\tint g = p[i-1];\n\t\twhile (g && s[i] != s[g]) g = p[g-1];\n\t\tp[i] = g + (s[i] == s[g]);\n\t}\n\treturn p;\n}\n \nvi match(const string& s, const string& pat) {\n\tvi p = pi(pat + '\\0' + s), res;\n\tfor(int i=sz(p)-sz(s);i<=sz(p);++i)\n\t\tif (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));\n\treturn res;\n}\n \n \nstruct AhoCorasick {\n\tenum {alpha = 26, first = 'a'};\n\tstruct Node {\n\t\t// (nmatches is optional)\n\t\tint back, next[alpha], start = -1, end = -1;\n        ll nmatches = 0;\n\t\tNode(int v) { memset(next, v, sizeof(next)); }\n\t};\n\tvector<Node> N;\n\tvector<int> backp;\n\tvoid insert(string& s, int j,ll val) {\n\t\tassert(!s.empty());\n\t\tint n = 0;\n\t\tfor(auto c:s) {\n\t\t\tint& m = N[n].next[c - first];\n\t\t\tif (m == -1) { n = m = sz(N); N.emplace_back(-1); }\n\t\t\telse n = m;\n\t\t}\n\t\tif (N[n].end == -1) N[n].start = j;\n\t\tbackp.push_back(N[n].end);\n\t\tN[n].end = j;\n\t\tN[n].nmatches+=val;\n\t}\n\tAhoCorasick(vector<string>& pat,vi val) {\n\t\tN.emplace_back(-1);\n\t\tfor (int i=0;i<sz(pat);++i) insert(pat[i], i, val[i]);\n\t\tN[0].back = sz(N);\n\t\tN.emplace_back(0);\n \n\t\tqueue<int> q;\n\t\tfor (q.push(0); !q.empty(); q.pop()) {\n\t\t\tint n = q.front(), prev = N[n].back;\n\t\t\tfor (int i=0;i<alpha;++i) {\n\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];\n\t\t\t\tif (ed == -1) ed = y;\n\t\t\t\telse {\n\t\t\t\t\tN[ed].back = y;\n\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])\n\t\t\t\t\t\t= N[y].end;\n\t\t\t\t\tN[ed].nmatches += N[y].nmatches;\n\t\t\t\t\tq.push(ed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvi find(string& word,ll& ans) {\n\t\tint n = 0;\n\t\tvi res;\n\t\tfor(auto c:word) {\n\t\t\tn = N[n].next[c - first];\n\t\t\tres.push_back(N[n].end);\n\t\t\tans += N[n].nmatches;\n\t\t}\n\t\treturn res;\n\t}\n\tvector<vi> findAll(vector<string>& pat, string word) {\n\t\tll ans=0;\n        vi r = find(word,ans);\n\t\tvector<vi> res(sz(word));\n\t\tfor (int i=0;i<sz(word);++i) {\n\t\t\tint ind = r[i];\n\t\t\twhile (ind != -1) {\n\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);\n\t\t\t\tind = backp[ind];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n \nstruct HLD{\n    int n,cnt=0;\n    vector<vi> G;\n    vi par,dep,siz,son,top,dfn,rk; \n    //父亲节点，深度，子树大小，重子节点，重链头部，dfs序，dfs序对应的节点编号\n    HLD(vector<vi> g,int root=1):n(sz(g)),G(g),par(n+7),dep(n+7),siz(n+7,1),son(n+7,-1),top(n+7),dfn(n+7),rk(n+7){\n        dep[0]=-1, dfs1(root,0), dfs2(root,0,root);\n    }\n    void dfs1(int u,int p){\n        for (auto c:G[u]){\n            if (c==p) continue;\n            dep[c]=dep[u]+1, par[c]=u;\n            dfs1(c,u);\n            siz[u]+=siz[c];\n            if (son[u]==-1||siz[son[u]]<siz[c]) son[u]=c;\n        }\n    }\n    void dfs2(int u,int p,int tp){\n        top[u]=tp;\n        dfn[u]=++cnt;\n        rk[cnt]=u;\n        if (son[u]==-1) return;\n        dfs2(son[u],u,tp);\n        for (auto c:G[u]){\n            if (c==p||c==son[u]) continue;\n            dfs2(c,u,c);\n        }\n    }\n    int lca(int u,int v){\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                u=par[top[u]];\n            }\n            else{\n                v=par[top[v]];\n            }\n        }\n        return dep[u]>dep[v]?v:u;\n    }\n    vector<pii> find_seg(int u,int v){\n        vector<pii> ft,bk,res;\n        ft.clear(), bk.clear(), res.clear();\n//        cout<<top[u]<<\" \"<<top[v]<<endl;\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                ft.pb({u,top[u]});\n                u=par[top[u]];\n            }\n            else{\n                bk.pb({top[v],v});\n                v=par[top[v]];\n            }\n        }\n        ft.pb({u,v});\n        for (int i=0;i<sz(ft);++i) res.pb(ft[i]);\n        for (int i=sz(bk);i>0;--i) res.pb(bk[i-1]);\n        return res;\n    }\n};\n \nstruct BIT{\n    vi C; int n;\n    BIT(int n):n(n){C.resize(n+7,0);}\n    void update(int u,int w){\n        for (;u<=n;u+=u&(-u)) C[u]+=w;\n    }\n    int query(int u){\n        int res=0;\n        for (;u>0;u-=u&(-u)) res+=C[u];\n        return res; \n    }\n};\n\nvi topoSort(const vector<vi>& gr) {\n\tvi indeg(sz(gr)), ret;\n\tfor (auto& li : gr) for (int x : li) indeg[x]++;\n\tqueue<int> q; // use priority queue for lexic. smallest ans.\n\trep(i,sz(gr)) if (indeg[i] == 0) q.push(-i);\n\twhile (!q.empty()) {\n\t\tint i = -q.front(); // top() for priority queue\n\t\tret.push_back(i);\n\t\tq.pop();\n\t\tfor (int x : gr[i])\n\t\t\tif (--indeg[x] == 0) q.push(-x);\n\t}\n\treturn ret;\n}\n\nvi path;\nnamespace Eulerian {\n    const int N = 3, M = 3;\n    int t, n, m, tot, cc, hd[N], nxt[M], to[M], bh[M], vis[M], in[N], out[N], ans[M];\n    void add(int x, int y, int id) {\n        nxt[++tot] = hd[x];\n        hd[x] = tot;\n        to[tot] = y;\n        bh[tot] = id;\n        in[y]++;\n        out[x]++;\n    }\n    void dfs(int x) {\n        for (int i = hd[x]; i; i = hd[x]) {\n            while (i && vis[abs(bh[i])]) i = nxt[i];\n            hd[x] = i;\n            if (!i) break;\n            vis[abs(bh[i])] = 1;\n            dfs(to[i]), ans[++cc] = bh[i];\n        }\n    }\n \n    void init() {\n        memset(hd, 0, sizeof(hd));\n        memset(nxt, 0, sizeof(nxt));\n        memset(to, 0, sizeof(to));\n        memset(bh, 0, sizeof(bh));\n        memset(vis, 0, sizeof(vis));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n        memset(ans, 0, sizeof(ans));\n        t = 1;\n        n = 0;\n        m = 0;\n        tot = 0;\n        cc = 0;\n    }\n    bool solve() {\n        for (int i = 1; i <= n; i++)\n            if ((t == 1 && in[i] & 1)) {\n                return false;\n            }\n        dfs(to[1]);\n        if (cc < m) return false;\n        else {\n            path.clear();\n            for (int i = cc; i >= 1; i--) path.push_back(ans[i]);\n            return true;\n        }\n    }\n} // namespace Eulerian\n\nnamespace FWT{\n    //mod=-1 (no mod)\n    const int mod=-1;\n\n    inline int modadd(int a,int b){\n        a+=b;\n        if (mod==-1) return a;\n        a%=mod, a+=mod, a%=mod;\n        return a;\n    }\n\n    vi OR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j]=modadd(b[j],b[j^(1<<i)]*mode); \n            }\n        }\n        return b;\n    }\n    vi AND(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]*mode);\n            }\n        }\n        return b;\n    }\n    vi XOR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1){\n                    b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]);\n                    b[j]=modadd(b[j^(1<<i)],-2*b[j]);\n                    if (mode<0) {\n                        if (mod>0) b[j]=b[j]*power(2,mod-2,mod)%mod, b[j^(1<<i)]=b[j^(1<<i)]*power(2,mod-2,mod)%mod;\n                        else b[j]/=2, b[j^(1<<i)]/=2;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n}\n\nconst int maxn=200007;\nconst int mod=998244353;\n\nint inv(int u){\n    return power(u,mod-2,mod);\n}\nint mult(int u,int v){\n    return u*v%mod;\n}\nint n,k;\nint a[maxn],p[maxn],q[maxn];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin>>n>>k;\n    rep1(i,n) cin>>a[i],p[i]=i;\n    sort(p+1,p+n+1,[&](int u,int v){return a[u]<a[v];});\n    rep1(i,n) q[p[i]]=1;\n    BIT C(n),C0(n);\n    int ans=0,ans0=0;\n    rep1(i,n){\n        C.update(a[i],power(1+inv(k-1),max(0ll,i-k),mod));\n        C0.update(a[i],1);\n        int r=C.query(n)-C.query(a[i]);\n        if (r>0) ans=(ans+mult(r,power(1-inv(k)+mod,max(0ll,i-k),mod)))%mod;\n //       cout<<ans<<endl;\n        ans0=(ans0+C.query(n)-C.query(a[i]))%mod;\n    }\n    ans=(ans0-ans+mod)%mod;\n    int tmp=0;\n    tmp=k*(k-1)/2;\n    tmp%=mod;\n    for (int i=1;i<=n-k;++i){\n        tmp=(tmp+mult(k,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    for (int i=1;i<n-k;++i){\n        int w=n-k-i;\n        tmp=(tmp+mult(w,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    tmp=mult(tmp,inv(2));\n    cout<<(ans+tmp)%mod;\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <atcoder/all>\nusing namespace atcoder;\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing mint = modint998244353;\n\nostream& operator<<(ostream& out, mint m){\n  out << m.val();\n  return out;\n}\n\nstruct node{\n  mint sum,evinv;\n  int sumzw;\n};\n\nnode empty(){\n  return {0,0,0};\n}\n\nint n,k;\n\nnode lacz(node a,node b){\n  return { a.sum + b.sum, \n    a.evinv + b.evinv + a.sumzw * b.sum,\n    a.sumzw + b.sumzw};\n}\n\nnode mapping(mint x, node a){\n  return {a.sum * x, a.evinv * x, a.sumzw};\n}\nmint composition(mint x,mint y){\n  return x * y;\n}\nmint jeden(){\n  return 1;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> k;\n  lazy_segtree<node, lacz, empty , mint, mapping, composition, jeden> tree(\n    vector<node>(n,{0,0,1}));\n  \n  vector<int> p(n);\n  R(i,n){\n    cin >> p[i];\n    p[i]--;\n  }\n  R(i,k)tree.set(p[i], {1,0,0});\n  \n  mint kinv = mint(1) / k;\n  mint res = 0;\n  R(i,n-k){\n    res += tree.all_prod().evinv * kinv;\n    res += mint(k-1) / 2;\n    tree.apply(0, n, (k-1) * kinv);\n    tree.set(p[i+k], {1,0,0});\n  } \n  res += mint(k) * (k - 1) / 4;\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n_/_/_/_/    _/_/_/_/_/  _/_/_/\n_/      _/      _/    _/      _/\n_/      _/      _/    _/      _/\n_/      _/      _/    _/      _/\n_/      _/      _/    _/  _/  _/\n_/      _/  _/  _/    _/    _/_/\n_/_/_/_/      _/_/     _/_/_/_/_/\n\n_/_/_/_/    _/    _/  _/      _/\n_/      _/   _/  _/   _/_/  _/_/\n_/      _/    _/_/    _/ _/_/ _/\n_/      _/     _/     _/  _/  _/\n_/      _/    _/_/    _/      _/\n_/      _/   _/  _/   _/      _/\n_/_/_/_/    _/    _/  _/      _/\n\n_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/\n    _/         _/     _/\n    _/         _/     _/\n    _/         _/     _/_/_/_/\n    _/         _/     _/\n    _/         _/     _/\n    _/     _/_/_/_/_/ _/_/_/_/_/\n\n_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/\n    _/         _/     _/\n    _/         _/     _/\n    _/         _/     _/_/_/_/\n    _/         _/     _/\n    _/         _/     _/\n    _/     _/_/_/_/_/ _/_/_/_/_/\n*/\n#include <atcoder/all>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nusing mint = atcoder::modint998244353;\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, k;\n  cin >> n >> k;\n  mint p = mint(k - 1) / k;\n\n  atcoder::fenwick_tree<mint> fw(n), fw2(n);\n  mint ans = 0;\n  for (int i = 1; i < k; ++i) {\n    ans += mint(i - 1) / 2;\n    int pos; cin >> pos;\n    fw.add(pos - 1, 1);\n    fw2.add(pos - 1, 1);\n  }\n  for (int i = k; i <= n; ++i) {\n    ans += mint(k - 1) / 2;\n    int pos; cin >> pos;\n    mint cp = p.pow(i - k);\n    mint cnt = fw.sum(pos, n);\n    mint psum = fw2.sum(pos, n) * cp;\n    ans += cnt - psum;\n    fw.add(pos - 1, 1);\n    fw2.add(pos - 1, 1 / cp);\n  }\n  cout << ans.val() << '\\n';\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\n#include <utility>\n\n\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//atcoderのやつが動かないから違うやつを使う\n#include <algorithm>\n#include <utility>\n#include <type_traits>\n#include <cstdint>\n//永夜作\n#define mnt mint_base\nclass mint_base;\n//mint_base_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\nclass mint_base\n{\npublic:\n\tconstexpr mint_base operator+(const mint_base &other)const noexcept\n\t{auto v = *this;return v += other;}\n\tconstexpr mint_base operator-(const mint_base &other)const noexcept\n\t{auto v = *this;return v -= other;}\n\tconstexpr mint_base operator*(const mint_base &other)const noexcept\n\t{auto v = *this;return v *= other;}\n\tconstexpr auto operator/(const mint_base &other)const noexcept\n\t{auto v = *this;return v /= other;}\n\tconstexpr mint_base & operator+=(const mint_base &other) noexcept\n\t{a += other.a;if (mod <= a) { a -= mod; };return *this;}\n\tconstexpr mint_base & operator-=(const mint_base &other) noexcept\n\t{if (a >= other.a) {a -= other.a;}else {a = (a + mod) - other.a;}return *this;}\n\tconstexpr mint_base & operator*=(const mint_base &other) noexcept\n\t{a *= other.a;a %= mod;return *this;}\n\tconstexpr mint_base & operator/=(const mint_base &other) noexcept\n\t{return *this *= ~other;}\n\tconstexpr mint_base operator+()const noexcept { return *this; }\n\tconstexpr mint_base operator-()const noexcept\n\t{return{ mod - a, mod_value_tag{} };}\n\tconstexpr mint_base & operator++() noexcept\n\t{if (mod <= ++a) { a = 0; };return *this;}\n\tconstexpr mint_base & operator--() noexcept\n\t{if (a <= 0) { a = mod; };--a;return *this;}\n\tconstexpr mint_base operator++(int) noexcept\n\t{auto tmp = *this;++*this;return tmp;}\n\tconstexpr mint_base operator--(int) noexcept\n\t{auto tmp = *this;--*this;return tmp;}\n\tconstexpr mint_base operator~()const noexcept\n\t{return m_pow(*this, mod-2);}\n\tconstexpr mint_base & operator=(const mint_base &other) noexcept\n\t{a=other.a;return *this;}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{return a;}\n\tconstexpr explicit operator int()const noexcept\n\t{return a;}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{return (unsigned)a;}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{return mod;}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % mod) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tuint64_t a;\n};\n\n//mint_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x,uint64_t n)noexcept\n{\n\tmint_base res = 1;\n\twhile(n>0){\n\t\tif(n&1){res*=x;}\n\t\tx*=x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\nvector<mint_base> fla;//階乗が入る\nvoid fla_set(mint_base x)\n{\n\tfla.resize(((uint64_t)x)+1);\n\tfla[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x;i++){fla[i]=fla[i-1]*i;}\n}\nvector<mint_base> gya;//~fla[i] が入る\n\n//O(x+log mod)で求める O(xlogmod)より速い\nvoid fla_gya_set(mint_base x)\n{\n\tfla_set(x);\n\tgya.resize(((uint64_t)x)+1);\n\tgya[(uint64_t)x]=~fla[(uint64_t)x];\n\tfor(uint64_t i =(uint64_t)x;i>0;i--){gya[i-1]=gya[i]*i;}\n}\n\n//mint_base型のstreamへの出力\nstd::ostream& operator<<(std::ostream& os, mint_base i)\n{os<<(uint64_t)i;return os;}\n//mint_base型のstreamからの入力\nstd::istream& operator >> (std::istream& is, mint_base& i)\n{uint64_t tmp;is>>tmp;i=tmp;return is;}\n\n//BITはatcoderを使う\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = T;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\tU sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n  private:\n    int _n;\n    std::vector<U> data;\n\n    \n};\n\nint main(void){\n\tint n,K,i,j;cin>>n>>K;\n\tfenwick_tree<mint_base>ki(n+1);\n\tfenwick_tree<mint_base>uki(n+1);\n\tvector<int>p(n);\n\tvector<int>gya(n);\n\tfor(i=0;i<n;i++){cin>>p[i];p[i]--;gya[p[i]]=i;}\n\tmint_base Kaaa=K;\n\tmint_base R=(((mint_base)K)-1)/Kaaa;\n\tvector<mint_base>zyo(n+1);\n\tmint_base ans=((mint_base) 1)/2*K*(K-1)/2;\n\tzyo[0]=1;\n\tfor(i=1;i<=n;i++){zyo[i]=zyo[i-1]*R;}\n\tfor(i=0;i<n;i++){\n\t\tki.add(i,zyo[i]/2);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tint t=gya[i];\n\t\tchmax(t,K-1);\n\t\tans+=ki.sum(t+1,n)/zyo[t];\n\t\tans+=uki.sum(t+1,n);\n\t\tuki.add(t,1);\n\t\tki.add(t,-zyo[t]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nll mod=998244353;\nll lazy[N*4],seg[N*4];\nll power(ll n,ll k){\n    if (k==0) return 1;\n    if (k%2==1){\n        ll x=power(n,k/2);\n        return x*x%mod*n%mod;\n    }\n    ll x=power(n,k/2);\n    return x*x%mod;\n}\nvoid shift(ll nod){\n    seg[nod*2]*=lazy[nod];\n    seg[nod*2]%=mod;\n    lazy[nod*2]*=lazy[nod];\n    lazy[nod*2]%=mod;\n    seg[nod*2+1]*=lazy[nod];\n    seg[nod*2+1]%=mod;\n    lazy[nod*2+1]*=lazy[nod];\n    lazy[nod*2+1]%=mod;\n    lazy[nod]=1;\n}\nvoid upd(ll nod,ll l,ll r,ll L,ll R,ll val){\n    if (l>=R || L>=r) return ;\n    if (l>=L && r<=R){\n        lazy[nod]*=val;\n        seg[nod]*=val;\n        lazy[nod]%=mod;\n        seg[nod]%=mod;\n        return ;\n    }\n    ll mid=(r+l)/2;\n    shift(nod);\n    upd(nod*2,l,mid,L,R,val);\n    upd(nod*2+1,mid,r,L,R,val);\n    seg[nod]=seg[nod*2]+seg[nod*2+1];\n    seg[nod]%=mod;\n}\nvoid add(ll nod,ll l,ll r,ll id){\n    if (r-l==1){\n        seg[nod]=1;\n        return ;\n    }\n    ll mid=(r+l)/2;\n    shift(nod);\n    if (mid>id) add(nod*2,l,mid,id);\n    else add(nod*2+1,mid,r,id);\n    seg[nod]=seg[nod*2]+seg[nod*2+1];\n    seg[nod]%=mod;\n}\nll get(ll nod,ll l,ll r,ll L,ll R){\n    if (l>=R || L>=r) return 0;\n    if (l>=L && r<=R) return seg[nod];\n    shift(nod);\n    ll mid=(r+l)/2;\n    return get(nod*2,l,mid,L,R)+get(nod*2+1,mid,r,L,R);\n}\nll fen[N];\nvoid ad(ll idx,ll val){\n    for (;idx<N;idx+= idx & (-idx)) fen[idx]+=val;\n}\nll ge(ll idx){\n    ll s=0;\n    for (;idx;idx-= idx & (-idx)) s+=fen[idx];\n    return s;\n}\nll a[N];\nint32_t main(){\n    sync;\n    for (int i=0;i<N*4;i++){\n        lazy[i]=1;\n    }\n    ll n,k;\n    cin >> n >> k;\n    for (int i=1;i<=n;i++){\n        cin >> a[i];\n    }\n    ll ans=(k-1)*k/2;\n    ans%=mod;\n    ans*=power(2,mod-2);\n    ans%=mod;\n    ll z=(k-1)*power(k,mod-2)%mod;\n    for (int i=1;i<=n-k;i++){\n        ll cnt=n-i;\n        ll zz=power(z,i);\n        ans+=cnt*zz%mod*power(2,mod-2)%mod;\n        ans%=mod;\n    }\n    for (int i=1;i<=k;i++){\n        add(1,1,n+1,a[i]);\n        ad(a[i],1);\n    }\n    for (int i=k+1;i<=n;i++){\n        upd(1,1,n+1,1,n+1,z);\n        ll y=get(1,1,n+1,a[i],n+1);\n        y%=mod;\n        ll e=ge(N-1)-ge(a[i])+mod;\n        e%=mod;\n        //cout << e << endl;\n        ans+=e-y;\n        ans+=mod;\n        ans%=mod;\n        add(1,1,n+1,a[i]);\n        ad(a[i],1);\n    }\n    cout << ans%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 998244353\n#define N_MAX 10000000\nll fac[N_MAX+1], inv[N_MAX+1], finv[N_MAX+1];\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nll perm(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (fac[n]*finv[n-k])%P;\n}\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){ return (a * b)%P;}\nll mpow(ll a, ll b, ll p = -1){\n  ll ret = 1, num = a;\n  while(b>0){\n    if(b&1) ret = (ret*num)%p;\n    num = (num*num)%p;\n    b /= 2;\n  }\n  return ret;\n}\n\n\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 1);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = (node[i*2+1] + node[i*2+2])%P;\n    }\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 1) {\n            node[k] = (node[k] * lazy[k])%P;\n            if(r - l > 1) {\n                lazy[2*k+1] = (lazy[2*k+1] * lazy[k])%P;\n                lazy[2*k+2] = (lazy[2*k+2] * lazy[k])%P;\n            }\n            lazy[k] = 1;\n        }\n    }\n    void ml(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = (lazy[k] * x)%P;\n            eval(k, l, r);\n        }\n        else {\n            ml(a, b, x, 2*k+1, l, (l+r)/2);\n            ml(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = (node[2*k+1] + node[2*k+2])%P;\n        }\n    }\n\n    void add(ll x, int k){\n      getsum(k, k+1);\n      k += n-1;\n      node[k] = (node[k] + x)%P;\n      while(k){\n        k = (k-1)/2;\n        node[k] = (node[2*k+1] + node[2*k+2])%P;\n      }\n    }\n\n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr)%P;\n    }\n};\n\nstruct BIT{\n  ll M=1;\n  vector<ll> dat;\n  BIT(ll N){\n    if(N<=1) N = 2;\n    while(N>M) M*=2;\n    dat.resize(M*2-1, 0);\n  }\n  void update(ll x, ll k){\n    for(int i=k+1;i<=M;i+=(i&(-i))){\n      dat[i] += x;\n    }\n  }\n  ll sum(ll r){\n    ll ret = 0;\n    for(int k=r;k>0;k-=(k&(-k))) ret += dat[k];\n    return ret;\n  }\n\n  ll query(ll l, ll r){\n    return sum(r) - sum(l);\n  }\n};\n\nint main(){\n  ll n, k;std::cin >> n >> k;\n  init();\n  vll p(n);\n  re(i, n) {\n    scanf(\"%lld\", &p[i]);\n    p[i]--;\n  }\n  BIT bt(n);\n  LazySegmentTree seg(vll(n, 0));\n\n  ll ans = 0;\n  for(int i=0;i<k;i++){\n    //iまで到達する確率\n    ll lef = seg.getsum(0, p[i]);//巻き込まれて1/2   -> i<kなら1/2 異なれば\n    ll ri  = seg.getsum(p[i], n);//巻き込まれない or 巻き込まれて1/2\n    ll num = bt.query(p[i], n);\n    ll psum = ((lef * inv[2])%P + (ri * inv[2])%P + (num - ri + P)%P)%P;\n    ans = (ans + psum)%P;\n    seg.add(1, p[i]);\n    bt.update(1, p[i]);\n  }\n\n  ll x = ((k-1LL) * inv[k])%P;\n  for(int i=k;i<n;i++){\n    seg.ml(0, n+1, x);\n    //iまで到達する確率\n    ll lef = seg.getsum(0, p[i]);//巻き込まれて1/2   -> i<kなら1/2 異なれば\n    ll ri  = seg.getsum(p[i], n);//巻き込まれない or 巻き込まれて1/2\n    ll num = bt.query(p[i], n);\n    ll psum = ((lef * inv[2])%P + (ri * inv[2])%P + (num - ri + P)%P)%P;\n    //for(int j=0;j<n;j++) std::cout << seg.getsum(j, j+1) << (j==n-1?\"\\n\":\" \");\n    //std::cout << lef << \" \" << ri << '\\n';\n    ans = (ans + psum)%P;\n    seg.add(1, p[i]);\n    bt.update(1, p[i]);\n  }\n  std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n/*\n0-index\nfunctionの中を書いて使う\nsegtree<ll> seg(n, [](ll a, ll b){return a + b;}, 0);\n*/\ntemplate<typename T>\nstruct segtree{\n\tint n;\n\tvector<T> dat;\n\tT ZERO;\n\tfunction<T(T,T)> func;//要素と要素をマージする関数\n\n\tsegtree(int n_, function<T(T,T)> func_, T zero):func(func_), ZERO(zero){\n\t  n = 1;\n\t  while(n < n_)n*=2;\n\t  dat.resize(2*n);\n\t  for(int i = 0;i < 2*n;i++)dat[i] = ZERO;\n\t}\n\n\tvoid update(int k, T a){\n\t  k += n - 1;dat[k] = a;\n\t  while(k > 0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = func(dat[k*2+1],dat[k*2+2]);\n\t  }\n\t}\n\n\tvoid set(int k, T a) {\n\t\tk += n - 1;dat[k] = a;\n\t}\n\n\tvoid build(){\n\t\tfor(int i = n - 2;i >= 0;i--){\n\t\t\tdat[i] = func(dat[2 * i + 1], dat[2 * i + 2]);\n\t\t}\n\t}\n\n\tT get(int k){return dat[k+n-1];}\n\n\tT que(int a,int b){\n\t\tT L = ZERO,R = ZERO;\n\t\tint A = a + n - 1;\n\t\tint B = b + n - 1;\n\t\twhile(A < B){\n\t\t\tif((A & 1) == 0)L = func(L,dat[A++]);\n            if((B & 1) == 0)R = func(dat[--B],R);\n            A = A >> 1;\n            B = B >> 1;\n\t\t}\n\t\treturn func(L,R);\n\t}\n};\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\n#define MAX_K 333333\nvector<long long> fact(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(fact[0] != 1){\n\t\tfact[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)fact[i] = (fact[i-1] * i) % MOD;\n\t}\n    long long ret = fact[n];\n\tlong long tmp = (fact[r] * fact[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tll n, k;cin >> n >> k;\n\tsegtree<ll> seg_a(n + 2, [](ll a, ll b){return (a + b) % MOD;}, 0);\n\tsegtree<ll> seg_b(n + 2, [](ll a, ll b){return (a + b) % MOD;}, 0);\n\tll ans = 0;\n\tll seica = mod_div(1, 2);\n\tll base = 1;\n\n\tREP(i, n) {\n\t\tll a; cin >> a;\n\t\tif(i >= k)base = base * mod_div(k - 1, k) % MOD;\n\t\tans = (ans + seg_a.que(0, a) * base % MOD) % MOD;\n\t\tans = (ans + seg_b.que(a + 1, n + 1) * 1 - seg_a.que(a + 1, n + 1) * base % MOD + MOD) % MOD;\n\t\tseg_a.update(a, seica * mod_div(1, base) % MOD);\n\t\tseg_b.update(a, 1);\n\t\t//REP(j, n+1)cout << seg_a.que(j, j+1) << \" \";cout << endl;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"main.cpp\"\n\n/**\n * @title Template\n */\n\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n#include <cassert>\n\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/chmin_chmax.cpp\"\n\ntemplate <class T, class U>\nconstexpr bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) { lhs = rhs; return true; }\n  return false;\n}\n\ntemplate <class T, class U>\nconstexpr bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) { lhs = rhs; return true; }\n  return false;\n}\n\n/**\n * @title Chmin/Chmax\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/range.cpp\"\n\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/range.cpp\"\n\nclass range {\npublic:\n  class iterator {\n  private:\n    int64_t M_position;\n\n  public:\n    constexpr iterator(int64_t position) noexcept: M_position(position) { }\n    constexpr void operator ++ () noexcept { ++M_position; }\n    constexpr bool operator != (iterator other) const noexcept { return M_position != other.M_position; }\n    constexpr int64_t operator * () const noexcept { return M_position; }\n  };\n\n  class reverse_iterator {\n  private:\n    int64_t M_position;\n  \n  public:\n    constexpr reverse_iterator(int64_t position) noexcept: M_position(position) { }\n    constexpr void operator ++ () noexcept { --M_position; }\n    constexpr bool operator != (reverse_iterator other) const noexcept { return M_position != other.M_position; }\n    constexpr int64_t operator * () const noexcept { return M_position; }\n  };\n  \nprivate:\n  const iterator M_first, M_last;\n\npublic:\n  constexpr range(int64_t first, int64_t last) noexcept: M_first(first), M_last(std::max(first, last)) { }\n  constexpr iterator begin() const noexcept { return M_first; }\n  constexpr iterator end() const noexcept { return M_last; }\n  constexpr reverse_iterator rbegin() const noexcept { return reverse_iterator(*M_last - 1); } \n  constexpr reverse_iterator rend() const noexcept { return reverse_iterator(*M_first - 1); } \n};\n\n/**\n * @title Range\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/rev.cpp\"\n\n#include <type_traits>\n#include <iterator>\n#line 6 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/rev.cpp\"\n\ntemplate <class T>\nclass rev_impl {\npublic:\n  using iterator = decltype(std::rbegin(std::declval<T>()));\n\nprivate:\n  const iterator M_begin;\n  const iterator M_end;\n\npublic:\n  constexpr rev_impl(T &&cont) noexcept: M_begin(std::rbegin(cont)), M_end(std::rend(cont)) { }\n  constexpr iterator begin() const noexcept { return M_begin; }\n  constexpr iterator end() const noexcept { return M_end; }\n};\n\ntemplate <class T>\nconstexpr decltype(auto) rev(T &&cont) {\n  return rev_impl<T>(std::forward<T>(cont));\n}\n\n/**\n * @title Reverser\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/modular.cpp\"\n\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/ext_gcd.cpp\"\n\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/ext_gcd.cpp\"\n#include <cstdint>\n\nconstexpr std::pair<int64_t, int64_t> ext_gcd(int64_t a, int64_t b) {\n  if ((a %= b) == 0) return { b, 0 };\n  int64_t s = b, t = (a < 0 ? a + b : a);\n  int64_t m0 = 0, m1 = 1, tmp = 0;\n  while (t > 0) {\n    const auto u = s / t;\n    s -= t * u; m0 -= m1 * u;\n    tmp = s; s = t; t = tmp; tmp = m0; m0 = m1; m1 = tmp;\n  }\n  return { s, (m0 < 0 ? m0 + b / s : m0) };\n}\n\n/**\n * @title Extended GCD\n */\n#line 4 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/modular.cpp\"\n\n#line 8 \"/Users/kodamankod/Desktop/cpp_programming/Library/algebraic/modular.cpp\"\n#include <type_traits>\n\ntemplate <class Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using cover_type = uint64_t;\n \n  template <class T>\n  static constexpr value_type normalize(T value_) noexcept {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= Modulus::mod();\n      if (value_ == 0) return 0;\n      return Modulus::mod() - value_;\n    }\n    return value_ % Modulus::mod();\n  }\n\nprivate:\n  value_type value;\n\n  template <bool IsPrime, std::enable_if_t<IsPrime>* = nullptr>\n  constexpr modular inverse_helper() const noexcept { return power(*this, Modulus::mod() - 2); }\n  template <bool IsPrime, std::enable_if_t<!IsPrime>* = nullptr>\n  constexpr modular inverse_helper() const noexcept {\n    const auto tmp = ext_gcd(value, Modulus::mod());\n    assert(tmp.first == 1);\n    return modular(tmp.second);\n  }\n\npublic:\n  constexpr modular() noexcept : value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_) noexcept : value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() const noexcept { return static_cast<T>(value); }\n \n  constexpr value_type get() const noexcept { return value; }\n  constexpr value_type &extract() noexcept { return value; }\n  constexpr modular operator - () const noexcept { return modular(Modulus::mod() - value); }\n  constexpr modular operator ~ () const noexcept { return inverse(*this); }\n \n  constexpr modular operator + (const modular &rhs) const noexcept { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) noexcept { \n    if ((value += rhs.value) >= Modulus::mod()) value -= Modulus::mod(); \n    return *this; \n  }\n \n  constexpr modular operator - (const modular &rhs) const noexcept { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) noexcept { \n    if ((value += Modulus::mod() - rhs.value) >= Modulus::mod()) value -= Modulus::mod(); \n    return *this; \n  }\n \n  constexpr modular operator * (const modular &rhs) const noexcept { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) noexcept { \n    value = (cover_type) value * rhs.value % Modulus::mod();\n    return *this;\n  }\n \n  constexpr modular operator / (const modular &rhs) const noexcept { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) noexcept { return (*this) *= inverse(rhs); }\n \n  constexpr bool zero() const noexcept { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const noexcept { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const noexcept { return value != rhs.value; }\n \n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) { return stream << rhs.value; }\n  friend constexpr modular inverse(const modular &val) noexcept { return val.inverse_helper<Modulus::is_prime>(); }\n  friend constexpr modular power(modular val, cover_type exp) noexcept { \n    modular res(1);\n    for (; exp > 0; exp >>= 1, val *= val) if (exp & 1) res *= val;\n    return res;\n  }\n \n};\n \ntemplate <uint32_t Mod, bool IsPrime = true>\nstruct static_modulus { \n  static constexpr uint32_t mod() noexcept { return Mod; } \n  static constexpr bool is_prime = IsPrime;\n};\n\ntemplate <uint32_t Id = 0, bool IsPrime = false>\nstruct dynamic_modulus {\n  static uint32_t &mod() noexcept { static uint32_t val = 0; return val; }\n  static constexpr bool is_prime = IsPrime;\n};\n\ntemplate <uint32_t Mod>\nusing mint32_t = modular<static_modulus<Mod>>;\nusing rmint32_t = modular<dynamic_modulus<>>;\n\n/*\n * @title Modint\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/container/lazy_propagation_segment_tree.cpp\"\n\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/bit_operation.cpp\"\n\n#include <cstddef>\n#line 5 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/bit_operation.cpp\"\n\nconstexpr size_t bit_ppc(const uint64_t x) { return __builtin_popcountll(x); }\nconstexpr size_t bit_ctzr(const uint64_t x) { return x == 0 ? 64 : __builtin_ctzll(x); }\nconstexpr size_t bit_ctzl(const uint64_t x) { return x == 0 ? 64 : __builtin_clzll(x); }\nconstexpr size_t bit_width(const uint64_t x) { return 64 - bit_ctzl(x); }\nconstexpr uint64_t bit_msb(const uint64_t x) { return x == 0 ? 0 : uint64_t(1) << (bit_width(x) - 1); }\nconstexpr uint64_t bit_lsb(const uint64_t x) { return x & (-x); }\nconstexpr uint64_t bit_cover(const uint64_t x) { return x == 0 ? 0 : bit_msb(2 * x - 1); }\n\nconstexpr uint64_t bit_rev(uint64_t x) {\n  x = ((x >> 1) & 0x5555555555555555) | ((x & 0x5555555555555555) << 1);\n  x = ((x >> 2) & 0x3333333333333333) | ((x & 0x3333333333333333) << 2);\n  x = ((x >> 4) & 0x0F0F0F0F0F0F0F0F) | ((x & 0x0F0F0F0F0F0F0F0F) << 4);\n  x = ((x >> 8) & 0x00FF00FF00FF00FF) | ((x & 0x00FF00FF00FF00FF) << 8);\n  x = ((x >> 16) & 0x0000FFFF0000FFFF) | ((x & 0x0000FFFF0000FFFF) << 16);\n  x = (x >> 32) | (x << 32);\n  return x;\n}\n\n/**\n * @title Bit Operations\n */\n#line 2 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/monoid.cpp\"\n\n#include <type_traits>\n#line 5 \"/Users/kodamankod/Desktop/cpp_programming/Library/other/monoid.cpp\"\n#include <stdexcept>\n\ntemplate <class T, class = void>\nclass has_identity: public std::false_type { };\n\ntemplate <class T>\nclass has_identity<T, typename std::conditional<false, decltype(T::identity()), void>::type>: public std::true_type { };\n\ntemplate <class T>\nconstexpr typename std::enable_if<has_identity<T>::value, typename T::type>::type empty_exception() {\n  return T::identity();\n}\ntemplate <class T>\n[[noreturn]] typename std::enable_if<!has_identity<T>::value, typename T::type>::type empty_exception() {\n  throw std::runtime_error(\"type T has no identity\");\n}\n\ntemplate <class T, bool HasIdentity>\nclass fixed_monoid_impl: public T {\npublic:\n  using type = typename T::type;\n\n  static constexpr type convert(const type &value) { return value; }\n  static constexpr type revert(const type &value) { return value; }\n\n  template <class Mapping, class Value, class... Args>\n  static constexpr void operate(Mapping &&func, Value &value, const type &op, Args&&... args) {\n    value = func(value, op, std::forward<Args>(args)...);\n  }\n  template <class Constraint>\n  static constexpr bool satisfies(Constraint &&func, const type &value) {\n    return func(value);\n  }\n};\n\ntemplate <class T>\nclass fixed_monoid_impl<T, false> {\npublic:\n  class type {\n  public:\n    typename T::type value;\n    bool state;\n  \n    explicit constexpr type(): value(typename T::type { }), state(false) { }\n    explicit constexpr type(const typename T::type &value): value(value), state(true) { }\n  };\n\n  static constexpr type convert(const typename T::type &value) { return type(value); }\n  static constexpr typename T::type revert(const type &value) { \n    if (!value.state) throw std::runtime_error(\"attempted to revert identity to non-monoid\"); \n    return value.value; \n  }\n\n  static constexpr type identity() { return type(); }\n  static constexpr type operation(const type &v1, const type &v2) {\n    if (!v1.state) return v2;\n    if (!v2.state) return v1;\n    return type(T::operation(v1.value, v2.value));\n  }\n\n  template <class Mapping, class Value, class... Args>\n  static constexpr void operate(Mapping &&func, Value &value, const type &op, Args&&... args) {\n    if (!op.state) return;\n    value = func(value, op.value, std::forward<Args>(args)...);\n  }\n  template <class Constraint>\n  static constexpr bool satisfies(Constraint &&func, const type &value) {\n    if (!value.state) return false;\n    return func(value.value);\n  }\n};\n\ntemplate <class T>\nusing fixed_monoid = fixed_monoid_impl<T, has_identity<T>::value>;\n\n/**\n * @title Monoid Utility\n */\n#line 5 \"/Users/kodamankod/Desktop/cpp_programming/Library/container/lazy_propagation_segment_tree.cpp\"\n\n#line 11 \"/Users/kodamankod/Desktop/cpp_programming/Library/container/lazy_propagation_segment_tree.cpp\"\n\ntemplate <class CombinedMonoid>\nclass lazy_propagation_segment_tree {\npublic:\n  using structure       = CombinedMonoid;\n  using value_monoid    = typename CombinedMonoid::value_structure;\n  using operator_monoid = typename CombinedMonoid::operator_structure;\n  using value_type      = typename CombinedMonoid::value_structure::type;\n  using operator_type   = typename CombinedMonoid::operator_structure::type;\n  using size_type       = size_t;\n\nprivate:\n  using fixed_operator_monoid = fixed_monoid<operator_monoid>;\n  using fixed_operator_type   = typename fixed_operator_monoid::type;\n\n  class node_type {\n  public:\n    value_type    value;\n    fixed_operator_type lazy;\n    node_type(\n      const value_type    &value = value_monoid::identity(),\n      const fixed_operator_type &lazy = fixed_operator_monoid::identity()\n    ): value(value), lazy(lazy) { }\n  };\n\n  static void S_apply(node_type &node, const fixed_operator_type &op, const size_type length) {\n    fixed_operator_monoid::operate(structure::operation, node.value, op, length);\n    node.lazy = fixed_operator_monoid::operation(node.lazy, op);\n  }\n\n  void M_propagate(const size_type index, const size_type length) {\n    S_apply(M_tree[index << 1 | 0], M_tree[index].lazy, length);\n    S_apply(M_tree[index << 1 | 1], M_tree[index].lazy, length);\n    M_tree[index].lazy = fixed_operator_monoid::identity();\n  }\n  void M_fix_change(const size_type index) {\n    M_tree[index].value = \n      value_monoid::operation(M_tree[index << 1 | 0].value, M_tree[index << 1 | 1].value);\n  }\n\n  void M_pushdown(const size_type index) {\n    const size_type lsb = bit_ctzr(index);\n    for (size_type story = bit_width(index); story != lsb; --story) {\n      M_propagate(index >> story, 1 << (story - 1));\n    }\n  }\n  void M_pullup(size_type index) {\n    index >>= bit_ctzr(index);\n    while (index != 1) {\n      index >>= 1;\n      M_fix_change(index);\n    }\n  }\n\n  std::vector<node_type> M_tree;\n\npublic:\n  lazy_propagation_segment_tree() = default;\n  explicit lazy_propagation_segment_tree(const size_type size) { initialize(size); }\n  template <class InputIterator>\n  explicit lazy_propagation_segment_tree(InputIterator first, InputIterator last) { construct(first, last); }\n\n  void initialize(const size_type size) {\n    clear();\n    M_tree.assign(size << 1, node_type());\n  }\n\n  template <class InputIterator>\n  void construct(InputIterator first, InputIterator last) {\n    clear();\n    const size_type size = std::distance(first, last);\n    M_tree.reserve(size << 1);\n    M_tree.assign(size, node_type());\n    for (; first != last; ++first) {\n      M_tree.emplace_back(*first, fixed_operator_monoid::identity());\n    }\n    for (size_type index = size - 1; index != 0; --index) {\n      M_fix_change(index);\n    }\n  }\n\n  value_type fold(size_type first, size_type last) {\n    assert(first <= last);\n    assert(last <= size());\n    first += size();\n    last  += size();\n    M_pushdown(first);\n    M_pushdown(last);\n    value_type fold_l = value_monoid::identity();\n    value_type fold_r = value_monoid::identity();\n    while (first != last) {\n      if (first & 1) {\n        fold_l = value_monoid::operation(fold_l, M_tree[first].value);\n        ++first;\n      }\n      if (last & 1) {\n        --last;\n        fold_r = value_monoid::operation(M_tree[last].value, fold_r);\n      }\n      first >>= 1;\n      last  >>= 1;\n    }\n    return value_monoid::operation(fold_l, fold_r);\n  }\n\n  void operate(size_type first, size_type last, const operator_type &op_) {\n    assert(first <= last);\n    assert(last <= size());\n    const auto op = fixed_operator_monoid::convert(op_);\n    first += size();\n    last  += size();\n    M_pushdown(first);\n    M_pushdown(last);\n    const size_type first_c = first;\n    const size_type last_c  = last;\n    for (size_type story = 0; first != last; ++story) {\n      if (first & 1) {\n        S_apply(M_tree[first], op, 1 << story);\n        ++first;\n      }\n      if (last & 1) {\n        --last;\n        S_apply(M_tree[last], op, 1 << story);\n      }\n      first >>= 1;\n      last  >>= 1;\n    }\n    M_pullup(first_c);\n    M_pullup(last_c);\n  }\n\n  void assign(size_type index, const value_type &val) {\n    assert(index < size());\n    index += size();\n    for (size_type story = bit_width(index); story != 0; --story) {\n      M_propagate(index >> story, 1 << (story - 1));\n    }\n    M_tree[index].value = val;\n    M_tree[index].lazy  = fixed_operator_monoid::identity();\n    while (index != 1) {\n      index >>= 1;\n      M_fix_change(index);\n    }\n  }\n\n  template <bool ToRight = true, class Constraint, std::enable_if_t<ToRight>* = nullptr> \n  size_type satisfies(const size_type left, Constraint &&func) {\n    assert(left <= size());\n    if (func(value_monoid::identity())) return left;\n    size_type first = left + size();\n    size_type last = 2 * size();\n    M_pushdown(first);\n    M_pushdown(last);\n    const size_type last_c = last;\n    value_type fold = value_monoid::identity();\n    const auto try_merge = [&](const size_type index) {\n      value_type tmp = value_monoid::operation(fold, M_tree[index].value);\n      if (func(tmp)) return true;\n      fold = std::move(tmp);\n      return false;\n    };\n    const auto subtree = [&](size_type index, size_type story) {\n      while (index < size()) {\n        M_propagate(index, 1 << (story - 1));\n        index <<= 1;\n        if (!try_merge(index)) ++index;\n        --story;\n      }\n      return index - size() + 1;\n    };\n    size_type story = 0;\n    while (first < last) {\n      if (first & 1) {\n        if (try_merge(first)) return subtree(first, story);\n        ++first;\n      }\n      first >>= 1;\n      last >>= 1;\n      ++story;\n    }\n    while (story--) {\n      last = last_c >> story;\n      if (last & 1) {\n        --last;\n        if (try_merge(last)) return subtree(last, story);\n      }\n    }\n    return size() + 1;\n  }\n\n  template <bool ToRight = true, class Constraint, std::enable_if_t<!ToRight>* = nullptr> \n  size_type satisfies(const size_type right, Constraint &&func) {\n    assert(right <= size());\n    if (func(value_monoid::identity())) return right;\n    size_type first = size();\n    size_type last = right + size();\n    M_pushdown(first);\n    M_pushdown(last);\n    const size_type first_c = first;\n    value_type fold = value_monoid::identity();\n    const auto try_merge = [&](const size_type index) {\n      value_type tmp = value_monoid::operation(M_tree[index].value, fold);\n      if (func(tmp)) return true;\n      fold = std::move(tmp);\n      return false;\n    };\n    const auto subtree = [&](size_type index, size_type story) {\n      while (index < size()) {\n        M_propagate(index, 1 << (story - 1));\n        index <<= 1;\n        if (try_merge(index + 1)) ++index;\n        --story;\n      }\n      return index - size();\n    };\n    size_type story = 0;\n    while (first < last) {\n      if (first & 1) ++first;\n      if (last & 1) {\n        --last;\n        if (try_merge(last)) return subtree(last, story);\n      }\n      first >>= 1;\n      last >>= 1;\n      ++story;\n    }\n    const size_type cover = bit_cover(first_c);\n    while (story--) {\n      first = (cover >> story) - ((cover - first_c) >> story);\n      if (first & 1) {\n        if (try_merge(first)) return subtree(first, story);\n      }\n    }\n    return size_type(-1);\n  }\n\n  void clear() {\n    M_tree.clear();\n    M_tree.shrink_to_fit();\n  }\n  size_type size() const { \n    return M_tree.size() >> 1;\n  }\n};\n\n/**\n * @title Lazy Propagation Segment Tree\n */\n#line 19 \"main.cpp\"\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\nconstexpr i32 inf32 = (i32(1) << 30) - 1;\nconstexpr i64 inf64 = (i64(1) << 62) - 1;\n\nusing m32 = mint32_t<998244353>;\n\nstruct lst_monoid {\n  struct value_structure {\n    using type = m32;\n    static type identity() { return m32(0); }\n    static type operation(const type& v1, const type& v2) { \n      return v1 + v2;\n    }\n  };\n  struct operator_structure {\n    using type = m32;\n    static type identity() { return m32(1); }\n    static type operation(const type& v1, const type& v2) { \n      return v1 * v2;\n    }\n  };\n  static typename value_structure::type operation(\n    const typename value_structure::type    &val,\n    const typename operator_structure::type &op,\n    const size_t = 1) {\n    return val * op;\n  }\n};\n\nint main() {\n  i32 N, K;\n  std::cin >> N >> K;\n  std::vector<i32> P(N);\n  for (auto &x: P) {\n    std::cin >> x;\n    --x;\n  }\n  m32 ans = m32(K) * m32(K - 1) / m32(4);\n  lazy_propagation_segment_tree<lst_monoid> seg(N);\n  const auto half = m32(1) / m32(2);\n  const auto coeff = m32(K - 1) / m32(K);\n  for (auto i: range(0, K)) {\n    seg.assign(P[i], half);\n  }\n  for (auto i: range(K, N)) {\n    seg.operate(0, N, coeff);\n    ans += seg.fold(0, P[i]);\n    ans += m32(N - P[i] - 1) - seg.fold(P[i] + 1, N);\n    seg.assign(P[i], half);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace atcoder;\n#define int long long\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    const int MAX =200005;\nconst int MOD =1000000007;\nusing mint = modint998244353;\nsigned main(){\n  int n,k;\n  cin>>n>>k;\n  pair<int,int> p[n];int p0;\n  mint k2=k;\n  k2=1-k2.inv();\n  mint ans=0,itr1=1,itr2=1;\n  for(int i=1;i<n;i++){\n    itr1=k2.pow(max(0ll,i+1-k));\n    ans+=itr2*itr1;\n    itr2+=itr1.inv();\n     //cerr<<ans.val()<<' '<<itr1.val()<<endl;\n  }\n  ans/=2;\n  \n // cerr<<ans.val()<<endl;\n  for(int i=0;i<n;i++){\n    cin>>p0;\n    p[i]={p0,i};\n  }\n  sort(p,p+n);\n  fenwick_tree<mint> tr(n),tr2(n);\n  for(int i=0;i<n;i++){\n    int j=p[i].second;\n   itr1=k2.pow(max(0ll,j+1-k));\n   ans-=tr.sum(j,n)/itr1;\n   ans+=tr2.sum(j,n);\n   tr.add(j,itr1);\n   tr2.add(j,1);\n\n  }\n  cout<<ans.val()<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n#ifndef FENWICK\n#define FENWICK\n\n// Fenwick tree implementation to compute sum on subsegments.\n// Each function requires O(log(N)).\n\n#include <cmath>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n// A structure able to perform the following operation on an array A:\n// 1. Sum x to A[i].\n// 2. Get the sum A[l] + A[l+1] + ... + A[r].\n// Both the operation are O(log(N)).\n// Everything is 0-based.\ntemplate <typename Value>\nclass Fenwick {\n  public:\n    // The Fenwick tree is initialized leaving all entries with the value 0.\n    Fenwick(int N) :\n        size(N),\n        max_pow2(log2(N)),\n        container(N, 0) {}\n\n    // Initialize the Fenwick tree with the given values as entries.\n    Fenwick(const vector<Value>& initial_values) :\n            Fenwick(initial_values.size()) {\n        for (int p = 0; p < size; p++) {\n            int q = p | (p+1);\n            container[p] += initial_values[p];\n            if (q < size) container[q] += container[p];\n        }\n    }\n\n    // Add x to the p-th entry.\n    void Add(int p, Value x) {\n        for (; p < size; p |= (p+1)) container[p] += x;\n    }\n\n    // Get the sum on the interval [l, r].\n    Value GetRange(int l, int r) {\n        if (l > 0) return GetRange(0, r) - GetRange(0, l-1);\n        Value res = 0;\n        for (; r >= 0; r = (r&(r+1))-1) res += container[r];\n        return res;\n    }\n\n    // Get the value of the p-th entry.\n    Value Get(int p) {\n        return GetRange(p, p);\n    }\n    \n    // Get the smallest p >= 0 such that GetRange(0, p) >= x.\n    // If such a p does not exist, it returns size.\n    // ACHTUNG: Works only if all values are nonnegative.\n    int LowerBound(Value x) {\n        Value sum = 0;\n        int res = 0;\n        for(int i = 1 << max_pow2; i > 0; i >>= 1) {\n            if(res + i - 1 < size and sum + container[res + i - 1] < x) {\n                sum += container[res + i - 1];\n                res += i;\n            }\n        }\n        return res;\n    }\n\n    // Set the p-th entry to x.\n    void Set(int p, Value x) {\n        Add(p, x - Get(p));\n    }\n\n    // Prints the current state of the Fenwick tree.\n    void Debug() {\n        cout << \"Internal container representation (size = \" << size << \"):\\n\";\n        for (int i = 0; i < size; i++) cout << container[i] << \" \";\n        cout << \"\\nValues of the entries:\\n\";\n        for (int i = 0; i < size; i++) cout << Get(i) << \" \";\n        cout << \"\\n\";\n        cout.flush();\n    }\n    \n  private:\n    int size; // = container.size() (just to have a shorter name).\n    int max_pow2; // = maximum integer such that (1 << max_pow2) <= N.\n    // container[xxx01...1] contains the sum of all the entries from\n    // xxx00...0 to xxx01...1 inclusive.\n    // i.e. container[2] contains exactly the value of entry[2], whereas\n    // container[3] contains the sum entry[0] + entry[1] + entry[2] + entry[3].\n    vector<Value> container;\n};\n\n#endif  // FENWICK\n        \n// Overloading of the operator << for __int128 type.\nostream& operator <<(ostream& out, __int128 x) {\n    static short int digits[41];\n    if (x == 0) {\n        out << '0';\n        return out;\n    }\n    if (x < 0) {\n        out << '-';\n        x = -x;\n    }\n    int length = 0;\n    for (; x > 0; x /= 10) {\n        digits[length] = x % 10;\n        length++;\n    }\n    for (int i = length - 1; i >= 0; i--) out << digits[i];\n    return out;\n}\n\n\n// Computes the inverse of n modulo m.\n// Precondition: n >= 0, m > 0 and gcd(n, m) == 1.\n// The returned value satisfies 0 <= x < m (Inverse(0, 1) = 0).\n// ACHTUNG: It must hold max(m, n) < 2**31 to avoid integer overflow.\nLL Inverse(LL n, LL m) {\n    n %= m;\n    if (n <= 1) return n; // Handles properly (n = 0, m = 1).\n    return m - ((m * Inverse(m, n) - 1) / n);\n}\n\n// Fast exponentiation modulo mod. Returns x**e modulo mod.\n// Assumptions: 0 <= x < mod\n//              mod < 2**31.\n//              0 <= e < 2**63\nLL pow(LL x, LL e, LL mod) {\n    LL res = 1;\n    for (; e >= 1; e >>= 1) {\n        if (e & 1) res = res * x % mod;\n        x = x * x % mod;\n    }\n    return res;\n}\n\n// Struct that computes x % mod faster than usual, if mod is always the same.\n// It gives a x1.8 speed up over the % operator (with mod ~ 1e9 and x large).\n// It is an implementation of the Barrett reduction, see\n//    https://en.wikipedia.org/wiki/Barrett_reduction .\n// If fast_mod is an instance of the class, then fast_mod(x) will return\n// x % mod. There are no restrictions on the values of mod and x, provided\n// that they fit in an unsigned long long (and mod != 0).\n//\n// ACHTUNG: The integer type __uint128_t must be available.\nstruct FastMod {\n    ULL mod;\n    ULL inv;\n    FastMod(ULL mod) : mod(mod), inv(-1ULL / mod) {}\n    ULL operator()(ULL x) {\n        ULL q = (ULL)((__uint128_t(inv) * x) >> 64);\n        ULL r = x - q * mod;\n        return r - mod * (r >= mod);\n    }\n};\n\n// Class for integers modulo mod.\n// It supports all expected operations: +, -, *, /, pow, ==, < and >.\n// It is as fast as it can be.\n// The modulo mod shall be set through set_mod().\n//\n// Assumptions: mod < (1<<30).\n// ACHTUNG: The integer type __uint128_t must be available.\n//\n// Remark: To handle larger moduli (up to 1<<62), one has to:\n//          1. replace int in the definitions of mod, n.\n//          2. The parameter of fast_mod must be __uint128_t, so it must be\n//             changed in the definition of fast_mod and in the definition of\n//             the operators * and *=.\n//          3. fast_mod must be a naive modulo operation, no barrett reduction.\n//          4. In Inverse, __int128_t shall be used.\nstruct ModularInteger {\n    static int mod;\n    static __uint128_t inv_mod; // Necessary for fast_mod.\n    int n; // 0 <= n < mod at all times\n    static void set_mod(int _mod) {\n        mod = _mod;\n        inv_mod = -1ULL / mod;\n    }\n    ModularInteger(): n(0) {}\n    ModularInteger(LL _n): n(_n % mod) {\n        n += (n<0)*mod;\n    }\n    LL get() const { return n; }\n    static int fast_mod(ULL x) { // Barrett reduction.\n        ULL q = (inv_mod * x) >> 64;\n        int m = x - q * mod;\n        m -= mod * (m >= mod);\n        return m;\n    }\n\n    ModularInteger operator-() const { return n?mod-n:0; }\n};\nint ModularInteger::mod;\n__uint128_t ModularInteger::inv_mod;\n\nModularInteger operator +(const ModularInteger& A, const ModularInteger& B) {\n    ModularInteger C;\n    C.n = A.n + B.n;\n    C.n -= (C.n >= ModularInteger::mod)*ModularInteger::mod;\n    return C;\n}\n\nvoid operator +=(ModularInteger& A, const ModularInteger& B) {\n    A.n += B.n;\n    A.n -= (A.n >= ModularInteger::mod)*ModularInteger::mod;\n}\n\nModularInteger operator -(const ModularInteger& A, const ModularInteger& B) {\n    ModularInteger C;\n    C.n = A.n - B.n;\n    C.n += (C.n < 0)*ModularInteger::mod;\n    return C;\n}\n\nvoid operator -=(ModularInteger& A, const ModularInteger& B) {\n    A.n -= B.n;\n    A.n += (A.n < 0)*ModularInteger::mod;\n}\n\nModularInteger operator *(const ModularInteger& A, const ModularInteger& B) {\n    ModularInteger C;\n    C.n = ModularInteger::fast_mod(((ULL)A.n) * B.n);\n    return C;\n}\n\nvoid operator *=(ModularInteger& A, const ModularInteger& B) {\n    A.n = ModularInteger::fast_mod(((ULL)A.n) * B.n);\n}\n\n// Assumption: gcd(B, mod) = 1.\nModularInteger operator /(const ModularInteger& A, const ModularInteger& B) {\n    return A * Inverse(B.n, ModularInteger::mod);\n}\n\n// Assumption: gcd(B, mod) = 1.\nvoid operator/=(ModularInteger& A, const ModularInteger& B) {\n    A *= Inverse(B.n, ModularInteger::mod);\n}\n\nModularInteger power(ModularInteger A, ULL e) {\n    ModularInteger res = 1;\n    for (; e >= 1; e >>= 1) {\n        if (e & 1) res *= A;\n        A *= A;\n    }\n    return res;\n}\n\nbool operator ==(const ModularInteger& A, const ModularInteger& B) {\n    return A.n == B.n;\n}\nbool operator !=(const ModularInteger& A, const ModularInteger& B) {\n    return A.n != B.n;\n}\nbool operator <(const ModularInteger& A, const ModularInteger& B) {\n    return A.n < B.n;\n}\nbool operator >(const ModularInteger& A, const ModularInteger& B) {\n    return A.n > B.n;\n}\nbool operator <=(const ModularInteger& A, const ModularInteger& B) {\n    return A.n <= B.n;\n}\nbool operator >=(const ModularInteger& A, const ModularInteger& B) {\n    return A.n >= B.n;\n}\n\nostream& operator <<(ostream& out, const ModularInteger& A) {\n    out << A.n;\n    return out;\n}\n\nistream& operator >>(istream& in, ModularInteger& A) {\n  LL a;\n  in >> a;\n  A = ModularInteger(a);\n  return in;\n}\n\ntypedef ModularInteger mint;\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    mint::set_mod(998244353);\n\n    int N, K;\n    cin >> N >> K;\n\n    Fenwick<mint> fen1(N+1), fen2(N+1), fen3(N+1);\n\n    vector<int> p(N+1);\n    vector<int> invp(N+1);\n    for (int i = 1; i <= N; i++) cin >> p[i], invp[p[i]] = i;\n    vector<int> a(N+1);\n    for (int i = 1; i <= N; i++) a[i] = max(K, i);\n\n    mint z = mint(K-1)/K;\n    mint invz = 1/z;\n    for (int i = 1; i <= N; i++) fen1.Set(i, power(z, a[i]));\n\n    mint res = 0;\n    for (int pp = 1; pp <= N; pp++) {\n        int i = invp[pp];\n        fen1.Set(i, 0);\n\n        res += power(invz, a[i]) * (fen1.GetRange(i, N) - fen2.GetRange(i, N)) / 2;\n        res += fen3.GetRange(i, N);\n        \n        fen2.Set(i, power(z, a[i]));\n        fen3.Set(i, 1);\n    }\n    cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){x>y?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0';\n\tx*=f;\n}\nconst int MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=200005;\n\nint n,k,a[MAXN],pw[MAXN],ipw[MAXN];\nint c[MAXN];\nvoid add(int x,int d){for(;x<=n;x+=(x&-x))inc(c[x],d);}\nint query(int x){int s=0;for(;x;x-=(x&-x))inc(s,c[x]);return s;}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n),readint(k);\n\tfor(int i=1;i<=n;++i)readint(a[i]);\n\tpw[0]=ipw[0]=1,pw[1]=dmy(1+MOD-qmi(k,MOD-2)),ipw[1]=qmi(pw[1],MOD-2);\n\tfor(int i=2;i<=n;++i)pw[i]=1ll*pw[i-1]*pw[1]%MOD,ipw[i]=1ll*ipw[i-1]*ipw[1]%MOD;\n\tint ans=0,cnt=0;\n\tfor(int i=1;i<=n;++i)\n\t\tinc(cnt,query(n)-query(a[i])),\n\t\tadd(a[i],1);\n\tmemset(c,0,sizeof(c));\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint u=max(i,k);\n\t\tint sn=query(n),si=query(a[i]);\n\t\tinc(ans,1ll*dmy(dmy(si<<1)-sn+MOD)*pw[u]%MOD);\n\t\tadd(a[i],ipw[u]);\n\t}\n\tans=(cnt+1ll*ans*qmi(2,MOD-2))%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<atcoder/modint>\n#include<atcoder/fenwicktree>\nusing namespace std;\nusing namespace atcoder;\nusing mint=modint998244353;\nint N,K;\nint P[2<<17];\nmain()\n{\n\tcin>>N>>K;\n\tfor(int i=0;i<N;i++)cin>>P[i];\n\tfenwick_tree<mint>A(N);\n\tfenwick_tree<int>B(N);\n\tmint ans=0;\n\tmint X=mint(K-1)/K;\n\tfor(int j=1;j<N;j++)\n\t{\n\t\tA.add(P[j-1]-1,1/X.pow(max(j,K)-1));\n\t\tB.add(P[j-1]-1,1);\n\t\tans+=(A.sum(0,P[j]-1)-A.sum(P[j],N))*X.pow(max(j,K-1))+2*B.sum(P[j],N);\n\t}\n\tcout<<(ans/2).val()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<atcoder/modint>\n#include<atcoder/fenwicktree>\nusing namespace std;\nusing namespace atcoder;\nusing mint=modint998244353;\nint N,K;\nint P[2<<17];\nlong calc()\n{\n\tfenwick_tree<int>A(N+1);\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tans+=i-A.sum(0,P[i]);\n\t\tA.add(P[i],1);\n\t}\n\treturn ans;\n}\nmain()\n{\n\tcin>>N>>K;\n\tfor(int i=0;i<N;i++)cin>>P[i];\n\tmint ans=calc();\n\tans*=K;\n\tmint invK=mint(1)/K;\n\tmint X=mint(K-1)*invK;\n\tmint Y=mint(K-2)*invK;\n\tmint invY=mint(1)/(1-Y);\n\tmint Kinv2=mint(1)/2*K;\n\tfenwick_tree<int>Q(N+1);\n\tfenwick_tree<int>R(N+1);\n\tfenwick_tree<mint>low(N+1);\n\tfor(int j=1;j<N;j++)\n\t{\n\t\tQ.add(P[j-1],1);\n\t\tif(j<=K)R.add(P[j-1],1);\n\t\t{\n\t\t\tint i=j-1;\n\t\t\tif(i>=K)\n\t\t\t{\n\t\t\t\tlow.add(P[i],X.pow(i).inv());\n\t\t\t}\n\t\t}\n\t\tint t=min(N-j,N-K);\n\t\tmint Yt=Y.pow(t);\n\t\tmint T=(1-Yt)*invY+Yt*Kinv2;\n\t\tmint tmp=0;\n\t\tif(j<=K-1)\n\t\t{\n\t\t\ttmp=2*Q.sum(0,P[j])-j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp=X.pow(j-(K-1))*(2*R.sum(0,P[j])-K);\n\t\t\tmint Xj=X.pow(j);\n\t\t\ttmp+=low.sum(0,P[j])*Xj;\n\t\t\ttmp-=low.sum(P[j],N+1)*Xj;\n\t\t}\n\t\tans+=tmp*T;\n\t}\n\tcout<<(ans*invK).val()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  T sum(ll a){\n\tif(a<0)return 0;\n    T ret = 0;\n    for(ll i=a+1;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  T sum(ll a,ll b){return a>b?0:sum(b)-sum(a-1);}\n  T operator[](ll pos){\n    return sum(pos,pos);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n;i++){\n      if(i!=0)cout<<\" \";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD9 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,k;cin>>n>>k;\n  vector<ll>p(n);\n  rep(i,0,n)cin>>p[i],p[i]--;\n  BIT<modint>bit1(n);\n  BIT<modint>bit2(n);\n  modint tmp=1;\n  modint ret=0;\n  modint mul=k-1;mul/=k;\n  rep(i,0,n){\n    if(i>=k)tmp/=mul;\n    modint dec=bit1.sum(p[i]-1);\n    modint inc=bit1.sum(p[i]+1,n-1);\n    ret+=dec/tmp/2;\n    modint incnum=bit2.sum(p[i]+1,n-1);\n    ret+=incnum-inc/tmp/2;\n    bit1.add(p[i],tmp);\n    bit2.add(p[i],1);\n    //cout<<ret spa dec spa inc spa dec/mul/2 spa incnum-inc/mul/2<<endl;\n  }\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n\nusing namespace atcoder;\n\nusing Mint = modint998244353;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, k;\n    std::cin >> n >> k;\n    std::vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> p[i];\n        --p[i];\n    }\n    \n    fenwick_tree<Mint> fw(n);\n    fenwick_tree<int> fw2(n);\n    \n    Mint pr = 1 - Mint(k).inv();\n    std::vector<Mint> pw(n);\n    pw[0] = 1;\n    for (int i = 1; i < n; ++i)\n        pw[i] = pw[i - 1] * pr;\n    \n    Mint ans = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        auto v = pw[std::max(i, k - 1)];\n        ans += (fw.sum(0, p[i]) - fw.sum(p[i], n)) * v;\n        fw.add(p[i], v.inv());\n        ans += fw2.sum(p[i], n);\n        fw2.add(p[i], 2);\n    }\n    \n    ans /= 2;\n    std::cout << ans.val() << \"\\n\";\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<atcoder/modint>\n#include<atcoder/fenwicktree>\nusing namespace std;\nusing namespace atcoder;\nusing mint=modint998244353;\nint N,K;\nint P[2<<17];\nlong calc()\n{\n\tfenwick_tree<int>A(N+1);\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tans+=i-A.sum(0,P[i]);\n\t\tA.add(P[i],1);\n\t}\n\treturn ans;\n}\nmain()\n{\n\tcin>>N>>K;\n\tfor(int i=0;i<N;i++)cin>>P[i];\n\tmint ans=calc();\n\tans*=K;\n\tmint invK=mint(1)/K;\n\tmint X=mint(K-1)*invK;\n\tmint Y=mint(K-2)*invK;\n\tmint invY=mint(1)/(1-Y);\n\tmint Kinv2=mint(1)/2*K;\n\tfor(int j=1;j<N;j++)\n\t{\n\t\tint t=min(N-j,N-K);\n\t\tmint Yt=Y.pow(t);\n\t\tmint T=(1-Yt)*invY+Yt*Kinv2;\n\t\tmint tmp=0;\n\t\tfor(int i=0;i<j;i++)\n\t\t{\n\t\t\tmint a=X.pow(max(0,j-max(K-1,i)));\n\t\t\tif(P[i]<P[j])tmp+=a;\n\t\t\telse tmp-=a;\n\t\t}\n\t\tans+=tmp*T;\n\t}\n\tcout<<(ans*invK).val()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <atcoder/lazysegtree>\n#include <atcoder/modint>\n#include <boost/range/adaptors.hpp>\n#include <boost/range/irange.hpp>\n\nusing namespace atcoder;\nusing namespace std;\nusing namespace boost;\nusing namespace boost::adaptors;\n\nusing Mod = modint998244353;\n\nMod op(Mod lhs, Mod rhs) { return lhs + rhs; }\n\nMod e() { return Mod(0); }\n\nMod mapping(Mod m, Mod v) { return m * v; }\n\nMod composition(Mod l, Mod r) { return l * r; }\n\nMod id() { return Mod(1); }\n\nusing ST = lazy_segtree<Mod, op, e, Mod, mapping, composition, id>;\n\nint main() {\n    int64_t n, k;\n    cin >> n >> k;\n\n    vector p(n, 0L);\n    for (auto&& pp : p) {\n        cin >> pp;\n    }\n\n    ST st(n + 1), st1(n + 1);\n\n    Mod half = Mod(1) / 2;\n    Mod m = Mod(1) - Mod(1) / k;\n\n    Mod ans = 0;\n    for (auto i : irange(0L, k)) {\n        ans += st.prod(0, p[i]);\n        ans += st1.prod(p[i], n + 1);\n        ans -= st.prod(p[i], n + 1);\n\n        st.set(p[i], half);\n        st1.set(p[i], Mod(1));\n    }\n\n    for (auto i : irange(k, n)) {\n        st.apply(0, n + 1, m);\n\n        ans += st.prod(0, p[i]);\n        ans += st1.prod(p[i], n + 1);\n        ans -= st.prod(p[i], n + 1);\n\n        st.set(p[i], half);\n        st1.set(p[i], Mod(1));\n    }\n\n    cout << ans.val() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\ntypedef long long int ll;\nconstexpr int kMod = 998244353, kN = int(2E5 + 10);\n\nstruct BIT {\n\tll val[kN];\n\tvoid init() {memset(val, 0, sizeof(val));}\n\tvoid add(int pos, ll x) {\n\t\twhile (pos < kN) {\n\t\t\tval[pos] = (val[pos] + x) % kMod;\n\t\t\tpos += pos & -pos;\n\t\t}\n\t\treturn ;\n\t}\n\tll ask(int pos) {\n\t\tll ans = 0;\n\t\twhile (pos){\n\t\t\tans += val[pos];\n\t\t\tpos ^= pos & -pos;\n\t\t}\n\t\treturn ans % kMod;\n\t}\n};\n\nll Pow(ll a, ll b) {\n\tll ans = 1;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a % kMod;\n\t\ta = a * a % kMod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll Rev(ll n) {return Pow(n, kMod - 2);}\n\nint a[kN], f[kN];\nll p[kN];\nBIT bit, bcnt;\n\nint main() {\n\tint n, k;\n\tll ans = 0, tot = 0, sum = 0;\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tp[0] = 1;\n\tp[1] = (k - 1) * Rev(k) % kMod;\n\tfor (int i = 2; i <= n; i++) p[i] = p[i - 1] * p[1] % kMod;\n\tfor (int i = 1; i <= k; i++) f[i] = 0;\n\tfor (int i = k + 1; i <= n; i++) f[i] = i - k;\n\tbit.init();\n\tbcnt.init();\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += p[f[i]] * tot % kMod;\n\t\tans -= p[f[i]] * (tot + tot - bit.ask(a[i])) % kMod;\n\t\tans += (i - 1 - bcnt.ask(a[i]));\n\t\tbit.add(a[i], Rev(p[f[i]]));\n\t\tbcnt.add(a[i], 1);\n\t\ttot = (tot + Rev(p[f[i]]) * Rev(2)) % kMod;\n\t}\n\tans %= kMod;\n\tif (ans < 0) ans += kMod;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 21;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nint gcd(int a, int b) {\n\tif (a > b)swap(a, b);\n\twhile (b > 0) {\n\t\tint r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\nint gcm(int a, int b) {\n\treturn (a / gcd(a, b)) * b;\n}\n\nstruct BIT {\nprivate:\n\tvector<modint> node; int n;\npublic:\n\tBIT(int n_) {\n\t\tn = n_; node.resize(n, 0);\n\t}\n\t//0-indexed\n\tvoid add(int a, modint w) {\n\t\tfor (int i = a; i < n; i |= i + 1)node[i] += w;\n\t}\n\t//[0,a)\n\tmodint sum(int a) {\n\t\tmodint ret = 0;\n\t\tfor (int i = a - 1; i >= 0; i = (i & (i + 1)) - 1)ret += node[i];\n\t\treturn ret;\n\t}\n\t//[a,b)\n\tmodint sum(int a, int b) {\n\t\treturn sum(b) - sum(a);\n\t}\n};\n\n\nvoid solve() {\n\tint n, k; cin >> n >> k;\n\tvector<int> p(n);\n\trep(i, n) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tvector<int> l(n);\n\trep(i, n) {\n\t\tl[i] = max(0, i - k + 1);\n\t}\n\tmodint inv2 = (1 + mod) / 2;\n\tmodint ans = 0;\n\trep(i, n) {\n\t\tint r = l.back() - l[i];\n\t\tans += inv2 * ((modint)(k - 1) - ((modint)mod_pow(k - 1, r + 1) / (modint)mod_pow(k, r)));\n\t\tmodint cz = 0;\n\t\tif (i < k)cz = k - 1 - i;\n\t\tans += cz * inv2;\n\t}\n\tmodint q = (modint(k - 1)) / (modint)k;\n\tvector<int> trans(n);\n\trep(i, n)trans[p[i]] = i;\n\tBIT bt(n);\n\tBIT cnt(n);\n\trep(i, n) {\n\t\tint loc = trans[i];\n\t\tmodint s = bt.sum(loc, n);\n\t\tmodint val = mod_pow(q, l[loc]);\n\t\ts = s / val;\n\t\tans -= s;\n\t\tbt.add(loc, val);\n\t\tans += cnt.sum(loc, n);\n\t\tcnt.add(loc, 1);\n\t}\n\tcout << ans << \"\\n\";\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(8);\n\t//init_f();\n\t//init();\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma comment (linker, \"/STACK:526000000\")\n#include \"bits/stdc++.h\"\n\n/*\nAtCoder Compressed STL, licensed under public domain (cc0)\nDownload Compressed: https://gist.github.com/yosupo06/ddd51afb727600fd95d9d8ad6c3c80c9\nbased on AtCoder STL,\nDownload: https://img.atcoder.jp/practice2/ac-library.zip\n*/\n\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tint ceil_pow2(int n) {\n\t\t\tint x = 0;\n\t\t\twhile ((1U << x) < (unsigned int)(n)) x++;\n\t\t\treturn x;\n\t\t}\n\n\t\tint bsf(unsigned int n) {\n#ifdef _MSC_VER\n\t\t\tunsigned long index;\n\t\t\t_BitScanForward(&index, n);\n\t\t\treturn index;\n#else\n\t\t\treturn __builtin_ctz(n);\n#endif\n\t\t}\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tconstexpr long long safe_mod(long long x, long long m) {\n\t\t\tx %= m;\n\t\t\tif (x < 0) x += m;\n\t\t\treturn x;\n\t\t}\n\n\t\tstruct barrett {\n\t\t\tunsigned int _m;\n\t\t\tunsigned long long im;\n\n\t\t\tbarrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n\t\t\tunsigned int umod() const { return _m; }\n\n\t\t\tunsigned int mul(unsigned int a, unsigned int b) const {\n\n\t\t\t\tunsigned long long z = a;\n\t\t\t\tz *= b;\n#ifdef _MSC_VER\n\t\t\t\tunsigned long long x;\n\t\t\t\t_umul128(z, im, &x);\n#else\n\t\t\t\tunsigned long long x =\n\t\t\t\t\t(unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n\t\t\t\tunsigned int v = (unsigned int)(z - x * _m);\n\t\t\t\tif (_m <= v) v += _m;\n\t\t\t\treturn v;\n\t\t\t}\n\t\t};\n\n\t\tconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n\t\t\tif (m == 1) return 0;\n\t\t\tunsigned int _m = (unsigned int)(m);\n\t\t\tunsigned long long r = 1;\n\t\t\tunsigned long long y = safe_mod(x, m);\n\t\t\twhile (n) {\n\t\t\t\tif (n & 1) r = (r * y) % _m;\n\t\t\t\ty = (y * y) % _m;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\n\t\tconstexpr bool is_prime_constexpr(int n) {\n\t\t\tif (n <= 1) return false;\n\t\t\tif (n == 2 || n == 7 || n == 61) return true;\n\t\t\tif (n % 2 == 0) return false;\n\t\t\tlong long d = n - 1;\n\t\t\twhile (d % 2 == 0) d /= 2;\n\t\t\tint v[3] = { 2,7,61 };\n\t\t\tfor (long long a : v) {\n\t\t\t\tlong long t = d;\n\t\t\t\tlong long y = pow_mod_constexpr(a, t, n);\n\t\t\t\twhile (t != n - 1 && y != 1 && y != n - 1) {\n\t\t\t\t\ty = y * y % n;\n\t\t\t\t\tt <<= 1;\n\t\t\t\t}\n\t\t\t\tif (y != n - 1 && t % 2 == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\ttemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n\t\tconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n\t\t\ta = safe_mod(a, b);\n\t\t\tif (a == 0) return { b, 0 };\n\n\t\t\tlong long s = b, t = a;\n\t\t\tlong long m0 = 0, m1 = 1;\n\n\t\t\twhile (t) {\n\t\t\t\tlong long u = s / t;\n\t\t\t\ts -= t * u;\n\t\t\t\tm0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n\n\t\t\t\tauto tmp = s;\n\t\t\t\ts = t;\n\t\t\t\tt = tmp;\n\t\t\t\ttmp = m0;\n\t\t\t\tm0 = m1;\n\t\t\t\tm1 = tmp;\n\t\t\t}\n\t\t\tif (m0 < 0) m0 += b / s;\n\t\t\treturn { s, m0 };\n\t\t}\n\n\t\tconstexpr int primitive_root_constexpr(int m) {\n\t\t\tif (m == 2) return 1;\n\t\t\tif (m == 167772161) return 3;\n\t\t\tif (m == 469762049) return 3;\n\t\t\tif (m == 754974721) return 11;\n\t\t\tif (m == 998244353) return 3;\n\t\t\tint divs[20] = {};\n\t\t\tdivs[0] = 2;\n\t\t\tint cnt = 1;\n\t\t\tint x = (m - 1) / 2;\n\t\t\twhile (x % 2 == 0) x /= 2;\n\t\t\tfor (int i = 3; (long long)(i)*i <= x; i += 2) {\n\t\t\t\tif (x % i == 0) {\n\t\t\t\t\tdivs[cnt++] = i;\n\t\t\t\t\twhile (x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x > 1) {\n\t\t\t\tdivs[cnt++] = x;\n\t\t\t}\n\t\t\tfor (int g = 2;; g++) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t\t\tif (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) return g;\n\t\t\t}\n\t\t}\n\t\ttemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n#ifndef _MSC_VER\n\t\ttemplate <class T>\n\t\tusing is_signed_int128 =\n\t\t\ttypename std::conditional<std::is_same<T, __int128_t>::value ||\n\t\t\tstd::is_same<T, __int128>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int128 =\n\t\t\ttypename std::conditional<std::is_same<T, __uint128_t>::value ||\n\t\t\tstd::is_same<T, unsigned __int128>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing make_unsigned_int128 =\n\t\t\ttypename std::conditional<std::is_same<T, __int128_t>::value,\n\t\t\t__uint128_t,\n\t\t\tunsigned __int128>;\n\n\t\ttemplate <class T>\n\t\tusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n\t\t\tis_signed_int128<T>::value ||\n\t\t\tis_unsigned_int128<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_signed_int = typename std::conditional<(is_integral<T>::value&&\n\t\t\tstd::is_signed<T>::value) ||\n\t\t\tis_signed_int128<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int =\n\t\t\ttypename std::conditional<(is_integral<T>::value&&\n\t\t\t\tstd::is_unsigned<T>::value) ||\n\t\t\tis_unsigned_int128<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing to_unsigned = typename std::conditional<\n\t\t\tis_signed_int128<T>::value,\n\t\t\tmake_unsigned_int128<T>,\n\t\t\ttypename std::conditional<std::is_signed<T>::value,\n\t\t\tstd::make_unsigned<T>,\n\t\t\tstd::common_type<T>>::type>::type;\n\n#else\n\n\t\ttemplate <class T> using is_integral = typename std::is_integral<T>;\n\n\t\ttemplate <class T>\n\t\tusing is_signed_int =\n\t\t\ttypename std::conditional<is_integral<T>::value&& std::is_signed<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int =\n\t\t\ttypename std::conditional<is_integral<T>::value&&\n\t\t\tstd::is_unsigned<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n\t\t\tstd::make_unsigned<T>,\n\t\t\tstd::common_type<T>>::type;\n\n#endif\n\n\t\ttemplate <class T>\n\t\tusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\n\t\ttemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tstruct modint_base {};\n\t\tstruct static_modint_base : modint_base {};\n\n\t\ttemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\n\t\ttemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n\t}  // namespace internal\n\n\ttemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n\tstruct static_modint : internal::static_modint_base {\n\t\tusing mint = static_modint;\n\n\tpublic:\n\t\tstatic constexpr int mod() { return m; }\n\t\tstatic mint raw(int v) {\n\t\t\tmint x;\n\t\t\tx._v = v;\n\t\t\treturn x;\n\t\t}\n\n\t\tstatic_modint() : _v(0) {}\n\t\ttemplate <class T, internal::is_signed_int_t<T>* = nullptr>\n\t\tstatic_modint(T v) {\n\t\t\tlong long x = (long long)(v % (long long)(umod()));\n\t\t\tif (x < 0) x += umod();\n\t\t\t_v = (unsigned int)(x);\n\t\t}\n\t\ttemplate <class T, internal::is_unsigned_int_t<T>* = nullptr>\n\t\tstatic_modint(T v) {\n\t\t\t_v = (unsigned int)(v % umod());\n\t\t}\n\t\tstatic_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n\t\tunsigned int val() const { return _v; }\n\n\t\tmint& operator++() {\n\t\t\t_v++;\n\t\t\tif (_v == umod()) _v = 0;\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator--() {\n\t\t\tif (_v == 0) _v = umod();\n\t\t\t_v--;\n\t\t\treturn *this;\n\t\t}\n\t\tmint operator++(int) {\n\t\t\tmint result = *this;\n\t\t\t++* this;\n\t\t\treturn result;\n\t\t}\n\t\tmint operator--(int) {\n\t\t\tmint result = *this;\n\t\t\t--* this;\n\t\t\treturn result;\n\t\t}\n\n\t\tmint& operator+=(const mint& rhs) {\n\t\t\t_v += rhs._v;\n\t\t\tif (_v >= umod()) _v -= umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator-=(const mint& rhs) {\n\t\t\t_v -= rhs._v;\n\t\t\tif (_v >= umod()) _v += umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator*=(const mint& rhs) {\n\t\t\tunsigned long long z = _v;\n\t\t\tz *= rhs._v;\n\t\t\t_v = (unsigned int)(z % umod());\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n\t\tmint operator+() const { return *this; }\n\t\tmint operator-() const { return mint() - *this; }\n\n\t\tmint pow(long long n) const {\n\t\t\tassert(0 <= n);\n\t\t\tmint x = *this, r = 1;\n\t\t\twhile (n) {\n\t\t\t\tif (n & 1) r *= x;\n\t\t\t\tx *= x;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tmint inv() const {\n\t\t\tif (prime) {\n\t\t\t\tassert(_v);\n\t\t\t\treturn pow(umod() - 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto eg = internal::inv_gcd(_v, m);\n\t\t\t\tassert(eg.first == 1);\n\t\t\t\treturn eg.second;\n\t\t\t}\n\t\t}\n\n\t\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) += rhs;\n\t\t}\n\t\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) -= rhs;\n\t\t}\n\t\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) *= rhs;\n\t\t}\n\t\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) /= rhs;\n\t\t}\n\t\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v == rhs._v;\n\t\t}\n\t\tfriend bool operator!=(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v != rhs._v;\n\t\t}\n\n\tprivate:\n\t\tunsigned int _v;\n\t\tstatic constexpr unsigned int umod() { return m; }\n\t\tstatic constexpr bool prime = internal::is_prime<m>;\n\t};\n\n\ttemplate <int id> struct dynamic_modint : internal::modint_base {\n\t\tusing mint = dynamic_modint;\n\n\tpublic:\n\t\tstatic int mod() { return (int)(bt.umod()); }\n\t\tstatic void set_mod(int m) {\n\t\t\tassert(1 <= m);\n\t\t\tbt = internal::barrett(m);\n\t\t}\n\t\tstatic mint raw(int v) {\n\t\t\tmint x;\n\t\t\tx._v = v;\n\t\t\treturn x;\n\t\t}\n\n\t\tdynamic_modint() : _v(0) {}\n\t\ttemplate <class T, internal::is_signed_int_t<T>* = nullptr>\n\t\tdynamic_modint(T v) {\n\t\t\tlong long x = (long long)(v % (long long)(mod()));\n\t\t\tif (x < 0) x += mod();\n\t\t\t_v = (unsigned int)(x);\n\t\t}\n\t\ttemplate <class T, internal::is_unsigned_int_t<T>* = nullptr>\n\t\tdynamic_modint(T v) {\n\t\t\t_v = (unsigned int)(v % mod());\n\t\t}\n\t\tdynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n\t\tunsigned int val() const { return _v; }\n\n\t\tmint& operator++() {\n\t\t\t_v++;\n\t\t\tif (_v == umod()) _v = 0;\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator--() {\n\t\t\tif (_v == 0) _v = umod();\n\t\t\t_v--;\n\t\t\treturn *this;\n\t\t}\n\t\tmint operator++(int) {\n\t\t\tmint result = *this;\n\t\t\t++* this;\n\t\t\treturn result;\n\t\t}\n\t\tmint operator--(int) {\n\t\t\tmint result = *this;\n\t\t\t--* this;\n\t\t\treturn result;\n\t\t}\n\n\t\tmint& operator+=(const mint& rhs) {\n\t\t\t_v += rhs._v;\n\t\t\tif (_v >= umod()) _v -= umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator-=(const mint& rhs) {\n\t\t\t_v += mod() - rhs._v;\n\t\t\tif (_v >= umod()) _v -= umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator*=(const mint& rhs) {\n\t\t\t_v = bt.mul(_v, rhs._v);\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n\t\tmint operator+() const { return *this; }\n\t\tmint operator-() const { return mint() - *this; }\n\n\t\tmint pow(long long n) const {\n\t\t\tassert(0 <= n);\n\t\t\tmint x = *this, r = 1;\n\t\t\twhile (n) {\n\t\t\t\tif (n & 1) r *= x;\n\t\t\t\tx *= x;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tmint inv() const {\n\t\t\tauto eg = internal::inv_gcd(_v, mod());\n\t\t\tassert(eg.first == 1);\n\t\t\treturn eg.second;\n\t\t}\n\n\t\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) += rhs;\n\t\t}\n\t\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) -= rhs;\n\t\t}\n\t\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) *= rhs;\n\t\t}\n\t\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) /= rhs;\n\t\t}\n\t\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v == rhs._v;\n\t\t}\n\t\tfriend bool operator!=(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v != rhs._v;\n\t\t}\n\n\tprivate:\n\t\tunsigned int _v;\n\t\tstatic internal::barrett bt;\n\t\tstatic unsigned int umod() { return bt.umod(); }\n\t};\n\ttemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\n\tusing modint998244353 = static_modint<998244353>;\n\tusing modint1000000007 = static_modint<1000000007>;\n\tusing modint = dynamic_modint<-1>;\n\n\tnamespace internal {\n\n\t\ttemplate <class T>\n\t\tusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\n\t\ttemplate <class T>\n\t\tusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\n\t\ttemplate <class> struct is_dynamic_modint : public std::false_type {};\n\t\ttemplate <int id>\n\t\tstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\n\t\ttemplate <class T>\n\t\tusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\ttemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\n\t\tvoid butterfly(std::vector<mint>& a) {\n\t\t\tstatic constexpr int g = internal::primitive_root<mint::mod()>;\n\t\t\tint n = int(a.size());\n\t\t\tint h = internal::ceil_pow2(n);\n\n\t\t\tstatic bool first = true;\n\t\t\tstatic mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tmint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n\t\t\t\tint cnt2 = bsf(mint::mod() - 1);\n\t\t\t\tmint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n\t\t\t\tfor (int i = cnt2; i >= 2; i--) {\n\t\t\t\t\tes[i - 2] = e;\n\t\t\t\t\ties[i - 2] = ie;\n\t\t\t\t\te *= e;\n\t\t\t\t\tie *= ie;\n\t\t\t\t}\n\t\t\t\tmint now = 1;\n\t\t\t\tfor (int i = 0; i < cnt2 - 2; i++) {\n\t\t\t\t\tsum_e[i] = es[i] * now;\n\t\t\t\t\tnow *= ies[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int ph = 1; ph <= h; ph++) {\n\t\t\t\tint w = 1 << (ph - 1), p = 1 << (h - ph);\n\t\t\t\tmint now = 1;\n\t\t\t\tfor (int s = 0; s < w; s++) {\n\t\t\t\t\tint offset = s << (h - ph + 1);\n\t\t\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\t\t\tauto l = a[i + offset];\n\t\t\t\t\t\tauto r = a[i + offset + p] * now;\n\t\t\t\t\t\ta[i + offset] = l + r;\n\t\t\t\t\t\ta[i + offset + p] = l - r;\n\t\t\t\t\t}\n\t\t\t\t\tnow *= sum_e[bsf(~(unsigned int)(s))];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\n\t\tvoid butterfly_inv(std::vector<mint>& a) {\n\t\t\tstatic constexpr int g = internal::primitive_root<mint::mod()>;\n\t\t\tint n = int(a.size());\n\t\t\tint h = internal::ceil_pow2(n);\n\n\t\t\tstatic bool first = true;\n\t\t\tstatic mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tmint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n\t\t\t\tint cnt2 = bsf(mint::mod() - 1);\n\t\t\t\tmint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n\t\t\t\tfor (int i = cnt2; i >= 2; i--) {\n\t\t\t\t\tes[i - 2] = e;\n\t\t\t\t\ties[i - 2] = ie;\n\t\t\t\t\te *= e;\n\t\t\t\t\tie *= ie;\n\t\t\t\t}\n\t\t\t\tmint now = 1;\n\t\t\t\tfor (int i = 0; i < cnt2 - 2; i++) {\n\t\t\t\t\tsum_ie[i] = ies[i] * now;\n\t\t\t\t\tnow *= es[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int ph = h; ph >= 1; ph--) {\n\t\t\t\tint w = 1 << (ph - 1), p = 1 << (h - ph);\n\t\t\t\tmint inow = 1;\n\t\t\t\tfor (int s = 0; s < w; s++) {\n\t\t\t\t\tint offset = s << (h - ph + 1);\n\t\t\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\t\t\tauto l = a[i + offset];\n\t\t\t\t\t\tauto r = a[i + offset + p];\n\t\t\t\t\t\ta[i + offset] = l + r;\n\t\t\t\t\t\ta[i + offset + p] =\n\t\t\t\t\t\t\t(unsigned long long)(mint::mod() + l.val() - r.val()) *\n\t\t\t\t\t\t\tinow.val();\n\t\t\t\t\t}\n\t\t\t\t\tinow *= sum_ie[bsf(~(unsigned int)(s))];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}  // namespace internal\n\n\ttemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\n\tstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n\t\tint n = int(a.size()), m = int(b.size());\n\t\tif (!n || !m) return {};\n\t\tif (std::min(n, m) <= 60) {\n\t\t\tif (n < m) {\n\t\t\t\tstd::swap(n, m);\n\t\t\t\tstd::swap(a, b);\n\t\t\t}\n\t\t\tstd::vector<mint> ans(n + m - 1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tans[i + j] += a[i] * b[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tint z = 1 << internal::ceil_pow2(n + m - 1);\n\t\ta.resize(z);\n\t\tinternal::butterfly(a);\n\t\tb.resize(z);\n\t\tinternal::butterfly(b);\n\t\tfor (int i = 0; i < z; i++) {\n\t\t\ta[i] *= b[i];\n\t\t}\n\t\tinternal::butterfly_inv(a);\n\t\ta.resize(n + m - 1);\n\t\tmint iz = mint(z).inv();\n\t\tfor (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n\t\treturn a;\n\t}\n\n\ttemplate <unsigned int mod = 998244353,\n\t\tclass T,\n\t\tstd::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n\t\tstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n\t\tint n = int(a.size()), m = int(b.size());\n\t\tif (!n || !m) return {};\n\n\t\tusing mint = static_modint<mod>;\n\t\tstd::vector<mint> a2(n), b2(m);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta2[i] = mint(a[i]);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tb2[i] = mint(b[i]);\n\t\t}\n\t\tauto c2 = convolution(move(a2), move(b2));\n\t\tstd::vector<T> c(n + m - 1);\n\t\tfor (int i = 0; i < n + m - 1; i++) {\n\t\t\tc[i] = c2[i].val();\n\t\t}\n\t\treturn c;\n\t}\n\n\tstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n\t\tconst std::vector<long long>& b) {\n\t\tint n = int(a.size()), m = int(b.size());\n\t\tif (!n || !m) return {};\n\n\t\tstatic constexpr unsigned long long MOD1 = 754974721;  // 2^24\n\t\tstatic constexpr unsigned long long MOD2 = 167772161;  // 2^25\n\t\tstatic constexpr unsigned long long MOD3 = 469762049;  // 2^26\n\t\tstatic constexpr unsigned long long M2M3 = MOD2 * MOD3;\n\t\tstatic constexpr unsigned long long M1M3 = MOD1 * MOD3;\n\t\tstatic constexpr unsigned long long M1M2 = MOD1 * MOD2;\n\t\tstatic constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n\t\tstatic constexpr unsigned long long i1 =\n\t\t\tinternal::inv_gcd(MOD2 * MOD3, MOD1).second;\n\t\tstatic constexpr unsigned long long i2 =\n\t\t\tinternal::inv_gcd(MOD1 * MOD3, MOD2).second;\n\t\tstatic constexpr unsigned long long i3 =\n\t\t\tinternal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n\t\tauto c1 = convolution<MOD1>(a, b);\n\t\tauto c2 = convolution<MOD2>(a, b);\n\t\tauto c3 = convolution<MOD3>(a, b);\n\n\t\tstd::vector<long long> c(n + m - 1);\n\t\tfor (int i = 0; i < n + m - 1; i++) {\n\t\t\tunsigned long long x = 0;\n\t\t\tx += (c1[i] * i1) % MOD1 * M2M3;\n\t\t\tx += (c2[i] * i2) % MOD2 * M1M3;\n\t\t\tx += (c3[i] * i3) % MOD3 * M1M2;\n\t\t\tlong long diff =\n\t\t\t\tc1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n\t\t\tif (diff < 0) diff += MOD1;\n\t\t\tstatic constexpr unsigned long long offset[5] = {\n\t\t\t\t0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3 };\n\t\t\tx -= offset[diff % 5];\n\t\t\tc[i] = x;\n\t\t}\n\n\t\treturn c;\n\t}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\tstruct dsu {\n\tpublic:\n\t\tdsu() : _n(0) {}\n\t\tdsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n\t\tint merge(int a, int b) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\tassert(0 <= b && b < _n);\n\t\t\tint x = leader(a), y = leader(b);\n\t\t\tif (x == y) return x;\n\t\t\tif (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n\t\t\tparent_or_size[x] += parent_or_size[y];\n\t\t\tparent_or_size[y] = x;\n\t\t\treturn x;\n\t\t}\n\n\t\tbool same(int a, int b) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\tassert(0 <= b && b < _n);\n\t\t\treturn leader(a) == leader(b);\n\t\t}\n\n\t\tint leader(int a) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\tif (parent_or_size[a] < 0) return a;\n\t\t\treturn parent_or_size[a] = leader(parent_or_size[a]);\n\t\t}\n\n\t\tint size(int a) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\treturn -parent_or_size[leader(a)];\n\t\t}\n\n\t\tstd::vector<std::vector<int>> groups() {\n\t\t\tstd::vector<int> leader_buf(_n), group_size(_n);\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tleader_buf[i] = leader(i);\n\t\t\t\tgroup_size[leader_buf[i]]++;\n\t\t\t}\n\t\t\tstd::vector<std::vector<int>> result(_n);\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tresult[i].reserve(group_size[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tresult[leader_buf[i]].push_back(i);\n\t\t\t}\n\t\t\tresult.erase(\n\t\t\t\tstd::remove_if(result.begin(), result.end(),\n\t\t\t\t\t[&](const std::vector<int>& v) { return v.empty(); }),\n\t\t\t\tresult.end());\n\t\t\treturn result;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<int> parent_or_size;\n\t};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class T> struct fenwick_tree {\n\t\tusing U = internal::to_unsigned_t<T>;\n\n\tpublic:\n\t\tfenwick_tree() : _n(0) {}\n\t\tfenwick_tree(int n) : _n(n), data(n) {}\n\n\t\tvoid add(int p, T x) {\n\t\t\tassert(0 <= p && p < _n);\n\t\t\tp++;\n\t\t\twhile (p <= _n) {\n\t\t\t\tdata[p - 1] += U(x);\n\t\t\t\tp += p & -p;\n\t\t\t}\n\t\t}\n\n\t\tT sum(int l, int r) {\n\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\treturn sum(r) - sum(l);\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<U> data;\n\n\t\tU sum(int r) {\n\t\t\tU s = 0;\n\t\t\twhile (r > 0) {\n\t\t\t\ts += data[r - 1];\n\t\t\t\tr -= r & -r;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\n\ttemplate <class S,\n\t\tS(*op)(S, S),\n\t\tS(*e)(),\n\t\tclass F,\n\t\tS(*mapping)(F, S),\n\t\tF(*composition)(F, F),\n\t\tF(*id)()>\n\t\tstruct lazy_segtree {\n\t\tpublic:\n\t\t\tlazy_segtree() : lazy_segtree(0) {}\n\t\t\tlazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n\t\t\tlazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n\t\t\t\tlog = internal::ceil_pow2(_n);\n\t\t\t\tsize = 1 << log;\n\t\t\t\td = std::vector<S>(2 * size, e());\n\t\t\t\tlz = std::vector<F>(size, id());\n\t\t\t\tfor (int i = 0; i < _n; i++) d[size + i] = v[i];\n\t\t\t\tfor (int i = size - 1; i >= 1; i--) {\n\t\t\t\t\tupdate(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid set(int p, S x) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = x;\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\n\t\t\tS get(int p) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\treturn d[p];\n\t\t\t}\n\n\t\t\tS prod(int l, int r) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return e();\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push(r >> i);\n\t\t\t\t}\n\n\t\t\t\tS sml = e(), smr = e();\n\t\t\t\twhile (l < r) {\n\t\t\t\t\tif (l & 1) sml = op(sml, d[l++]);\n\t\t\t\t\tif (r & 1) smr = op(d[--r], smr);\n\t\t\t\t\tl >>= 1;\n\t\t\t\t\tr >>= 1;\n\t\t\t\t}\n\n\t\t\t\treturn op(sml, smr);\n\t\t\t}\n\n\t\t\tS all_prod() { return d[1]; }\n\n\t\t\tvoid apply(int p, F f) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = mapping(f, d[p]);\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\t\t\tvoid apply(int l, int r, F f) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return;\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tint l2 = l, r2 = r;\n\t\t\t\t\twhile (l < r) {\n\t\t\t\t\t\tif (l & 1) all_apply(l++, f);\n\t\t\t\t\t\tif (r & 1) all_apply(--r, f);\n\t\t\t\t\t\tl >>= 1;\n\t\t\t\t\t\tr >>= 1;\n\t\t\t\t\t}\n\t\t\t\t\tl = l2;\n\t\t\t\t\tr = r2;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 1; i <= log; i++) {\n\t\t\t\t\tif (((l >> i) << i) != l) update(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) update((r - 1) >> i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttemplate <bool (*g)(S)> int max_right(int l) {\n\t\t\t\treturn max_right(l, [](S x) { return g(x); });\n\t\t\t}\n\t\t\ttemplate <class G> int max_right(int l, G g) {\n\t\t\t\tassert(0 <= l && l <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (l == _n) return _n;\n\t\t\t\tl += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(l >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\t\t\tif (!g(op(sm, d[l]))) {\n\t\t\t\t\t\twhile (l < size) {\n\t\t\t\t\t\t\tpush(l);\n\t\t\t\t\t\t\tl = (2 * l);\n\t\t\t\t\t\t\tif (g(op(sm, d[l]))) {\n\t\t\t\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn l - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\tl++;\n\t\t\t\t} while ((l & -l) != l);\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\ttemplate <bool (*g)(S)> int min_left(int r) {\n\t\t\t\treturn min_left(r, [](S x) { return g(x); });\n\t\t\t}\n\t\t\ttemplate <class G> int min_left(int r, G g) {\n\t\t\t\tassert(0 <= r && r <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (r == 0) return 0;\n\t\t\t\tr += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push((r - 1) >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\tr--;\n\t\t\t\t\twhile (r > 1 && (r % 2)) r >>= 1;\n\t\t\t\t\tif (!g(op(d[r], sm))) {\n\t\t\t\t\t\twhile (r < size) {\n\t\t\t\t\t\t\tpush(r);\n\t\t\t\t\t\t\tr = (2 * r + 1);\n\t\t\t\t\t\t\tif (g(op(d[r], sm))) {\n\t\t\t\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn r + 1 - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t} while ((r & -r) != r);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n, size, log;\n\t\t\tstd::vector<S> d;\n\t\t\tstd::vector<F> lz;\n\n\t\t\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\t\t\tvoid all_apply(int k, F f) {\n\t\t\t\td[k] = mapping(f, d[k]);\n\t\t\t\tif (k < size) lz[k] = composition(f, lz[k]);\n\t\t\t}\n\t\t\tvoid push(int k) {\n\t\t\t\tall_apply(2 * k, lz[k]);\n\t\t\t\tall_apply(2 * k + 1, lz[k]);\n\t\t\t\tlz[k] = id();\n\t\t\t}\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\n\tlong long pow_mod(long long x, long long n, int m) {\n\t\tassert(0 <= n && 1 <= m);\n\t\tif (m == 1) return 0;\n\t\tinternal::barrett bt((unsigned int)(m));\n\t\tunsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n\t\twhile (n) {\n\t\t\tif (n & 1) r = bt.mul(r, y);\n\t\t\ty = bt.mul(y, y);\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn r;\n\t}\n\n\tlong long inv_mod(long long x, long long m) {\n\t\tassert(1 <= m);\n\t\tauto z = internal::inv_gcd(x, m);\n\t\tassert(z.first == 1);\n\t\treturn z.second;\n\t}\n\n\tstd::pair<long long, long long> crt(const std::vector<long long>& r,\n\t\tconst std::vector<long long>& m) {\n\t\tassert(r.size() == m.size());\n\t\tint n = int(r.size());\n\t\tlong long r0 = 0, m0 = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(1 <= m[i]);\n\t\t\tlong long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n\t\t\tif (m0 < m1) {\n\t\t\t\tstd::swap(r0, r1);\n\t\t\t\tstd::swap(m0, m1);\n\t\t\t}\n\t\t\tif (m0 % m1 == 0) {\n\t\t\t\tif (r0 % m1 != r1) return { 0, 0 };\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\tlong long g, im;\n\t\t\tstd::tie(g, im) = internal::inv_gcd(m0, m1);\n\n\t\t\tlong long u1 = (m1 / g);\n\t\t\tif ((r1 - r0) % g) return { 0, 0 };\n\n\t\t\tlong long x = (r1 - r0) / g % u1 * im % u1;\n\n\t\t\tr0 += x * m0;\n\t\t\tm0 *= u1;  // -> lcm(m0, m1)\n\t\t\tif (r0 < 0) r0 += m0;\n\t\t}\n\t\treturn { r0, m0 };\n\t}\n\n\tlong long floor_sum(long long n, long long m, long long a, long long b) {\n\t\tlong long ans = 0;\n\t\tif (a >= m) {\n\t\t\tans += (n - 1) * n * (a / m) / 2;\n\t\t\ta %= m;\n\t\t}\n\t\tif (b >= m) {\n\t\t\tans += n * (b / m);\n\t\t\tb %= m;\n\t\t}\n\n\t\tlong long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n\t\tif (y_max == 0) return ans;\n\t\tans += (n - (x_max + a - 1) / a) * y_max;\n\t\tans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n\t\treturn ans;\n\t}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\ttemplate <class T> struct simple_queue {\n\t\t\tstd::vector<T> payload;\n\t\t\tint pos = 0;\n\t\t\tvoid reserve(int n) { payload.reserve(n); }\n\t\t\tint size() const { return int(payload.size()) - pos; }\n\t\t\tbool empty() const { return pos == int(payload.size()); }\n\t\t\tvoid push(const T& t) { payload.push_back(t); }\n\t\t\tT& front() { return payload[pos]; }\n\t\t\tvoid clear() {\n\t\t\t\tpayload.clear();\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\tvoid pop() { pos++; }\n\t\t};\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class Cap> struct mf_graph {\n\tpublic:\n\t\tmf_graph() : _n(0) {}\n\t\tmf_graph(int n) : _n(n), g(n) {}\n\n\t\tint add_edge(int from, int to, Cap cap) {\n\t\t\tassert(0 <= from && from < _n);\n\t\t\tassert(0 <= to && to < _n);\n\t\t\tassert(0 <= cap);\n\t\t\tint m = int(pos.size());\n\t\t\tpos.push_back({ from, int(g[from].size()) });\n\t\t\tg[from].push_back(_edge{ to, int(g[to].size()), cap });\n\t\t\tg[to].push_back(_edge{ from, int(g[from].size()) - 1, 0 });\n\t\t\treturn m;\n\t\t}\n\n\t\tstruct edge {\n\t\t\tint from, to;\n\t\t\tCap cap, flow;\n\t\t};\n\n\t\tedge get_edge(int i) {\n\t\t\tint m = int(pos.size());\n\t\t\tassert(0 <= i && i < m);\n\t\t\tauto _e = g[pos[i].first][pos[i].second];\n\t\t\tauto _re = g[_e.to][_e.rev];\n\t\t\treturn edge{ pos[i].first, _e.to, _e.cap + _re.cap, _re.cap };\n\t\t}\n\t\tstd::vector<edge> edges() {\n\t\t\tint m = int(pos.size());\n\t\t\tstd::vector<edge> result;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tresult.push_back(get_edge(i));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvoid change_edge(int i, Cap new_cap, Cap new_flow) {\n\t\t\tint m = int(pos.size());\n\t\t\tassert(0 <= i && i < m);\n\t\t\tassert(0 <= new_flow && new_flow <= new_cap);\n\t\t\tauto& _e = g[pos[i].first][pos[i].second];\n\t\t\tauto& _re = g[_e.to][_e.rev];\n\t\t\t_e.cap = new_cap - new_flow;\n\t\t\t_re.cap = new_flow;\n\t\t}\n\n\t\tCap flow(int s, int t) {\n\t\t\treturn flow(s, t, std::numeric_limits<Cap>::max());\n\t\t}\n\t\tCap flow(int s, int t, Cap flow_limit) {\n\t\t\tassert(0 <= s && s < _n);\n\t\t\tassert(0 <= t && t < _n);\n\n\t\t\tstd::vector<int> level(_n), iter(_n);\n\t\t\tinternal::simple_queue<int> que;\n\n\t\t\tauto bfs = [&]() {\n\t\t\t\tstd::fill(level.begin(), level.end(), -1);\n\t\t\t\tlevel[s] = 0;\n\t\t\t\tque.clear();\n\t\t\t\tque.push(s);\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\tint v = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tfor (auto e : g[v]) {\n\t\t\t\t\t\tif (e.cap == 0 || level[e.to] >= 0) continue;\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tif (e.to == t) return;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tauto dfs = [&](auto self, int v, Cap up) {\n\t\t\t\tif (v == s) return up;\n\t\t\t\tCap res = 0;\n\t\t\t\tint level_v = level[v];\n\t\t\t\tfor (int& i = iter[v]; i < int(g[v].size()); i++) {\n\t\t\t\t\t_edge& e = g[v][i];\n\t\t\t\t\tif (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n\t\t\t\t\tCap d =\n\t\t\t\t\t\tself(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n\t\t\t\t\tif (d <= 0) continue;\n\t\t\t\t\tg[v][i].cap += d;\n\t\t\t\t\tg[e.to][e.rev].cap -= d;\n\t\t\t\t\tres += d;\n\t\t\t\t\tif (res == up) break;\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t};\n\n\t\t\tCap flow = 0;\n\t\t\twhile (flow < flow_limit) {\n\t\t\t\tbfs();\n\t\t\t\tif (level[t] == -1) break;\n\t\t\t\tstd::fill(iter.begin(), iter.end(), 0);\n\t\t\t\twhile (flow < flow_limit) {\n\t\t\t\t\tCap f = dfs(dfs, t, flow_limit - flow);\n\t\t\t\t\tif (!f) break;\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\n\t\tstd::vector<bool> min_cut(int s) {\n\t\t\tstd::vector<bool> visited(_n);\n\t\t\tinternal::simple_queue<int> que;\n\t\t\tque.push(s);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint p = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tvisited[p] = true;\n\t\t\t\tfor (auto e : g[p]) {\n\t\t\t\t\tif (e.cap && !visited[e.to]) {\n\t\t\t\t\t\tvisited[e.to] = true;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn visited;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstruct _edge {\n\t\t\tint to, rev;\n\t\t\tCap cap;\n\t\t};\n\t\tstd::vector<std::pair<int, int>> pos;\n\t\tstd::vector<std::vector<_edge>> g;\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class Cap, class Cost> struct mcf_graph {\n\tpublic:\n\t\tmcf_graph() {}\n\t\tmcf_graph(int n) : _n(n), g(n) {}\n\n\t\tint add_edge(int from, int to, Cap cap, Cost cost) {\n\t\t\tassert(0 <= from && from < _n);\n\t\t\tassert(0 <= to && to < _n);\n\t\t\tint m = int(pos.size());\n\t\t\tpos.push_back({ from, int(g[from].size()) });\n\t\t\tg[from].push_back(_edge{ to, int(g[to].size()), cap, cost });\n\t\t\tg[to].push_back(_edge{ from, int(g[from].size()) - 1, 0, -cost });\n\t\t\treturn m;\n\t\t}\n\n\t\tstruct edge {\n\t\t\tint from, to;\n\t\t\tCap cap, flow;\n\t\t\tCost cost;\n\t\t};\n\n\t\tedge get_edge(int i) {\n\t\t\tint m = int(pos.size());\n\t\t\tassert(0 <= i && i < m);\n\t\t\tauto _e = g[pos[i].first][pos[i].second];\n\t\t\tauto _re = g[_e.to][_e.rev];\n\t\t\treturn edge{\n\t\t\t\tpos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n\t\t\t};\n\t\t}\n\t\tstd::vector<edge> edges() {\n\t\t\tint m = int(pos.size());\n\t\t\tstd::vector<edge> result(m);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tresult[i] = get_edge(i);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tstd::pair<Cap, Cost> flow(int s, int t) {\n\t\t\treturn flow(s, t, std::numeric_limits<Cap>::max());\n\t\t}\n\t\tstd::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n\t\t\treturn slope(s, t, flow_limit).back();\n\t\t}\n\t\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n\t\t\treturn slope(s, t, std::numeric_limits<Cap>::max());\n\t\t}\n\t\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n\t\t\tassert(0 <= s && s < _n);\n\t\t\tassert(0 <= t && t < _n);\n\t\t\tassert(s != t);\n\t\t\tstd::vector<Cost> dual(_n, 0), dist(_n);\n\t\t\tstd::vector<int> pv(_n), pe(_n);\n\t\t\tstd::vector<bool> vis(_n);\n\t\t\tauto dual_ref = [&]() {\n\t\t\t\tstd::fill(dist.begin(), dist.end(),\n\t\t\t\t\tstd::numeric_limits<Cost>::max());\n\t\t\t\tstd::fill(pv.begin(), pv.end(), -1);\n\t\t\t\tstd::fill(pe.begin(), pe.end(), -1);\n\t\t\t\tstd::fill(vis.begin(), vis.end(), false);\n\t\t\t\tstruct Q {\n\t\t\t\t\tCost key;\n\t\t\t\t\tint to;\n\t\t\t\t\tbool operator<(Q r) const { return key > r.key; }\n\t\t\t\t};\n\t\t\t\tstd::priority_queue<Q> que;\n\t\t\t\tdist[s] = 0;\n\t\t\t\tque.push(Q{ 0, s });\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\tint v = que.top().to;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (vis[v]) continue;\n\t\t\t\t\tvis[v] = true;\n\t\t\t\t\tif (v == t) break;\n\t\t\t\t\tfor (int i = 0; i < int(g[v].size()); i++) {\n\t\t\t\t\t\tauto e = g[v][i];\n\t\t\t\t\t\tif (vis[e.to] || !e.cap) continue;\n\t\t\t\t\t\tCost cost = e.cost - dual[e.to] + dual[v];\n\t\t\t\t\t\tif (dist[e.to] - dist[v] > cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + cost;\n\t\t\t\t\t\t\tpv[e.to] = v;\n\t\t\t\t\t\t\tpe[e.to] = i;\n\t\t\t\t\t\t\tque.push(Q{ dist[e.to], e.to });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!vis[t]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tfor (int v = 0; v < _n; v++) {\n\t\t\t\t\tif (!vis[v]) continue;\n\t\t\t\t\tdual[v] -= dist[t] - dist[v];\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\t\t\tCap flow = 0;\n\t\t\tCost cost = 0, prev_cost = -1;\n\t\t\tstd::vector<std::pair<Cap, Cost>> result;\n\t\t\tresult.push_back({ flow, cost });\n\t\t\twhile (flow < flow_limit) {\n\t\t\t\tif (!dual_ref()) break;\n\t\t\t\tCap c = flow_limit - flow;\n\t\t\t\tfor (int v = t; v != s; v = pv[v]) {\n\t\t\t\t\tc = std::min(c, g[pv[v]][pe[v]].cap);\n\t\t\t\t}\n\t\t\t\tfor (int v = t; v != s; v = pv[v]) {\n\t\t\t\t\tauto& e = g[pv[v]][pe[v]];\n\t\t\t\t\te.cap -= c;\n\t\t\t\t\tg[v][e.rev].cap += c;\n\t\t\t\t}\n\t\t\t\tCost d = -dual[s];\n\t\t\t\tflow += c;\n\t\t\t\tcost += c * d;\n\t\t\t\tif (prev_cost == d) {\n\t\t\t\t\tresult.pop_back();\n\t\t\t\t}\n\t\t\t\tresult.push_back({ flow, cost });\n\t\t\t\tprev_cost = cost;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\n\t\tstruct _edge {\n\t\t\tint to, rev;\n\t\t\tCap cap;\n\t\t\tCost cost;\n\t\t};\n\n\t\tstd::vector<std::pair<int, int>> pos;\n\t\tstd::vector<std::vector<_edge>> g;\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n\tnamespace internal {\n\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges)\n\t\t\t\t: start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() { return _n; }\n\n\t\t\tvoid add_edge(int from, int to) { edges.push_back({ from, {to} }); }\n\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn { group_num, ids };\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\tstruct scc_graph {\n\tpublic:\n\t\tscc_graph() : internal(0) {}\n\t\tscc_graph(int n) : internal(n) {}\n\n\t\tvoid add_edge(int from, int to) {\n\t\t\tint n = internal.num_vertices();\n\t\t\tassert(0 <= from && from < n);\n\t\t\tassert(0 <= to && to < n);\n\t\t\tinternal.add_edge(from, to);\n\t\t}\n\n\t\tstd::vector<std::vector<int>> scc() { return internal.scc(); }\n\n\tprivate:\n\t\tinternal::scc_graph internal;\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class S, S(*op)(S, S), S(*e)()> struct segtree {\n\tpublic:\n\t\tsegtree() : segtree(0) {}\n\t\tsegtree(int n) : segtree(std::vector<S>(n, e())) {}\n\t\tsegtree(const std::vector<S>& v) : _n(int(v.size())) {\n\t\t\tlog = internal::ceil_pow2(_n);\n\t\t\tsize = 1 << log;\n\t\t\td = std::vector<S>(2 * size, e());\n\t\t\tfor (int i = 0; i < _n; i++) d[size + i] = v[i];\n\t\t\tfor (int i = size - 1; i >= 1; i--) {\n\t\t\t\tupdate(i);\n\t\t\t}\n\t\t}\n\n\t\tvoid set(int p, S x) {\n\t\t\tassert(0 <= p && p < _n);\n\t\t\tp += size;\n\t\t\td[p] = x;\n\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t}\n\n\t\tS get(int p) {\n\t\t\tassert(0 <= p && p < _n);\n\t\t\treturn d[p + size];\n\t\t}\n\n\t\tS prod(int l, int r) {\n\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\tS sml = e(), smr = e();\n\t\t\tl += size;\n\t\t\tr += size;\n\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1) sml = op(sml, d[l++]);\n\t\t\t\tif (r & 1) smr = op(d[--r], smr);\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\treturn op(sml, smr);\n\t\t}\n\n\t\tS all_prod() { return d[1]; }\n\n\t\ttemplate <bool (*f)(S)> int max_right(int l) {\n\t\t\treturn max_right(l, [](S x) { return f(x); });\n\t\t}\n\t\ttemplate <class F> int max_right(int l, F f) {\n\t\t\tassert(0 <= l && l <= _n);\n\t\t\tassert(f(e()));\n\t\t\tif (l == _n) return _n;\n\t\t\tl += size;\n\t\t\tS sm = e();\n\t\t\tdo {\n\t\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\t\tif (!f(op(sm, d[l]))) {\n\t\t\t\t\twhile (l < size) {\n\t\t\t\t\t\tl = (2 * l);\n\t\t\t\t\t\tif (f(op(sm, d[l]))) {\n\t\t\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn l - size;\n\t\t\t\t}\n\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\tl++;\n\t\t\t} while ((l & -l) != l);\n\t\t\treturn _n;\n\t\t}\n\n\t\ttemplate <bool (*f)(S)> int min_left(int r) {\n\t\t\treturn min_left(r, [](S x) { return f(x); });\n\t\t}\n\t\ttemplate <class F> int min_left(int r, F f) {\n\t\t\tassert(0 <= r && r <= _n);\n\t\t\tassert(f(e()));\n\t\t\tif (r == 0) return 0;\n\t\t\tr += size;\n\t\t\tS sm = e();\n\t\t\tdo {\n\t\t\t\tr--;\n\t\t\t\twhile (r > 1 && (r % 2)) r >>= 1;\n\t\t\t\tif (!f(op(d[r], sm))) {\n\t\t\t\t\twhile (r < size) {\n\t\t\t\t\t\tr = (2 * r + 1);\n\t\t\t\t\t\tif (f(op(d[r], sm))) {\n\t\t\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn r + 1 - size;\n\t\t\t\t}\n\t\t\t\tsm = op(d[r], sm);\n\t\t\t} while ((r & -r) != r);\n\t\t\treturn 0;\n\t\t}\n\n\tprivate:\n\t\tint _n, size, log;\n\t\tstd::vector<S> d;\n\n\t\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tstd::vector<int> sa_naive(const std::vector<int>& s) {\n\t\t\tint n = int(s.size());\n\t\t\tstd::vector<int> sa(n);\n\t\t\tstd::iota(sa.begin(), sa.end(), 0);\n\t\t\tstd::sort(sa.begin(), sa.end(), [&](int l, int r) {\n\t\t\t\tif (l == r) return false;\n\t\t\t\twhile (l < n && r < n) {\n\t\t\t\t\tif (s[l] != s[r]) return s[l] < s[r];\n\t\t\t\t\tl++;\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\treturn l == n;\n\t\t\t\t});\n\t\t\treturn sa;\n\t\t}\n\n\t\tstd::vector<int> sa_doubling(const std::vector<int>& s) {\n\t\t\tint n = int(s.size());\n\t\t\tstd::vector<int> sa(n), rnk = s, tmp(n);\n\t\t\tstd::iota(sa.begin(), sa.end(), 0);\n\t\t\tfor (int k = 1; k < n; k *= 2) {\n\t\t\t\tauto cmp = [&](int x, int y) {\n\t\t\t\t\tif (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n\t\t\t\t\tint rx = x + k < n ? rnk[x + k] : -1;\n\t\t\t\t\tint ry = y + k < n ? rnk[y + k] : -1;\n\t\t\t\t\treturn rx < ry;\n\t\t\t\t};\n\t\t\t\tstd::sort(sa.begin(), sa.end(), cmp);\n\t\t\t\ttmp[sa[0]] = 0;\n\t\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t\t}\n\t\t\t\tstd::swap(tmp, rnk);\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\n\t\ttemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n\t\tstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n\t\t\tint n = int(s.size());\n\t\t\tif (n == 0) return {};\n\t\t\tif (n == 1) return { 0 };\n\t\t\tif (n == 2) {\n\t\t\t\tif (s[0] < s[1]) {\n\t\t\t\t\treturn { 0, 1 };\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn { 1, 0 };\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n < THRESHOLD_NAIVE) {\n\t\t\t\treturn sa_naive(s);\n\t\t\t}\n\t\t\tif (n < THRESHOLD_DOUBLING) {\n\t\t\t\treturn sa_doubling(s);\n\t\t\t}\n\n\t\t\tstd::vector<int> sa(n);\n\t\t\tstd::vector<bool> ls(n);\n\t\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\t\tls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n\t\t\t}\n\t\t\tstd::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!ls[i]) {\n\t\t\t\t\tsum_s[s[i]]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum_l[s[i] + 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= upper; i++) {\n\t\t\t\tsum_s[i] += sum_l[i];\n\t\t\t\tif (i < upper) sum_l[i + 1] += sum_s[i];\n\t\t\t}\n\n\t\t\tauto induce = [&](const std::vector<int>& lms) {\n\t\t\t\tstd::fill(sa.begin(), sa.end(), -1);\n\t\t\t\tstd::vector<int> buf(upper + 1);\n\t\t\t\tstd::copy(sum_s.begin(), sum_s.end(), buf.begin());\n\t\t\t\tfor (auto d : lms) {\n\t\t\t\t\tif (d == n) continue;\n\t\t\t\t\tsa[buf[s[d]]++] = d;\n\t\t\t\t}\n\t\t\t\tstd::copy(sum_l.begin(), sum_l.end(), buf.begin());\n\t\t\t\tsa[buf[s[n - 1]]++] = n - 1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint v = sa[i];\n\t\t\t\t\tif (v >= 1 && !ls[v - 1]) {\n\t\t\t\t\t\tsa[buf[s[v - 1]]++] = v - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstd::copy(sum_l.begin(), sum_l.end(), buf.begin());\n\t\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\t\tint v = sa[i];\n\t\t\t\t\tif (v >= 1 && ls[v - 1]) {\n\t\t\t\t\t\tsa[--buf[s[v - 1] + 1]] = v - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tstd::vector<int> lms_map(n + 1, -1);\n\t\t\tint m = 0;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (!ls[i - 1] && ls[i]) {\n\t\t\t\t\tlms_map[i] = m++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::vector<int> lms;\n\t\t\tlms.reserve(m);\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (!ls[i - 1] && ls[i]) {\n\t\t\t\t\tlms.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinduce(lms);\n\n\t\t\tif (m) {\n\t\t\t\tstd::vector<int> sorted_lms;\n\t\t\t\tsorted_lms.reserve(m);\n\t\t\t\tfor (int v : sa) {\n\t\t\t\t\tif (lms_map[v] != -1) sorted_lms.push_back(v);\n\t\t\t\t}\n\t\t\t\tstd::vector<int> rec_s(m);\n\t\t\t\tint rec_upper = 0;\n\t\t\t\trec_s[lms_map[sorted_lms[0]]] = 0;\n\t\t\t\tfor (int i = 1; i < m; i++) {\n\t\t\t\t\tint l = sorted_lms[i - 1], r = sorted_lms[i];\n\t\t\t\t\tint end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n\t\t\t\t\tint end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n\t\t\t\t\tbool same = true;\n\t\t\t\t\tif (end_l - l != end_r - r) {\n\t\t\t\t\t\tsame = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twhile (l < end_l) {\n\t\t\t\t\t\t\tif (s[l] != s[r]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (l == n || s[l] != s[r]) same = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!same) rec_upper++;\n\t\t\t\t\trec_s[lms_map[sorted_lms[i]]] = rec_upper;\n\t\t\t\t}\n\n\t\t\t\tauto rec_sa =\n\t\t\t\t\tsa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tsorted_lms[i] = lms[rec_sa[i]];\n\t\t\t\t}\n\t\t\t\tinduce(sorted_lms);\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\n\t}  // namespace internal\n\n\tstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n\t\tassert(0 <= upper);\n\t\tfor (int d : s) {\n\t\t\tassert(0 <= d && d <= upper);\n\t\t}\n\t\tauto sa = internal::sa_is(s, upper);\n\t\treturn sa;\n\t}\n\n\ttemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> idx(n);\n\t\tiota(idx.begin(), idx.end(), 0);\n\t\tsort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n\t\tstd::vector<int> s2(n);\n\t\tint now = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i && s[idx[i - 1]] != s[idx[i]]) now++;\n\t\t\ts2[idx[i]] = now;\n\t\t}\n\t\treturn internal::sa_is(s2, now);\n\t}\n\n\tstd::vector<int> suffix_array(const std::string& s) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> s2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn internal::sa_is(s2, 255);\n\t}\n\n\ttemplate <class T>\n\tstd::vector<int> lcp_array(const std::vector<T>& s,\n\t\tconst std::vector<int>& sa) {\n\t\tint n = int(s.size());\n\t\tassert(n >= 1);\n\t\tstd::vector<int> rnk(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\trnk[sa[i]] = i;\n\t\t}\n\t\tstd::vector<int> lcp(n - 1);\n\t\tint h = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (h > 0) h--;\n\t\t\tif (rnk[i] == 0) continue;\n\t\t\tint j = sa[rnk[i] - 1];\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rnk[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n\n\tstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> s2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn lcp_array(s2, sa);\n\t}\n\n\ttemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n\t\tint n = int(s.size());\n\t\tif (n == 0) return {};\n\t\tstd::vector<int> z(n);\n\t\tz[0] = 0;\n\t\tfor (int i = 1, j = 0; i < n; i++) {\n\t\t\tint& k = z[i];\n\t\t\tk = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n\t\t\twhile (i + k < n && s[k] == s[i + k]) k++;\n\t\t\tif (j + z[j] < i + z[i]) j = i;\n\t\t}\n\t\tz[0] = n;\n\t\treturn z;\n\t}\n\n\tstd::vector<int> z_algorithm(const std::string& s) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> s2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn z_algorithm(s2);\n\t}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\tstruct two_sat {\n\tpublic:\n\t\ttwo_sat() : _n(0), scc(0) {}\n\t\ttwo_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n\t\tvoid add_clause(int i, bool f, int j, bool g) {\n\t\t\tassert(0 <= i && i < _n);\n\t\t\tassert(0 <= j && j < _n);\n\t\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t\t}\n\t\tbool satisfiable() {\n\t\t\tauto id = scc.scc_ids().second;\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tif (id[2 * i] == id[2 * i + 1]) return false;\n\t\t\t\t_answer[i] = id[2 * i] < id[2 * i + 1];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tstd::vector<bool> answer() { return _answer; }\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<bool> _answer;\n\t\tinternal::scc_graph scc;\n\t};\n\n}  // namespace atcoder\n\n/*\nend of AtCoder STL\n*/\n\n#define int ll\nusing namespace std;\nusing namespace atcoder;\ntypedef string::const_iterator State;\n#define eps 1e-8L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n};\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n#define int ll\nusing mint = modint998244353;\nmint cnter[400000];\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\tmint ans = 0;\n\tvector<mint> hogea;\n\thogea.push_back(1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\thogea.push_back(hogea.back() * (k - 1) / k);\n\t}\n\treverse(ALL(hogea));\n\tfenwick_tree<mint> seg(n + 1);\n\tfenwick_tree<mint> cnter(n + 1);\n\tvector<pair<int,int>> inputs;\n\tREP(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tinputs.push_back(mp(a, i));\n\t}\n\tsort(ALL(inputs));\n\tREP(i, inputs.size()) {\n\t\tint itr = max(inputs[i].second - k + 1, 0LL);\n\t\tmint hoge = seg.sum(0, itr);\n\t\thoge /= hogea[itr];\n\t\thoge = cnter.sum(0, itr + 1) - hoge;\n\t\tans += hoge / 2;\n\t\tseg.add(itr, hogea[itr]);\n\t\tcnter.add(itr, 1);\n\t}\n\treverse(ALL(inputs));\n\tseg = fenwick_tree<mint>(n + 1);\n\tcnter = fenwick_tree<mint>(n + 1);\n\tREP(i, inputs.size()) {\n\t\tint itr = max(inputs[i].second - k + 1, 0LL);\n\t\tmint hoge = seg.sum(0, itr);\n\t\thoge /= hogea[itr];\n\t\tans += hoge + (cnter.sum(0, itr) - hoge) / 2;\n\t\tseg.add(itr, hogea[itr]);\n\t\tcnter.add(itr, 1);\n\t}\n\tcout << ans.val() << endl;\n}\n#undef int\nint main() {\n\tinit();\n\tint t = 1;\n\t//cin >> t;\n\tREP(tea, t) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\nconst long long mod = 998244353ll, Inv2 = mod + 1 >> 1;\n\nlong long qpow(long long a, long long b) {\n\tlong long res = 1ll;\n\tfor (; b; b >>= 1, a = a * a % mod) {\n\t\tif (b & 1) res = res * a % mod;\n\t}\n\treturn res;\n}\n\nint n, k, perm[N];\nlong long bit[N], ans = 0ll;\nint lowbit(int x) {\n\treturn x & -x;\n}\nstruct fenwick {\n\tlong long bit[N];\n\tvoid clear() {\n\t\tfor (int i = 0; i <= n; i++) bit[i] = 0;\n\t}\n\tvoid add(int pos, long long x){\n\t\tfor (; pos <= n; pos += lowbit(pos)) bit[pos] = (bit[pos] + x) % mod;\n\t}\n\tlong long query(int pos) {\n\t\tlong long res = 0;\n\t\tfor (; pos; pos ^= lowbit(pos)) res = (res + bit[pos]) % mod;\n\t\treturn res;\n\t}\n} bit1, bit2;\n\nlong long inv1, inv2, pw1[N], pw2[N];\nint pre[N];\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &perm[i]);\n\n\t// We calculate the contribution of (l, r) (1 <= l < r <= n)\n\t// Part 1 : l <= k\n\t// Initialize\n\tans = (ans + 1ll * k * (k - 1) / 2 % mod * Inv2) % mod;\n\tinv1 = qpow(k, mod - 2) * (k - 1) % mod;\n\tinv2 = qpow(inv1, mod - 2);\n\tpw1[0] = 1ll, pw2[0] = 1ll;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpw1[i] = pw1[i - 1] * inv1 % mod;\n\t\tpw2[i] = pw2[i - 1] * inv2 % mod;\n\t}\n\tfor (int i = 0; i <= n; i++) pre[i] = 0;\n\tfor (int i = 1; i <= k; i++) pre[perm[i]] = 1;\n\tfor (int i = 1; i <= n; i++) pre[i] += pre[i - 1];\n\tfor (int i = k + 1; i <= n; i++) {\n\t\t// p_l < p_r\n\t\tans = (ans + Inv2 * pw1[i - k] % mod * pre[perm[i]]) % mod;\n\t\t// p_l > p_r\n\t\tans = (ans + (k - pre[perm[i]])) % mod;\n\t\tans = (ans + mod - Inv2 * pw1[i - k] % mod * (k - pre[perm[i]]) % mod) % mod;\n\t}\n\n\t// Part 2: l > k\n\tbit1.clear(), bit2.clear();\n\tfor (int i = k + 1; i <= n; i++) {\n\t\t// p_l < p_r\n\t\tans = (ans + Inv2 * pw1[i] % mod * bit2.query(perm[i])) % mod;\n\t\t// p_l > p_r\n\t\tans = (ans + bit1.query(n) - bit1.query(perm[i])) % mod;\n\t\tans = (ans + mod - Inv2 * pw1[i] % mod * (bit2.query(n) + mod - bit2.query(perm[i])) % mod) % mod;\n\t\tbit1.add(perm[i], 1), bit2.add(perm[i], pw2[i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <fstream>\n#include <cmath>\n#include <limits>\n#include <chrono>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\n#include <cassert>\n#include <atcoder/all>\nusing namespace atcoder;\n#pragma warning (disable: 4996)\nusing namespace std;\n\nusing ll = long long;\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nll ll_gcd(ll a, ll b) {\n    if (a < b) return ll_gcd(b, a);\n    ll r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nstruct UnionFind {\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    if (n < 0)return 0;\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nll merge_cnt(vector<ll>& a) {\n    int n = a.size();\n    if (n <= 1) { return 0; }\n\n    ll cnt = 0;\n    vector<ll> b(a.begin(), a.begin() + n / 2);\n    vector<ll> c(a.begin() + n / 2, a.end());\n\n    cnt += merge_cnt(b);\n    cnt += merge_cnt(c);\n\n    int ai = 0, bi = 0, ci = 0;\n    while (ai < n) {\n        if (bi < b.size() && (ci == c.size() || b[bi] <= c[ci])) {\n            a[ai++] = b[bi++];\n        }\n        else {\n            cnt += n / 2 - bi;\n            a[ai++] = c[ci++];\n        }\n    }\n    return cnt;\n}\n\n\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\nll op(ll a,ll b) {\n    return (a + b) % 998244353;\n}\n\nll e() {\n    return 0;\n}\n\nint main() {\n    ll n, k;\n    cin >> n >> k;\n    vector<ll> x(k);\n    vector<ll> z(n-k);\n    vector<pair<ll, ll>> d(n-k);\n    for (int i = 0; i < k; i++) {\n        cin >> x[i];\n    }\n    for (int i = 0; i < n-k; i++) {\n        cin >> z[i];\n        d[i].first = z[i];\n        d[i].second = i;\n    }\n    sort(x.begin(), x.end());\n    ll ans = 0;\n    for (int i = 0; i < n - k; i++) {\n        ll r = modpow(k-1, i+1, 998244353) * modinv(modpow(k, i+1, 998244353),998244353) % 998244353*modinv(2,998244353) % 998244353;\n        ll ok = -1;\n        ll ng = k;\n        while (ng - ok > 1) {\n            ll mid = (ok + ng) / 2;\n            if (x[mid] < z[i])ok = mid;\n            else ng = mid;\n        }\n        ok++;\n        ans += (ok * r + (k - ok) * (998244354 - r)) % 998244353;\n        ans %= 998244353;\n    }\n    sort(d.begin(), d.end());\n    segtree<ll, op, e> t(n-k);\n    segtree<ll, op, e> f(n - k);\n    ll h = 1;\n    for (int i = 0; i < n-k; i++) {\n        t.set(i,h);\n        h *= (k-1) * modinv(k,998244353) % 998244353;\n        h %= 998244353;\n    }\n    for (int i = 0; i < n - k; i++) {\n        ll g = t.prod(d[i].second+1, n-k);\n        ans += g * modinv(t.get(d[i].second), 998244353) % 998244353*modinv(2,998244353) % 998244353;\n        t.set(d[i].second, 0);\n        ans %= 998244353;\n    }\n    reverse(d.begin(), d.end());\n    for (int i = 0; i < n - k; i++) {\n        t.set(i, h);\n        h *= (k-1) * modinv(k, 998244353) % 998244353;\n        h %= 998244353;\n    }\n    for (int i = 0; i < n - k; i++) {\n        ll g = t.prod(d[i].second+1, n-k);\n        ans += n-k-d[i].second-1+998244353-(g * modinv(t.get(d[i].second), 998244353) % 998244353 * modinv(2, 998244353) % 998244353) % 998244353;\n        ans += f.prod(d[i].second, n - k);\n        t.set(d[i].second, 0);\n        f.set(d[i].second, 998244352);\n        \n        ans %= 998244353;\n    }\n    ans += k * (k-1)/2 % 998244353 * modinv(2,998244353) % 998244353;\n    ans %= 998244353;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nclass Add_Segment_Tree {\n\tvector<long long int>v;\n\tlong long int ret;\n\tint num;\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = Update(place * 2) + Update(place * 2 + 1);\n\t\treturn v[place];\n\t}\npublic:\n\tAdd_Segment_Tree(int n) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2)num *= 2;\n\t\tv.resize(num, 0);\n\t}\n\tvoid Add(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] += num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tv[place] = v[place * 2] + v[place * 2 + 1];\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid TopDown() {\n\t\tUpdate(1);\n\t}\n\tlong long int Sum(int a, int b) {\n\t\tret = 0;\n\t\tb++;\n\t\tfor (a += num / 2, b += num / 2; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1)ret += v[a++];\n\t\t\tif (b & 1)ret += v[--b];\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tlong long int ans = 0;\n\tvector<int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tAdd_Segment_Tree asg(N);\n\tAdd_Segment_Tree num(N);\n\tvector<long long int>by(N - K + 2, 1);\n\tby.back() = 1;\n\tfor (int i = by.size() - 2; i >= 0; i--) {\n\t\tby[i] = by[i + 1] * (K - 1);\n\t\tby[i] %= MOD;\n\t\tby[i] *= power(K, MOD - 2, MOD);\n\t\tby[i] %= MOD;\n\t}\n\tans += (K - 1)*K / 2 %MOD* power(2, MOD - 2, MOD);\n\tans %= MOD;\n\tfor (int i = 0; i < K; i++) {\n\t\tasg.Add(v[i], by[1], true);\n\t\tnum.Add(v[i], 1, true);\n\t}\n\tfor (int i = K; i < N; i++) {\n\t\tans -= asg.Sum(v[i] + 1, N)*power(by[i - K + 2], MOD - 2, MOD) % MOD*power(2, MOD - 2, MOD) % MOD;\n\t\tans += num.Sum(v[i] + 1, N);\n\t\tans += asg.Sum(1, v[i] - 1)*power(by[i - K + 2], MOD - 2, MOD) % MOD*power(2, MOD - 2, MOD) % MOD;\n\t\tnum.Add(v[i], 1, true);\n\t\tasg.Add(v[i], by[i - K + 2], true);\n\t\tans += MOD;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <cstdio>\n#include <cstdint>\n#define rep(i, n) for(int i=0; i<n; ++i)\nusing namespace std;\n\nconst unsigned int mod = 998244353;\n\nstruct mint {\n  unsigned int x;\n  mint():x(0) {}\n  mint(int64_t x_) {\n    int64_t v = int64_t(x_ % mod);\n    if(v < 0) v += mod;\n    x = (unsigned int)v;\n  }\n  static mint row(int v) {\n    mint v_;\n    v_.x = v;\n    return v_;\n  }\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    uint64_t z = x;\n    z *= a.x;\n    x = (unsigned int)(z % mod);\n    return *this;\n  }\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  friend bool operator==(const mint &a, const mint &b) {return a.x == b.x;}\n  friend bool operator!=(const mint &a, const mint &b) {return a.x != b.x;}\n  mint &operator++() {\n    x++;\n    if(x == mod) x = 0;\n    return *this;\n  }\n  mint &operator--() {\n    if(x == 0) x = mod;\n    x--;\n    return *this;\n  }\n  mint operator++(int) {\n    mint result = *this;\n    ++*this;\n    return result;\n  }\n  mint operator--(int) {\n    mint result = *this;\n    --*this;\n    return result;\n  }\n  mint pow(int64_t t) const {\n    mint x_ = *this, r = 1;\n    while(t) {\n      if(t&1) r *= x_;\n      x_ *= x_;\n      t >>= 1;\n    }\n    return r;\n  }\n  //for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) {return mint(*this) /= a;}\n};\n\n#define N 200100\n\n//head\n\nint n, k;\nint p[N];\nmint u[N], _u[N];\nmint ans;\nmint bit1[N], bit2[N];\nvoid add(int i, mint x, mint *bit) {\n  while(i <= n) {\n    bit[i] += x;\n    i += i&-i;\n  }\n}\nmint sum(int i, mint *bit) {\n  mint res;\n  while(i) {\n    res += bit[i];\n    i &= i-1;\n  }\n  return res;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  rep(i, n) scanf(\"%d\", p+i);\n  const mint g = mint(k-1)/k, _g = g.inv(), gg = mint(2).inv();\n  u[0] = _u[0] = 1;\n  rep(i, n-1) {\n    if(i < k-1) {\n      u[i+1] = u[i];\n      _u[i+1] = _u[i];\n    }\n    else {\n      u[i+1] = u[i]*g;\n      _u[i+1] = _u[i]*_g;\n    }\n  }\n  rep(i, n) {\n    ans += sum(p[i], bit1)*gg*u[i];\n    ans -= sum(p[i], bit2)-i;\n    ans -= (sum(n, bit1)-sum(p[i], bit1))*gg*u[i];\n    add(p[i], _u[i], bit1);\n    add(p[i], 1, bit2);\n  }\n  printf(\"%d\\n\", ans.x);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n{By GWj\n*/\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n#define R(a) cin>>a\n#define R2(a,b) cin>>a>>b\n#define check_min(a,b) a=min(a,b)\n#define check_max(a,b) a=max(a,b)\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\n/*}\n*/\nconst int MOD=998244353;\nLL quick(LL A,LL B){\n\tif(B==0) return 1;\n\tLL  tmp=quick(A,B>>1);\n\ttmp*=tmp;\n\ttmp%=MOD;\n\tif(B&1)\n\t\ttmp*=A,tmp%=MOD;\n \treturn tmp;\n}\nvoid add(int & A,int B){\n\tA+=B;\n\tif(A>=MOD) A-=MOD;\n}\nint inv(int A){return quick(A,MOD-2);}\nint x[200000+20];\nint n,k;\nconst int MAXN=200000;\nstruct BIT{\n\tvoid add(int & A,int B){\n\t\tA+=B;\n\t\tif(A>=MOD) A-=MOD;\n\t}\n\tint bit[MAXN+10]={0};\n\tint sum(int i){\n\t\tint s=0;\n\t\twhile(i>0){\n\t\t\tadd(s,bit[i]);\n\t\t\ti-=i&(-i);\n\t\t}\n\t\treturn s;\n\t}\n\tvoid modi(int i,int x=1){\n\t\twhile(i<=n){\n\t\t\tadd(bit[i],x);\n\t\t\ti+=i&(-i);\t\n\t\t}\n\t}\n}sum,cnt;\nint main(){\n\tfastio;\n\tint rest=0;\n\tcin>>n>>k;\n\trb(i,1,n) R(x[i]);\n\tint p=1ll*(k-1)*inv(k)%MOD;\n\trl(i,n,1){\n\t\tint fi=max(0,i-k);\n\t\tint tmp;\n\t\ttmp=sum.sum(n)-sum.sum(x[i]);\n\t\tif(tmp<0) tmp+=MOD;\n\t\ttmp=1ll*tmp*inv(quick(p,fi))%MOD;\n\t\tadd(rest,tmp);\n\t\t\n\t\t\n\t\t\n\t\ttmp=sum.sum(x[i]-1);\n\t\tint cn=cnt.sum(x[i]-1);\n\t\ttmp=1ll*tmp*inv(quick(p,fi))%MOD;\n\t\tcn-=tmp;\n\t\tif(cn<0) cn+=MOD;\n\t\tadd(rest,cn);\n\t\t\n\t\t\n\t\tcnt.modi(x[i]);\n\t\tsum.modi(x[i],1ll*inv(2)*quick(p,fi)%MOD);\n\t\t\n//\t\tcout<<rest<<\" \"<<p<<endl;\n\t}\n\tcout<<rest<<endl;\n\treturn 0;\n}\n/** 程序框架：\n  *\n  *\n  *\n  *\n  **/\n"
  },
  {
    "language": "C++",
    "code": "//@formatter:off\n#include<bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < int(n); ++i)\n#define rrep(i,n) for (int i = int(n)-1; i >= 0; i--)\n#define rep2(i,s,n) for (int i = int(s); i < int(n); ++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vd vector<double>\n#define vvd vector<vector<double>>\n#define vs vector<string>\n#define vc vector<char>\n#define vvc vector<vector<char>>\n#define vb vector<bool>\n#define vvb vector<vector<bool>>\n#define vp vector<P>\n#define vvp vector<vector<P>>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nusing LP = pair<ll,ll>;\ntemplate<class S,class T> istream& operator>>(istream &is,pair<S,T> &p) { return is >> p.first >> p.second; }\ntemplate<class S,class T> ostream& operator<<(ostream &os,const pair<S,T> &p) { return os<<'{'<<p.first<<\",\"<<p.second<<'}'; }\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) { for(T &t:v){is>>t;} return is; }\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) { os<<'[';rep(i,v.size())os<<v[i]<<(i==int(v.size()-1)?\"\":\",\"); return os<<']'; }\nvoid Yes(bool b) { cout << (b ? \"Yes\" : \"No\") << '\\n'; }\nvoid YES(bool b) { cout << (b ? \"YES\" : \"NO\") << '\\n'; }\ntemplate<class T> bool chmin(T& a,T b) {if(a > b){a = b; return true;} return false;}\ntemplate<class T> bool chmax(T& a,T b) {if(a < b){a = b; return true;} return false;}\nconst int inf = 1001001001;\nconst ll linf = 1001001001001001001;\n//@formatter:on\n\n//constexpr int mod = 1000000007;\nconstexpr int mod = 998244353;\n\nstruct mint {\n    ll x;\n    \n    constexpr mint(ll x = 0) : x((x % mod + mod) % mod) {}\n    \n    constexpr mint operator-() const { return mint(-x); }\n    \n    constexpr mint &operator+=(const mint &a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    \n    constexpr mint &operator++() { return *this += mint(1); }\n    \n    constexpr mint &operator-=(const mint &a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n    \n    constexpr mint &operator--() { return *this -= mint(1); }\n    \n    constexpr mint &operator*=(const mint &a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    \n    constexpr mint operator+(const mint &a) const {\n        mint res(*this);\n        return res += a;\n    }\n    \n    constexpr mint operator-(const mint &a) const {\n        mint res(*this);\n        return res -= a;\n    }\n    \n    constexpr mint operator*(const mint &a) const {\n        mint res(*this);\n        return res *= a;\n    }\n    \n    constexpr mint pow(ll t) const {\n        mint res = mint(1), a(*this);\n        while (t > 0) {\n            if (t & 1) res *= a;\n            t >>= 1;\n            a *= a;\n        }\n        return res;\n    }\n    \n    // for prime mod\n    constexpr mint inv() const { return pow(mod - 2); }\n    \n    constexpr mint &operator/=(const mint &a) { return *this *= a.inv(); }\n    \n    constexpr mint operator/(const mint &a) const {\n        mint res(*this);\n        return res /= a;\n    }\n};\n\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\ntemplate<typename T>\nclass BIT {\n    int n;\n    vector<T> val;\npublic:\n    BIT(int n) : n(n), val(n + 1, 0) {}\n    \n    void add(int i, T x = 1) {\n        i++;\n        while (i <= n) {\n            val[i] += x;\n            i += i & -i;\n        }\n    }\n    \n    T sum(int i) {\n        T ret = 0;\n        i++;\n        while (i > 0) {\n            ret += val[i];\n            i -= i & -i;\n        }\n        return ret;\n    }\n    \n    // [l,r)\n    T sum(int l, int r) { return sum(r - 1) - sum(l - 1); }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    mint t = mint(k - 1) / k;\n    vi p(n);\n    cin >> p;\n    rep(i, n) p[i]--;\n    vi v(n);\n    rep(i, n) v[i] = max(i - k + 1, 0);\n    BIT<int> cnt(n);\n    BIT<mint> sum(n);\n    mint ans = 0;\n    rep(i, n) {\n        ans += sum.sum(0, p[i]) * t.pow(v[i]) / 2;\n        ans += cnt.sum(p[i], n);\n        ans -= sum.sum(p[i], n) * t.pow(v[i]) / 2;\n        cnt.add(p[i]);\n        sum.add(p[i], mint(1) / t.pow(v[i]));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimization (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(v) v.begin(),v.end()\n#define P pair<int,int>\n#define len(s) (int)s.size()\n \ntemplate<class T> inline bool chmin(T &a, T b){\n\tif(a>b){a=b;return true;}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T &a, T b){\n\tif(a<b){a=b;return true;}\n\treturn false;\n}\nconstexpr int mod = 998244353;\nconstexpr long long inf = 3e18;\n\ntemplate<int MOD>\nstruct mint{\n\tint n;\n\tmint():n(0){}\n\tmint(int x):n(x>=0?x%MOD:(MOD-(-x)%MOD)%MOD){}\n\n\tmint &operator+=(const mint &p){\n\t\tif((n+=p.n)>=MOD)n-=MOD;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &p){\n\t\tif((n+=MOD-p.n)>=MOD)n-=MOD;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &p){\n\t\tn=n*p.n%MOD;\n\t\treturn *this;\n\t}\n\tmint &operator/=(const mint &p){\n\t\t*this*=p.inverse();\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint(-n);}\n\tmint operator+(const mint &p)const{return mint(*this)+=p;}\n\tmint operator-(const mint &p)const{return mint(*this)-=p;}\n\tmint operator*(const mint &p)const{return mint(*this)*=p;}\n\tmint operator/(const mint &p)const{return mint(*this)/=p;}\n\tmint operator==(const mint &p)const{return n==p.n;}\n\tmint operator!=(const mint &p)const{return n!=p.n;}\n\n\tfriend ostream &operator<<(ostream &os,const mint &p){\n\t\treturn os<<p.n;\n\t}\n\tfriend istream &operator>>(istream &is,mint &p){\n\t\tint x;is>>x;\n\t\tp=mint(x);\n\t\treturn is;\n\t}\n\tmint pow(int x)const{\n\t\tmint res(1),mul(n);\n\t\twhile(x>0){\n\t\t\tif(x&1)res*=mul;\n\t\t\tmul*=mul;\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inverse()const{\n\t\treturn pow(MOD-2);\n\t}\n};\nusing modint=mint<mod>;\n\ntemplate<class T>\nclass BIT{\n\tint N;\n\tvector<T>bit;\n\tvoid add_(int x,T y){\n\t\twhile(x<=N){\n\t\t\tbit[x]+=y;x+=x&-x;\n\t\t}\n\t}\n\tT sum_(int x){\n\t\tT res=0;\n\t\twhile(x>0){\n\t\t\tres+=bit[x];x-=x&-x;\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tint lower_bound(T w){\n\t\tif(w<=0)return -1;\n\t\tint x=0;\n\t\tint k=1;while(k*2<=N)k*=2;\n\t\tfor(;k>0;k/=2){\n\t\t\tif(x+k<=N&&bit[x+k]<w){\n\t\t\t\tw-=bit[x+k];\n\t\t\t\tx+=k;\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n\tvoid add(int x,T y){add_(x+1,y);}\n\tT sum(int l,int r){return sum_(r)-sum_(l);}\n\tBIT(int x):N(x),bit(x+1){}\n};\n\nint N,K,A[200005];\nsigned main(){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tcin>>N>>K;\n\trep(i,N){cin>>A[i];A[i]--;}\n\n\tBIT<modint>bit(N),bit2(N);\n\tmodint ans;\n\trep(i,N){\n\t\tint j=max(0ll,i+1-K);\n\t\tmodint k=(modint(K-1)/modint(K)).pow(j);\n\t\tans+=bit.sum(A[i],N)*k/modint(2);\n\t\tans+=bit2.sum(A[i],N)-bit.sum(A[i],N)*k;\n\t\tans+=bit.sum(0,A[i])*k/modint(2);\n\t\tbit.add(A[i],modint(1)/k);\n\t\tbit2.add(A[i],1);\n\t}\n\tcout<<ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//By TheOneYouWant\n#pragma GCC optimize (\"-O2\")\n#include <bits/stdc++.h>\n#include<atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define int long long int\n#define memreset(a) memset(a,0,sizeof(a))\n#define testcase(t) int t;cin>>t;while(t--)\n#define forstl(i,v) for(auto &i: v)\n#define forn(i,e) for(int i=0;i<e;++i)\n#define forsn(i,s,e) for(int i=s;i<e;++i)\n#define rforn(i,s) for(int i=s;i>=0;--i)\n#define rforsn(i,s,e) for(int i=s;i>=e;--i)\n#define bitcount(a) __builtin_popcount(a) // set bits (add ll)\n#define ln '\\n'\n#define getcurrtime() cerr<<\"Time = \"<<((double)clock()/CLOCKS_PER_SEC)<<endl\n#define dbgarr(v,s,e) cerr<<#v<<\" = \"; forsn(i,s,e) cerr<<v[i]<<\", \"; cerr<<endl\n#define inputfile freopen(\"input.txt\", \"r\", stdin)\n#define outputfile freopen(\"output.txt\", \"w\", stdout)\n#define dbg(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); \\\nstringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) { cerr<<endl; }\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << \"\\t\"; err(++it, args...);\n}\ntemplate<typename T1,typename T2>\nostream& operator <<(ostream& c,pair<T1,T2> &v){\n    c<<\"(\"<<v.fi<<\",\"<<v.se<<\")\"; return c;\n}\ntemplate <template <class...> class TT, class ...T>\nostream& operator<<(ostream& out,TT<T...>& c){\n    out<<\"{ \";\n    forstl(x,c) out<<x<<\" \";\n    out<<\"}\"; return out;\n}\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> p64;\ntypedef pair<int,int> p32;\ntypedef pair<int,p32> p96;\ntypedef vector<ll> v64;\ntypedef vector<int> v32; \ntypedef vector<v32> vv32;\ntypedef vector<v64> vv64;\ntypedef vector<p32> vp32;\ntypedef vector<p64> vp64;\ntypedef vector<vp32> vvp32;\ntypedef map<int,int> m32;\nconst int LIM=2e5+5,MOD=998244353;\nconst ld EPS = 1e-9;\n\nint read(){\n    int xx=0,ff=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')ff=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){xx=(xx<<3)+(xx<<1)+ch-'0';ch=getchar();}\n    return xx*ff;\n}\nusing mint = modint998244353;\n\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct S {\n    mint a;\n    int size;\n};\n\nstruct F {\n    mint a, b;\n};\n\nS op(S l, S r) { return S{l.a + r.a, l.size + r.size}; }\n\nS e() { return S{0, 0}; }\n\nS mapping(F l, S r) { return S{r.a * l.a + r.size * l.b, r.size}; }\n\nF composition(F l, F r) { return F{r.a * l.a, r.b * l.a + l.b}; }\n\nF id() { return F{1, 0}; }\n\nll mul(ll a, ll b){\n    return (a*b)%MOD;\n}\nll add(ll a, ll b){\n    return (a+b)%MOD;\n}\n\nll fastpow(ll a, ll p){\n    if(p == 0) return 1;\n    ll z = fastpow(a, p/2);\n    z = mul(z, z);\n    if(p%2) z = mul(a,z);\n    return z;\n}\n\nsigned main() {\n\n    int n, k;\n    cin>>n>>k;\n    int p[n];\n    forn(i,n){\n        cin>>p[i];\n        p[i]--;\n    }\n\n    vector<S> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = S{0, 0};\n    }\n\n    lazy_segtree<S, op, e, F, mapping, composition, id> seg(a);\n\n    mint ans = 0;\n\n    for(int i = 0; i < k; i++){\n        mint add1 = seg.prod(0,p[i]).a;\n        ans += add1;\n        mint add2 = seg.prod(p[i]+1,n).a;\n        mint sz = seg.prod(p[i]+1,n).size;\n        add2 = sz-add2;\n        ans += add2;\n        seg.set(p[i], S{fastpow(2,MOD-2),1});\n    }\n\n    mint app = mul(k-1, fastpow(k,MOD-2));\n\n    for(int i = k; i < n; i++){\n        seg.apply(0, n, F{app,0});\n        mint add1 = seg.prod(0,p[i]).a;\n        ans += add1;\n        mint add2 = seg.prod(p[i]+1,n).a;\n        mint sz = seg.prod(p[i]+1,n).size;\n        add2 = sz-add2;\n        ans += add2;\n        seg.set(p[i], S{fastpow(2,MOD-2),1});\n    }\n    cout<<ans.val()<<ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\ntemplate <typename _T>\ninline void read(_T &f) {\n    f = 0; _T fu = 1; char c = getchar();\n    while (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }\n    while (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }\n    f *= fu;\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    if (x < 0) putchar('-'), x = -x;\n    if (x < 10) putchar(x + 48);\n    else print(x / 10), putchar(x % 10 + 48);\n}\n\ntemplate <typename T>\nvoid print(T x, char t) {\n    print(x); putchar(t);\n}\n\nconst int N = 2e5 + 5, md = 998244353;\n\ninline int add(int x, int y) {\n    x += y;\n    if (x >= md) x -= md;\n    return x;\n}\n\ninline int sub(int x, int y) {\n    x -= y;\n    if (x < 0) x += md;\n    return x;\n}\n\ninline int mul(int x, int y) { return 1ll * x * y % md; }\n\ninline int fpow(int x, int y) {\n    int ans = 1;\n    while (y) {\n        if (y & 1) ans = mul(ans, x);\n        y >>= 1; x = mul(x, x);\n    }\n    return ans;\n}\n\nint a[N], id[N], s[N];\nint n, k, p, ans;\n\nbool cmp(int x, int y) { return a[x] < a[y]; }\n\nstruct fenwick {\n    int f[N];\n\n    inline int lowbit(int x) { return x & -x; }\n\n    inline void add(int x, int y) {\n        while (x <= n) {\n            f[x] = ::add(f[x], y);\n            x += lowbit(x);\n        }\n    }\n\n    inline int query(int x) {\n        int ans = 0;\n        while (x) {\n            ans = ::add(ans, f[x]);\n            x ^= lowbit(x);\n        }\n        return ans;\n    }\n} tr1, tr2;\n\nint main() {\n    read(n); read(k); p = mul(k - 1, fpow(k, md - 2));\n    for (int i = 1; i <= n; i++) read(a[i]), id[i] = i;\n    for (int i = 1; i <= n; i++) s[i] = add(s[i - 1], fpow(p, max(i, k)));\n    sort(id + 1, id + n + 1, cmp);\n    for (int i = 1; i <= n; i++) {\n        int p1 = sub(tr1.query(n), tr1.query(id[i])), p2 = sub(sub(s[n], s[id[i]]), p1), inv = fpow(fpow(p, max(id[i], k)), md - 2);\n        p1 = mul(p1, inv); p2 = mul(p2, inv);\n        ans = add(ans, sub(tr2.query(n) - tr2.query(id[i]), p1));\n        ans = add(ans, mul(add(p1, p2), (md + 1) >> 1));\n        tr1.add(id[i], fpow(p, max(id[i], k))); tr2.add(id[i], 1);\n    }\n    print(ans, '\\n');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimization (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(v) v.begin(),v.end()\n#define P pair<int,int>\n#define len(s) (int)s.size()\n \ntemplate<class T> inline bool chmin(T &a, T b){\n\tif(a>b){a=b;return true;}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T &a, T b){\n\tif(a<b){a=b;return true;}\n\treturn false;\n}\nconstexpr int mod = 998244353;\nconstexpr long long inf = 3e18;\n\ntemplate<int MOD>\nstruct mint{\n\tint32_t n;\n\tmint():n(0){}\n\tmint(int x):n(x>=0?x%MOD:(MOD-(-x)%MOD)%MOD){}\n\n\tmint &operator+=(const mint &p){\n\t\tif((n+=p.n)>=MOD)n-=MOD;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &p){\n\t\tif((n+=MOD-p.n)>=MOD)n-=MOD;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &p){\n\t\tn=1ll*n*p.n%MOD;\n\t\treturn *this;\n\t}\n\tmint &operator/=(const mint &p){\n\t\t*this*=p.inverse();\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint(-n);}\n\tmint operator+(const mint &p)const{return mint(*this)+=p;}\n\tmint operator-(const mint &p)const{return mint(*this)-=p;}\n\tmint operator*(const mint &p)const{return mint(*this)*=p;}\n\tmint operator/(const mint &p)const{return mint(*this)/=p;}\n\tbool operator==(const mint &p)const{return n==p.n;}\n\tbool operator!=(const mint &p)const{return n!=p.n;}\n\n\tfriend ostream &operator<<(ostream &os,const mint &p){\n\t\treturn os<<p.n;\n\t}\n\tfriend istream &operator>>(istream &is,mint &p){\n\t\tint x;is>>x;\n\t\tp=mint(x);\n\t\treturn is;\n\t}\n\tmint pow(int64_t x)const{\n\t\tmint res(1),mul(n);\n\t\twhile(x>0){\n\t\t\tif(x&1)res*=mul;\n\t\t\tmul*=mul;\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inverse()const{\n\t\treturn pow(MOD-2);\n\t}\n};\nusing modint=mint<mod>;\n\ntemplate<class T>\nclass BIT{\n\tint N;\n\tvector<T>bit;\n\tvoid add_(int x,T y){\n\t\twhile(x<=N){\n\t\t\tbit[x]+=y;x+=x&-x;\n\t\t}\n\t}\n\tT sum_(int x){\n\t\tT res=0;\n\t\twhile(x>0){\n\t\t\tres+=bit[x];x-=x&-x;\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tint lower_bound(T w){\n\t\tif(w<=0)return -1;\n\t\tint x=0;\n\t\tint k=1;while(k*2<=N)k*=2;\n\t\tfor(;k>0;k/=2){\n\t\t\tif(x+k<=N&&bit[x+k]<w){\n\t\t\t\tw-=bit[x+k];\n\t\t\t\tx+=k;\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n\tvoid add(int x,T y){add_(x+1,y);}\n\tT sum(int l,int r){return sum_(r)-sum_(l);}\n\tBIT(int x):N(x),bit(x+1){}\n};\n\nint N,K,A[200005];\nsigned main(){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tcin>>N>>K;\n\trep(i,N){cin>>A[i];A[i]--;}\n\n\tBIT<modint>bit(N),bit2(N);\n\tmodint ans;\n\trep(i,N){\n\t\tint j=max(0ll,i+1-K);\n\t\tmodint k=(modint(K-1)/modint(K)).pow(j);\n\t\tans+=bit.sum(A[i],N)*k/modint(2);\n\t\tans+=bit2.sum(A[i],N)-bit.sum(A[i],N)*k;\n\t\tans+=bit.sum(0,A[i])*k/modint(2);\n\t\tbit.add(A[i],modint(1)/k);\n\t\tbit2.add(A[i],1);\n\t}\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int   ll;\ntypedef pair<ll, ll>    pll;\ntypedef pair<int, int>  pii;\n\n#define all(x)          x.begin(), x.end()\n#define kill(x)         return cout << x << endl, 0\n#define X               first\n#define Y               second\n#define sep             ' '\n#define endl            '\\n'\n\nll pw(ll a, ll b, ll mod) {\n    if (!b)    return 1;\n    if (b & 1) return a * pw(a * a % mod, b / 2, mod) % mod;\n    return pw(a * a % mod, b / 2, mod) % mod;\n}\n\nconst ll N    = 2e5 + 10;\nconst ll MOD  = 998244353;\nconst ll INF  = 1e18;\n\nll n, k, A[N], fen[2][N], dp[N], F[N], ans;\n\nvoid Add(int z, int i, ll val) {\n\tfor (i += 2; i < N; i += i & (-i))\n\t\tfen[z][i] = (fen[z][i] + val) % MOD;\n}\n\nll Get(int z, int r) {\n\tll res = 0;\n\tfor (r += 2; r > 0; r -= r & (-r))\n\t\tres = (res + fen[z][r]) % MOD;\n\treturn res;\n}\n\nll Get(int z, int l, int r) {\n\treturn (Get(z, r) - Get(z, l - 1) + MOD) % MOD;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) {\n    \tcin >> A[i];\n    \tF[i] = min(n, max(i - k + 1, 0LL) + k);\n    }\n    dp[0] = pw(2, MOD - 2, MOD);\n    ll kinv = pw(k, MOD - 2, MOD);\n    for (int i = 1; i <= n; i++) {\n    \tdp[i] = kinv * (1 + (k - 2) * dp[i - 1] % MOD) % MOD;\n    }\n    ll w = (k - 1) * pw(k, MOD - 2, MOD) % MOD;\n    ll winv = k * pw(k - 1, MOD - 2, MOD) % MOD;\n    for (int i = 0; i < n; i++) {\n    \tll gt = i - Get(0, A[i]);\n    \tAdd(0, A[i], +1);\n    \tll g = dp[n - F[i]] * pw(w, F[i], MOD) % MOD;\n    \tans += Get(1, 0, A[i]) * g % MOD; \n    \tans += (gt + MOD - Get(1, A[i], n) * g % MOD) % MOD;\n    \tans %= MOD;\n    \tAdd(1, A[i], pw(winv, F[i], MOD));\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a, b)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define lscan(x) scanf(\"%I64d\", &x)\n#define lprint(x) printf(\"%I64d\", x)\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define rep2(i, n) for (ll i = n - 1; i >= 0; i--)\nconst int mod = 998244353;\nll gcd(ll a, ll b)\n{\n\tll c = a % b;\n\twhile (c != 0)\n\t{\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\nstruct UnionFind\n{\n\tvector<ll> data;\n\n\tUnionFind(int sz)\n\t{\n\t\tdata.assign(sz, -1);\n\t}\n\n\tbool unite(int x, int y)\n\t{\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)\n\t\t\treturn (false);\n\t\tif (data[x] > data[y])\n\t\t\tswap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn (true);\n\t}\n\n\tint find(int k)\n\t{\n\t\tif (data[k] < 0)\n\t\t\treturn (k);\n\t\treturn (data[k] = find(data[k]));\n\t}\n\n\tll size(int k)\n\t{\n\t\treturn (-data[find(k)]);\n\t}\n};\n\nll M = 1000000007;\n\nvector<ll> fac(2000011);  //n!(mod M)\nvector<ll> ifac(2000011); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nll mpow2(ll x, ll n, ll mod)\n{\n\tll ans = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = ans * x % mod;\n\t\tx = x * x % mod;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb()\n{\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000010; i++)\n\t{\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n\tifac[2000010] = mpow(fac[2000010], M - 2);\n\tfor (ll i = 2000010; i > 0; i--)\n\t{\n\t\tifac[i - 1] = ifac[i] * i % M;\n\t}\n}\nll comb(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b)\n{\n\tif (a == 0 && b == 0)\n\t\treturn 1;\n\tif (a < b || a < 0)\n\t\treturn 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\nlong long modinv(long long a)\n{\n\tlong long b = M, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0)\n\t\tu += M;\n\treturn u;\n}\nll modinv2(ll a, ll mod)\n{\n\tll b = mod, u = 1, v = 0;\n\twhile (b)\n\t{\n\t\tll t = a / b;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t\tu -= t * v;\n\t\tswap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0)\n\t\tu += mod;\n\treturn u;\n}\n\ntemplate <int mod>\nstruct ModInt\n{\n\tint x;\n\n\tModInt() : x(0) {}\n\n\tModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n\tModInt &operator+=(const ModInt &p)\n\t{\n\t\tif ((x += p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator-=(const ModInt &p)\n\t{\n\t\tif ((x += mod - p.x) >= mod)\n\t\t\tx -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator*=(const ModInt &p)\n\t{\n\t\tx = (int)(1LL * x * p.x % mod);\n\t\treturn *this;\n\t}\n\n\tModInt &operator/=(const ModInt &p)\n\t{\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\n\tModInt operator-() const { return ModInt(-x); }\n\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\n\tModInt inverse() const\n\t{\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\n\tModInt pow(int64_t n) const\n\t{\n\t\tModInt ret(1), mul(x);\n\t\twhile (n > 0)\n\t\t{\n\t\t\tif (n & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const ModInt &p)\n\t{\n\t\treturn os << p.x;\n\t}\n\n\tfriend istream &operator>>(istream &is, ModInt &a)\n\t{\n\t\tint64_t t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n\n\tstatic int get_mod() { return mod; }\n};\n\nusing mint = ModInt<mod>;\n\nvector<vector<ll>> mul(vector<vector<ll>> a, vector<vector<ll>> b, int n)\n{\n\tint i, j, k, t;\n\tvector<vector<ll>> c(n);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\tt = (t + a[i][k] * b[k][j] % M) % M;\n\t\t\tc[i].push_back(t);\n\t\t}\n\t}\n\treturn c;\n}\n\nvector<vector<ll>> mat_pow(vector<vector<ll>> x, ll n)\n{\n\tll k = x.size();\n\tvector<vector<ll>> ans(k, vector<ll>(k, 0));\n\tfor (int i = 0; i < k; i++)\n\t\tans[i][i] = 1;\n\twhile (n != 0)\n\t{\n\t\tif (n & 1)\n\t\t\tans = mul(ans, x, k);\n\t\tx = mul(x, x, k);\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\n\ntemplate <typename Monoid>\nstruct SegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\n\tint sz;\n\tvector<Monoid> seg;\n\n\tconst F f;\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1)\n\t{\n\t\tsz = 1;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x)\n\t{\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1)\n\t\t{\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t\tL = f(L, seg[a++]);\n\t\t\tif (b & 1)\n\t\t\t\tR = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k) const\n\t{\n\t\treturn seg[k + sz];\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tMonoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, seg[1])))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, seg[a]);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(seg[1], R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(seg[--b], R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\ntemplate <unsigned mod>\nstruct RollingHash\n{\n\tvector<unsigned> hashed, power;\n\n\tinline unsigned mul(unsigned a, unsigned b) const\n\t{\n\t\tunsigned long long x = (unsigned long long)a * b;\n\t\tunsigned xh = (unsigned)(x >> 32), xl = (unsigned)x, d, m;\n\t\tasm(\"divl %4; \\n\\t\"\n\t\t\t: \"=a\"(d), \"=d\"(m)\n\t\t\t: \"d\"(xh), \"a\"(xl), \"r\"(mod));\n\t\treturn m;\n\t}\n\n\tRollingHash(const string &s, unsigned base = 10007)\n\t{\n\t\tint sz = (int)s.size();\n\t\thashed.assign(sz + 1, 0);\n\t\tpower.assign(sz + 1, 0);\n\t\tpower[0] = 1;\n\t\tfor (int i = 0; i < sz; i++)\n\t\t{\n\t\t\tpower[i + 1] = mul(power[i], base);\n\t\t\thashed[i + 1] = mul(hashed[i], base) + s[i];\n\t\t\tif (hashed[i + 1] >= mod)\n\t\t\t\thashed[i + 1] -= mod;\n\t\t}\n\t}\n\n\tunsigned get(int l, int r) const\n\t{\n\t\tunsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tunsigned connect(unsigned h1, int h2, int h2len) const\n\t{\n\t\tunsigned ret = mul(h1, power[h2len]) + h2;\n\t\tif (ret >= mod)\n\t\t\tret -= mod;\n\t\treturn ret;\n\t}\n\n\tint LCP(const RollingHash<mod> &b, int l1, int r1, int l2, int r2)\n\t{\n\t\tint len = min(r1 - l1, r2 - l2);\n\t\tint low = -1, high = len + 1;\n\t\twhile (high - low > 1)\n\t\t{\n\t\t\tint mid = (low + high) / 2;\n\t\t\tif (get(l1, l1 + mid) == b.get(l2, l2 + mid))\n\t\t\t\tlow = mid;\n\t\t\telse\n\t\t\t\thigh = mid;\n\t\t}\n\t\treturn (low);\n\t}\n};\n\nusing RH = RollingHash<1000000007>;\n\ntemplate <typename T>\nstruct edge\n{\n\tint src, to;\n\tT cost;\n\n\tedge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n\tedge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n\tedge &operator=(const int &x)\n\t{\n\t\tto = x;\n\t\treturn *this;\n\t}\n\n\toperator int() const { return to; }\n};\n\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate <typename T>\nusing Matrix = vector<vector<T>>;\n\ntemplate <typename G>\nstruct DoublingLowestCommonAncestor\n{\n\tconst int LOG;\n\tvector<int> dep;\n\tconst G &g;\n\tvector<vector<int>> table;\n\n\tDoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size()))\n\t{\n\t\ttable.assign(LOG, vector<int>(g.size(), -1));\n\t}\n\n\tvoid dfs(int idx, int par, int d)\n\t{\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor (auto &to : g[idx])\n\t\t{\n\t\t\tif (to != par)\n\t\t\t\tdfs(to, idx, d + 1);\n\t\t}\n\t}\n\n\tvoid build()\n\t{\n\t\tdfs(0, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG; k++)\n\t\t{\n\t\t\tfor (int i = 0; i < table[k].size(); i++)\n\t\t\t{\n\t\t\t\tif (table[k][i] == -1)\n\t\t\t\t\ttable[k + 1][i] = -1;\n\t\t\t\telse\n\t\t\t\t\ttable[k + 1][i] = table[k][table[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v)\n\t{\n\t\tif (dep[u] > dep[v])\n\t\t\tswap(u, v);\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (((dep[v] - dep[u]) >> i) & 1)\n\t\t\t\tv = table[i][v];\n\t\t}\n\t\tif (u == v)\n\t\t\treturn u;\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (table[i][u] != table[i][v])\n\t\t\t{\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid>\nstruct LazySegmentTree\n{\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\tusing G = function<Monoid(Monoid, OperatorMonoid)>;\n\tusing H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n\tint sz, height;\n\tvector<Monoid> data;\n\tvector<OperatorMonoid> lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst Monoid M1;\n\tconst OperatorMonoid OM0;\n\n\tLazySegmentTree(int n, const F f, const G g, const H h,\n\t\t\t\t\tconst Monoid &M1, const OperatorMonoid OM0)\n\t\t: f(f), g(g), h(h), M1(M1), OM0(OM0)\n\t{\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile (sz < n)\n\t\t\tsz <<= 1, height++;\n\t\tdata.assign(2 * sz, M1);\n\t\tlazy.assign(2 * sz, OM0);\n\t}\n\n\tvoid set(int k, const Monoid &x)\n\t{\n\t\tdata[k + sz] = x;\n\t}\n\n\tvoid build()\n\t{\n\t\tfor (int k = sz - 1; k > 0; k--)\n\t\t{\n\t\t\tdata[k] = f(data[2 * k + 0], data[2 * k + 1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k)\n\t{\n\t\tif (lazy[k] != OM0)\n\t\t{\n\t\t\tlazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n\t\t\tlazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = OM0;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k)\n\t{\n\t\treturn lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n\t}\n\n\tinline void recalc(int k)\n\t{\n\t\twhile (k >>= 1)\n\t\t\tdata[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n\t}\n\n\tinline void thrust(int k)\n\t{\n\t\tfor (int i = height; i > 0; i--)\n\t\t\tpropagate(k >> i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tlazy[l] = h(lazy[l], x), ++l;\n\t\t\tif (r & 1)\n\t\t\t\t--r, lazy[r] = h(lazy[r], x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b)\n\t{\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tMonoid L = M1, R = M1;\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t\tL = f(L, reflect(l++));\n\t\t\tif (r & 1)\n\t\t\t\tR = f(reflect(--r), R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k)\n\t{\n\t\treturn query(k, k + 1);\n\t}\n\n\ttemplate <typename C>\n\tint find_subtree(int a, const C &check, Monoid &M, bool type)\n\t{\n\t\twhile (a < sz)\n\t\t{\n\t\t\tpropagate(a);\n\t\t\tMonoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n\t\t\tif (check(nxt))\n\t\t\t\ta = 2 * a + type;\n\t\t\telse\n\t\t\t\tM = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate <typename C>\n\tint find_first(int a, const C &check)\n\t{\n\t\tMonoid L = M1;\n\t\tif (a <= 0)\n\t\t{\n\t\t\tif (check(f(L, reflect(1))))\n\t\t\t\treturn find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(a + sz);\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (a & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(L, reflect(a));\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\ttemplate <typename C>\n\tint find_last(int b, const C &check)\n\t{\n\t\tMonoid R = M1;\n\t\tif (b >= sz)\n\t\t{\n\t\t\tif (check(f(reflect(1), R)))\n\t\t\t\treturn find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(b + sz - 1);\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t{\n\t\t\t\tMonoid nxt = f(reflect(--b), R);\n\t\t\t\tif (check(nxt))\n\t\t\t\t\treturn find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint main()\n{\n\tM = 998244353;\n\tll n, k, p[222222];\n\tcin >> n >> k;\n\trep(i, n) cin >> p[i];\n\tll r = k - 1;\n\tr *= modinv(k);\n\tmint ans = k * (k - 1);\n\tans /= 4;\n\tvector<vector<ll>> v(3, vector<ll>(3));\n\tv[0][2] = 1;\n\tv[1][2] = 1;\n\tv[2][2] = 1;\n\tvector<vector<ll>> u(3, vector<ll>(3));\n\tu[0][0] = 1;\n\tu[1][1] = r;\n\tu[2][2] = 1;\n\tvector<vector<ll>> t(3, vector<ll>(3));\n\tt[0][0] = 1;\n\tt[1][1] = 1;\n\tt[2][2] = 1;\n\tfunction<pair<pair<mint, mint>, mint>(pair<pair<mint, mint>, mint>, pair<pair<mint, mint>, mint>)> f = [](pair<pair<mint, mint>, mint> a, pair<pair<mint, mint>, mint> b) { return mp(mp(a.first.first + b.first.first, a.first.second + b.first.second), a.second + b.second); };\n\tfunction<pair<pair<mint, mint>, mint>(pair<pair<mint, mint>, mint>, vector<vector<ll>>)> g = [](pair<pair<mint, mint>, mint> a, vector<vector<ll>> x) { return mp(mp(a.first.first * x[0][0] + a.first.second * x[0][1] + a.second * x[0][2], a.first.first * x[1][0] + a.first.second * x[1][1] + a.second * x[1][2]), a.first.first * x[2][0] + a.first.second * x[2][1] + a.second * x[2][2]); };\n\tfunction<vector<vector<ll>>(vector<vector<ll>>, vector<vector<ll>>)> h = [](vector<vector<ll>> v1, vector<vector<ll>> v2) { return mul(v2, v1, 3); };\n\tLazySegmentTree<pair<pair<mint, mint>, mint>, vector<vector<ll>>> seg(n + 1, f, g, h, mp(mp(0, 0), 1), t);\n\trep(i, k) seg.set(p[i], mp(mp(1, 1), 1));\n\tseg.build();\n\tfor (int i = 1; i < n - k + 1; i++){\n\t\tans += (k - 1) * modinv(2);\n\t\tseg.update(0, n + 1, u);\n\t\tans += seg.query(p[i + k - 1], n + 1).first.first;\n\t\tans -= seg.query(p[i + k - 1], n + 1).first.second;\n\t\tseg.update(p[i + k - 1], p[i + k - 1] + 1, v);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<atcoder/modint>\n#include<atcoder/fenwicktree>\nusing namespace std;\nusing namespace atcoder;\nusing mint=modint998244353;\nint N,K;\nint P[2<<17];\nlong calc()\n{\n\tfenwick_tree<int>A(N+1);\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tans+=i-A.sum(0,P[i]);\n\t\tA.add(P[i],1);\n\t}\n\treturn ans;\n}\nmain()\n{\n\tcin>>N>>K;\n\tfor(int i=0;i<N;i++)cin>>P[i];\n\tmint ans=calc();\n\tans*=K;\n\tmint invK=mint(1)/K;\n\tmint X=mint(K-1)*invK;\n\tmint Y=mint(K-2)*invK;\n\tmint invY=mint(1)/(1-Y);\n\tmint Kinv2=mint(1)/2*K;\n\tfenwick_tree<int>Q(N+1);\n\tfenwick_tree<int>R(N+1);\n\tfor(int j=1;j<N;j++)\n\t{\n\t\tQ.add(P[j-1],1);\n\t\tif(j<=K)R.add(P[j-1],1);\n\t\tint t=min(N-j,N-K);\n\t\tmint Yt=Y.pow(t);\n\t\tmint T=(1-Yt)*invY+Yt*Kinv2;\n\t\tmint tmp=0;\n\t\tif(j<=K-1)\n\t\t{\n\t\t\ttmp=2*Q.sum(0,P[j])-j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp=X.pow(j-(K-1))*(2*R.sum(0,P[j])-K);\n\t\t\tfor(int i=K;i<j;i++)\n\t\t\t{\n\t\t\t\tmint a=X.pow(j-i);\n\t\t\t\tif(P[i]<P[j])tmp+=a;\n\t\t\t\telse tmp-=a;\n\t\t\t}\n\t\t}\n\t\tans+=tmp*T;\n\t}\n\tcout<<(ans*invK).val()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\ntemplate<typename T>\nstruct fenwick_tree {\n    int tree_n = 0;\n    T tree_sum = 0;\n    vector<T> tree;\n\n    fenwick_tree(int n = -1) {\n        if (n >= 0)\n            init(n);\n    }\n\n    static int largest_bit(int x) {\n        return x == 0 ? -1 : 31 - __builtin_clz(x);\n    }\n\n    void init(int n) {\n        tree_n = n;\n        tree_sum = 0;\n        tree.assign(tree_n + 1, 0);\n    }\n\n    // O(n) initialization of the Fenwick tree.\n    template<typename T_array>\n    void build(const T_array &initial) {\n        assert(int(initial.size()) == tree_n);\n        tree_sum = 0;\n\n        for (int i = 1; i <= tree_n; i++) {\n            tree[i] = initial[i - 1];\n            tree_sum += initial[i - 1];\n\n            for (int k = (i & -i) >> 1; k > 0; k >>= 1)\n                tree[i] += tree[i - k];\n        }\n    }\n\n    // index is in [0, tree_n).\n    void update(int index, const T &change) {\n        assert(0 <= index && index < tree_n);\n        tree_sum += change;\n\n        for (int i = index + 1; i <= tree_n; i += i & -i)\n            tree[i] += change;\n    }\n\n    // Returns the sum of the range [0, count).\n    T query(int count) const {\n        count = min(count, tree_n);\n        T sum = 0;\n\n        for (int i = count; i > 0; i -= i & -i)\n            sum += tree[i];\n\n        return sum;\n    }\n\n    // Returns the sum of the range [start, tree_n).\n    T query_suffix(int start) const {\n        return tree_sum - query(start);\n    }\n\n    // Returns the sum of the range [a, b).\n    T query(int a, int b) const {\n        return query(b) - query(a);\n    }\n\n    // Returns the element at index a in O(1) amortized across every index. Equivalent to query(a, a + 1).\n    T get(int a) const {\n        assert(0 <= a && a < tree_n);\n        int above = a + 1;\n        T sum = tree[above];\n        above -= above & -above;\n\n        while (a != above) {\n            sum -= tree[a];\n            a -= a & -a;\n        }\n\n        return sum;\n    }\n\n    bool set(int index, T value) {\n        assert(0 <= index && index < tree_n);\n        T current = get(index);\n\n        if (current == value)\n            return false;\n\n        update(index, value - current);\n        return true;\n    }\n\n    // Returns the largest p in `[0, tree_n]` such that `query(p) <= sum`. Returns -1 if no such p exists (`sum < 0`).\n    // Can be used as an ordered set/multiset on indices in `[0, tree_n)` by using the tree as a 0/1 or frequency array:\n    // `set(index, 1)` is equivalent to insert(index). `update(index, +1)` is equivalent to multiset.insert(index).\n    // `set(index, 0)` or `update(index, -1)` are equivalent to erase(index).\n    // `get(index)` provides whether index is present or not, or the count of index (if multiset).\n    // `query(index)` provides the count of elements < index.\n    // `find_last_prefix(k)` finds the k-th smallest element (0-indexed). Returns `tree_n` for `sum >= set.size()`.\n    int find_last_prefix(T sum) const {\n        if (sum < 0)\n            return -1;\n\n        int prefix = 0;\n\n        for (int k = largest_bit(tree_n); k >= 0; k--)\n            if (prefix + (1 << k) <= tree_n && tree[prefix + (1 << k)] <= sum) {\n                prefix += 1 << k;\n                sum -= tree[prefix];\n            }\n\n        return prefix;\n    }\n};\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, K;\n    cin >> N >> K;\n    mod_int R = 1 - mod_int(1) / K;\n    fenwick_tree<int> tree(N);\n    fenwick_tree<mod_int> p_tree(N);\n    mod_int pow_sum = 0;\n    mod_int total = 0;\n\n    for (int i = 0; i < N; i++) {\n        int p;\n        cin >> p;\n        p--;\n\n        int start = max(i - (K - 1), 0);\n\n        mod_int power = R.pow(start);\n        mod_int inv_pow = power.inv();\n        total += power * pow_sum / 2;\n        pow_sum += inv_pow;\n\n        total += tree.query_suffix(p) - power * p_tree.query_suffix(p);\n\n        tree.update(p, +1);\n        p_tree.update(p, inv_pow);\n    }\n\n    cout << total << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair < int , int > pii;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nLL readint(){\n\tchar c=getchar();\n\tLL ret=0ll;\n\tbool neg=0;\n\twhile(!(c>='0' && c<='9')){\n\t\tif(c=='-') neg=1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10ll+(LL)(c-'0');\n\t\tc=getchar();\n\t}\n\treturn neg?-ret:ret;\n}\nvoid putint(LL v){\n\tif(v<0){\n\t\tputchar('-');\n\t\tv=-v;\n\t}\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10ll) putint(v/10ll);\n\tputchar('0'+(v%10ll));\n}\nconst int MOD=998244353;\nint powM(int V,int T=MOD-2){\n\tint R=1;\n\twhile(T){\n\t\tif(T&1) R=(LL)R*V%MOD;\n\t\tT>>=1;\n\t\tV=(LL)V*V%MOD;\n\t}\n\treturn R;\n}\nint n,m,p[200005],cv[200005];\nstruct BIT{\n\tint a[200005];\n\tvoid add(int p,int v){\n\t\t++p;\n\t\twhile(p<=n){\n\t\t\ta[p]+=v;\n\t\t\tif(a[p]>=MOD) a[p]-=MOD;\n\t\t\tp+=p&-p;\n\t\t}\n\t}\n\tint sum(int p){\n\t\t++p;\n\t\tint r=0;\n\t\twhile(p){\n\t\t\tr+=a[p];\n\t\t\tif(r>=MOD) r-=MOD;\n\t\t\tp-=p&-p;\n\t\t}\n\t\treturn r;\n\t}\n}CNT,SUM;\nint main(){\n\tint i,j,k;\n\tn=readint();m=readint();\n\tfor(i=0;i<n;++i) p[i]=n-readint();\n\tfor(i=0;i<m;++i) cv[i]=0;\n\tfor(i=m;i<n;++i) cv[i]=i-m+1;\n\tint c=0,p1=0,p2=0,ss=0,invm=(1+MOD-powM(m))%MOD,om=powM(invm),ci=1,cp=1;\n\tfor(i=0;i<n;++i){\n\t\tif(i && cv[i]>cv[i-1]) ci=(LL)ci*invm%MOD,cp=(LL)cp*om%MOD;\n\t\tc+=CNT.sum(p[i]);\n\t\tif(c>=MOD) c-=MOD;\n\t\tCNT.add(p[i],1);\n\t\tp1+=(LL)SUM.sum(p[i])*ci%MOD;\n\t\tif(p1>=MOD) p1-=MOD;\n\t\tSUM.add(p[i],cp);\n\t\tp2+=(LL)ss*ci%MOD;\n\t\tif(p2>=MOD) p2-=MOD;\n\t\tss+=cp;\n\t\tif(ss>=MOD) ss-=MOD;\n\t}\n//\tprintf(\"p2=%d p1=%d c=%d\\n\",p2,p1,c);\n\tint inv2=(MOD+1)/2;\n\tint res=((LL)inv2*p2+c-p1+MOD)%MOD;\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n/*\n * 代码框架\n * 1. 开数组记录每个位置的最小覆盖标号 \n * 2. 预处理K的逆\n * 3. 开两个BIT分别维护个数和总和，得到逆序对的总个数c和总概率p1。\n * 4. 计算全局总概率p2，答案等于p2/2+c-p1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int32_t M=998244353;\nint32_t rev(int32_t x,int32_t m){\n    if(x==1)return 1;\n    return (1-(ll)rev(m%x,x)*m)/x+m;\n}\nstruct mint{\n    int32_t x;\n    mint():x(0){}\n    mint(int32_t xx):x(xx%M){if(x<0)x+=M;}\n    mint(ll xx):x(xx%M){if(x<0)x+=M;}\n    mint& operator+=(mint b){if((x+=b.x)>=M)x-=M;return *this;}\n    mint operator+(mint b){mint res=*this;res+=b;return res;}\n    mint& operator-=(mint b){if((x-=b.x)<0)x+=M;return *this;}\n    mint operator-(mint b){mint res=*this;res-=b;return res;}\n    mint& operator*=(mint b){x=(ll)x*b.x%M;return *this;}\n    mint operator*(mint b){mint res=*this;res*=b;return res;}\n    mint inverse(){return rev(x,M);}\n    mint& operator/=(mint b){x=(ll)x*rev(b.x,M)%M;return *this;}\n    mint operator/(mint b){mint res=*this;res/=b;return res;}\n    mint operator^(ll w) {mint r=1,a=*this;while(w){if(w&1)r*=a;a*=a;w/=2;}return r;}\n    mint operator^=(ll w){return *this=(*this)^w;}\n    mint operator^(mint w){return *this^w.x;}\n    mint operator^=(mint w){return *this=(*this)^w;}\n    mint operator-()const{return mint()-*this;}\n    explicit operator bool()const{return x;}\n};\nistream&operator>>(istream&is,mint&p){istream&res=is>>p.x;p.x%=M;return res;}\nostream&operator<<(ostream&os,mint p){return os<<p.x;}\ntemplate<typename T>mint operator+(T x,mint y){return mint(x)+y;}\ntemplate<typename T>mint operator-(T x,mint y){return mint(x)-y;}\ntemplate<typename T>mint operator*(T x,mint y){return mint(x)*y;}\ntemplate<typename T>mint operator/(T x,mint y){return mint(x)/y;}\ntemplate<typename T>mint operator^(T x,mint y){return mint(x)^y;}\nmint abs(mint x){return x;}\n\nconst int N=2e5+5;\nmint t[N];\nmint get(int i){\n    mint res=0;\n    for(;i>=0;i=(i&(i+1))-1)res+=t[i];\n    return res;\n}\nvoid add(int i,mint x){for(;i<N;i|=i+1)t[i]+=x;}\nint a[N];\nmint ri[N];\nmint invri[N];\nint32_t main(){\n\tint n,k;\n\tcin>>n>>k;\n\tri[0]=1;\n\tinvri[0]=1;\n\tmint r=((mint)k-1)/k;\n\tmint invr=1/r;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tri[i]=ri[i-1]*r;\n\t\tinvri[i]=invri[i-1]*invr;\n\t}\n\tmint inv=0;\n\tfor(int i=n;i>=1;--i){\n\t\tinv+=get(a[i]);\n\t\tadd(a[i],1);\n\t}\n\tmemset(t,0,sizeof t);\n\tmint canadd=0;\n\tfor(int i=1;i<=n;++i){\n\t\tcanadd+=get(a[i])*ri[max(i,k)];\n\t\tadd(a[i],invri[max(i,k)]);\n\t}\n\tmemset(t,0,sizeof t);\n\tfor(int i=1;i<=n;++i){\n\t\tint x=n-a[i]+1;\n\t\tcanadd-=get(x)*ri[max(i,k)];\n\t\tadd(x,invri[max(i,k)]);\n\t}\n\tcanadd/=2;\n\tcout<<inv+canadd<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nconst int mod=998244353;\nint n,m,i,j,a[200005],s[200005],s2[200005],ans;\nint fac[200005],inv[200005],fi[200005],pw[200005],ipw[200005];\nvector<int> v[200005];\nvoid add(int x,int y)\n{\n\twhile(x){\n\t\tinc(s[x],y)\n\t\ts2[x]++;\n\t\tx-=(x&-x);\n\t}\n}\nint query(int x)\n{\n\tint ss=0;\n\twhile(x<=n){\n\t\tinc(ss,s[x])\n\t\tx+=(x&-x);\n\t}\n\treturn ss;\n}\nint query2(int x)\n{\n\tint ss=0;\n\twhile(x<=n){\n\t\tss+=s2[x];\n\t\tx+=(x&-x);\n\t}\n\treturn ss;\n}\nint main()\n{\n\tfac_init(200002)\n\tread(n);read(m);\n\tpw[0]=ipw[0]=1;\n\tpw[1]=1ll*(m-1)*inv[m]%mod;\n\tipw[1]=1ll*m*inv[m-1]%mod;\n\tfz(i,2,n){\n\t\tpw[i]=1ll*pw[i-1]*pw[1]%mod;\n\t\tipw[i]=1ll*ipw[i-1]*ipw[1]%mod;\n\t}\n\tfz1(i,n){\n\t\tread(a[i]); \n\t\tv[max(1,i-m+1)].push_back(a[i]);\n\t}\n\tint s=0,c=0;\n\tans=1ll*n*(n-1)/2%mod;\n\tfz1(i,n-m+1){\n\t\tff(v[i],it){\n\t\t\tans=(ans+(mod-i+1))%mod;\n\t\t\tans=(ans+2ll*query2(*it))%mod;\n\t\t\tans=(ans+2ll*(mod-pw[i])*query(*it))%mod;\n\t\t}\n\t\tff(v[i],it){\n\t\t\tc++;\n\t\t\tinc(s,ipw[i])\n\t\t\tadd(*it,ipw[i]);\n\t\t}\n\t}\n\tcout<<1ll*ans*inv[2]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\ntemplate<class T> bool chmin(T& a,T b){if(a>b) {a = b; return true;} return false;}\ntemplate<class T> bool chmax(T& a,T b){if(a<b) {a = b; return true;} return false;}\n#define all(x) (x).begin(),(x).end()\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\n\nconstexpr ll mod = 998244353;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n    bool operator==(const mint a)const{\n        return x==a.x;\n    }\n};\n\ntemplate<typename Monoid,typename F>\nclass SegmentTree{\nprivate:\n    int sz;\n    vector<Monoid> seg;\n    const F op;\n    const Monoid e;\npublic:\n    SegmentTree(int n,const F op,const Monoid &e):op(op),e(e){\n        sz = 1;\n        while(sz<=n) sz <<= 1;\n        seg.assign(2*sz,e);\n    }\n    void set(int k, const Monoid &x){\n        seg[k+sz] = x;\n    }\n    void build(){\n        for(int i=sz-1;i>0;i--){\n            seg[i] = op(seg[2*i],seg[2*i+1]);\n        }\n    }\n    void update(int k,const Monoid &x){\n        k += sz;\n        seg[k] = x;\n        while(k>>=1){\n            seg[k] = op(seg[2*k],seg[2*k+1]);\n        }\n    }\n    Monoid query(int l,int r){\n        Monoid L = e,R = e;\n        for(l+=sz,r+=sz;l<r;l>>=1,r>>=1){\n            if(l&1) L = op(L,seg[l++]);\n            if(r&1) R = op(seg[--r],R);\n        }\n        return op(L,R);\n    }\n    Monoid operator[](const int &k)const{\n        return seg[k+sz];\n    }\n};\n\nint main(){\n    int N,K;\n    cin >> N >> K;\n    vec<int> P(N);\n    for(auto& x:P){\n        cin >> x;\n        x--;\n    }\n    mint p = ((mint) K-1)/K;\n    vec<mint> powp(N+1,1);\n    for(int i=1;i<=N;i++) powp[i] = powp[i-1]/p;\n    SegmentTree seg(N,[](mint a,mint b){return a+b;},((mint) 0));\n    SegmentTree seg2(N,[](int a,int b){return a+b;},0);\n    mint ans = 0;\n    for(int i=0;i<N;i++){\n        mint val = seg.query(0,P[i]);\n        val /= powp[max(i-K+1,0)];\n        ans += val/2;\n        val = seg.query(P[i]+1,N);\n        int cnt = seg2.query(P[i]+1,N);\n        val /= powp[max(i-K+1,0)];\n        ans += ((mint) cnt) - val/2;\n        seg.update(P[i],powp[max(i-K+1,0)]);\n        seg2.update(P[i],1);\n    }\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#include <random>\n#include <iomanip>\n#include <bitset>\n#include <array>\n#define FOR(i, n, m) for(ll i = (n); i < (ll)(m); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 998244353;\nconstexpr long double eps = 1e-6;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << v[i];\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 1010101\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n \nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll N = 202020;\nmi bit[202020];\nvoid add(ll a, mi w) {\n    a++;\n    for (ll x = a; x <= N; x += x & -x) bit[x] += w;\n}\nmi sum(ll a) {\n    a++;\n    mi ret = 0;\n    for (ll x = a; x > 0; x -= x & -x) ret += bit[x];\n    return ret;\n}\n// return the sum of [a, b)\nmi sum(ll a, ll b) {\n    mi ret = 0;\n    if(b == 0) return 0;\n    ret += sum(b - 1);\n    if(a) ret -= sum(a - 1);\n    return ret;\n}\n\nmi bit2[202020];\nvoid add2(ll a, mi w) {\n    a++;\n    for (ll x = a; x <= N; x += x & -x) bit2[x] += w;\n}\nmi sum2(ll a) {\n    a++;\n    mi ret = 0;\n    for (ll x = a; x > 0; x -= x & -x) ret += bit2[x];\n    return ret;\n}\n// return the sum of [a, b)\nmi sum2(ll a, ll b) {\n    mi ret = 0;\n    if(b == 0) return 0;\n    ret += sum2(b - 1);\n    if(a) ret -= sum2(a - 1);\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    vector<int> p(n);\n    REP(i, n) cin >> p[i];\n    mi val = (k - 1); val /= k;\n    mi div2 = mod_pow(2, mod - 2);\n    mi ans = 0;\n    \n    mi val2 = mod_pow(val, k - 1);\n    \n    mi val3 = mod_pow(val, mod - 2);\n    mi val4 = mod_pow(val3, k - 1);\n    \n    REP(i, n) {\n        int lo = sum(0, p[i]).n, hi = sum(p[i], n + 3).n;\n        \n        if(i >= k) {\n            val2 *= val;\n            val4 *= val3;\n        }\n        \n        ans += div2 * val2 * sum2(0, p[i]);\n        ans += hi;\n        ans -= div2 * val2 * sum2(p[i], n + 3);\n        \n        add(p[i], 1);\n        add2(p[i], val4);\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 998244353;\n\nint add(int a, int b)\n{\n    a += b;\n    if (a >= MOD)\n    {\n        return a - MOD;\n    }\n    if (a < 0)\n    {\n        return a + MOD;\n    }\n    return a;\n}\n\nint mul(int a, int b)\n{\n    return a * (ll) b % MOD;\n}\n\nint pw(int a, int b)\n{\n    int r = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            r = mul(r, a);\n        }\n        a = mul(a, a);\n        b /= 2;\n    }\n    return r;\n}\n\nint dv(int a, int b)\n{\n    return mul(a, pw(b, MOD - 2));\n}\n\nconst int N = (int) 2e3 + 7;\n/// const int N = (int) 2e5 + 7; the true limits :)\nint n;\nint k;\nint a[N];\nint survive[N][N];\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        int start = max(1, i - k + 1);\n        for (int j = 0; j < start; j++)\n        {\n            survive[i][j] = 1;\n        }\n        for (int j = start; j <= n; j++)\n        {\n            int rem = min(n - j + 1, k);\n            survive[i][j] = mul(survive[i][j - 1], dv(rem - 1, rem));\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            cout << survive[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n\n}\n/// for after contest:)"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5, mod = 998244353;\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nstruct Fenwick {\n  int bit[N];\n  Fenwick() {\n    memset(bit, 0, sizeof bit);\n  }\n\n  void upd(int x, int v) {\n    for (++x; x < N; x += x&-x)\n      bit[x] = (bit[x] + v) % mod;\n  }\n\n  int get(int x) {\n    int ret = 0;\n    for (++x; x; x -= x&-x)\n      ret = (ret + bit[x]) % mod;\n    return ret;\n  }\n};\n\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  vector<int> p(n);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", &p[i]);\n  long long ans = 1LL * k * (k - 1) / 2;\n  ans %= mod;\n  long long prob = powmod(k, mod - 2), q = (mod + 1 - prob) % mod;\n  Fenwick sum, cnt;\n  for (int i = 0; i < k; ++i) {\n    sum.upd(p[i], powmod(q, mod - 1 - (k-1)));\n    cnt.upd(p[i], +1);\n  }\n  ans = ans * powmod(2, mod - 2) % mod;\n  for (int i = k; i < n; ++i) {\n    long long now = powmod(q, i)* powmod(2, mod - 2) % mod;\n    long long down = sum.get(p[i]), up = sum.get(N-2) - down;\n    int cdown = cnt.get(p[i]), cup = cnt.get(N-2) - cdown;\n    down = down * now % mod;\n    up = up * now % mod;\n    ans = (ans + up  + cdown - down) % mod;\n    sum.upd(p[i], powmod(q, mod - 1 - i));\n    cnt.upd(p[i], +1);\n  }\n  long long tot = 1LL * n * (n - 1) / 2;\n  tot %= mod;\n  ans = (tot - ans) % mod;\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n #include<atcoder/all>\nusing namespace atcoder;\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[400100];\n                int inv[400010];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n  \n\nstruct segsum{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// 1<<15 = 32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<18);\n\t\n\tvector<int> vec;\n\t\n\tvoid shoki1(){\n\t\tvec.resize(2*cor+3, 0);\n\t}\n\tvoid shoki2(){\n\t\tfor(int i=cor-1;i>0;i--) vec[i]=vec[2*i]+vec[2*i+1];\n\t}\n\tvoid clear(){    \n\t    for(int i=0;i<(int)vec.size();i++)vec[i]=0;\n    }\n\t\n\tvoid updadd(int x,int w){\n\t\t//x 項目に w加算\n\t\tx+=cor;\n\t\tvec[x]+=w;\n\t\tvec[x]%=mod;\n\t\tx/=2;\n\t\twhile(x){\n\t\t\tvec[x]=(vec[2*x]+vec[2*x+1])%mod;\n\t\t\tx/=2;\n\t\t}\n\t}\n\t\n\tvoid updchan(int x,int w){\n\t\t//x項目をwに変更\n\t\tx+=cor;\n\t\tvec[x]=w;\n\t\twhile(x){\n\t\t\tx/=2;\n\t\t\tvec[x]=(vec[2*x]+vec[2*x+1])%mod;\n\t\t}\t\t\n\t}\n\t\n\t// [a,b)\n\tint sum(int a,int b){\n\t\tint hi=0,mi=0;\n\t\ta+=cor,b+=cor;\n\t\twhile(a<b){\n\t\t\tif(a&1){\n\t\t\t\thi=hi+vec[a];\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(b&1){\n\t\t\t\tb--;\n\t\t\t\tmi=vec[b]+mi;\n\t\t\t}\n\t\t\ta/=2,b/=2;\n\t\t}\n\t\treturn (hi+mi)%mod;\n\t}\n\t\n\t\n\t\n};\n\n\n\nint Dinvbe[500020];\nint Dbe[500020];\nvoid solve(){\nmod=998244353;\nsegsum ss;\n\tss.shoki1();\n\tss.shoki2();\n\nsegsum kosu;\n\tkosu.shoki1();\n\tkosu.shoki2();\n\t\t\n\tfor(int i=1;i<=5;i++){\n\t//\tcout<<i<<\" \"<<beki(i,mod-2,mod)<<endl;\n\t}\n\t\n\tint n,k;\n\tcin>>n>>k;\n\tvector<int> ve(n);\n\tfor(int i=0;i<n;i++)cin>>ve[i];\n\tvector<pa> W;\n\tfor(int i=0;i<n;i++){\n\t\tW.pb(mp(ve[i],i));\n\t}\n\tsort(W.begin(),W.end(),greater<pa>());\n\t\n\tint D=mod+1-beki(k,mod-2,mod);\n\tD%=mod;\n\tint Dinv = beki(D,mod-2,mod);\n\tDinvbe[0]=1;\n\tDbe[0]=1;\n\tfor(int i=1;i<=500000;i++){\n\t\tDinvbe[i]=Dinvbe[i-1]*Dinv%mod;\n\t\tDbe[i]=Dbe[i-1]*D%mod;\n\t\t\n\t}\n\t\n\tint ans=0;\n\tfor(auto v:W){\n\t\tint f=max(k,v.second+1);\n\t\tint z1=kosu.sum(v.second,f);\n\t\tz1*=(mod+1)/2;\n\t\tz1%=mod;\n\t\tint k2=kosu.sum(f,ss.cor);\n\t\tint z2=ss.sum(f,ss.cor);\n\t\tz2*=Dinvbe[f-1];\n\t//\tcout<<v.second+k-1<<endl;\n\t\tz2%=mod;\n\t\tz2*=(mod+1)/2;\n\t\tz2%=mod;\n\t\tans+=z1+z2;\n\t//\tcout<<z1<<\" \"<<z2<<endl;\n\t\tss.updadd(v.second,Dbe[v.second]);\n\t\tkosu.updadd(v.second,1);\n\t}\n\t\n\t\n\tfor(int i=0;i<=n+10;i++){\n\t\tss.updchan(i,0);\n\t\tkosu.updchan(i,0);\n\t\t\n\t}\n\t\n\treverse(W.begin(),W.end());\n\t\n\t\tfor(auto v:W){\n\t\t\tint f=max(k,v.second+1);\n\t\tint z1=kosu.sum(v.second,f);\n\t\tz1*=(mod+1)/2;\n\t\tz1%=mod;\n\t\tint k2=kosu.sum(f,ss.cor);\n\t\tint z2=ss.sum(f,ss.cor);\n\t\tz2*=Dinvbe[f-1];\n\t\tz2%=mod;\n\t\tz2*=(mod+1)/2;\n\t\tz2%=mod;\n\t\t\tz2=k2+mod-z2;\n\t\t\tz2%=mod;\n\t\tans+=z1+z2;\n\t\t\n\t\tss.updadd(v.second,Dbe[v.second]);\n\t\tkosu.updadd(v.second,1);\n\t}\n\tcout<<ans%mod<<endl;\n}\n\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\nint n=1;\n//\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tsolve();\n\n\t}\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=n;i--;)\n#define rrep2(i,n) for(ll i=n;i--;)\n#define rrep3(i,a,b) for(ll i=b;i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=(a)+((b)-(a)-1)/(c)*(c);i>=(a);i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each1(i,a) for(auto&&i:a)\n#define each2(x,y,a) for(auto&&[x,y]:a)\n#define each3(x,y,z,a) for(auto&&[x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define Msum(...) accumulate(all(__VA_ARGS__),0_M)\n#define elif else if\n#define unless(a) if(!(a))\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type>name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type>name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > T(b)){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < T(b)){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T> a){ Uniq(a); unordered_map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T> a){ Uniq(a); map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const complex<T>& a){ if(a.real() >= 0) print('+'); print(a.real()); if(a.imag() >= 0) print('+'); print(a.imag()); print('i'); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\ntemplate<class T>\nstruct SegmentTree{\n    virtual T f(const T&, const T&) const = 0;\n    const T def_value;\n    ll size = 1, rank = 0, expected_size;\n    vector<T> data;\n    SegmentTree(ll n, const T& def_value): def_value(def_value), expected_size(n){\n        while(size < expected_size){\n            size *= 2;\n            rank++;\n        }\n        data.assign(size * 2, def_value);\n    }\n    SegmentTree(const vector<T>& v, const T& def_value): def_value(def_value), expected_size(v.size()){\n        while(size < expected_size){\n            size *= 2;\n            rank++;\n        }\n        data.assign(size * 2, def_value);\n        for(ll i = 0; i < v.size(); i++) data[size + i] = v[i];\n        // for(ll i = Base::size; --i;) Base::data[i] = f(Base::data[i * 2], Base::data[i * 2 + 1]);\n    }\n    T operator[](ll at) const {\n        return data[size + at];\n    }\n    void update(ll at){\n        while(at /= 2) data[at] = f(data[at * 2], data[at * 2 + 1]);\n    }\n    void set(ll at, const T& val){\n        at += size;\n        data[at] = val;\n        update(at);\n    }\n    void add(ll at, const T& val){\n        at += size;\n        data[at] += val;\n        update(at);\n    }\n    T get(ll l, ll r) const {\n        T L = def_value, R = def_value;\n        l += size; r += size;\n        for(; l < r; l /= 2, r /= 2){\n            if(l & 1) L = f(L, data[l++]);\n            if(r & 1) R = f(data[--r], R);\n        }\n        return f(L, R);\n    }\n    template<class F> ll find_last(const F& check, ll l = 0) const { // max x  s.t. check(get(l, x)) == true\n        if(l == expected_size) return expected_size;\n        ll height = 0, at = l + size;\n        T val = def_value;\n        for(; height <= rank; height++) if(at >> height & 1){\n            T val2 = f(val, data[at >> height]);\n            if(check(val2)){\n                at += 1 << height;\n                if(at == size * 2) return expected_size;\n                val = val2;\n            }\n            else break;\n        }\n        for(; height--; ){\n            T val2 = f(val, data[at >> height]);\n            if(check(val2)){\n                at += 1 << height;\n                if(at == size * 2) return expected_size;\n                val = val2;\n            }\n        }\n        return min(at - size, expected_size);\n    }\n    template<class F> ll find_first(const F& check, ll r) const { // min x  s.t. check(get(x, r)) == true\n        if(!r) return 0;\n        ll height = 0, at = r + size;\n        T val = def_value;\n        for(; height <= rank; height++) if(at >> height & 1){\n            T val2 = f(val, data[at >> height ^ 1]);\n            if(check(val2)){\n                at -= 1 << height;\n                if(at == size) return 0;\n                val = val2;\n            }\n            else break;\n        }\n        for(; height--; ){\n            T val2 = f(val, data[(at >> height) - 1]);\n            if(check(val2)){\n                at -= 1 << height;\n                if(at == size) return 0;\n                val = val2;\n            }\n        }\n        return at - size;\n    }\n    void clear(){\n        for(auto& i : data) i = def_value;\n    }\n};\ntemplate<class T>\nstruct RmQ : SegmentTree<T>{\n    using Base = SegmentTree<T>;\n    T f(const T& a, const T& b) const {return min(a, b);}\n    RmQ(ll n, const T& def_value) : Base(n, def_value){}\n    RmQ(const vector<T>& v, const T& def_value) : Base(v, def_value){\n        for(ll i = Base::size; --i;) Base::data[i] = f(Base::data[i * 2], Base::data[i * 2 + 1]);\n    }\n};\ntemplate<class T>\nstruct RMQ : SegmentTree<T>{\n    using Base = SegmentTree<T>;\n    T f(const T& a, const T& b) const {return max(a, b);}\n    RMQ(ll n, const T& def_value) : Base(n, def_value){}\n    RMQ(const vector<T>& v, const T& def_value) : Base(v, def_value){\n        for(ll i = Base::size; --i;) Base::data[i] = f(Base::data[i * 2], Base::data[i * 2 + 1]);\n    }\n};\ntemplate<class T>\nstruct RSQ : SegmentTree<T>{\n    using Base = SegmentTree<T>;\n    T f(const T& a, const T& b) const {return a + b;}\n    RSQ(ll n, const T& def_value = T()) : Base(n, def_value){}\n    RSQ(const vector<T>& v, const T& def_value = T()) : Base(v, def_value){\n        for(ll i = Base::size; --i;) Base::data[i] = f(Base::data[i * 2], Base::data[i * 2 + 1]);\n    }\n};\nconstexpr uint mod = MODD;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint() noexcept {}\n    constexpr Modint(const Modint &x) noexcept : num(x.num){}\n    inline constexpr operator ll() const noexcept { return num; }\n    inline constexpr Modint& operator+=(Modint x) noexcept { num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++() noexcept { if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator-() const noexcept { return Modint(0) -= *this; }\n    inline constexpr Modint operator-(Modint x) const noexcept { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x) noexcept { if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--() noexcept { if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x) noexcept { num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x) noexcept { return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x) noexcept {\n        using U = typename conditional<sizeof(T) >= 4, T, int>::type;\n        U y = x; y %= U(mod); if(y < 0) y += mod; num = uint(y);\n    }\n    template<class T> inline constexpr Modint operator+(T x) const noexcept { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x) noexcept { return operator+=(Modint(x)); }\n    template<class T> inline constexpr Modint operator-(T x) const noexcept { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x) noexcept { return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator*(T x) const noexcept { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x) noexcept { return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/(T x) const noexcept { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x) noexcept { return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    static inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x){ ll a; in(a); x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){\n    if(r < 0 || n < r) return 0;\n    if(n >> 24){ Modint ans = 1; for(ll i = 0; i < r; i++) ans *= n--; return ans; }\n    reserve(n + 1); return fac[n] * inv[n - r];\n}\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nsigned main(){\n    LL(n,k);\n    VEC(ll,p,n);\n    each(i,p)i--;\n    vec(Modint,power_,n*2+1);\n    auto power=power_.begin()+n;\n    power[0]=1;\n    power[1]=1_M-1_M/k;\n    rep(i,2,n+1)power[i]=power[i-1]*power[1];\n    power[-n]=power[n].inv();\n    rep(i,-n+1,0)power[i]=power[i-1]*power[1];\n    RSQ<Modint>low(n-k+1),high(n-k+1),cnt(n-k+1);\n    Modint ans=0;\n    vec(ll,inv,n);\n    rep(n)inv[p[i]]=max(0LL,i-k+1);\n    each(x,inv){\n        ans+=low.get(0,x)*power[-(n-k-x)];\n        ans+=cnt.get(x,cnt.size)*2-high.get(x,high.size)*power[-x];\n        low.add(x,power[n-k-x]);\n        high.add(x,power[x]);\n        cnt.add(x,1);\n    }\n    out(ans/2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 998244353;\n\nint add(int a, int b)\n{\n    a += b;\n    if (a >= MOD)\n    {\n        return a - MOD;\n    }\n    if (a < 0)\n    {\n        return a + MOD;\n    }\n    return a;\n}\n\nint mul(int a, int b)\n{\n    return a * (ll) b % MOD;\n}\n\nint pw(int a, int b)\n{\n    int r = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            r = mul(r, a);\n        }\n        a = mul(a, a);\n        b /= 2;\n    }\n    return r;\n}\n\nint dv(int a, int b)\n{\n    return mul(a, pw(b, MOD - 2));\n}\n\nconst int N = (int) 2e5 + 7;\nint n;\nint k;\nint a[N];\nint enter[N];\nint kek;\nint val[N];\nint inv_val[N];\nint inv2;\n\nint prob_swap(int i, int j)\n{\n    /// i < j\n    return mul(inv2, mul(val[j], inv_val[i]));\n}\n\nint aib[N];\n\nvoid clr()\n{\n    for (int i = 1; i <= n; i++)\n    {\n        aib[i] = 0;\n    }\n}\n\nvoid op(int i, int x)\n{\n    while (i <= n)\n    {\n        aib[i] += x;\n        i += i & (-i);\n    }\n}\n\nint get(int i)\n{\n    int sol = 0;\n    while (i)\n    {\n        sol += aib[i];\n        i -= i & (-i);\n    }\n    return sol;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> k;\n    inv2 = dv(1, 2);\n    kek = dv(k - 1, k);\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        enter[i] = max(0, i - k);\n        val[i] = pw(kek, enter[i]);\n        inv_val[i] = dv(1, val[i]);\n    }\n    int inversion_count = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        inversion_count = add(inversion_count, i - 1 - get(a[i]));\n        op(a[i], 1);\n    }\n    clr();\n    int invs = 0, x = 0, y = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = i + 1; j <= n; j++)\n        {\n            if (a[i] < a[j])\n            {\n                x = add(x, prob_swap(i, j));\n                invs = add(invs, prob_swap(i, j));\n            }\n            else\n            {\n                y = add(y, prob_swap(i, j));\n            }\n        }\n    }\n    invs = add(x, -y);\n    invs = add(invs, inversion_count);\n    cout << invs << \"\\n\";\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <atcoder/all>\nusing namespace atcoder;\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing mint = modint998244353;\n\nostream& operator<<(ostream& out, mint m){\n  out << m.val();\n  return out;\n}\n\nvector<mint> sum;\nvector<mint> evinv;\nvector<mint> mno;\nvector<int> sumzw;\n\nint n,k,nn;\n\nvoid mnoz(int v, mint x){\n  mno[v] *= x;\n  evinv[v] *= x;\n  sum[v] *= x;\n}\n\nvoid touch(int nr){\n  if(mno[nr] != 1){\n    mnoz(nr * 2, mno[nr]);\n    mnoz(nr * 2 + 1, mno[nr]);\n  }\n  mno[nr] = 1;\n}\n\nvoid licz(int nr){\n  sumzw[nr] = sumzw[nr * 2] + sumzw[nr*2+1];\n  sum[nr] = sum[nr * 2] + sum[nr * 2 + 1];\n  evinv[nr] = evinv[nr * 2] + evinv[nr * 2 + 1] + sumzw[nr * 2] * sum[nr * 2 + 1];\n}\n\nvoid add(int x){\n  function<void(int,int,int)> rec = [&](int nr,int po,int ko){\n    if(po + 1 == ko){\n      sum[nr]++;\n      sumzw[nr]--;\n      return;\n    }\n    touch(nr);\n    int m = (po + ko) / 2;\n    if(x < m)rec(nr * 2, po ,m);\n    else rec(nr * 2+1, m, ko);\n    licz(nr);\n  };\n  rec(1,0,nn);\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> k;\n  nn = 1;while(nn <= n)nn *= 2;\n  sum.resize(nn*2);\n  evinv.resize(nn*2);\n  mno.resize(nn*2, 1);\n  sumzw.resize(nn*2);\n  R(i,n){\n    sumzw[i + nn] = 1;\n  }\n  for(int i = nn-1; i; i--){\n    sumzw[i] = sumzw[i*2] + sumzw[i*2+1];\n  }\n  vector<int> p(n);\n  R(i,n){\n    cin >> p[i];\n    p[i]--;\n  }\n  R(i,k)add(p[i]);\n  debug(sum, mno, evinv, sumzw);\n  mint kinv = mint(1) / k;\n  mint res = 0;\n  R(i,n-k){\n    res += evinv[1] * kinv;\n    res += mint(k-1) / 2;\n    mnoz(1,(k-1) * kinv);\n    add(p[i+k]);\n  } \n  res += mint(k) * (k - 1) / 4;\n  debug(res * 4);\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define FIO ios_base::sync_with_stdio(false); cin.tie(0);\n#define trav(x,a) for (auto& x: a)\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), (x).end()\n#define mem(a,v) memset((a), (v), sizeof (a))\n// #define endl \"\\n\"\n#define case(t) cout << \"Case #\" << (t) << \": \"\n#define reada(a, n) for (int _i = 0; _i < (n); _i++) read(a[_i])\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int mod = 998244353;\nconst int inf = 1e9 + 7;\nconst int N = 2e5 + 5;\nconst double eps = 1e-9;\n\ntemplate<class T> void read(T& x) { cin >> x; }\ntemplate<class X, class Y> void read(pair<X,Y>& a) { read(a.first), read(a.second); }\ntemplate<class T> void read(vector<T>& x) { trav(y, x) read(y); }\ntemplate<class T, class... O> void read(T& x, O&... y) { read(x), read(y...); }\n\nstring to_string(const char& x) { return string(1,x); }\nstring to_string(const char*& x) { return (string)x; }\nstring to_string(const string& x) { return x; }\ntemplate<class T, class U> string to_string(const pair<T,U>& x) { return to_string(x.first) + \" \" + to_string(x.second); }\ntemplate<class T> string to_string(const vector<T>& x) { string ret = \"\"; bool f = 0; trav(y, x) ret += (!f ? \"\" : \" \") + to_string(y), f = 1; return ret; }\nvoid print() { cout << endl; }\ntemplate<class T> void pr(const T& x) { cout << to_string(x); }\ntemplate<class T, class... O> void print(const T& x, const O&... y) { pr(x); if (sizeof...(y)) pr(\" \"); print(y...); }\n\nint inv[N], ifac[N], fac[N];\n\nint add(int x, int y) { return x+y < mod ? x+y : x+y-mod; }\nint sub(int x, int y) { return x-y >= 0 ? x-y : x-y+mod; }\nint mul(int x, int y) { return x * 1ll * y % mod; }\ntemplate<class T, class... O> int add(T x, O... y) { return add(x, add(y...)); }\ntemplate<class T, class... O> int mul(T x, O... y) { return mul(x, mul(y...)); }\nint norm(int x) { return x >= 0 ? (x < mod ? x : x-mod) : x+mod; }\nint pw(int x, int y) {\n  int r = 1;\n  for (; y; x = mul(x, x), y /= 2)\n    if (y & 1)\n      r = mul(r, x);\n  return r;\n}\nint inverse(int x) { return pw(x, mod-2); }\nint ncr(int n, int k) {\n  if (n < k || k < 0) return 0;\n  if (n < N) return mul(fac[n], ifac[n-k], ifac[k]);\n  int r = 1;\n  for (int i = 1; i <= k; i++)\n    r = mul(r, n-i+1, inv[i]);\n  return r;\n}\n\nvoid precomputeInverse(int n) {\n  inv[1] = ifac[0] = ifac[1] = fac[0] = fac[1] = 1;\n  for (int i = 2; i < n; i++) {\n    inv[i] = mod - mul(mod / i, inv[mod % i]);\n    fac[i] = mul(fac[i-1], i);\n    ifac[i] = mul(ifac[i-1], inv[i]);\n  }\n}\n\nstruct mat : array<int,4> {\n  mat() {}\n  mat(int i, int j, int k, int l) { (*this)[0] = i, (*this)[1] = j, (*this)[2] = k, (*this)[3] = l; }\n  mat operator+=(mat x) {\n    for (int i = 0; i < 2; i++)\n      for (int j = 0; j < 2; j++)\n        (*this)[2*i+j] = add((*this)[2*i+j], x[2*i+j]);\n    return *this;\n  }\n  mat operator*=(mat x) {\n    mat r;\n    for (int i = 0; i < 2; i++)\n      for (int j = 0; j < 2; j++)\n        r[2*i+j] = add(mul((*this)[2*i+0], x[2*0+j]), mul((*this)[2*i+1], x[2*1+j]));\n    *this = r;\n    return *this;\n  }\n  mat& operator=(mat x) {\n    for (int i = 0; i < 2; i++)\n      for (int j = 0; j < 2; j++)\n        (*this)[2*i+j] = x[2*i+j];\n    return *this;\n  }\n  friend mat operator+(mat x, mat y) { return x += y; }\n  friend mat operator*(mat x, mat y) { return x *= y; }\n} pref[2][2][N], ipref[2][2][N], suf[N], pre[N], lo[N][2], hi[N][2];\npair<mat,mat> seg[4*N];\n\nstring to_string(const mat& x) { string ret = \"\"; for (int i = 0; i < 4; i++) ret += (!i ? \"\" : \" \") + to_string(x[i]); return ret; }\n\nmat imat(mat x) {\n  return mat(inverse(x[2*0+0]),0,mul(mod-1,x[2*1+0],inverse(x[2*0+0]),inverse(x[2*1+1])),inverse(x[2*1+1]));\n}\n\nvoid build(int l, int r, int k) {\n  seg[k].st = mat(0,0,0,0);\n  seg[k].nd = mat(0,0,0,0);\n  if (l == r) return;\n  int m = (l+r) / 2;\n  build(l, m, k*2); build(m+1, r, k*2+1);\n}\n\nvoid upd(int l, int r, int k, int x) {\n  if (l == r) {\n    seg[k] = make_pair(lo[x][1], hi[x][0]);\n    return;\n  }\n  int m = (l+r) / 2;\n  if (x <= m) upd(l, m, k*2, x);\n  else upd(m+1, r, k*2+1, x);\n  seg[k].st = seg[k*2].st + seg[k*2+1].st;\n  seg[k].nd = seg[k*2].nd + seg[k*2+1].nd;\n}\n\npair<mat,mat> qry(int l, int r, int k, int x, int y) {\n  if (r < x || y < l || x > y) return make_pair(mat(0,0,0,0),mat(0,0,0,0));\n  if (x <= l && r <= y) return seg[k];\n  int m = (l+r) / 2;\n  pair<mat,mat> lhs = qry(l, m, k*2, x, y);\n  pair<mat,mat> rhs = qry(m+1, r, k*2+1, x, y);\n  rhs.st = rhs.st + lhs.st;\n  rhs.nd = rhs.nd + lhs.nd;\n  return rhs;\n}\n\nint main() {\n  FIO\n  precomputeInverse(N);\n  int n, k; read(n, k); vector<int> p(n); read(p);\n  for (int visi = 0; visi <= 1; visi++) {\n    for (int visj = 0; visj <= 1; visj++) if (visi ^ visj) {\n      pref[visi][visj][0] = mat(1, 0, 0, 1);\n      ipref[visi][visj][0] = mat(1, 0, 0, 1);\n      for (int i = 1; i <= n; i++) {\n        mat cur = mat(norm(min(k, n-i+1) - visi - visj), 0, visi, min(k, n-i+1));\n        pref[visi][visj][i] = cur * pref[visi][visj][i-1];\n        ipref[visi][visj][i] = ipref[visi][visj][i-1] * imat(cur);\n      }\n    }\n  }\n  pre[0] = mat(1, 0, 0, 1);\n  for (int i = 1; i <= n; i++)\n    pre[i] = mat(min(k, n-i+1), 0, 0, min(k, n-i+1)) * pre[i-1];\n  suf[n+1] = mat(1, 0, 0, 1);\n  for (int i = n; i; i--)\n    suf[i] = suf[i+1] * mat(norm(min(k, n-i+1) - 2), 0, 1, min(k, n-i+1));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2; j++) // i < j, i > j\n      hi[i][j] = suf[max(0,i-k+1)+1] * pref[j^1][j][max(0,i-k+1)];\n    for (int j = 0; j < 2; j++) // i < j, i > j\n      lo[i][j] = ipref[j^1][j][max(0,i-k+1)] * pre[max(0,i-k+1)];\n  }\n  int ans = 0, tot = mul(pw(k, n-k), fac[k]), itot = inverse(tot);\n  vector<int> ind(n); iota(all(ind), 0);\n  sort(all(ind), [&](int l, int r) { return p[l] < p[r]; });\n  build(0, n-1, 1);\n  for (int ii = 0; ii < n; ii++) {\n    int i = ind[ii];\n    ans = add(ans, (hi[i][1] * qry(0, n-1, 1, 0, i-1).st)[2]); // lo[][1]\n    ans = add(ans, (qry(0, n-1, 1, i+1, n-1).nd * lo[i][0])[2]); // hi[][0]\n    upd(0, n-1, 1, i);\n  }\n  // for (int i = 0; i < n; i++) {\n  //   for (int j = 0; j < n; j++) if (p[i] > p[j]) { // place i before j\n  //     ans = add(ans, (hi[max(i,j)][i > j] * lo[min(i,j)][i > j])[2]);\n  //   }\n  // }\n  ans = mul(ans, itot);\n  print(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\n\nusing namespace std;\nusing namespace atcoder;\n\ntypedef long long ll;\n\nconst int N = 200010;\nconst int MOD = 998244353;\n\nll fen[N];\nint n, k, p[N];\n\nvoid update (int p, ll v) {\n  while (p < N) fen[p] = (fen[p] + v) % MOD, p += p & -p;\n}\n\nll pref (int p) {\n  ll ret = 0;\n  while (p) ret = (ret + fen[p]) % MOD, p -= p & -p;\n  return ret;\n}\n\ninline ll get (int l, int r) {\n  return (pref(r) - pref(l - 1) + MOD) % MOD;\n}\n\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", p + i);\n  }\n  fenwick_tree <int> f(n + 69);\n  ll chance = inv_mod(k, MOD);\n  ll offset = (MOD + 1 - chance) % MOD;\n  ll half = inv_mod(2, MOD);\n  ll ans = 0;\n  for (int j = 1; j <= k; ++j) {\n    ans += (j - 1) * half, ans %= MOD;\n    f.add(p[j], 1);\n  }\n  for (int j = k + 1; j <= n; ++j) {\n    ll cur = pow_mod(offset, j - k, MOD) * half % MOD;\n    ll small = f.sum(1, p[j]);\n    ans = (ans + small * cur) % MOD;\n    ans = (ans + (k - small) * (1 - cur)) % MOD;\n  }\n  for (int j = 1; j <= k; ++j) {\n    f.add(p[j], -1);\n  }\n  for (int j = k + 1; j <= n; ++j) {\n    ll cur = pow_mod(offset, j, MOD) * half % MOD;\n    ll big = j - 1 - k - f.sum(1, p[j]);\n    ll smallAdd = cur * pref(p[j] - 1) % MOD;\n    ll bigAdd = (big - cur * get(p[j] + 1, n)) % MOD;\n    ans += smallAdd, ans += bigAdd;\n    f.add(p[j], 1); update(p[j], pow_mod(offset, MOD - 1 - j, MOD));\n  }\n  // for (int j = k + 1; j <= n; ++j) {\n  //   int x = p[i], y = p[j];\n  //   ll swap = pow_mod(offset, max(0, j - max(i, k)), MOD) * half % MOD;\n  //   if (x < y) ans += swap; else ans += 1 - swap;\n  // }\n  ans %= MOD, ans += MOD, ans %= MOD;\n  cout << ans << '\\n';\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n/*#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#define mp make_pair\n#define pb push_back\n#define pll pair<LL,LL>\n#define pii pair<int,int>\n#define y second\n#define x first\n#define LL long long \n#define sqr(x) ((x)*(x))\n#define pi acosl(-1)\n#define MEM(x) memset(x,0,sizeof(x))\n#define MEMS(x) memset(x,-1,sizeof(x))\nusing namespace std;\n/*\nstruct matrix{\n    LL a[2][2];\n};\nint mod=998244353;\nmatrix operator*(const matrix &a,const matrix &b){\n    matrix c;\n    for(int i = 0;i<2;i++){\n        for(int j = 0;j<2;j++){\n            c.a[i][j]=0;\n        }\n    }\n    for(int i = 0;i<2;i++){\n        for(int j = 0;j<2;j++)[\n            for(int k =0;k<2;k++){\n                c.a[i][j]+=a.a[i][k]*b.a[k][j]%mod;\n            }\n            c.a[i][j]%=mod;\n        ]\n    }\n    return c;\n}\nmatrix f_pow(matrix a,int b){\n    matrix res,tmp=a;\n    res.a[0][0]=res.a[1][1]=1;\n    res.a[0][1]=res.a[1][0]=0;\n    while(b){\n        if(b&1)res=res*tmp;\n        tmp=tmp*tmp;\n        b>>=1;\n    }\n    return res;\n}*/\nconst int mod=998244353;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nLL s[200005];\nLL sum[200005];\nvoid add(LL x,LL k,LL *S){\n   // printf(\"%lld\\n\",x);\n    for(int i = x;i<200005;i+=i&-i){\n        S[i]+=k;\n        S[i]%=mod;\n    }\n    //return res;\n}\nLL query(LL x,LL *S){\n    LL res=0;\n    for(int i = x;i>0;i-=i&-i){\n        res+=S[i];\n    }\n    return res%mod;\n}\nvoid solve(){\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    LL ans=0;\n    LL aa=(k-1)*f_pow(k,mod-2)%mod;\n    for(int i = 1;i<=n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        LL q1=query(x-1,s),q2=((query(n,s)-query(x-1,s))%mod+mod)%mod;\n        ans+=(q1+q2)*f_pow(aa,max(i-k,0))%mod*((mod+1)/2)%mod;\n      //  printf(\"%lld %lld %lld %lld\\n\",q1,q2,ans,i-1-query(x,sum));\n        ans+=((i-1-query(x,sum)-q2*f_pow(aa,max(i-k,0)))%mod+mod)%mod;\n        ans%=mod;\n        add(x,1,sum);\n        add(x,f_pow(f_pow(aa,max(i-k,0)),mod-2),s);\n        //printf(\"%lld %lld %lld\\n\",q1,q2,ans);\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main(){\n    int t=1;\n    //scanf(\"%d\",&t);\n    while(t--){\n        solve();\n    }\n}\n/*\n1 6 6\n2 7 4\n3 5 2\n4 3 1\n5 2 5\n6 4 0\n7 1 3\n*/\n/*\n100\n5\n5 4\n4 2\n4 2 3\n5 4 2 3 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma comment (linker, \"/STACK:526000000\")\n#include \"bits/stdc++.h\"\n\n/*\nAtCoder Compressed STL, licensed under public domain (cc0)\nDownload Compressed: https://gist.github.com/yosupo06/ddd51afb727600fd95d9d8ad6c3c80c9\nbased on AtCoder STL,\nDownload: https://img.atcoder.jp/practice2/ac-library.zip\n*/\n\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tint ceil_pow2(int n) {\n\t\t\tint x = 0;\n\t\t\twhile ((1U << x) < (unsigned int)(n)) x++;\n\t\t\treturn x;\n\t\t}\n\n\t\tint bsf(unsigned int n) {\n#ifdef _MSC_VER\n\t\t\tunsigned long index;\n\t\t\t_BitScanForward(&index, n);\n\t\t\treturn index;\n#else\n\t\t\treturn __builtin_ctz(n);\n#endif\n\t\t}\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tconstexpr long long safe_mod(long long x, long long m) {\n\t\t\tx %= m;\n\t\t\tif (x < 0) x += m;\n\t\t\treturn x;\n\t\t}\n\n\t\tstruct barrett {\n\t\t\tunsigned int _m;\n\t\t\tunsigned long long im;\n\n\t\t\tbarrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n\t\t\tunsigned int umod() const { return _m; }\n\n\t\t\tunsigned int mul(unsigned int a, unsigned int b) const {\n\n\t\t\t\tunsigned long long z = a;\n\t\t\t\tz *= b;\n#ifdef _MSC_VER\n\t\t\t\tunsigned long long x;\n\t\t\t\t_umul128(z, im, &x);\n#else\n\t\t\t\tunsigned long long x =\n\t\t\t\t\t(unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n\t\t\t\tunsigned int v = (unsigned int)(z - x * _m);\n\t\t\t\tif (_m <= v) v += _m;\n\t\t\t\treturn v;\n\t\t\t}\n\t\t};\n\n\t\tconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n\t\t\tif (m == 1) return 0;\n\t\t\tunsigned int _m = (unsigned int)(m);\n\t\t\tunsigned long long r = 1;\n\t\t\tunsigned long long y = safe_mod(x, m);\n\t\t\twhile (n) {\n\t\t\t\tif (n & 1) r = (r * y) % _m;\n\t\t\t\ty = (y * y) % _m;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\n\t\tconstexpr bool is_prime_constexpr(int n) {\n\t\t\tif (n <= 1) return false;\n\t\t\tif (n == 2 || n == 7 || n == 61) return true;\n\t\t\tif (n % 2 == 0) return false;\n\t\t\tlong long d = n - 1;\n\t\t\twhile (d % 2 == 0) d /= 2;\n\t\t\tint v[3] = { 2,7,61 };\n\t\t\tfor (long long a : v) {\n\t\t\t\tlong long t = d;\n\t\t\t\tlong long y = pow_mod_constexpr(a, t, n);\n\t\t\t\twhile (t != n - 1 && y != 1 && y != n - 1) {\n\t\t\t\t\ty = y * y % n;\n\t\t\t\t\tt <<= 1;\n\t\t\t\t}\n\t\t\t\tif (y != n - 1 && t % 2 == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\ttemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n\t\tconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n\t\t\ta = safe_mod(a, b);\n\t\t\tif (a == 0) return { b, 0 };\n\n\t\t\tlong long s = b, t = a;\n\t\t\tlong long m0 = 0, m1 = 1;\n\n\t\t\twhile (t) {\n\t\t\t\tlong long u = s / t;\n\t\t\t\ts -= t * u;\n\t\t\t\tm0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n\n\t\t\t\tauto tmp = s;\n\t\t\t\ts = t;\n\t\t\t\tt = tmp;\n\t\t\t\ttmp = m0;\n\t\t\t\tm0 = m1;\n\t\t\t\tm1 = tmp;\n\t\t\t}\n\t\t\tif (m0 < 0) m0 += b / s;\n\t\t\treturn { s, m0 };\n\t\t}\n\n\t\tconstexpr int primitive_root_constexpr(int m) {\n\t\t\tif (m == 2) return 1;\n\t\t\tif (m == 167772161) return 3;\n\t\t\tif (m == 469762049) return 3;\n\t\t\tif (m == 754974721) return 11;\n\t\t\tif (m == 998244353) return 3;\n\t\t\tint divs[20] = {};\n\t\t\tdivs[0] = 2;\n\t\t\tint cnt = 1;\n\t\t\tint x = (m - 1) / 2;\n\t\t\twhile (x % 2 == 0) x /= 2;\n\t\t\tfor (int i = 3; (long long)(i)*i <= x; i += 2) {\n\t\t\t\tif (x % i == 0) {\n\t\t\t\t\tdivs[cnt++] = i;\n\t\t\t\t\twhile (x % i == 0) {\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x > 1) {\n\t\t\t\tdivs[cnt++] = x;\n\t\t\t}\n\t\t\tfor (int g = 2;; g++) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t\t\tif (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) return g;\n\t\t\t}\n\t\t}\n\t\ttemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n#ifndef _MSC_VER\n\t\ttemplate <class T>\n\t\tusing is_signed_int128 =\n\t\t\ttypename std::conditional<std::is_same<T, __int128_t>::value ||\n\t\t\tstd::is_same<T, __int128>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int128 =\n\t\t\ttypename std::conditional<std::is_same<T, __uint128_t>::value ||\n\t\t\tstd::is_same<T, unsigned __int128>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing make_unsigned_int128 =\n\t\t\ttypename std::conditional<std::is_same<T, __int128_t>::value,\n\t\t\t__uint128_t,\n\t\t\tunsigned __int128>;\n\n\t\ttemplate <class T>\n\t\tusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n\t\t\tis_signed_int128<T>::value ||\n\t\t\tis_unsigned_int128<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_signed_int = typename std::conditional<(is_integral<T>::value&&\n\t\t\tstd::is_signed<T>::value) ||\n\t\t\tis_signed_int128<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int =\n\t\t\ttypename std::conditional<(is_integral<T>::value&&\n\t\t\t\tstd::is_unsigned<T>::value) ||\n\t\t\tis_unsigned_int128<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing to_unsigned = typename std::conditional<\n\t\t\tis_signed_int128<T>::value,\n\t\t\tmake_unsigned_int128<T>,\n\t\t\ttypename std::conditional<std::is_signed<T>::value,\n\t\t\tstd::make_unsigned<T>,\n\t\t\tstd::common_type<T>>::type>::type;\n\n#else\n\n\t\ttemplate <class T> using is_integral = typename std::is_integral<T>;\n\n\t\ttemplate <class T>\n\t\tusing is_signed_int =\n\t\t\ttypename std::conditional<is_integral<T>::value&& std::is_signed<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int =\n\t\t\ttypename std::conditional<is_integral<T>::value&&\n\t\t\tstd::is_unsigned<T>::value,\n\t\t\tstd::true_type,\n\t\t\tstd::false_type>::type;\n\n\t\ttemplate <class T>\n\t\tusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n\t\t\tstd::make_unsigned<T>,\n\t\t\tstd::common_type<T>>::type;\n\n#endif\n\n\t\ttemplate <class T>\n\t\tusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\n\t\ttemplate <class T>\n\t\tusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\n\t\ttemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tstruct modint_base {};\n\t\tstruct static_modint_base : modint_base {};\n\n\t\ttemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\n\t\ttemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n\t}  // namespace internal\n\n\ttemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n\tstruct static_modint : internal::static_modint_base {\n\t\tusing mint = static_modint;\n\n\tpublic:\n\t\tstatic constexpr int mod() { return m; }\n\t\tstatic mint raw(int v) {\n\t\t\tmint x;\n\t\t\tx._v = v;\n\t\t\treturn x;\n\t\t}\n\n\t\tstatic_modint() : _v(0) {}\n\t\ttemplate <class T, internal::is_signed_int_t<T>* = nullptr>\n\t\tstatic_modint(T v) {\n\t\t\tlong long x = (long long)(v % (long long)(umod()));\n\t\t\tif (x < 0) x += umod();\n\t\t\t_v = (unsigned int)(x);\n\t\t}\n\t\ttemplate <class T, internal::is_unsigned_int_t<T>* = nullptr>\n\t\tstatic_modint(T v) {\n\t\t\t_v = (unsigned int)(v % umod());\n\t\t}\n\t\tstatic_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n\t\tunsigned int val() const { return _v; }\n\n\t\tmint& operator++() {\n\t\t\t_v++;\n\t\t\tif (_v == umod()) _v = 0;\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator--() {\n\t\t\tif (_v == 0) _v = umod();\n\t\t\t_v--;\n\t\t\treturn *this;\n\t\t}\n\t\tmint operator++(int) {\n\t\t\tmint result = *this;\n\t\t\t++* this;\n\t\t\treturn result;\n\t\t}\n\t\tmint operator--(int) {\n\t\t\tmint result = *this;\n\t\t\t--* this;\n\t\t\treturn result;\n\t\t}\n\n\t\tmint& operator+=(const mint& rhs) {\n\t\t\t_v += rhs._v;\n\t\t\tif (_v >= umod()) _v -= umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator-=(const mint& rhs) {\n\t\t\t_v -= rhs._v;\n\t\t\tif (_v >= umod()) _v += umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator*=(const mint& rhs) {\n\t\t\tunsigned long long z = _v;\n\t\t\tz *= rhs._v;\n\t\t\t_v = (unsigned int)(z % umod());\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n\t\tmint operator+() const { return *this; }\n\t\tmint operator-() const { return mint() - *this; }\n\n\t\tmint pow(long long n) const {\n\t\t\tassert(0 <= n);\n\t\t\tmint x = *this, r = 1;\n\t\t\twhile (n) {\n\t\t\t\tif (n & 1) r *= x;\n\t\t\t\tx *= x;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tmint inv() const {\n\t\t\tif (prime) {\n\t\t\t\tassert(_v);\n\t\t\t\treturn pow(umod() - 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto eg = internal::inv_gcd(_v, m);\n\t\t\t\tassert(eg.first == 1);\n\t\t\t\treturn eg.second;\n\t\t\t}\n\t\t}\n\n\t\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) += rhs;\n\t\t}\n\t\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) -= rhs;\n\t\t}\n\t\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) *= rhs;\n\t\t}\n\t\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) /= rhs;\n\t\t}\n\t\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v == rhs._v;\n\t\t}\n\t\tfriend bool operator!=(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v != rhs._v;\n\t\t}\n\n\tprivate:\n\t\tunsigned int _v;\n\t\tstatic constexpr unsigned int umod() { return m; }\n\t\tstatic constexpr bool prime = internal::is_prime<m>;\n\t};\n\n\ttemplate <int id> struct dynamic_modint : internal::modint_base {\n\t\tusing mint = dynamic_modint;\n\n\tpublic:\n\t\tstatic int mod() { return (int)(bt.umod()); }\n\t\tstatic void set_mod(int m) {\n\t\t\tassert(1 <= m);\n\t\t\tbt = internal::barrett(m);\n\t\t}\n\t\tstatic mint raw(int v) {\n\t\t\tmint x;\n\t\t\tx._v = v;\n\t\t\treturn x;\n\t\t}\n\n\t\tdynamic_modint() : _v(0) {}\n\t\ttemplate <class T, internal::is_signed_int_t<T>* = nullptr>\n\t\tdynamic_modint(T v) {\n\t\t\tlong long x = (long long)(v % (long long)(mod()));\n\t\t\tif (x < 0) x += mod();\n\t\t\t_v = (unsigned int)(x);\n\t\t}\n\t\ttemplate <class T, internal::is_unsigned_int_t<T>* = nullptr>\n\t\tdynamic_modint(T v) {\n\t\t\t_v = (unsigned int)(v % mod());\n\t\t}\n\t\tdynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n\t\tunsigned int val() const { return _v; }\n\n\t\tmint& operator++() {\n\t\t\t_v++;\n\t\t\tif (_v == umod()) _v = 0;\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator--() {\n\t\t\tif (_v == 0) _v = umod();\n\t\t\t_v--;\n\t\t\treturn *this;\n\t\t}\n\t\tmint operator++(int) {\n\t\t\tmint result = *this;\n\t\t\t++* this;\n\t\t\treturn result;\n\t\t}\n\t\tmint operator--(int) {\n\t\t\tmint result = *this;\n\t\t\t--* this;\n\t\t\treturn result;\n\t\t}\n\n\t\tmint& operator+=(const mint& rhs) {\n\t\t\t_v += rhs._v;\n\t\t\tif (_v >= umod()) _v -= umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator-=(const mint& rhs) {\n\t\t\t_v += mod() - rhs._v;\n\t\t\tif (_v >= umod()) _v -= umod();\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator*=(const mint& rhs) {\n\t\t\t_v = bt.mul(_v, rhs._v);\n\t\t\treturn *this;\n\t\t}\n\t\tmint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n\t\tmint operator+() const { return *this; }\n\t\tmint operator-() const { return mint() - *this; }\n\n\t\tmint pow(long long n) const {\n\t\t\tassert(0 <= n);\n\t\t\tmint x = *this, r = 1;\n\t\t\twhile (n) {\n\t\t\t\tif (n & 1) r *= x;\n\t\t\t\tx *= x;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tmint inv() const {\n\t\t\tauto eg = internal::inv_gcd(_v, mod());\n\t\t\tassert(eg.first == 1);\n\t\t\treturn eg.second;\n\t\t}\n\n\t\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) += rhs;\n\t\t}\n\t\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) -= rhs;\n\t\t}\n\t\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) *= rhs;\n\t\t}\n\t\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\t\treturn mint(lhs) /= rhs;\n\t\t}\n\t\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v == rhs._v;\n\t\t}\n\t\tfriend bool operator!=(const mint& lhs, const mint& rhs) {\n\t\t\treturn lhs._v != rhs._v;\n\t\t}\n\n\tprivate:\n\t\tunsigned int _v;\n\t\tstatic internal::barrett bt;\n\t\tstatic unsigned int umod() { return bt.umod(); }\n\t};\n\ttemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\n\tusing modint998244353 = static_modint<998244353>;\n\tusing modint1000000007 = static_modint<1000000007>;\n\tusing modint = dynamic_modint<-1>;\n\n\tnamespace internal {\n\n\t\ttemplate <class T>\n\t\tusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\n\t\ttemplate <class T>\n\t\tusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\n\t\ttemplate <class> struct is_dynamic_modint : public std::false_type {};\n\t\ttemplate <int id>\n\t\tstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\n\t\ttemplate <class T>\n\t\tusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\ttemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\n\t\tvoid butterfly(std::vector<mint>& a) {\n\t\t\tstatic constexpr int g = internal::primitive_root<mint::mod()>;\n\t\t\tint n = int(a.size());\n\t\t\tint h = internal::ceil_pow2(n);\n\n\t\t\tstatic bool first = true;\n\t\t\tstatic mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tmint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n\t\t\t\tint cnt2 = bsf(mint::mod() - 1);\n\t\t\t\tmint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n\t\t\t\tfor (int i = cnt2; i >= 2; i--) {\n\t\t\t\t\tes[i - 2] = e;\n\t\t\t\t\ties[i - 2] = ie;\n\t\t\t\t\te *= e;\n\t\t\t\t\tie *= ie;\n\t\t\t\t}\n\t\t\t\tmint now = 1;\n\t\t\t\tfor (int i = 0; i < cnt2 - 2; i++) {\n\t\t\t\t\tsum_e[i] = es[i] * now;\n\t\t\t\t\tnow *= ies[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int ph = 1; ph <= h; ph++) {\n\t\t\t\tint w = 1 << (ph - 1), p = 1 << (h - ph);\n\t\t\t\tmint now = 1;\n\t\t\t\tfor (int s = 0; s < w; s++) {\n\t\t\t\t\tint offset = s << (h - ph + 1);\n\t\t\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\t\t\tauto l = a[i + offset];\n\t\t\t\t\t\tauto r = a[i + offset + p] * now;\n\t\t\t\t\t\ta[i + offset] = l + r;\n\t\t\t\t\t\ta[i + offset + p] = l - r;\n\t\t\t\t\t}\n\t\t\t\t\tnow *= sum_e[bsf(~(unsigned int)(s))];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\n\t\tvoid butterfly_inv(std::vector<mint>& a) {\n\t\t\tstatic constexpr int g = internal::primitive_root<mint::mod()>;\n\t\t\tint n = int(a.size());\n\t\t\tint h = internal::ceil_pow2(n);\n\n\t\t\tstatic bool first = true;\n\t\t\tstatic mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tmint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n\t\t\t\tint cnt2 = bsf(mint::mod() - 1);\n\t\t\t\tmint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n\t\t\t\tfor (int i = cnt2; i >= 2; i--) {\n\t\t\t\t\tes[i - 2] = e;\n\t\t\t\t\ties[i - 2] = ie;\n\t\t\t\t\te *= e;\n\t\t\t\t\tie *= ie;\n\t\t\t\t}\n\t\t\t\tmint now = 1;\n\t\t\t\tfor (int i = 0; i < cnt2 - 2; i++) {\n\t\t\t\t\tsum_ie[i] = ies[i] * now;\n\t\t\t\t\tnow *= es[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int ph = h; ph >= 1; ph--) {\n\t\t\t\tint w = 1 << (ph - 1), p = 1 << (h - ph);\n\t\t\t\tmint inow = 1;\n\t\t\t\tfor (int s = 0; s < w; s++) {\n\t\t\t\t\tint offset = s << (h - ph + 1);\n\t\t\t\t\tfor (int i = 0; i < p; i++) {\n\t\t\t\t\t\tauto l = a[i + offset];\n\t\t\t\t\t\tauto r = a[i + offset + p];\n\t\t\t\t\t\ta[i + offset] = l + r;\n\t\t\t\t\t\ta[i + offset + p] =\n\t\t\t\t\t\t\t(unsigned long long)(mint::mod() + l.val() - r.val()) *\n\t\t\t\t\t\t\tinow.val();\n\t\t\t\t\t}\n\t\t\t\t\tinow *= sum_ie[bsf(~(unsigned int)(s))];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}  // namespace internal\n\n\ttemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\n\tstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n\t\tint n = int(a.size()), m = int(b.size());\n\t\tif (!n || !m) return {};\n\t\tif (std::min(n, m) <= 60) {\n\t\t\tif (n < m) {\n\t\t\t\tstd::swap(n, m);\n\t\t\t\tstd::swap(a, b);\n\t\t\t}\n\t\t\tstd::vector<mint> ans(n + m - 1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tans[i + j] += a[i] * b[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tint z = 1 << internal::ceil_pow2(n + m - 1);\n\t\ta.resize(z);\n\t\tinternal::butterfly(a);\n\t\tb.resize(z);\n\t\tinternal::butterfly(b);\n\t\tfor (int i = 0; i < z; i++) {\n\t\t\ta[i] *= b[i];\n\t\t}\n\t\tinternal::butterfly_inv(a);\n\t\ta.resize(n + m - 1);\n\t\tmint iz = mint(z).inv();\n\t\tfor (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n\t\treturn a;\n\t}\n\n\ttemplate <unsigned int mod = 998244353,\n\t\tclass T,\n\t\tstd::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n\t\tstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n\t\tint n = int(a.size()), m = int(b.size());\n\t\tif (!n || !m) return {};\n\n\t\tusing mint = static_modint<mod>;\n\t\tstd::vector<mint> a2(n), b2(m);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta2[i] = mint(a[i]);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tb2[i] = mint(b[i]);\n\t\t}\n\t\tauto c2 = convolution(move(a2), move(b2));\n\t\tstd::vector<T> c(n + m - 1);\n\t\tfor (int i = 0; i < n + m - 1; i++) {\n\t\t\tc[i] = c2[i].val();\n\t\t}\n\t\treturn c;\n\t}\n\n\tstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n\t\tconst std::vector<long long>& b) {\n\t\tint n = int(a.size()), m = int(b.size());\n\t\tif (!n || !m) return {};\n\n\t\tstatic constexpr unsigned long long MOD1 = 754974721;  // 2^24\n\t\tstatic constexpr unsigned long long MOD2 = 167772161;  // 2^25\n\t\tstatic constexpr unsigned long long MOD3 = 469762049;  // 2^26\n\t\tstatic constexpr unsigned long long M2M3 = MOD2 * MOD3;\n\t\tstatic constexpr unsigned long long M1M3 = MOD1 * MOD3;\n\t\tstatic constexpr unsigned long long M1M2 = MOD1 * MOD2;\n\t\tstatic constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n\t\tstatic constexpr unsigned long long i1 =\n\t\t\tinternal::inv_gcd(MOD2 * MOD3, MOD1).second;\n\t\tstatic constexpr unsigned long long i2 =\n\t\t\tinternal::inv_gcd(MOD1 * MOD3, MOD2).second;\n\t\tstatic constexpr unsigned long long i3 =\n\t\t\tinternal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n\t\tauto c1 = convolution<MOD1>(a, b);\n\t\tauto c2 = convolution<MOD2>(a, b);\n\t\tauto c3 = convolution<MOD3>(a, b);\n\n\t\tstd::vector<long long> c(n + m - 1);\n\t\tfor (int i = 0; i < n + m - 1; i++) {\n\t\t\tunsigned long long x = 0;\n\t\t\tx += (c1[i] * i1) % MOD1 * M2M3;\n\t\t\tx += (c2[i] * i2) % MOD2 * M1M3;\n\t\t\tx += (c3[i] * i3) % MOD3 * M1M2;\n\t\t\tlong long diff =\n\t\t\t\tc1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n\t\t\tif (diff < 0) diff += MOD1;\n\t\t\tstatic constexpr unsigned long long offset[5] = {\n\t\t\t\t0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3 };\n\t\t\tx -= offset[diff % 5];\n\t\t\tc[i] = x;\n\t\t}\n\n\t\treturn c;\n\t}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\tstruct dsu {\n\tpublic:\n\t\tdsu() : _n(0) {}\n\t\tdsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n\t\tint merge(int a, int b) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\tassert(0 <= b && b < _n);\n\t\t\tint x = leader(a), y = leader(b);\n\t\t\tif (x == y) return x;\n\t\t\tif (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n\t\t\tparent_or_size[x] += parent_or_size[y];\n\t\t\tparent_or_size[y] = x;\n\t\t\treturn x;\n\t\t}\n\n\t\tbool same(int a, int b) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\tassert(0 <= b && b < _n);\n\t\t\treturn leader(a) == leader(b);\n\t\t}\n\n\t\tint leader(int a) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\tif (parent_or_size[a] < 0) return a;\n\t\t\treturn parent_or_size[a] = leader(parent_or_size[a]);\n\t\t}\n\n\t\tint size(int a) {\n\t\t\tassert(0 <= a && a < _n);\n\t\t\treturn -parent_or_size[leader(a)];\n\t\t}\n\n\t\tstd::vector<std::vector<int>> groups() {\n\t\t\tstd::vector<int> leader_buf(_n), group_size(_n);\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tleader_buf[i] = leader(i);\n\t\t\t\tgroup_size[leader_buf[i]]++;\n\t\t\t}\n\t\t\tstd::vector<std::vector<int>> result(_n);\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tresult[i].reserve(group_size[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tresult[leader_buf[i]].push_back(i);\n\t\t\t}\n\t\t\tresult.erase(\n\t\t\t\tstd::remove_if(result.begin(), result.end(),\n\t\t\t\t\t[&](const std::vector<int>& v) { return v.empty(); }),\n\t\t\t\tresult.end());\n\t\t\treturn result;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<int> parent_or_size;\n\t};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class T> struct fenwick_tree {\n\t\tusing U = internal::to_unsigned_t<T>;\n\n\tpublic:\n\t\tfenwick_tree() : _n(0) {}\n\t\tfenwick_tree(int n) : _n(n), data(n) {}\n\n\t\tvoid add(int p, T x) {\n\t\t\tassert(0 <= p && p < _n);\n\t\t\tp++;\n\t\t\twhile (p <= _n) {\n\t\t\t\tdata[p - 1] += U(x);\n\t\t\t\tp += p & -p;\n\t\t\t}\n\t\t}\n\n\t\tT sum(int l, int r) {\n\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\treturn sum(r) - sum(l);\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<U> data;\n\n\t\tU sum(int r) {\n\t\t\tU s = 0;\n\t\t\twhile (r > 0) {\n\t\t\t\ts += data[r - 1];\n\t\t\t\tr -= r & -r;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\n\ttemplate <class S,\n\t\tS(*op)(S, S),\n\t\tS(*e)(),\n\t\tclass F,\n\t\tS(*mapping)(F, S),\n\t\tF(*composition)(F, F),\n\t\tF(*id)()>\n\t\tstruct lazy_segtree {\n\t\tpublic:\n\t\t\tlazy_segtree() : lazy_segtree(0) {}\n\t\t\tlazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n\t\t\tlazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n\t\t\t\tlog = internal::ceil_pow2(_n);\n\t\t\t\tsize = 1 << log;\n\t\t\t\td = std::vector<S>(2 * size, e());\n\t\t\t\tlz = std::vector<F>(size, id());\n\t\t\t\tfor (int i = 0; i < _n; i++) d[size + i] = v[i];\n\t\t\t\tfor (int i = size - 1; i >= 1; i--) {\n\t\t\t\t\tupdate(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid set(int p, S x) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = x;\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\n\t\t\tS get(int p) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\treturn d[p];\n\t\t\t}\n\n\t\t\tS prod(int l, int r) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return e();\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push(r >> i);\n\t\t\t\t}\n\n\t\t\t\tS sml = e(), smr = e();\n\t\t\t\twhile (l < r) {\n\t\t\t\t\tif (l & 1) sml = op(sml, d[l++]);\n\t\t\t\t\tif (r & 1) smr = op(d[--r], smr);\n\t\t\t\t\tl >>= 1;\n\t\t\t\t\tr >>= 1;\n\t\t\t\t}\n\n\t\t\t\treturn op(sml, smr);\n\t\t\t}\n\n\t\t\tS all_prod() { return d[1]; }\n\n\t\t\tvoid apply(int p, F f) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = mapping(f, d[p]);\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\t\t\tvoid apply(int l, int r, F f) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return;\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tint l2 = l, r2 = r;\n\t\t\t\t\twhile (l < r) {\n\t\t\t\t\t\tif (l & 1) all_apply(l++, f);\n\t\t\t\t\t\tif (r & 1) all_apply(--r, f);\n\t\t\t\t\t\tl >>= 1;\n\t\t\t\t\t\tr >>= 1;\n\t\t\t\t\t}\n\t\t\t\t\tl = l2;\n\t\t\t\t\tr = r2;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 1; i <= log; i++) {\n\t\t\t\t\tif (((l >> i) << i) != l) update(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) update((r - 1) >> i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttemplate <bool (*g)(S)> int max_right(int l) {\n\t\t\t\treturn max_right(l, [](S x) { return g(x); });\n\t\t\t}\n\t\t\ttemplate <class G> int max_right(int l, G g) {\n\t\t\t\tassert(0 <= l && l <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (l == _n) return _n;\n\t\t\t\tl += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(l >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\t\t\tif (!g(op(sm, d[l]))) {\n\t\t\t\t\t\twhile (l < size) {\n\t\t\t\t\t\t\tpush(l);\n\t\t\t\t\t\t\tl = (2 * l);\n\t\t\t\t\t\t\tif (g(op(sm, d[l]))) {\n\t\t\t\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn l - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\tl++;\n\t\t\t\t} while ((l & -l) != l);\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\ttemplate <bool (*g)(S)> int min_left(int r) {\n\t\t\t\treturn min_left(r, [](S x) { return g(x); });\n\t\t\t}\n\t\t\ttemplate <class G> int min_left(int r, G g) {\n\t\t\t\tassert(0 <= r && r <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (r == 0) return 0;\n\t\t\t\tr += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push((r - 1) >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\tr--;\n\t\t\t\t\twhile (r > 1 && (r % 2)) r >>= 1;\n\t\t\t\t\tif (!g(op(d[r], sm))) {\n\t\t\t\t\t\twhile (r < size) {\n\t\t\t\t\t\t\tpush(r);\n\t\t\t\t\t\t\tr = (2 * r + 1);\n\t\t\t\t\t\t\tif (g(op(d[r], sm))) {\n\t\t\t\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn r + 1 - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t} while ((r & -r) != r);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n, size, log;\n\t\t\tstd::vector<S> d;\n\t\t\tstd::vector<F> lz;\n\n\t\t\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\t\t\tvoid all_apply(int k, F f) {\n\t\t\t\td[k] = mapping(f, d[k]);\n\t\t\t\tif (k < size) lz[k] = composition(f, lz[k]);\n\t\t\t}\n\t\t\tvoid push(int k) {\n\t\t\t\tall_apply(2 * k, lz[k]);\n\t\t\t\tall_apply(2 * k + 1, lz[k]);\n\t\t\t\tlz[k] = id();\n\t\t\t}\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\n\tlong long pow_mod(long long x, long long n, int m) {\n\t\tassert(0 <= n && 1 <= m);\n\t\tif (m == 1) return 0;\n\t\tinternal::barrett bt((unsigned int)(m));\n\t\tunsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n\t\twhile (n) {\n\t\t\tif (n & 1) r = bt.mul(r, y);\n\t\t\ty = bt.mul(y, y);\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn r;\n\t}\n\n\tlong long inv_mod(long long x, long long m) {\n\t\tassert(1 <= m);\n\t\tauto z = internal::inv_gcd(x, m);\n\t\tassert(z.first == 1);\n\t\treturn z.second;\n\t}\n\n\tstd::pair<long long, long long> crt(const std::vector<long long>& r,\n\t\tconst std::vector<long long>& m) {\n\t\tassert(r.size() == m.size());\n\t\tint n = int(r.size());\n\t\tlong long r0 = 0, m0 = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(1 <= m[i]);\n\t\t\tlong long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n\t\t\tif (m0 < m1) {\n\t\t\t\tstd::swap(r0, r1);\n\t\t\t\tstd::swap(m0, m1);\n\t\t\t}\n\t\t\tif (m0 % m1 == 0) {\n\t\t\t\tif (r0 % m1 != r1) return { 0, 0 };\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\tlong long g, im;\n\t\t\tstd::tie(g, im) = internal::inv_gcd(m0, m1);\n\n\t\t\tlong long u1 = (m1 / g);\n\t\t\tif ((r1 - r0) % g) return { 0, 0 };\n\n\t\t\tlong long x = (r1 - r0) / g % u1 * im % u1;\n\n\t\t\tr0 += x * m0;\n\t\t\tm0 *= u1;  // -> lcm(m0, m1)\n\t\t\tif (r0 < 0) r0 += m0;\n\t\t}\n\t\treturn { r0, m0 };\n\t}\n\n\tlong long floor_sum(long long n, long long m, long long a, long long b) {\n\t\tlong long ans = 0;\n\t\tif (a >= m) {\n\t\t\tans += (n - 1) * n * (a / m) / 2;\n\t\t\ta %= m;\n\t\t}\n\t\tif (b >= m) {\n\t\t\tans += n * (b / m);\n\t\t\tb %= m;\n\t\t}\n\n\t\tlong long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n\t\tif (y_max == 0) return ans;\n\t\tans += (n - (x_max + a - 1) / a) * y_max;\n\t\tans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n\t\treturn ans;\n\t}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\ttemplate <class T> struct simple_queue {\n\t\t\tstd::vector<T> payload;\n\t\t\tint pos = 0;\n\t\t\tvoid reserve(int n) { payload.reserve(n); }\n\t\t\tint size() const { return int(payload.size()) - pos; }\n\t\t\tbool empty() const { return pos == int(payload.size()); }\n\t\t\tvoid push(const T& t) { payload.push_back(t); }\n\t\t\tT& front() { return payload[pos]; }\n\t\t\tvoid clear() {\n\t\t\t\tpayload.clear();\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\tvoid pop() { pos++; }\n\t\t};\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class Cap> struct mf_graph {\n\tpublic:\n\t\tmf_graph() : _n(0) {}\n\t\tmf_graph(int n) : _n(n), g(n) {}\n\n\t\tint add_edge(int from, int to, Cap cap) {\n\t\t\tassert(0 <= from && from < _n);\n\t\t\tassert(0 <= to && to < _n);\n\t\t\tassert(0 <= cap);\n\t\t\tint m = int(pos.size());\n\t\t\tpos.push_back({ from, int(g[from].size()) });\n\t\t\tg[from].push_back(_edge{ to, int(g[to].size()), cap });\n\t\t\tg[to].push_back(_edge{ from, int(g[from].size()) - 1, 0 });\n\t\t\treturn m;\n\t\t}\n\n\t\tstruct edge {\n\t\t\tint from, to;\n\t\t\tCap cap, flow;\n\t\t};\n\n\t\tedge get_edge(int i) {\n\t\t\tint m = int(pos.size());\n\t\t\tassert(0 <= i && i < m);\n\t\t\tauto _e = g[pos[i].first][pos[i].second];\n\t\t\tauto _re = g[_e.to][_e.rev];\n\t\t\treturn edge{ pos[i].first, _e.to, _e.cap + _re.cap, _re.cap };\n\t\t}\n\t\tstd::vector<edge> edges() {\n\t\t\tint m = int(pos.size());\n\t\t\tstd::vector<edge> result;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tresult.push_back(get_edge(i));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvoid change_edge(int i, Cap new_cap, Cap new_flow) {\n\t\t\tint m = int(pos.size());\n\t\t\tassert(0 <= i && i < m);\n\t\t\tassert(0 <= new_flow && new_flow <= new_cap);\n\t\t\tauto& _e = g[pos[i].first][pos[i].second];\n\t\t\tauto& _re = g[_e.to][_e.rev];\n\t\t\t_e.cap = new_cap - new_flow;\n\t\t\t_re.cap = new_flow;\n\t\t}\n\n\t\tCap flow(int s, int t) {\n\t\t\treturn flow(s, t, std::numeric_limits<Cap>::max());\n\t\t}\n\t\tCap flow(int s, int t, Cap flow_limit) {\n\t\t\tassert(0 <= s && s < _n);\n\t\t\tassert(0 <= t && t < _n);\n\n\t\t\tstd::vector<int> level(_n), iter(_n);\n\t\t\tinternal::simple_queue<int> que;\n\n\t\t\tauto bfs = [&]() {\n\t\t\t\tstd::fill(level.begin(), level.end(), -1);\n\t\t\t\tlevel[s] = 0;\n\t\t\t\tque.clear();\n\t\t\t\tque.push(s);\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\tint v = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tfor (auto e : g[v]) {\n\t\t\t\t\t\tif (e.cap == 0 || level[e.to] >= 0) continue;\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tif (e.to == t) return;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tauto dfs = [&](auto self, int v, Cap up) {\n\t\t\t\tif (v == s) return up;\n\t\t\t\tCap res = 0;\n\t\t\t\tint level_v = level[v];\n\t\t\t\tfor (int& i = iter[v]; i < int(g[v].size()); i++) {\n\t\t\t\t\t_edge& e = g[v][i];\n\t\t\t\t\tif (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n\t\t\t\t\tCap d =\n\t\t\t\t\t\tself(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n\t\t\t\t\tif (d <= 0) continue;\n\t\t\t\t\tg[v][i].cap += d;\n\t\t\t\t\tg[e.to][e.rev].cap -= d;\n\t\t\t\t\tres += d;\n\t\t\t\t\tif (res == up) break;\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t};\n\n\t\t\tCap flow = 0;\n\t\t\twhile (flow < flow_limit) {\n\t\t\t\tbfs();\n\t\t\t\tif (level[t] == -1) break;\n\t\t\t\tstd::fill(iter.begin(), iter.end(), 0);\n\t\t\t\twhile (flow < flow_limit) {\n\t\t\t\t\tCap f = dfs(dfs, t, flow_limit - flow);\n\t\t\t\t\tif (!f) break;\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\n\t\tstd::vector<bool> min_cut(int s) {\n\t\t\tstd::vector<bool> visited(_n);\n\t\t\tinternal::simple_queue<int> que;\n\t\t\tque.push(s);\n\t\t\twhile (!que.empty()) {\n\t\t\t\tint p = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tvisited[p] = true;\n\t\t\t\tfor (auto e : g[p]) {\n\t\t\t\t\tif (e.cap && !visited[e.to]) {\n\t\t\t\t\t\tvisited[e.to] = true;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn visited;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\t\tstruct _edge {\n\t\t\tint to, rev;\n\t\t\tCap cap;\n\t\t};\n\t\tstd::vector<std::pair<int, int>> pos;\n\t\tstd::vector<std::vector<_edge>> g;\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class Cap, class Cost> struct mcf_graph {\n\tpublic:\n\t\tmcf_graph() {}\n\t\tmcf_graph(int n) : _n(n), g(n) {}\n\n\t\tint add_edge(int from, int to, Cap cap, Cost cost) {\n\t\t\tassert(0 <= from && from < _n);\n\t\t\tassert(0 <= to && to < _n);\n\t\t\tint m = int(pos.size());\n\t\t\tpos.push_back({ from, int(g[from].size()) });\n\t\t\tg[from].push_back(_edge{ to, int(g[to].size()), cap, cost });\n\t\t\tg[to].push_back(_edge{ from, int(g[from].size()) - 1, 0, -cost });\n\t\t\treturn m;\n\t\t}\n\n\t\tstruct edge {\n\t\t\tint from, to;\n\t\t\tCap cap, flow;\n\t\t\tCost cost;\n\t\t};\n\n\t\tedge get_edge(int i) {\n\t\t\tint m = int(pos.size());\n\t\t\tassert(0 <= i && i < m);\n\t\t\tauto _e = g[pos[i].first][pos[i].second];\n\t\t\tauto _re = g[_e.to][_e.rev];\n\t\t\treturn edge{\n\t\t\t\tpos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n\t\t\t};\n\t\t}\n\t\tstd::vector<edge> edges() {\n\t\t\tint m = int(pos.size());\n\t\t\tstd::vector<edge> result(m);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tresult[i] = get_edge(i);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tstd::pair<Cap, Cost> flow(int s, int t) {\n\t\t\treturn flow(s, t, std::numeric_limits<Cap>::max());\n\t\t}\n\t\tstd::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n\t\t\treturn slope(s, t, flow_limit).back();\n\t\t}\n\t\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n\t\t\treturn slope(s, t, std::numeric_limits<Cap>::max());\n\t\t}\n\t\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n\t\t\tassert(0 <= s && s < _n);\n\t\t\tassert(0 <= t && t < _n);\n\t\t\tassert(s != t);\n\t\t\tstd::vector<Cost> dual(_n, 0), dist(_n);\n\t\t\tstd::vector<int> pv(_n), pe(_n);\n\t\t\tstd::vector<bool> vis(_n);\n\t\t\tauto dual_ref = [&]() {\n\t\t\t\tstd::fill(dist.begin(), dist.end(),\n\t\t\t\t\tstd::numeric_limits<Cost>::max());\n\t\t\t\tstd::fill(pv.begin(), pv.end(), -1);\n\t\t\t\tstd::fill(pe.begin(), pe.end(), -1);\n\t\t\t\tstd::fill(vis.begin(), vis.end(), false);\n\t\t\t\tstruct Q {\n\t\t\t\t\tCost key;\n\t\t\t\t\tint to;\n\t\t\t\t\tbool operator<(Q r) const { return key > r.key; }\n\t\t\t\t};\n\t\t\t\tstd::priority_queue<Q> que;\n\t\t\t\tdist[s] = 0;\n\t\t\t\tque.push(Q{ 0, s });\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\tint v = que.top().to;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (vis[v]) continue;\n\t\t\t\t\tvis[v] = true;\n\t\t\t\t\tif (v == t) break;\n\t\t\t\t\tfor (int i = 0; i < int(g[v].size()); i++) {\n\t\t\t\t\t\tauto e = g[v][i];\n\t\t\t\t\t\tif (vis[e.to] || !e.cap) continue;\n\t\t\t\t\t\tCost cost = e.cost - dual[e.to] + dual[v];\n\t\t\t\t\t\tif (dist[e.to] - dist[v] > cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + cost;\n\t\t\t\t\t\t\tpv[e.to] = v;\n\t\t\t\t\t\t\tpe[e.to] = i;\n\t\t\t\t\t\t\tque.push(Q{ dist[e.to], e.to });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!vis[t]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tfor (int v = 0; v < _n; v++) {\n\t\t\t\t\tif (!vis[v]) continue;\n\t\t\t\t\tdual[v] -= dist[t] - dist[v];\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\t\t\tCap flow = 0;\n\t\t\tCost cost = 0, prev_cost = -1;\n\t\t\tstd::vector<std::pair<Cap, Cost>> result;\n\t\t\tresult.push_back({ flow, cost });\n\t\t\twhile (flow < flow_limit) {\n\t\t\t\tif (!dual_ref()) break;\n\t\t\t\tCap c = flow_limit - flow;\n\t\t\t\tfor (int v = t; v != s; v = pv[v]) {\n\t\t\t\t\tc = std::min(c, g[pv[v]][pe[v]].cap);\n\t\t\t\t}\n\t\t\t\tfor (int v = t; v != s; v = pv[v]) {\n\t\t\t\t\tauto& e = g[pv[v]][pe[v]];\n\t\t\t\t\te.cap -= c;\n\t\t\t\t\tg[v][e.rev].cap += c;\n\t\t\t\t}\n\t\t\t\tCost d = -dual[s];\n\t\t\t\tflow += c;\n\t\t\t\tcost += c * d;\n\t\t\t\tif (prev_cost == d) {\n\t\t\t\t\tresult.pop_back();\n\t\t\t\t}\n\t\t\t\tresult.push_back({ flow, cost });\n\t\t\t\tprev_cost = cost;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\tprivate:\n\t\tint _n;\n\n\t\tstruct _edge {\n\t\t\tint to, rev;\n\t\t\tCap cap;\n\t\t\tCost cost;\n\t\t};\n\n\t\tstd::vector<std::pair<int, int>> pos;\n\t\tstd::vector<std::vector<_edge>> g;\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n\tnamespace internal {\n\n\t\ttemplate <class E> struct csr {\n\t\t\tstd::vector<int> start;\n\t\t\tstd::vector<E> elist;\n\t\t\tcsr(int n, const std::vector<std::pair<int, E>>& edges)\n\t\t\t\t: start(n + 1), elist(edges.size()) {\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\tstart[e.first + 1]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tstart[i] += start[i - 1];\n\t\t\t\t}\n\t\t\t\tauto counter = start;\n\t\t\t\tfor (auto e : edges) {\n\t\t\t\t\telist[counter[e.first]++] = e.second;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tstruct scc_graph {\n\t\tpublic:\n\t\t\tscc_graph(int n) : _n(n) {}\n\n\t\t\tint num_vertices() { return _n; }\n\n\t\t\tvoid add_edge(int from, int to) { edges.push_back({ from, {to} }); }\n\n\t\t\tstd::pair<int, std::vector<int>> scc_ids() {\n\t\t\t\tauto g = csr<edge>(_n, edges);\n\t\t\t\tint now_ord = 0, group_num = 0;\n\t\t\t\tstd::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n\t\t\t\tvisited.reserve(_n);\n\t\t\t\tauto dfs = [&](auto self, int v) -> void {\n\t\t\t\t\tlow[v] = ord[v] = now_ord++;\n\t\t\t\t\tvisited.push_back(v);\n\t\t\t\t\tfor (int i = g.start[v]; i < g.start[v + 1]; i++) {\n\t\t\t\t\t\tauto to = g.elist[i].to;\n\t\t\t\t\t\tif (ord[to] == -1) {\n\t\t\t\t\t\t\tself(self, to);\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], low[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlow[v] = std::min(low[v], ord[to]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (low[v] == ord[v]) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tint u = visited.back();\n\t\t\t\t\t\t\tvisited.pop_back();\n\t\t\t\t\t\t\tord[u] = _n;\n\t\t\t\t\t\t\tids[u] = group_num;\n\t\t\t\t\t\t\tif (u == v) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroup_num++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tif (ord[i] == -1) dfs(dfs, i);\n\t\t\t\t}\n\t\t\t\tfor (auto& x : ids) {\n\t\t\t\t\tx = group_num - 1 - x;\n\t\t\t\t}\n\t\t\t\treturn { group_num, ids };\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<int>> scc() {\n\t\t\t\tauto ids = scc_ids();\n\t\t\t\tint group_num = ids.first;\n\t\t\t\tstd::vector<int> counts(group_num);\n\t\t\t\tfor (auto x : ids.second) counts[x]++;\n\t\t\t\tstd::vector<std::vector<int>> groups(ids.first);\n\t\t\t\tfor (int i = 0; i < group_num; i++) {\n\t\t\t\t\tgroups[i].reserve(counts[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\t\tgroups[ids.second[i]].push_back(i);\n\t\t\t\t}\n\t\t\t\treturn groups;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n;\n\t\t\tstruct edge {\n\t\t\t\tint to;\n\t\t\t};\n\t\t\tstd::vector<std::pair<int, edge>> edges;\n\t\t};\n\n\t}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\tstruct scc_graph {\n\tpublic:\n\t\tscc_graph() : internal(0) {}\n\t\tscc_graph(int n) : internal(n) {}\n\n\t\tvoid add_edge(int from, int to) {\n\t\t\tint n = internal.num_vertices();\n\t\t\tassert(0 <= from && from < n);\n\t\t\tassert(0 <= to && to < n);\n\t\t\tinternal.add_edge(from, to);\n\t\t}\n\n\t\tstd::vector<std::vector<int>> scc() { return internal.scc(); }\n\n\tprivate:\n\t\tinternal::scc_graph internal;\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\ttemplate <class S, S(*op)(S, S), S(*e)()> struct segtree {\n\tpublic:\n\t\tsegtree() : segtree(0) {}\n\t\tsegtree(int n) : segtree(std::vector<S>(n, e())) {}\n\t\tsegtree(const std::vector<S>& v) : _n(int(v.size())) {\n\t\t\tlog = internal::ceil_pow2(_n);\n\t\t\tsize = 1 << log;\n\t\t\td = std::vector<S>(2 * size, e());\n\t\t\tfor (int i = 0; i < _n; i++) d[size + i] = v[i];\n\t\t\tfor (int i = size - 1; i >= 1; i--) {\n\t\t\t\tupdate(i);\n\t\t\t}\n\t\t}\n\n\t\tvoid set(int p, S x) {\n\t\t\tassert(0 <= p && p < _n);\n\t\t\tp += size;\n\t\t\td[p] = x;\n\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t}\n\n\t\tS get(int p) {\n\t\t\tassert(0 <= p && p < _n);\n\t\t\treturn d[p + size];\n\t\t}\n\n\t\tS prod(int l, int r) {\n\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\tS sml = e(), smr = e();\n\t\t\tl += size;\n\t\t\tr += size;\n\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1) sml = op(sml, d[l++]);\n\t\t\t\tif (r & 1) smr = op(d[--r], smr);\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\treturn op(sml, smr);\n\t\t}\n\n\t\tS all_prod() { return d[1]; }\n\n\t\ttemplate <bool (*f)(S)> int max_right(int l) {\n\t\t\treturn max_right(l, [](S x) { return f(x); });\n\t\t}\n\t\ttemplate <class F> int max_right(int l, F f) {\n\t\t\tassert(0 <= l && l <= _n);\n\t\t\tassert(f(e()));\n\t\t\tif (l == _n) return _n;\n\t\t\tl += size;\n\t\t\tS sm = e();\n\t\t\tdo {\n\t\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\t\tif (!f(op(sm, d[l]))) {\n\t\t\t\t\twhile (l < size) {\n\t\t\t\t\t\tl = (2 * l);\n\t\t\t\t\t\tif (f(op(sm, d[l]))) {\n\t\t\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn l - size;\n\t\t\t\t}\n\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\tl++;\n\t\t\t} while ((l & -l) != l);\n\t\t\treturn _n;\n\t\t}\n\n\t\ttemplate <bool (*f)(S)> int min_left(int r) {\n\t\t\treturn min_left(r, [](S x) { return f(x); });\n\t\t}\n\t\ttemplate <class F> int min_left(int r, F f) {\n\t\t\tassert(0 <= r && r <= _n);\n\t\t\tassert(f(e()));\n\t\t\tif (r == 0) return 0;\n\t\t\tr += size;\n\t\t\tS sm = e();\n\t\t\tdo {\n\t\t\t\tr--;\n\t\t\t\twhile (r > 1 && (r % 2)) r >>= 1;\n\t\t\t\tif (!f(op(d[r], sm))) {\n\t\t\t\t\twhile (r < size) {\n\t\t\t\t\t\tr = (2 * r + 1);\n\t\t\t\t\t\tif (f(op(d[r], sm))) {\n\t\t\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn r + 1 - size;\n\t\t\t\t}\n\t\t\t\tsm = op(d[r], sm);\n\t\t\t} while ((r & -r) != r);\n\t\t\treturn 0;\n\t\t}\n\n\tprivate:\n\t\tint _n, size, log;\n\t\tstd::vector<S> d;\n\n\t\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\t};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\n\tnamespace internal {\n\n\t\tstd::vector<int> sa_naive(const std::vector<int>& s) {\n\t\t\tint n = int(s.size());\n\t\t\tstd::vector<int> sa(n);\n\t\t\tstd::iota(sa.begin(), sa.end(), 0);\n\t\t\tstd::sort(sa.begin(), sa.end(), [&](int l, int r) {\n\t\t\t\tif (l == r) return false;\n\t\t\t\twhile (l < n && r < n) {\n\t\t\t\t\tif (s[l] != s[r]) return s[l] < s[r];\n\t\t\t\t\tl++;\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\treturn l == n;\n\t\t\t\t});\n\t\t\treturn sa;\n\t\t}\n\n\t\tstd::vector<int> sa_doubling(const std::vector<int>& s) {\n\t\t\tint n = int(s.size());\n\t\t\tstd::vector<int> sa(n), rnk = s, tmp(n);\n\t\t\tstd::iota(sa.begin(), sa.end(), 0);\n\t\t\tfor (int k = 1; k < n; k *= 2) {\n\t\t\t\tauto cmp = [&](int x, int y) {\n\t\t\t\t\tif (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n\t\t\t\t\tint rx = x + k < n ? rnk[x + k] : -1;\n\t\t\t\t\tint ry = y + k < n ? rnk[y + k] : -1;\n\t\t\t\t\treturn rx < ry;\n\t\t\t\t};\n\t\t\t\tstd::sort(sa.begin(), sa.end(), cmp);\n\t\t\t\ttmp[sa[0]] = 0;\n\t\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t\t}\n\t\t\t\tstd::swap(tmp, rnk);\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\n\t\ttemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n\t\tstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n\t\t\tint n = int(s.size());\n\t\t\tif (n == 0) return {};\n\t\t\tif (n == 1) return { 0 };\n\t\t\tif (n == 2) {\n\t\t\t\tif (s[0] < s[1]) {\n\t\t\t\t\treturn { 0, 1 };\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn { 1, 0 };\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n < THRESHOLD_NAIVE) {\n\t\t\t\treturn sa_naive(s);\n\t\t\t}\n\t\t\tif (n < THRESHOLD_DOUBLING) {\n\t\t\t\treturn sa_doubling(s);\n\t\t\t}\n\n\t\t\tstd::vector<int> sa(n);\n\t\t\tstd::vector<bool> ls(n);\n\t\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\t\tls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n\t\t\t}\n\t\t\tstd::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!ls[i]) {\n\t\t\t\t\tsum_s[s[i]]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum_l[s[i] + 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= upper; i++) {\n\t\t\t\tsum_s[i] += sum_l[i];\n\t\t\t\tif (i < upper) sum_l[i + 1] += sum_s[i];\n\t\t\t}\n\n\t\t\tauto induce = [&](const std::vector<int>& lms) {\n\t\t\t\tstd::fill(sa.begin(), sa.end(), -1);\n\t\t\t\tstd::vector<int> buf(upper + 1);\n\t\t\t\tstd::copy(sum_s.begin(), sum_s.end(), buf.begin());\n\t\t\t\tfor (auto d : lms) {\n\t\t\t\t\tif (d == n) continue;\n\t\t\t\t\tsa[buf[s[d]]++] = d;\n\t\t\t\t}\n\t\t\t\tstd::copy(sum_l.begin(), sum_l.end(), buf.begin());\n\t\t\t\tsa[buf[s[n - 1]]++] = n - 1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint v = sa[i];\n\t\t\t\t\tif (v >= 1 && !ls[v - 1]) {\n\t\t\t\t\t\tsa[buf[s[v - 1]]++] = v - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstd::copy(sum_l.begin(), sum_l.end(), buf.begin());\n\t\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\t\tint v = sa[i];\n\t\t\t\t\tif (v >= 1 && ls[v - 1]) {\n\t\t\t\t\t\tsa[--buf[s[v - 1] + 1]] = v - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tstd::vector<int> lms_map(n + 1, -1);\n\t\t\tint m = 0;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (!ls[i - 1] && ls[i]) {\n\t\t\t\t\tlms_map[i] = m++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::vector<int> lms;\n\t\t\tlms.reserve(m);\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (!ls[i - 1] && ls[i]) {\n\t\t\t\t\tlms.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinduce(lms);\n\n\t\t\tif (m) {\n\t\t\t\tstd::vector<int> sorted_lms;\n\t\t\t\tsorted_lms.reserve(m);\n\t\t\t\tfor (int v : sa) {\n\t\t\t\t\tif (lms_map[v] != -1) sorted_lms.push_back(v);\n\t\t\t\t}\n\t\t\t\tstd::vector<int> rec_s(m);\n\t\t\t\tint rec_upper = 0;\n\t\t\t\trec_s[lms_map[sorted_lms[0]]] = 0;\n\t\t\t\tfor (int i = 1; i < m; i++) {\n\t\t\t\t\tint l = sorted_lms[i - 1], r = sorted_lms[i];\n\t\t\t\t\tint end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n\t\t\t\t\tint end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n\t\t\t\t\tbool same = true;\n\t\t\t\t\tif (end_l - l != end_r - r) {\n\t\t\t\t\t\tsame = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twhile (l < end_l) {\n\t\t\t\t\t\t\tif (s[l] != s[r]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (l == n || s[l] != s[r]) same = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!same) rec_upper++;\n\t\t\t\t\trec_s[lms_map[sorted_lms[i]]] = rec_upper;\n\t\t\t\t}\n\n\t\t\t\tauto rec_sa =\n\t\t\t\t\tsa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tsorted_lms[i] = lms[rec_sa[i]];\n\t\t\t\t}\n\t\t\t\tinduce(sorted_lms);\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\n\t}  // namespace internal\n\n\tstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n\t\tassert(0 <= upper);\n\t\tfor (int d : s) {\n\t\t\tassert(0 <= d && d <= upper);\n\t\t}\n\t\tauto sa = internal::sa_is(s, upper);\n\t\treturn sa;\n\t}\n\n\ttemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> idx(n);\n\t\tiota(idx.begin(), idx.end(), 0);\n\t\tsort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n\t\tstd::vector<int> s2(n);\n\t\tint now = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i && s[idx[i - 1]] != s[idx[i]]) now++;\n\t\t\ts2[idx[i]] = now;\n\t\t}\n\t\treturn internal::sa_is(s2, now);\n\t}\n\n\tstd::vector<int> suffix_array(const std::string& s) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> s2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn internal::sa_is(s2, 255);\n\t}\n\n\ttemplate <class T>\n\tstd::vector<int> lcp_array(const std::vector<T>& s,\n\t\tconst std::vector<int>& sa) {\n\t\tint n = int(s.size());\n\t\tassert(n >= 1);\n\t\tstd::vector<int> rnk(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\trnk[sa[i]] = i;\n\t\t}\n\t\tstd::vector<int> lcp(n - 1);\n\t\tint h = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (h > 0) h--;\n\t\t\tif (rnk[i] == 0) continue;\n\t\t\tint j = sa[rnk[i] - 1];\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (s[j + h] != s[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rnk[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n\n\tstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> s2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn lcp_array(s2, sa);\n\t}\n\n\ttemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n\t\tint n = int(s.size());\n\t\tif (n == 0) return {};\n\t\tstd::vector<int> z(n);\n\t\tz[0] = 0;\n\t\tfor (int i = 1, j = 0; i < n; i++) {\n\t\t\tint& k = z[i];\n\t\t\tk = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n\t\t\twhile (i + k < n && s[k] == s[i + k]) k++;\n\t\t\tif (j + z[j] < i + z[i]) j = i;\n\t\t}\n\t\tz[0] = n;\n\t\treturn z;\n\t}\n\n\tstd::vector<int> z_algorithm(const std::string& s) {\n\t\tint n = int(s.size());\n\t\tstd::vector<int> s2(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts2[i] = s[i];\n\t\t}\n\t\treturn z_algorithm(s2);\n\t}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n\tstruct two_sat {\n\tpublic:\n\t\ttwo_sat() : _n(0), scc(0) {}\n\t\ttwo_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n\t\tvoid add_clause(int i, bool f, int j, bool g) {\n\t\t\tassert(0 <= i && i < _n);\n\t\t\tassert(0 <= j && j < _n);\n\t\t\tscc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n\t\t\tscc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n\t\t}\n\t\tbool satisfiable() {\n\t\t\tauto id = scc.scc_ids().second;\n\t\t\tfor (int i = 0; i < _n; i++) {\n\t\t\t\tif (id[2 * i] == id[2 * i + 1]) return false;\n\t\t\t\t_answer[i] = id[2 * i] < id[2 * i + 1];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tstd::vector<bool> answer() { return _answer; }\n\n\tprivate:\n\t\tint _n;\n\t\tstd::vector<bool> _answer;\n\t\tinternal::scc_graph scc;\n\t};\n\n}  // namespace atcoder\n\n/*\nend of AtCoder STL\n*/\n\n#define int ll\nusing namespace std;\nusing namespace atcoder;\ntypedef string::const_iterator State;\n#define eps 1e-8L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n};\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n#define int ll\nusing mint = modint998244353;\nmint cnter[400000];\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\tmint ans = 0;\n\tvector<mint> hogea;\n\thogea.push_back(1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\thogea.push_back(hogea.back() * (k - 1) / k);\n\t}\n\treverse(ALL(hogea));\n\tfenwick_tree<mint> seg(n + 10);\n\tfenwick_tree<mint> cnter(n + 10);\n\tvector<pair<int,int>> inputs;\n\tREP(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tinputs.push_back(mp(a, i));\n\t}\n\tsort(ALL(inputs));\n\tREP(i, inputs.size()) {\n\t\tint itr = max(inputs[i].second - k + 1, 0LL);\n\t\tmint hoge = seg.sum(0, itr);\n\t\thoge /= hogea[itr];\n\t\t//hoge = cnter.sum(0, itr + 1) - hoge;\n\t\tans += hoge / 2;\n\t\tseg.add(itr, hogea[itr]);\n\t\tcnter.add(itr, 1);\n\t}\n\tans += cnter.sum(0,1) * (cnter.sum(0,1) - 1) / 4;\n\treverse(ALL(inputs));\n\tseg = fenwick_tree<mint>(n + 10);\n\tcnter = fenwick_tree<mint>(n + 10);\n\tREP(i, inputs.size()) {\n\t\tint itr = max(inputs[i].second - k + 1, 0LL);\n\t\tmint hoge = seg.sum(0, itr);\n\t\thoge /= hogea[itr];\n\t\tans += hoge / 2 + (cnter.sum(0, itr) - hoge);\n\t\tseg.add(itr, hogea[itr]);\n\t\tcnter.add(itr, 1);\n\t}\n\t//cout << ans << endl;\n\tcout << ans.val() << endl;\n}\n#undef int\nint main() {\n\tinit();\n\tint t = 1;\n\t//cin >> t;\n\tREP(tea, t) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <cstdio>\n#include <cstdint>\n#define rep(i, n) for(int i=0; i<n; ++i)\nusing namespace std;\n\nconst unsigned int mod = 998244353;\n\nstruct mint {\n  unsigned int x;\n  mint():x(0) {}\n  mint(int64_t x_) {\n    int64_t v = int64_t(x_ % mod);\n    if(v < 0) v += mod;\n    x = (unsigned int)v;\n  }\n  static mint row(int v) {\n    mint v_;\n    v_.x = v;\n    return v_;\n  }\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    u_int64_t z = x;\n    z *= a.x;\n    x = (unsigned int)(z % mod);\n    return *this;\n  }\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  friend bool operator==(const mint &a, const mint &b) {return a.x == b.x;}\n  friend bool operator!=(const mint &a, const mint &b) {return a.x != b.x;}\n  mint &operator++() {\n    x++;\n    if(x == mod) x = 0;\n    return *this;\n  }\n  mint &operator--() {\n    if(x == 0) x = mod;\n    x--;\n    return *this;\n  }\n  mint operator++(int) {\n    mint result = *this;\n    ++*this;\n    return result;\n  }\n  mint operator--(int) {\n    mint result = *this;\n    --*this;\n    return result;\n  }\n  mint pow(int64_t t) const {\n    mint x_ = *this, r = 1;\n    while(t) {\n      if(t&1) r *= x_;\n      x_ *= x_;\n      t >>= 1;\n    }\n    return r;\n  }\n  //for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) {return mint(*this) /= a;}\n};\n\n#define N 200100\n\n//head\n\nint n, k;\nint p[N];\nmint u[N], _u[N];\nmint ans;\nmint bit1[N], bit2[N];\nvoid add(int i, mint x, mint *bit) {\n  while(i <= n) {\n    bit[i] += x;\n    i += i&-i;\n  }\n}\nmint sum(int i, mint *bit) {\n  mint res;\n  while(i) {\n    res += bit[i];\n    i &= i-1;\n  }\n  return res;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  rep(i, n) scanf(\"%d\", p+i);\n  const mint g = mint(k-1)/k, _g = g.inv(), gg = mint(2).inv();\n  u[0] = _u[0] = 1;\n  rep(i, n-1) {\n    if(i < k-1) {\n      u[i+1] = u[i];\n      _u[i+1] = _u[i];\n    }\n    else {\n      u[i+1] = u[i]*g;\n      _u[i+1] = _u[i]*_g;\n    }\n  }\n  rep(i, n) {\n    ans += sum(p[i], bit1)*gg*u[i];\n    ans -= sum(p[i], bit2)-i;\n    ans -= (sum(n, bit1)-sum(p[i], bit1))*gg*u[i];\n    add(p[i], _u[i], bit1);\n    add(p[i], 1, bit2);\n  }\n  printf(\"%d\\n\", ans.x);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#include<bits/extc++.h>\n#define int long long\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define rep(i,n) for (int i=0;i<(int)(n);++i)\n#define rep1(i,n) for (int i=1;i<=(int)(n);++i)\n#define range(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define F first\n#define S second\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> VL;\n\n\nll power(ll u,ll v,ll mod){\n    ll ret=1,t=u%mod;\n    while (v){\n        if (v&1) ret=t*ret%mod;\n        t=t*t%mod, v>>=1;\n    }\n    return ret%mod;\n}\n \n/*\n计算gcd(a,b)并找寻ax+by=gcd(a,b)的一组解\nret=exgcd(a,b,x,y); \n*/\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if (b){\n        ll d=exgcd(b,a%b,y,x);\n        return y-=a/b*x, d;\n    }\n    return x=1,y=0,a;\n}\n \n/*\n计算x=a(mod m), x=b(mod n)的一组解，若无解返回-1\nret=crt(a,m,b,n);\n*/\nll crt(ll a,ll m,ll b,ll n){\n    if (n>m) swap(a,b), swap(n,m);\n    ll x,y,g=exgcd(m,n,x,y);\n    if ((b-a)%g) return -1;\n    x=(b-a)%n*x%n/g*m+a;\n    return x<0?x+m*n/g:x;\n}\n \n/*\n生成<=n的质数\ngen_prime<5000>(ret);\n*/\n \nvoid gen_prime(int n,vi &ret){\n    vector<bool> p;\n    p.resize(n+1,1);\n    p[0]=p[1]=0;\n    for (int i=4;i<=n;i+=2) p[i]=0;\n    for (int i=3;i*i<=n;i+=2){\n        if (p[i]){\n            for (int j=i*i;j<=n;j+=2*i){\n                p[j]=0;\n            }\n        }\n    }\n    for (int i=2;i<=n;++i){\n        if (p[i]) ret.pb(i);\n    }\n}\n \n/*\n生成<=n的phi\ngen_phi<5000>(ret);\n*/\nvoid gen_phi(int n,vi &phi){\n    phi.resize(n+1);\n    for (int i=0;i<=n;++i) phi[i]=i&1?i:i/2;\n    for (int i=3;i<=n;i+=2){\n        if (phi[i]==i){\n            for (int j=i;j<=n;j+=i) phi[j]-=phi[j]/i;\n        }\n    }\n}\n \n/*\n支持更高的快速幂操作\nexpower.mod_pow(a,b,mod);\n*/\n \nstruct expower{\n    ull mod_mul(ull a,ull b,ull M) {\n        ll ret=a*b-M*ull(ld(a)* ld(b)/ld(M));\n        return ret+M*(ret<0)-M*(ret>=(ll)M);\n    }\n    ull mod_pow(ull b,ull e,ull mod) {\n        ull ans=1;\n        for (; e; b=mod_mul(b,b,mod), e/=2)\n            if (e&1) ans=mod_mul(ans,b,mod);\n        return ans%mod;\n    }\n}expower;\n \n/*\nMiller-Rubin素数判别\nis_prime(n);\n*/\nbool is_prime(ull n){ \n    if (n<2||n%6%4!=1) return n-2<2;\n    ull A[]={2,325,9375,28178,450775,9780504,1795265022},\n    s=__builtin_ctzll(n-1), d = n >> s;\n    for (auto a:A){\n        ull p=expower.mod_pow(a,d,n),i=s;\n        while (p!=1&&p!=n-1&&a%n&&i--)\n            p=expower.mod_mul(p,p,n);\n        if (p!=n-1&&i!=s) return 0;\n    }\n    return 1;\n}\n \n/*\n素因数分解\nret=factorization(n);\n*/\null pollard(ull n){\n    auto f=[n](ull x){return (expower.mod_mul(x,x,n)+1)%n;};\n    if (!(n&1)) return 2;\n    for (ull i=2;;i++){\n        ull x=i,y=f(x),p;\n        while ((p=__gcd(n+y-x,n))==1)\n            x=f(x),y=f(f(y));\n        if (p!=n) return p;\n    }\n}\n \nvector<ull> factorization(ull n){\n    if (n==1) return {};\n    if (is_prime(n)) return {n};\n    ull x=pollard(n);\n    auto l=factorization(x),r=factorization(n/x);\n    l.insert(l.end(),range(r));\n    return l;\n}\n \nstruct DSU{\n    //insert info.\n    vector<int> p;\n    DSU(int n){\n        p.resize(n+1);\n        for (int i=1;i<=n;++i) p[i]=i;\n    }\n    int find(int u){\n        if (p[u]==u) return u;\n        return p[u]=find(find(p[u]));\n    } \n    bool unite(int u,int v){\n        int pu=find(u), pv=find(v);\n        if (pu!=pv){\n            p[pu]=pv;\n        }\n        return pu!=pv;\n    }\n};\n \n/* (u,v,w) */\ntemplate<class T> vector<tuple<int,int,T> > MST(int n,vector<tuple<int,int,T> >g){\n    vector<tuple<int,int,T> > ret;\n    ret.clear();\n    DSU dsu(n);\n    auto cmp=[&](tuple<int,int,T> x,tuple<int,int,T> y){\n        int ux,uy,vx,vy;\n        T wx,wy;\n        tie(ux,vx,wx)=x, tie(uy,vy,wy)=y;\n        return wx<wy;\n    };\n    sort(range(g),cmp);\n    for (auto c:g){\n        int u,v;\n        T w;\n        tie(u,v,w)=c;\n        if(dsu.unite(u,v)) ret.push_back(c);\n    }\n    return ret;\n}\n \ntemplate<int n,class T>\nstruct SegmentTree{\n    typedef struct{\n        T lz,mx,mn,sum;\n    }Node;\n    vector<Node> tree;\n    SegmentTree(){\n        tree.resize((n+7)<<2);\n    }  \n    void pushup(int num){\n        tree[num].mx=max(tree[num<<1].mx,tree[num<<1|1].mx);\n        tree[num].mn=min(tree[num<<1].mn,tree[num<<1|1].mn);\n        tree[num].sum=tree[num<<1].sum+tree[num<<1|1].sum;\n    }\n    void pushdown(int num,int l,int r,int md){\n        if (tree[num].lz){\n            tree[num<<1].mx+=tree[num].lz;\n            tree[num<<1|1].mx+=tree[num].lz;\n            tree[num<<1].mn+=tree[num].lz;\n            tree[num<<1|1].mn+=tree[num].lz;\n            tree[num<<1].sum+=tree[num].lz*(md-l+1);\n            tree[num<<1|1].sum+=tree[num].lz*(r-md);\n            tree[num<<1].lz+=tree[num].lz;\n            tree[num<<1|1].lz+=tree[num].lz;\n            tree[num].lz=0;\n        }\n    }\n    void update1(int num,int l,int r,int L,int R,T val){\n        if (L<=l&&r<=R){\n            tree[num].mx+=val;\n            tree[num].mn+=val;\n            tree[num].sum+=val*(r-l+1);\n            tree[num].lz+=val;\n            return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=L) update1(num<<1,l,md,L,R,val);\n        if (md<R) update1(num<<1|1,md+1,r,L,R,val);\n        pushup(num);\n    }\n    tuple<T,T,T> query1(int num,int l,int r,int L,int R){\n        if (L<=l&&r<=R){\n            return {tree[num].mn,tree[num].mx,tree[num].sum};\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        if (md>=R){\n            return query1(num<<1,l,md,L,R);\n        }\n        else{\n            if (md<L){\n                return query1(num<<1|1,md+1,r,L,R);\n            }\n            else{\n                tuple<T,T,T> ret1=query1(num<<1,l,md,L,R), ret2=query1(num<<1|1,md+1,r,L,R);\n                T a,b,c,d,e,f;\n                tie(a,b,c)=ret1, tie(d,e,f)=ret2;\n                return {min(a,d),max(b,e),c+f};\n            }\n        } \n    }\n    void update(int L,int R,int w){\n        update1(1,1,n,L,R,w);\n    }\n    tuple<T,T,T> query(int L,int R){\n        return query1(1,1,n,L,R);\n    }\n    void debug1(int num,int l,int r){\n        if (l==r){\n            cout<<tree[num].mn<<\" \"; return;\n        }\n        int md=(l+r)>>1;\n        pushdown(num,l,r,md);\n        debug1(num<<1,l,md);\n         debug1(num<<1|1,md+1,r);        \n    }\n    void debug(){\n        debug1(1,1,n);\n        cout<<endl;\n    }\n};\n \nstruct XORBasis{\n    int n;\n    vector<ull> p;\n    vector<ull> ans;\n    XORBasis(int k):n(k){\n        p.resize(k+1);\n    }\n    void rebuilt(){\n        ans.clear();\n        for (int i=0;i<=n;++i){\n            if (p[i]) ans.push_back(p[i]);\n        }\n    }\n    void insert(ull u){\n        for (int i=n;i>=0;--i){\n            if (u&(1ull<<i)){\n                if (p[i]) u^=p[i];\n                else{\n                    p[i]=u;\n                    for (int j=i-1;j>=0;--j){\n                        if (p[i]&(1ull<<j)) p[i]^=p[j];\n                    }\n                    for (int j=i+1;j<=n;++j){\n                        if (p[j]&(1ull<<i)) p[j]^=p[i];\n                    }\n                    break;\n                }\n            }\n        }\n        rebuilt();\n    }\n    bool check(ull u){\n        for (int i=n;i>-1;--i){\n            if (u&(1ull<<i)) u^=p[i];\n        }\n        return (u==0);\n    }\n    ull kth(ull t){ // the k-th smallest, excluding 0.\n        if (t>=(1ull<<sz(ans))) return -1;\n        ull ret=0;\n        for (int i=0;i<sz(ans);++i){\n            if (t&(1ull<<i)) ret^=ans[i];\n        }\n        return ret;\n    }\n    ull total(){\n        return (1ull<<sz(ans));\n    }\n};\n \n \nvi pi(const string& s) {\n\tvi p(sz(s));\n\tfor (int i=1;i<=sz(s);++i) {\n\t\tint g = p[i-1];\n\t\twhile (g && s[i] != s[g]) g = p[g-1];\n\t\tp[i] = g + (s[i] == s[g]);\n\t}\n\treturn p;\n}\n \nvi match(const string& s, const string& pat) {\n\tvi p = pi(pat + '\\0' + s), res;\n\tfor(int i=sz(p)-sz(s);i<=sz(p);++i)\n\t\tif (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));\n\treturn res;\n}\n \n \nstruct AhoCorasick {\n\tenum {alpha = 26, first = 'a'};\n\tstruct Node {\n\t\t// (nmatches is optional)\n\t\tint back, next[alpha], start = -1, end = -1;\n        ll nmatches = 0;\n\t\tNode(int v) { memset(next, v, sizeof(next)); }\n\t};\n\tvector<Node> N;\n\tvector<int> backp;\n\tvoid insert(string& s, int j,ll val) {\n\t\tassert(!s.empty());\n\t\tint n = 0;\n\t\tfor(auto c:s) {\n\t\t\tint& m = N[n].next[c - first];\n\t\t\tif (m == -1) { n = m = sz(N); N.emplace_back(-1); }\n\t\t\telse n = m;\n\t\t}\n\t\tif (N[n].end == -1) N[n].start = j;\n\t\tbackp.push_back(N[n].end);\n\t\tN[n].end = j;\n\t\tN[n].nmatches+=val;\n\t}\n\tAhoCorasick(vector<string>& pat,vi val) {\n\t\tN.emplace_back(-1);\n\t\tfor (int i=0;i<sz(pat);++i) insert(pat[i], i, val[i]);\n\t\tN[0].back = sz(N);\n\t\tN.emplace_back(0);\n \n\t\tqueue<int> q;\n\t\tfor (q.push(0); !q.empty(); q.pop()) {\n\t\t\tint n = q.front(), prev = N[n].back;\n\t\t\tfor (int i=0;i<alpha;++i) {\n\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];\n\t\t\t\tif (ed == -1) ed = y;\n\t\t\t\telse {\n\t\t\t\t\tN[ed].back = y;\n\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])\n\t\t\t\t\t\t= N[y].end;\n\t\t\t\t\tN[ed].nmatches += N[y].nmatches;\n\t\t\t\t\tq.push(ed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvi find(string& word,ll& ans) {\n\t\tint n = 0;\n\t\tvi res;\n\t\tfor(auto c:word) {\n\t\t\tn = N[n].next[c - first];\n\t\t\tres.push_back(N[n].end);\n\t\t\tans += N[n].nmatches;\n\t\t}\n\t\treturn res;\n\t}\n\tvector<vi> findAll(vector<string>& pat, string word) {\n\t\tll ans=0;\n        vi r = find(word,ans);\n\t\tvector<vi> res(sz(word));\n\t\tfor (int i=0;i<sz(word);++i) {\n\t\t\tint ind = r[i];\n\t\t\twhile (ind != -1) {\n\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);\n\t\t\t\tind = backp[ind];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n \nstruct HLD{\n    int n,cnt=0;\n    vector<vi> G;\n    vi par,dep,siz,son,top,dfn,rk; \n    //父亲节点，深度，子树大小，重子节点，重链头部，dfs序，dfs序对应的节点编号\n    HLD(vector<vi> g,int root=1):n(sz(g)),G(g),par(n+7),dep(n+7),siz(n+7,1),son(n+7,-1),top(n+7),dfn(n+7),rk(n+7){\n        dep[0]=-1, dfs1(root,0), dfs2(root,0,root);\n    }\n    void dfs1(int u,int p){\n        for (auto c:G[u]){\n            if (c==p) continue;\n            dep[c]=dep[u]+1, par[c]=u;\n            dfs1(c,u);\n            siz[u]+=siz[c];\n            if (son[u]==-1||siz[son[u]]<siz[c]) son[u]=c;\n        }\n    }\n    void dfs2(int u,int p,int tp){\n        top[u]=tp;\n        dfn[u]=++cnt;\n        rk[cnt]=u;\n        if (son[u]==-1) return;\n        dfs2(son[u],u,tp);\n        for (auto c:G[u]){\n            if (c==p||c==son[u]) continue;\n            dfs2(c,u,c);\n        }\n    }\n    int lca(int u,int v){\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                u=par[top[u]];\n            }\n            else{\n                v=par[top[v]];\n            }\n        }\n        return dep[u]>dep[v]?v:u;\n    }\n    vector<pii> find_seg(int u,int v){\n        vector<pii> ft,bk,res;\n        ft.clear(), bk.clear(), res.clear();\n//        cout<<top[u]<<\" \"<<top[v]<<endl;\n        while (top[u]!=top[v]){\n            if (dep[top[u]]>dep[top[v]]){\n                ft.pb({u,top[u]});\n                u=par[top[u]];\n            }\n            else{\n                bk.pb({top[v],v});\n                v=par[top[v]];\n            }\n        }\n        ft.pb({u,v});\n        for (int i=0;i<sz(ft);++i) res.pb(ft[i]);\n        for (int i=sz(bk);i>0;--i) res.pb(bk[i-1]);\n        return res;\n    }\n};\n \nstruct BIT{\n    vi C; int n;\n    BIT(int n):n(n){C.resize(n+7,0);}\n    void update(int u,int w){\n        for (;u<=n;u+=u&(-u)) C[u]+=w;\n    }\n    int query(int u){\n        int res=0;\n        for (;u>0;u-=u&(-u)) res+=C[u];\n        return res; \n    }\n};\n\nvi topoSort(const vector<vi>& gr) {\n\tvi indeg(sz(gr)), ret;\n\tfor (auto& li : gr) for (int x : li) indeg[x]++;\n\tqueue<int> q; // use priority queue for lexic. smallest ans.\n\trep(i,sz(gr)) if (indeg[i] == 0) q.push(-i);\n\twhile (!q.empty()) {\n\t\tint i = -q.front(); // top() for priority queue\n\t\tret.push_back(i);\n\t\tq.pop();\n\t\tfor (int x : gr[i])\n\t\t\tif (--indeg[x] == 0) q.push(-x);\n\t}\n\treturn ret;\n}\n\nvi path;\nnamespace Eulerian {\n    const int N = 3, M = 3;\n    int t, n, m, tot, cc, hd[N], nxt[M], to[M], bh[M], vis[M], in[N], out[N], ans[M];\n    void add(int x, int y, int id) {\n        nxt[++tot] = hd[x];\n        hd[x] = tot;\n        to[tot] = y;\n        bh[tot] = id;\n        in[y]++;\n        out[x]++;\n    }\n    void dfs(int x) {\n        for (int i = hd[x]; i; i = hd[x]) {\n            while (i && vis[abs(bh[i])]) i = nxt[i];\n            hd[x] = i;\n            if (!i) break;\n            vis[abs(bh[i])] = 1;\n            dfs(to[i]), ans[++cc] = bh[i];\n        }\n    }\n \n    void init() {\n        memset(hd, 0, sizeof(hd));\n        memset(nxt, 0, sizeof(nxt));\n        memset(to, 0, sizeof(to));\n        memset(bh, 0, sizeof(bh));\n        memset(vis, 0, sizeof(vis));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n        memset(ans, 0, sizeof(ans));\n        t = 1;\n        n = 0;\n        m = 0;\n        tot = 0;\n        cc = 0;\n    }\n    bool solve() {\n        for (int i = 1; i <= n; i++)\n            if ((t == 1 && in[i] & 1)) {\n                return false;\n            }\n        dfs(to[1]);\n        if (cc < m) return false;\n        else {\n            path.clear();\n            for (int i = cc; i >= 1; i--) path.push_back(ans[i]);\n            return true;\n        }\n    }\n} // namespace Eulerian\n\nnamespace FWT{\n    //mod=-1 (no mod)\n    const int mod=-1;\n\n    inline int modadd(int a,int b){\n        a+=b;\n        if (mod==-1) return a;\n        a%=mod, a+=mod, a%=mod;\n        return a;\n    }\n\n    vi OR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j]=modadd(b[j],b[j^(1<<i)]*mode); \n            }\n        }\n        return b;\n    }\n    vi AND(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1) b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]*mode);\n            }\n        }\n        return b;\n    }\n    vi XOR(vi &a,int mode=1){\n        vi b(a);\n        for (int i=0;(1<<i)<sz(a);++i){\n            for (int j=0;j<sz(a);++j){\n                if (j>>i&1){\n                    b[j^(1<<i)]=modadd(b[j^(1<<i)],b[j]);\n                    b[j]=modadd(b[j^(1<<i)],-2*b[j]);\n                    if (mode<0) {\n                        if (mod>0) b[j]=b[j]*power(2,mod-2,mod)%mod, b[j^(1<<i)]=b[j^(1<<i)]*power(2,mod-2,mod)%mod;\n                        else b[j]/=2, b[j^(1<<i)]/=2;\n                    }\n                }\n            }\n        }\n        return b;\n    }\n}\n\nconst int maxn=200007;\nconst int mod=998244353;\n\nint inv(int u){\n    return power(u,mod-2,mod);\n}\nint mult(int u,int v){\n    return u*v%mod;\n}\nint n,k;\nint a[maxn],p[maxn],q[maxn];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin>>n>>k;\n    rep1(i,n) cin>>a[i],p[i]=i;\n    sort(p+1,p+n+1,[&](int u,int v){return a[u]<a[v];});\n    rep1(i,n) q[p[i]]=1;\n    BIT C(n),C0(n);\n    int ans=0,ans0=0;\n    rep1(i,n){\n        C.update(a[i],power(1+inv(k-1),max(0ll,i-k),mod));\n        C0.update(a[i],1);\n        int r=C.query(n)-C.query(a[i]);\n        if (r>0) ans=(ans+mult(r,power(1-inv(k)+mod,max(0ll,i-k),mod)))%mod;\n //       cout<<ans<<endl;\n        ans0=(ans0+C0.query(n)-C0.query(a[i]))%mod;\n    }\n    ans=(ans0-ans+mod)%mod;\n    int tmp=0;\n    tmp=k*(k-1)/2;\n    tmp%=mod;\n    for (int i=1;i<=n-k;++i){\n        tmp=(tmp+mult(k,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    for (int i=1;i<n-k;++i){\n        int w=n-k-i;\n        tmp=(tmp+mult(w,power(1-inv(k)+mod,i,mod)))%mod;\n    }\n    tmp=mult(tmp,inv(2));\n    cout<<((ans+tmp)%mod+mod)%mod;\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 998244353;\n\nint add(int a, int b)\n{\n    a += b;\n    if (a >= MOD)\n    {\n        return a - MOD;\n    }\n    if (a < 0)\n    {\n        return a + MOD;\n    }\n    return a;\n}\n\nint mul(int a, int b)\n{\n    return a * (ll) b % MOD;\n}\n\nint pw(int a, int b)\n{\n    int r = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            r = mul(r, a);\n        }\n        a = mul(a, a);\n        b /= 2;\n    }\n    return r;\n}\n\nint dv(int a, int b)\n{\n    return mul(a, pw(b, MOD - 2));\n}\n\nconst int N = (int) 2e5 + 7;\nint n;\nint k;\nint a[N];\nint enter[N];\nint val;\n\nint prob_swap(int i, int j)\n{\n    /// i < j\n    return dv(pw(val, enter[j] - enter[i]), 2);\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> a[i];\n        enter[i] = max(0, i - k);\n    }\n    val = dv(k - 1, k);\n    int invs = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = i + 1; j <= n; j++)\n        {\n            if (a[i] < a[j])\n            {\n                invs = add(invs, prob_swap(i, j));\n            }\n            else\n            {\n                invs = add(invs, add(1, -prob_swap(i, j)));\n            }\n        }\n    }\n    cout << invs << \"\\n\";\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,n) for (ll i = 0; i < (n); ++i)\n#define RREP(i, n) for (ll i = (n) - 1; i >= 0; --i)\n#define ALL(v) (v).begin(), (v).end()\ntemplate<class T>\nusing reverse_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nusing mint = modint998244353;\n\nstruct S{\n    ll num;\n    mint psum;\n};\nS e(){ return S{0, 0}; }\nS op(S x, S y){ return S{x.num + y.num, x.psum + y.psum}; }\n\nint main(){\n    ll n, k;\n    cin >> n >> k;\n\n    vector<ll> p(n);\n    REP(i, n){\n        cin >> p.at(i);\n        p.at(i)--;\n    }\n\n    const mint q = mint(k - 1) / mint(k);\n    const mint qinv = q.inv();\n\n    // cerr << \"q=\" << q.val() << \", qinv=\" << qinv.val() << endl;\n\n    segtree<S, op, e> st(n);\n\n    mint ans = 0;\n\n    REP(i, n){\n        const ll pi = p.at(i);\n        const ll fi = max(i - k + 1, 0LL);\n\n        const auto sd = st.prod(0, pi);\n        mint tmp1 = q.pow(fi) * sd.psum / 2;\n\n        const auto su = st.prod(pi + 1, n);\n        mint tmp2 = su.num - q.pow(fi) * su.psum / 2;\n\n        mint tmp = tmp1 + tmp2;\n\n        // cerr << \"i=\" << i << \", tmp=\" << tmp.val() << \", tmp1=\" << tmp1.val() << \", tmp2=\" << tmp2.val() << endl;\n        ans += tmp;\n\n        st.set(pi, S{1, qinv.pow(fi)});\n    }\n\n    cout << ans.val() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate <typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate <typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate <typename V, typename T> void ndfill(V &x, const T &val) { x = val; }\ntemplate <typename V, typename T> void ndfill(vector<V> &vec, const T &val) { for (auto &v : vec) ndfill(v, val); }\ntemplate <typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate <typename T> bool chmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate <typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate <typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate <typename T> vector<T> srtunq(vector<T> vec) { sort(vec.begin(), vec.end()), vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto &v : vec) is >> v; return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { os << '['; for (auto v : vec) os << v << ','; os << ']'; return os; }\n#if __cplusplus >= 201703L\ntemplate <typename... T> istream &operator>>(istream &is, tuple<T...> &tpl) { std::apply([&is](auto &&... args) { ((is >> args), ...);}, tpl); return is; }\ntemplate <typename... T> ostream &operator<<(ostream &os, const tuple<T...> &tpl) { std::apply([&os](auto &&... args) { ((os << args << ','), ...);}, tpl); return os; }\n#endif\ntemplate <typename T> ostream &operator<<(ostream &os, const deque<T> &vec) { os << \"deq[\"; for (auto v : vec) os << v << ','; os << ']'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa) { os << '(' << pa.first << ',' << pa.second << ')'; return os; }\ntemplate <typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\ntemplate <typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\n#ifdef HITONANODE_LOCAL\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl\n#else\n#define dbg(x)\n#endif\n\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    static int get_mod() { return mod; }\n    static int get_primitive_root() {\n        static int primitive_root = 0;\n        if (!primitive_root) {\n            primitive_root = [&](){\n                std::set<int> fac;\n                int v = mod - 1;\n                for (lint i = 2; i * i <= v; i++) while (v % i == 0) fac.insert(i), v /= i;\n                if (v > 1) fac.insert(v);\n                for (int g = 1; g < mod; g++) {\n                    bool ok = true;\n                    for (auto i : fac) if (ModInt(g).power((mod - 1) / i) == 1) { ok = false; break; }\n                    if (ok) return g;\n                }\n                return -1;\n            }();\n        }\n        return primitive_root;\n    }\n    int val;\n    constexpr ModInt() : val(0) {}\n    constexpr ModInt &_setval(lint v) { val = (v >= mod ? v - mod : v); return *this; }\n    constexpr ModInt(lint v) { _setval(v % mod + mod); }\n    explicit operator bool() const { return val != 0; }\n    constexpr ModInt operator+(const ModInt &x) const { return ModInt()._setval((lint)val + x.val); }\n    constexpr ModInt operator-(const ModInt &x) const { return ModInt()._setval((lint)val - x.val + mod); }\n    constexpr ModInt operator*(const ModInt &x) const { return ModInt()._setval((lint)val * x.val % mod); }\n    constexpr ModInt operator/(const ModInt &x) const { return ModInt()._setval((lint)val * x.inv() % mod); }\n    constexpr ModInt operator-() const { return ModInt()._setval(mod - val); }\n    constexpr ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    constexpr ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    constexpr ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    constexpr ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    friend constexpr ModInt operator+(lint a, const ModInt &x) { return ModInt()._setval(a % mod + x.val); }\n    friend constexpr ModInt operator-(lint a, const ModInt &x) { return ModInt()._setval(a % mod - x.val + mod); }\n    friend constexpr ModInt operator*(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.val % mod); }\n    friend constexpr ModInt operator/(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.inv() % mod); }\n    constexpr bool operator==(const ModInt &x) const { return val == x.val; }\n    constexpr bool operator!=(const ModInt &x) const { return val != x.val; }\n    bool operator<(const ModInt &x) const { return val < x.val; }  // To use std::map<ModInt, T>\n    friend std::istream &operator>>(std::istream &is, ModInt &x) { lint t; is >> t; x = ModInt(t); return is; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) { os << x.val;  return os; }\n    constexpr lint power(lint n) const {\n        lint ans = 1, tmp = this->val;\n        while (n) {\n            if (n & 1) ans = ans * tmp % mod;\n            tmp = tmp * tmp % mod;\n            n /= 2;\n        }\n        return ans;\n    }\n    constexpr lint inv() const { return this->power(mod - 2); }\n    constexpr ModInt operator^(lint n) const { return ModInt(this->power(n)); }\n    constexpr ModInt &operator^=(lint n) { return *this = *this ^ n; }\n\n    inline ModInt fac() const {\n        static std::vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? ModInt(1) : facs[i - 1] * ModInt(i));\n        return facs[this->val];\n    }\n\n    ModInt doublefac() const {\n        lint k = (this->val + 1) / 2;\n        if (this->val & 1) return ModInt(k * 2).fac() / ModInt(2).power(k) / ModInt(k).fac();\n        else return ModInt(k).fac() * ModInt(2).power(k);\n    }\n\n    ModInt nCr(const ModInt &r) const {\n        if (this->val < r.val) return ModInt(0);\n        return this->fac() / ((*this - r).fac() * r.fac());\n    }\n\n    ModInt sqrt() const {\n        if (val == 0) return 0;\n        if (mod == 2) return val;\n        if (power((mod - 1) / 2) != 1) return 0;\n        ModInt b = 1;\n        while (b.power((mod - 1) / 2) == 1) b += 1;\n        int e = 0, m = mod - 1;\n        while (m % 2 == 0) m >>= 1, e++;\n        ModInt x = power((m - 1) / 2), y = (*this) * x * x;\n        x *= (*this);\n        ModInt z = b.power(m);\n        while (y != 1) {\n            int j = 0;\n            ModInt t = y;\n            while (t != 1) j++, t *= t;\n            z = z.power(1LL << (e - j - 1));\n            x *= z, z *= z, y *= z;\n            e = j;\n        }\n        return ModInt(std::min(x.val, mod - x.val));\n    }\n};\nconstexpr lint MOD = 998244353;\nusing mint = ModInt<MOD>;\n\n// 1-indexed BIT (i : [1, len])\ntemplate <typename T>\nstruct BIT : std::vector<T>\n{\n    BIT(int len = 0) : std::vector<T>(len + 1) {}\n    void reset() { fill(this->begin(), this->end(), 0); }\n    void add(int pos, T v) {\n        while (pos > 0 and pos < (int)this->size()) (*this)[pos] += v, pos += pos & -pos;\n    }\n    T sum(int pos) const { // (0, pos]\n        T res = 0;\n        while (pos > 0) res += (*this)[pos], pos -= pos & -pos;\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const BIT &bit) {\n        T prv = 0;\n        os << '[';\n        for (int i = 1; i < (int)bit.size(); i++) {\n            T now = bit.sum(i);\n            os << now - prv << \",\";\n            prv = now;\n        }\n        os << ']';\n        return os;\n    }\n};\n\nint main()\n{\n    int N, K;\n    cin >> N >> K;\n    vector<int> P(N);\n    cin >> P;\n    mint ret = 0;\n    BIT<mint> bit(N + 1), bitten(N + 1);\n\n    mint coeff = 1;\n    mint inv2 = mint(1) / 2;\n    mint ten0 = 0;\n    mint gensui = mint(K - 1) / K;\n    REP(i, N)\n    {\n        if (i >= K) coeff *= gensui;\n        ret += inv2 * coeff * (bit.sum(P[i]) * 2 - bit.sum(N));\n        dbg(bit);\n        dbg(coeff);\n        dbg(ret);\n        bit.add(P[i], 1 / coeff);\n        bitten.add(P[i], 1);\n        ten0 += bitten.sum(N) - bitten.sum(P[i]);\n    }\n    dbg(ten0);\n    cout << ten0 + ret << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <fstream>\n#include <cmath>\n#include <limits>\n#include <chrono>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\n#include <cassert>\n#include <atcoder/all>\nusing namespace atcoder;\n#pragma warning (disable: 4996)\nusing namespace std;\n\nusing ll = long long;\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nll ll_gcd(ll a, ll b) {\n    if (a < b) return ll_gcd(b, a);\n    ll r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nstruct UnionFind {\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    if (n < 0)return 0;\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nll merge_cnt(vector<ll>& a) {\n    int n = a.size();\n    if (n <= 1) { return 0; }\n\n    ll cnt = 0;\n    vector<ll> b(a.begin(), a.begin() + n / 2);\n    vector<ll> c(a.begin() + n / 2, a.end());\n\n    cnt += merge_cnt(b);\n    cnt += merge_cnt(c);\n\n    int ai = 0, bi = 0, ci = 0;\n    while (ai < n) {\n        if (bi < b.size() && (ci == c.size() || b[bi] <= c[ci])) {\n            a[ai++] = b[bi++];\n        }\n        else {\n            cnt += n / 2 - bi;\n            a[ai++] = c[ci++];\n        }\n    }\n    return cnt;\n}\n\n\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\nll op(ll a,ll b) {\n    return (a + b) % 998244353;\n}\n\nll e() {\n    return 0;\n}\n\nint main() {\n    ll n, k;\n    cin >> n >> k;\n    vector<ll> x(k);\n    vector<ll> z(n-k);\n    vector<pair<ll, ll>> d(n-k);\n    for (int i = 0; i < k; i++) {\n        cin >> x[i];\n    }\n    for (int i = 0; i < n-k; i++) {\n        cin >> z[i];\n        d[i].first = z[i];\n        d[i].second = i;\n    }\n    sort(x.begin(), x.end());\n    ll ans = 0;\n    for (int i = 0; i < n - k; i++) {\n        ll r = modpow(k-1, i+1, 998244353) * modinv(modpow(k, i+1, 998244353),998244353) % 998244353*modinv(2,998244353);\n        ll ok = -1;\n        ll ng = k;\n        while (ng - ok > 1) {\n            ll mid = (ok + ng) / 2;\n            if (x[mid] < z[i])ok = mid;\n            else ng = mid;\n        }\n        ok++;\n        ans += (ok * r + (k - ok) * (998244354 - r)) % 998244353;\n        ans %= 998244353;\n    }\n    sort(d.begin(), d.end());\n    segtree<ll, op, e> t(n-k);\n    segtree<ll, op, e> f(n - k);\n    ll h = 1;\n    for (int i = 0; i < n-k; i++) {\n        t.set(i,h);\n        h *= (k-1) * modinv(k,998244353) % 998244353;\n        h %= 998244353;\n    }\n    for (int i = 0; i < n - k; i++) {\n        ll g = t.prod(d[i].second+1, n-k);\n        ans += g * modinv(t.get(d[i].second), 998244353) % 998244353*modinv(2,998244353) % 998244353;\n        t.set(d[i].second, 0);\n        ans %= 998244353;\n    }\n    reverse(d.begin(), d.end());\n    for (int i = 0; i < n - k; i++) {\n        t.set(i, h);\n        h *= (k-1) * modinv(k, 998244353) % 998244353;\n        h %= 998244353;\n    }\n    for (int i = 0; i < n - k; i++) {\n        ll g = t.prod(d[i].second+1, n-k);\n        ans += n-k-d[i].second-1+998244353-(g * modinv(t.get(d[i].second), 998244353) % 998244353 * modinv(2, 998244353) % 998244353);\n        ans += f.prod(d[i].second + 1, n - k);\n        t.set(d[i].second, 0);\n        f.set(d[i].second, 998244352);\n        \n        ans %= 998244353;\n    }\n    ans += k * (k-1)/2 % 998244353 * modinv(2,998244353) % 998244353;\n    ans %= 998244353;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include \"bits/stdc++.h\"\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n///////////////////////////////////////////////////////////////////////\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n\n/*\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\nvoid mod_print(ll k){\n    ll P=50000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        \n        if(abs(x)<=P||x+P>=i_7){\n            if(x+P>=i_7){\n                x-=i_7;\n            }\n            cout<<x<<\"/\"<<y<<endl;\n            //cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n */\n/*\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n*/\ntypedef long double dd;\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\ndd EPS=1E-12;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#define endl \"\\n\"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！\n#define all(c) c.begin(),c.end()\ntypedef vector<ll> vl;\n\n\nusing mint = modint998244353;\n//using mint = modint1000000007;\n//using mint=modint;\n//using mint=static_modint<100>;\n//////////////////////////\n\n//using mint=dd;\nusing S=mint;\nmint op(mint a,mint b){\n    return a+b;\n}\nmint e(){\n    return 0;\n}\n\nint main(){fastio\n    ll n,k;cin>>n>>k;\n    ll p[n];\n    rep(i,0,n-1){\n        cin>>p[i];p[i]--;\n    }\n    \n    segtree<mint,op,e>seg(n);\n    ll N=400005;\n  //  ll N=100;\n    mint po[N];//(K-1)/Kのi乗\n    mint po2[N];//逆\n    po[0]=1;\n    rep(i,1,N-1){\n        po[i]=po[i-1]*(k-1)/k;\n    }\n    rep(i,0,N-1){\n        po2[i]=1/po[i];\n    }\n    \n    mint ans1=0;\n    rep(i,0,n-1){\n        if(i<=k-1){\n            seg.set(p[i],po[N-(k-1)]);\n        }else{\n            mint val=seg.prod(0,p[i]);\n            val*=po2[N-i];\n            ans1+=val;\n            seg.set(p[i],po[N-i]);\n        }\n    }\n    mint ans2=(mint)k*(k-1)/4;\n    mint ans3=0;\n    rep(i,1,n-k){\n        mint val=n-k-i;\n        val+=k;//n==kでおかしいかも？？\n        ans3+=val/2*po[i];\n    }\n    mint ans4=0;\n    segtree<S,op,e>s2(n);\n    rep(i,0,n-1){\n        if(i>=k)ans4+=s2.prod(p[i],n);\n        s2.set(p[i],1);\n    }\n    \n    mint ans=ans1+ans2-ans3+ans4;\n    /*\n    cout<<ans1<<\" \"<<ans2<<\" \"<<ans3<<\" \"<<ans4<<endl;\n    cout<<ans<<endl;\n    \n     */\n   // cout<<ans1.val()<<\" \"<<ans2.val()<<\" \"<<ans3.val()<<\" \"<<ans4.val()<<endl;\n    cout<<ans.val()<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<atcoder/all>\nusing namespace atcoder;\n\n#include<bits/stdc++.h>\n#include<array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing MLL = modint998244353;\nMLL RSQ_e() { return 0; }\nMLL RSQ_f(MLL a, MLL b) { return a + b; }\nusing RSQ = segtree<MLL, RSQ_f, RSQ_e>;\n\nint main() {\n    int N, K; scanf(\"%d%d\", &N, &K);\n\n    MLL invK = MLL(K).inv();\n    vector<MLL> f(N), invf(N);\n    rep(i, K) f[i] = 1;\n    for (int i = K; i < N; i++) f[i] = f[i - 1] * (K - 1) * invK;\n    rep(i, N) invf[i] = f[i].inv();\n\n    RSQ Q1(N), Q2(N), Q3(N);\n    MLL inv2 = MLL(2).inv();\n    int I[200000]; rep(i, N) { int a; scanf(\"%d\", &a); a--; I[a] = i; }\n    MLL ans = 0;\n    rep(i, N) {\n        ans += Q1.prod(0, I[i]) * f[I[i]] * inv2;\n        ans -= Q2.prod(I[i] + 1, N) * invf[I[i]] * inv2;\n        ans += Q3.prod(I[i] + 1, N);\n        Q1.set(I[i], invf[I[i]]);\n        Q2.set(I[i], f[I[i]]);\n        Q3.set(I[i], 1);\n    }\n    printf(\"%u\\n\", ans.val());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> pippi;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<61;\nint iinf=1<<30;\ndouble pi=3.14159265358979323846;\ndouble pi2=pi/2.0;\ndouble eps=1e-8;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n//#define endl \"\\n\"\nint dh[4]={1,0,-1,0};\nint dw[4]={0,1,0,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<int,int,custom_hash>\nll gcd(ll a,ll b){\n    if(a<0)a=-a;\n    if(b<0)b=-b;\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\n\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\n\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n#include <utility>\nnamespace atcoder {\nnamespace internal {\n\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n   \n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n   \n    unsigned int umod() const { return _m; }\n   \n    unsigned int mul(unsigned int a, unsigned int b) const {\n        \n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n    \n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;\n        \n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n   \n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n#include <algorithm>\n#include <utility>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n    int num_vertices() { return _n; }\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n    \n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n}\n}\n#endif\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\nnamespace atcoder {\nnamespace internal {\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n#else\ntemplate <class T> using is_integral = typename std::is_integral<T>;\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n#endif\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n}\n}\n#endif\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nnamespace atcoder {\nnamespace internal {\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n}\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n    unsigned int val() const { return _v; }\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\nnamespace internal {\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n}\n}\n#endif\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_e[30];\n    if (first) {\n        first = false;\n        mint es[30], ies[30];\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            \n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n    static bool first = true;\n    static mint sum_ie[30];\n    if (first) {\n        first = false;\n        mint es[30], ies[30];\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            \n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    static constexpr unsigned long long MOD1 = 754974721;\n    static constexpr unsigned long long MOD2 = 167772161;\n    static constexpr unsigned long long MOD3 = 469762049;\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        \n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n    return c;\n}\n}\n#endif\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n  private:\n    int _n;\n    \n    std::vector<int> parent_or_size;\n};\n}\n#endif\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n    void change(int p,T x){\n        add(p,x-data[p]);\n    }\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n  private:\n    int _n;\n    std::vector<U> data;\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\nstruct fenwickd{\nprivate:\n    ll u;\n    vector<double> bit;\npublic:\n    fenwickd(ll n){\n        u=1;while(u<n)u*=2;\n        bit.resize(u+10,0);\n        \n    }\n    void add(ll n,double x){\n        ll i=n;\n        bit[i]+=x;\n        //bit[i]%=mod;\n        while(i<u){\n            i+=i&(-i);\n            bit[i]+=x;\n            //bit[i]%=mod;\n        }\n\n    }\n    void change(ll n,double x){\n        add(n,x-bit[n]);\n    }\n    double sum(ll n){\n        ll i=n;\n        double ret=0;\n        while(i>0){\n            ret+=bit[i];\n            i-=i&(-i);\n            //ret%=mod;\n        }\n        return ret;\n    }\n    ll lb(double w){\n        if(w<=0)return 0;\n        ll x=0;\n        for(ll k=u;k>0;k/=2){\n            if(x+k<=u&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n};\n//vector<BIT> b(26,n+1);\n}\n#endif\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n        l += size;\n        r += size;\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n}\n#endif\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\nnamespace atcoder {\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    \n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        \n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n        long long u1 = (m1 / g);\n        \n        if ((r1 - r0) % g) return {0, 0};\n        \n        long long x = (r1 - r0) / g % u1 * im % u1;\n        \n        r0 += x * m0;\n        m0 *= u1;\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n}\n#endif\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}\n#endif\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\nnamespace atcoder {\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n       \n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                \n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    \n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                \n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n}\n#endif\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n  private:\n    internal::scc_graph internal;\n};\n}\n#endif\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <vector>\nnamespace atcoder {\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n    S all_prod() { return d[1]; }\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n}\n#endif\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\nnamespace atcoder {\nnamespace internal {\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n    induce(lms);\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n}\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\ntemplate <class T> std::vector<int> z_algo(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\nstd::vector<int> z_algo(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algo(s2);\n}\n}\n#endif\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n#include <cassert>\n#include <vector>\nnamespace atcoder {\n\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n    void add(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satis() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n}\n#endif\nusing namespace atcoder;\n//dsu d(n) d.merge d.same d.leader d.size vector<vector<int>> d.groups()\n//fenwick_tree<ll> fw(n) fw.add(p,x) fw.sum(l,r) [l,r)\n// pll crt(vector<ll> r,vector<ll> m)   x≡y (modz) {y,z}\n// floor_sum(n,m,a,b) Σi=0:i=n-1 floor((a*i+b)/m) O(log)\n// mf_graph<int/ll> graph(n) int graph.add_edge(from,to,cap) (the number of edge) graph.flow(s,t)\n//graph.flow(s,t,flow_limit) if(allcap==1) O(min(n^(2/3)m,m^(3/2)) else O(mnn)\n//graph.change_cap(i,new_cap,new_flow) (can change)\n//mf_graph<cap>::edge graph.get_edge(i) from,to,cap,flow\n//vector<mf_graph<cap>::edge> graph.edges()\n//mcf_graph<cap,cost> graph(n) int graph.add_edge(from,to,cap,cost) (the number of edge)\n//pair<cap,cost> graph.flow(s,t,(flow_limit)) vector<pair<cap,cost>> graph.slope(s,t) ??\n//O(FV^2)or O(FElogV)\n// using mint=static_modint<mod> or modint998244353; int x.val();\n//scc_graph g(n) g.add_edge(from,to) vector<vector<int>> v=g.scc();\n//vector<ll> convolution<prime>(vector<ll> a,vector<ll> b)\n//vector<ll> convolution_ll(vector<ll> a,vector<ll> b) no mod\n//two_sat ts(n) ts.add(i,bool f,j,bool g)\n//bool ts.satis() vector<bool> ts.answer()\n//vector<int> suffix_array(s) suffix_array<int>(vector<int> s)\n//vector<int> lcp_array(or <int>)(s or vector<int> s,vector<int> sa)\n// vector<int> z_algo(or <int>)(s or vector<int> s)\n//segtree<S,op,e> seg(n or vector<S> v)\n// seg.set(place,S x) S seg.get(place) S seg.prod(l,r) op(a[l],...,a[r-1])\n//S seg.all_prod() op(a[0],...,a[n-1])\n//int seg.max_right<f>(l) define bool f(S x) output one r binary search\n//int seg.min_left<f>(r)\n// ST...op,e(),(f)\n//lazy_segtree<S,op,e,F,mapping,composition,id> seg(n or vector<T> v);\n// set get prod all_prod max_right min_left\n// seg.apply(place,T x) a[p]=op(a[p],x) seg.apply(l,r,T x) l~r-1 a[i]=op(a[i],x)\nusing mint=static_modint<998244353>;\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n  ll n,k;cin>>n>>k;\n  ll a[n];vector<pll> v;\n  rep(i,0,n){cin>>a[i];v.push_back({a[i],i});}\n    fenwick_tree<mint> fw(n),fw2(n);\nsort(v.begin(),v.end(),greater<pll>());\n mint ans=0;\n  mint l=k-1;\n  (l/=k);\nrep(i,0,n){\n    ll num=v[i].second;\n ll num2=max(num,k-1);\n  ll be=beki(l,num2,mod2);\n  ll be2=gyaku(be,mod2);\n  mint wa=fw.sum(num,n);\n  mint wa2=fw2.sum(0,num);\n  mint bee=be,bee2=be2;\n  ans+=bee*wa2+bee2*wa;\n  fw.add(num,bee);\n  fw2.add(num,ber2);\n  }\n  ans/=2;\n  cout<<ans.val()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\ntemplate<typename T>\nstruct fenwick_tree {\n    int tree_n = 0;\n    T tree_sum = 0;\n    vector<T> tree;\n\n    fenwick_tree(int n = -1) {\n        if (n >= 0)\n            init(n);\n    }\n\n    static int largest_bit(int x) {\n        return x == 0 ? -1 : 31 - __builtin_clz(x);\n    }\n\n    void init(int n) {\n        tree_n = n;\n        tree_sum = 0;\n        tree.assign(tree_n + 1, 0);\n    }\n\n    // O(n) initialization of the Fenwick tree.\n    template<typename T_array>\n    void build(const T_array &initial) {\n        assert(int(initial.size()) == tree_n);\n        tree_sum = 0;\n\n        for (int i = 1; i <= tree_n; i++) {\n            tree[i] = initial[i - 1];\n            tree_sum += initial[i - 1];\n\n            for (int k = (i & -i) >> 1; k > 0; k >>= 1)\n                tree[i] += tree[i - k];\n        }\n    }\n\n    // index is in [0, tree_n).\n    void update(int index, const T &change) {\n        assert(0 <= index && index < tree_n);\n        tree_sum += change;\n\n        for (int i = index + 1; i <= tree_n; i += i & -i)\n            tree[i] += change;\n    }\n\n    // Returns the sum of the range [0, count).\n    T query(int count) const {\n        count = min(count, tree_n);\n        T sum = 0;\n\n        for (int i = count; i > 0; i -= i & -i)\n            sum += tree[i];\n\n        return sum;\n    }\n\n    // Returns the sum of the range [start, tree_n).\n    T query_suffix(int start) const {\n        return tree_sum - query(start);\n    }\n\n    // Returns the sum of the range [a, b).\n    T query(int a, int b) const {\n        return query(b) - query(a);\n    }\n\n    // Returns the element at index a in O(1) amortized across every index. Equivalent to query(a, a + 1).\n    T get(int a) const {\n        assert(0 <= a && a < tree_n);\n        int above = a + 1;\n        T sum = tree[above];\n        above -= above & -above;\n\n        while (a != above) {\n            sum -= tree[a];\n            a -= a & -a;\n        }\n\n        return sum;\n    }\n\n    bool set(int index, T value) {\n        assert(0 <= index && index < tree_n);\n        T current = get(index);\n\n        if (current == value)\n            return false;\n\n        update(index, value - current);\n        return true;\n    }\n\n    // Returns the largest p in `[0, tree_n]` such that `query(p) <= sum`. Returns -1 if no such p exists (`sum < 0`).\n    // Can be used as an ordered set/multiset on indices in `[0, tree_n)` by using the tree as a 0/1 or frequency array:\n    // `set(index, 1)` is equivalent to insert(index). `update(index, +1)` is equivalent to multiset.insert(index).\n    // `set(index, 0)` or `update(index, -1)` are equivalent to erase(index).\n    // `get(index)` provides whether index is present or not, or the count of index (if multiset).\n    // `query(index)` provides the count of elements < index.\n    // `find_last_prefix(k)` finds the k-th smallest element (0-indexed). Returns `tree_n` for `sum >= set.size()`.\n    int find_last_prefix(T sum) const {\n        if (sum < 0)\n            return -1;\n\n        int prefix = 0;\n\n        for (int k = largest_bit(tree_n); k >= 0; k--)\n            if (prefix + (1 << k) <= tree_n && tree[prefix + (1 << k)] <= sum) {\n                prefix += 1 << k;\n                sum -= tree[prefix];\n            }\n\n        return prefix;\n    }\n};\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, K;\n    cin >> N >> K;\n    mod_int R = 1 - mod_int(1) / K;\n    fenwick_tree<mod_int> tree(N), p_tree(N);\n    mod_int total = 0;\n    mod_int pow_sum = 0;\n\n    for (int i = 0; i < N; i++) {\n        int p;\n        cin >> p;\n        p--;\n\n        int start = max(i - (K - 1), 0);\n        mod_int power = R.pow(start);\n        total += power * pow_sum / 2;\n        pow_sum += 1 / power;\n\n        total += tree.query_suffix(p);\n        total -= power * p_tree.query_suffix(p);\n\n        tree.update(p, +1);\n        p_tree.update(p, R.pow(-start));\n    }\n\n    cout << total << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define FORR2(x,y,arr) for(auto& [x,y]:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nint A[202020];\n\nll mo=998244353;\ntemplate<class V, int ME> class BIT_mod {\npublic:\n\tV bit[1<<ME];\n\tBIT_mod(){ZERO(bit);};\n\tV operator()(int e) {ll s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s%mo;}\n\tvoid add(int e,V v) { e++; while(e<=1<<ME) { bit[e-1]+=v; bit[e-1] -= (bit[e-1]>=mo)?mo:0; e+=e&-e;}}\n};\nBIT_mod<ll,20> bt,num;\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;a%=mo;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\tFOR(i,N) cin>>A[i];\n\t\n\tll r2=(mo+1)/2;\n\tll ret=0;\n\tFOR(i,K) {\n\t\tbt.add(A[i],1);\n\t\tnum.add(A[i],1);\n\t}\n\t\n\tret=1LL*K*(K-1)%mo*r2%mo*r2%mo;\n\t\n\tll p=(K-1)*modpow(K)%mo;\n\tll rp=1;\n\tll c=1;\n\tfor(i=K;i<N;i++) {\n\t\tc=c*p%mo;\n\t\t// less\n\t\t(ret+=bt(A[i])*(c*r2%mo))%=mo;\n\t\t// more\n\t\t(ret+=(mo+bt(N)-bt(A[i]))*(mo-c*r2%mo))%=mo;\n\t\t(ret+=(mo+num(N)-num(A[i])))%=mo;\n\t\tbt.add(A[i],modpow(c));\n\t\tnum.add(A[i],1);\n\t}\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005,M=998244353;\nint n,k,p[N],i,a[N],q[N];\nlong long tree[N],m[N],ans[N];\nlong long qpow(long long a,long long b)\n{\n\tlong long s=a,ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*s%M;\n\t\ts=s*s%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid modify(int x,int y)\n{\n\twhile(x<=n)\n\t{\n\t\ttree[x]+=y;\n\t\tx+=-x&x;\n\t}\n}\nint Query(int x)\n{\n\tlong long s=0;\n\twhile(x)\n\t{\n\t\ts+=tree[x];\n\t\tx-=-x&x;\n\t}\n\treturn s%M;\n}\nvoid dfs(int l,int r)\n{\n\tif(l==r)\n\t\treturn;\n\tint mid=l+r>>1,i;\n\tlong long s=0,tot=0;\n\tfor(i=l;i<=mid;++i)\n\t{\n\t\tmodify(p[i],m[i]);\n\t\ttot=(tot+m[i])%M;\n\t}\n\tfor(i=r;i>mid;--i)\n\t{\n\t\tans[i]=(ans[i]+s)%M;\n\t\ts=(s+tot-Query(p[i]))%M;\n\t}\n\tfor(i=l;i<=mid;++i)\n\t\tmodify(p[i],-m[i]);\n\ts=0;\n\tfor(i=mid+1;i<=r;++i)\n\t\tmodify(p[i],1);\n\tfor(i=l;i<=mid;++i)\n\t{\n\t\ts=(s+Query(p[i])*m[i])%M;\n\t\tans[i]=(ans[i]+s)%M;\n\t}\n\tfor(i=mid+1;i<=r;++i)\n\t\tmodify(p[i],-1);\n\tdfs(l,mid);\n\tdfs(mid+1,r);\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&k);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&p[i]);\n\t\tq[p[i]]=i;\n\t}\n\tlong long in=qpow(k,M-2);\n\tlong long iw=in*(k-1)%M;\n\tlong long iiw=qpow(iw,M-2);\n\tfor(i=1;i<=n;++i)\n\t\tm[i]=in*qpow(iw,n-max(i,k))%M;\n\tdfs(1,n);\n\tlong long s=((n-k)*qpow(2,M-2)%M*(k-1)%M+1ll*k*(k-1)/2%M*qpow(2,M-2))%M;\n\tfor(i=n-k;i>=1;--i)\n\t\ts=(s+ans[i+k-1]*qpow(iiw,n-i-k+1))%M;\n\tcout<<(s%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <atcoder/all>\nusing namespace std;\nusing namespace atcoder;\n#define REP(i, n) FOR(i, 0, (n))\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define LAR(a, b) ((a)=max((a),(b)))\n#define SML(a, b) ((a)=min((a),(b)))\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing pii = pair<int, int>;\nusing vpii = vector<pair<int, int>>;\ntemplate<typename T>\nusing pque = priority_queue<T, vector<T>, greater<T>>;\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define ALL(a) (a).begin(), (a).end()\n#ifdef LOCAL_DEBUG\n#define DEBUG(...) printf(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\nusing mint = modint998244353;\n#define N 212345\nint n, k;\nint p[N], pi[N];\nfenwick_tree<mint> s(N), t(N);\nmint kappa;\n\nmint gpsum(mint a, int p, int q){\n\tmint ret = (a.pow(p) - a.pow(q+1)) / (1-a);\n\t// DEBUG(\"gpsum(%d/200000000, %d, %d) = %d/200000000\\n\", (a*200000000).val(), p, q, (ret*200000000).val());\n\treturn ret;\n}\n\n// For test\nint h(int i, int j){\n\tint ret = max(j - (k-1), 0) - max(i - (k-1), 0);\n\t// DEBUG(\"h(%d, %d) = %d\\n\", i, j, ret);\n\treturn ret;\n}\nmint g(int i, int j){\n\tmint ret = kappa.pow(h(i, j)) / 2;\n\t// DEBUG(\"g(%d, %d) = %d/200000000\\n\", i, j, (ret*200000000).val());\n\treturn ret;\n}\n\nmint s1(int i){\n\t// mint ret = 0;\n\t// FOR(j, i+1, n) ret += g(i, j);\n\tif (i < k-1){\n\t\tmint ret2 = ((k-1) - (i+1) + gpsum(kappa, 0, n-k))/2;\n\t\t// DEBUG(\"s1(%d) %d/200000000 %d/200000000\\n\", i, (ret*200000000).val(), (ret2*200000000).val());\n\t\treturn ret2;\n\t} else {\n\t\tmint ret2 = gpsum(kappa, i+1-i, n-1-i) / 2;\n\t\t// DEBUG(\"s1(%d) %d/200000000 %d/200000000\\n\", i, (ret*200000000).val(), (ret2*200000000).val());\n\t\treturn ret2;\n\t}\n\t// return ret;\n}\nmint s2(int i){\n\t// mint ret = 0;\n\t// FOR(j, i+1, n) if(p[i] > p[j]) ret += g(i, j);\n\tif(i < k-1){\n\t\tmint ret2 = t.sum(i+1, n) / 2;\n\t\t// if(ret != ret2)\n\t\t// \tDEBUG(\"s2(%d) %d/200000000 %d/200000000\\n\", i, (ret*200000000).val(), (ret2*200000000).val());\n\t\treturn ret2;\n\t} else {\n\t\tmint ret2 = t.sum(i+1, n) / kappa.pow(i-(k-1)) / 2;\n\t\t// if(ret != ret2)\n\t\t// \tDEBUG(\"s2(%d) %d/200000000 %d/200000000\\n\", i, (ret*200000000).val(), (ret2*200000000).val());\n\t\treturn ret2;\n\t}\n\t// return ret;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tREP(i, n){\n\t\tscanf(\"%d\", p+i);\n\t\tpi[p[i]] = i;\n\t}\n\tkappa = mint(k-1) / k;\n\tmint ans = 0;\n\n\tFOR(pp, 1, n+1){\n\t\tint i = pi[pp];\n\t\tans += s1(i) + s.sum(i, n) - 2 * s2(i);\n\t\ts.add(i, 1);\n\t\tt.add(i, kappa.pow(max(i-(k-1), 0)));\n\t}\n\n\tprintf(\"%d\\n\", ans.val());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include \"bits/stdc++.h\"\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param n `0 <= n`\n// @return minimum non-negative `x` s.t. `n <= 2**x`\nint ceil_pow2(int n) {\n    int x = 0;\n    while ((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\n\n// @param n `1 <= n`\n// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast moduler by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if (_m <= v) v += _m;\n        return v;\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    for (long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n\n    unsigned int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for (int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if (first) {\n        first = false;\n        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for (int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for (int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for (int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for (int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for (int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] =\n                    (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                    inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n    if (std::min(n, m) <= 60) {\n        if (n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(move(a2), move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = leader(parent_or_size[a]);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n};\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push(r >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) break;\n            }\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            while (flow < flow_limit) {\n                Cap f = dfs(dfs, t, flow_limit - flow);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    mcf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n        g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{\n            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n        };\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result(m);\n        for (int i = 0; i < m; i++) {\n            result[i] = get_edge(i);\n        }\n        return result;\n    }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n        std::vector<Cost> dual(_n, 0), dist(_n);\n        std::vector<int> pv(_n), pe(_n);\n        std::vector<bool> vis(_n);\n        auto dual_ref = [&]() {\n            std::fill(dist.begin(), dist.end(),\n                      std::numeric_limits<Cost>::max());\n            std::fill(pv.begin(), pv.end(), -1);\n            std::fill(pe.begin(), pe.end(), -1);\n            std::fill(vis.begin(), vis.end(), false);\n            struct Q {\n                Cost key;\n                int to;\n                bool operator<(Q r) const { return key > r.key; }\n            };\n            std::priority_queue<Q> que;\n            dist[s] = 0;\n            que.push(Q{0, s});\n            while (!que.empty()) {\n                int v = que.top().to;\n                que.pop();\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                for (int i = 0; i < int(g[v].size()); i++) {\n                    auto e = g[v][i];\n                    if (vis[e.to] || !e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual[e.to] + dual[v];\n                    if (dist[e.to] - dist[v] > cost) {\n                        dist[e.to] = dist[v] + cost;\n                        pv[e.to] = v;\n                        pe[e.to] = i;\n                        que.push(Q{dist[e.to], e.to});\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])\n                //         = - shortest(s, t) + dual[t] + shortest(s, v)\n                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C\n                dual[v] -= dist[t] - dist[v];\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost = -1;\n        std::vector<std::pair<Cap, Cost>> result;\n        result.push_back({flow, cost});\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = pv[v]) {\n                c = std::min(c, g[pv[v]][pe[v]].cap);\n            }\n            for (int v = t; v != s; v = pv[v]) {\n                auto& e = g[pv[v]][pe[v]];\n                e.cap -= c;\n                g[v][e.rev].cap += c;\n            }\n            Cost d = -dual[s];\n            flow += c;\n            cost += c * d;\n            if (prev_cost == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost = cost;\n        }\n        return result;\n    }\n\n  private:\n    int _n;\n\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n  public:\n    segtree() : segtree(0) {}\n    segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        log = internal::ceil_pow2(_n);\n        size = 1 << log;\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n///////////////////////////////////////////////////////////////////////\n\nusing namespace std;\nusing namespace atcoder;\ntypedef long long ll;\n\n/*\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\nvoid mod_print(ll k){\n    ll P=50000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        \n        if(abs(x)<=P||x+P>=i_7){\n            if(x+P>=i_7){\n                x-=i_7;\n            }\n            cout<<x<<\"/\"<<y<<endl;\n            //cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n */\n/*\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n*/\ntypedef long double dd;\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\ndd EPS=1E-12;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#define endl \"\\n\"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！\n#define all(c) c.begin(),c.end()\ntypedef vector<ll> vl;\n\n\nusing mint = modint998244353;\n//using mint = modint1000000007;\n//using mint=modint;\n//using mint=static_modint<100>;\n//////////////////////////\n\n//using mint=dd;\nusing S=mint;\nmint op(mint a,mint b){\n    return a+b;\n}\nmint e(){\n    return 0;\n}\n\nint main(){fastio\n    ll n,k;cin>>n>>k;\n    ll p[n];\n    rep(i,0,n-1){\n        cin>>p[i];p[i]--;\n    }\n    \n    segtree<mint,op,e>seg(n);\n  //  ll N=400005;\n    ll N=100;\n    mint po[N];//(K-1)/Kのi乗\n    mint po2[N];//逆\n    po[0]=1;\n    rep(i,1,N-1){\n        po[i]=po[i-1]*(k-1)/k;\n    }\n    rep(i,0,N-1){\n        po2[i]=1/po[i];\n    }\n    \n    mint ans1=0;\n    rep(i,0,n-1){\n        if(i<=k-1){\n            seg.set(p[i],po[N-(k-1)]);\n        }else{\n            mint val=seg.prod(0,p[i]);\n            val*=po2[N-i];\n            ans1+=val;\n            seg.set(p[i],po[N-i]);\n        }\n    }\n    mint ans2=(mint)k*(k-1)/4;\n    mint ans3=0;\n    rep(i,1,n-k){\n        mint val=n-k-i;\n        val+=k;//n==kでおかしいかも？？\n        ans3+=val/2*po[i];\n    }\n    mint ans4=0;\n    segtree<S,op,e>s2(n);\n    rep(i,0,n-1){\n        if(i>=k)ans4+=s2.prod(p[i],n);\n        s2.set(p[i],1);\n    }\n    \n    mint ans=ans1+ans2-ans3+ans4;\n    /*\n    cout<<ans1<<\" \"<<ans2<<\" \"<<ans3<<\" \"<<ans4<<endl;\n    cout<<ans<<endl;\n    \n     */\n   // cout<<ans1.val()<<\" \"<<ans2.val()<<\" \"<<ans3.val()<<\" \"<<ans4.val()<<endl;\n    cout<<ans.val()<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n/*#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#define mp make_pair\n#define pb push_back\n#define pll pair<LL,LL>\n#define pii pair<int,int>\n#define y second\n#define x first\n#define LL long long \n#define sqr(x) ((x)*(x))\n#define pi acosl(-1)\n#define MEM(x) memset(x,0,sizeof(x))\n#define MEMS(x) memset(x,-1,sizeof(x))\nusing namespace std;\n/*\nstruct matrix{\n    LL a[2][2];\n};\nint mod=998244353;\nmatrix operator*(const matrix &a,const matrix &b){\n    matrix c;\n    for(int i = 0;i<2;i++){\n        for(int j = 0;j<2;j++){\n            c.a[i][j]=0;\n        }\n    }\n    for(int i = 0;i<2;i++){\n        for(int j = 0;j<2;j++)[\n            for(int k =0;k<2;k++){\n                c.a[i][j]+=a.a[i][k]*b.a[k][j]%mod;\n            }\n            c.a[i][j]%=mod;\n        ]\n    }\n    return c;\n}\nmatrix f_pow(matrix a,int b){\n    matrix res,tmp=a;\n    res.a[0][0]=res.a[1][1]=1;\n    res.a[0][1]=res.a[1][0]=0;\n    while(b){\n        if(b&1)res=res*tmp;\n        tmp=tmp*tmp;\n        b>>=1;\n    }\n    return res;\n}*/\nconst int mod=998244353;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nLL s[200005];\nLL sum[200005];\nvoid add(LL x,LL k,LL *S){\n   // printf(\"%lld\\n\",x);\n    for(int i = x;i<200005;i+=i&-i){\n        S[i]+=k;\n        S[i]%=mod;\n    }\n    //return res;\n}\nLL query(LL x,LL *S){\n    LL res=0;\n    for(int i = x;i>0;i-=i&-i){\n        res+=S[i];\n    }\n    return res%mod;\n}\nvoid solve(){\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    LL ans=0;\n    LL aa=(k-1)*f_pow(k,mod-2);\n    for(int i = 1;i<=n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        LL q1=query(x-1,s),q2=((query(n,s)-query(x-1,s))%mod+mod)%mod;\n        ans+=(q1+q2)*f_pow(aa,max(i-k,0))%mod*((mod+1)/2)%mod;\n      //  printf(\"%lld %lld %lld %lld\\n\",q1,q2,ans,i-1-query(x,sum));\n        ans+=((i-1-query(x,sum)-q2*f_pow(aa,max(i-k,0)))%mod+mod)%mod;\n        ans%=mod;\n        add(x,1,sum);\n        add(x,f_pow(f_pow(aa,max(i-k,0)),mod-2),s);\n        //printf(\"%lld %lld %lld\\n\",q1,q2,ans);\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main(){\n    int t=1;\n    //scanf(\"%d\",&t);\n    while(t--){\n        solve();\n    }\n}\n/*\n1 6 6\n2 7 4\n3 5 2\n4 3 1\n5 2 5\n6 4 0\n7 1 3\n*/\n/*\n100\n5\n5 4\n4 2\n4 2 3\n5 4 2 3 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: E.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\ntemplate<class T>bool sort2(T &a,T &b){return a>b?swap(a,b),1:0;}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nconst int p=998244353;\nstruct Z{\n\tuint x;\n\tZ(){}\n\tZ(uint a){\n\t\tx=a;\n\t}\n};\ninline uint modp(const uint x){\n\treturn x<p?x:x-p;\n}\ninline Z operator+(const Z x1, const Z x2) { return modp(x1.x+x2.x);}\ninline Z operator-(const Z x1, const Z x2) { return modp(x1.x+p-x2.x);}\ninline Z operator-(const Z x) {return x.x?p-x.x:0;}\ninline Z operator*(const Z x1, const Z x2) { return static_cast<ull>(x1.x)*x2.x%p;}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n}\ninline Z Inv(const Z a){\n\tint x,y;\n\texgcd(p,a.x,x,y);\n\treturn y<0?y+=p:y;\n}\ninline Z operator/(const Z x1, const Z x2) { return x1*Inv(x2);}\n\ninline Z &operator++(Z &x1){x1.x==p-1?x1.x=0:++x1.x;return x1;} \ninline Z &operator--(Z &x1){x1.x?--x1.x:x1.x=p-1;return x1;}\ninline Z &operator+=(Z &x1, const Z x2) { return x1 = x1 + x2; }\ninline Z &operator-=(Z &x1, const Z x2) { return x1 = x1 - x2; }\ninline Z &operator*=(Z &x1, const Z x2) { return x1 = x1 * x2; }\ninline Z &operator/=(Z &x1, const Z x2) { return x1 = x1 / x2; }\ninline Z fpm(Z a,int b){Z c(1);for(;b;b>>=1,a*=a)if(b&1)c*=a;return c;}\nZ inv[200005],invf[200005],fac[200005];\nZ f[200005],pw[200005],ipw[200005];\nint a[200005];\nint n;\nstruct bit{\n\tZ s[200005];\n\tvoid add(int x,Z y){for(;x;x^=x&-x)s[x]+=y;}\n\tZ sum(int x){Z y=0;for(;x<=n;x+=x&-x)y+=s[x];return y;}\n}s1,s2;\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint k;\n\tread(n,k);\t\n\tfor(int i=1;i<=n;++i)read(a[i]);\n\tfac[0]=fac[1]=inv[1]=invf[0]=invf[1]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tfac[i]=fac[i-1]*i;\n\t\tinv[i]=(p-p/i)*inv[p%i];\n\t\tinvf[i]=inv[i]*invf[i-1];\n\t}\n\tf[n]=inv[2];\n\tfor(int i=n-1;i>=k;--i){\n\t\tf[i]=inv[k]+(k-2)*inv[k]*f[i+1];\n\t}\n\tZ ans=Z(k)*(k-1)*inv[2]*f[k];\n\tpw[0]=ipw[0]=1;\n\tfor(int i=1;i<=n;++i)pw[i]=pw[i-1]*(k-1)*inv[k];\n\tfor(int i=1;i<=n;++i)ipw[i]=ipw[i-1]*k*inv[k-1];\n\tZ s(0);\n\tfor(int i=1;i<=k;++i){\n\t\ts+=ipw[k];\n\t\ts1.add(a[i],1);\n\t\ts2.add(a[i],ipw[k]);\n\t}\n\tfor(int i=k+1;i<=n;++i){\n\t\tans+=pw[i]*s*f[i];\n\t\tans+=s1.sum(a[i]+1)-pw[i]*s2.sum(a[i]+1);\n\t\ts1.add(a[i],1);\n\t\ts2.add(a[i],ipw[i]);\n\t\ts+=ipw[i];\n\t}\n\twrite(ans.x,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=200005;\nconst int mod=998244353;\nint n,k,p,ip,ans;\nint a[maxn],pw[maxn],ipw[maxn];\n\nint power(int x,int pow){\n\tint res=1;\n\tfor(;pow;pow>>=1){\n\t\tif(pow&1)res=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t}\n\treturn res;\n}\n\nclass Fenwick{\npublic:\n\tint t[maxn];\n\tvoid add(int v,int val){\n\t\tfor(;v<=n;v+=(v&-v)){\n\t\t\tt[v]+=val;\n\t\t\tif(t[v]>=mod)t[v]-=mod;\n\t\t}\n\t}\n\tint qry(int v){\n\t\tint res=0;\n\t\tfor(;v;v-=(v&-v)){\n\t\t\tres+=t[v];\n\t\t\tif(res>=mod)res-=mod;\n\t\t}\n\t\treturn res;\n\t}\n}Cnt,Sum;\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tans=1LL*(n-k)*(k-1)%mod*(mod+1)/2%mod;\n\tans=(ans+1LL*k*(k-1)%mod*power(4,mod-2))%mod;\n\tp=1LL*(k-1)*power(k,mod-2)%mod;\n\tip=power(p,mod-2);\n\tpw[0]=ipw[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tpw[i]=1LL*pw[i-1]*p%mod,ipw[i]=1LL*ipw[i-1]*ip%mod;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=n-1;i>=k;i--){\n\t\tCnt.add(a[i+1],1);\n\t\tSum.add(a[i+1],pw[i+1]);\n\t\tans=(ans+Cnt.qry(a[i]))%mod;\n\t\tans=(ans+1LL*(mod-Sum.qry(a[i]))*ipw[i])%mod;\n\t}\n\tfor(int i=k-1;i>=1;i--){\n\t\tans=(ans+Cnt.qry(a[i]))%mod;\n\t\tans=(ans+1LL*(mod-Sum.qry(a[i]))*ipw[k])%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\nconst mod_int INV2 = mod_int(2).inv();\n\nmod_int INV1H, INV1H2;\n\nint N, K;\nmod_int inv_K, H;\nvector<mod_int> H_pow;\n\nstruct segment_change {\n    mod_int h_add;\n\n    segment_change(mod_int _h_add = 0) : h_add(_h_add) {}\n\n    void reset() {\n        h_add = 0;\n    }\n\n    bool has_change() const {\n        return h_add != 0;\n    }\n\n    // Return the combined result of applying this segment change followed by `other`.\n    segment_change combine(const segment_change &other) const {\n        return segment_change(h_add + other.h_add);\n    }\n};\n\nstruct segment {\n    mod_int sum, h_sum;\n    int length = 0;\n\n    segment(mod_int _sum = 0, mod_int _h_sum = 0, int _length = 0) : sum(_sum), h_sum(_h_sum), length(_length) {}\n\n    void apply(int _length, const segment_change &change) {\n        // dbg(length, _length);\n        assert(length <= _length);\n\n        if (change.h_add != 0) {\n            sum += change.h_add * (1 - H_pow[length]) * INV1H;\n            h_sum += change.h_add * (1 - H_pow[2 * length]) * INV1H2;\n        }\n    }\n\n    void join(const segment &other) {\n        sum += other.sum;\n        h_sum += H_pow[length] * other.h_sum;\n        length += other.length;\n    }\n\n    void join(const segment &a, const segment &b) {\n        *this = a;\n        join(b);\n    }\n};\n\npair<int, int> right_half[32];\n\nstruct seg_tree {\n    int tree_n = 0;\n    vector<segment> tree;\n    vector<segment_change> changes;\n\n    seg_tree(int n = -1) {\n        if (n >= 0)\n            init(n);\n    }\n\n    void init(int n) {\n        tree_n = 1;\n\n        while (tree_n < n)\n            tree_n *= 2;\n\n        tree.assign(2 * tree_n, segment());\n        changes.assign(tree_n, segment_change());\n    }\n\n    // Builds our tree from an array in O(n).\n    void build(const vector<segment> &initial) {\n        int n = int(initial.size());\n        init(n);\n        assert(n <= tree_n);\n\n        for (int i = 0; i < n; i++)\n            tree[tree_n + i] = initial[i];\n\n        for (int position = tree_n - 1; position > 0; position--)\n            tree[position].join(tree[2 * position], tree[2 * position + 1]);\n    }\n\n    void apply_and_combine(int position, int length, const segment_change &change) {\n        tree[position].apply(length, change);\n        if (position < tree_n) changes[position] = changes[position].combine(change);\n    }\n\n    void push_down(int position, int length) {\n        if (changes[position].has_change()) {\n            apply_and_combine(2 * position, length / 2, changes[position]);\n            changes[position].h_add *= H_pow[length / 2];\n            apply_and_combine(2 * position + 1, length / 2, changes[position]);\n            changes[position].reset();\n        }\n    }\n\n    // Calls push_down for all necessary nodes in order to query the range [a, b).\n    void push_all(int a, int b) {\n        assert(0 <= a && a < b && b <= tree_n);\n        a += tree_n;\n        b += tree_n - 1;\n\n        for (int up = 31 - __builtin_clz(tree_n); up > 0; up--) {\n            int x = a >> up, y = b >> up;\n            push_down(x, 1 << up);\n            if (x != y) push_down(y, 1 << up);\n        }\n    }\n\n    void join_and_apply(int position, int length) {\n        tree[position].join(tree[2 * position], tree[2 * position + 1]);\n        tree[position].apply(length, changes[position]);\n    }\n\n    // Calls join for all necessary nodes after updating the range [a, b).\n    void join_all(int a, int b) {\n        assert(0 <= a && a < b && b <= tree_n);\n        a += tree_n;\n        b += tree_n - 1;\n        int length = 1;\n\n        while (a > 1) {\n            a /= 2;\n            b /= 2;\n            length *= 2;\n            join_and_apply(a, length);\n            if (a != b) join_and_apply(b, length);\n        }\n    }\n\n    template<typename T_range_op>\n    void process_range(int a, int b, bool needs_join, T_range_op &&range_op) {\n        if (a == b) return;\n        push_all(a, b);\n        int original_a = a, original_b = b;\n        int length = 1, r_size = 0;\n\n        for (a += tree_n, b += tree_n; a < b; a /= 2, b /= 2, length *= 2) {\n            if (a & 1)\n                range_op(a++, length);\n\n            if (b & 1)\n                right_half[r_size++] = {--b, length};\n        }\n\n        for (int i = r_size - 1; i >= 0; i--)\n            range_op(right_half[i].first, right_half[i].second);\n\n        if (needs_join)\n            join_all(original_a, original_b);\n    }\n\n    segment query(int a, int b) {\n        assert(0 <= a && a <= b && b <= tree_n);\n        segment answer;\n\n        process_range(a, b, false, [&](int position, int) {\n            answer.join(tree[position]);\n        });\n\n        return answer;\n    }\n\n    void update(int a, int b, const segment_change &change) {\n        assert(0 <= a && a <= b && b <= tree_n);\n\n        process_range(a, b, true, [&](int position, int length) {\n            int start = length * (position - (1 << (31 - __builtin_clz(position))));\n            apply_and_combine(position, length, segment_change(change.h_add * H_pow[start - a]));\n        });\n    }\n\n    vector<segment> to_array() {\n        for (int i = 1; i < tree_n; i++)\n            push_down(i, tree_n >> (31 - __builtin_clz(i)));\n\n        vector<segment> segs(tree_n);\n\n        for (int i = 0; i < tree_n; i++)\n            segs[i] = tree[tree_n + i];\n\n        return segs;\n    }\n};\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> N >> K;\n    inv_K = mod_int(K).inv();\n    H = 1 - inv_K;\n    H_pow.assign(10 * N + 1, 1);\n\n    for (int i = 1; i <= 10 * N; i++)\n        H_pow[i] = H * H_pow[i - 1];\n\n    INV1H = 1 / (1 - H);\n    INV1H2 = 1 / (1 - H * H);\n\n    vector<int> P(N);\n    vector<int> location(N + 1, -1);\n\n    for (int i = 0; i < N; i++) {\n        cin >> P[i];\n        location[P[i]] = i;\n    }\n\n    seg_tree tree(N - K);\n    tree.build(vector<segment>(N - K, segment(0, 0, 1)));\n    mod_int last_K = 0;\n\n    auto add = [&](int start) {\n        start -= K - 1;\n        start = max(start, 0);\n        assert(0 <= start && start <= N - K);\n        tree.update(start, N - K, segment_change(inv_K));\n        last_K += inv_K * H_pow[N - K - start];\n    };\n\n    auto query_sum = [&](int start) {\n        start -= K - 1;\n        start = max(start, 0);\n        assert(0 <= start && start <= N - K);\n        mod_int sum = tree.query(0, start).sum;\n        sum += H * tree.query(start, N - K).h_sum;\n        sum += last_K * H_pow[N - K - start + 1] * INV2 * K;\n        return sum;\n    };\n\n    auto query_here = [&](int start) {\n        start -= K - 1;\n        start = max(start, 0);\n        assert(0 <= start && start <= N - K);\n        mod_int sum = inv_K * tree.query(start, N - K).h_sum;\n        sum += last_K * K * H_pow[N - K - start] * inv_K;\n        return sum;\n    };\n\n    mod_int answer = 0;\n\n    for (int x = N; x > 0; x--) {\n        int start = location[x];\n        // dbg(start, query_sum(start), query_here(start) * INV2);\n        answer += query_sum(start);\n        answer += query_here(start) * INV2;\n        add(start);\n\n        // auto arr = tree.to_array();\n        // for (int i = 0; i < N - K; i++)\n        //     cerr << arr[i].sum << ' ';\n        // cerr << last_K << endl;\n    }\n\n    cout << answer << '\\n';\n}\n"
  },
  {
    "language": "C",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005,M=998244353;\nint n,k,p[N],i,a[N],q[N];\nlong long tree[N],m[N],ans[N];\nlong long qpow(long long a,long long b)\n{\n\tlong long s=a,ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*s%M;\n\t\ts=s*s%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid modify(int x,int y)\n{\n\twhile(x<=n)\n\t{\n\t\ttree[x]+=y;\n\t\tx+=-x&x;\n\t}\n}\nint Query(int x)\n{\n\tlong long s=0;\n\twhile(x)\n\t{\n\t\ts+=tree[x];\n\t\tx-=-x&x;\n\t}\n\treturn s%M;\n}\nvoid dfs(int l,int r)\n{\n\tif(l==r)\n\t\treturn;\n\tint mid=l+r>>1,i;\n\tlong long s=0,tot=0;\n\tfor(i=l;i<=mid;++i)\n\t{\n\t\tmodify(p[i],m[i]);\n\t\ttot=(tot+m[i])%M;\n\t}\n\tfor(i=r;i>mid;--i)\n\t{\n\t\tans[i]=(ans[i]+s)%M;\n\t\ts=(s+tot-Query(p[i]))%M;\n\t}\n\tfor(i=l;i<=mid;++i)\n\t\tmodify(p[i],-m[i]);\n\ts=0;\n\tfor(i=mid+1;i<=r;++i)\n\t\tmodify(p[i],1);\n\tfor(i=l;i<=mid;++i)\n\t{\n\t\ts=(s+Query(p[i])*m[i])%M;\n\t\tans[i]=(ans[i]+s)%M;\n\t}\n\tfor(i=mid+1;i<=r;++i)\n\t\tmodify(p[i],-1);\n\tdfs(l,mid);\n\tdfs(mid+1,r);\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&k);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&p[i]);\n\t\tq[p[i]]=i;\n\t}\n\tlong long in=qpow(k,M-2);\n\tlong long iw=in*(k-1)%M;\n\tlong long iiw=qpow(iw,M-2);\n\tfor(i=1;i<=n;++i)\n\t\tm[i]=in*qpow(iw,n-max(i,k))%M;\n\tdfs(1,n);\n\tlong long s=((n-k)*qpow(2,M-2)%M*(k-1)%M+1ll*k*(k-1)/2%M*qpow(2,M-2))%M;\n\tfor(i=n-k;i>=1;--i)\n\t\ts=(s+ans[i+k-1]*qpow(iiw,n-i-k+1))%M;\n\tcout<<(s%M+M)%M;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n  int a, b;\n  int sum = 0;\n\n  cout << \"Enter two numbers: \" << endl;\n\n  cin >> a >> b;\n  sum = a + b;\n\n  cout << \"The sum of two numbers is: \" << sum << endl;\n\n  if (sum < 5)\n  {\n    for (int i = 0; sum <= 10; i++)\n    {\n      cout << \"Happy Coding \" << sum++ << endl;\n    }\n  }\n\n  else\n  {\n    cout << \"Please enter the numbers in range!\" << endl;\n  }\n\n  cout << \"Happy Coding!\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define mod 998244353\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long ssize=524288,vd=0;\n\nvoid sinit(long long stree[],long long lazy[]){\n    long long i,j;\n    for(i=0;i<2*ssize;i++){\n        stree[i]=0;\n        lazy[i]=1;\n    }\n    return;\n}\n\n//lazy evaluation\nvoid eval(long long k,long long stree[],long long lazy[]){\n  if(lazy[k]!=1){\n    stree[k]*=lazy[k];\n    stree[k]%=mod;\n    if(k<(ssize-1)){\n      lazy[2*k+1]*=lazy[k];\n      lazy[2*k+1]%=mod;\n      lazy[2*k+2]*=lazy[k];\n      lazy[2*k+2]%=mod;\n    }\n    lazy[k]=1;\n  }\n  return;\n}\n\nvoid upd(long long k,long long a,long long stree[],long long lazy[]){\n    long long i,m,w,l,r;\n    long long mem[128];\n    long long ld,rd,md;\n    k+=ssize-1;\n    mem[0]=k;\n    w=1;\n    while(k>0){\n        k=(k-1)/2;\n        mem[w]=k;\n        w++;\n    }\n    l=0;r=ssize;\n    eval(0,stree,lazy);\n    for(i=w-1;i>0;i--){\n      eval((2*mem[i])+1,stree,lazy);\n      eval((2*mem[i])+2,stree,lazy);\n    }\n    stree[mem[0]]=a;\n    lazy[mem[0]]=1;\n    for(i=1;i<w;i++){\n        k=mem[i];\n        ld=stree[2*k+1];\n        rd=stree[2*k+2];\n        md=ld+rd;\n        md%=mod;\n        stree[k]=md;\n    }\n    return;\n}\n\n//multiple *t [a,b)\n//call:k=0,l=0,r=ssize\nvoid multquery(long long a,long long b,long long t,long long k,long long l,long long r,long long stree[],long long lazy[]){\n    long long ld,rd,md;\n    long long i,lp,rp;\n    eval(k,stree,lazy);\n    if(r<=a || b<=l){return;}\n    if(a<=l && r<=b){\n        lazy[k]*=t;\n        lazy[k]%=mod;\n        eval(k,stree,lazy);\n        return;\n    }\n    else{\n        eval(k*2+1,stree,lazy);\n        eval(k*2+2,stree,lazy);\n        multquery(a,b,t,k*2+1,l,(l+r)/2,stree,lazy);\n        multquery(a,b,t,k*2+2,(l+r)/2,r,stree,lazy);\n        stree[k]=(stree[k*2+1]+stree[k*2+2])%mod;\n        lazy[k]=1;\n        return;\n    }\n}\n\n//calc sum[a,b)\n//call:k=0,l=0,r=ssize\nlong long sumquery(long long a,long long b,long long k,long long l,long long r,long long stree[],long long lazy[]){\n    long long ld,rd,md;\n    long long i,lp,rp;\n    eval(k,stree,lazy);\n    if(r<=a || b<=l){return vd;}\n    if(a<=l && r<=b){\n        return stree[k];\n    }\n    else{\n        ld=sumquery(a,b,k*2+1,l,(l+r)/2,stree,lazy);\n        rd=sumquery(a,b,k*2+2,(l+r)/2,r,stree,lazy);\n        lp=0;rp=0;\n        md=ld+rd;\n        md%=mod;\n        return md;\n    }\n}\n\nint main(){\n  long long ms[1048576],ml[1048576];\n  long long ks[1048576],kl[1048576];\n  long long n,k,a[524288];\n  scanf(\"%lld%lld\",&n,&k);\n  long long iv=k-1;\n  iv*=modular_inverse(k);iv%=mod;\n  for(int i=1;i<=n;i++){\n    scanf(\"%lld\",&a[i]);\n  }\n  sinit(ms,ml);\n  sinit(ks,kl);\n  for(int i=1;i<=k;i++){\n    upd(a[i],1,ms,ml);\n    upd(a[i],a[i],ks,kl);\n  }\n  long long res=0;\n  long long niv=modular_inverse(k);\n  for(int i=k+1;i<=n;i++){\n    long long v;\n    v=sumquery((i-k),ssize,0,0,ssize,ks,kl);\n    v+=mod;\n    v-=(((i-k)*sumquery((i-k),ssize,0,0,ssize,ms,ml))%mod);\n    v%=mod;\n    //printf(\"<%lld>\\n\",v);\n    v*=niv;v%=mod;\n    res+=v;res%=mod;\n    multquery(0,ssize,iv,0,0,ssize,ms,ml);\n    multquery(0,ssize,iv,0,0,ssize,ks,kl);\n    upd(a[i],1,ms,ml);\n    upd(a[i],a[i],ks,kl);\n  }\n  long long vv=k;\n  for(int i=n-k+1;i<=n;i++){\n    long long nniv=modular_inverse(vv);\n    long long v;\n    v=sumquery(i,ssize,0,0,ssize,ks,kl);\n    v+=mod;\n    v-=((i*sumquery(i,ssize,0,0,ssize,ms,ml))%mod);\n    v%=mod;\n    v*=nniv;v%=mod;\n    res+=v;res%=mod;\n    nniv=vv-1;\n    nniv*=modular_inverse(vv);\n    nniv%=mod;\n    multquery(0,ssize,nniv,0,0,ssize,ms,ml);\n    multquery(0,ssize,nniv,0,0,ssize,ks,kl);\n    vv--;\n  }\n  printf(\"%lld\\n\",res%mod);\n  return 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport kotlin.math.max\n\nconst val MOD = 998244353L\n\nfun main() {\n    val jin = BufferedReader(InputStreamReader(System.`in`))\n    val (n, k) = jin.readLine().split(\" \").map { it.toInt() }\n    val p = listOf(0) + jin.readLine().split(\" \").map { it.toInt() }\n    val pow = LongArray(200001)\n    val powInv = LongArray(200001)\n    pow[0] = 1L\n    pow[1] = ((k - 1).toLong() * (k.toLong() pow -1)) % MOD\n    powInv[0] = 1L\n    powInv[1] = pow[1] pow -1\n    for (j in 2..200000) {\n        pow[j] = (pow[1] * pow[j - 1]) % MOD\n        powInv[j] = (powInv[1] * powInv[j - 1]) % MOD\n    }\n    val bitSum = BinaryIndexTree(1, n)\n    val bitAMT = BinaryIndexTree(1, n)\n    var answer = 0L\n    for (j in 1..n) {\n        val ix = max(k, j)\n        answer += pow[ix] * bitSum[1, p[j] - 1]\n        answer += bitAMT[p[j] + 1, n]\n        answer -= pow[ix] * bitSum[p[j] + 1, n]\n        answer %= MOD\n        bitSum.update(p[j], powInv[ix])\n        bitAMT.update(p[j], 2L)\n    }\n    answer *= 2L pow -1\n    answer %= MOD\n    answer += MOD\n    answer %= MOD\n    println(answer)\n}\n\nclass BinaryIndexTree(val treeFrom: Int, treeTo: Int) {\n    val value = LongArray(treeTo - treeFrom + 2)\n\n    fun update(index: Int, delta: Long) {\n        var i = index + 1 - treeFrom\n        while (i < value.size) {\n            value[i] += delta\n            value[i] %= MOD\n            i += i and -i\n        }\n    }\n\n    fun query(to: Int): Long {\n        var res = 0L\n        var i = to + 1 - treeFrom\n        while (i > 0) {\n            res += value[i]\n            res %= MOD\n            i -= i and -i\n        }\n        return res\n    }\n\n    operator fun get(from: Int, to: Int) = if (to < from) 0L else query(to) - query(from - 1)\n}\n\nconst val MOD_TOTIENT = MOD.toInt() - 1\n\ninfix fun Long.pow(power: Int): Long {\n    var e = power\n    e %= MOD_TOTIENT\n    if (e < 0) {\n        e += MOD_TOTIENT\n    }\n    if (e == 0 && this == 0L) {\n        return this\n    }\n    var b = this % MOD\n    var res = 1L\n    while (e > 0) {\n        if (e and 1 != 0) {\n            res *= b\n            res %= MOD\n        }\n        b *= b\n        b %= MOD\n        e = e shr 1\n    }\n    return res\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.BufferedReader\nimport java.io.InputStreamReader\nimport kotlin.math.max\n\nconst val MOD = 998244353L\n\nfun main() {\n    val jin = BufferedReader(InputStreamReader(System.`in`))\n    val (n, k) = jin.readLine().split(\" \").map { it.toInt() }\n    val p = listOf(0) + jin.readLine().split(\" \").map { it.toInt() }\n    val pow = LongArray(200001)\n    val powInv = LongArray(200001)\n    pow[0] = 1L\n    pow[1] = ((k - 1).toLong() * (k.toLong() pow -1)) % MOD\n    powInv[0] = 1L\n    powInv[1] = pow[1] pow -1\n    for (j in 2..200000) {\n        pow[j] = (pow[1] * pow[j - 1]) % MOD\n        powInv[j] = (powInv[1] * powInv[j - 1]) % MOD\n    }\n    val bitSum = BinaryIndexTree(1, n)\n    val bitAMT = BinaryIndexTree(1, n)\n    var answer = 0L\n    for (j in 1..n) {\n        val ix = max(k, j)\n        answer += pow[ix] * bitSum[1, p[j] - 1]\n        answer += bitAMT[p[j] + 1, n]\n        answer -= pow[ix] * bitSum[p[j] + 1, n]\n        answer %= MOD\n        bitSum.update(p[j], powInv[ix])\n        bitAMT.update(p[j], 2L)\n    }\n    answer *= 2L pow -1\n    answer %= MOD\n    answer += MOD\n    answer %= MOD\n    println(answer)\n}\n\nclass BinaryIndexTree(val treeFrom: Int, treeTo: Int) {\n    val value = LongArray(treeTo - treeFrom + 2)\n\n    fun update(index: Int, delta: Long) {\n        var i = index + 1 - treeFrom\n        while (i < value.size) {\n            value[i] += delta\n            i += i and -i\n        }\n    }\n\n    fun query(to: Int): Long {\n        var res = 0L\n        var i = to + 1 - treeFrom\n        while (i > 0) {\n            res += value[i]\n            i -= i and -i\n        }\n        return res\n    }\n\n    operator fun get(from: Int, to: Int) = if (to < from) 0L else query(to) - query(from - 1)\n}\n\nconst val MOD_TOTIENT = MOD.toInt() - 1\n\ninfix fun Long.pow(power: Int): Long {\n    var e = power\n    e %= MOD_TOTIENT\n    if (e < 0) {\n        e += MOD_TOTIENT\n    }\n    if (e == 0 && this == 0L) {\n        return this\n    }\n    var b = this % MOD\n    var res = 1L\n    while (e > 0) {\n        if (e and 1 != 0) {\n            res *= b\n            res %= MOD\n        }\n        b *= b\n        b %= MOD\n        e = e shr 1\n    }\n    return res\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic void solve()\n\t{\n\t\tint n = ni(), K = ni();\n\t\tint[] a = na(n);\n\n\t\tint[][] ai = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tai[i] = new int[]{a[i], i};\n\t\t}\n\t\tArrays.sort(ai, (x, y) -> {\n\t\t\tif (x[0] != y[0]) return x[0] - y[0];\n\t\t\treturn (x[1] - y[1]);\n\t\t});\n\n\t\tint mod = 998244353;\n\t\tlong P = mod+1-invl(K, mod);\n\t\tP %= mod;\n\n\t\tlong IP = invl(P, mod);\n\t\tlong[] pows = enumPows(P, n+5, mod);\n\t\tlong[] ft = new long[n+5];\n\t\tlong[] ift = new long[n+5];\n\t\tlong[] nft = new long[n+5];\n\t\tlong ans = invl(2, mod) * (long)(n*(n-1)/2%mod) % mod;\n\t\tlong escp = 0;\n\t\tfor(int[] u : ai){\n\t\t\tint pos = Math.max(u[1], K-1);\n\t\t\t{\n\t\t\t\tlong nh = sumFenwick(nft, n) - sumFenwick(nft, pos) + mod;\n\t\t\t\tlong h = sumFenwick(ft, n) - sumFenwick(ft, pos) + mod;\n\t\t\t\th = h * invl(pows[pos], mod) % mod;\n\t\t\t\tescp += nh;\n\t\t\t\tescp -= h;\n\t\t\t}\n\t\t\t{\n\t\t\t\tlong nh = sumFenwick(nft, pos-1);\n\t\t\t\tlong h = sumFenwick(ift, pos-1);\n\t\t\t\th = h * pows[pos] % mod;\n\t\t\t\tescp -= nh;\n\t\t\t\tescp += h;\n\t\t\t}\n\t\t\taddFenwick(ft, pos, pows[pos]);\n\t\t\taddFenwick(ift, pos, invl(pows[pos], mod));\n\t\t\taddFenwick(nft, pos, 1);\n//\t\t\ttr(escp%mod, guessFrac(escp, mod));\n\t\t}\n\t\t// 3/2\n\t\t// -1/4\n\n\t\tescp %= mod;\n\t\tif(escp < 0)escp += mod;\n\t\tout.println((escp * invl(2, mod) % mod + ans) % mod);\n\t}\n\n\tpublic static long[] guessFrac(long n, int mod)\n\t{\n\t\tlong min = mod;\n\t\tlong argnum = -1, argden = 0;\n\t\tfor(int den = 1;den <= 200000;den++){\n\t\t\tlong num = n*den%mod;\n\t\t\tif(num*2 >= mod)num -= mod;\n\t\t\tif(Math.abs(num) + den < min){\n\t\t\t\tmin = Math.abs(num) + den;\n\t\t\t\targnum = num;\n\t\t\t\targden = den;\n\t\t\t}\n\t\t}\n\t\treturn argden == 0 ? null : new long[]{argnum, argden};\n\t}\n\n\n\tpublic static long[] enumPows(long a, int n, int mod)\n\t{\n\t\ta %= mod;\n\t\tlong[] pows = new long[n+1];\n\t\tpows[0] = 1;\n\t\tfor(int i = 1;i <= n;i++)pows[i] = pows[i-1] * a % mod;\n\t\treturn pows;\n\t}\n\n\n\tpublic static final int mod = 998244353;\n\n\tpublic static long sumFenwick(long[] ft, int i)\n\t{\n\t\tlong sum = 0;\n\t\tfor(i++;i > 0;i -= i&-i){\n\t\t\tsum += ft[i];\n\t\t\tif(sum >= mod)sum -= mod;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tpublic static void addFenwick(long[] ft, int l, int r, long v)\n\t{\n\t\taddFenwick(ft, l, v);\n\t\taddFenwick(ft, r, -v);\n\t}\n\n\tpublic static void addFenwick(long[] ft, int i, long v)\n\t{\n\t\tv %= mod;\n\t\tif(v < 0)v += mod;\n\t\tif(v == 0)return;\n\t\tint n = ft.length;\n\t\tfor(i++;i < n;i += i&-i){\n\t\t\tft[i] += v;\n\t\t\tif(ft[i] >= mod)ft[i] -= mod;\n\t\t}\n\t}\n\n\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EShuffleWindow solver = new EShuffleWindow();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EShuffleWindow {\n        private static long mod = 998244353;\n        private static Modular modular = new Modular(mod);\n        private static Power power = new Power(modular);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int[] p = new int[n];\n            in.populate(p);\n            Segment segment = new Segment(1, n);\n            int die = power.inverse(k);\n            int alive = modular.subtract(1, die);\n            int half = power.inverse(2);\n            long exp = 0;\n            long inverseCnt = 0;\n            for (int i = 0; i < n; i++) {\n                if (i >= k) {\n                    segment.update(1, n, 1, n, alive);\n                }\n                long pre = segment.query(1, p[i], 1, n);\n                long post = segment.query(p[i], n, 1, n);\n                exp += half * pre % mod;\n                exp -= half * post % mod;\n\n                int postSize = segment.querySize(p[i], n, 1, n);\n                inverseCnt += postSize;\n\n                segment.active(p[i], p[i], 1, n);\n            }\n            long ans = exp + inverseCnt;\n            ans = modular.valueOf(ans);\n            out.println(ans);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static class Segment implements Cloneable {\n        private Segment left;\n        private Segment right;\n        private static long mod = 998244353;\n        private long sum = 0;\n        private long mul = 1;\n        private int size = 0;\n\n        private void active() {\n            size = 1;\n            sum = 1;\n        }\n\n        private void modify(long x) {\n            sum = sum * x % mod;\n            mul = mul * x % mod;\n        }\n\n        public void pushUp() {\n            sum = (left.sum + right.sum) % mod;\n            size = left.size + right.size;\n        }\n\n        public void pushDown() {\n            if (mul != 1) {\n                left.modify(mul);\n                right.modify(mul);\n                mul = 1;\n            }\n        }\n\n        public Segment(int l, int r) {\n            if (l < r) {\n                int m = DigitUtils.floorAverage(l, r);\n                left = new Segment(l, m);\n                right = new Segment(m + 1, r);\n                pushUp();\n            } else {\n\n            }\n        }\n\n        private boolean covered(int ll, int rr, int l, int r) {\n            return ll <= l && rr >= r;\n        }\n\n        private boolean noIntersection(int ll, int rr, int l, int r) {\n            return ll > r || rr < l;\n        }\n\n        public void update(int ll, int rr, int l, int r, long x) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                modify(x);\n                return;\n            }\n            pushDown();\n            int m = DigitUtils.floorAverage(l, r);\n            left.update(ll, rr, l, m, x);\n            right.update(ll, rr, m + 1, r, x);\n            pushUp();\n        }\n\n        public void active(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                active();\n                return;\n            }\n            pushDown();\n            int m = DigitUtils.floorAverage(l, r);\n            left.active(ll, rr, l, m);\n            right.active(ll, rr, m + 1, r);\n            pushUp();\n        }\n\n        public long query(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return 0;\n            }\n            if (covered(ll, rr, l, r)) {\n                return sum;\n            }\n            pushDown();\n            int m = DigitUtils.floorAverage(l, r);\n            return (left.query(ll, rr, l, m) +\n                    right.query(ll, rr, m + 1, r)) % mod;\n        }\n\n        public int querySize(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return 0;\n            }\n            if (covered(ll, rr, l, r)) {\n                return size;\n            }\n            pushDown();\n            int m = DigitUtils.floorAverage(l, r);\n            return left.querySize(ll, rr, l, m) +\n                    right.querySize(ll, rr, m + 1, r);\n        }\n\n        private Segment deepClone() {\n            Segment seg = clone();\n            if (seg.left != null) {\n                seg.left = seg.left.deepClone();\n            }\n            if (seg.right != null) {\n                seg.right = seg.right.deepClone();\n            }\n            return seg;\n        }\n\n        protected Segment clone() {\n            try {\n                return (Segment) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        private void toString(StringBuilder builder) {\n            if (left == null && right == null) {\n                builder.append(\"val\").append(\",\");\n                return;\n            }\n            pushDown();\n            left.toString(builder);\n            right.toString(builder);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            deepClone().toString(builder);\n            if (builder.length() > 0) {\n                builder.setLength(builder.length() - 1);\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        static IntExtGCDObject extGCD = new IntExtGCDObject();\n        final Modular modular;\n        int modVal;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n            this.modVal = modular.getMod();\n        }\n\n        public int inverse(int x) {\n            int ans = inverseExtGCD(x);\n//        if(modular.mul(ans, x) != 1){\n//            throw new IllegalStateException();\n//        }\n            return ans;\n        }\n\n        public int inverseExtGCD(int x) {\n            if (extGCD.extgcd(x, modVal) != 1) {\n                throw new IllegalArgumentException();\n            }\n            return modular.valueOf(extGCD.getX());\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class IntExtGCDObject {\n        private int[] xy = new int[2];\n\n        public int extgcd(int a, int b) {\n            return ExtGCD.extGCD(a, b, xy);\n        }\n\n        public int getX() {\n            return xy[0];\n        }\n\n    }\n\n    static class ExtGCD {\n        public static int extGCD(int a, int b, int[] xy) {\n            if (a >= b) {\n                return extGCD0(a, b, xy);\n            }\n            int ans = extGCD0(b, a, xy);\n            SequenceUtils.swap(xy, 0, 1);\n            return ans;\n        }\n\n        private static int extGCD0(int a, int b, int[] xy) {\n            if (b == 0) {\n                xy[0] = 1;\n                xy[1] = 0;\n                return a;\n            }\n            int ans = extGCD0(b, a % b, xy);\n            int x = xy[0];\n            int y = xy[1];\n            xy[0] = y;\n            xy[1] = x - a / b * y;\n            return ans;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorAverage(int x, int y) {\n            return (x & y) + ((x ^ y) >> 1);\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void swap(int[] data, int i, int j) {\n            int tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic void solve()\n\t{\n\t\tint n = ni(), K = ni();\n\t\tint[] a = na(n);\n\n\t\tint[][] ai = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tai[i] = new int[]{a[i], i};\n\t\t}\n\t\tArrays.sort(ai, (x, y) -> {\n\t\t\tif (x[0] != y[0]) return x[0] - y[0];\n\t\t\treturn (x[1] - y[1]);\n\t\t});\n\n\t\tint mod = 998244353;\n\t\tlong P = mod+1-invl(K, mod);\n\t\tP %= mod;\n\n\t\tlong[] pows = enumPows(P, n+5, mod);\n\t\tlong[] ft = new long[n+5];\n\t\tlong[] ift = new long[n+5];\n\t\tlong[] nft = new long[n+5];\n\t\tlong ans = invl(2, mod) * ((long)n*(n-1)/2%mod) % mod;\n\t\tlong escp = 0;\n\t\tfor(int[] u : ai){\n\t\t\tint pos = Math.max(u[1], K-1);\n\t\t\t{\n\t\t\t\tlong nh = sumFenwick(nft, n) - sumFenwick(nft, pos) + mod;\n\t\t\t\tlong h = sumFenwick(ft, n) - sumFenwick(ft, pos) + mod;\n\t\t\t\th = h * invl(pows[pos], mod) % mod;\n\t\t\t\tescp += nh;\n\t\t\t\tescp -= h;\n\t\t\t}\n\t\t\t{\n\t\t\t\tlong nh = sumFenwick(nft, pos-1);\n\t\t\t\tlong h = sumFenwick(ift, pos-1);\n\t\t\t\th = h * pows[pos] % mod;\n\t\t\t\tescp -= nh;\n\t\t\t\tescp += h;\n\t\t\t}\n\t\t\taddFenwick(ft, pos, pows[pos]);\n\t\t\taddFenwick(ift, pos, invl(pows[pos], mod));\n\t\t\taddFenwick(nft, pos, 1);\n//\t\t\ttr(escp%mod, guessFrac(escp, mod));\n\t\t}\n\t\t// 3/2\n\t\t// -1/4\n\n\t\tescp %= mod;\n\t\tif(escp < 0)escp += mod;\n\t\tout.println((escp * invl(2, mod) % mod + ans) % mod);\n\t}\n\n\tpublic static long[] guessFrac(long n, int mod)\n\t{\n\t\tlong min = mod;\n\t\tlong argnum = -1, argden = 0;\n\t\tfor(int den = 1;den <= 200000;den++){\n\t\t\tlong num = n*den%mod;\n\t\t\tif(num*2 >= mod)num -= mod;\n\t\t\tif(Math.abs(num) + den < min){\n\t\t\t\tmin = Math.abs(num) + den;\n\t\t\t\targnum = num;\n\t\t\t\targden = den;\n\t\t\t}\n\t\t}\n\t\treturn argden == 0 ? null : new long[]{argnum, argden};\n\t}\n\n\n\tpublic static long[] enumPows(long a, int n, int mod)\n\t{\n\t\ta %= mod;\n\t\tlong[] pows = new long[n+1];\n\t\tpows[0] = 1;\n\t\tfor(int i = 1;i <= n;i++)pows[i] = pows[i-1] * a % mod;\n\t\treturn pows;\n\t}\n\n\n\tpublic static final int mod = 998244353;\n\n\tpublic static long sumFenwick(long[] ft, int i)\n\t{\n\t\tlong sum = 0;\n\t\tfor(i++;i > 0;i -= i&-i){\n\t\t\tsum += ft[i];\n\t\t\tif(sum >= mod)sum -= mod;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tpublic static void addFenwick(long[] ft, int l, int r, long v)\n\t{\n\t\taddFenwick(ft, l, v);\n\t\taddFenwick(ft, r, -v);\n\t}\n\n\tpublic static void addFenwick(long[] ft, int i, long v)\n\t{\n\t\tv %= mod;\n\t\tif(v < 0)v += mod;\n\t\tif(v == 0)return;\n\t\tint n = ft.length;\n\t\tfor(i++;i < n;i += i&-i){\n\t\t\tft[i] += v;\n\t\t\tif(ft[i] >= mod)ft[i] -= mod;\n\t\t}\n\t}\n\n\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nstruct ModInt(int M_) {\n  import std.conv : to;\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      if (a < 0) return (this = inv()^^(-a));\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e > 0; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op: \"-\")() const { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const {\n    return mixin(\"ModInt(this) \" ~ op ~ \"= a\");\n  }\n  ModInt opBinaryRight(string op)(long a) const {\n    return mixin(\"ModInt(a) \" ~ op ~ \"= this\");\n  }\n  bool opCast(T: bool)() const { return (x != 0); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998244353;\nalias Mint = ModInt!MO;\n\n\nvoid bAdd(T)(T[] bit, int pos, T val)\nin {\n  assert(0 <= pos && pos < bit.length, \"bAdd: 0 <= pos < |bit| must hold\");\n}\ndo {\n  for (int x = pos; x < bit.length; x |= x + 1) {\n    bit[x] += val;\n  }\n}\n\n// sum of [0, pos)\nT bSum(T)(T[] bit, int pos)\nin {\n  assert(0 <= pos && pos <= bit.length, \"bSum: 0 <= pos <= |bit| must hold\");\n}\ndo {\n  T ret = 0;\n  for (int x = pos - 1; x >= 0; x = (x & (x + 1)) - 1) {\n    ret += bit[x];\n  }\n  return ret;\n}\n\n\nvoid main() {\n  try {\n    for (; ; ) {\n      const N = readInt();\n      const K = readInt();\n      auto A = new int[N];\n      foreach (i; 0 .. N) {\n        A[i] = readInt() - 1;\n      }\n      \n      const survive = Mint(K - 1) / Mint(K);\n      const invSurvive = survive.inv;\n      auto pw = new Mint[N + 1];\n      auto invPw = new Mint[N + 1];\n      pw[0] = invPw[0] = 1;\n      foreach (i; 1 .. N + 1) {\n        pw[i] = pw[i - 1] * survive;\n        invPw[i] = invPw[i - 1] * invSurvive;\n      }\n      \n      auto bit0 = new long[N];\n      auto bit1 = new Mint[N];\n      Mint tot1;\n      Mint ans;\n      foreach (i; 0 .. N) {\n        const res0 = bit0.bSum(A[i]);\n        const res1 = bit1.bSum(A[i]);\n        ans += res1 * pw[max(i, K - 1)] / 2;\n        ans += (i - res0) - (tot1 - res1) * pw[max(i, K - 1)] / 2;\n        bit0.bAdd(A[i], 1);\n        bit1.bAdd(A[i], invPw[max(i, K - 1)]);\n        tot1 += invPw[max(i, K - 1)];\n      }\n      writeln(ans);\n      \n      debug {\n        Mint brt;\n        foreach (i; 0 .. N) foreach (j; i + 1 .. N) {\n          const prob = (Mint(K - 1) / Mint(K))^^(max(j, K - 1) - max(i, K - 1)) / 2;\n          brt += (A[i] > A[j]) ? (1 - prob) : prob;\n        }\n        writeln(\"brt = \", brt);\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.buffer.readline\n\nmod=998244353\n\nclass BIT:\n\tdef __init__(self,n):\n\t\tself.n=n\n\t\tself.buf=[0]*n\n\t\n\tdef add(self,i,v):\n\t\tbuf=self.buf\n\t\twhile i<n:\n\t\t\tbuf[i]+=v\n\t\t\tif buf[i]>=mod:\n\t\t\t\tbuf[i]-=mod\n\t\t\ti+=(i+1)&(-i-1)\n\t\n\tdef get(self,i):\n\t\tbuf=self.buf\n\t\tres=0\n\t\twhile i>=0:\n\t\t\tres+=buf[i]\n\t\t\tif res>=mod:\n\t\t\t\tres-=mod\n\t\t\ti-=(i+1)&(-i-1)\n\t\treturn res\n\t\n\tdef rng(self,b,e):\n\t\tres=self.get(e-1)-self.get(b)\n\t\tif res<0:\n\t\t\tres+=mod\n\t\treturn res\n\nn,k=map(int,readline().split())\np=list(map(int,readline().split()))\nfor i in range(n):\n\tp[i]-=1\n\nans=0\n\nbit=BIT(n)\nfor i in range(n):\n\tans+=i-bit.get(p[i])\n\tbit.add(p[i],1)\n\nz=pow(2,mod-2,mod);\nw=1\nwinv=1\nrem=(k-1)*pow(k,mod-2,mod)%mod\nreminv=pow(rem,mod-2,mod)\n\nbit=BIT(n)\nfor i in range(n):\n\tlw=bit.get(p[i])\n\tup=bit.rng(p[i],n)\n\tdif=(lw-up+mod)%mod\n\tans=(ans+dif*w*z)%mod\n\tbit.add(p[i],winv)\n\tif i>=k-1:\n\t\tw=w*rem%mod\n\t\twinv=winv*reminv%mod\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8, f8\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 998_244_353\n\n@njit((i8, i8), cache=True)\ndef mpow(a, n):\n    p = 1\n    while n:\n        if n & 1:\n            p = p * a % MOD\n        a = a * a % MOD\n        n >>= 1\n    return p\n\n@njit((i8[:], ), cache=True)\ndef build(raw_data):\n    bit = raw_data.copy()\n    for i in range(len(bit)):\n        j = i + (i & (-i))\n        if j < len(bit):\n            bit[j] += bit[i]\n            bit[j] %= MOD\n    return bit\n\n\n@njit((i8[:], i8), cache=True)\ndef get_sum(bit, i):\n    s = 0\n    while i:\n        s += bit[i]\n        i -= i & -i\n    return s % MOD\n\n\n@njit((i8[:], i8, i8), cache=True)\ndef add(bit, i, x):\n    while i < len(bit):\n        bit[i] += x\n        bit[i] %= MOD\n        i += i & -i\n\n@njit((i8, i8[:]), cache=True)\ndef main(K, A):\n    N = len(A)\n    # 各処理の段階で、n が active になっている確率を求める。\n    # 個数の分布も持つ。\n    # 更新を sparse にするために、時刻（右端のインデックス） i にアクティブになったところの\n    # 生存率には、p^{-i} を入れておく。時刻 t には確率 p^{t-i} なので、和に p^t をかける\n    p = (1 - mpow(K, MOD - 2)) % MOD\n    p_inv = mpow(p, MOD - 2)\n    bit_active = np.zeros(N + 1, np.int64)\n    bit_cnt = np.zeros(N + 1, np.int64)\n    half = (MOD + 1) // 2\n    ans = 0\n    # 最初の起動\n    ans += K * (K - 1) // 2 % MOD * half % MOD\n    ans %= MOD\n    for i in range(K):\n        x = A[i]\n        add(bit_cnt, x, 1)\n        add(bit_active, x, mpow(p_inv, K - 1))\n    for i in range(K, N):\n        x = A[i]\n        low_cnt = get_sum(bit_cnt, x)\n        high_cnt = i - low_cnt\n        pt = mpow(p, i)\n        active_sum_low = get_sum(bit_active, x) * pt % MOD\n        active_sum_high = K - 1 - active_sum_low\n        # 追加処理\n        add(bit_cnt, x, 1)\n        add(bit_active, x, mpow(p_inv, i))\n        # A[i] と A[j] (j<i) の転倒数の期待値を計算\n        inv = 0\n        inv += active_sum_low * half % MOD\n        inv += (high_cnt - active_sum_high)\n        inv += active_sum_high * half % MOD\n        inv %= MOD\n        ans += inv\n        ans %= MOD\n    return ans\n\nN, K = map(int, readline().split())\nA = np.array(read().split(), np.int64)\n\nprint(main(K, A))"
  },
  {
    "language": "Python",
    "code": "class SegmentTree():\n    def __init__(self, init, unit, f):\n        self.unit = unit\n        self.f = f\n        if type(init) == int:\n            self.n = init\n            # self.n = 1 << (self.n - 1).bit_length()\n            self.X = [unit] * (self.n * 2)\n        else:\n            self.n = len(init)\n            # self.n = 1 << (self.n - 1).bit_length()\n            self.X = [unit] * self.n + init + [unit] * (self.n - len(init))\n            for i in range(self.n-1, 0, -1):\n                self.X[i] = self.f(self.X[i*2], self.X[i*2|1])\n    \n    def getvalue(self, i):\n        i += self.n\n        return self.X[i]\n        \n    def update(self, i, x):\n        i += self.n\n        self.X[i] = x\n        i >>= 1\n        while i:\n            self.X[i] = self.f(self.X[i*2], self.X[i*2|1])\n            i >>= 1\n    \n    def add(self, i, x):\n        i += self.n\n        self.X[i] = (self.X[i] + x) % mod\n        i >>= 1\n        while i:\n            self.X[i] = self.f(self.X[i*2], self.X[i*2|1])\n            i >>= 1\n    \n    def getrange(self, l, r):\n        l += self.n\n        r += self.n\n        al = self.unit\n        ar = self.unit\n        while l < r:\n            if l & 1:\n                al = self.f(al, self.X[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                ar = self.f(self.X[r], ar)\n            l >>= 1\n            r >>= 1\n        return self.f(al, ar)\n    \n    def debug(self):\n        de = []\n        a, b = self.n, self.n * 2\n        while b:\n            de.append(self.X[a:b])\n            a, b = a//2, a\n        print(\"--- debug ---\")\n        for d in de[::-1]:\n            print(d)\n        print(\"--- ---\")\n\ndef r(a):\n    for i in range(1, 10001):\n        if i and a * i % mod <= 10000:\n            return str(a*i%mod) + \"/\" + str(i)\n        if i and -a * i % mod <= 10000:\n            return str(-(-a*i%mod)) + \"/\" + str(i)\n    return a\n\nmod = 998244353\nN, K = map(int, input().split())\nP = [int(a) - 1 for a in input().split()]\nf = lambda a, b: (a + b) % mod\n\np1 = (K - 1) * (K - 2) * pow(4, mod - 2, mod) % mod\np2 = K * (K - 1) * pow(4, mod - 2, mod) % mod\nm = (K - 1) * pow(K, mod - 2, mod) % mod\ninvm = K * pow(K - 1, mod - 2, mod) % mod\n\nst1 = SegmentTree(N, 0, f)\nst2 = SegmentTree(N, 0, f)\nans = p2\nfor i, x in enumerate(P):\n    if i >= K:\n        ans = (ans + st1.getrange(x, N)) % mod\n    st1.add(x, 1)\n\ns = 1\ninvs = 1\nst = SegmentTree(N, 0, f)\nfor i, x in enumerate(P[:K]):\n    st.add(x, 1)\nfor i in range(K, N):\n    s = s * m % mod\n    invs = invs * invm % mod\n    x = P[i]\n    a = st.getrange(x, N) * s % mod\n    ans = (ans + p2 - p1 - a) % mod\n    st.add(x, invs % mod)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "class BIT: #0-indexed\n    __slots__ = [\"size\", \"tree\",\"depth\",\"n0\"]\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0]*(n+1)\n        self.depth = n.bit_length()\n        self.n0 = 1<<self.depth\n\n    def get_sum(self, i): #a_0 + ... + a_{i} #閉区間\n        s = 0; i += 1\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def range_sum(self,l,r): #a_l + ... + a_r 閉区間\n        return self.get_sum(r) - self.get_sum(l-1) \n\n    def add(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n    def bisect_left(self,w):\n        #和が w 以上になる最小の index\n        #w が存在しない場合 self.size を返す\n        if w <= 0: return 0\n        x,k = 0,self.n0\n        for _ in range(self.depth):\n            k >>= 1\n            if x+k <= self.size and self.tree[x+k] < w:\n                w -= self.tree[x+k]\n                x += k\n        return x\n\n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,k = map(int,readline().split())\n*p, = map(int,readline().split())\n\nb = BIT(n)\nnum = BIT(n)\nMOD = 998244353\ninv2 = (MOD+1)//2\nfor i in range(k):\n    b.add(p[i]-1,inv2)\n    num.add(p[i]-1,1)\n\nans = k*(k-1)//2%MOD*inv2%MOD\n\nprob = (k-1)*pow(k,MOD-2,MOD)%MOD #(k-1/k)\npinv = pow(prob,MOD-2,MOD)\nval = pinv*inv2%MOD #(k-1)/k/2: これを bit に足していく\nrate = prob #倍率\nfor j in range(k,n):\n    # p_i < p_j\n    pj = p[j]-1\n    v = b.get_sum(pj)\n    ans += v*rate%MOD\n    ans %= MOD\n\n    # p_i > p_j\n    w =  b.get_sum(n-1)-v\n    ans += (j - num.get_sum(pj)) - w*rate%MOD\n    ans %= MOD\n    \n    b.add(pj,val)\n    num.add(pj,1)\n    val = val*pinv%MOD\n    rate = rate*prob%MOD\n\nprint(ans%MOD)\n"
  },
  {
    "language": "Python",
    "code": "class SegmentTree:\n    def __init__(self, data, default=0, func=max):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.data[stop], res_right)\n            start >>= 1\n            stop >>= 1\n\n        return self._func(res_left, res_right)\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n \ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\nn, k = map(int, input().split())\np = list(map(lambda x: int(x) - 1, input().split()))\n\nout = 0\nmod = 998244353\n\nmult_r = (k-1) * modinv(k, mod)\nmult_inv = modinv(mult_r, mod)\nmult = 1\ninv = 1\n\nseg = SegmentTree([0] * n, func = lambda x,y: x+y)\nseg2 = SegmentTree([0] * n, func = lambda x,y: x+y)\n\nfor i in range(n):\n\n    if i >= k:\n        mult *= mult_r\n        mult %= mod\n\n        inv *= mult_inv\n        inv %= mod\n\n    expected_above = (seg.query(p[i], n) * mult) % mod\n    expected_below = (seg.query(0,p[i]) * mult) % mod\n\n    tot_above = seg2.query(p[i], n)\n    #tot_below = seg2.query(0, p[i])\n\n    out += tot_above - modinv(2, mod) * (expected_above)\n    out += modinv(2, mod) * (expected_below)\n    out %= mod\n\n    seg[p[i]] = inv\n    seg2[p[i]] = 1\nprint(out)\n#print((modinv(2, mod) * dout) % mod)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nclass BIT:\n    #1-indexed\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n        self.p = 2**(n.bit_length() - 1)\n        self.dep = n.bit_length()\n    def get(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n    \n    def bl(self, v):\n        if v <= 0:\n            return -1\n        s = 0\n        k = self.p\n        for _ in range(self.dep):\n            if s + k <= self.size and self.tree[s+k] < v:\n                s += k\n                v -= self.tree[s+k]\n            k //= 2\n        return s + 1\n\nN, K = map(int, readline().split())\nMOD = 998244353\nP = list(map(int, readline().split()))\n\nr = (K-1)*pow(K, MOD-2, MOD)\n\nL = [pow(r, max(0, i-K+1), MOD) for i in range(N)]\nLinv = [pow(l, MOD-2, MOD) for l in L]\nT1 = BIT(N)\nT2 = BIT(N)\n\nans = 0\nasum = 0\nti = (MOD+1)//2\nfor i in range(N):\n    ans += i - T2.get(P[i])\n    g1 = T1.get(P[i])\n    ans = (ans + ti*L[i]*(2*g1-asum))%MOD\n    T2.add(P[i], 1)\n    T1.add(P[i], Linv[i])\n    asum = (asum + Linv[i]) % MOD\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "class BIT: #0-indexed\n    __slots__ = [\"size\", \"tree\",\"depth\",\"n0\"]\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0]*(n+1)\n        self.depth = n.bit_length()\n        self.n0 = 1<<self.depth\n\n    def get_sum(self, i): #a_0 + ... + a_{i} #閉区間\n        s = 0; i += 1\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def range_sum(self,l,r): #a_l + ... + a_r 閉区間\n        return self.get_sum(r) - self.get_sum(l-1) \n\n    def add(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n    def bisect_left(self,w):\n        #和が w 以上になる最小の index\n        #w が存在しない場合 self.size を返す\n        if w <= 0: return 0\n        x,k = 0,self.n0\n        for _ in range(self.depth):\n            k >>= 1\n            if x+k <= self.size and self.tree[x+k] < w:\n                w -= self.tree[x+k]\n                x += k\n        return x\n\n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,k = map(int,readline().split())\n*p, = map(int,readline().split())\n\nb = BIT(n)\nnum = BIT(n)\nMOD = 998244353\ninv = (MOD+1)//2\nfor i in range(k):\n    b.add(p[i]-1,1)\n    num.add(p[i]-1,1)\n\nans = k*(k-1)//2%MOD*inv%MOD\n\ntot = k\nrate = (k-1)*pow(k,MOD-2,MOD)%MOD\nrateinv = pow(rate,MOD-2,MOD)\nbunbo = rate\nhosei = rateinv\nfor i in range(k,n):\n    pi = p[i]-1\n    v = b.get_sum(pi)\n    #print(v*inv%MOD*bunbo%MOD,v*inv%MOD*bunbo%MOD*4%MOD,\"v\")\n    ans += v*inv%MOD*bunbo%MOD\n    ans %= MOD\n    \n\n    x = i - num.get_sum(pi)\n    w = x - (tot-v)*inv%MOD*bunbo%MOD\n    #print(x,tot,v)\n    #print(w,w*4%MOD,\"w\")\n    ans += w\n    ans %= MOD\n    \n    b.add(pi,hosei)\n    num.add(pi,1)\n    tot += hosei\n    hosei = hosei*rateinv%MOD\n    bunbo = bunbo*rate%MOD\n\n\n\nprint(ans%MOD)\n#print(ans*8%MOD)\n\n"
  },
  {
    "language": "Rust",
    "code": "// template {{{\n#![allow(clippy::many_single_char_names)]\n\n#[allow(dead_code)]\nmod ngtio {\n    use ::std::collections::VecDeque;\n\n    pub struct Buffer {\n        buf: VecDeque<String>,\n    }\n\n    impl Buffer {\n        pub fn new() -> Self {\n            Self {\n                buf: VecDeque::new(),\n            }\n        }\n\n        fn load(&mut self) {\n            while self.buf.is_empty() {\n                let mut s = String::new();\n                let length = ::std::io::stdin().read_line(&mut s).unwrap();\n                if length == 0 {\n                    break;\n                }\n                self.buf.extend(s.split_whitespace().map(|s| s.to_owned()));\n            }\n        }\n\n        pub fn string(&mut self) -> String {\n            self.load();\n            self.buf\n                .pop_front()\n                .unwrap_or_else(|| panic!(\"入力が終了したのですが。\"))\n        }\n\n        pub fn string_char_vec(&mut self) -> Vec<char> {\n            let s = self.string();\n            s.chars().collect::<Vec<_>>()\n        }\n\n        pub fn string_char_vec_trusted_len(&mut self, len: usize) -> Vec<char> {\n            let s = self.string();\n            let s = s.chars().collect::<Vec<_>>();\n            assert_eq!(s.len(), len, \"あら、思ったのと長さ違いますね……\");\n            s\n        }\n\n        pub fn char(&mut self) -> char {\n            let string = self.string();\n            let mut chars = string.chars();\n            let res = chars.next().unwrap();\n            assert!(\n                chars.next().is_none(),\n                \"char で受け取りたいのも山々なのですが、さては 2 文字以上ありますね？\"\n            );\n            res\n        }\n\n        pub fn read<T: ::std::str::FromStr>(&mut self) -> T\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            self.string()\n                .parse::<T>()\n                .expect(\"Failed to parse the input.\")\n        }\n\n        pub fn read_vec<T: ::std::str::FromStr>(&mut self, len: usize) -> Vec<T>\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            (0..len).map(|_| self.read::<T>()).collect()\n        }\n    }\n\n    macro_rules! define_primitive_reader {\n        ($($ty:tt,)*) => {\n            impl Buffer {\n                $(\n#[inline]\n                    pub fn $ty(&mut self) -> $ty {\n                        self.read::<$ty>()\n                    }\n                )*\n            }\n        }\n    }\n\n    define_primitive_reader! {\n        u8, u16, u32, u64, usize,\n        i8, i16, i32, i64, isize,\n    }\n\n    impl Default for Buffer {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n}\n\n#[allow(unused_imports)]\nuse std::{collections, iter, mem, ops};\n// }}}\n// fp {{{\n#[allow(dead_code)]\nmod fp {\n    #![warn(missing_docs)]\n    use crate::type_traits::*;\n    pub use aliases::*;\n    use std::{cmp, fmt, iter, mem, ops::*};\n\n    mod arith {\n        use super::{Fp, Modable, Value};\n        use crate::type_traits::*;\n        use std::ops::*;\n\n        impl<Mod: Modable> Add for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn add(self, rhs: Self) -> Self {\n                Self(Self::normalize_from_the_bottom(\n                    self.into_inner() + rhs.into_inner(),\n                ))\n            }\n        }\n\n        impl<Mod: Modable> Sub for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn sub(self, rhs: Self) -> Self {\n                Self(Self::normalize_from_the_top(\n                    self.into_inner() - rhs.into_inner(),\n                ))\n            }\n        }\n\n        impl<Mod: Modable> Mul for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn mul(self, rhs: Self) -> Self {\n                Self::new(self.into_inner() * rhs.into_inner())\n            }\n        }\n\n        #[allow(clippy::suspicious_arithmetic_impl)]\n        impl<Mod: Modable> Div for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn div(self, rhs: Self) -> Self {\n                self * rhs.inv()\n            }\n        }\n\n        impl<Mod: Modable> Neg for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn neg(self) -> Self {\n                if self.into_inner().is_zero() {\n                    Self::zero()\n                } else {\n                    Self(Mod::VALUE - self.into_inner())\n                }\n            }\n        }\n\n        impl<Mod: Modable> Neg for &Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Fp<Mod>;\n\n            #[inline]\n            fn neg(self) -> Fp<Mod> {\n                if self.into_inner().is_zero() {\n                    Fp::zero()\n                } else {\n                    Fp(Mod::VALUE - self.into_inner())\n                }\n            }\n        }\n\n        macro_rules! forward_assign_biop {\n            ($(impl $trait:ident, $fn_assign:ident, $fn:ident)*) => {\n                $(\n                    impl<Mod: Modable> $trait for Fp<Mod>\n                    where\n                        Mod::Output: Value\n                    {\n                        #[inline]\n                        fn $fn_assign(&mut self, rhs: Self) {\n                            *self = self.$fn(rhs);\n                        }\n                    }\n                )*\n            };\n        }\n        forward_assign_biop! {\n            impl AddAssign, add_assign, add\n            impl SubAssign, sub_assign, sub\n            impl MulAssign, mul_assign, mul\n            impl DivAssign, div_assign, div\n        }\n\n        macro_rules! forward_ref_binop {\n            ($(impl $imp:ident, $method:ident)*) => {\n                $(\n                    impl<'a, Mod: Modable> $imp<Fp<Mod>> for &'a Fp<Mod>\n                    where\n                        Mod::Output:Value\n                    {\n                        type Output = Fp<Mod>;\n\n                        #[inline]\n                        fn $method(self, other: Fp<Mod>) -> Self::Output {\n                            $imp::$method(*self, other)\n                        }\n                    }\n\n                    impl<'a, Mod: Modable> $imp<&'a Fp<Mod>> for Fp<Mod>\n                    where\n                        Mod::Output:Value\n                    {\n                        type Output = Fp<Mod>;\n\n                        #[inline]\n                        fn $method(self, other: &Fp<Mod>) -> Self::Output {\n                            $imp::$method(self, *other)\n                        }\n                    }\n\n                    impl<'a, Mod: Modable> $imp<&'a Fp<Mod>> for &'a Fp<Mod>\n                    where\n                        Mod::Output:Value\n                    {\n                        type Output = Fp<Mod>;\n\n                        #[inline]\n                        fn $method(self, other: &Fp<Mod>) -> Self::Output {\n                            $imp::$method(*self, *other)\n                        }\n                    }\n                )*\n            };\n        }\n        forward_ref_binop! {\n            impl Add, add\n            impl Sub, sub\n            impl Mul, mul\n            impl Div, div\n        }\n    }\n\n    #[macro_export]\n    macro_rules! fp_vec {\n        () => (\n            Vec::<$crate::Fp<_>>::new()\n        );\n        ($elem:expr; $n:expr) => (\n            vec![$crate::Fp::new($elem); $n]\n        );\n        ($($x:expr),+ $(,)?) => (\n            vec![$($crate::Fp::new($x),)+];\n        );\n    }\n\n    #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    pub struct Fp<Mod: Modable>(Mod::Output);\n\n    impl<Mod: Modable> Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        #[inline]\n        pub fn new(src: Mod::Output) -> Self {\n            Self(Self::normalize(src))\n        }\n\n        #[inline]\n        pub fn frac(num: Mod::Output, den: Mod::Output) -> Self {\n            Self::new(num) / Self::new(den)\n        }\n\n        #[inline]\n        pub fn into_inner(self) -> Mod::Output {\n            self.0\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        pub fn inv(self) -> Self {\n            assert_ne!(\n                self.into_inner(),\n                Mod::Output::zero(),\n                \"さては 0 の逆元を取ろうとしていますね？\"\n            );\n            let mut x = self.into_inner();\n            let mut y = Mod::VALUE;\n            let mut u = Mod::Output::one();\n            let mut v = Mod::Output::zero();\n            while x != Mod::Output::zero() {\n                let q = y / x;\n                y -= q * x;\n                v -= q * u;\n                mem::swap(&mut x, &mut y);\n                mem::swap(&mut u, &mut v);\n            }\n            assert!(\n                x == Mod::Output::zero()\n                    && y == Mod::Output::one()\n                    && (u == Mod::VALUE || u == -Mod::VALUE)\n                    && (-Mod::VALUE < v && v < Mod::VALUE)\n            );\n            Self(Self::normalize_from_the_top(v))\n        }\n\n        pub fn pow(mut self, mut p: u64) -> Self {\n            let mut ans = Self::one();\n            while p != 0 {\n                if p % 2 == 1 {\n                    ans *= self;\n                }\n                self *= self;\n                p /= 2;\n            }\n            ans\n        }\n\n        #[inline]\n        fn normalize(src: Mod::Output) -> Mod::Output {\n            Self::normalize_from_the_top(src % Mod::VALUE)\n        }\n\n        #[inline]\n        fn normalize_from_the_bottom(src: Mod::Output) -> Mod::Output {\n            if Mod::VALUE <= src {\n                src - Mod::VALUE\n            } else {\n                src\n            }\n        }\n\n        #[inline]\n        fn normalize_from_the_top(src: Mod::Output) -> Mod::Output {\n            if src < Mod::Output::zero() {\n                src + Mod::VALUE\n            } else {\n                src\n            }\n        }\n    }\n\n    impl<Mod: Modable> Zero for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        #[inline]\n        fn zero() -> Fp<Mod> {\n            Fp::new(Mod::Output::zero())\n        }\n        fn times(self, n: u64) -> Fp<Mod> {\n            self * Fp::from_u64(n)\n        }\n        fn times_assign(&mut self, n: u64) {\n            *self *= Fp::from_u64(n)\n        }\n        fn from_u64(n: u64) -> Fp<Mod> {\n            Fp::new(Mod::Output::from_u64(n))\n        }\n    }\n\n    impl<Mod: Modable> One for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        #[inline]\n        fn one() -> Fp<Mod> {\n            Fp::new(Mod::Output::one())\n        }\n    }\n\n    impl<Mod: Modable> iter::Sum<Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = Fp<Mod>>,\n        {\n            iter.fold(Fp::zero(), Add::add)\n        }\n    }\n\n    impl<'a, Mod: 'a + Modable> iter::Sum<&'a Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = &'a Fp<Mod>>,\n        {\n            iter.fold(Fp::zero(), Add::add)\n        }\n    }\n\n    impl<Mod: Modable> iter::Product<Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn product<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = Fp<Mod>>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n\n    impl<'a, Mod: 'a + Modable> iter::Product<&'a Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn product<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = &'a Fp<Mod>>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n\n    impl<Mod: Modable> fmt::Display for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    pub trait Modable: Constant + Clone + fmt::Debug + cmp::PartialEq + cmp::Eq {}\n    impl<Mod: Constant + Clone + fmt::Debug + cmp::PartialEq + cmp::Eq> Modable for Mod {}\n\n    pub trait Value:\n        Sized\n        + Clone\n        + Copy\n        + Ring\n        + fmt::Debug\n        + fmt::Display\n        + cmp::PartialOrd\n        + cmp::Ord\n        + cmp::Eq\n        + Div<Output = Self>\n        + Rem<Output = Self>\n        + Neg<Output = Self>\n        + DivAssign\n        + RemAssign\n    {\n    }\n\n    macro_rules! impl_value {\n        ($($type:ty,)*) => { $(impl Value for $type {})* };\n    }\n\n    impl_value! { i8, i16, i32, i64, i128, isize, }\n\n    mod aliases {\n        use super::Fp;\n        use crate::type_traits::Constant;\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n        pub struct Mod1000000007 {}\n        pub type F1000000007 = Fp<Mod1000000007>;\n        impl Constant for Mod1000000007 {\n            type Output = i64;\n            const VALUE: i64 = 1_000_000_007;\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n        pub struct Mod998244353 {}\n        pub type F998244353 = Fp<Mod998244353>;\n        impl Constant for Mod998244353 {\n            type Output = i64;\n            const VALUE: i64 = 998_244_353;\n        }\n    }\n}\n// }}}\n// dbg {{{\n#[allow(dead_code)]\nmod dbg {\n    #[macro_export]\n    macro_rules! lg {\n        () => {\n            $crate::eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n        };\n        ($val:expr) => {\n            match $val {\n                tmp => {\n                    eprintln!(\"[{}:{}] {} = {:?}\",\n                        file!(), line!(), stringify!($val), &tmp);\n                    tmp\n                }\n            }\n        };\n        ($val:expr,) => { $crate::lg!($val) };\n        ($($val:expr),+ $(,)?) => {\n            ($($crate::lg!($val)),+,)\n        };\n    }\n\n    #[macro_export]\n    macro_rules! lg_nl {\n        () => {\n            eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n        };\n        ($val:expr) => {\n            match $val {\n                tmp => {\n                    eprintln!(\"[{}:{}] {}:\\n{:?}\", file!(), line!(), stringify!($val), tmp);\n                    tmp\n                }\n            };\n        };\n    }\n\n    #[macro_export]\n    macro_rules! msg {\n        () => {\n            compile_error!();\n        };\n        ($msg:expr) => {\n            $crate::eprintln!(\"[{}:{}][{}]\", $crate::file!(), $crate::line!(), $msg);\n        };\n        ($msg:expr, $val:expr) => {\n            match $val {\n                tmp => {\n                    eprintln!(\"[{}:{}][{}] {} = {:?}\",\n                        file!(), line!(), $msg, stringify!($val), &tmp);\n                    tmp\n                }\n            }\n        };\n        ($msg:expr, $val:expr,) => { msg!($msg, $val) };\n        ($msg:expr, $($val:expr),+ $(,)?) => {\n            ($(msg!($msg, $val)),+,)\n        };\n    }\n\n    #[macro_export]\n    macro_rules! tabular {\n        ($val:expr) => {\n            $crate::lg_nl!(crate::dbg::Tabular($val))\n        };\n    }\n\n    #[macro_export]\n    macro_rules! boolean_table {\n        ($val:expr) => {\n            $crate::lg_nl!(crate::dbg::BooleanTable($val));\n        };\n    }\n\n    #[macro_export]\n    macro_rules! boolean_slice {\n        ($val:expr) => {\n            $crate::lg!(crate::dbg::BooleanSlice($val));\n        };\n    }\n\n    use std::fmt::{Debug, Formatter};\n\n    #[derive(Clone)]\n    pub struct Tabular<'a, T: Debug>(pub &'a [T]);\n    impl<'a, T: Debug> Debug for Tabular<'a, T> {\n        fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n            for i in 0..self.0.len() {\n                writeln!(f, \"{:2} | {:?}\", i, &self.0[i])?;\n            }\n            Ok(())\n        }\n    }\n\n    #[derive(Clone)]\n    pub struct BooleanTable<'a>(pub &'a [Vec<bool>]);\n    impl<'a> Debug for BooleanTable<'a> {\n        fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n            for i in 0..self.0.len() {\n                writeln!(f, \"{:2} | {:?}\", i, BooleanSlice(&self.0[i]))?;\n            }\n            Ok(())\n        }\n    }\n\n    #[derive(Clone)]\n    pub struct BooleanSlice<'a>(pub &'a [bool]);\n    impl<'a> Debug for BooleanSlice<'a> {\n        fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n            write!(\n                f,\n                \"{}\",\n                self.0\n                    .iter()\n                    .map(|&b| if b { \"1 \" } else { \"0 \" })\n                    .collect::<String>()\n            )?;\n            Ok(())\n        }\n    }\n}\n// }}}\n// type_traits {{{\n#[allow(dead_code)]\nmod type_traits {\n    #![warn(missing_docs)]\n\n    use std::{cmp, fmt, ops};\n\n    mod primitive {\n        use super::{One, Zero};\n\n        macro_rules! int {\n            ($($T:ty,)*) => {\n                $(\n                    impl Zero for $T {\n                        fn zero() -> $T {\n                            0\n                        }\n                        fn times(self, n: u64) -> $T {\n                            self * n as $T\n                        }\n                        fn times_assign(&mut self, n: u64) {\n                            *self *= n as $T\n                        }\n                        fn from_u64(n: u64) -> $T {\n                            n as $T\n                        }\n                    }\n                    impl One for $T {\n                        fn one() -> $T {\n                            1\n                        }\n                    }\n                )*\n            }\n        }\n\n        int! {\n            u8, u16, u32, u64, u128, usize,\n            i8, i16, i32, i64, i128, isize,\n        }\n    }\n\n    pub mod wrappers {\n        use super::{Assoc, Element, Identity, One, Zero};\n        use std::ops;\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Add<T>(pub T);\n        impl<T> Assoc for Add<T>\n        where\n            T: ops::Add<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Add(self.0 + rhs.0)\n            }\n        }\n        impl<T> Identity for Add<T>\n        where\n            T: Zero,\n        {\n            fn identity() -> Self {\n                Add(T::zero())\n            }\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Mul<T>(pub T);\n\n        impl<T> Assoc for Mul<T>\n        where\n            T: ops::Mul<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Mul(self.0 * rhs.0)\n            }\n        }\n        impl<T> Identity for Mul<T>\n        where\n            T: One,\n        {\n            fn identity() -> Self {\n                Mul(T::one())\n            }\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Affine<T> {\n            pub a: T,\n            pub b: T,\n        }\n\n        impl<T> Assoc for Affine<T>\n        where\n            T: ops::Add<Output = T> + Element,\n            T: ops::Mul<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Self {\n                    a: self.a.clone() * rhs.a,\n                    b: self.b + self.a * rhs.b,\n                }\n            }\n        }\n        impl<T> Identity for Affine<T>\n        where\n            T: Zero + One,\n        {\n            fn identity() -> Self {\n                Self {\n                    a: T::one(),\n                    b: T::zero(),\n                }\n            }\n        }\n\n        #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Cat(pub String);\n\n        impl Assoc for Cat {\n            fn op(self, rhs: Self) -> Self {\n                Cat(self.0.chars().chain(rhs.0.chars()).collect())\n            }\n        }\n        impl Identity for Cat {\n            fn identity() -> Self {\n                Cat(String::new())\n            }\n        }\n    }\n\n    pub trait Element: Sized + Clone + PartialEq + fmt::Debug {}\n    impl<T: Sized + Clone + PartialEq + fmt::Debug> Element for T {}\n\n    pub trait Assoc: Element {\n        fn op(self, rhs: Self) -> Self;\n\n        fn op_from_left(&mut self, left: &Self) {\n            *self = Self::op(left.clone(), self.clone());\n        }\n\n        fn op_from_right(&mut self, right: &Self) {\n            *self = Self::op(self.clone(), right.clone());\n        }\n    }\n\n    pub trait Identity: Assoc {\n        fn identity() -> Self;\n    }\n\n    pub trait Zero: ops::Add<Output = Self> + ops::AddAssign + Element {\n        fn zero() -> Self;\n\n        fn is_zero(&self) -> bool\n        where\n            Self: cmp::PartialEq,\n        {\n            self == &Self::zero()\n        }\n\n        fn times(self, n: u64) -> Self;\n\n        fn times_assign(&mut self, n: u64);\n\n        fn from_u64(x: u64) -> Self;\n    }\n\n    pub trait One: ops::Mul<Output = Self> + ops::MulAssign + Element {\n        fn one() -> Self;\n\n        fn is_one(&self) -> bool\n        where\n            Self: cmp::PartialEq,\n        {\n            self == &Self::one()\n        }\n    }\n\n    pub trait Ring: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign {}\n    impl<T: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign> Ring for T {}\n\n    #[macro_export]\n    macro_rules! define_constant {\n        ($(#[$attr:meta])? $vis:vis type $wrapper_type:ident: $value_type:ty = $value:expr;) => {\n            $(#[$attr])?\n            #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n            $vis struct $wrapper_type {}\n\n            impl Constant for $wrapper_type {\n                type Output = $value_type;\n                const VALUE: Self::Output = $value;\n            }\n        };\n    }\n\n    pub trait Constant: Copy {\n        type Output: Copy;\n\n        const VALUE: Self::Output;\n    }\n}\n// }}}\n\nuse type_traits::{One, Zero};\ntype Fp = fp::F998244353;\n\n#[allow(dead_code)]\nfn guess(x: Fp) -> (i64, i64) {\n    for i in 2..1000 {\n        for j in 2..1000 {\n            if x == Fp::frac(i, j) {\n                return (i, j);\n            }\n        }\n    }\n    (x.into_inner(), 1)\n}\n\nfn main() {\n    let mut buf = ngtio::Buffer::new();\n    let n = buf.usize();\n    let k = buf.usize();\n    let a = iter::repeat_with(|| buf.usize() - 1)\n        .take(n)\n        .collect::<Vec<_>>();\n\n    let p = Fp::one() - Fp::new(k as i64).inv();\n    let mut pow_p = vec![Fp::zero(); n + 1];\n    pow_p[0] = Fp::one();\n    for i in 0..n {\n        pow_p[i + 1] = pow_p[i] * p;\n    }\n\n    let mut plus = vec![0; n];\n    let mut minus = vec![0; n];\n    for (i, &x) in a.iter().enumerate() {\n        for j in i + 1..n {\n            let y = a[j];\n            let d = std::cmp::min(j - i, j.saturating_sub(k - 1));\n            if x < y {\n                plus[d] += 1;\n            } else {\n                minus[d] += 1;\n            }\n        }\n    }\n\n    let mut ans = Fp::zero();\n    for i in 0..n {\n        let q = pow_p[i] / Fp::new(2);\n        ans += q * Fp::new(plus[i] as i64);\n        ans += (Fp::one() - q) * Fp::new(minus[i] as i64);\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(clippy::many_single_char_names)]\n\nuse type_traits::{One, Zero};\ntype Fp = fp::F998244353;\n\n#[allow(dead_code)]\nfn guess(x: Fp) -> (i64, i64) {\n    for i in 2..1000 {\n        for j in 2..1000 {\n            if x == Fp::frac(i, j) {\n                return (i, j);\n            }\n        }\n    }\n    (x.into_inner(), 1)\n}\n\nfn main() {\n    let mut buf = ngtio::Buffer::new();\n    let n = buf.usize();\n    let k = buf.usize();\n    let a = iter::repeat_with(|| buf.usize() - 1)\n        .take(n)\n        .collect::<Vec<_>>();\n    let mut b = (0..n)\n        .map(|i| (a[i], i.saturating_sub(k - 1)))\n        .collect::<Vec<_>>();\n    b.sort();\n    let b = b.iter().map(|&(_, i)| i).collect::<Vec<_>>();\n\n    let p = Fp::one() - Fp::new(k as i64).inv();\n    let mut pow_p = vec![Fp::one(); n - k + 1];\n    for i in 1..n - k + 1 {\n        pow_p[i] = pow_p[i - 1] * p;\n    }\n\n    let mut fwk0 = fenwick::Fenwick::from_zero_slice(0, &vec![0; n - k + 1]);\n    let mut fwk1 = fenwick::Fenwick::from_zero_slice(Fp::zero(), &vec![Fp::zero(); n - k + 1]);\n    let mut fwk2 = fenwick::Fenwick::from_zero_slice(Fp::zero(), &vec![Fp::zero(); n - k + 1]);\n    let mut invertion = 0;\n    let mut plus = vec![Fp::zero(); n - k + 1];\n    let mut minus = vec![Fp::zero(); n - k + 1];\n    for &x in &b {\n        invertion += fwk0.sum(x + 1..);\n        plus[x] += fwk1.sum(..x);\n        minus[x] += fwk2.sum(x + 1..);\n        fwk0.add(x, 1);\n        fwk1.add(x, pow_p[x].inv());\n        fwk2.add(x, pow_p[x]);\n    }\n\n    let ans = (0..n - k + 1)\n        .map(|i| plus[i] * pow_p[i] - minus[i] * pow_p[i].inv())\n        .sum::<Fp>();\n    let ans = Fp::new(invertion as i64)\n        + ans / Fp::new(2)\n        + Fp::new((k * (k - 1) / 2) as i64) / Fp::new(2);\n    println!(\"{}\", ans);\n}\n\n// template {{{\n#[allow(dead_code)]\nmod ngtio {\n    use ::std::collections::VecDeque;\n\n    pub struct Buffer {\n        buf: VecDeque<String>,\n    }\n\n    impl Buffer {\n        pub fn new() -> Self {\n            Self {\n                buf: VecDeque::new(),\n            }\n        }\n\n        fn load(&mut self) {\n            while self.buf.is_empty() {\n                let mut s = String::new();\n                let length = ::std::io::stdin().read_line(&mut s).unwrap();\n                if length == 0 {\n                    break;\n                }\n                self.buf.extend(s.split_whitespace().map(|s| s.to_owned()));\n            }\n        }\n\n        pub fn string(&mut self) -> String {\n            self.load();\n            self.buf\n                .pop_front()\n                .unwrap_or_else(|| panic!(\"入力が終了したのですが。\"))\n        }\n\n        pub fn string_char_vec(&mut self) -> Vec<char> {\n            let s = self.string();\n            s.chars().collect::<Vec<_>>()\n        }\n\n        pub fn string_char_vec_trusted_len(&mut self, len: usize) -> Vec<char> {\n            let s = self.string();\n            let s = s.chars().collect::<Vec<_>>();\n            assert_eq!(s.len(), len, \"あら、思ったのと長さ違いますね……\");\n            s\n        }\n\n        pub fn char(&mut self) -> char {\n            let string = self.string();\n            let mut chars = string.chars();\n            let res = chars.next().unwrap();\n            assert!(\n                chars.next().is_none(),\n                \"char で受け取りたいのも山々なのですが、さては 2 文字以上ありますね？\"\n            );\n            res\n        }\n\n        pub fn read<T: ::std::str::FromStr>(&mut self) -> T\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            self.string()\n                .parse::<T>()\n                .expect(\"Failed to parse the input.\")\n        }\n\n        pub fn read_vec<T: ::std::str::FromStr>(&mut self, len: usize) -> Vec<T>\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            (0..len).map(|_| self.read::<T>()).collect()\n        }\n    }\n\n    macro_rules! define_primitive_reader {\n        ($($ty:tt,)*) => {\n            impl Buffer {\n                $(\n#[inline]\n                    pub fn $ty(&mut self) -> $ty {\n                        self.read::<$ty>()\n                    }\n                )*\n            }\n        }\n    }\n\n    define_primitive_reader! {\n        u8, u16, u32, u64, usize,\n        i8, i16, i32, i64, isize,\n    }\n\n    impl Default for Buffer {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n}\n\n#[allow(unused_imports)]\nuse std::{collections, iter, mem, ops};\n// }}}\n// fp {{{\n#[allow(dead_code)]\nmod fp {\n    #![warn(missing_docs)]\n    use crate::type_traits::*;\n    pub use aliases::*;\n    use std::{cmp, fmt, iter, mem, ops::*};\n\n    mod arith {\n        use super::{Fp, Modable, Value};\n        use crate::type_traits::*;\n        use std::ops::*;\n\n        impl<Mod: Modable> Add for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn add(self, rhs: Self) -> Self {\n                Self(Self::normalize_from_the_bottom(\n                    self.into_inner() + rhs.into_inner(),\n                ))\n            }\n        }\n\n        impl<Mod: Modable> Sub for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn sub(self, rhs: Self) -> Self {\n                Self(Self::normalize_from_the_top(\n                    self.into_inner() - rhs.into_inner(),\n                ))\n            }\n        }\n\n        impl<Mod: Modable> Mul for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn mul(self, rhs: Self) -> Self {\n                Self::new(self.into_inner() * rhs.into_inner())\n            }\n        }\n\n        #[allow(clippy::suspicious_arithmetic_impl)]\n        impl<Mod: Modable> Div for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn div(self, rhs: Self) -> Self {\n                self * rhs.inv()\n            }\n        }\n\n        impl<Mod: Modable> Neg for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn neg(self) -> Self {\n                if self.into_inner().is_zero() {\n                    Self::zero()\n                } else {\n                    Self(Mod::VALUE - self.into_inner())\n                }\n            }\n        }\n\n        impl<Mod: Modable> Neg for &Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Fp<Mod>;\n\n            #[inline]\n            fn neg(self) -> Fp<Mod> {\n                if self.into_inner().is_zero() {\n                    Fp::zero()\n                } else {\n                    Fp(Mod::VALUE - self.into_inner())\n                }\n            }\n        }\n\n        macro_rules! forward_assign_biop {\n            ($(impl $trait:ident, $fn_assign:ident, $fn:ident)*) => {\n                $(\n                    impl<Mod: Modable> $trait for Fp<Mod>\n                    where\n                        Mod::Output: Value\n                    {\n                        #[inline]\n                        fn $fn_assign(&mut self, rhs: Self) {\n                            *self = self.$fn(rhs);\n                        }\n                    }\n                )*\n            };\n        }\n        forward_assign_biop! {\n            impl AddAssign, add_assign, add\n            impl SubAssign, sub_assign, sub\n            impl MulAssign, mul_assign, mul\n            impl DivAssign, div_assign, div\n        }\n\n        macro_rules! forward_ref_binop {\n            ($(impl $imp:ident, $method:ident)*) => {\n                $(\n                    impl<'a, Mod: Modable> $imp<Fp<Mod>> for &'a Fp<Mod>\n                    where\n                        Mod::Output:Value\n                    {\n                        type Output = Fp<Mod>;\n\n                        #[inline]\n                        fn $method(self, other: Fp<Mod>) -> Self::Output {\n                            $imp::$method(*self, other)\n                        }\n                    }\n\n                    impl<'a, Mod: Modable> $imp<&'a Fp<Mod>> for Fp<Mod>\n                    where\n                        Mod::Output:Value\n                    {\n                        type Output = Fp<Mod>;\n\n                        #[inline]\n                        fn $method(self, other: &Fp<Mod>) -> Self::Output {\n                            $imp::$method(self, *other)\n                        }\n                    }\n\n                    impl<'a, Mod: Modable> $imp<&'a Fp<Mod>> for &'a Fp<Mod>\n                    where\n                        Mod::Output:Value\n                    {\n                        type Output = Fp<Mod>;\n\n                        #[inline]\n                        fn $method(self, other: &Fp<Mod>) -> Self::Output {\n                            $imp::$method(*self, *other)\n                        }\n                    }\n                )*\n            };\n        }\n        forward_ref_binop! {\n            impl Add, add\n            impl Sub, sub\n            impl Mul, mul\n            impl Div, div\n        }\n    }\n\n    #[macro_export]\n    macro_rules! fp_vec {\n        () => (\n            Vec::<$crate::Fp<_>>::new()\n        );\n        ($elem:expr; $n:expr) => (\n            vec![$crate::Fp::new($elem); $n]\n        );\n        ($($x:expr),+ $(,)?) => (\n            vec![$($crate::Fp::new($x),)+];\n        );\n    }\n\n    #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    pub struct Fp<Mod: Modable>(Mod::Output);\n\n    impl<Mod: Modable> Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        #[inline]\n        pub fn new(src: Mod::Output) -> Self {\n            Self(Self::normalize(src))\n        }\n\n        #[inline]\n        pub fn frac(num: Mod::Output, den: Mod::Output) -> Self {\n            Self::new(num) / Self::new(den)\n        }\n\n        #[inline]\n        pub fn into_inner(self) -> Mod::Output {\n            self.0\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        pub fn inv(self) -> Self {\n            assert_ne!(\n                self.into_inner(),\n                Mod::Output::zero(),\n                \"さては 0 の逆元を取ろうとしていますね？\"\n            );\n            let mut x = self.into_inner();\n            let mut y = Mod::VALUE;\n            let mut u = Mod::Output::one();\n            let mut v = Mod::Output::zero();\n            while x != Mod::Output::zero() {\n                let q = y / x;\n                y -= q * x;\n                v -= q * u;\n                mem::swap(&mut x, &mut y);\n                mem::swap(&mut u, &mut v);\n            }\n            assert!(\n                x == Mod::Output::zero()\n                    && y == Mod::Output::one()\n                    && (u == Mod::VALUE || u == -Mod::VALUE)\n                    && (-Mod::VALUE < v && v < Mod::VALUE)\n            );\n            Self(Self::normalize_from_the_top(v))\n        }\n\n        pub fn pow(mut self, mut p: u64) -> Self {\n            let mut ans = Self::one();\n            while p != 0 {\n                if p % 2 == 1 {\n                    ans *= self;\n                }\n                self *= self;\n                p /= 2;\n            }\n            ans\n        }\n\n        #[inline]\n        fn normalize(src: Mod::Output) -> Mod::Output {\n            Self::normalize_from_the_top(src % Mod::VALUE)\n        }\n\n        #[inline]\n        fn normalize_from_the_bottom(src: Mod::Output) -> Mod::Output {\n            if Mod::VALUE <= src {\n                src - Mod::VALUE\n            } else {\n                src\n            }\n        }\n\n        #[inline]\n        fn normalize_from_the_top(src: Mod::Output) -> Mod::Output {\n            if src < Mod::Output::zero() {\n                src + Mod::VALUE\n            } else {\n                src\n            }\n        }\n    }\n\n    impl<Mod: Modable> Zero for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        #[inline]\n        fn zero() -> Fp<Mod> {\n            Fp::new(Mod::Output::zero())\n        }\n        fn times(self, n: u64) -> Fp<Mod> {\n            self * Fp::from_u64(n)\n        }\n        fn times_assign(&mut self, n: u64) {\n            *self *= Fp::from_u64(n)\n        }\n        fn from_u64(n: u64) -> Fp<Mod> {\n            Fp::new(Mod::Output::from_u64(n))\n        }\n    }\n\n    impl<Mod: Modable> One for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        #[inline]\n        fn one() -> Fp<Mod> {\n            Fp::new(Mod::Output::one())\n        }\n    }\n\n    impl<Mod: Modable> iter::Sum<Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = Fp<Mod>>,\n        {\n            iter.fold(Fp::zero(), Add::add)\n        }\n    }\n\n    impl<'a, Mod: 'a + Modable> iter::Sum<&'a Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = &'a Fp<Mod>>,\n        {\n            iter.fold(Fp::zero(), Add::add)\n        }\n    }\n\n    impl<Mod: Modable> iter::Product<Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn product<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = Fp<Mod>>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n\n    impl<'a, Mod: 'a + Modable> iter::Product<&'a Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn product<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = &'a Fp<Mod>>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n\n    impl<Mod: Modable> fmt::Display for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    pub trait Modable: Constant + Clone + fmt::Debug + cmp::PartialEq + cmp::Eq {}\n    impl<Mod: Constant + Clone + fmt::Debug + cmp::PartialEq + cmp::Eq> Modable for Mod {}\n\n    pub trait Value:\n        Sized\n        + Clone\n        + Copy\n        + Ring\n        + fmt::Debug\n        + fmt::Display\n        + cmp::PartialOrd\n        + cmp::Ord\n        + cmp::Eq\n        + Div<Output = Self>\n        + Rem<Output = Self>\n        + Neg<Output = Self>\n        + DivAssign\n        + RemAssign\n    {\n    }\n\n    macro_rules! impl_value {\n        ($($type:ty,)*) => { $(impl Value for $type {})* };\n    }\n\n    impl_value! { i8, i16, i32, i64, i128, isize, }\n\n    mod aliases {\n        use super::Fp;\n        use crate::type_traits::Constant;\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n        pub struct Mod1000000007 {}\n        pub type F1000000007 = Fp<Mod1000000007>;\n        impl Constant for Mod1000000007 {\n            type Output = i64;\n            const VALUE: i64 = 1_000_000_007;\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n        pub struct Mod998244353 {}\n        pub type F998244353 = Fp<Mod998244353>;\n        impl Constant for Mod998244353 {\n            type Output = i64;\n            const VALUE: i64 = 998_244_353;\n        }\n    }\n}\n// }}}\n// type_traits {{{\n#[allow(dead_code)]\nmod type_traits {\n    #![warn(missing_docs)]\n\n    use std::{cmp, fmt, ops};\n\n    mod primitive {\n        use super::{One, Zero};\n\n        macro_rules! int {\n            ($($T:ty,)*) => {\n                $(\n                    impl Zero for $T {\n                        fn zero() -> $T {\n                            0\n                        }\n                        fn times(self, n: u64) -> $T {\n                            self * n as $T\n                        }\n                        fn times_assign(&mut self, n: u64) {\n                            *self *= n as $T\n                        }\n                        fn from_u64(n: u64) -> $T {\n                            n as $T\n                        }\n                    }\n                    impl One for $T {\n                        fn one() -> $T {\n                            1\n                        }\n                    }\n                )*\n            }\n        }\n\n        int! {\n            u8, u16, u32, u64, u128, usize,\n            i8, i16, i32, i64, i128, isize,\n        }\n    }\n\n    pub mod wrappers {\n        use super::{Assoc, Element, Identity, One, Zero};\n        use std::ops;\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Add<T>(pub T);\n        impl<T> Assoc for Add<T>\n        where\n            T: ops::Add<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Add(self.0 + rhs.0)\n            }\n        }\n        impl<T> Identity for Add<T>\n        where\n            T: Zero,\n        {\n            fn identity() -> Self {\n                Add(T::zero())\n            }\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Mul<T>(pub T);\n\n        impl<T> Assoc for Mul<T>\n        where\n            T: ops::Mul<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Mul(self.0 * rhs.0)\n            }\n        }\n        impl<T> Identity for Mul<T>\n        where\n            T: One,\n        {\n            fn identity() -> Self {\n                Mul(T::one())\n            }\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Affine<T> {\n            pub a: T,\n            pub b: T,\n        }\n\n        impl<T> Assoc for Affine<T>\n        where\n            T: ops::Add<Output = T> + Element,\n            T: ops::Mul<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Self {\n                    a: self.a.clone() * rhs.a,\n                    b: self.b + self.a * rhs.b,\n                }\n            }\n        }\n        impl<T> Identity for Affine<T>\n        where\n            T: Zero + One,\n        {\n            fn identity() -> Self {\n                Self {\n                    a: T::one(),\n                    b: T::zero(),\n                }\n            }\n        }\n\n        #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Cat(pub String);\n\n        impl Assoc for Cat {\n            fn op(self, rhs: Self) -> Self {\n                Cat(self.0.chars().chain(rhs.0.chars()).collect())\n            }\n        }\n        impl Identity for Cat {\n            fn identity() -> Self {\n                Cat(String::new())\n            }\n        }\n    }\n\n    pub trait Element: Sized + Clone + PartialEq + fmt::Debug {}\n    impl<T: Sized + Clone + PartialEq + fmt::Debug> Element for T {}\n\n    pub trait Assoc: Element {\n        fn op(self, rhs: Self) -> Self;\n\n        fn op_from_left(&mut self, left: &Self) {\n            *self = Self::op(left.clone(), self.clone());\n        }\n\n        fn op_from_right(&mut self, right: &Self) {\n            *self = Self::op(self.clone(), right.clone());\n        }\n    }\n\n    pub trait Identity: Assoc {\n        fn identity() -> Self;\n    }\n\n    pub trait Zero: ops::Add<Output = Self> + ops::AddAssign + Element {\n        fn zero() -> Self;\n\n        fn is_zero(&self) -> bool\n        where\n            Self: cmp::PartialEq,\n        {\n            self == &Self::zero()\n        }\n\n        fn times(self, n: u64) -> Self;\n\n        fn times_assign(&mut self, n: u64);\n\n        fn from_u64(x: u64) -> Self;\n    }\n\n    pub trait One: ops::Mul<Output = Self> + ops::MulAssign + Element {\n        fn one() -> Self;\n\n        fn is_one(&self) -> bool\n        where\n            Self: cmp::PartialEq,\n        {\n            self == &Self::one()\n        }\n    }\n\n    pub trait Ring: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign {}\n    impl<T: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign> Ring for T {}\n\n    #[macro_export]\n    macro_rules! define_constant {\n        ($(#[$attr:meta])? $vis:vis type $wrapper_type:ident: $value_type:ty = $value:expr;) => {\n            $(#[$attr])?\n            #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n            $vis struct $wrapper_type {}\n\n            impl Constant for $wrapper_type {\n                type Output = $value_type;\n                const VALUE: Self::Output = $value;\n            }\n        };\n    }\n\n    pub trait Constant: Copy {\n        type Output: Copy;\n\n        const VALUE: Self::Output;\n    }\n}\n// }}}\n// fenwick {{{\n#[allow(dead_code)]\nmod fenwick {\n    use std::{fmt, iter, ops};\n\n    #[derive(Debug, Clone)]\n    pub struct Fenwick<T> {\n        table: Vec<T>,\n    }\n\n    impl<'a, T> Fenwick<T>\n    where\n        T: Clone + fmt::Debug + ops::Add<Output = T> + ops::AddAssign + iter::Sum<T>,\n    {\n        pub fn new(zero: T) -> Self {\n            Fenwick { table: vec![zero] }\n        }\n\n        pub fn from_zero_slice(zero: T, src: &[T]) -> Self {\n            let mut table = iter::once(zero)\n                .chain(src.iter().cloned())\n                .collect::<Vec<_>>();\n            let n = table.len();\n            (1..n)\n                .map(|i| (i, i + lsb(i)))\n                .filter(|&(_, j)| j < n)\n                .for_each(|(i, j)| {\n                    let x = table[i].clone();\n                    table[j] += x\n                });\n            Self { table }\n        }\n\n        pub fn push(&mut self, mut x: T) {\n            let i = self.table.len();\n            let lsb_i = lsb(i);\n            x += iter::successors(Some(1), |&d| Some(2 * d))\n                .take_while(|&d| d != lsb_i)\n                .map(|d| self.table[i - d].clone())\n                .sum::<T>();\n            self.table.push(x);\n        }\n\n        pub fn prefix_sum(&self, i: usize) -> T {\n            iter::successors(Some(i), |&i| Some(i - lsb(i)))\n                .take_while(|&i| i != 0)\n                .map(|i| self.table[i].clone())\n                .sum::<T>()\n        }\n\n        pub fn add(&mut self, i: usize, x: T) {\n            let n = self.table.len();\n            iter::successors(Some(i + 1), |&i| Some(i + lsb(i)))\n                .take_while(|&i| i < n)\n                .for_each(|i| self.table[i] += x.clone());\n        }\n\n        pub fn partition_point(&self, pred: impl Fn(usize, &T) -> bool) -> (usize, T) {\n            let mut j = 0;\n            let mut current = self.table[0].clone();\n            for d in iter::successors(Some(self.table.len().next_power_of_two() / 2), |&d| {\n                Some(d / 2)\n            })\n            .take_while(|&d| d != 0)\n            {\n                assert!(\n                    pred(0, &self.table[0]),\n                    \"pred(0, zero) のほうよろしくお願いいたします！\"\n                );\n                if j + d < self.table.len() {\n                    let next = current.clone() + self.table[j + d].clone();\n                    if pred(j + d, &next) {\n                        current = next;\n                        j += d;\n                    }\n                }\n            }\n            (j, current)\n        }\n\n        #[inline]\n        pub fn lower_bound(&self, x: &T) -> usize\n        where\n            T: Ord,\n        {\n            self.partition_point(|_, y| y < x).0\n        }\n\n        #[inline]\n        pub fn upper_bound(&self, x: &T) -> usize\n        where\n            T: Ord,\n        {\n            self.partition_point(|_, y| y <= x).0\n        }\n\n        #[inline]\n        pub fn lower_bound_from(&self, i: usize, x: &T) -> usize\n        where\n            T: Ord,\n        {\n            let bi = self.prefix_sum(i);\n            let res = self.partition_point(|_, y| y < &(bi.clone() + x.clone())).0;\n            assert!(i <= res, \"逆戻りしていませんか？\");\n            res\n        }\n\n        #[inline]\n        pub fn upper_bound_from(&self, i: usize, x: &T) -> usize\n        where\n            T: Ord,\n        {\n            let bi = self.prefix_sum(i);\n            let res = self\n                .partition_point(|_, y| y <= &(bi.clone() + x.clone()))\n                .0;\n            assert!(i <= res, \"逆戻りしていませんか？\");\n            res\n        }\n    }\n\n    impl<'a, T> Fenwick<T>\n    where\n        T: Clone\n            + fmt::Debug\n            + ops::Add<Output = T>\n            + ops::AddAssign\n            + ops::Sub<Output = T>\n            + ops::SubAssign\n            + iter::Sum<T>,\n    {\n        pub fn sum(&self, range: impl ops::RangeBounds<usize>) -> T {\n            let start = match range.start_bound() {\n                ops::Bound::Unbounded => 0,\n                ops::Bound::Included(&x) => x,\n                ops::Bound::Excluded(&x) => x + 1,\n            };\n            let end = match range.end_bound() {\n                ops::Bound::Excluded(&x) => x,\n                ops::Bound::Included(&x) => x + 1,\n                ops::Bound::Unbounded => self.table.len() - 1,\n            };\n            assert!(start <= end, \"変な区間を渡すのをやめませんか？\");\n            assert!(end < self.table.len(), \"残念範囲外です！\");\n            self.prefix_sum(end) - self.prefix_sum(start)\n        }\n\n        pub fn access(&self, i: usize) -> T {\n            assert!(i < self.table.len() - 1, \"残念範囲外です！\");\n            self.prefix_sum(i + 1) - self.prefix_sum(i)\n        }\n\n        pub fn set(&mut self, i: usize, x: T) {\n            assert!(i < self.table.len() - 1, \"残念範囲外です！\");\n            self.add(i, x - self.access(i));\n        }\n    }\n\n    fn lsb(x: usize) -> usize {\n        x & x.wrapping_neg()\n    }\n}\n// }}}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(clippy::many_single_char_names)]\n\nuse type_traits::{One, Zero};\ntype Fp = fp::F998244353;\n\nfn main() {\n    let mut buf = ngtio::Buffer::new();\n    let n = buf.usize();\n    let k = buf.usize();\n    let a = iter::repeat_with(|| buf.usize() - 1)\n        .take(n)\n        .collect::<Vec<_>>();\n    let mut b = (0..n)\n        .map(|i| (a[i], i.saturating_sub(k - 1)))\n        .collect::<Vec<_>>();\n    b.sort();\n    let b = b.iter().map(|&(_, i)| i).collect::<Vec<_>>();\n\n    let p = Fp::one() - Fp::new(k as i64).inv();\n    let mut pow_p = vec![Fp::one(); n - k + 1];\n    for i in 1..n - k + 1 {\n        pow_p[i] = pow_p[i - 1] * p;\n    }\n\n    let mut fwk0 = fenwick::Fenwick::from_zero_slice(0, &vec![0; n - k + 1]);\n    let mut fwk1 = fenwick::Fenwick::from_zero_slice(Fp::zero(), &vec![Fp::zero(); n - k + 1]);\n    let mut fwk2 = fenwick::Fenwick::from_zero_slice(Fp::zero(), &vec![Fp::zero(); n - k + 1]);\n    let mut invertion = 0i64;\n    let mut plus = vec![Fp::zero(); n - k + 1];\n    let mut minus = vec![Fp::zero(); n - k + 1];\n    for &x in &b {\n        invertion += fwk0.sum(x + 1..);\n        plus[x] += fwk1.sum(..x);\n        minus[x] += fwk2.sum(x + 1..);\n        fwk0.add(x, 1);\n        fwk1.add(x, pow_p[x].inv());\n        fwk2.add(x, pow_p[x]);\n    }\n\n    let ans = (0..n - k + 1)\n        .map(|i| plus[i] * pow_p[i] - minus[i] * pow_p[i].inv())\n        .sum::<Fp>();\n    let ans =\n        Fp::new(invertion) + ans / Fp::new(2) + Fp::new((k * (k - 1) / 2) as i64) / Fp::new(2);\n    println!(\"{}\", ans);\n}\n\n// template {{{\n#[allow(dead_code)]\nmod ngtio {\n    use ::std::collections::VecDeque;\n\n    pub struct Buffer {\n        buf: VecDeque<String>,\n    }\n\n    impl Buffer {\n        pub fn new() -> Self {\n            Self {\n                buf: VecDeque::new(),\n            }\n        }\n\n        fn load(&mut self) {\n            while self.buf.is_empty() {\n                let mut s = String::new();\n                let length = ::std::io::stdin().read_line(&mut s).unwrap();\n                if length == 0 {\n                    break;\n                }\n                self.buf.extend(s.split_whitespace().map(|s| s.to_owned()));\n            }\n        }\n\n        pub fn string(&mut self) -> String {\n            self.load();\n            self.buf\n                .pop_front()\n                .unwrap_or_else(|| panic!(\"入力が終了したのですが。\"))\n        }\n\n        pub fn string_char_vec(&mut self) -> Vec<char> {\n            let s = self.string();\n            s.chars().collect::<Vec<_>>()\n        }\n\n        pub fn string_char_vec_trusted_len(&mut self, len: usize) -> Vec<char> {\n            let s = self.string();\n            let s = s.chars().collect::<Vec<_>>();\n            assert_eq!(s.len(), len, \"あら、思ったのと長さ違いますね……\");\n            s\n        }\n\n        pub fn char(&mut self) -> char {\n            let string = self.string();\n            let mut chars = string.chars();\n            let res = chars.next().unwrap();\n            assert!(\n                chars.next().is_none(),\n                \"char で受け取りたいのも山々なのですが、さては 2 文字以上ありますね？\"\n            );\n            res\n        }\n\n        pub fn read<T: ::std::str::FromStr>(&mut self) -> T\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            self.string()\n                .parse::<T>()\n                .expect(\"Failed to parse the input.\")\n        }\n\n        pub fn read_vec<T: ::std::str::FromStr>(&mut self, len: usize) -> Vec<T>\n        where\n            <T as ::std::str::FromStr>::Err: ::std::fmt::Debug,\n        {\n            (0..len).map(|_| self.read::<T>()).collect()\n        }\n    }\n\n    macro_rules! define_primitive_reader {\n        ($($ty:tt,)*) => {\n            impl Buffer {\n                $(\n#[inline]\n                    pub fn $ty(&mut self) -> $ty {\n                        self.read::<$ty>()\n                    }\n                )*\n            }\n        }\n    }\n\n    define_primitive_reader! {\n        u8, u16, u32, u64, usize,\n        i8, i16, i32, i64, isize,\n    }\n\n    impl Default for Buffer {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n}\n\n#[allow(unused_imports)]\nuse std::{collections, iter, mem, ops};\n// }}}\n// fp {{{\n#[allow(dead_code)]\nmod fp {\n    #![warn(missing_docs)]\n    use crate::type_traits::*;\n    pub use aliases::*;\n    use std::{cmp, fmt, iter, mem, ops::*};\n\n    mod arith {\n        use super::{Fp, Modable, Value};\n        use crate::type_traits::*;\n        use std::ops::*;\n\n        impl<Mod: Modable> Add for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn add(self, rhs: Self) -> Self {\n                Self(Self::normalize_from_the_bottom(\n                    self.into_inner() + rhs.into_inner(),\n                ))\n            }\n        }\n\n        impl<Mod: Modable> Sub for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn sub(self, rhs: Self) -> Self {\n                Self(Self::normalize_from_the_top(\n                    self.into_inner() - rhs.into_inner(),\n                ))\n            }\n        }\n\n        impl<Mod: Modable> Mul for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn mul(self, rhs: Self) -> Self {\n                Self::new(self.into_inner() * rhs.into_inner())\n            }\n        }\n\n        #[allow(clippy::suspicious_arithmetic_impl)]\n        impl<Mod: Modable> Div for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn div(self, rhs: Self) -> Self {\n                self * rhs.inv()\n            }\n        }\n\n        impl<Mod: Modable> Neg for Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Self;\n\n            #[inline]\n            fn neg(self) -> Self {\n                if self.into_inner().is_zero() {\n                    Self::zero()\n                } else {\n                    Self(Mod::VALUE - self.into_inner())\n                }\n            }\n        }\n\n        impl<Mod: Modable> Neg for &Fp<Mod>\n        where\n            Mod::Output: Value,\n        {\n            type Output = Fp<Mod>;\n\n            #[inline]\n            fn neg(self) -> Fp<Mod> {\n                if self.into_inner().is_zero() {\n                    Fp::zero()\n                } else {\n                    Fp(Mod::VALUE - self.into_inner())\n                }\n            }\n        }\n\n        macro_rules! forward_assign_biop {\n            ($(impl $trait:ident, $fn_assign:ident, $fn:ident)*) => {\n                $(\n                    impl<Mod: Modable> $trait for Fp<Mod>\n                    where\n                        Mod::Output: Value\n                    {\n                        #[inline]\n                        fn $fn_assign(&mut self, rhs: Self) {\n                            *self = self.$fn(rhs);\n                        }\n                    }\n                )*\n            };\n        }\n        forward_assign_biop! {\n            impl AddAssign, add_assign, add\n            impl SubAssign, sub_assign, sub\n            impl MulAssign, mul_assign, mul\n            impl DivAssign, div_assign, div\n        }\n\n        macro_rules! forward_ref_binop {\n            ($(impl $imp:ident, $method:ident)*) => {\n                $(\n                    impl<'a, Mod: Modable> $imp<Fp<Mod>> for &'a Fp<Mod>\n                    where\n                        Mod::Output:Value\n                    {\n                        type Output = Fp<Mod>;\n\n                        #[inline]\n                        fn $method(self, other: Fp<Mod>) -> Self::Output {\n                            $imp::$method(*self, other)\n                        }\n                    }\n\n                    impl<'a, Mod: Modable> $imp<&'a Fp<Mod>> for Fp<Mod>\n                    where\n                        Mod::Output:Value\n                    {\n                        type Output = Fp<Mod>;\n\n                        #[inline]\n                        fn $method(self, other: &Fp<Mod>) -> Self::Output {\n                            $imp::$method(self, *other)\n                        }\n                    }\n\n                    impl<'a, Mod: Modable> $imp<&'a Fp<Mod>> for &'a Fp<Mod>\n                    where\n                        Mod::Output:Value\n                    {\n                        type Output = Fp<Mod>;\n\n                        #[inline]\n                        fn $method(self, other: &Fp<Mod>) -> Self::Output {\n                            $imp::$method(*self, *other)\n                        }\n                    }\n                )*\n            };\n        }\n        forward_ref_binop! {\n            impl Add, add\n            impl Sub, sub\n            impl Mul, mul\n            impl Div, div\n        }\n    }\n\n    #[macro_export]\n    macro_rules! fp_vec {\n        () => (\n            Vec::<$crate::Fp<_>>::new()\n        );\n        ($elem:expr; $n:expr) => (\n            vec![$crate::Fp::new($elem); $n]\n        );\n        ($($x:expr),+ $(,)?) => (\n            vec![$($crate::Fp::new($x),)+];\n        );\n    }\n\n    #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    pub struct Fp<Mod: Modable>(Mod::Output);\n\n    impl<Mod: Modable> Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        #[inline]\n        pub fn new(src: Mod::Output) -> Self {\n            Self(Self::normalize(src))\n        }\n\n        #[inline]\n        pub fn frac(num: Mod::Output, den: Mod::Output) -> Self {\n            Self::new(num) / Self::new(den)\n        }\n\n        #[inline]\n        pub fn into_inner(self) -> Mod::Output {\n            self.0\n        }\n\n        #[allow(clippy::many_single_char_names)]\n        pub fn inv(self) -> Self {\n            assert_ne!(\n                self.into_inner(),\n                Mod::Output::zero(),\n                \"さては 0 の逆元を取ろうとしていますね？\"\n            );\n            let mut x = self.into_inner();\n            let mut y = Mod::VALUE;\n            let mut u = Mod::Output::one();\n            let mut v = Mod::Output::zero();\n            while x != Mod::Output::zero() {\n                let q = y / x;\n                y -= q * x;\n                v -= q * u;\n                mem::swap(&mut x, &mut y);\n                mem::swap(&mut u, &mut v);\n            }\n            assert!(\n                x == Mod::Output::zero()\n                    && y == Mod::Output::one()\n                    && (u == Mod::VALUE || u == -Mod::VALUE)\n                    && (-Mod::VALUE < v && v < Mod::VALUE)\n            );\n            Self(Self::normalize_from_the_top(v))\n        }\n\n        pub fn pow(mut self, mut p: u64) -> Self {\n            let mut ans = Self::one();\n            while p != 0 {\n                if p % 2 == 1 {\n                    ans *= self;\n                }\n                self *= self;\n                p /= 2;\n            }\n            ans\n        }\n\n        #[inline]\n        fn normalize(src: Mod::Output) -> Mod::Output {\n            Self::normalize_from_the_top(src % Mod::VALUE)\n        }\n\n        #[inline]\n        fn normalize_from_the_bottom(src: Mod::Output) -> Mod::Output {\n            if Mod::VALUE <= src {\n                src - Mod::VALUE\n            } else {\n                src\n            }\n        }\n\n        #[inline]\n        fn normalize_from_the_top(src: Mod::Output) -> Mod::Output {\n            if src < Mod::Output::zero() {\n                src + Mod::VALUE\n            } else {\n                src\n            }\n        }\n    }\n\n    impl<Mod: Modable> Zero for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        #[inline]\n        fn zero() -> Fp<Mod> {\n            Fp::new(Mod::Output::zero())\n        }\n        fn times(self, n: u64) -> Fp<Mod> {\n            self * Fp::from_u64(n)\n        }\n        fn times_assign(&mut self, n: u64) {\n            *self *= Fp::from_u64(n)\n        }\n        fn from_u64(n: u64) -> Fp<Mod> {\n            Fp::new(Mod::Output::from_u64(n))\n        }\n    }\n\n    impl<Mod: Modable> One for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        #[inline]\n        fn one() -> Fp<Mod> {\n            Fp::new(Mod::Output::one())\n        }\n    }\n\n    impl<Mod: Modable> iter::Sum<Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = Fp<Mod>>,\n        {\n            iter.fold(Fp::zero(), Add::add)\n        }\n    }\n\n    impl<'a, Mod: 'a + Modable> iter::Sum<&'a Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn sum<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = &'a Fp<Mod>>,\n        {\n            iter.fold(Fp::zero(), Add::add)\n        }\n    }\n\n    impl<Mod: Modable> iter::Product<Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn product<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = Fp<Mod>>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n\n    impl<'a, Mod: 'a + Modable> iter::Product<&'a Fp<Mod>> for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn product<I>(iter: I) -> Self\n        where\n            I: iter::Iterator<Item = &'a Fp<Mod>>,\n        {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n\n    impl<Mod: Modable> fmt::Display for Fp<Mod>\n    where\n        Mod::Output: Value,\n    {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    pub trait Modable: Constant + Clone + fmt::Debug + cmp::PartialEq + cmp::Eq {}\n    impl<Mod: Constant + Clone + fmt::Debug + cmp::PartialEq + cmp::Eq> Modable for Mod {}\n\n    pub trait Value:\n        Sized\n        + Clone\n        + Copy\n        + Ring\n        + fmt::Debug\n        + fmt::Display\n        + cmp::PartialOrd\n        + cmp::Ord\n        + cmp::Eq\n        + Div<Output = Self>\n        + Rem<Output = Self>\n        + Neg<Output = Self>\n        + DivAssign\n        + RemAssign\n    {\n    }\n\n    macro_rules! impl_value {\n        ($($type:ty,)*) => { $(impl Value for $type {})* };\n    }\n\n    impl_value! { i8, i16, i32, i64, i128, isize, }\n\n    mod aliases {\n        use super::Fp;\n        use crate::type_traits::Constant;\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n        pub struct Mod1000000007 {}\n        pub type F1000000007 = Fp<Mod1000000007>;\n        impl Constant for Mod1000000007 {\n            type Output = i64;\n            const VALUE: i64 = 1_000_000_007;\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n        pub struct Mod998244353 {}\n        pub type F998244353 = Fp<Mod998244353>;\n        impl Constant for Mod998244353 {\n            type Output = i64;\n            const VALUE: i64 = 998_244_353;\n        }\n    }\n}\n// }}}\n// type_traits {{{\n#[allow(dead_code)]\nmod type_traits {\n    #![warn(missing_docs)]\n\n    use std::{cmp, fmt, ops};\n\n    mod primitive {\n        use super::{One, Zero};\n\n        macro_rules! int {\n            ($($T:ty,)*) => {\n                $(\n                    impl Zero for $T {\n                        fn zero() -> $T {\n                            0\n                        }\n                        fn times(self, n: u64) -> $T {\n                            self * n as $T\n                        }\n                        fn times_assign(&mut self, n: u64) {\n                            *self *= n as $T\n                        }\n                        fn from_u64(n: u64) -> $T {\n                            n as $T\n                        }\n                    }\n                    impl One for $T {\n                        fn one() -> $T {\n                            1\n                        }\n                    }\n                )*\n            }\n        }\n\n        int! {\n            u8, u16, u32, u64, u128, usize,\n            i8, i16, i32, i64, i128, isize,\n        }\n    }\n\n    pub mod wrappers {\n        use super::{Assoc, Element, Identity, One, Zero};\n        use std::ops;\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Add<T>(pub T);\n        impl<T> Assoc for Add<T>\n        where\n            T: ops::Add<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Add(self.0 + rhs.0)\n            }\n        }\n        impl<T> Identity for Add<T>\n        where\n            T: Zero,\n        {\n            fn identity() -> Self {\n                Add(T::zero())\n            }\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Mul<T>(pub T);\n\n        impl<T> Assoc for Mul<T>\n        where\n            T: ops::Mul<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Mul(self.0 * rhs.0)\n            }\n        }\n        impl<T> Identity for Mul<T>\n        where\n            T: One,\n        {\n            fn identity() -> Self {\n                Mul(T::one())\n            }\n        }\n\n        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Affine<T> {\n            pub a: T,\n            pub b: T,\n        }\n\n        impl<T> Assoc for Affine<T>\n        where\n            T: ops::Add<Output = T> + Element,\n            T: ops::Mul<Output = T> + Element,\n        {\n            fn op(self, rhs: Self) -> Self {\n                Self {\n                    a: self.a.clone() * rhs.a,\n                    b: self.b + self.a * rhs.b,\n                }\n            }\n        }\n        impl<T> Identity for Affine<T>\n        where\n            T: Zero + One,\n        {\n            fn identity() -> Self {\n                Self {\n                    a: T::one(),\n                    b: T::zero(),\n                }\n            }\n        }\n\n        #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\n        pub struct Cat(pub String);\n\n        impl Assoc for Cat {\n            fn op(self, rhs: Self) -> Self {\n                Cat(self.0.chars().chain(rhs.0.chars()).collect())\n            }\n        }\n        impl Identity for Cat {\n            fn identity() -> Self {\n                Cat(String::new())\n            }\n        }\n    }\n\n    pub trait Element: Sized + Clone + PartialEq + fmt::Debug {}\n    impl<T: Sized + Clone + PartialEq + fmt::Debug> Element for T {}\n\n    pub trait Assoc: Element {\n        fn op(self, rhs: Self) -> Self;\n\n        fn op_from_left(&mut self, left: &Self) {\n            *self = Self::op(left.clone(), self.clone());\n        }\n\n        fn op_from_right(&mut self, right: &Self) {\n            *self = Self::op(self.clone(), right.clone());\n        }\n    }\n\n    pub trait Identity: Assoc {\n        fn identity() -> Self;\n    }\n\n    pub trait Zero: ops::Add<Output = Self> + ops::AddAssign + Element {\n        fn zero() -> Self;\n\n        fn is_zero(&self) -> bool\n        where\n            Self: cmp::PartialEq,\n        {\n            self == &Self::zero()\n        }\n\n        fn times(self, n: u64) -> Self;\n\n        fn times_assign(&mut self, n: u64);\n\n        fn from_u64(x: u64) -> Self;\n    }\n\n    pub trait One: ops::Mul<Output = Self> + ops::MulAssign + Element {\n        fn one() -> Self;\n\n        fn is_one(&self) -> bool\n        where\n            Self: cmp::PartialEq,\n        {\n            self == &Self::one()\n        }\n    }\n\n    pub trait Ring: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign {}\n    impl<T: Zero + One + ops::Neg + ops::Sub<Output = Self> + ops::SubAssign> Ring for T {}\n\n    #[macro_export]\n    macro_rules! define_constant {\n        ($(#[$attr:meta])? $vis:vis type $wrapper_type:ident: $value_type:ty = $value:expr;) => {\n            $(#[$attr])?\n            #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n            $vis struct $wrapper_type {}\n\n            impl Constant for $wrapper_type {\n                type Output = $value_type;\n                const VALUE: Self::Output = $value;\n            }\n        };\n    }\n\n    pub trait Constant: Copy {\n        type Output: Copy;\n\n        const VALUE: Self::Output;\n    }\n}\n// }}}\n// fenwick {{{\n#[allow(dead_code)]\nmod fenwick {\n    use std::{fmt, iter, ops};\n\n    #[derive(Debug, Clone)]\n    pub struct Fenwick<T> {\n        table: Vec<T>,\n    }\n\n    impl<'a, T> Fenwick<T>\n    where\n        T: Clone + fmt::Debug + ops::Add<Output = T> + ops::AddAssign + iter::Sum<T>,\n    {\n        pub fn new(zero: T) -> Self {\n            Fenwick { table: vec![zero] }\n        }\n\n        pub fn from_zero_slice(zero: T, src: &[T]) -> Self {\n            let mut table = iter::once(zero)\n                .chain(src.iter().cloned())\n                .collect::<Vec<_>>();\n            let n = table.len();\n            (1..n)\n                .map(|i| (i, i + lsb(i)))\n                .filter(|&(_, j)| j < n)\n                .for_each(|(i, j)| {\n                    let x = table[i].clone();\n                    table[j] += x\n                });\n            Self { table }\n        }\n\n        pub fn push(&mut self, mut x: T) {\n            let i = self.table.len();\n            let lsb_i = lsb(i);\n            x += iter::successors(Some(1), |&d| Some(2 * d))\n                .take_while(|&d| d != lsb_i)\n                .map(|d| self.table[i - d].clone())\n                .sum::<T>();\n            self.table.push(x);\n        }\n\n        pub fn prefix_sum(&self, i: usize) -> T {\n            iter::successors(Some(i), |&i| Some(i - lsb(i)))\n                .take_while(|&i| i != 0)\n                .map(|i| self.table[i].clone())\n                .sum::<T>()\n        }\n\n        pub fn add(&mut self, i: usize, x: T) {\n            let n = self.table.len();\n            iter::successors(Some(i + 1), |&i| Some(i + lsb(i)))\n                .take_while(|&i| i < n)\n                .for_each(|i| self.table[i] += x.clone());\n        }\n\n        pub fn partition_point(&self, pred: impl Fn(usize, &T) -> bool) -> (usize, T) {\n            let mut j = 0;\n            let mut current = self.table[0].clone();\n            for d in iter::successors(Some(self.table.len().next_power_of_two() / 2), |&d| {\n                Some(d / 2)\n            })\n            .take_while(|&d| d != 0)\n            {\n                assert!(\n                    pred(0, &self.table[0]),\n                    \"pred(0, zero) のほうよろしくお願いいたします！\"\n                );\n                if j + d < self.table.len() {\n                    let next = current.clone() + self.table[j + d].clone();\n                    if pred(j + d, &next) {\n                        current = next;\n                        j += d;\n                    }\n                }\n            }\n            (j, current)\n        }\n\n        #[inline]\n        pub fn lower_bound(&self, x: &T) -> usize\n        where\n            T: Ord,\n        {\n            self.partition_point(|_, y| y < x).0\n        }\n\n        #[inline]\n        pub fn upper_bound(&self, x: &T) -> usize\n        where\n            T: Ord,\n        {\n            self.partition_point(|_, y| y <= x).0\n        }\n\n        #[inline]\n        pub fn lower_bound_from(&self, i: usize, x: &T) -> usize\n        where\n            T: Ord,\n        {\n            let bi = self.prefix_sum(i);\n            let res = self.partition_point(|_, y| y < &(bi.clone() + x.clone())).0;\n            assert!(i <= res, \"逆戻りしていませんか？\");\n            res\n        }\n\n        #[inline]\n        pub fn upper_bound_from(&self, i: usize, x: &T) -> usize\n        where\n            T: Ord,\n        {\n            let bi = self.prefix_sum(i);\n            let res = self\n                .partition_point(|_, y| y <= &(bi.clone() + x.clone()))\n                .0;\n            assert!(i <= res, \"逆戻りしていませんか？\");\n            res\n        }\n    }\n\n    impl<'a, T> Fenwick<T>\n    where\n        T: Clone\n            + fmt::Debug\n            + ops::Add<Output = T>\n            + ops::AddAssign\n            + ops::Sub<Output = T>\n            + ops::SubAssign\n            + iter::Sum<T>,\n    {\n        pub fn sum(&self, range: impl ops::RangeBounds<usize>) -> T {\n            let start = match range.start_bound() {\n                ops::Bound::Unbounded => 0,\n                ops::Bound::Included(&x) => x,\n                ops::Bound::Excluded(&x) => x + 1,\n            };\n            let end = match range.end_bound() {\n                ops::Bound::Excluded(&x) => x,\n                ops::Bound::Included(&x) => x + 1,\n                ops::Bound::Unbounded => self.table.len() - 1,\n            };\n            assert!(start <= end, \"変な区間を渡すのをやめませんか？\");\n            assert!(end < self.table.len(), \"残念範囲外です！\");\n            self.prefix_sum(end) - self.prefix_sum(start)\n        }\n\n        pub fn access(&self, i: usize) -> T {\n            assert!(i < self.table.len() - 1, \"残念範囲外です！\");\n            self.prefix_sum(i + 1) - self.prefix_sum(i)\n        }\n\n        pub fn set(&mut self, i: usize, x: T) {\n            assert!(i < self.table.len() - 1, \"残念範囲外です！\");\n            self.add(i, x - self.access(i));\n        }\n    }\n\n    fn lsb(x: usize) -> usize {\n        x & x.wrapping_neg()\n    }\n}\n// }}}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin Lazy Segment Tree ----------\npub trait TE {\n    type T: Clone;\n    type E: Clone;\n    fn fold(l: &Self::T, r: &Self::T) -> Self::T;\n    fn eval(x: &Self::T, f: &Self::E) -> Self::T;\n    fn merge(g: &Self::E, h: &Self::E) -> Self::E;\n    fn e() -> Self::T;\n    fn id() -> Self::E;\n}\n \npub struct LazySegmentTree<R: TE> {\n    size: usize,\n    bit: usize,\n    a: Vec<(R::T, R::E)>,\n}\n \nimpl <R: TE> LazySegmentTree<R> {\n    pub fn new(n: usize) -> LazySegmentTree<R> {\n        let size = n.next_power_of_two();\n        let bit = size.trailing_zeros() as usize;\n        LazySegmentTree {\n            size: size,\n            bit: bit,\n            a: vec![(R::e(), R::id()); 2 * size],\n        }\n    }\n    pub fn build_by(z: &[R::T]) -> LazySegmentTree<R> {\n        let mut seg = LazySegmentTree::<R>::new(z.len());\n        for (a, z) in seg.a[seg.size..].iter_mut().zip(z.iter()) {\n            a.0 = z.clone();\n        }\n        let a = &mut seg.a;\n        for i in (1..seg.size).rev() {\n            a[i].0 = R::fold(&a[2 * i].0, &a[2 * i + 1].0);\n        }\n        seg\n    }\n    fn apply(&mut self, x: usize, op: &R::E) {\n        let node = &mut self.a[x];\n        node.0 = R::eval(&node.0, op);\n        node.1 = R::merge(&node.1, op);\n    }\n    fn propagate_at(&mut self, x: usize) {\n        let mut op = R::id();\n        std::mem::swap(&mut op, &mut self.a[x].1);\n        self.apply(2 * x, &op);\n        self.apply(2 * x + 1, &op);\n    }\n    fn save_at(&mut self, x: usize) {\n        let a = &mut self.a;\n        a[x].0 = R::fold(&a[2 * x].0, &a[2 * x + 1].0);\n    }\n    fn down(&mut self, x: usize) {\n        let x = x + self.size;\n        for i in (1..=self.bit).rev() {\n            self.propagate_at(x >> i);\n        }\n    }\n    fn save(&mut self, x: usize) {\n        let mut x = (x + self.size) >> 1;\n        while x > 0 {\n            self.save_at(x);\n            x >>= 1;\n        }\n    }\n    pub fn set_at(&mut self, x: usize, val: R::T) {\n        assert!(x < self.size);\n        self.down(x);\n        self.a[x + self.size] = (val, R::id());\n        self.save(x);\n    }\n    fn propagate_range(&mut self, l: usize, r: usize) {\n        let x = l + self.size;\n        let y = r + self.size;\n        let mut k = self.bit;\n        while (x >> k) == (y >> k) {\n            self.propagate_at(x >> k);\n            k -= 1;\n        }\n        for i in ((x.trailing_zeros() as usize + 1)..=k).rev() {\n            self.propagate_at(x >> i);\n        }\n        for i in ((y.trailing_zeros() as usize + 1)..=k).rev() {\n            self.propagate_at(y >> i);\n        }\n    }\n    fn save_range(&mut self, l: usize, r: usize) {\n        let mut x = l + self.size;\n        let mut y = r + self.size;\n        let mut p = (x & 1) == 1;\n        let mut q = (y & 1) == 1;\n        x >>= 1;\n        y >>= 1;\n        while 0 < x && x < y {\n            if p {\n                self.a[x].0 = R::fold(&self.a[2 * x].0, &self.a[2 * x + 1].0);\n            }\n            if q {\n                self.a[y].0 = R::fold(&self.a[2 * y].0, &self.a[2 * y + 1].0);\n            }\n            p |= (x & 1) == 1;\n            q |= (y & 1) == 1;\n            x >>= 1;\n            y >>= 1;\n        }\n        while 0 < x {\n            self.a[x].0 = R::fold(&self.a[2 * x].0, &self.a[2 * x + 1].0);\n            x >>= 1;\n        }\n    }\n    pub fn update(&mut self, l: usize, r: usize, op: R::E) {\n        assert!(l <= r && r <= self.size);\n        if l == r {\n            return;\n        }\n        self.propagate_range(l, r);\n        let mut x = l + self.size;\n        let mut y = r + self.size;\n        while x < y {\n            if x & 1 == 1 {\n                self.apply(x, &op);\n                x += 1;\n            }\n            if y & 1 == 1 {\n                y -= 1;\n                self.apply(y, &op);\n            }\n            x >>= 1;\n            y >>= 1;\n        }\n        self.save_range(l, r);\n    }\n    pub fn find(&mut self, l: usize, r: usize) -> R::T {\n        assert!(l <= r && r <= self.size);\n        if l == r {\n            return R::e();\n        }\n        self.propagate_range(l, r);\n        let mut x = l + self.size;\n        let mut y = r + self.size;\n        let mut p = R::e();\n        let mut q = R::e();\n        while x < y {\n            if x & 1 == 1 {\n                p = R::fold(&p, &self.a[x].0);\n                x += 1;\n            }\n            if y & 1 == 1 {\n                y -= 1;\n                q = R::fold(&self.a[y].0, &q);\n            }\n            x >>= 1;\n            y >>= 1;\n        }\n        R::fold(&p, &q)\n    }\n}\n// ---------- end Lazy Segment Tree ----------\n// ---------- begin ModInt ----------\nmod modint {\n\n    #[allow(dead_code)]\n    pub struct Mod;\n    impl ConstantModulo for Mod {\n        const MOD: u32 = 998_244_353;\n    }\n\n    #[allow(dead_code)]\n    pub struct StaticMod;\n    static mut STATIC_MOD: u32 = 0;\n    impl Modulo for StaticMod {\n        fn modulo() -> u32 {\n            unsafe { STATIC_MOD }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl StaticMod {\n        pub fn set_modulo(p: u32) {\n            unsafe {\n                STATIC_MOD = p;\n            }\n        }\n    }\n\n    use std::marker::*;\n    use std::ops::*;\n\n    pub trait Modulo {\n        fn modulo() -> u32;\n    }\n\n    pub trait ConstantModulo {\n        const MOD: u32;\n    }\n\n    impl<T> Modulo for T\n    where\n        T: ConstantModulo,\n    {\n        fn modulo() -> u32 {\n            T::MOD\n        }\n    }\n\n    pub struct ModInt<T>(pub u32, PhantomData<T>);\n\n    impl<T> Clone for ModInt<T> {\n        fn clone(&self) -> Self {\n            ModInt::new_unchecked(self.0)\n        }\n    }\n\n    impl<T> Copy for ModInt<T> {}\n\n    impl<T: Modulo> Add for ModInt<T> {\n        type Output = ModInt<T>;\n        fn add(self, rhs: Self) -> Self::Output {\n            let mut d = self.0 + rhs.0;\n            if d >= T::modulo() {\n                d -= T::modulo();\n            }\n            ModInt::new_unchecked(d)\n        }\n    }\n\n    impl<T: Modulo> AddAssign for ModInt<T> {\n        fn add_assign(&mut self, rhs: Self) {\n            *self = *self + rhs;\n        }\n    }\n\n    impl<T: Modulo> Sub for ModInt<T> {\n        type Output = ModInt<T>;\n        fn sub(self, rhs: Self) -> Self::Output {\n            let mut d = T::modulo() + self.0 - rhs.0;\n            if d >= T::modulo() {\n                d -= T::modulo();\n            }\n            ModInt::new_unchecked(d)\n        }\n    }\n\n    impl<T: Modulo> SubAssign for ModInt<T> {\n        fn sub_assign(&mut self, rhs: Self) {\n            *self = *self - rhs;\n        }\n    }\n\n    impl<T: Modulo> Mul for ModInt<T> {\n        type Output = ModInt<T>;\n        fn mul(self, rhs: Self) -> Self::Output {\n            let v = self.0 as u64 * rhs.0 as u64 % T::modulo() as u64;\n            ModInt::new_unchecked(v as u32)\n        }\n    }\n\n    impl<T: Modulo> MulAssign for ModInt<T> {\n        fn mul_assign(&mut self, rhs: Self) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T: Modulo> Neg for ModInt<T> {\n        type Output = ModInt<T>;\n        fn neg(self) -> Self::Output {\n            if self.0 == 0 {\n                Self::zero()\n            } else {\n                Self::new_unchecked(T::modulo() - self.0)\n            }\n        }\n    }\n\n    impl<T> std::fmt::Display for ModInt<T> {\n        fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    impl<T: Modulo> std::str::FromStr for ModInt<T> {\n        type Err = std::num::ParseIntError;\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            let val = s.parse::<u32>()?;\n            Ok(ModInt::new(val))\n        }\n    }\n\n    impl<T: Modulo> From<usize> for ModInt<T> {\n        fn from(val: usize) -> ModInt<T> {\n            ModInt::new_unchecked((val % T::modulo() as usize) as u32)\n        }\n    }\n\n    impl<T: Modulo> From<u64> for ModInt<T> {\n        fn from(val: u64) -> ModInt<T> {\n            ModInt::new_unchecked((val % T::modulo() as u64) as u32)\n        }\n    }\n\n    impl<T: Modulo> From<i64> for ModInt<T> {\n        fn from(val: i64) -> ModInt<T> {\n            let m = T::modulo() as i64;\n            ModInt::new((val % m + m) as u32)\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<T> ModInt<T> {\n        pub fn new_unchecked(d: u32) -> Self {\n            ModInt(d, PhantomData)\n        }\n        pub fn zero() -> Self {\n            ModInt::new_unchecked(0)\n        }\n        pub fn one() -> Self {\n            ModInt::new_unchecked(1)\n        }\n        pub fn is_zero(&self) -> bool {\n            self.0 == 0\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<T: Modulo> ModInt<T> {\n        pub fn new(d: u32) -> Self {\n            ModInt::new_unchecked(d % T::modulo())\n        }\n        pub fn pow(&self, mut n: u64) -> Self {\n            let mut t = Self::one();\n            let mut s = *self;\n            while n > 0 {\n                if n & 1 == 1 {\n                    t *= s;\n                }\n                s *= s;\n                n >>= 1;\n            }\n            t\n        }\n        pub fn inv(&self) -> Self {\n            assert!(self.0 != 0);\n            self.pow(T::modulo() as u64 - 2)\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn mod_pow(r: u64, mut n: u64, m: u64) -> u64 {\n        let mut t = 1 % m;\n        let mut s = r % m;\n        while n > 0 {\n            if n & 1 == 1 {\n                t = t * s % m;\n            }\n            s = s * s % m;\n            n >>= 1;\n        }\n        t\n    }\n}\n// ---------- end ModInt ----------\n// ---------- begin Precalc ----------\nmod precalc {\n    use super::modint::*;\n    #[allow(dead_code)]\n    pub struct Precalc<T> {\n        inv: Vec<ModInt<T>>,\n        fact: Vec<ModInt<T>>,\n        ifact: Vec<ModInt<T>>,\n    }\n    #[allow(dead_code)]\n    impl<T: Modulo> Precalc<T> {\n        pub fn new(n: usize) -> Precalc<T> {\n            let mut inv = vec![ModInt::one(); n + 1];\n            let mut fact = vec![ModInt::one(); n + 1];\n            let mut ifact = vec![ModInt::one(); n + 1];\n            for i in 2..(n + 1) {\n                fact[i] = fact[i - 1] * ModInt::new_unchecked(i as u32);\n            }\n            ifact[n] = fact[n].inv();\n            if n > 0 {\n                inv[n] = ifact[n] * fact[n - 1];\n            }\n            for i in (1..n).rev() {\n                ifact[i] = ifact[i + 1] * ModInt::new_unchecked((i + 1) as u32);\n                inv[i] = ifact[i] * fact[i - 1];\n            }\n            Precalc {\n                inv: inv,\n                fact: fact,\n                ifact: ifact,\n            }\n        }\n        pub fn inv(&self, n: usize) -> ModInt<T> {\n            assert!(n > 0);\n            self.inv[n]\n        }\n        pub fn fact(&self, n: usize) -> ModInt<T> {\n            self.fact[n]\n        }\n        pub fn ifact(&self, n: usize) -> ModInt<T> {\n            self.ifact[n]\n        }\n        pub fn perm(&self, n: usize, k: usize) -> ModInt<T> {\n            if k > n {\n                return ModInt::zero();\n            }\n            self.fact[n] * self.ifact[n - k]\n        }\n        pub fn comb(&self, n: usize, k: usize) -> ModInt<T> {\n            if k > n {\n                return ModInt::zero();\n            }\n            self.fact[n] * self.ifact[k] * self.ifact[n - k]\n        }\n    }\n}\n// ---------- end Precalc ----------\n\nuse proconio::*;\nuse proconio::marker::*;\n\nuse modint::*;\ntype M = ModInt<Mod>;\n\nstruct R;\nimpl TE for R {\n    type T = (M, M);\n    type E = M;\n    fn fold(l: &Self::T, r: &Self::T) -> Self::T {\n        (l.0 + r.0, l.1 + r.1)\n    }\n    fn eval(x: &Self::T, f: &Self::E) -> Self::T {\n        (x.0 * *f, x.1)\n    }\n    fn merge(g: &Self::E, h: &Self::E) -> Self::E {\n        *g * *h\n    }\n    fn e() -> Self::T {\n        (M::zero(), M::zero())\n    }\n    fn id() -> Self::E {\n        M::one()\n    }\n}\n\nfn run() {\n    input! {\n        n: usize,\n        k: usize,\n        p: [usize; n],\n    }\n    let mut ans = M::from(k * (k - 1)) * M::new(4).inv();\n    let mut seg = LazySegmentTree::<R>::new(n + 1);\n    for p in p.iter().take(k) {\n        seg.set_at(*p, (M::one(), M::one()));\n    }\n    let mul = M::from(k - 1) * M::from(k).inv();\n    seg.update(0, n + 1, mul);\n    for p in p.iter().skip(k) {\n        let x = seg.find(0, *p);\n        let y = seg.find(*p, n + 1);\n        ans += x.0 * M::new(2).inv() + y.0 * M::new(2).inv() + (y.1 - y.0);\n        seg.set_at(*p, (M::one(), M::one()));\n        seg.update(0, n + 1, mul);\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  }
]