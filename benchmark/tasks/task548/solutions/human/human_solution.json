[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> p(n);\n    vector<int> q(n);\n    vector<vector<int>> G;\n    \n    for(int i=0;i<n;++i){\n        cin>>p[i];\n        --p[i];\n    }\n    map<int,int> mp;//[val,pos]\n    for(int i=0;i<n;++i)mp[p[i]]=i;\n\n    for(int i=0;i<n;++i){\n        cin>>q[i];\n        --q[i];\n    }\n\n    vector<bool> used(n,false);\n    for(int i=0;i<n;++i){\n        if(used[i])continue;\n        vector<int> t;\n        t.push_back(i);\n        used[i]=true;\n        int nx=q[i];\n        while(nx!=i){\n            t.push_back(nx);\n            used[nx]=true;\n            nx=q[nx];\n        }\n        G.push_back(t);\n    }\n\n    vector<int> d;\n\n    for(auto seq:G){\n        int okn=-1;\n        for(int i=0;i<seq.size();++i){\n            bool ok=true;\n            for(int j=0;j<seq.size();++j){\n                int prev=seq[j],nxt=seq[(j+i)%seq.size()];\n                if(mp[prev]!=nxt){\n                    ok=false;\n                    break;\n                }\n            }\n            if(ok){\n                okn=i;\n                break;\n            }\n        }\n        if(okn==-1){\n            cout<<\"-1\"<<endl;\n            return 0;\n        }\n        d.emplace_back(okn);\n    }\n\n    for(int i=0;i<G.size();++i){\n        for (int j = 0; j < G.size(); j++){\n            int g = __gcd(G[i].size(), G[j].size());\n            if (d[i] % g != d[j] % g){\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n    }\n\n    int64_t cur = d[0];\n    int64_t lcm = G[0].size();\n\n    while (true){\n        int flag = true;\n        //cout << cur << \" \" << lcm << endl;\n        for (int i = 0; i < G.size(); i++){\n            bool f = cur % G[i].size() == d[i];\n            if (f){\n                lcm = lcm * G[i].size() / __gcd(lcm, int64_t(G[i].size()));\n            }\n            flag &= f;\n        }\n        if (flag)\n            break;\n            \n        cur += lcm;\n    }\n\n    cout << cur << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define dbg(x) cout<<#x<<\"=\"<<x<<endl\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<ll,ll> PA;\n\nll gcd(ll a,ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a,ll b,ll& x,ll &y){\n  ll d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;y=0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a,ll m){ \n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m)%m;\n}\n\nPA linear_congruence(const vector<PA>& A){\n  ll x=0,m=1;\n\n  ll N=A.size();\n  for(ll i=0;i<N;i++){\n    ll a=m%A[i].se,b=A[i].fi-x,d=gcd(A[i].se,a);\n    b%=A[i].se;\n    if(b<0)b+=A[i].se;\n    if(b%d!=0)return PA(0,-1);\n    ll t=((b/d)*mod_inverse(a/d,A[i].se/d))%(A[i].se/d);\n    x=x+m*t;\n    m*=A[i].se/d;\n    x%=m;\n    if(x<0)x+=m;\n  }\n\n  return PA(x%m,m);\n}\n\nint main(){\n\n  int N;\n  cin>>N;\n  vector<int> P(N);\n  vector<int> Q(N);\n  vector<int> tmp(N);\n  vector<bool> vis(N,false);\n\n  rep(i,N){\n    cin>>tmp[i];\n    tmp[i]--;\n    P[tmp[i]]=i;\n  }\n  rep(i,N){\n    cin>>tmp[i];\n    tmp[i]--;\n    Q[i]=tmp[i];\n  }\n\n  bool ok=true;\n  vector<PA> ps;\n  rep(i,N){\n    if(vis[i])continue;\n    int v=i;\n    vector<int> vs;\n    while(!vis[v]){\n      vs.push_back(v);\n      vis[v]=true;\n      v=Q[v];\n    }\n    vector<int> pos;\n    rep(j,vs.size()){\n      pos.push_back(P[vs[j]]);\n    }\n    int M=vs.size();\n    ll b=0;\n    while(pos!=vs&&b<M){\n      vector<int> tmpp;\n      tmpp.push_back(pos.back());\n      rep(j,M-1)tmpp.push_back(pos[j]);\n      pos=tmpp;\n      b++;\n    }\n    if(b==M){\n      cout<<-1<<endl;\n      return 0;\n    }\n    if(M>1)ps.push_back(PA(b,M));\n  }\n\n  PA res=linear_congruence(ps);\n\n  if(res.se==-1){\n    cout<<-1<<endl;\n    return 0;\n  }\n\n  if(res.fi<0)res.fi+=res.se;\n\n  cout<<res.fi<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;};\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;};\n\ntemplate<typename T> void drop(T x){cout<<x<<endl;exit(0);};\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y){\n  T d = a;\n  if(b != 0){\n    d = extgcd(b, a%b, y, x);\n    y -=(a/b) * x;\n  }else{\n    x = 1;\n    y = 0;\n  }\n  return d;\n}\n\ntemplate<typename T>\nT mod_inverse(T a, T mod){\n  T x, y;\n  extgcd(a, mod, x, y);\n  return (mod + x%mod)%mod;\n}\n\ntemplate<typename T>\npair<T, T> linear_congruence(const vector<T> &A,\n                            const vector<T> &B,\n                            const vector<T> &M){\n  T x = 0, m = 1;\n  for(int i=0;i<(int)A.size();i++){\n    T a = A[i] * m, b = B[i] - A[i]*x, d = __gcd(M[i], a);\n    if(b%d!=0) return make_pair(0, -1);\n    T t=b/d*mod_inverse(a/d, M[i]/d)%(M[i]/d);\n    x = x + m * t;\n    m *= M[i]/d;\n  }\n  return make_pair((x%m + m)%m, m);\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n;\n  cin>>n;\n  vector<int> ps(n),qs(n);\n  for(int i=0;i<n;i++) cin>>ps[i],ps[i]--;\n  for(int i=0;i<n;i++) cin>>qs[i],qs[i]--;\n\n  using ll = __int128_t;\n  vector<ll> A,B,M;\n\n  vector<int> used(n,0);\n  for(int i=0;i<n;i++){\n    if(used[i]) continue;\n    int pos=i;\n    vector<int> vs,ws;\n    while(!used[pos]){\n      vs.emplace_back(pos);\n      ws.emplace_back(ps[pos]);\n      used[pos]=1;\n      pos=qs[pos];\n    }\n    {\n      auto as=vs,bs=ws;\n      sort(as.begin(),as.end());\n      sort(bs.begin(),bs.end());\n      if(as!=bs) drop(-1);\n    }\n    int m=vs.size();\n    for(int j=0;j<m;j++)\n      ws.emplace_back(int(ws[j]));\n\n    const int DEBUG = 0;\n    if(DEBUG){\n      for(int j=0;j<m;j++) cout<<vs[j]<<\" \";\n      cout<<endl;\n      for(int j=0;j<m;j++) cout<<ws[j]<<\" \";\n      cout<<endl;\n    }\n\n    for(int j=0;j<m;j++){\n      if(ws[j]!=vs[0]) continue;\n      for(int k=0;k<m;k++)\n        if(ws[j+k]!=vs[k]) drop(-1);\n\n      //cout<<1<<\" \"<<j<<\" \"<<m<<endl;\n      A.emplace_back(1);\n      B.emplace_back(j);\n      M.emplace_back(m);\n    }\n  }\n\n  auto res=linear_congruence(A,B,M);\n  if(res.second<0) drop(-1);\n  cout<<(long long)(res.first)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\nlong long invmod(long long a,long long m)\n{\n\tlong long s=a%m,t=m,sx=1,sy=0,tx=0,ty=1;\n\twhile(s%t!=0)\n\t{\n\t\tlong long f=s/t;\n\t\tlong long u=s-t*f,ux=sx-tx*f,uy=sy-ty*f;\n\t\ts=t,sx=tx,sy=ty;\n\t\tt=u,tx=ux,ty=uy;\n\t}\n\tif(tx<0)tx+=m;\n\treturn tx;\n}\nlong long garner(const vector<long long>&x,const vector<long long>&m,const int mod=0)//*=x mod m\n{\n\tif(x.empty())return 0LL;\n\tvector<long long>v(x.size());\n\tv[0]=x[0];\n\tfor(int i=1;i<x.size();i++)\n\t{\n\t\tlong long X=(x[i]-x[0])%m[i];\n\t\tlong long M=1;\n\t\tfor(int j=0;j<i-1;j++)\n\t\t{\n\t\t\t(M*=m[j])%=m[i];\n\t\t\t(X-=v[j+1]*M)%=m[i];\n\t\t}\n\t\t(M*=m[i-1])%=m[i];\n\t\tif(X<0)X+=m[i];\n\t\tv[i]=X*invmod(M,m[i])%m[i];\n\t}\n\tlong long ret=v[0],p=1;\n\tif(mod==0)\n\t{\n\t\tfor(int i=1;i<x.size();i++)\n\t\t{\n\t\t\tp*=m[i-1];\n\t\t\tret+=p*v[i];\n\t\t}\n\t}\n\telse\n\t{\n\t\tret%=mod;\n\t\tfor(int i=1;i<x.size();i++)\n\t\t{\n\t\t\t(p*=m[i-1])%=mod;\n\t\t\t(ret+=p*v[i])%=mod;\n\t\t}\n\t}\n\treturn ret;\n}\n#include<algorithm>\nlong long garner_helper(vector<int>A,vector<int>B,const int mod=0,bool zero=true)//allow zero?\n//make B disjoint. NA => -1\n{\n\tvector<int>primes;\n\tfor(int i=0;i<A.size();i++)\n\t{\n\t\tint b=B[i];\n\t\tfor(int j=2;j*j<=b;j++)\n\t\t{\n\t\t\tif(b%j==0)\n\t\t\t{\n\t\t\t\tprimes.push_back(j);\n\t\t\t\twhile(b%j==0)b/=j;\n\t\t\t}\n\t\t}\n\t\tif(b>1)primes.push_back(b);\n\t}\n\tsort(primes.begin(),primes.end());\n\tprimes.erase(unique(primes.begin(),primes.end()),primes.end());\n\tvector<long long>a,b;\n\tbool flag=!zero;\n\tlong long ret=1;\n\tfor(int p:primes)\n\t{\n\t\tint ma=1,res;\n\t\tvector<pair<int,int> >x;\n\t\tfor(int i=0;i<A.size();i++)\n\t\t{\n\t\t\tif(B[i]%p==0)\n\t\t\t{\n\t\t\t\tint t=1;\n\t\t\t\twhile(B[i]%p==0)\n\t\t\t\t{\n\t\t\t\t\tB[i]/=p;\n\t\t\t\t\tt*=p;\n\t\t\t\t}\n\t\t\t\tx.push_back(make_pair(t,A[i]%t));\n\t\t\t\tif(ma<t)ma=t,res=x.back().second;\n\t\t\t\tA[i]%=B[i];\n\t\t\t}\n\t\t}\n\t\tfor(pair<int,int>q:x)\n\t\t{\n\t\t\tif(res%q.first!=q.second)return-1;\n\t\t}\n\t\ta.push_back(res);\n\t\tb.push_back(ma);\n\t\tflag&=res==0;\n\t\tif(flag)\n\t\t{\n\t\t\tret*=ma;\n\t\t\tif(mod!=0)ret%=mod;\n\t\t}\n\t}\n\tif(!flag)ret=garner(a,b,mod);\n\treturn ret;\n}\nint ap[200][200];\nmain()\n{\n\tint N;\n\tcin>>N;\n\tvector<int>P(N),Q(N);\n\tfor(int i=0;i<N;i++)cin>>P[i],P[i]--;\n\tfor(int i=0;i<N;i++)cin>>Q[i],Q[i]--;\n\tvector<int>A(N),B(N),tmp(N,1);\n\tfor(int i=1;i<=N+1;i++)\n\t{\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(ap[j][P[j]]==0)\n\t\t\t{\n\t\t\t\tap[j][P[j]]=i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(B[j]==0)B[j]=i-ap[j][P[j]];\n\t\t\t}\n\t\t\tP[j]=Q[P[j]];\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tA[i]=ap[i][i]-1;\n\t\tif(A[i]<0)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<garner_helper(A,B)<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1000000010\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\nint gcd(int a,int b){\n  if(a<b) swap(a,b);\n  if(a%b==0) return b;\n  else return gcd(b,a%b);\n}\n\n\nsigned main(){\n  cin.tie(0);\t\n  int n;\n  int a,b,c,d;\n  int p[200],q[200];\n  cin>>n;\n  rep(i,n){\n    cin>>p[i];p[i]--;\n  }\n  rep(i,n){\n    cin>>q[i];q[i]--;\n  }\n  int visited[200]={0};\n  vector<pair<int,int> > mo;\n  rep(i,n){\n   \n    //cout<<endl;\n    if(visited[i]) continue;\n    else{\n      visited[i]=1;\n      c=q[i];\n      int cnt=1;\n      while(c!=i){\n\tvisited[c]=1;\n\tc=q[c];\n\tcnt++;\n      }\n      // debug(1);\n      c=p[i];\n      int cnt2=0;\n      while(c!=i){\n\t//debug(c);\n\tc=q[c];\n\tcnt2++;\n\tif(cnt2>n){cout<<-1<<endl;return 0;}\n      }\n      //cout<<cnt<<\" \"<<cnt2<<endl;\n      c=i;\n      int cc=p[i];\n      rep(j,cnt){\n\tcc=p[c];\n\trep(k,cnt2){\n\t  cc=q[cc];\n\t}\n\t//cout<<cc<<endl;\n\tif(cc!=c){cout<<-1<<endl;return 0;}\n\tc=q[c];\n      }\n      mo.push_back(make_pair(cnt,cnt2));\n    }\n  }\n  a=mo[0].fst;b=mo[0].scd;\n  repi(i,1,mo.size() ){\n    c=mo[i].fst;\n    d=mo[i].scd;\n    if(a<c){\n      swap(a,c);\n      swap(b,d);\n    }\n    rep(j,c){\n      if(b%c==d){\n\ta=a*c/gcd(c,a);\n\tbreak;\n      }\n      b+=a;\n      if(j==c-1){cout<<-1<<endl;return 0;}\n    }\n  }\n  cout<<b<<endl;\n      \n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdio>\n#include <complex>\n#include <numeric>\n#include <string.h>\n#include <random>\n#define rep(i,n) for (int i = 0; i < (int)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\ndouble PI = 3.141592653589793238462643383279;\nconst double EPS = 1e-9;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\n\nint N;\nint P[200], Q[200];\nbool saw[200];\nvector<pl> v;\n\nll gcd (ll x, ll y) {\n    if (y == 0) return x;\n    return gcd(y, x%y);\n}\n\nint main() {\n    cin >> N;\n    rep(i,N) cin >> P[i];\n    rep(i,N) cin >> Q[i];\n    rep(i,N) {\n        P[i]--;\n        Q[i]--;\n    }\n    {\n        bool zero = true;\n        rep(i,N) {\n            if (P[i] != i) {\n                zero = false;\n            }\n        }\n        if (zero) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n    rep(i,N) P[i] = Q[P[i]];\n    rep(i,N) {\n        if (saw[i]) continue;\n        ll a = 1;\n        vector<int> tmp;\n        {\n            tmp.push_back(P[i]);\n            int pos = Q[P[i]];\n            while (pos != P[i]) {\n                tmp.push_back(pos);\n                pos = Q[pos];\n                a++;\n            }\n        }\n        //rep(j,tmp.size()) saw[tmp[j]] = true;\n        ll b = -1;\n        rep(j,tmp.size()) {\n            if (tmp[j] == i) {\n                b = j;\n                break;\n            }\n        }\n        if (b == -1) {\n            cout << -1 << endl;\n            return 0;\n        }\n        v.push_back(pl(a,b));\n    }\n    if (v.size() == 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    pl now = v[0];\n    for (int i = 1; i < v.size(); i++) {\n        ll t = now.second;\n        ll l = now.first * v[i].first / gcd(now.first, v[i].first);\n        ll cnt = 0;\n        while (true) {\n            if (t >= v[i].second && (t-v[i].second)%v[i].first == 0) {\n                break;\n            }\n            t += now.first;\n            cnt++;\n            if (cnt > v[i].first) {\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n        now.first = l;\n        now.second = t;\n    }\n    cout << now.second+1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long int;\n\nstruct UnionFind {\n  vector<int> par, s;\n  UnionFind(int n) { init(n); }\n  void init(int n) {\n    s.assign(n, 1); par.resize(n);\n    iota(par.begin(), par.end(), 0);\n  }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return s[find(x)]; }\n};\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1, y = 0;\n  if(b != 0) g = extgcd(b, a%b, y, x), y -= (a/b) * x;\n  return g;\n}\nll inv(ll a, ll n) {\n  ll s, t;\n  extgcd(a, n, s, t);\n  return (n+s) % n;\n}\nusing PII = pair<ll,ll>;\nconst double lim = 1.5 * 1e18;\nPII crt(const vector<ll>& a, const vector<ll>& b, const vector<ll>& m) {\n  PII ret(0, 1);\n  // for(int i=0; i<a.size(); ++i) {\n  //   ll s = a[i] * ret.second;\n  //   ll t = b[i] - a[i] * ret.first;\n  //   ll d = __gcd(m[i], s);\n  //   if(t%d != 0) return make_pair(-1, -1);\n  //   ll u = t / d * inv(s/d, m[i]/d) % (m[i]/d);\n  //   ret.first += ret.second * u;\n  //   ret.second *= m[i] / d; \n  //   ret.first = (ret.first % ret.second + ret.second) % ret.second;\n  // }\n  for(int i=0; i<a.size(); ++i) {\n    bool ok = false;\n    for(int j=0; j<=m[i]; ++j) {\n      if((double)ret.first + (double)ret.second*j > lim) break; \n      ll nans = ret.first+ret.second*j;\n      if(nans % m[i] == b[i]) {\n        ret.first = nans;\n        ret.second = ret.second * (m[i] / __gcd(ret.second, m[i]));\n        ok = true;\n        break;\n      }\n    }\n    // cout << i << \" \" << ret.first << \" \" << ret.second << endl;\n    if(!ok) return make_pair(-1, -1);\n  }\n  return ret;\n}\n\nsigned main() {\n  ll n;\n  cin >> n;\n  vector<ll> p(n), q(n), ord(n);\n  for(int i=0; i<n; ++i) cin >> p[i], p[i]--, ord[p[i]] = i;\n  for(int i=0; i<n; ++i) cin >> q[i], q[i]--;\n\n  vector<ll> trans(n);\n  for(int i=0; i<n; ++i) trans[i] = q[i];\n\n  UnionFind uf(n);\n  for(int i=0; i<n; ++i) uf.unite(i, q[i]);\n  vector<vector<ll>> group(n);\n  for(int i=0; i<n; ++i) group[uf.find(i)].push_back(ord[i]);\n  // for(auto &v: group) {\n  //   sort(v.begin(), v.end(), [&](ll l, ll r){\n  //     return ord[l] < ord[r];\n  //   });\n  // }\n\n  for(auto v: group) {\n    vector<ll> v1, v2;\n    for(auto i: v) {\n      v1.push_back(i);\n      v2.push_back(ord[i]);\n    }\n    sort(v1.begin(), v1.end());\n    sort(v2.begin(), v2.end());\n    if(v1 != v2) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n\n  vector<ll> a, b, m;\n  for(auto v: group) {\n    if(v.size() == 0) continue;\n    sort(v.begin(), v.end());\n    // cout << \"v: \";\n    // for(auto i: v) cout << i << \" \";\n    // cout << endl;\n\n    bool ok = false;\n    map<vector<ll>,ll> mp;\n    vector<ll> permut(n, -1);\n    vector<ll> vs;\n    for(int i=0; i<v.size(); ++i) {\n      permut[v[i]] = p[v[i]];\n      vs.push_back(p[v[i]]); \n    }\n    sort(vs.begin(), vs.end());\n    // cout << \"vs: \";\n    // for(auto i: vs) cout << i << \" \";\n    // cout << endl;\n    vector<ll> sorted(n, -1);\n    for(int i=0; i<v.size(); ++i) {\n      sorted[v[i]] = vs[i];\n    }\n    // cout << \"sorted: \";\n    // for(auto i: sorted) cout << i << \" \";\n    // cout << endl;\n    for(int i=0; i<v.size()*3; ++i) {\n      // cout << i << \" ( \";\n      // for(auto j: permut) cout << j << \" \";\n      // cout << \")\" << endl;\n      if(permut == sorted) ok = true;\n      if(permut == sorted && mp.find(permut) != mp.end()) {\n        if(i-mp[permut] > 1) {\n          a.push_back(1);\n          b.push_back(mp[permut]);\n          m.push_back(i-mp[permut]);\n        }\n        // cout << \"ok=\" << ok << endl;\n        break;\n      }\n      mp[permut] = i;\n\n      vector<ll> n_permut(permut);\n      for(int j=0; j<v.size(); ++j) {\n        n_permut[v[j]] = trans[permut[v[j]]];\n      }\n      permut = n_permut;\n    }\n\n    // cout << \"ok=\" << ok << endl;\n    if(!ok) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n\n  // for(auto i: a) cout << i << \" \";\n  // cout << endl;\n  // for(auto i: b) cout << i << \" \";\n  // cout << endl;\n  // for(auto i: m) cout << i << \" \";\n  // cout << endl;\n\n  ll ret = crt(a, b, m).first;\n  if(ret != -1) {\n    for(int i=0; i<a.size(); ++i) {\n      if(ret % m[i] != b[i]) {\n        ret = -1;\n        break;\n      }\n    }\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\nusing namespace std;\n\nusing ll = long long;\n\nlong long ext_gcd(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long q = a / b;\n    long long g = ext_gcd(b, a - q * b , x, y);\n    long long z = x - q * y;\n    x = y;\n    y = z;\n    return g;\n}\n\n// x ≡ r (mod m) の (r,m) を返す．m = lcm(m_1,m_2,...)\n// 解なしの場合 (-1,-1) を返す．\npair<long long, long long> crt(const vector<long long> &b, const vector<long long> &m) {\n    long long r = 0, M = 1;\n    for (int i = 0; i < (int)b.size(); ++i) {\n        long long p, q;\n        long long d = ext_gcd(M, m[i], p, q);\n        if ((b[i] - r) % d)\n            return make_pair(-1, -1);\n        long long tmp = (b[i] - r) / d * p % (m[i] / d);\n        r += M * tmp;\n        M *= m[i] / d;\n    }\n    r %= M;\n    if (r < 0) r += M;\n    return make_pair(r, M);\n}\n\nint N;\nint P[210], Q[210];\nint pos[210];   // i列目に最初にiが現れる時刻\nint gap[210];   // i列目の周期\n\nint main() {\n    cin >> N;\n    REP(i, N) cin >> P[i], P[i]--;\n    REP(i, N) cin >> Q[i], Q[i]--;\n\n    REP(i, N) {\n        int now = P[i];\n        pos[i] = -1;\n        REP(j, 2 * N) {\n            if (pos[i] < 0 && now == i) {\n                pos[i] = j;\n            }\n            if (j > 0 && now == P[i]) {\n                break;\n            }\n            now = Q[now];\n            gap[i]++;\n        }\n\n        // i列目にiが現れないなら-1\n        if (pos[i] < 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    vector<ll> b, m;\n    REP(i, N) {\n        b.push_back(pos[i]);\n        m.push_back(gap[i]);\n    }\n    auto p = crt(b, m);\n    cout << p.first << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll,ll>;\n\nll x[500005],y[500005];\nll table[500005];\nbool visited[500005];\nll n,i;\nll cnt;\n\nvector <ll> G[500005];\nvector <P> constraints;\n\nll mygcd(ll a,ll b){\n\tif(b==0ll)return a;\n\treturn mygcd(b,a%b);\n}\n\nvoid dfs(ll v){\n\t//cout << v << endl;\n\tif(visited[v])return;\n\tvisited[v] = true;\n\tll nv = G[v][0];\n\tcnt++;\n\tdfs(nv);\n}\n\nvoid swap_dfs(ll v,ll bring){\n\tif(bring == 0){\n\t\tll tmp = table[v];\n\t\ttable[v] = 0;\n\t\tll nv = G[v][0];\n\t\tswap_dfs(nv, tmp);\n\t}else if(table[v] == 0){\n\t\ttable[v] = bring;\n\t\treturn;\n\t}else{\n\t\tll tmp = table[v];\n\t\ttable[v] = bring;\n\t\tll nv = G[v][0];\n\t\tswap_dfs(nv, tmp);\n\t}\n}\n\nbool dfs_check(ll v,ll cnt){\n\tif(cnt < -3){\n\t\treturn true;\n\t}\n\tif(table[v] == v){\n\t\tll nv = G[v][0];\n\t\tdfs_check(nv, cnt - 1);\n\t}else{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> x[i];\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> y[i];\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tG[i].push_back(y[i]);\n\t\ttable[x[i]] = i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!visited[i]){\n\t\t\tcnt = 0;\n\t\t\tdfs(i);\n\t\t\tll k = 0;\n\t\t\twhile(table[i] != i){\n\t\t\t\tk++;\n\t\t\t\tswap_dfs(i,0);\n\t\t\t\tif(k > n + 2){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok = dfs_check(i, cnt);\n\t\t\tif(!ok){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t//cout << \"const = \" << cnt << \" \" << k << endl;\n\t\t\tconstraints.push_back(P(cnt, k));\n\t\t}\n\t}\n\tP cons1 = constraints[0];\n\tll cntn = cons1.first;\n\tll kn = cons1.second;\n\tll m = constraints.size();\n\tfor(int i=1;i<m;i++){\n\t\tP conslook = constraints[i];\n\t\tll cnti = conslook.first;\n\t\tll ki = conslook.second;\n\t\tbool ok = false;\n\t\tfor(int j=0;j<cnti;j++){\n\t\t\tll nv = j * cntn + kn;\n\t\t\tif(nv > 1000000000000000000ll){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(nv % cnti == ki){\n\t\t\t\tok = true;\n\t\t\t\tcntn = (cntn / mygcd(cntn, cnti));\n\t\t\t\tcntn *= cnti;\n\t\t\t\tkn = nv;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//cout << \"cntc = \" << cntn << endl;\n\t\t\t//cout << \"kn = \" << kn << endl;\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << kn << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// as + bt = GCD(a,b) a,b:const s,t:var(any)\n// return GCD(a,b)\nlong long extGCD(long long a, long long b, long long& s,\n                 long long& t) {\n    s = 1, t = 0;\n    while(b) {\n        long long tmp = a / b;\n        a -= b * tmp;\n        s -= t * tmp;\n        swap(a, b);\n        swap(s, t);\n    }\n    return a;\n}\n\n// x≡b_i(mod m_i) calc min x,lcm(m_i).\n// if not exist, return (-1,-1)\npair<long long, long long> ChineseRem(\n        const vector<long long>& b,\n        const vector<long long>& m) {\n    long long r = 0, lcm = 1;\n    assert(b.size() == m.size());\n    long long bsize = b.size();\n    for(int i = 0; i < bsize; ++i) {\n        long long p, q, d, now;\n        d = extGCD(lcm, m[i], p, q);\n        if((b[i] - r) % d != 0) return make_pair(-1, -1);\n        now = (b[i] - r) / d * p % (m[i] / d);\n        r += lcm * now;\n        lcm *= m[i] / d;\n    }\n    return make_pair((r + lcm) % lcm, lcm);\n}\n\nlong long n;\nvector<long long> p,q,fmemo,lmemo;\n\nlong long solve();\n\nint main(){\n    cin >> n;\n    p.resize(n);\n    q.resize(n);\n    fmemo.assign(n,0);\n    lmemo.assign(n,0);\n    for(int i = 0;i < n;++i){\n        cin >> p[i];\n        --p[i];\n    }\n    for(int i = 0;i < n;++i){\n        cin >> q[i];\n        --q[i];\n    }\n    cout << solve() << endl;\n    return 0;\n}\n\nlong long solve(){\n    // prepair\n    for(int i = 0;i < n;++i){\n        long long now = p[i];\n        bool ch = 0;\n        for(int j = 0;j < n;++j){\n            if(now == i){\n                fmemo[i] = j;\n                ch = 1;\n            }\n            now = q[now];\n            if(now == p[i]){\n                lmemo[i] = j + 1;\n                break;\n            }\n        }\n        if(!ch)return -1;\n    }\n    long long ans = 0;\n    return ChineseRem(fmemo,lmemo).first;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <utility>\n#include <tuple>\nusing namespace std;\n\nusing int128 = __int128;\nconst long long INF = 1e18;\n\ntemplate <typename NumType, NumType LIMIT = int128(1e18)>\nstruct CRT {\n  pair<NumType, NumType> NIL;\n  CRT() : NIL(-1, -1) {}\n\n  NumType extgcd(NumType a, NumType b, NumType &p, NumType &q) {\n    if(b == 0) {\n      p = 1, q = 0;\n      return a;\n    }\n    NumType d = extgcd(b, a%b, q, p);\n    q -= a / b * p;\n    return d;\n  }\n\n  pair<NumType, NumType> solve(NumType b1, NumType mod1, NumType b2, NumType mod2) {\n    NumType p, q;\n    NumType d = extgcd(mod1, mod2, p, q);\n\n    if((b2 - b1) % d != 0) return NIL;\n    NumType s = (b2 - b1) / d;\n    NumType t = (s * p % (mod2 / d));\n\n    NumType lc = min(mod1 / d * mod2, (int128)(2*INF));\n    NumType so = (b1 + mod1 * t) % lc;\n    (so += lc) %= lc;\n    return make_pair(so, lc);\n  }\n\n  pair<NumType, NumType> solve(vector<NumType> m, vector<NumType> mod) {\n    assert(m.size() == mod.size());\n    NumType so = 0, lc = 1;\n    for(size_t i=0; i<m.size(); i++) {\n      tie(so, lc) = solve(so, lc, m[i], mod[i]);\n      if(so > LIMIT or so < 0) {\n        return NIL;\n      }\n    }\n    return make_pair(so, lc);\n  }\n};\n\nint main() {\n  int N;\n  cin >> N;\n  vector<int> P(N), Q(N);\n  for(int i = 0; i < N; ++i){\n    cin >> P[i];\n    --P[i];\n  }\n  for(int i = 0; i < N; ++i){\n    cin >> Q[i];\n    --Q[i];\n  }\n  vector<vector<long long>> D(N,vector<long long>(N,INF));\n  for(int i = 0; i < N; ++i){\n    D[P[i]][Q[P[i]]] = 1;\n  }\n  for(int k = 0; k < N; ++k){\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n        D[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n      }\n    }\n  }\n  CRT<int128> crt;\n  vector<int128> m(N), mod(N);\n  for(int i = 0; i < N; ++i){\n    int128 r = D[P[i]][i], t = D[i][i];\n    if(r == INF){\n      cout << -1 << endl;\n      return 0;\n    }\n    r %= t;\n    m[i] = r;\n    mod[i] = t;\n    // cerr << (long long)r << \" \"<< (long long)t << endl;\n  }\n  auto ans = crt.solve(m,mod);\n  if(ans.first > INF) cout << -1 << endl;\n  else cout << (long long)ans.first << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nllint gcd(llint a, llint b)\n{\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\n//ax+by = gcd(a, b)を満たす(x, y)を求めgcd(a, b)を返す\nllint extgcd(llint a, llint b, llint &x, llint &y)\n{\n\tif(b == 0){\n\t\tx = 1, y = 0;\n\t\treturn a;\n\t}\n\tllint xx, yy;\n\tllint d = extgcd(b, a%b, xx, yy);\n\tx = yy, y = xx-(a/b)*yy;\n\treturn d;\n}\n\n//a^{-1} (mod m)を求める。存在しない場合(gcd(a, m)!=1)は-1を返す\nllint mod_inverse(llint a, llint m)\n{\n\tllint x, y;\n\tif(extgcd(a, m, x, y) != 1) return -1;\n\treturn (x%m + m) % m;\n}\n\n//ax = b (mod m)を満たすx(mod m/gcd(a, m))を求める。存在しない場合(b%gcd(a, m)!=0)は(0, -1)を返す\nP congruence(llint a, llint b, llint m)\n{\n\tllint d = gcd(a, m);\n\tif(b % d) return make_pair(0, -1);\n\ta /= d, b /= d, m /= d;\n\treturn make_pair(b * mod_inverse(a, m) % m, m);\n}\n\n//連立合同方程式a_i*x = b_i (mod m_i)(i = 1, 2, ..., n)の解(x, M)を求める。存在しない場合(0, -1)を返す\nP SimultaneousCongruence(llint a[], llint b[], llint m[], llint n)\n{\n\tllint x = 0, M = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tP res = congruence(a[i]*M, (b[i]-a[i]*x%m[i]+m[i])%m[i], m[i]);\n\t\tif(res.second == -1) return res;\n\t\tx += M*res.first, M *= res.second;\n\t}\n\treturn make_pair(x, M);\n}\n\nllint n;\nllint p[205], q[205];\nllint pinv[205];\nUnionFind uf(205);\nvector<llint> vec[205];\nllint a[205], b[205], m[205];\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\tfor(int i = 1; i <= n; i++) cin >> q[i];\n\tfor(int i = 1; i <= n; i++) pinv[p[i]] = i;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tllint x = p[i], mn = -1, cnt = 0;\n\t\tdo{\n\t\t\tif(x == i) mn = cnt;\n\t\t\tx = q[x];\n\t\t\tcnt++;\n\t\t}while(x != p[i]);\n\t\tif(mn == -1){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\ta[i] = 1, b[i] = mn, m[i] = cnt;\n\t}\n\t\n\t//for(int i = 1; i <= n; i++) cout << a[i] << \" \" << b[i] << \" \" << m[i] << endl;\n\t\n\tP res = SimultaneousCongruence(a, b, m, n);\n\tif(res.second == -1) cout << -1 << endl;\n\telse cout << res.first << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 2010\n\n// {a, {b, c}} : a = gcd(p, q) = bp + cq\npair<ll,pair<ll,ll>> ext_gcd(ll p, ll q) {\n  if (q == 0) return {p, {1, 0}};\n  auto r = ext_gcd(q, p%q);\n  return {r.first, {r.second.second, r.second.first - p/q*r.second.second}};\n}\n\n\n/* 中国剰余定理 */\n\npair<ll,ll> CRT(ll a1, ll m1, ll a2, ll m2){\n  auto eg = ext_gcd(m1, m2);\n  ll d = eg.first;\n  if((a2 - a1) % d) return {0, -1};\n  ll m = m1 / d * m2;\n  ll r = ((a1 + m1 * ((__int128_t)(a2 - a1) / d * eg.second.first % (m2/d))) % m + m) % m;\n  return {r, m};\n}\n\n\nint main(){\n  int N, p[SIZE], q[SIZE], revp[SIZE];\n  bool used[SIZE] = {};\n\n  scanf(\"%d\", &N);\n\n  for(int i=0; i<N; i++) { scanf(\"%d\", p+i); p[i]--; revp[p[i]] = i;}\n  for(int i=0; i<N; i++) { scanf(\"%d\", q+i); q[i]--; }\n\n  ll ansA = 0, ansB = 1;\n\n  for(int i=0 ;i<N; i++) {\n    if (used[i]) continue;\n\n    int t = i, start = i;\n    vector<int> vec, to, idx;\n\n    do{\n      to.push_back(t);\n      used[t] = true;\n      t = revp[q[p[t]]];\n    }while(t != start);\n\n    sort(to.begin(), to.end());\n\n    idx = to;\n\n    for(int i=0; i<to.size(); i++) {\n      vec.push_back(p[to[i]]);\n      to[i] = p[to[i]];\n    }\n\n    sort(to.begin(), to.end());\n\n    // a mod b\n    int a = -1, b;\n\n    b = vec.size();\n\n    for(int i=0; i<vec.size(); i++) {\n      if (vec == idx) { a = i; break; }\n\n      for(int j=0; j<vec.size(); j++)\n        vec[j] = q[vec[j]];\n    }\n\n    if (a == -1) {\n      ansB = -1;\n    } else {\n      auto res = CRT(a, b, ansA, ansB);\n      //auto res = CRT(ansA, ansB, a, b);\n      ansA = res.first;\n      ansB = res.second;\n    }\n\n    if (ansB == -1) {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n  cout << ansA << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n#define DEBUG(x) cerr << #x << \": \" << (x) << endl\n\nusing ll = __int128_t;\nusing ll64 = long long;\n\nint n;\nint p[252], q[252];\nint rev[252];\nbool used[252];\n\nvoid extgcd(ll p, ll q, ll& x, ll& y, ll& g){\n  if(q==0){\n    g = p;\n    x = 1;\n    y = 0;\n    return;\n  }\n  extgcd(q, p%q, y, x, g);\n  y -= p / q * x;\n  return;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%d\",p+i),p[i]--;\n  REP(i,n)scanf(\"%d\",q+i),q[i]--;\n  REP(i,n)rev[p[i]] = i;\n  fill(used, used+n, false);\n  ll M = 1;\n  ll R = 0;\n  REP(i,n)if(!used[i]){\n    vector<int> ids;\n    int cur = i;\n    do{\n      ids.push_back(cur);\n      cur = rev[q[p[cur]]];\n    }while(cur != i);\n    for(int x : ids){\n      used[x] = true;\n    }\n    sort(ids.begin(), ids.end());\n    vector<int> vals;\n    for(int x : ids){\n      vals.push_back(p[x]);\n    }\n    sort(vals.begin(), vals.end());\n    if(ids != vals){\n      puts(\"-1\");\n      return 0;\n    }\n    vals.clear();\n    for(int x : ids){\n      vals.push_back(p[x]);\n    }\n    ll m = ids.size();\n    ll r = 0;\n    while(r<m){\n      if(vals == ids)break;\n      // step\n      REP(j,m)vals[j] = q[vals[j]];\n      r++;\n    }\n    if(r==m){\n      puts(\"-1\");\n      return 0;\n    }\n    ll x, y, g;\n    extgcd(M, -m, x, y, g);\n\n    if(abs((ll64)(R-r)) % __gcd((ll64)M,(ll64)m) != 0){\n      puts(\"-1\");\n      return 0;\n    }\n    ll mul = (r-R) / g;\n\n    ll nxtM = M/__gcd((ll64)M,(ll64)m)*m;\n    x = (x * mul) % nxtM;\n    R = M * x + R;\n    M = nxtM;\n    R %= M;\n    if(R<0)R+=M;\n  }\n\n  printf(\"%lld\\n\",(ll)R);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nlint tmod(lint a, lint p) { return (a %= p) < 0 ? a + p : a; }\nlint mod_inv(lint a, lint p) {\n    a = tmod(a, p);\n    lint b = p, x = 1, u = 0;\n    while (b) {\n        lint q = a / b;\n        swap(a -= q * b, b);\n        swap(x -= q * u, u);\n    }\n    return a == 1 ? tmod(x, p) : -1;\n}\n\nbool pre(V<lint>& a, V<lint>& p) {\n    assert(a.size() == p.size());\n    int n = a.size();\n    for (int i = 0; i < n; ++i) {\n        a[i] = tmod(a[i], p[i]);\n    }\n    for (int i = 0; i < n; ++i) for (int j = i + 1; j < n; ++j) {\n        lint d = __gcd(p[i], p[j]);\n        if (a[i] % d != a[j] % d) return false;\n        p[i] /= d;\n        p[j] /= d;\n        while (true) {\n            lint e = __gcd(d, p[j]);\n            if (e == 1) break;\n            p[j] *= e;\n            d /= e;\n        }\n        p[i] *= d;\n        a[i] %= p[i];\n        a[j] %= p[j];\n    }\n    return true;\n}\n\nlint CRT(const V<lint>& a, const V<lint>& p) {\n    int n = a.size();\n    lint x = 0;\n    V<lint> y(n);\n    lint prod = 1;\n    for (int i = 0; i < n; ++i) {\n        y[i] = tmod(a[i] - x, p[i]);\n        for (int j = 0; j < i; ++j) {\n            (y[i] *= mod_inv(p[j], p[i])) %= p[i];\n        }\n        x += prod * y[i];\n        prod *= p[i];\n    }\n    return x;\n}\n\nint main() {\n    int n; cin >> n;\n    V<> p(n); for (auto&& e : p) cin >> e, --e;\n    V<> q(n); for (auto&& e : q) cin >> e, --e;\n    VV<> v;\n    V<bool> used(n);\n    for (int i = 0; i < n; ++i) if (!used[i]) {\n        V<> nv;\n        int t = i;\n        while (true) {\n            nv.push_back(t);\n            t = q[t];\n            if (t == i) break;\n        }\n        for (int e : nv) used[e] = true;\n        v.push_back(nv);\n    }\n    // for (const auto& e : v) {\n    //     for (int f : e) cerr << f << ' ';\n    //     cerr << endl;\n    // }\n    V<lint> a, pr;\n    for (const auto& y : v) {\n        V<> x;\n        for (int e : p) if (find(begin(y), end(y), e) != end(y)) {\n            x.push_back(e);\n        }\n        pr.push_back(y.size());\n        for (int i = 0; i < pr.back(); ++i) {\n            // for (int e : x) {\n                // cerr << e << ' ';\n            // }\n            // cerr << \" x\\n\";\n            if (is_sorted(begin(x), end(x))) {\n                a.push_back(i);\n                break;\n            }\n            for (auto&& e : x) {\n                int j = find(begin(y), end(y), e) - begin(y);\n                e = y[(j + 1) % pr.back()];\n            }\n        }\n        if (a.size() < pr.size()) {\n            return cout << -1 << endl, 0;\n        }\n        // cerr << a.back() << ' ' << pr.back() << endl;\n    }\n    if (!pre(a, pr)) {\n        return cout << -1 << endl, 0;\n    }\n    lint res = CRT(a, pr);\n    for (const auto& y : v) {\n        int c = res % y.size();\n        while (c--) {\n            for (auto&& e : p) {\n                int j = find(begin(y), end(y), e) - begin(y);\n                if (j == (int)y.size()) continue;\n                e = y[(j + 1) % y.size()];\n            }\n        }\n    }\n    if (!is_sorted(begin(p), end(p))) {\n        return cout << -1 << endl, 0;\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\nconst long double eps = 1e-12;\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nint next_go[2000];\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint main(){\n\tiostream::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<int> inputs;\n\tREP(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\tinputs.push_back(a-1);\n\t}\n\tREP(i, n) {\n\t\tcin >> next_go[i];\n\t\tnext_go[i]--;\n\t}\n\tvector<pair<long long, long long>> threads;\n\tREP(i, n) {\n\t\tint first_clock = -1;\n\t\tint second_clock = 0;\n\t\tint now = inputs[i];\n\t\twhile (second_clock <= 500) {\n\t\t\tif (now == i) {\n\t\t\t\tif (first_clock == -1) {\n\t\t\t\t\tfirst_clock = second_clock;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow = next_go[now];\n\t\t\tsecond_clock++;\n\t\t}\n\t\tif (second_clock >= 500) {\n\t\t\tif (first_clock == -1) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tthreads.push_back(make_pair(first_clock, 0));\n\t\t}\n\t\telse {\n\t\t\tthreads.push_back(make_pair(first_clock, second_clock - first_clock));\n\t\t}\n\t}\n\tfor (int i = 0; i < threads.size(); ++i) {\n\t\tif (threads[i].second == 0) {\n\t\t\t//!\n\t\t\tfor (int q = 0; q < threads.size(); ++q) {\n\t\t\t\tif (threads[q].second == 0) {\n\t\t\t\t\tif (threads[q].first != threads[i].first) {\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threads[q].first % threads[q].second != threads[i].first % threads[q].second) {\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << threads[i].first << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tpair<long long, long long> now = threads[0];\n\tfor (int i = 1; i < threads.size(); ++i) {\n\t\tfor (long long q = 0; q <= 500; ++q) {\n\t\t\tif (q == 500||(q != 0&&now.first >= (2e18-now.first) / q)) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlong long next_go = now.first + q * now.second;\n\t\t\tif (next_go % threads[i].second == threads[i].first) {\n\t\t\t\tnow.first = next_go;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlong long hoge = gcd(now.second, threads[i].second);\n\t\tif (threads[i].second >= (2e18) / (now.second) * hoge) {\n\t\t\tnow.second = 2e18;\n\t\t}\n\t\telse {\n\t\t\tnow.second *= threads[i].second / hoge;\n\t\t}\n\t}\n\tcout << now.first << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define int long long\n#define MAX_N 100005\ntypedef long long ll;\n\nclass UnionFind{\n    private:\n    int sz;\n    vector<int> par,size_;\n    public:\n    UnionFind(){}\n    UnionFind(int node_size):sz(node_size),par(sz),size_(sz,1){\n        iota(par.begin(),par.end(),0);\n    }\n    int find(int x){\n        if(par[x]==x)return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x),y = find(y);\n        if(x==y)return;\n        if(size_[x]<size_[y])swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n};\n\nll Gcd(ll a,ll b){\n    if(a%b==0){\n        return b;\n    }else{\n        return Gcd(b,a%b);\n    }\n}\n\nll extgcd(ll a,ll b,ll &x,ll &y){\n    if(b!=0){\n        extgcd(b,a%b,y,x);\n        y -= (a/b)*x;\n    }else{\n        x = 1;\n        y = 0;\n    }\n}\n\npair<ll,ll> CRT(const pair<ll,ll>&a1,const pair<ll,ll>&a2){\n    const ll v1 = a1.first,m1 = a1.second;\n    const ll v2 = a2.first,m2 = a2.second;\n    ll g = Gcd(m1,m2);\n    ll dev = (v2-v1)/g;\n    ll mod = abs(v2-v1)%g;\n    if(mod) return make_pair((ll)-1,(ll)-1);\n    ll x,y;\n    extgcd(m1/g,m2/g,x,y);\n    x *= dev, y *= dev;\n    const ll m = m1/g*m2;\n    return make_pair(((((__int128)m1*x+v1)%m)+m)%m,m);\n}\n\nll calc(vector<int>x,vector<int>&p,vector<int>&q){\n    // vector<int>inv(500);\n    // rep(i,p.size()){\n    //     inv[p[i]] = i;\n    // }\n    ll s = 0;\n    ll cur = x[0];\n    ll id;\n    rep(i,p.size()){\n        if(p[i]==x[0]){\n            id = i;\n        }\n    }\n    ll tar = id;\n    ll res = 0;\n    //cerr << cur << \" \" << tar << endl;\n    while(cur!=tar){\n        cur = q[cur];\n        res++;\n    }\n    return res;\n}\n\nsigned main(){\n    int n;\n    cin >> n;\n    vector<int>p(n),q(n);\n    vector<int>inv(n);\n    rep(i,n){\n        cin >> p[i];\n        p[i]--;\n        inv[p[i]] = i;\n    }\n    rep(i,n){\n        cin >> q[i];\n        q[i]--;\n    }\n    vector<bool> a(n);\n    UnionFind uf(n);\n    rep(i,n){\n        uf.unite(i,q[i]);\n    }\n    map<int,vector<int> > vv;\n    rep(i,n){\n        vv[uf.find(q[i])].push_back(i);\n    }\n    vector<vector<int> > v;\n    for(auto x:vv){\n        v.push_back(x.second);\n        // for(auto xx:v.back()){\n        //     cerr << xx << \" \" << inv[xx] << endl;\n        // }\n        // cerr << endl;\n    }\n    for(auto x:v){\n        vector<int> pppp = x;\n        sort(pppp.begin(),pppp.end());\n        vector<int> y;\n        for(auto ss:x){\n        //    cerr << ss << \" \" << inv[ss] << endl;\n            y.push_back(inv[ss]);\n        }\n        sort(y.begin(),y.end());\n        for(int i=0;i<x.size();i++){\n          //  cerr << pppp[i] << \" \" << y[i] << endl;\n            if(pppp[i]!=y[i]){\n            //    cerr << \"test\" << endl;\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n    }\n    pair<ll,ll> res = make_pair((ll)0,(ll)0);\n    for(auto x:v){\n        if(x.size()==1)continue;\n        int id;\n        rep(i,p.size()){\n            if(p[i]==x[0])id = i;\n        }\n        int cur = x[0];\n        vector<int> c = p;\n        int aa = 0;\n        while(cur!=id){\n            cur = q[cur];\n            rep(i,n){\n                c[i] = q[c[i]];\n            }\n            aa++;\n        }\n        rep(i,x.size()){\n            if(c[x[i]]!=x[i]){\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n        pair<ll,ll> sss= make_pair(aa,x.size());\n        // for(auto tt:y){\n        //     cerr << tt << \" \";\n        // }\n        // cerr << endl;\n        // cerr << endl;\n        // cerr << sss.first << \" \" << sss.second  << endl;\n        if(res==make_pair((ll)0,(ll)0)){\n            res = sss;\n        }else{\n            res = CRT(res,sss);\n        }\n        //cerr << res.first << \" \" << res.second << endl;\n        if(res==make_pair((ll)-1,(ll)-1)){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    cout << res.first << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define vi vector<int>\n\nusing lll = __int128_t;\n\npair<lll, lll> crt(lll a1, lll m1, lll a2, lll m2)\n{\n    auto normal = [](lll x, lll m) { return x >= -x ? x % m : m - (-x) % m; };\n    auto modmul = [&normal](lll a, lll b, lll m) { return normal(a, m) * normal(b, m) % m; };\n    auto extgcd = [](lll a, lll b, lll &x, lll &y) {\n        for (lll u = y = 1, v = x = 0; a;) {\n            lll q = b / a;\n            swap(x -= q * u, u);\n            swap(y -= q * v, v);\n            swap(b -= q * a, a);\n        }\n        return b;\n    };\n    lll k1, k2;\n    lll g = extgcd(m1, m2, k1, k2);\n    if (normal(a1, g) != normal(a2, g))\n        return {-1, -1};\n    else {\n        lll l = m1 / g * m2;\n        lll x = a1 + modmul(modmul((a2 - a1) / g, k1, l), m1, l);\n        return {x, l};\n    }\n}\n\npair<lll, lll> crt(vector<lll> a, vector<lll> m)\n{\n    lll mod = 1, ans = 0;\n    lll n = a.size();\n    rep(i, n) {\n        tie(ans, mod) = crt(ans, mod, a[i], m[i]);\n        if (ans == -1) return {-1, -1};\n    }\n    return {ans, mod};\n}\n\npair<int, int> get(int pos, int num, vi &b)\n{\n    int step = 0, first = -1, second = -1;\n    int n = b.size();\n    for (int i = 0; i <= n + n; i++) {\n        if (num == pos) {\n            first = i;\n            break;\n        }\n        num = b[num-1];\n    }\n    if (first == -1) return {-1, -1};\n    for (int i = first+1; i <= n + n + n + n; i++) {\n        num = b[num-1];\n        if (num == pos) {\n            second = i;\n            break;\n        }\n    }\n    return {second - first, first};\n}\n\nsigned main()\n{\n    int n;\n    cin >> n;\n    vi target(n), base(n);\n    rep(i, n) {\n        cin >> target[i];\n    }\n    rep(i, n) {\n        cin >> base[i];\n    }\n    vector<lll> a(n), m(n);\n    rep(i, n) {\n        auto t = get(i+1, target[i], base);\n        if (t.first == -1) {\n            cout << -1 << endl;\n            return 0;\n        }\n        a[i] = (lll)t.second;\n        m[i] = (lll)t.first;\n    }\n    //rep(i, n) cout << a[i] << \" \"; cout << endl;\n    //rep(i, n) cout << m[i] << \" \"; cout << endl;\n\n    auto t = crt(a, m);\n    if (t.first == -1) {\n        cout << -1 << endl;\n    } else {\n        cout << (int)t.first << endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstd::vector<int> take_cycle(int position, const std::vector<int>& initial, const std::vector<int>& permutation) {\n\tstd::vector<int> result;\n\tint value = initial[position];\n\tdo {\n\t\tresult.push_back(value);\n\t\tvalue = permutation[value];\n\t} while (result.front() != value);\n\treturn result;\n}\nstd::pair<__int128_t, __int128_t> gcd_pair(const __int128_t a, const __int128_t b, const __int128_t ar = 1, const __int128_t br = 0, const __int128_t as = 0, const __int128_t bs = 1) {\n\tauto aa = ar * a + br * b;\n\tauto bb = as * a + bs * b;\n\tauto q = aa / bb;\n\tauto r = aa % bb;\n\tauto rr = (ar - as * q) % b * a + (br - bs * q) % a * b;\n\tif (r != rr) throw \"???\";\n\tif (r == 0) return std::make_pair((as % b + b) % b, (bs % a + a) % a);\n\telse return gcd_pair(a, b, as, bs, (ar - as * q) % b, (br - bs * q) % a);\n}\n__int128_t gcd(const __int128_t a, const __int128_t b) {\n\tif (b == 0) return a;\n\telse return gcd(b, a % b);\n}\n__int128_t lcm(const __int128_t a, const __int128_t b) {\n\treturn a / gcd(a, b) * b;\n}\n__int128_t solve(const std::vector<int>& initial, const std::vector<int>& permutation) {\n\tstd::vector<bool> taken(initial.size(), false);\n\t__int128_t first = -1;\n\t__int128_t loop_length = 0;\n\tfor (auto pos = 0; pos < initial.size(); ++pos) if (!taken[pos]) {\n\t\tauto cycle = take_cycle(pos, initial, permutation);\n\t\tauto shift = std::distance(cycle.begin(), std::find(cycle.begin(), cycle.end(), pos));\n\t\tif (shift == cycle.size()) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (auto i = 0; i < cycle.size(); ++i) {\n\t\t\ttaken[cycle[i]] = true;\n\t\t\tif (initial[cycle[(i + shift) % cycle.size()]] != cycle[i]) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (first < 0) {\n\t\t\tfirst = shift;\n\t\t\tloop_length = cycle.size();\n\t\t}\n\t\telse {\n\t\t\tauto g = gcd(loop_length, cycle.size());\n\t\t\tif (first % g != shift % g) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tauto pair = gcd_pair(loop_length, cycle.size());\n\t\t\tauto l = lcm(loop_length, cycle.size());\n\t\t\tauto next = ((pair.first % cycle.size() * (shift / g) % cycle.size() * loop_length % l + pair.second % loop_length * (first / g) % loop_length * cycle.size() % l + first % g) % l + l) % l;\n\t\t\tif (next % cycle.size() != shift || next % loop_length != first)\n\t\t\t\tthrow \"???\";\n\t\t\tfirst = next;\n\t\t\tloop_length = lcm(loop_length, cycle.size());\n\t\t}\n\t}\n\treturn first;\n}\n\nstd::ostream& operator<<(std::ostream& os, __int128_t value) {\n\tif (value == -1) return os << -1;\n\tif (value == 0) return os << 0;\n\tstd::vector<int> digits;\n\twhile (value != 0) {\n\t\tdigits.push_back(value % 10);\n\t\tvalue /= 10;\n\t}\n\tstd::reverse(digits.begin(), digits.end());\n\tfor (auto d : digits) os << d;\n\treturn os;\n}\nint main() {\n\tint n; std::cin >> n;\n\tstd::vector<int> initial(n), permutation(n); for (auto& p : initial) { std::cin >> p; --p; }; for (auto& p : permutation) { std::cin >> p; --p; };\n\tstd::cout << solve(initial, permutation) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(sz[x] > sz[y]) swap(x, y);\n        par[x] = y;\n        sz[y] += sz[x];\n        return true;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint64_t mod(int64_t a, int64_t m) {\n    return (a % m + m) % m;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\npair<int64_t, int64_t> crt(int64_t b1, int64_t m1, int64_t b2, int64_t m2){\n    int64_t p, q;\n    int64_t d = extgcd(m1, m2, p, q);\n    if((b2-b1) % d != 0) return {-1, -1};\n    int64_t m = m1 * (m2/d);\n    int64_t tmp = (b2 - b1) / d * p % (m2/d);\n    int64_t r = mod(b1 + m1 * tmp, m);\n    return make_pair(r, m);\n}\n\nint main(){\n    int N;\n    int P[200], Q[200];\n    cin >> N;\n    for(int i=0; i<N; i++){\n        cin >> P[i];\n        P[i]--;\n    }\n    UnionFind uf(N);\n    for(int i=0; i<N; i++){\n        cin >> Q[i];\n        Q[i]--;\n        uf.unite(i, Q[i]);\n    }\n    pair<int64_t, int64_t> ans = {0, 1};\n    for(int i=0; i<N; i++) if(uf.find(i) == i){\n        int sz = uf.size(i), t = 0;\n        bool ok = false;\n        while(t <= sz){\n            ok = true;\n            for(int j=0; j<N; j++) if(uf.same(i, P[j]) && j != P[j]) ok = false;\n            if(ok) break;\n            t++;\n            for(int j=0; j<N; j++) if(uf.same(i, P[j])) P[j] = Q[P[j]];\n        }\n        if(!ok){\n            cout << -1 << endl;\n            return 0;\n        }\n        ans = crt(ans.first, ans.second, t, sz);\n        if(ans.first == -1){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    cout << ans.first << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <set>\n#include <vector>\n\nusing namespace std;\nusing ll = __int128;\n#define REP(i, n) for (ll i = 0; i < n; ++i)\n#define ALL(v) v.begin(), v.end()\n\nstruct CRT {\n\tusing P = pair<ll, ll>;\n\tP calc(vector<ll> &r, vector<ll> &m) {\n\t\tassert(r.size() == m.size());\n\t\tll R = 0, M = 1;\n\t\tREP(i, r.size()) {\n\t\t\tP p = calc(R, M, r[i], m[i]);\n\t\t\tif (p.second == -1) {\n\t\t\t\treturn P(0, -1);\n\t\t\t}\n\t\t\tR = p.first;\n\t\t\tM = p.second;\n\t\t}\n\t\treturn P(R, M);\n\t}\n\tll extgcd(ll a, ll b, ll &p, ll &q) {\n\t\tif (b == 0) {\n\t\t\tp = 1;\n\t\t\tq = 0;\n\t\t\treturn a;\n\t\t}\n\t\tll d = extgcd(b, a % b, q, p);\n\t\tq -= (a / b) * p;\n\t\treturn d;\n\t}\n\tP calc(ll r1, ll m1, ll r2, ll m2) {\n\t\tll p, q;\n\t\tll d = extgcd(m1, m2, p, q);\n\t\tif ((r2 - r1) % d != 0) {\n\t\t\treturn P(0, -1);\n\t\t}\n\t\tll M = m1 / d * m2;\n\t\treturn P((r1 + ((r2 - r1) / d) * p % M * m1 % M + M) % M, M);\n\t}\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> p(n), q(n);\n\tREP(i, n) {\n\t\tcin >> p[i];\n\t\tp[i]--;\n\t}\n\tREP(i, n) {\n\t\tcin >> q[i];\n\t\tq[i]--;\n\t}\n\n\tvector<ll> r(n), m(n);\n\n\tREP(i, n) {\n\t\tint a = i;\n\t\tint cnt = 0;\n\t\twhile (1) {\n\t\t\tif (cnt > 0 && a == i) break;\n\t\t\tcnt++;\n\t\t\ta = q[a];\n\t\t}\n\t\tm[i] = cnt;\n\t}\n\tREP(i, n) {\n\t\tmap<int, int> mp;\n\t\tint a = p[i];\n\t\tint k = 0;\n\t\twhile (1) {\n\t\t\tif (mp.count(a)) {\n\t\t\t\tif (mp.count(i) == 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tr[i] = mp[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmp[a] = k;\n\t\t\ta = q[a];\n\t\t\tk++;\n\t\t}\n\t}\n\n\tCRT crt;\n\tauto ans = crt.calc(r, m);\n\tif (ans.second == -1) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << (long long )ans.first << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define X first\n#define Y second\n#define eb emplace_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define all(v) v.begin(),v.end()\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define EFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP rep\nusing vint=vector<int>;\ntypedef __int128 ll;\ntypedef ll LL;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> inline bool MX(T&l, const T&r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T&l, const T&r){return l>r?l=r,1:0;}\n\nint N;\nint when[214];\nbool is_composite[414];\nvector<int> primes;\n\n\n//#define int long long\n\nLL extgcd(LL a, LL b, LL &x, LL &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n\n  LL ret = extgcd(b, a%b, x, y);\n  LL nx = y;\n  LL ny = x - a/b*y;\n  x = nx;\n  y = ny;\n  return ret;\n}\n\nLL china2(const vector<LL> &a, const vector<LL> &m) {\n  __int128 p=1;\n  LL re=0, pp,x,y;\n  rep(i, m.size()) {\n    p *= m[i];\n    if (p > 1000000000000000000) break;\n  }\n  rep(i, m.size()) {\n    pp = p/m[i];\n    extgcd(m[i], pp, x, y);\n    (re+=pp*y%p*a[i]%p) %= p;\n  }\n  return (re%p+p)%p;\n}\n\nint updChina(map<LL,pll> &mp, LL a, LL m, LL p) {\n  if (mp.count(p)) {\n    pll tmp = mp[p];\n    if ((tmp.X-a)%min(tmp.Y, m)) return 1;\n\n    if (tmp.Y < m) mp[p] = pll(a, m);\n  } else {\n    mp[p] = pll(a, m);\n  }\n  return 0;\n}\n\nLL china(const vector<LL> &a, const vector<LL> &m) {\n  map<LL, pll> mp;\n  pll tmp;\n  LL num, p=1;\n  rep(i, a.size()) {\n    num = m[i];\n    rep(j, primes.size()) if (m[i]%primes[j]==0) {\n      p = 1;\n      while (num%primes[j] == 0) {\n        p*=primes[j];\n        num/=primes[j];\n      }\n      if (updChina(mp, a[i], p, primes[j])) return -1;\n    }\n    if (num > 1) if (updChina(mp, a[i], num, num)) return -1;\n  }\n  vector<LL> aa, mm;\n  for (auto temp : mp) {\n    num=temp.Y.X; p=temp.Y.Y;\n    aa.pb((num%p+p)%p);\n    mm.pb(p);\n  }\n  return china2(aa,mm);\n}\n\nvint Merge(vint &p, vint &q) {\n  vint ret(N);\n  rep(i, N) {\n    ret[i] = q[p[i]];\n  }\n  return ret;\n}\n\nsigned  main(){\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n\n  reps(i, 2, 214) {\n    if (is_composite[i]) continue;\n    primes.eb(i);\n    for (int j=i*i; j<214; j+=i) {\n      is_composite[j] = true;\n    }\n  }\n\n  cin >> N;\n\n  vector<int> P(N);\n  vector<int> Q(N);\n  rep(i, N) {\n    cin >> P[i];\n    --P[i];\n  }\n  rep(i, N) {\n    cin >> Q[i];\n    --Q[i];\n  }\n\n  fill(when, when+N, -1);\n\n  vint cur = P;\n  vector<LL> a(N, -1);\n  vector<LL> b(N, -1);\n  rep(i, N*3) {\n    rep(j, N) {\n      if (cur[j] == j) {\n        if (when[j] == -1) when[j] = i;\n        else if (a[j] == -1) {\n          a[j] = i-when[j];\n          b[j] = when[j];\n          assert(a[j] > b[j]);\n        }\n      }\n    }\n\n    cur = Merge(cur, Q);\n  }\n\n  long long ans = (long long) china(b, a);\n  if (ans == -1) {\n    cout << ans << endl; \n    return 0;\n  }\n  vint perm(N);\n  rep(i, N) perm[i] = i;\n  vint mul = Q;\n  rep(i, 62) {\n    if (ans >> i & 1) {\n      perm = Merge(perm, mul);\n    }\n    mul = Merge(mul, mul);\n  }\n  auto test = Merge(perm, P);\n  rep(i, N) {\n    if (test[i] != i) {\n      cout << \"-1\\n\";\n      return 0;\n    }\n  }\n  \n  cout << ans << endl;\n} \n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 2e5 + 10;\nll a[N], m[N], p[N], q[N];\n\nll mul(ll a, ll b, ll P) {\n\tll res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % P)\n\t\tif (b & 1) res = (res + a) % P;\n\treturn res;\n}\nvoid exgcd(ll a, ll b, ll &g, ll &x, ll &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= a / b * x;\n}\nll exCRT(ll n, ll a[], ll m[]) {\n\tll ans = a[1], M = m[1];\n\tfor (ll i = 2; i <= n; i++) {\n\t\tll g, x, y, c;\n\t\tif (m[i] == 1) continue ;\n\t\texgcd(M, m[i], g, x, y);\n\t\tc = (a[i] - ans % m[i] + m[i]) % m[i];\n\t\tif (c % g) return -1;\n\t\tll p = m[i] / g;\n\t\tx = mul(x, c / g, p);\n\t\tans += x * M;\n\t\tM = M * p;\n\t\tans = (ans % M + M) % M;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tll n;\n\tbool flag = 0;\n\tscanf(\"%lld\", &n);\n\tfor (int i = 1; i <= n; i++) \n\t\tscanf(\"%lld\", &p[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &q[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tll x = q[i]; m[i] = 1;\n\t\twhile (x != i && m[i] <= n) x = q[x], m[i]++;\n\t\tif (m[i] > n) flag = 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tll x = p[i];\n\t\twhile (x != i && a[i] <= n) x = q[x], a[i]++;\n\t\tif (a[i] > n) flag = 1;\n\t}\n\tprintf(\"%lld\\n\", flag ? -1 : exCRT(n, a, m));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = 1'000'000'007; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\nvoid extgcd(int a, int b, int &x, int &y){\n\tif(b == 0){\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn ;\n\t}\n\textgcd(b,a%b,y,x);\n\ty -= a/b * x;\n}\n\nint mod_inverse(int a, int m){\n\tint x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m ) % m;\n}\n\nint gcd(int a, int b) {return a%b?gcd(b, a%b):b;};\n\npair<int,int> liner_congrunce(const vector<int>& A, const vector<int>& B, const vector<int>& M){\n\t\n\tint x = 0, m = 1;\n\t\n\tfor(int i = 0; i < A.size(); i++){ //cout<<\"i = \"<<i<<\" A = \"<<A[i]<<\" B = \"<<B[i]<<\" M = \"<<M[i]<<endl;\n\t\tint a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n\t\tif(b % d != 0) return make_pair(0, -1);\n\t\tint t =  b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\t\n\treturn make_pair((x%m + m) % m, m);\n}\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint N;\n\tvector<int> P, Q, T, C, con1, con2, con0;\n\t\n\tcin>>N;\n\t\n\tP.assign(N,0);\n\tQ.assign(N,0);\n\tT.assign(N,0);\n\tC.assign(N,0);\n\tcon1.assign(N,-1);\n\tcon2.assign(N,-1);\n\tcon0.assign(N,1);\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin>>P[i];\n\t\tP[i]--;\n\t\tC[P[i]] = i;\n\t\tT[i] = P[i];\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin>>Q[i];\n\t\tQ[i]--;\n\t}\n\t\n\tfor(int i = 0; i < N*2; i++){\n\t\t// cout<<\"---------- <><> \"<<i<<endl;\n\t\t// for(int j = 0; j < N; j++){\n\t\t\t// cout<<T[j]<<\" \";\n\t\t// }\n\t\t// cout<<endl;\n\t\t\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(T[j] == j){\n\t\t\t\tif(con1[j] == -1){\n\t\t\t\t\tcon1[j] = i;\n\t\t\t\t} else if(con2[j] == -1){\n\t\t\t\t\tcon2[j] = i - con1[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tT[j] = Q[T[j]];\n\t\t}\n\t}\n\t\n\tpair<int,int> ans;\n\t\n\tans = liner_congrunce(con0, con1, con2);\n\t\n\tif(ans.second == -1) cout<<-1<<endl;\n\telse cout<<ans.first<<endl;\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;};\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;};\n\ntemplate<typename T> void drop(T x){cout<<x<<endl;exit(0);};\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y){\n  T d = a;\n  if(b != 0){\n    d = extgcd(b, a%b, y, x);\n    y -=(a/b) * x;\n  }else{\n    x = 1;\n    y = 0;\n  }\n  return d;\n}\n\ntemplate<typename T>\nT mod_inverse(T a, T mod){\n  T x, y;\n  extgcd(a, mod, x, y);\n  return (mod + x%mod)%mod;\n}\n\ntemplate<typename T>\npair<T, T> linear_congruence(const vector<T> &A,\n                            const vector<T> &B,\n                            const vector<T> &M){\n  T x = 0, m = 1;\n  for(int i=0;i<(int)A.size();i++){\n    T a = A[i] * m, b = B[i] - A[i]*x, d = __gcd(M[i], a);\n    if(b%d!=0) return make_pair(0, -1);\n    T t=b/d*mod_inverse(a/d, M[i]/d)%(M[i]/d);\n    x = x + m * t;\n    m *= M[i]/d;\n  }\n  return make_pair((x%m + m)%m, m);\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n;\n  cin>>n;\n  vector<int> ps(n),qs(n);\n  for(int i=0;i<n;i++) cin>>ps[i],ps[i]--;\n  for(int i=0;i<n;i++) cin>>qs[i],qs[i]--;\n\n  using ll = long long;\n  vector<ll> A,B,M;\n\n  vector<int> used(n,0);\n  for(int i=0;i<n;i++){\n    if(used[i]) continue;\n    int pos=i;\n    vector<int> vs,ws;\n    while(!used[pos]){\n      vs.emplace_back(pos);\n      ws.emplace_back(ps[pos]);\n      used[pos]=1;\n      pos=qs[pos];\n    }\n    {\n      auto as=vs,bs=ws;\n      sort(as.begin(),as.end());\n      sort(bs.begin(),bs.end());\n      if(as!=bs) drop(-1);\n    }\n    int m=vs.size();\n    for(int j=0;j<m;j++)\n      ws.emplace_back(int(ws[j]));\n\n    const int DEBUG = 0;\n    if(DEBUG){\n      for(int j=0;j<m;j++) cout<<vs[j]<<\" \";\n      cout<<endl;\n      for(int j=0;j<m;j++) cout<<ws[j]<<\" \";\n      cout<<endl;\n    }\n\n    for(int j=0;j<m;j++){\n      if(ws[j]!=vs[0]) continue;\n      for(int k=0;k<m;k++)\n        if(ws[j+k]!=vs[k]) drop(-1);\n\n      //cout<<1<<\" \"<<j<<\" \"<<m<<endl;\n      A.emplace_back(1);\n      B.emplace_back(j);\n      M.emplace_back(m);\n    }\n  }\n\n  auto res=linear_congruence(A,B,M);\n  if(res.second<0) drop(-1);\n  cout<<(long long)(res.first)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\n////drkenさんの記事より\ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n\nlong long extGcd(long long a, long long b, long long &p, long long &q) {  \n    if (b == 0) { p = 1; q = 0; return a; }  \n    long long d = extGcd(b, a%b, q, p);  \n    q -= a/b * p;  \n    return d;  \n}\n\n// 中国剰余定理\n// リターン値を (r, m) とすると解は x ≡ r (mod. m)\n// 解なしの場合は (0, -1) をリターン\npair<long long, long long> ChineseRem(const vector<long long> &b, const vector<long long> &m) {\n  long long r = 0, M = 1;\n  for (int i = 0; i < (int)b.size(); ++i) {\n    long long p, q;\n    long long d = extGcd(M, m[i], p, q); // p is inv of M/d (mod. m[i]/d)\n    if ((b[i] - r) % d != 0) return make_pair(0, -1);\n    long long tmp = (b[i] - r) / d * p % (m[i]/d);\n    r += M * tmp;\n    M *= m[i]/d;\n  }\n  return make_pair(mod(r, M), M);\n}\n\n//\nint n;\nint p[200];\nint q[200];\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n;\n\trep(i, n) cin >> p[i];\n\trep(i, n) cin >> q[i];\n\t\n\tvector<long long> b;\n\tvector<long long> m;\n\t\n\trep(i, n) {\n\t\tint x = p[i];\n\t\trep(j, n + 1) {\n\t\t\tif (x == i + 1) break;\n\t\t\tx = q[x - 1];\n\t\t}\n\t\tif (j == n + 1) { cout << -1 << endl; return 0; }\n\t\t\n\t\tb.push_back(j);\n\t\t\n\t\tx = p[i];\n\t\trep(j, n + 1) {\n\t\t\tx = q[x - 1];\n\t\t\tif (x == p[i]) break;\n\t\t}\n\t\tm.push_back(j + 1);\n\t}\n\t\n\t//rep(i, n) cout << b[i] << \", \" << m[i] << endl;\n\t\n\tpair<long long, long long> ans = ChineseRem(b, m);\n\tif (ans.second == -1) { cout << -1 << endl; }\n\telse { cout << ans.first << endl; }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 2005\n\n\nint N;\nll P[SIZE],Q[SIZE];\nll cycle[SIZE],ok_count[SIZE];\n\nll gcd(ll x,ll y){\n\n\tx = abs(x);\n\ty = abs(y);\n\n\tif(x < y){\n\t\tswap(x,y);\n\t}\n\tif(y == 0){\n\t\treturn x;\n\t}else{\n\t\treturn gcd(y,x%y);\n\t}\n}\n\nll extgcd(ll a,ll b,ll &x,ll &y){\n\tll d = a;\n\tif(b != 0){\n\t\td = extgcd(b,a%b,y,x);\n\t\ty -= (a/b)*x;\n\t}else{\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\n//A[i]*x≡B[i](mod M[i])のxを求める\npair<ll,ll> linear_congruence(const vector<ll>&A, const vector<ll>&B,const vector<ll>&M){\n\n\tll x = 0,m = 1;\n\tfor(int i = 0; i < A.size(); i++){\n\t\tll a = A[i]*m,b = B[i]-A[i]*x,d = gcd(M[i],a);\n\t\tif(b%d != 0)return make_pair(0,-1); //解がない\n\t\tint t = b / d * mod_inverse(a/d,M[i]/d) % (M[i]/d);\n\t\tx = x+m*t;\n\t\tm *= M[i]/d;\n\t}\n\treturn make_pair(x%m,m);\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tscanf(\"%lld\",&P[i]);\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tscanf(\"%lld\",&Q[i]);\n\t}\n\n\tvector<ll> A,B,M;\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tll first = P[i],tmp = P[i];\n\t\tint count = 0;\n\n\t\tok_count[i] = -1;\n\n\t\twhile(true){\n\n\t\t\tif(tmp == i){\n\n\t\t\t\tok_count[i] = count;\n\t\t\t}\n\t\t\ttmp = Q[tmp];\n\t\t\tcount++;\n\n\t\t\tif(tmp == first){\n\t\t\t\tcycle[i] = count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(ok_count[i] == -1){\n\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tA.push_back(1);\n\t\tB.push_back(ok_count[i]);\n\t\tM.push_back(cycle[i]);\n\t}\n\n\tpair<ll,ll> ans = linear_congruence(A,B,M);\n\n\tif(ans.second == -1){\n\n\t\tprintf(\"-1\\n\");\n\n\t}else{\n\n\t\tprintf(\"%lld\\n\",(ans.first+ans.second)%ans.second);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for (int i = (a); i < (b); i++)\n#define rep(i, b) for (int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define int long long\nusing namespace std;\n\ntemplate <typename X, typename T>\nauto vectors(X x, T a) {\n\treturn vector<T>(x, a);\n}\n\ntemplate <typename X, typename Y, typename Z, typename... Zs>\nauto vectors(X x, Y y, Z z, Zs... zs) {\n\tauto cont = vectors(y, z, zs...);\n\treturn vector<decltype(cont)>(x, cont);\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n\trep(i, v.size()) { os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); }\n\treturn os;\n}\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n\tfor (T& x : v) { is >> x; }\n\treturn is;\n}\n\n// a x + b y = gcd(a, b)\nint extgcd(int a, int b, int& x, int& y) {\n\tint g = a;\n\tx = 1;\n\ty = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\n\n\nint gcd(int x, int y) {\n\tint r;\n\tif(x < y) swap(x, y);\n\n\twhile(y > 0){\n\t\tr = x % y;\n\t\tx = y;\n\t\ty = r;\n\t}\n\treturn x;\n}\n\n/* mod mでのaの逆元を求める.(gcd(a,m) = 1) */\nint modinv(int a, int m) {\n\tint x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\n/* 連立線形方程式を解く.\n\t\tA[i] * x ≡ B[i] (mod M[i])\n\tなる方程式の解が\n\t\tx ≡ b (mod m)\n\tとかけるとき、(b, m)を返す.(存在しなければ(0, -1)) */\npair<int, int> liner_congruence(vector<int> A, vector<int> B, vector<int> M) {\n\tint x = 0, m = 1;\n\n\tfor (int i = 0; i < A.size(); ++i) {\n\t\tint a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n\n\t\tif (b % d != 0) // 解なし\n\t\t\treturn make_pair(0, -1);\n\n\t\tint t = b / d * modinv(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\n\treturn make_pair((x % m + m) % m, m);\n}\n\nsigned main() {\n\tint n;\n\tcin >> n;\n\tvector<int> p(n), q(n);\n\tcin >> p >> q;\n\tfor (auto& i : p) i--;\n\tfor (auto& i : q) i--;\n\n\tvector<int> a(n, 1), b(n, -1), m(n);\n\trep(i, n) {\n\t\tint cur = p[i];\n\t\tint loop = 0;\n\t\twhile (cur != p[i] or loop == 0) {\n\t\t\tloop++;\n\t\t\tcur = q[cur];\n\t\t\tif (i == cur) b[i] = loop;\n\t\t}\n\t\tif(b[i] > loop) b[i] %= loop;\n\t\tm[i] = loop;\n\t}\n\t//cout << b << endl;\n\t//cout << m << endl;\n\tif (any_of(all(b), [](int x) { return x == -1; })) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tauto tmp = liner_congruence(a, b, m);\n\t\tif (tmp == make_pair(0LL, -1LL)) cout << -1 << endl;\n\t\telse cout << tmp.first << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nlong long has[205][205], lop[205], wok[205], Lop[205], Wok[205];\nlong long P[205], Q[205];\nlong long N[205];\nlong long ans;\nlong long ex_gcd(long long a,long long b,long long &x,long long &y)\n{\n    if(b==0)\n    {\n        x=1;y=0;\n        return a;\n    }\n    long long r=ex_gcd(b,a%b,x,y);\n    long long t=x;\n    x=y;\n    y=t-a/b*y;\n    return r;\n};\nlong long a[205], m[205], n;\nlong long CRT(long long a[], long long m[], long long n) {\n    if (n == 1) {\n        if (m[0] > a[0]) return a[0];\n        else return -1;\n    }\n    long long x, y, d;\n    for (int i = 1; i < n; i++) {\n        if (m[i] <= a[i]) return -1;\n        d = ex_gcd(m[0], m[i], x, y);\n        if ((a[i] - a[0]) % d != 0) return -1;\n        long long t = m[i] / d;\n        x = ((a[i] - a[0]) / d * x % t + t) % t;\n        a[0] = x * m[0] + a[0];\n        m[0] = m[0] * m[i] / d;\n        a[0] = (a[0] % m[0] + m[0]) % m[0];\n    }\n    return a[0];\n}\n\nlong long gcd(long long a,long long b)\n{\n    if(b==0)\n        return a;\n    return\n        gcd(b,a%b);\n}\nvoid check(long long i){\n    long long temp = Q[i], last = i;\n    has[i][i] = 0;\n    while(has[i][temp] == -1)\n        has[i][temp] = has[i][last] + 1, last = temp, temp = Q[temp];\n    lop[i] = has[i][last] + 1 - has[i][temp];\n    return ;\n}\nint main() {\n    long long N;\n    memset(has, -1, sizeof has);\n    cin >> N;\n    for(long long i = 1; i <= N; i++)\n        cin >> P[i], ans = (P[i] == i ? ans : 1);\n    for(long long i = 1; i <= N; i++)\n        cin >> Q[i];\n    for(long long i = 1; i <= N; i++)\n        check(i);\n    for(long long i = 1; i <= N; i++) {\n        if(has[P[i]][i] == -1) {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n        wok[i] = has[P[i]][i];\n    }\n    for(long long i = 1; i < N; i++)\n        for(long long j = i + 1; j <= N; j++)\n            if(lop[j] > lop[i])\n                swap(lop[i], lop[j]), swap(wok[i], wok[j]);\n    for(long long i = 1; i <= N; i++) {\n        if(lop[i] == lop[i - 1] && wok[i] != wok[i - 1]) {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n        long long temp = 0;\n        if(lop[i] == 1){\n            if(temp == 0)\n                temp = 1;\n            temp = temp / gcd(temp, wok[i]) * wok[i];\n        }\n        else if(lop[i] != lop[i - 1])\n            Lop[++Lop[0]] = lop[i], Wok[Lop[0]] = (wok[i] + temp) % lop[i];\n    }\n    //for(long long i = 1; i <= N; i++)\n    /*    cout << Wok[i] << \" \";\n    cout << endl;\n    for(long long i = 1; i <= N; i++)\n        cout << Lop[i] << \" \";\n    cout << endl;*/\n    cout << CRT(Wok + 1, Lop + 1, Lop[0]) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint gcd(int a, int b){\n\tif(b == 0){\n\t\treturn a;\n\t}\n\telse{\n\t\treturn gcd(b, a % b);\n\t}\n}\n\nint lcm(int a, int b){\n\treturn (a / gcd(a, b)) * b;\n}\n\nint MOD_m(int a, int m){\n\ta %= m;\n\treturn a >= 0 ? a : a + m;\n}\n\npair<int, int> Extention_Euclidean(int x, int y){\n\tif(y == 0){\n\t\treturn pair<int, int>(1, 0);\n\t}\n\telse{\n\t\tpair<int, int> p = Extention_Euclidean(y, x % y);\n\t\treturn pair<int, int>(p.second, p.first - p.second * (x / y));\n\t}\n}\n\nint inverse_m(int a, int m){\n\tif(gcd(a, m) > 1){\n\t\treturn -1;\n\t}\n\telse{\n\t\treturn MOD_m(Extention_Euclidean(a, m).first, m);\n\t}\n}\n\nint Garner(vector<int> &_a, vector<int> &_m, int N, int M){\n\tint i, j;\n\tvector<int> a(N), m(N);\n\tfor(i = 0; i < N; i++){\n\t\ta[i] = _a[i] % _m[i];\n\t\tm[i] = _m[i];\n\t}\n\tint g, gi, gj;\n\tfor(i = 0; i < N; i++){\n\t\tfor(j = i + 1; j < N; j++){\n\t\t\tg = gcd(m[i], m[j]);\n\t\t\tif(MOD_m(a[i] - a[j], g) != 0){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tm[i] /= g;\n\t\t\tm[j] /= g;\n\t\t\tgi = gcd(m[i], g);\n\t\t\tgj = g / gi;\n\t\t\tfor(g = gcd(gi, gj); g > 1; g = gcd(gi, gj)){\n\t\t\t\tgi *= g;\n\t\t\t\tgj /= g;\n\t\t\t}\n\t\t\tm[i] *= gi;\n\t\t\tm[j] *= gj;\n\t\t\ta[i] = MOD_m(a[i], m[i]);\n\t\t\ta[j] = MOD_m(a[j], m[j]);\n\t\t}\n\t}\n\tint T, ms, x;\n\tvector<int> t(N);\n\tt[0] = a[0];\n\tfor(i = 1; i < N; i++){\n\t\tT = 0;\n\t\tms = 1;\n\t\tfor(j = 0; j < i; j++){\n\t\t\tT = MOD_m(T + t[j] * ms, m[i]);\n\t\t\tms = MOD_m(ms * m[j], m[i]);\n\t\t}\n\t\tt[i] = MOD_m((a[i] - T) * inverse_m(ms, m[i]), m[i]);\n\t}\n\tx = 0;\n\tms = 1;\n\tfor(i = 0; i < N; i++){\n\t\tx = MOD_m(x + t[i] * ms, M);\n\t\tms = MOD_m(ms * m[i], M);\n\t}\n\treturn x;\n}\n\nsigned main(){\n\tint N, i, j;\n\tscanf(\"%lld\", &N);\n\tvector<int> P(N), Q(N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &P[i]);\n\t\tP[i]--;\n\t}\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &Q[i]);\n\t\tQ[i]--;\n\t}\n\tvector<int> is_visit(N, 0);\n\tvector<vector<int>> e(N, vector<int>(0));\n\tfor(i = 0; i < N; i++){\n\t\tif(is_visit[i] == 0){\n\t\t\te[i].push_back(i);\n\t\t\tfor(int j = Q[i]; j != i; j = Q[j]){\n\t\t\t\te[i].push_back(j);\n\t\t\t}\n\t\t\t//e[i].push_back(i);\n\t\t}\n\t}\n\n\tvector<int> a(N), b(N);\n\tfor(i=0;i<N;i++){\n\t\tfor(int j=0;j<e[P[i]].size();j++){\n\t\t\t//printf(\"test4%d %d\\n\", i, e[P[i]][j]);\n\t\t\tif(e[P[i]][j]==i){\n\t\t\t\ta[i]=j;\n\t\t\t\tb[i]=e[P[i]].size();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(j==e[P[i]].size()-1){\n\t\t\t\tprintf(\"-1\\n\");return 0;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"test5\\n\");\n\n\tint res = Garner(a, b, N, (int)(1e18 + 100));\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pii;\n#define mk make_pair\nconst int N=205;\nint n,a[N],b[N],nxt[N];\nstack<pii> stk;\nvector<int> v;\nint vis[N],tot=0,pos[N],tmppos[N];\npii t[N];\nint lcm=0,rest=0;\n\nint gcd(int x,int y)\n{\n    if(!y) return x;\n    return gcd(y,x%y);\n}\n\nint _abs(int x)\n{\n    if(x<0) return -x;\n    return x;\n}\n\nvoid dfs(int u)\n{\n    vis[u]=1;\n    stk.push(mk(u,pos[u]));\n    if(!vis[nxt[u]]) dfs(nxt[u]);\n}\n\nvoid init()\n{\n    scanf(\"%lld\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),pos[a[i]]=i;\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&b[i]);\n    for(int i=1;i<=n;i++) nxt[a[i]]=b[a[i]];\n}\n\nvoid change()\n{\n    for(int i=1;i<=tot;i++) t[i].first=nxt[t[i].first];\n}\n\nint judge()\n{\n    for(int i=1;i<=tot;i++) tmppos[i]=t[i].second;\n    int bl=1;\n    for(int j=1;j<=tot;j++) if(t[j].first!=tmppos[j]) bl=0;\n    if(bl) return 0;\n    for(int i=1;i<tot;i++)\n    {\n        change();\n        bl=1;\n        for(int j=1;j<=tot;j++) if(t[j].first!=tmppos[j]) bl=0;\n        if(bl) return i;\n    }\n    return -1;\n}\n\nvoid update(int &lcm,int &rest,int step,int sz)\n{\n    if(lcm==0)\n    {\n        lcm=sz; rest=step;\n        return;\n    }\n    int delta=_abs(rest-step);\n    int g=gcd(sz,lcm);\n    if(delta%g!=0)\n    {\n        puts(\"-1\");\n        exit(0);\n    }\n    if(delta==0)\n    {\n        lcm=lcm*sz/g;\n        return;\n    }\n    int now=rest; \n    if(now%sz==step) return;\n    for(int ttt=1;ttt<=sz;ttt++)\n    {\n        now+=lcm;\n        if(now%sz==step) \n        {\n            break;\n        }\n    }\n    //cout<<\"now=\"<<now<<endl;\n    lcm=lcm*sz/g; rest=now;\n}\n\nvoid solve()\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(!vis[i]) \n        {\n            tot=0;\n            while(!stk.empty()) stk.pop();\n            dfs(i);\n            while(!stk.empty()) t[++tot]=stk.top(),stk.pop(); \n            //for(int i=1;i<=tot;i++) cout<<t[i].first<<\" \"<<t[i].second<<endl;\n            int step=judge();\n            if(tot==1)\n            if(step==-1)\n            {\n                puts(\"-1\");\n                exit(0);\n            }\n            update(lcm,rest,step,tot); //cout<<\"OK\"<<step<<\" \"<<tot<<endl;\n        }\n    }\n}\n\nsigned main()\n{\n    init();\n    solve();\n    printf(\"%lld\\n\",rest);\n    return 0;\n}//\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, p[210], q[210], m[210], a[210];\n\nlong long extend_gcd(long long a,long long b,long long &x,long long &y)\n{\n    if(a == 0 && b == 0)return -1;\n    if(b ==0 ){x = 1; y = 0;return a;} long long d = extend_gcd(b,a%b,y,x); y -= a/b*x;\n    return d;\n}\n\n\nbool solve(long long &m0, long long &a0, int m, int a)\n{\n    long long y,x;\n    long long g = extend_gcd(m0,m,x,y);\n    if( abs(a - a0)%g ) return false;\n    x *= (a - a0)/g;\n    x %= m/g;\n    a0 = (x*m0 + a0); m0 *= m/g;\n    a0 %= m0;\n    if( a0 < 0 )a0 += m0;\n    return true;\n}\n\n\nbool MLES(long long &m0, long long &a0, int n)\n{\n    bool flag = true; m0 = 1;\n    a0 = 0;\n    for(int i = 1; i <= n; i++)\n        if( !solve(m0, a0, m[i], a[i]))\n        {\n            flag = false;\n            break;\n        }\n    return flag;\n}\n\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i=1; i<=n; i++) scanf(\"%d\", &p[i]);\n    for (int i=1; i<=n; i++) scanf(\"%d\", &q[i]);\n    for (int i=1; i<=n; i++)\n    {\n        int x=p[i], count=0;\n        a[i]=-1;\n        for (;;)\n        {\n            if (x==i) a[i]=count;\n            x=q[x];\n            count++;\n            \n            if (x==p[i])\n            {\n                m[i]=count;\n                break;\n            }\n        }\n        if (a[i]==-1) { puts(\"-1\"); return 0; }\n    }\n    long long m0, a0;\n    if (!MLES(m0, a0, n)) { puts(\"-1\"); return 0; }\n    else\n    {\n        printf(\"%lld\\n\", (a0+m0)%m0);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nlint tmod(lint a, lint p) { return (a %= p) < 0 ? a + p : a; }\nlint mod_inv(lint a, lint p) {\n    a = tmod(a, p);\n    lint b = p, x = 1, u = 0;\n    while (b) {\n        lint q = a / b;\n        swap(a -= q * b, b);\n        swap(x -= q * u, u);\n    }\n    return a == 1 ? tmod(x, p) : -1;\n}\n\nbool pre(V<lint>& a, V<lint>& p) {\n    assert(a.size() == p.size());\n    int n = a.size();\n    for (int i = 0; i < n; ++i) {\n        a[i] = tmod(a[i], p[i]);\n    }\n    for (int i = 0; i < n; ++i) for (int j = i + 1; j < n; ++j) {\n        lint d = __gcd(p[i], p[j]);\n        if (a[i] % d != a[j] % d) return false;\n        p[i] /= d;\n        p[j] /= d;\n        while (true) {\n            lint e = __gcd(d, p[j]);\n            if (e == 1) break;\n            p[j] *= e;\n            d /= e;\n        }\n        p[i] *= d;\n        a[i] %= p[i];\n        a[j] %= p[j];\n    }\n    return true;\n}\n\nlint CRT(const V<lint>& a, const V<lint>& p) {\n    int n = a.size();\n    lint x = 0;\n    V<lint> y(n);\n    lint prod = 1;\n    for (int i = 0; i < n; ++i) {\n        y[i] = tmod(a[i] - x, p[i]);\n        for (int j = 0; j < i; ++j) {\n            (y[i] *= mod_inv(p[j], p[i])) %= p[i];\n        }\n        x += prod * y[i];\n        prod *= p[i];\n    }\n    return x;\n}\n\nint main() {\n    int n; cin >> n;\n    V<> p(n); for (auto&& e : p) cin >> e, --e;\n    V<> q(n); for (auto&& e : q) cin >> e, --e;\n    VV<> v;\n    V<bool> used(n);\n    for (int i = 0; i < n; ++i) if (!used[i]) {\n        V<> nv;\n        int t = i;\n        while (true) {\n            nv.push_back(t);\n            t = q[t];\n            if (t == i) break;\n        }\n        for (int e : nv) used[e] = true;\n        v.push_back(nv);\n    }\n    // for (const auto& e : v) {\n    //     for (int f : e) cerr << f << ' ';\n    //     cerr << endl;\n    // }\n    V<lint> a, pr;\n    for (const auto& y : v) {\n        V<> x;\n        for (int e : p) if (find(begin(y), end(y), e) != end(y)) {\n            x.push_back(e);\n        }\n        pr.push_back(y.size());\n        for (int i = 0; i < pr.back(); ++i) {\n            // for (int e : x) {\n                // cerr << e << ' ';\n            // }\n            // cerr << \" x\\n\";\n            if (is_sorted(begin(x), end(x))) {\n                a.push_back(i);\n                break;\n            }\n            for (auto&& e : x) {\n                int j = find(begin(y), end(y), e) - begin(y);\n                e = y[(j + 1) % pr.back()];\n            }\n        }\n        if (a.size() < pr.size()) {\n            return cout << -1 << endl, 0;\n        }\n        // cerr << a.back() << ' ' << pr.back() << endl;\n    }\n    if (!pre(a, pr)) {\n        return cout << -1 << endl, 0;\n    }\n    lint res = CRT(a, pr);\n    for (const auto& y : v) {\n        int c = res % y.size();\n        while (c--) {\n            for (auto&& e : p) {\n                int j = find(begin(y), end(y), e) - begin(y);\n                if (j == (int)y.size()) continue;\n                e = y[(j + 1) % y.size()];\n            }\n        }\n    }\n    if (!is_sorted(begin(p), end(p))) {\n        return cout << -1 << endl, 0;\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n   #include <bits/stdc++.h>\n \n #define int long long\n #define ll long long\n #define pa pair<int,int>\n  #define  mp make_pair\n  #define  pb push_back\n using namespace std;\n\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n\nll modinv(ll r,ll mo){// mod mo での r の逆数 ないときは-1\n\t// r*x +mo*r = 1\n\t\n\tll aa,bb;\n\tll gc=extgcd(r,mo,aa,bb);\n\tif(gc!=-1){\n\t//\tcout<<-1<<endl;\n\t}\n\tif(gc!=1) return -1;\n\taa%=mo;\n\tif(aa<0)aa+=mo;\n\t\n\treturn aa;\n}\n\n\nll garner(vector<pair<ll,ll>> vec){\n\t// vec[i]: x % vec[i].first == vec[i].second\n\t// 0<= vec[i].second<vec[i].first\n\t\n\t// vec[i].first はどの2つも互いに素！！！！\n\t// MOD はどうでもいい\n\tvec.pb({0ll,0ll});\n\t\n\tint siz=vec.size();\n\t\n\tvector<ll> ruiseki(siz,1ll);\n\tvector<ll> teisuu(siz,0ll);\n\t\n\tll val;\n\tfor(int i=0;i<siz-1;i++){\n\t\n\t\t// (teisuu[i] + val*ruiseki[i]) % vec[i].first = vec[i].second\n\t\t\n\t\tval= (ll)vec[i].second-teisuu[i];\n\t\twhile(val<0) val+=(ll)vec[i].first;\n\t\tval%=(ll)vec[i].first;\n\t\tval*= modinv(ruiseki[i],(ll)vec[i].first);\n\t\tval%=(ll)vec[i].first;\n\t\n\t\t\n\t\tfor(int j=i+1;j<siz;j++){\n\t\t\tteisuu[j]+=(ll)ruiseki[j]*val;\n\t\t\tif(j<siz-1)teisuu[j]%=(ll)vec[j].first;\n\t//\t\tcout<<teisuu[j]<<endl;\n\t\t\truiseki[j]*=(ll)vec[i].first;\n\t\t\tif(j<siz-1)ruiseki[j]%=(ll)vec[j].first;\n\t\t}\n\t}\n\treturn teisuu.back();\n\t\n\t\n}\n\n\n\n signed main(){\n \t\n \n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n \tint n;\n \tcin>>n;\n \t \tvector<int> p(n),q(n);\n \tfor(int i=0;i<n;i++){\n \t\tcin>>p[i];\n \t\tp[i]--;\n \t}\n \tfor(int i=0;i<n;i++){\n \t\tcin>>q[i];\n \t\tq[i]--;\n \t}\n \tvector<pa> ve;\n \tfor(int i=0;i<n;i++){\n \t\t\n \t\tint v=p[i];\n \t\tint cnt=0;\n \t\tint mo=-1;\n \t\twhile(1){\n \t\t\t\n \t\t\tif(v==i){\n \t\t\t\tmo=cnt;\n \t\t\t}\n \t\t\t\n \t\t\tcnt++;\n \t\t\tv=q[v];\n \t\t\tif(v==p[i]){\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif(mo==-1){\n \t\t\tcout<<-1<<endl;\n \t\t\treturn 0;\n \t\t}\n \t\t\n \t\tif(cnt>1)ve.pb(mp(cnt,mo));\n \t//\tcout<<cnt<<\" \"<<mo<<endl;\n \t}\n \tif(ve.size()==0){\n \t\tcout<<0<<endl;\n \t\treturn 0;\n \t}\n \tsort(ve.begin(),ve.end());\n \tint m=ve.size();\n \tvector<pa> ve2;\n \tve2.pb(ve[0]);\n \tfor(int i=1;i<m;i++){\n \t\tif(ve[i].first==ve[i-1].first){\n \t\tif(ve[i].second!=ve[i-1].second){\n \t\t\tcout<<-1<<endl;\n \t\t\treturn 0;\n \t\t}\n \t\t}\n \t\telse ve2.pb(ve[i]);\n \t}\n \tswap(ve,ve2);\n\t\n \tint ma=1;\n \t m=ve.size();\n \tfor(auto v:ve){\n \t//\tcout<<v.first<<\" \"<<v.second<<endl;\n \t\t ma=v.first/__gcd(v.first,ma)*ma;\n \t}\n \t\n \tvector<pa> qu;\n \tfor(int i=2;i<=n;i++){\n \t\n \t\tbool bo=1;\n \t\tfor(int j=2;j<i;j++){\n \t\t\tif(i%j==0){\n \t\t\t\tbo=0;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif(!bo) continue;\n \t\t\n \t\t// i is prime\n \t\tint ind=-1,cnt=-1; \n \t\tfor(int j=0;j<m;j++){\n \t\t\tint f=1;\n \t\t\tint ee=ve[j].first;\n \t\t\twhile(ee%i==0){\n \t\t\t\tf*=i;\n \t\t\t\tee/=i;\n \t\t\t}\n \t\t\tif(cnt<f&&f>1){\n \t\t\t\n \t\t\t\tcnt=f;\n \t\t\t\tind=j;\n \t\t\t}\n \t\t\t\n \t\t}\n \t\tif(cnt>1){\n \t\t\tqu.pb(mp(cnt,ve[ind].second%cnt));\n \t\t}\n \t}\n \t\n \tint ans=garner(qu);\n// \tcout<<ans<<endl;\n \tfor(auto v:ve){\n \t\tif(ans%v.first!=v.second){\n \t\t\tcout<<-1<<endl;\n \t\t\treturn 0;\n \t\t}\n \t}\n \tcout<<ans<<endl;\n \t\nreturn 0;\n\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace ChineseRemainderTheorem {\n\ttemplate<typename T>\n\tinline T modulo(T x, const T MOD) {\n\t\tif(0 <= x and x < MOD) return x;\n\t\tx %= MOD;\n\t\tif(x < 0) x += MOD;\n\t\treturn x;\n\t}\n\t// gcd(a, b)\n\t// ap + bq = gcd(a, b)を満たす(p, q)\n\ttemplate<typename T>\n\tT exGCD(T a, T b, T &p, T &q) {\n\t\tif(b == 0) {\n\t\t\t// gcd(a, b)p + 0q = gcd(a, b)\n\t\t\tp = 1, q = 0;\n\t\t\treturn a;\n\t\t}\n\t\tT ret = exGCD(b, a % b, q, p);\n\t\tq -= a / b * p;\n\t\treturn ret;\n\t}\n\t// gcd(a, b)\n\ttemplate<typename T>\n\tT exGCD(T a, T b) {\n\t\tT _p, _q;\n\t\treturn exGCD(a, b, _p, _q);\n\t}\n\t// Garnerの前処理（互いに素にする）\n\t// lcm(mod) % MOD\n\ttemplate<typename T>\n\tT normalisation(vector<T> &b, vector<T> &mod, const T MOD = numeric_limits<T>::max()) {\n\t\tfor(int i = 0; i < (int)b.size(); ++i) {\n\t\t\tfor(int j = 0; j < i; ++j) {\n\t\t\t\tT g = exGCD(mod[i], mod[j]);\n\t\t\t\t// 必要十分性の確認\n\t\t\t\tif ((b[i] - b[j]) % g != 0) throw \"NOT FOUND\";\n\t\t\t\tmod[i] /= g;\n\t\t\t\tmod[j] /= g;\n\t\t\t\tT gi = exGCD(mod[i], g);\n\t\t\t\tT gj = g / gi;\n\t\t\t\t// 共通する場合，iの方が指数大\n\t\t\t\twhile(true) {\n\t\t\t\t\tT gg = exGCD(gi, gj);\n\t\t\t\t\tif(gg == 1) break;\n\t\t\t\t\tgi *= gg, gj /= gg;\n\t\t\t\t}\n\t\t\t\tmod[i] *= gi;\n\t\t\t\tmod[j] *= gj;\n\t\t\t\tb[i] = modulo(b[i], mod[i]);\n\t\t\t\tb[j] = modulo(b[j], mod[j]);\n\t\t\t}\n\t\t}\n\t\tT ret = 1;\n\t\tfor(int i = 0; i < (int)b.size(); ++i) {\n\t\t\tret *= mod[i];\n\t\t\tret = modulo(ret, MOD);\n\t\t}\n\t\treturn ret;\n\t}\n\t// x ≡ b(mod m)を満たすx(mod M (= lcm m))\n\ttemplate<typename T>\n\tT CRT(vector<T> &b, vector<T> &mod) {\n\t\t// x ≡ 0(mod 1)は全ての整数\n\t\tT x = 0, MOD = 1;\n\t\tfor(int i = 0; i < (int)b.size(); ++i) {\n\t\t\tT p, _q;\n\t\t\tT d = exGCD(MOD, mod[i], p, _q);\n\t\t\t// 必要十分性の確認\n\t\t\tif((x - b[i]) % d != 0) throw \"NOT FOUND\";\n\t\t\t// nextMOD = MOD * (mod[i] / d)なので部分的にmodが取れてオーバーフロー回避\n\t\t\tx = x - modulo((x - b[i]) / d * p, (mod[i] / d)) * MOD;\n\t\t\t// lcm(M, m) = M * m / gcd(M, m)\n\t\t\tMOD = MOD * (mod[i] / d);\n\t\t\tx = modulo(x, MOD);\n\t\t}\n\t\treturn modulo(x, MOD);\n\t}\n\ttemplate<typename T>\n\tT Garner(vector<T> &b, vector<T> &mod, T MOD = numeric_limits<T>::max()) {\n\t\ttry {\n\t\t\tnormalisation(b, mod, MOD);\n\t\t}\n\t\tcatch(...) {\n\t\t\tthrow \"NOT FOUND\";\n\t\t}\n\t\tvector<T> p(b.size());\n\t\tfor(int i = 0; i < (int)b.size(); ++i) {\n\t\t\tp[i] = b[i] % mod[i];\n\t\t\tfor(int j = 0; j < i; ++j) {\n\t\t\t\tT inv, _tmp;\n\t\t\t\texGCD(mod[j], mod[i], inv, _tmp);\n\t\t\t\tinv = modulo(inv, mod[i]);\n\t\t\t\tp[i] = (p[i] - p[j]) * inv;\n\t\t\t\tp[i] = modulo(p[i], mod[i]);\n\t\t\t}\n\t\t}\n\t\t// 復元\n\t\tT ret = 0;\n\t\tfor(int i = 0; i < (int)b.size(); ++i) {\n\t\t\tT tmp = modulo(p[i], MOD);\n\t\t\tfor(int j = 0; j < i; ++j) {\n\t\t\t\ttmp *= mod[j];\n\t\t\t\ttmp = modulo(tmp, MOD);\n\t\t\t}\n\t\t\tret += tmp;\n\t\t\tret = modulo(ret, MOD);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tusing namespace ChineseRemainderTheorem;\n\tint n; cin >> n;\n\tvector<int64_t> p(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> p[i];\n\t}\n\tvector<int64_t> q(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> q[i];\n\t}\n\tvector<int64_t> b(n);\n\tvector<int64_t> mod(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tbool used[n] = {};\n\t\twhile(p[i] != i + 1) {\n\t\t\tif(used[p[i] - 1]) {\n\t\t\t\tcout << -1 << '\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tused[p[i] - 1] = true;\n\t\t\tp[i] = q[p[i] - 1];\n\t\t\t++b[i];\n\t\t}\n\t\tp[i] = q[p[i] - 1];\n\t\tmod[i] = 1;\n\t\twhile(p[i] != i + 1) {\n\t\t\tp[i] = q[p[i] - 1];\n\t\t\t++mod[i];\n\t\t}\n\t}\n\ttry {\n\t\tcout << Garner(b, mod) << '\\n';\n\t}\n\tcatch(...) {\n\t\tcout << -1 << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define EQ(a,b) (abs(a - b) < 1e-10)\nusing namespace std;\ntypedef long long LL;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\n// LONG_MAX,LLONG_MAX\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class Key,class Value> ostream& operator << (ostream &s, map<Key,Value> M)\n{ for ( auto itr = begin(M); itr != end(M); ++itr) { s << itr->first << \":\" << itr->second; } return s;}\n\ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n\n// 拡張 Euclid の互除法\nlong long extGCD(long long a, long long b, long long &p, long long &q) {\n    if (b == 0) { p = 1; q = 0; return a; }\n    long long d = extGCD(b, a%b, q, p);\n    q -= a/b * p;\n    return d;\n}\n\n// 答えを x ≡ r (mod. M) として、{r, M} をリターン, 存在しない場合は {0, -1} をリターン\npair<long long, long long> ChineseRem(const vector<long long> &b, const vector<long long> &m) {\n    long long r = 0, M = 1;\n    for (int i = 0; i < (int)b.size(); ++i) {\n        long long p, q;\n        long long d = extGCD(M, m[i], p, q); // p is inv of M/d (mod. m[i]/d)\n        if ((b[i] - r) % d != 0) return make_pair(0, -1);\n        long long tmp = (b[i] - r) / d * p % (m[i]/d);\n        r += M * tmp;\n        M *= m[i]/d;\n    }\n    return make_pair(mod(r, M), M);\n}\n\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<int> P(N);\n    vector<int> Q(N);\n    REP(i, N) {\n        cin >> P[i];\n        P[i]--;\n    }\n    REP(i, N) {\n        cin >> Q[i];\n        Q[i]--;\n    }\n\n    vector<int> group(N, -1);\n    int g = 0;\n    REP(i, N) {\n        if (group[i] != (-1)) {\n            continue;\n        }\n        int idx = i;\n        while (true) {\n            if (group[idx] != (-1)) break;\n            group[idx] = g;\n            idx = Q[idx];\n        }\n        g++;\n    }\n    vector<vector<int>> T(g);\n    REP(i, N) {\n        if (group[P[i]] != group[i]) {\n            cout << -1 << endl;\n            exit(0);\n        }\n        T[group[P[i]]].push_back(P[i]);\n    }\n\n    // 何ループ目かを求める.\n    vector<long long> roop(g, 0LL);\n    vector<long long> m(g, 0LL);\n    REP(i, g) {\n        vector<int> cur = T[i];\n        m[i] = cur.size();\n        int cnt = 0;\n        while (true) {\n            bool ok = true;\n            REP(j, cur.size()-1) {\n                if (cur[j+1] <= cur[j]) ok = false;\n            }\n            if (ok) {\n                roop[i] = cnt;\n                break;\n            }\n            bool turn = true;;\n            REP(j, cur.size()) {\n                cur[j] = Q[cur[j]];\n                if (cur[j] != T[i][j]) {\n                    turn = false;\n                }\n            }\n            cnt++;\n            if (turn) {\n                cout << -1 << endl;\n                exit(0);\n            }\n        }\n    }\n    pair<long long, long long> res = ChineseRem(roop, m);\n    if (res.second == -1) cout << -1 << endl;\n    else cout << res.first << endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing lint = long long;\n\nlint gcd(lint x, lint y){\n    while(y){\n        lint r = x % y;\n        x = y;\n        y = r;\n    }\n    return x;\n}\n\nlint extgcd(lint a, lint b, lint& x, lint& y){\n    lint d = a;\n    if(b){\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\nlint mod_inverse(lint a, lint m){\n    lint x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\npair<lint, lint> linear_congruence(const vector<lint>& A, const vector<lint>& B, const vector<lint>& M){\n    lint x = 0, m = 1;\n    for(int i = 0 ; i < A.size() ; ++i){\n        lint a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n        if(b % d != 0LL){\n            return make_pair(-1LL, -1LL);\n        }\n        lint t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n        x = x + m * t;\n        m *= M[i] / d;\n    }\n    return make_pair(x % m, m);\n}\n\nlint solve(int n){\n    vector<int> p(n);\n    for(int i = 0 ; i < n ; ++i){\n        cin >> p[i];\n        --p[i];\n    }\n    vector<int> q(n);\n    for(int i = 0 ; i < n ; ++i){\n        cin >> q[i];\n        --q[i];\n    }\n\n    vector<lint> A, B, M;\n\n    vector<bool> done(n, false);\n    for(int i = 0 ; i < n ; ++i){\n        if(done[i]){\n            continue;\n        }\n        int now = i;\n        vector<int> vp, vq;\n        while(!done[now]){\n            done[now] = true;\n            vp.emplace_back(p[now]);\n            vq.emplace_back(now);\n            now = q[now];\n        }\n\n        vector<int> loop = vq;\n\n        sort(vp.begin(), vp.end());\n        sort(vq.begin(), vq.end());\n        if(vp != vq){\n            return -1LL;\n        }\n\n        int m = (int)loop.size();\n        vector<int> ptmp = p;\n        for(int j = 0 ; j <= m ; ++j){\n            vector< pair<int, int> > v;\n            for(int k = 0 ; k < m ; ++k){\n                v.emplace_back(loop[k], ptmp[loop[k]]);\n            }\n            sort(v.begin(), v.end());\n            bool flag = true;\n            for(int k = 0 ; k < m - 1 ; ++k){\n                if(v[k].second > v[k + 1].second){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                A.push_back(1);\n                B.push_back(j);\n                M.push_back(m);\n                break;\n            }else if(j == m){\n                return -1LL;\n            }\n            for(int k = 0 ; k < m ; ++k){\n                int num = ptmp[loop[k]];\n                ptmp[loop[k]] = q[num];\n            }\n        }\n    }\n\n    pair<lint, lint> ans = linear_congruence(A, B, M);\n\n    if(ans.second == -1LL){\n        return -1LL;\n    }\n\n    return ((ans.first % ans.second) + ans.second) % ans.second;\n}\n\nint main(){\n    int n;\n    while(cin >> n){\n        lint ans = solve(n);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<ll, ll> P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define all(x) (x).begin(),(x).end()\n#define stop char nyaa; cin>>nyaa;\nll gcd(ll x, ll y) {\n\treturn y ? gcd(y, x%y) : x;\n}\nll lcm(ll x, ll y) {\n\tll g = gcd(x, y);\n\tif ((double)x / g * y > 2e18)return -1;\n\treturn x / g * y;\n}\n\npair<ll, ll> marge(pair<ll, ll> x, pair<ll, ll> y) {\n\tll l = lcm(x.first, y.first);\n\tif (l == -1)return { -1,-1 };\n\trep(i, x.first) {\n\t\tif ((y.first*i + y.second) % x.first == x.second%x.first) {\n\t\t\treturn { l,y.first*i + y.second };\n\t\t}\n\t}\n\treturn { -1,-1 };\n\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> p(n), q(n);\n\trep(i, n)cin >> p[i];\n\trep(i, n)--p[i];\n\trep(i, n)cin >> q[i];\n\trep(i, n)--q[i];\n\tvector<vector<int>> ans(n);\n\trep(c, 3 * n) {\n\t\tvector<int> np(n);\n\t\trep(i, n)np[i] = q[p[i]];\n\t\trep(i, n)if (np[i] == i)ans[i].push_back(c+1);\n\t\tnp.swap(p);\n\t}\n\tpair<ll, ll> res = { 1,0 };\n\trep(i, n) {\n\t\tif (ans[i].size() < 2) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn ;\n\t\t}\n\t\tres = marge({ ans[i][1] - ans[i][0],ans[i][0] }, res);\n\t\tif (res.first == -1) {\n\n\t\t\tcout << -1 << endl;\n\t\t\treturn ;\n\t\t}\n\t}\n\tif (res.second > 1e18) {\n\t\tcout << -1 << endl;\n\t}\n\telse cout << res.second%res.first << endl;\n\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//find_prime();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing Int = long long int;\nusing std::vector;\n\nInt gcd(Int a, Int b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\nvoid fail() {\n    std::cout << -1 << std::endl;\n    std::exit(0);\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    vector<int> p(n), q(n);\n    for (auto& x : p) {\n        std::cin >> x;\n        --x;\n    }\n    for (auto& x : q) {\n        std::cin >> x;\n        --x;\n    }\n\n    Int a = 1, b = 0;\n    // d = ax + b で揃う\n    for (int i = 0; i < n; ++i) {\n        int v = p[i];\n        Int aa = -1, bb = -1;\n        for (int t = 1; t <= n; ++t) {\n            v = q[v];\n            if (v == i) {\n                bb = t;\n            }\n            if (v == p[i]) {\n                aa = t;\n                break;\n            }\n        }\n        if (bb < 0) fail();\n        bb %= aa;\n\n        // d = ax + b = aay + bb\n        // 0 <= x < aa で十分\n        Int x;\n        for (x = 0; x < aa; ++x) {\n            if ((a * x + b) % aa == bb) break;\n        }\n        if (x == aa) fail();\n\n        b += a * x;\n        a = a / gcd(a, aa) * aa;\n        b %= a;\n    }\n\n    std::cout << b << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\n\nconst ll N=210;\nll n,ans,a[N],b[N],c[N],mod[N];\n\ninline ll read(){\n    ll x=0,tmp=1;\n    char ch=getchar();\n    while(!isdigit(ch)){\n        if(ch=='-') tmp=-1;\n        ch=getchar();\n    }\n    while(isdigit(ch)){\n        x=(x<<3)+(x<<1)+(ch^48);\n        ch=getchar();\n    }\n    return tmp*x;\n}\n\ninline ll ksm(ll x,ll y,ll mod){\n    ll ans=0;\n    while(y){\n        if(y&1) ans=(ans+x)%mod;\n        x=(x+x)%mod;\n        y>>=1;\n    }\n    return ans;\n}\n\nll exgcd(ll a,ll b,ll &x,ll &y){\n    if(!b){\n        x=1; y=0;\n        return a;\n    }\n    ll gcd=exgcd(b,a%b,y,x); y-=a/b*x;\n    return gcd;\n}\n\ninline ll exCRT(){\n    ll M=mod[1],ans=c[1];\n    for(ll i=2; i<=n; i++){\n        ll A=M,B=mod[i],C=(c[i]-ans%B+B)%B,x,y;\n        ll gcd=exgcd(A,B,x,y),bg=B/gcd;\n        if(C%gcd) return -1;\n        x=ksm(x,C/gcd,bg);\n        ans+=x*M;\n        M*=bg;\n        ans=(ans%M+M)%M;\n    }\n    return (ans%M+M)%M;\n}\n\ninline bool check(){\n    for(ll i=1; i<=n; i++){\n        if(a[i]!=i) return 0;\n    }\n    return 1;\n}\n\nint main(){\n    n=read();\n    for(ll i=1; i<=n; i++) a[i]=read();\n    for(ll i=1; i<=n; i++) b[i]=read();\n    if(check()) return printf(\"0\\n\")&0;    \n    for(ll i=1; i<=n; i++){\n        while(c[i]<=n&&a[i]!=i){\n            a[i]=b[a[i]];\n            c[i]++;\n        }\n        if(c[i]>n) return printf(\"-1\\n\")&0;\n        do{\n            a[i]=b[a[i]];\n            mod[i]++;\n        }while(a[i]!=i);\n    }\n    cout<<exCRT()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\n/* aとbの最大公約数を求める. */\nll gcd(ll a, ll b) {\n\tif (b > a) return gcd(b, a);\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\n/* ax+by=gcd(a,b)を満たす(x,y)を格納し、gcd(a,b)を返す. */\nll extgcd(ll a, ll b, ll& x, ll& y) {\n\tif (b > a) return extgcd(b, a, y, x);\n\tif (b == 0) {\n\t\tx = 1; y = 0;\n\t\treturn a;\n\t}\n\tll g = extgcd(b, a % b, y, x);\n\ty -= (a / b) * x;\n\treturn g;\n}\n\n/* mod mでのaの逆元を求める.(gcd(a,m) = 1) */\nll modinv(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\n/* 連立線形方程式を解く.\n\t\tA[i] * x ≡ B[i] (mod M[i])\n\tなる方程式の解が\n\t\tx ≡ b (mod m)\n\tとかけるとき、(b, m)を返す.(存在しなければ(0, -1)) */\npair<ll, ll> liner_congruence(\n\tvector<ll> A, vector<ll> B, vector<ll> M\n) {\n\tll x = 0, m = 1;\n\n\tfor (int i = 0; i < A.size(); ++i) {\n\t\tll a = A[i] * m,\n\t\t\tb = B[i] - A[i] * x,\n\t\t\td = gcd(M[i], a);\n\n\t\tif (b % d != 0) // 解なし\n\t\t\treturn make_pair(0, -1);\n\n\t\tll t = b / d * modinv(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\n\treturn make_pair(x % m, m);\n}\n\nsigned main() {\n\tint n; cin >> n;\n\tvector<int> p(n), q(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> p[i];\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> q[i];\n\n\t// dp[i][j] := 数字iがj日後に何に書き換わるか\n\tint dp[201][201];\n\tfor (int i = 1; i <= n; ++i) // 初期化\n\t\tdp[i][0] = i;\n\tfor (int j = 1; j <= 200; ++j)\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tdp[i][j] = q[dp[i][j - 1] - 1];\n\n\t// i番目の数字について、\n\t// ・B[i-1]日後に初めてiになり、\n\t// ・M[i-1]日周期で数字が繰り返す\n\t// を求める.(i=1,2,...,n)\n\tvector<ll> B(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tB[i - 1] = -1;\n\t\tint pi = p[i - 1]; // 0日目の数字\n\t\tfor (int j = 0; j <= 200; ++j) {\n\t\t\tif (dp[pi][j] == i) {\n\t\t\t\tB[i - 1] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (B[i - 1] == -1) { // iになることがなければ-1\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvector<ll> M(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tM[i - 1] = -1;\n\t\tint pi = p[i - 1]; // 0日目の数字\n\t\tfor (int j = 1; j <= 200; ++j) {\n\t\t\tif (dp[pi][j] == pi) {\n\t\t\t\tM[i - 1] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<ll> A(n, 1);\n\tauto ans = (liner_congruence(A, B, M));\n\tif (ans.second == -1) {\n\t\tcout << -1 << endl;\n\t}\n\telse if (ans.first >= 0) {\n\t\tcout << ans.first << endl;\n\t}\n\telse {\n\t\tcout << (ans.first + ans.second) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\n\nint p[205],q[205];\nint n;\nstruct s{\n    int par[205];\n    void init(){ rep(i,205) par[i] = i;}\n    int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]);}\n    void unite(int x,int y){\n        x = find(x); y = find(y);\n        if(x == y) return;\n        par[x] = y;\n    }\n    bool same(int x,int y){ return find(x) == find(y); }\n}kaede;\nvector<int>id[205];\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\n\nll garner(vector<P> mr, ll mod){\n    mr.emplace_back(mod, 0);\n\n    vector<ll> coffs(sz(mr), 1);\n    vector<ll> constants(sz(mr), 0);\n    FOR(i, sz(mr) - 1){\n        // coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n        ll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n        if (v < 0) v += mr[i].first;\n\n        for (int j = i + 1; j < sz(mr); j++) {\n            (constants[j] += coffs[j] * v) %= mr[j].first;\n            (coffs[j] *= mr[i].first) %= mr[j].first;\n        }\n    }\n\n    return constants[sz(mr) - 1];\n}\nll gcd(ll a, ll b){\n    if(a<b)swap(a,b);\n    if(b==0) return a;\n    else return gcd(b,a%b);\n}\nll preGarner(vector <ll> &b, vector <ll> &m, ll MOD) {\n    for (int i = 0; i < b.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            ll g = gcd(m[i], m[j]);\n            if ((b[i] - b[j]) % g != 0) return -1;\n\n            m[i] /= g, m[j] /= g;\n            ll gi = gcd(m[i], g), gj = g / gi;\n            do {\n                g = gcd(gi, gj);\n                gi *= g, gj /= g;\n            } while (g != 1);\n            m[i] *= gi, m[j] *= gj;\n            b[i] %= m[i], b[j] %= m[j];\n        }\n    }\n\n    ll res = 1;\n    for (int i = 0; i < b.size(); i++) (res *= m[i]) %= MOD;\n    return res;\n}\n\nint las[205];\nvector<int>pos[205];\nsigned main(){\n    cin >> n;\n    repn(i,n) cin >> p[i];\n    kaede.init();\n    repn(i,n) {cin >> q[i];kaede.unite(i,q[i]);}\n\n    repn(i,n){\n        id[kaede.find(p[i])].pb(p[i]);\n        pos[kaede.find(p[i])].pb(i);\n    }\n    vector<pair<int,int>>vec;\n    repn(i,n){\n        if(id[i].empty()) continue;\n        rep(j,205){\n            rep(x,id[i].size()) if(x && id[i][x-1] > id[i][x]) goto fail;\n            vec.pb(mp(id[i].size(),j)); goto nxt; fail:;\n            rep(x,id[i].size()) id[i][x] = q[id[i][x]];\n        }\n        puts(\"-1\"); return 0; nxt:;\n        rep(s,pos[i].size()) las[pos[i][s]] = id[i][s];\n    }\n    repn(i,n) assert(las[i]);\n    repn(i,n) if(las[i] != i) {  puts(\"-1\"); return 0;  }\n    vector<ll>v1,v2; rep(i,vec.size()) { v1.pb(vec[i].fi); v2.pb(vec[i].sc); }\n    ll l = preGarner(v2,v1,2000000000000000009LL);\n    if(l == -1) { puts(\"-1\"); return 0;}\n    rep(i,vec.size()) { vec[i].fi = v1[i]; vec[i].sc = v2[i]; }\n    ll x =  garner(vec,2000000000000000009LL);\n    cout << x << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst int INF=1e9;\nconst long long LINF=1e18;\n#define int long long\n//template\ntemplate <typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n//main\nsigned main(){\n  int N;cin>>N;\n  std::vector<int> p(N),q(N);\n  for(int i=0;i<N;i++)cin>>p[i];\n  for(int i=0;i<N;i++)cin>>q[i];\n  for(int i=0;i<N;i++)p[i]--,q[i]--;\n  typedef pair<int,int> P;\n  set<P> s;\n  for(int i=0;i<N;i++){\n    int cnt=0,one=-1,roop=0,now=p[i];\n    while(!roop){\n      if(now==i)one=cnt;\n      now=q[now];cnt++;\n      if(now==p[i])roop=cnt;\n    }\n    if(one<0)fin(-1);\n    s.insert(P(one,roop));\n  }\n  int pre=-1;\n  for(auto p:s){\n    int roop=p.second;\n    if(roop==pre)fin(-1);\n    pre=roop;\n  }\n  int ans=-1,b=1;\n  for(auto p:s){\n    int one=p.first,roop=p.second;\n    if(ans<0)ans=one;\n    else{\n      if((abs(ans-one)%__gcd(b,roop)))fin(-1);\n      while((ans%roop)!=one)ans+=b;\n    }\n    b=(b*roop)/__gcd(b,roop);\n  }\n  fin(ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\nll gcd(ll a,ll b){\n    return b==0?a:gcd(b,a%b);\n}\n\nll extgcd(ll a,ll b,ll &x,ll &y){\n  ll d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;\n    y=0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a,ll m){\n  ll x,y;\n  ll z=extgcd(a,m,x,y);\n  return(m+x%m)%m;\n}\n\npair<ll,ll> linear_congruence(const vector<ll> &A,const vector<ll> &B,\n                              const vector<ll> &M){\n  ll x=0,m=1;\n\n  for(int i=0;i<A.size();i++){\n      ll a=A[i]*m,b=B[i]-A[i]*x,d=gcd(M[i],a);\n      if(b%d!=0) return make_pair(-1,-1);\n\n      ll t=(b/d)*mod_inverse(a/d,M[i]/d)%(M[i]/d);\n      x=x+m*t;\n      m*=M[i]/d;\n\n      x=(x%m+m)%m;\n  }\n  return make_pair(x,m);\n}\n\npair<ll, ll> crt(ll b1, ll m1, ll b2, ll m2){\n    ll p, q;\n    ll d = extgcd(m1, m2, p, q);\n    if((b2-b1) % d != 0) return make_pair(-1, -1);\n    ll m = m1 * (m2/d);\n    ll tmp = (b2 - b1) / d * p % (m2/d);\n    ll r = b1 + m1 * tmp;\n    r = (r%m+m) % m;\n    return make_pair(r, m);\n}\n\n\nint main(){\n  int N;\n  cin>>N;\n  vector<int> P(N),Q(N);\n  rep(i,N) cin>>P[i];\n  rep(i,N) cin>>Q[i];\n\n  rep(i,N){\n    P[i]--;\n    Q[i]--;\n  }\n\n  vector<vector<int>> app(N);\n  vector<int> nowp=P;\n  rep(k,2*N+2){\n    vector<int> nexp(N);\n    for(int i=0;i<N;i++){\n      if(nowp[i]==i) app[i].push_back(k);\n      nexp[i]=Q[nowp[i]];\n    }\n    nowp.swap(nexp);\n  }\n\n  pair<ll,ll> ans={0,1};\n  for(int i=0;i<N;i++){\n    if(app[i].size()<2){\n      cout<<-1<<endl;\n      return 0;\n    }\n\n    ans=crt(ans.first,ans.second,app[i][0],app[i][1]-app[i][0]);\n    if(ans.first==-1){\n        cout<<-1<<endl;\n        return 0;\n    }\n  }\n\n  cout<<ans.first<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream&os, const pair<t,u>&p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream&operator <<(ostream&os,const vc<t>&v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nconst int inf=LLONG_MAX/4;\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tvi p(n);rep(i,n){cin>>p[i];p[i]--;}\n\tvi q(n);rep(i,n){cin>>q[i];q[i]--;}\n\t\n\tint a=0,b=1;\n\t\n\tvi dp(n,0);\n\trep(i,n){\n\t\tint s=0;\n\t\tint x=p[i];\n\t\tdo{x=q[x];s++;}while(x!=p[i]);\n\t\tint y=0;\n\t\twhile(y<s&&x!=i){\n\t\t\tx=q[x];\n\t\t\ty++;\n\t\t}\n\t\tif(y==s){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tx=p[i];\n\t\tint cnt=0;\n\t\twhile(cnt<s&&a<inf&&a%s!=y){a+=b;cnt++;}\n\t\tif(cnt==s){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tcnt=0;\n\t\tint c=b;\n\t\twhile(cnt<s&&c<inf&&c%s){c+=b;cnt++;}\n\t\tif(cnt==s){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tb=c;\n\t}\n\tif(a>=inf)cout<<-1<<endl;\n\telse cout<<a<<endl;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nP=[int(x)-1 for x in input().split()]\nQ=[int(x)-1 for x in input().split()]\nap=[[-1 for i in range(N)]for j in range(N)]\nb=[0]*N\nfor i in range(N+1):\n    for j in range(N):\n        if ap[j][P[j]]>=0:\n            if b[j]==0:b[j]=i-ap[j][P[j]]\n        else:\n            ap[j][P[j]]=i\n        P[j]=Q[P[j]]\na=[ap[i][i] for i in range(N)]\nflag=True\nif sum(A<0 for A in a)>0:\n    flag=False\nA=0\nB=1\ndef extgcd(a,b):\n    if b==0:\n        return (a,1,0)\n    q=a//b\n    g,x,y=extgcd(b,a-q*b)\n    z=x-q*y\n    return (g,y,z)\ndef f(A,B,a,b):\n    g,x,y=extgcd(B,b)\n    if (a-A)%g!=0:\n        return (0,0)\n    x*=(a-A)//g\n    A+=B*x\n    B=B//g*b\n    A%=B\n    if A<0:A+=B\n    return (A,B)\nfor i in range(N):\n    if flag:\n        A,B=f(A,B,a[i],b[i])\n        if B==0:flag=False\nprint(A if flag else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import reduce\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\nfor i in range(N):\n    P[i] -= 1\n    Q[i] -= 1\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a%b)\n\n# return [g, x, y]\n# g = gcd(a, b)\n# x, y satisfies a x + b y = g\ndef extgcd(a, b):\n    if b == 0:\n        return [a, 1, 0]\n    g, x, y = extgcd(b, a%b)\n    return [g, y, x - a//b * y]\n\n# eq0: x = a0 (mod m0)\n# eq1: x = a1 (mod m1)\n# returns [xt, mod] such that x = xt + k mod for integer k.\ndef crt(eq0, eq1):\n    a0, m0 = eq0\n    a1, m1 = eq1\n\n    g = gcd(m0, m1)\n\n    if a0 % g != a1 % g:\n        print(-1)\n        exit(0)\n\n    if g > 1:\n        m0 //= g\n        m1 //= g\n\n        while True:\n            gt = gcd(m0, g)\n            if gt == 1:\n                break\n            m0 *= gt\n            g //= gt\n        \n        m1 *= g\n\n        a0 %= m0\n        a1 %= m1\n\n    g, p, q = extgcd(m0, m1)\n    \n    x = a0 * q * m1 + a1 * p * m0\n    mod = m0 * m1\n    x = x % mod\n\n    return [x, mod]\n\neqs = []\nfor i in range(N):\n    a = []\n    for j in range(3 * N):\n        if len(a) == 2:\n            break\n        if P[i] == i:\n            a.append(j)\n        P[i] = Q[P[i]]\n    if len(a) != 2:\n        print(-1)\n        exit(0)\n    eqs.append([a[0], a[1] - a[0]])\n\nx, mod = reduce(crt, eqs, (0, 1))\nprint(x % mod)\n"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    if b>a:\n        return gcd(b,a)\n    if b == 0:\n        return a\n    return gcd(b,a%b)\n\n\ndef extgcd(a,b):\n    r = [1,0,a]\n    w = [0,1,b]\n    while w[2] != 1:\n        q = r[2]//w[2]\n        r2 = w\n        w2 = [r[0]-q*w[0],r[1]-q*w[1],r[2]-q*w[2]]\n        r = r2\n        w = w2\n    return w[0],w[1]\n\n\nn = int(input())\np = list(map(int,input().split()))\nq = list(map(int,input().split()))\n\ndp = [[0]*401 for _ in range(201)]\nfor i in range(1,n+1):\n    dp[i][0] = i\n    dp[i][1] = q[i-1]\n\nfor j in range(2,401):\n    for i in range(1,n+1):\n        dp[i][j] = dp[dp[i][j-1]][1]\n\nab = [[0,0] for _ in range(n)]\nfor i in range(n):\n    pi = p[i]\n    bi = -1\n    for b in range(401):\n        if dp[pi][b] == i+1:\n            bi = b\n            break\n    if bi == -1:\n        print(-1)\n        exit()\n    \n    ai = -1\n    for a in range(1,401):\n        if dp[pi][a] == pi:\n            ai = a\n            break\n    ab[i] = [ai,bi]\n\ntmp_a = ab[0][0]\ntmp_b = ab[0][1]\nfor i in range(1,n):\n    A = tmp_a\n    B = ab[i][0]\n    C = ab[i][1]-tmp_b\n\n    G= gcd(A,B)\n    if C%G != 0:\n        print(-1)\n        exit()\n    K1,K2 = extgcd(A//G,B//G)\n    tmp_a = G*(A//G)*(B//G)\n    K1 *= C//G\n    tmp_b = A * K1 + tmp_b\n    tmp_b = (tmp_b % tmp_a + tmp_a) % tmp_a\nprint(tmp_b)\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n\n    let n: usize = sc.read();\n    let mut p = vec![0; n];\n    let mut q = vec![0; n];\n    for i in 0..n {\n        p[i] = sc.read::<usize>() - 1;\n    }\n    for i in 0..n {\n        q[i] = sc.read::<usize>() - 1;\n    }\n\n    let mut count = vec![0; n];\n    for i in 0..n {\n        let mut cur = p[i];\n        while cur != i {\n            cur = q[cur];\n            count[i] += 1;\n            if cur == p[i] {\n                println!(\"-1\");\n                return;\n            }\n        }\n    }\n\n    let mut cycle = vec![0; n];\n    for i in 0..n {\n        let mut cur = i;\n        loop {\n            cur = q[cur];\n            cycle[i] += 1;\n            if cur == i {\n                break;\n            }\n        }\n    }\n\n    let a = chinese_remainder_theorem(&count, &cycle);\n    match a {\n        Some((a, _)) => {\n            println!(\"{}\", a);\n        }\n        None => {\n            println!(\"-1\");\n        }\n    }\n}\npub fn extended_gcd(a: i64, b: i64, p: &mut i64, q: &mut i64) -> i64 {\n    if b == 0 {\n        *p = 1;\n        *q = 0;\n        a\n    } else {\n        let d = extended_gcd(b, a % b, q, p);\n        *q -= a / b * *p;\n        d\n    }\n}\n\npub fn chinese_remainder_theorem(b: &Vec<i64>, modulo: &Vec<i64>) -> Option<(i64, i64)> {\n    let (mut r, mut m) = (0, 1);\n    for i in 0..b.len() {\n        let (mut p, mut q) = (0, 0);\n        let d = extended_gcd(m, modulo[i], &mut p, &mut q);\n        if (b[i] - r) % d != 0 {\n            return None;\n        }\n        let tmp = ((b[i] - r) / d * p) % (modulo[i] / d);\n        r += m * tmp;\n        m *= modulo[i] / d;\n    }\n    Some(((r % m + m) % m, m))\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: std::ops::Deref<Target = str>>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\n"
  }
]