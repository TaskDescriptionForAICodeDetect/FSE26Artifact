[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nvector<int> topological(vector<vector<int>>& g) {\n\tvector<int> topo;\n\tint n = g.size();\n\tvector<int> deg(n);\n\tfor (int i = 0; i < n; i++) for (auto next : g[i]) deg[next]++;\n\tqueue<int> q;\n\tfor (int i = 0; i < n; i++) if (deg[i] == 0) q.push(i), topo.push_back(i);\n\twhile (!q.empty()) {\n\t\tint cur = q.front();\n\t\tq.pop();\n\t\tfor (auto next : g[cur]) {\n\t\t\tdeg[next]--;\n\t\t\tif (deg[next] == 0) {\n\t\t\t\tq.emplace(next);\n\t\t\t\ttopo.push_back(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn topo;\n}\n\nvoid solve() {\n\tint n; cin >> n; if (n == 0) exit(0);\n\tvector<string> vs(n);\n\tfor (int i = 0; i < n; i++) cin >> vs[i];\n\tvector<vector<int>> g(26);\n\tfor (int i = 0; i + 1 < n; i++) {\n\t\tstring& s = vs[i];\n\t\tstring& t = vs[i + 1];\n\t\tbool u = false;\n\t\tfor (int j = 0; j < min(s.size(), t.size()); j++) {\n\t\t\tif (s[j] != t[j]) {\n\t\t\t\tg[s[j] - 'a'].emplace_back(t[j] - 'a');\n\t\t\t\tu = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!u and s.size() > t.size()) {\n\t\t\tcout << \"no\" << \"\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\n\tauto t = topological(g);\n\tif (t.size() == 26) cout << \"yes\" << \"\\n\";\n\telse cout << \"no\" << \"\\n\";\n}\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\n#define maxn 500000\n\nint grap[30][30];\nchar ch1[520][20];\nint c = 1 , n;\nint pre[30];\nint vis[30];\n\nvoid init()\n{\n    memset(grap , 0 , sizeof(grap));\n    memset(vis , 0 , sizeof(vis));\n    memset(pre , 0 , sizeof(pre));\n}\n\n/*bool panduan()\n{\n    int i;\n    int x = strlen(ch1) , y = strlen(ch2);\n    int z = x<y?x:y;\n    int g , h;\n    for(i = 0; i < z; i++)\n        if(ch1[i] != ch2[i])  break;\n\n    if(i == z)\n    {\n        if(x > y)  return false;\n        return true;\n    }\n    g = ch1[i]-'a'+1 , h = ch2[i]-'a'+1;\n    for(i = 1; i <= max_c[h][0] ; i++)\n        if(max_c[h][i] == g)  break;\n    if(i <= max_c[h][0])  return false;\n    for(i = 1; i <= min_c[h][0] ; i++)\n        if(min_c[h][0] == g)  break;\n    if(i > min_c[h][0])\n    {\n        min_c[h][i] = g;\n        min_c[h][i] = i;\n        max_c[g][++max_c[g][0]] = h;\n    }\n\n    return true;\n\n}*/\n\nbool panduan(int p)\n{\n    int i;\n    int x = strlen(ch1[p-1]) , y = strlen(ch1[p]);\n    int z = x<y?x:y;\n    for(i = 0; i < z; i++)\n        if(ch1[p-1][i] != ch1[p][i])  break;\n\n    if(i == z)\n    {\n        if(x > y)  return false;\n        return true;\n    }\n    x = ch1[p-1][i]-'a'+1 , y = ch1[p][i]-'a'+1;\n    vis[x] = vis[y] = 1;\n    grap[x][y] = 1;\n    //cout<<x<<\"  \"<<y<<endl;\n    return true;\n}\n\nbool dfs(int u)\n{\n    if(pre[u])  return false;\n    pre[u] = 1;\n    for(int i = 1; i <= 26; i++)\n    {\n        if(grap[u][i])\n        {\n            if(pre[i])  return false;\n            if(!dfs(i))  return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    while(scanf(\"%d\" , &n) && n)\n    {\n        init();\n        int i;\n        bool bz = true;\n\n        scanf(\"%s\" , ch1[0]);\n        for(i = 1; i < n; i++)\n        {\n            scanf(\"%s\" , ch1[i]);\n            if(!bz)  continue;\n            bz = panduan(i);\n        }\n        if(!bz)\n        {\n            cout<<\"no\"<<endl;\n            continue;\n        }\n\n        for(i = 1; i < 30; i++)\n            if(!pre[i] && vis[i])\n            {\n                memset(pre , 0 , sizeof(pre));\n                bz = dfs(i);\n                if(!bz)  break;\n            }\n        if(bz)  cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n\n#define yn(f) ((f)?\"yes\":\"no\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 510\n\nstring s[MAX];\nbool temp[30][30];\nint ans;\n\nvoid fuga(int a, int b){//cout<<(char)(a+'a')<<\" \"<<(char)(b+'a')<<endl;\n\tif(a==b||!ans) return;\n\ttemp[a][b] = true;\n\tif(temp[a][b]&&temp[b][a]){\n\t\tans = false;\n\t\t//cout<<\"XXXX \"<<(char)(a+'a')<<\" \"<<(char)(b+'a')<<endl;\n\t}\n}\n\nvoid hogehoge(int a, int b){\n\tif(a==b||!ans)return;\n\t\n\tqueue<int> Q;\n\tbool used[30] = {};\n\tQ.push(a);\n\t\n\twhile(!Q.empty()){\n\t\tint t = Q.front();Q.pop();\n\t\tused[t] = true;//cout<<t<<endl;\n\t\tfuga(t,b);\n\t\tfor(int i = 0 ; i < 26; i++){\n\t\t\tif(!used[i]&&temp[i][t]) Q.push(i);\n\t\t}\n\t}\n}\n\nvoid hoge(string a, string b){\n\tif(!ans) return;\n\tint flag = 1;\n\tfor(int i = 0,size = min(a.size(),b.size()); i < size; i++){//cout<<i<<\"---\"<<endl;\n\t\tif(flag)hogehoge(a[i]-'a',b[i]-'a');\n\t\tif(a[i] != b[i]) flag = false;\n\t}\n\tif(flag&&b.size()<a.size())ans = false;\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(7);\n\t\n\t\n\twhile(true){\n\t\tint n;\n\t\t\n\t\tans = true;\n\t\trep(i,30)rep(j,30)temp[i][j]=false;\n\t\t\n\t\tcin>>n;\n\t\t\n\t\tif(!n) break;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>s[i];\n\t\t\tif(i) hoge(s[i-1],s[i]);\n\t}\n\t\n\t\tcout<<yn(ans)<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        vector<string> S(N);\n        for(auto &s:S) cin>>s;\n        int G[26][26];\n        fill(G[0],G[N],0);\n        bool flag=true;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                string s1=S[i], s2=S[j];\n                if(s1==s2) continue;\n                for(int ite=0;ite<max(s1.size(),s2.size());ite++){\n                    if(ite>=s2.size()){\n                        flag=false;\n                        break;\n                    }else{\n                        if(ite>=s1.size()) break;\n                        else{\n                            if(s1[ite]==s2[ite]) continue;\n                            else{\n                                G[s1[ite]-'a'][s2[ite]-'a']=1;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for(int k=0;k<26;k++){\n            for(int i=0;i<26;i++){\n                for(int j=0;j<26;j++){\n                    G[i][j]|=G[i][k]&G[k][j];\n                }\n            }\n        }\n        for(int i=0;i<N;i++){\n            if(G[i][i]) flag=false;\n        }\n        cout<<(flag?\"yes\":\"no\")<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main(){\n\tint n;\n\twhile (cin >> n && n){\n\t\tbool f = 1;\n\t\tvector<string> s(n);\n\t\tREP(i,n) cin >> s[i];\n\t\tVVI e(26,VI(26));\n\t\tREP(i,n-1){\n\t\t\tstring a = s[i], b = s[i+1];\n\t\t\tREP(j,min(a.length(), b.length())){\n\t\t\t\tif (a[j] != b[j]){\n\t\t\t\t\te[a[j]-'a'][b[j]-'a'] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == min(a.length(), b.length())-1 && a.length() > b.length())\n\t\t\t\t\tf = 0;\n\t\t\t}\n\t\t}\n\t\tREP(i,26){\n\t\t\tVI visit(26);\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\twhile (!que.empty()){\n\t\t\t\tint x = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tREP(j,26){\n\t\t\t\t\tif (!e[x][j] || visit[j]) continue;\n\t\t\t\t\tvisit[j] = 1;\n\t\t\t\t\tque.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (visit[i]) f = 0;\n\t\t}\n\t\tcout << (f ? \"yes\" : \"no\") << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n\n\ntypedef long long ll;\n\nint main(){\n  int n;\n  char s[1024][256];\n  while(~scanf(\"%d\", &n) && n){\n        rep(i, n) scanf(\"%s\", s[i]);\n        set<char> st[256];\n        bool ans = true;\n        rep(i, n){\n          REP(j, i+1, n){\n                bool f = true;\n                int li = strlen(s[i]), lj = strlen(s[j]);\n                int l = min(li, lj);\n                rep(k, l){\n                  if(s[i][k] != s[j][k]){\n                        f =false;\n                        if(st[s[j][k]].count(s[i][k])){\n                          ans = false;\n                          break;\n                        }\n                        st[s[i][k]].insert(s[j][k]);\n                        break;\n                  }\n                }\n                if(f && li > lj) ans = false;\n          }\n        }\n        printf(\"%s\\n\", (ans?\"yes\" : \"no\"));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum RESULT{\n\tdifferent,\n\tpre_shorter,\n\tpre_longer,\n};\n\nchar table[26][26];\n\nstruct Info{\n\tchar pre,current;\n\tRESULT result;\n};\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nInfo compare(char pre[11],char current[11]){\n\tInfo info;\n\n\tint pre_length,current_length;\n\n\tfor(pre_length = 0;pre[pre_length] != '\\0';pre_length++);\n\tfor(current_length = 0; current[current_length] != '\\0';current_length++);\n\n\tint index;\n\n\tfor(index = 0;pre[index] == current[index] && index < pre_length && index < current_length ;index++);\n\n\tif(index == pre_length && index == current_length){\n\t\tinfo.result = pre_shorter;\n\t}else if(index != pre_length && index == current_length){\n\t\tinfo.result = pre_longer;\n\t}else if(index == pre_length && index != current_length){\n\t\tinfo.result = pre_shorter;\n\t}else{\n\n\t\tinfo.result = different;\n\t\tinfo.pre = pre[index];\n\t\tinfo.current = current[index];\n\t}\n\n\treturn info;\n}\n\n\nint main(){\n\n\tint N;\n\tchar pre[11],current[11];\n\tbool FLG;\n\tInfo reason;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tfor(int k = 0; k < 26; k++){\n\t\t\t\tif(i != k){\n\t\t\t\t\ttable[i][k] = '?';\n\t\t\t\t}else{\n\t\t\t\t\ttable[i][k] = 'a'+ i;\n \t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFLG = true;\n\n\t\tscanf(\"%s\",pre);\n\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tscanf(\"%s\",current);\n\n\t\t\tif(FLG){\n\t\t\t\treason = compare(pre,current);\n\t\t\t\tif(reason.result == pre_longer){\n\t\t\t\t\tFLG = false;\n\t\t\t\t}else if(reason.result == different){\n\n\t\t\t\t\tif(table[reason.pre-'a'][reason.current-'a'] == '?'){\n\n\t\t\t\t\t\tfor(int k = 0; k < 26; k++){\n\t\t\t\t\t\t\tif(table[k][reason.pre-'a'] == 'a'+k && table[k][reason.current-'a'] == reason.current){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttable[reason.pre-'a'][reason.current-'a'] = reason.pre;\n\t\t\t\t\t\ttable[reason.current-'a'][reason.pre-'a'] = reason.pre;\n\n\t\t\t\t\t\tfor(int me = 0;me < 26; me++){\n\t\t\t\t\t\t\tfor(int you = 0; you < 26; you++){\n\t\t\t\t\t\t\t\tif(me != you && table[me][you] == 'a' + me){\n\t\t\t\t\t\t\t\t\tfor(int other = 0; other < 26; other++){\n\t\t\t\t\t\t\t\t\t\tif(you != other && table[you][other] == 'a' + you){\n\t\t\t\t\t\t\t\t\t\t\ttable[me][other] = 'a' + me;\n\t\t\t\t\t\t\t\t\t\t\ttable[other][me] = 'a' + me;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(table[reason.pre-'a'][reason.current-'a'] == reason.pre){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstrcpy(pre,current);\n\t\t\t}\n\t\t}\n\n\t\tif(FLG)printf(\"yes\\n\");\n\t\telse{\n\t\t\tprintf(\"no\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<string> v(n);\n\t\tREP(i, n)cin >> v[i];\n\t\tvvi g(26);\n\t\tbool ok = true;\n\t\tREP(i, n - 1) {\n\t\t\tbool done = false;\n\t\t\tREP(j, min(v[i].size(), v[i + 1].size())) {\n\n\t\t\t\tif (v[i][j] != v[i + 1][j]) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tg[v[i][j] - 'a'].push_back(v[i + 1][j] - 'a');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\tif (v[i].size() > v[i + 1].size())ok = false;\n\t\t\t}\n\t\t}\n\t\tREP(i, 26) {\n\t\t\tsort(ALL(g[i]));\n\t\t\tUNIQUE(g[i]);\n\t\t}\n\t\tvi d(26);\n\t\tREP(i, 26) {\n\t\t\tREP(j, g[i].size()) {\n\t\t\t\td[g[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tqueue<int> q;\n\t\tREP(i, 26)if (d[i] == 0)q.push(i);\n\t\twhile (!q.empty()) {\n\t\t\tint p = q.front();\n\t\t\tq.pop();\n\t\t\tREP(i, g[p].size()) {\n\t\t\t\tif (--d[g[p][i]] == 0)q.push(g[p][i]);\n\t\t\t}\n\t\t}\n\t\tok &= *max_element(ALL(d)) == 0;\n\t\tif (ok)cout << \"yes\" << endl;\n\t\telse cout << \"no\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\nconst int AtoZ = 'z'-'a';\n\nbool check(int n, int b, int e, vector<string> &str, vector<vector<int> > &ord){\n\tchar now=str[b][n];\n\tint s=b;\n\tfor(int i=b; i<=e; i++){\n\t\tif(str[i][n] != now){\n\t\t\tif(str[i][n]=='0') return false;\n\t\t\tif(now!='0'){\n\t\t\t\tord[now-'a'][str[i][n]-'a'] = 0;\n\t\t\t\tif(!check(n+1, s, i-1, str, ord)) return false;\n\t\t\t\ts = i;\n\t\t\t\tnow = str[i][n];\n\t\t\t}\n\t\t}\n\t}\n\tif(now!='0'){\n\t\tif(!check(n+1, s, e, str, ord)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<string> str(n);\n\t\tvector<vector<int> > ord(AtoZ, vector<int>(AtoZ, inf));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> str[i];\n\t\t\tstr[i] += \"0\";\n\t\t}\n\t\tif(!check(0, 0, n-1, str, ord)){\n\t\t\tcout << \"no\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<AtoZ; k++){\n\t\t\tfor(int i=0; i<AtoZ; i++){\n\t\t\t\tfor(int j=0; j<AtoZ; j++){\n\t\t\t\t\tord[i][j] = min(ord[i][j], ord[i][k]+ord[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i=0; i<AtoZ; i++){\n\t\t\tfor(int j=i+1; j<AtoZ; j++){\n\t\t\t\tif(ord[i][j]==0 && ord[j][i]==0){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tcout << \"yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace Sccs{\n    struct Edge{\n        int to;\n        Edge(int to):to(to){};\n    };\n    typedef vector<vector<Edge> > Graph;\n\n    //O(V+E)\n    class Scc{\n    private:\n        int V;\n        Graph g,rg;\n        vector<bool> used;\n       \n        void dfs(int v){\n            used[v]=true;\n            EACH(e,g[v])if(!used[e->to])dfs(e->to);\n            vs.push_back(v);\n        }\n        void rdfs(int v,int k){\n            used[v]=true;\n            cmp[v]=k;\n            EACH(e,rg[v])if(!used[e->to])rdfs(e->to,k);\n        }\n    public:\n         vector<int> vs,cmp; //cmp...強連結成分を同一視したトポロジカルソート順序\n\n        Scc(int V):V(V){\n            g=Graph(V);rg=Graph(V);\n            vs=vector<int>(V);cmp=vector<int>(V);used=vector<bool>(V);\n        }\n        void add_edge(int f,int t){\n            g[f].push_back(t);rg[t].push_back(f);\n        }\n        int scc(){\n            fill(ALL(used),false);\n            vs.clear();\n            REP(v,V)if(!used[v])dfs(v);\n\n            fill(ALL(used),false);\n            int k=0;\n            for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n            return k;\n        }\n        //sample\n        bool same(int i,int j){\n            return cmp[i]==cmp[j];\n        }\n    };\n}\nusing namespace Sccs;\nclass Main{\npublic:\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N;cin >> N;\n\t\t\tif(N==0)break;\n\t\t\tvector<string> ss(N);\n\t\t\tREP(i,N) cin >> ss[i];\n\n\t\t\tbool ok=true;\n\t\t\tScc scc(26);\n\t\t\tfor(int i=0;i+1<N;i++){\n\t\t\t\tfor(int c=0;true;c++){\n\t\t\t\t\tif((c<ss[i].size()) && !(c<ss[i+1].size())){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(!(c<min(ss[i].size(),ss[i+1].size())))break;\n\n\t\t\t\t\tif(ss[i][c]!=ss[i+1][c]){\n\t\t\t\t\t\tscc.add_edge(ss[i][c]-'a',ss[i+1][c]-'a');\n\t\t\t\t\t//\tDUMP(ss[i][c]);DUMP(ss[i+1][c]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.scc();\n\t\t\tREP(i,26)REP(j,26) if(i!=j){\n\t\t\t\tif(scc.same(i, j))ok=false;\n\t\t\t}\n\t\t\tcout << (ok?\"yes\":\"no\")<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nbool vis[30];\nbool par[30][30];\nchar c[505][15];\nint diff(char* A,char* B,int len1,int len2)\n{\n    int mark=0,i;\n    for(i=0;i<len1&&i<len2;i++)\n    {\n        if(A[i]!=B[i])\n        {\n            return i;\n        }\n    }\n    return -1;\n}\nint main()\n{\n    int n,mark;\n    char last;\n    while(scanf(\"%d\",&n)!=EOF&&n)\n    {\n        mark=0;\n        memset(par,false,sizeof(par));\n        memset(vis,false,sizeof(vis));\n        for(int i=0;i<n;i++)\n            scanf(\"%s\",c[i]);\n        for(int i=0;i<n;i++)\n        {\n            if(i>0&&c[i-1][0]==c[i][0])\n            {\n                int len1=strlen(c[i-1]),len2=strlen(c[i]);\n                int pos=diff(c[i-1],c[i],len1,len2);\n                if(pos>0&&pos<len1&&pos<len2)\n                    par[c[i-1][pos]-'a'][c[i][pos]-'a']=true;\n                else if(len1>len2)\n                {\n                    int pos1=diff(c[i],c[i-1],len2,len1);\n                    if(pos1==-1)\n                    {\n                        mark=1;\n                        //printf(\"i-1=%s,i=%s\\n\",c[i-1],c[i]);\n                    }\n                }\n            }\n            else if(i>0) par[c[i-1][0]-'a'][c[i][0]-'a']=true;\n\n        }\n//        for(int i=0;i<10;i++)\n//        {\n//            for(int j=0;j<10;j++)\n//            {\n//                printf(\"%d \",par[i][j]);\n//            }\n//            cout<<endl;\n//        }\n        //cout<<mark<<endl;\n//        if(!mark)\n//        {\n            for(int i=0;i<27;i++)\n            {\n                for(int j=0;j<i;j++)\n                {\n                    if(par[i][j]&&par[j][i])\n                    {\n                        //printf(\"mark %c %c\\n\",i+'a',j+'a');\n                        mark=1;\n                        break;\n                    }\n                }\n                if(mark) break;\n            }\n//        }\n        if(mark) printf(\"no\\n\");\n        else printf(\"yes\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace Sccs{\n    struct Edge{\n        int to;\n        Edge(int to):to(to){};\n    };\n    using Graph= vector<vector<Edge> >;\n\n    //O(V+E)\n    class Scc{\n    private:\n        int V;\n        Graph g,rg;\n        vector<bool> used;\n       \n        void dfs(int v){\n            used[v]=true;\n            EACH(e,g[v])if(!used[e->to])dfs(e->to);\n            vs.push_back(v);\n        }\n        void rdfs(int v,int k){\n            used[v]=true;\n            cmp[v]=k;\n            EACH(e,rg[v])if(!used[e->to])rdfs(e->to,k);\n        }\n    public:\n         vector<int> vs,cmp; //cmp...強連結成分を同一視したトポロジカルソート順序\n\n        Scc(int V):V(V){\n            g=Graph(V);rg=Graph(V);\n            vs=vector<int>(V);cmp=vector<int>(V);used=vector<bool>(V);\n        }\n        void add_edge(int f,int t){\n            g[f].push_back(t);rg[t].push_back(f);\n        }\n        int scc(){\n            fill(ALL(used),false);\n            vs.clear();\n            REP(v,V)if(!used[v])dfs(v);\n\n            fill(ALL(used),false);\n            int k=0;\n            for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n            return k;\n        }\n        //sample\n        bool same(int i,int j){\n            return cmp[i]==cmp[j];\n        }\n    };\n}\nusing namespace Sccs;\nclass Main{\npublic:\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N;cin >> N;\n\t\t\tif(N==0)break;\n\t\t\tvector<string> ss(N);\n\t\t\tREP(i,N) cin >> ss[i];\n\n\t\t\tbool ok=true;\n\t\t\tScc scc(26);\n\t\t\tfor(int i=0;i+1<N;i++){\n\t\t\t\tfor(int c=0;true;c++){\n\t\t\t\t\tif((c<ss[i].size()) && !(c<ss[i+1].size())){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(!(c<min(ss[i].size(),ss[i+1].size())))break;\n\n\t\t\t\t\tif(ss[i][c]!=ss[i+1][c]){\n\t\t\t\t\t\tscc.add_edge(ss[i][c]-'a',ss[i+1][c]-'a');\n\t\t\t\t\t//\tDUMP(ss[i][c]);DUMP(ss[i+1][c]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tscc.scc();\n\t\t\tREP(i,26)REP(j,26) if(i!=j){\n\t\t\t\tif(scc.same(i, j))ok=false;\n\t\t\t}\n\t\t\tcout << (ok?\"yes\":\"no\")<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool dfs(int cur, bool m[30][30], bool used[30]){\n    if(used[cur]) return 1;\n    used[cur] = 1;\n\n    bool ret = 0;\n    rep(i,27){\n        if(m[cur][i]) ret |= dfs(i,m,used);\n    }\n    return ret;\n}\n\nbool isDAG(bool m[30][30]){\n    rep(i,27) if(m[i][i]) return false;\n\n    bool used[30] = {0};\n    return not dfs(0, m, used);\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        bool m[30][30] = {{0}};\n        char s[505][10];\n        rep(i,505) rep(j,10) s[i][j] = '\\0';\n        rep(i,n) cin >> s[i];\n\n        bool ans = true;\n        rep(i,n - 1){\n            rep(j,10){\n                if(s[i][j] != '\\0' && s[i + 1][j] == '\\0'){\n                    ans = false;\n                    break;\n                }else if(s[i][j] == '\\0' || s[i + 1][j] == '\\0'){\n                    break;\n                }else if(s[i][j] != s[i + 1][j]){\n                    m[s[i][j] - 'a'][s[i + 1][j] - 'a'] = 1;\n                    break;\n                }\n            }\n        }\n\n        cout << (isDAG(m) && ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<ll, ll> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vi> g(27);\n\t\tvs v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\twhile (s.size() < 10) s += 'z' + 1;\n\t\t\tv.push_back(s);\n\t\t}\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tstring u = v[i], d = v[j];\n\t\t\tint t = 0;\n\t\t\twhile (u[t] == d[t]&&t<10) t++;\n\t\t\tif (t == 10) continue;\n\t\t\tint un = u[t] - 'a', dn = d[t] - 'a';\n\t\t\tif (un != dn) g[un].push_back(dn);\n\t\t}\n\t\tbool f = true;\n\t\tif (g[26].size() > 0) f = false;\n\t\tREP(i, 26)\n\t\t{\n\t\t\tsort(ALL(g[i]));\n\t\t\tg[i].erase(unique(ALL(g[i])), g[i].end());\n\t\t}\n\t\tvector<bool> vis(26);\n\t\tREP(i, 26)\n\t\t{\n\t\t\tstack<pii> st;\n\t\t\tst.push(pii(i, 0));\n\t\t\twhile (st.size())\n\t\t\t{\n\t\t\t\tint tmp = st.top().first, cnt = st.top().second;\n\t\t\t\tst.pop();\n\t\t\t\tif (cnt>30)\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tREP(j, g[tmp].size())\n\t\t\t\t{\n\t\t\t\t\tst.push(pii(g[tmp][j], cnt+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tend:;\n\t\tputs(f ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<string> s;\nvector<vector<ll>> g(26);\nvector<bool> sorted;\n\nbool dfs(ll k) {\n\tbool upd=false;\n\tbool ret=true;\n\tREP(i,n-1) {\n\t\tif(!sorted[i]&&s[i].size()>k&&s[i+1].size()==k) ret=false;\n\t\tif(s[i].size()<=k||s[i+1].size()<=k) continue;\n\t\tupd=true;\n\t\tif(!sorted[i]&&s[i][k]!=s[i+1][k]) {\n\t\t\tsorted[i]=true;\n\t\t\tg[s[i][k]-'a'].pb(s[i+1][k]-'a');\n\t\t}\n\t}\n\tif(upd) ret=ret&dfs(k+1);\n\treturn ret;\n}\n\nbool dfs2(ll p, ll par, ll tgt, vector<bool>& used) {\n\tused[p]=true;\n\tbool ret=true;\n\tREP(i,g[p].size()) {\n\t\tif(g[p][i]==tgt) return false;\n\t\tif(g[p][i]==par) continue;\n\t\tif(used[g[p][i]]) continue;\n\t\telse ret=ret&dfs2(g[p][i],p,tgt,used);\n\t}\n\treturn ret;\n}\n\nbool is_dag() {\n\tREP(i,26) {\n\t\tif(g[i].empty()) continue;\n\t\tsort(ALL(g[i]));\n\t\tg[i].erase(unique(ALL(g[i])),g[i].end());\n\t}\n\tREP(i,26) {\n\t\tvector<bool> used(26,false);\n\t\tif(!dfs2(i,-1,i,used)) return false;\n\t}\n\treturn true;\n}\n\nstring solve() {\n\ts.assign(n,\"\");\n\tg.assign(26,vector<ll>(0));\n\tsorted.assign(n-1,false);\n\tREP(i,n) cin>>s[i];\n\tif(!dfs(0)) return \"no\";\n\tif(is_dag()) return \"yes\";\n\telse return \"no\";\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n \n#define INF 100000000\nbool p[26][26];\nint d[26];\nint n;\nstring s[510];\n \nint main(){\n  while(cin >> n,n){\n    for(int i=0;i<n;i++)cin >> s[i];\n \n    for(int i=0;i<26;i++)\n      for(int j=0;j<26;j++)p[i][j] = false;\n \n    bool f = true;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint lim = min(s[i].size(),s[j].size());\n\tint k;\n\tfor(k=0;k<lim;k++){\n\t  if(s[i][k] != s[j][k]){\n\t    p[s[i][k]-'a'][s[j][k]-'a'] = true;\n\t    break;\n\t  }\n\t}\n\tif(k==lim && s[i].size()>s[j].size()){\n\t  f = false;\n\t  break;\n\t}\n      }\n    }\n \n    for(int k=0;k<26;k++){\n      for(int i=0;i<26;i++){\n\tfor(int j=0;j<26;j++){\n\t  if(p[i][k] && p[k][j])p[i][j] = true;\n\t}\n      }\n    }\n  \n    for(int i=0;i<26;i++)if(p[i][i])f = false;\n \n    if(!f)cout << \"no\\n\";\n    else cout << \"yes\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500\n#define C 26\nusing namespace std;\nint n,slen[N],edge[C][C],f[N][N];\nint ans;\nstring s[N];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    ans=1;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      slen[i]=s[i].size();\n    }\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)f[i][j]=0;\n    for(int i=0;i<C;i++)\n      for(int j=0;j<C;j++)\n\tedge[i][j]=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<10;j++){\n\tif(slen[i]<j+1)continue;\n\tfor(int k=i+1;k<n;k++){\n\t  if(!f[i][k]&&s[i][j]==s[k][j])\n\t    if(slen[k]==j+1&&slen[i]>slen[k])\n\t      ans=0;\n\t  if(f[i][k])continue;\n\t  if(slen[k]<j+1)continue;\n\t  int i1=s[i][j]-'a';\n\t  int i2=s[k][j]-'a';\n\t  if(i1==i2)continue;\n\t  if(i1!=i2)f[i][k]=1;\n\t  edge[i1][i2]=1;\n\t}\n      }\n    }\n    for(int i=0;i<C;i++)\n      for(int j=0;j<C;j++)\n\tif(edge[i][j]&&edge[j][i])\n\t  ans=0;\n    if(ans)cout<<\"yes\"<<endl;\n    else cout<<\"no\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint n;\nstring str[501];\nvector<int> G[27];\nbool used[27];\nint edge[27][27];\nint num[27];\nvector<int> vs;\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n\nbool check(){\n\tfor(int i=0;i<27;i++){\n\t\tG[i].clear();\n\t}\n\tmemset(edge,0,sizeof(edge));\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tint k;\n\t\t\tfor(k=0;k<min(str[i].size(),str[j].size());k++){\n\t\t\t\tif(str[i][k]!=str[j][k]){\n\t\t\t\t\tif(edge[str[i][k]-'a'][str[j][k]-'a']==0){\n\t\t\t\t\t\tG[str[i][k]-'a'].push_back(str[j][k]-'a');\n\t\t\t\t\t\tedge[str[i][k]-'a'][str[j][k]-'a']=1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k==min(str[i].size(),str[j].size()) && str[i].size()>str[j].size())return false;\n\t\t}\n\t}\n\tmemset(used,0,sizeof(used));\n\tfor(int i=0;i<=26;i++){\n\t\tif(!used[i])dfs(i);\n\t}\n\tfor(int i=0;i<vs.size();i++){\n\t\tnum[vs[i]]=i;\n\t}\n\tfor(int i=0;i<26;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tif(num[i]<num[G[i][j]])return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> str[i];\n\t\t}\n\t\tprintf(\"%s\\n\",check()?\"yes\":\"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    \n    vector<string>v(n);\n    rep(i,n)cin >> v[i];\n\n    map<char,int>od;\n    bool fg=true;\n    int cnt=0;\n    for(int i=0;i<n;i++){\n      if(od.count(v[i][0])&& od[v[i][0]]!=cnt)fg=false;\n      if(!od.count(v[i][0]))od[v[i][0]]=++cnt;\n    }\n    \n    for(int i=1;i<10;i++){\n      for(int j=0;j+1<n;j++){\n\tif(v[j].substr(0,i)==v[j+1].substr(0,i)){\n\t  if(v[j+1].substr(i,v[j+1].size()-i).size()==0)fg=false;\n\t  if(od[v[j][i]]==0)od[v[j][i]]=++cnt;\n\t  if(od[v[j+1][i]]==0)od[v[j+1][i]]=++cnt;\n\t  if(od[v[j][i]]>od[v[j+1][i]])fg=false;\n\t}\n      }\n    }\n\n    cout << (fg?\"yes\":\"no\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        vector<string> S(N);\n        for(auto &s:S) cin>>s;\n        int G[26][26];\n        fill(G[0],G[N],0);\n        bool flag=true;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                string s1=S[i], s2=S[j];\n                if(s1==s2) continue;\n                for(int ite=0;ite<max(s1.size(),s2.size());ite++){\n                    if(ite>=s2.size()){\n                        flag=false;\n                        break;\n                    }else{\n                        if(ite>=s1.size()) break;\n                        else{\n                            if(s1[ite]==s2[ite]) continue;\n                            else{\n                                G[s1[ite]-'a'][s2[ite]-'a']=1;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for(int k=0;k<26;k++){\n            for(int i=0;i<26;i++){\n                for(int j=0;j<26;j++){\n                    G[i][j]|=G[i][k]&G[k][j];\n                }\n            }\n        }\n        for(int i=0;i<26;i++){\n            if(G[i][i]) flag=false;\n        }\n        cout<<(flag?\"yes\":\"no\")<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n    int n;\n    string a[505];\n    while(scanf(\"%d\",&n)!=EOF&&n)\n    {\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            cin>>a[i];\n            if(i>0)\n            {\n                for(int j=0;j<i;j++)\n                {\n                    int flag=0;\n                    int k=0;\n                    while(a[i][k])\n                    {\n                        if(a[i][k]!=a[j][k])\n                        {\n                            flag=1;\n                            break;\n                        }\n                        k++;\n                    }\n                    if(flag==0)\n                    {\n                        ans=0;\n                        break;\n                    }\n                    else\n                        ans=1;\n                }\n            }\n        }\n        if(ans==0)\n                cout<<\"no\"<<endl;\n            else\n                cout<<\"yes\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\nconst int AtoZ = 26;\n\nbool check(int n, int b, int e, vector<string> &str, vector<vector<int> > &ord){\n\tchar now=str[b][n];\n\tint s=b;\n\tfor(int i=b; i<=e; i++){\n\t\tif(str[i][n] != now){\n\t\t\tif(str[i][n]=='0') return false;\n\t\t\tif(now!='0'){\n\t\t\t\tord[now-'a'][str[i][n]-'a'] = 0;\n\t\t\t\tif(!check(n+1, s, i-1, str, ord)) return false;\n\t\t\t}\n\t\t\ts = i;\n\t\t\tnow = str[i][n];\n\t\t}\n\t}\n\tif(now!='0'){\n\t\tif(!check(n+1, s, e, str, ord)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<string> str(n);\n\t\tvector<vector<int> > ord(AtoZ, vector<int>(AtoZ, inf));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> str[i];\n\t\t\tstr[i] += \"0\";\n\t\t}\n\t\tif(!check(0, 0, n-1, str, ord)){\n\t\t\tcout << \"no\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<AtoZ; k++){\n\t\t\tfor(int i=0; i<AtoZ; i++){\n\t\t\t\tfor(int j=0; j<AtoZ; j++){\n\t\t\t\t\tord[i][j] = min(ord[i][j], ord[i][k]+ord[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i=0; i<AtoZ; i++){\n\t\t\tfor(int j=i+1; j<AtoZ; j++){\n\t\t\t\tif(ord[i][j]==0 && ord[j][i]==0){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tcout << \"yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint N;\nvector<vector<int>> v(26);\nint vis[26] = {};\n\nbool dfs(int n){\n    vis[n] = -1;\n    bool ok = true;\n    for(auto x:v[n]){\n        if(vis[x]==0) ok = ok && dfs(x);\n        else if(vis[x]==-1) return false;\n    }\n    vis[n] = 1;\n    return ok;\n}\n\nint main(){\n    while(cin >> N && N){\n        vector<string> S(N);\n        for(int i=0;i<26;i++){\n            v[i].clear();\n            vis[i] = 0;\n        }\n        bool yes = true;\n        for(int i=0;i<N;i++){\n            cin >> S[i];\n            if(i>=1){\n                if(S[i-1].size()>S[i].size() && S[i-1].substr(0,S[i].size())==S[i]) yes = false;\n                else{\n                    int n = S[i-1].size(),m = S[i].size();\n                    for(int j=0;j<min(n,m);j++){\n                        if(S[i-1][j]!=S[i][j]){\n                            v[S[i-1][j]-'a'].push_back(S[i][j]-'a');\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=0;i<26;i++) if(!vis[i]) yes = yes && dfs(i);\n        cout << (yes? \"yes\":\"no\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[510][20];\nint g[30][30];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<26;i++)for(int j=0;j<26;j++)g[i][j]=0;\n\t\tfor(int i=0;i<26;i++)g[i][i]=1;\n\t\tbool ok=true;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tint k;\n\t\t\t\tfor(k=0;str[i][k]&&str[j][k];k++){\n\t\t\t\t\tif(str[i][k]!=str[j][k]){\n\t\t\t\t\t\tg[str[i][k]-'a'][str[j][k]-'a']=1;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[i][k]&&!str[j][k])ok=false;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<26;k++)for(int i=0;i<26;i++)for(int j=0;j<26;j++)\n\t\t\tg[i][j]|=(g[i][k]&g[k][j]);\n\t\t\n\t\tfor(int i=0;i<26;i++)for(int j=0;j<26;j++)if(i!=j&&g[i][j]&&g[j][i])ok=false;\n\t\tif(ok)printf(\"yes\\n\");\n\t\telse printf(\"no\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Graph{\n\tpublic:\n\tint n;\n\tvvi g,rg;\n\tvi scc,used;\n\tstack<int> stc;\n\tvoid Order(int v){\n\t\tused[v]=1;\n\t\tfor(auto u:g[v]) if(!used[u]) Order(u);\n\t\tstc.push(v);\n\t}\n\tvoid DFS(int v,int t){\n\t\tused[v]=1;\n\t\tfor(auto u:rg[v]) if(!used[u]) DFS(u,t);\n\t\tscc[v]=t;\n\t}\n\tint SCC(){\n\t\tscc=used=vi(n);\n\t\trg=vvi(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!used[i]) Order(i);\n\t\t\tfor(auto v:g[i]) rg[v].push_back(i);\n\t\t}\n\t\tint t=0;\n\t\tused=vi(n);\n\t\twhile(!stc.empty()){\n\t\t\tint v=stc.top();\n\t\t\tstc.pop();\n\t\t\tif(!used[v]) DFS(v,t++);\n\t\t}\n\t\treturn t;\n\t}\n\tGraph(int v){\n\t\tn=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tvs a(n);\n\t\tfor(int i=0;i<n;i++) cin>>a[i];\n\t\tbool B=0;\n\t\tGraph g(26);\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint s=a[i-1].size(),s1=a[i].size();\n\t\t\tbool flag=0;\n\t\t\tfor(int j=0;j<min(s,s1);j++) if(a[i-1][j]!=a[i][j]){\n\t\t\t\tg.add_edge(a[i-1][j]-'a',a[i][j]-'a');\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!flag&&s>s1) B=1;\n\t\t}\n\t\tif(B){\n\t\t\tcout<<\"no\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(g.SCC()<26) cout<<\"no\"<<endl;\n\t\telse cout<<\"yes\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=29,INF=1<<30;\n\nint V,cmp[MAX];\nvector<int> G[MAX],rG[MAX],vs;//vsがトポソの逆順になってる\nbool used[MAX];\n\nvoid add_edge(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid DFS(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        if(used[G[v][i]]==0) DFS(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rDFS(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++){\n        if(used[rG[v][i]]==0) rDFS(rG[v][i],k);\n    }\n}\n\nint scc(){\n    memset(used,0,sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++){\n        if(used[v]==0) DFS(v);\n    }\n    \n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n        if(used[vs[i]]==0) rDFS(vs[i],k++);\n    }\n    return k;\n}\n\nvoid init(){\n    for(int i=0;i<26;i++){\n        G[i].clear();\n        rG[i].clear();\n    }\n    V=26;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        init();\n        vector<string> S(N);\n        for(int i=0;i<N;i++) cin>>S[i];\n        \n        bool ok=true;\n        \n        for(int i=1;i<N;i++){\n            if(S[i-1].size()==S[i].size()){\n                for(int j=0;j<S[i].size();j++){\n                    if(S[i-1][j]!=S[i][j]){\n                        add_edge(S[i-1][j]-'a',S[i][j]-'a');\n                        break;\n                    }\n                }\n            }else if(S[i-1].size()<S[i].size()){\n                for(int j=0;j<S[i-1].size();j++){\n                    if(S[i-1][j]!=S[i][j]){\n                        add_edge(S[i-1][j]-'a',S[i][j]-'a');\n                        break;\n                    }\n                }\n            }else{\n                for(int j=0;j<S[i].size();j++){\n                    if(S[i-1][j]!=S[i][j]){\n                        add_edge(S[i-1][j]-'a',S[i][j]-'a');\n                        break;\n                    }\n                    \n                    if(j+1==S[i].size()) ok=false;\n                }\n            }\n        }\n        \n        int k=scc();\n        \n        if(k==26&&ok) cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nchar premark = 'a' - 1;\n\nbool dfs(map<char, vector<char>>& G, vector<bool>& vis, char c, set<char>& st) {\n  for(auto& next: G[c]) {\n    if(st.count(next)) return false;\n    st.insert(next);\n    if(vis[next-'a']) continue;\n    vis[next-'a'] = 1;\n    if(!dfs(G, vis, next, st)) return false;\n    st.erase(next);\n  }\n  return true;\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    vector<string> v;\n    int L = 1;\n    rep(i, N) {\n      string s; cin >> s;\n      v.push_back(s);\n      maximize(L, s.size());\n    }\n    rep(i, N) {\n      v[i].resize(L, premark);\n    }\n\n    map<char, vector<char>> G;\n    vector<bool> vis(26);\n    bool oks[26] = {};\n    vector<char> starts;\n\n    rep(i, N-1) {\n      REP(ni, i+1, N) {\n        rep(j, L) {\n          if(v[i][j] == v[ni][j] && v[i][j] == premark) break;\n          if(v[i][j] == premark) break;\n          if(v[ni][j] == premark) goto ng;\n          if(v[i][j] == v[ni][j]) continue;\n          G[v[i][j]].push_back(v[ni][j]);\n          break;\n        }\n      }\n    }\n\n    rep(i, 26) if(!G['a'+i].empty()) {\n      sort(all(G['a'+i]));\n      G['a'+i].erase(unique(all(G['a'+i])), G['a'+i].end());\n    }\n\n    rep(i, 26) {\n      for(auto k: G[i+'a']) if(k) {\n        oks[k-'a'] = 1;\n      }\n    }\n\n\n    rep(i, 26)\n      if(!oks[i]) starts.push_back(i + 'a');\n\n    for(auto s: starts) {\n      vis[s-'a'] = 1;\n      set<char> st;\n      if(!dfs(G, vis, s, st)) goto ng;\n    }\n\n    cout << \"yes\" << endl;\n    continue;\n\n    ng:;\n    cout << \"no\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 100;\n\nvector<int> g[MAX_V]; //????????\nvector<int> tp; //????????????????????????????????????\n\nbool visit(int v, vector<int> &color){\n    color[v] = 1;\n    rep(i,g[v].size()){\n        int d = g[v][i];\n        if(color[d] == 2) continue;\n        if(color[d] == 1) return false;\n        if(not visit(d, color)) return false;\n    }\n    tp.emplace_back(v);\n    color[v] = 2;\n    return true;\n}\n\nbool topologicalSort(int v){\n    vector<int> color(v);\n    rep(i,v){\n        if(not color[i] && not visit(i, color)) return false;\n    }\n    reverse(all(tp));\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        rep(i,MAX_V) g[i].clear();\n        tp.clear();\n        char s[505][10];\n        rep(i,505) rep(j,10) s[i][j] = '\\0';\n        rep(i,n) cin >> s[i];\n\n        bool ans = true;\n        rep(i,n){\n            range(j,i + 1, n){\n                rep(k,10){\n                    if(s[i][k] != '\\0' && s[j][k] == '\\0'){\n                        ans = false;\n                        break;\n                    }else if(s[i][k] == '\\0' || s[j][k] == '\\0'){\n                        break;\n                    }else if(s[i][k] != s[j][k]){\n                        //cout << s[i][k] << ' ' << s[j][k] << endl;\n                        g[s[i][k] - 'a'].emplace_back(s[j][k] - 'a');\n                        break;\n                    }\n                }\n            }\n        }\n\n        cout << (topologicalSort(27) && ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint n; vector<string> s;\nbool ok(int d, int l, int r) {\n\tif (s[l].size() == d) l++;\n\tfor (int i = l; i < r; i++) {\n\t\tif (s[i].size() == d) return false;\n\t}\n\tbool ret = true;\n\tfor (int p = l, i = l + 1; i <= r; i++) {\n\t\tif (i == r || s[i - 1][d] != s[i][d]) {\n\t\t\tif (!ok(d + 1, p, i)) ret = false;\n\t\t\tp = i;\n\t\t}\n\t}\n\treturn ret;\n}\nbool cycle_detection(vector<vector<int> > &G) {\n\tvector<bool> vis(G.size());\n\tfunction<bool(int, int, bool)> rec = [&](int pos, int start, bool flag) {\n\t\tif (pos == start && flag) return true;\n\t\tif (flag) vis[pos] = true;\n\t\tbool ret = false;\n\t\tfor (int e : G[pos]) {\n\t\t\tif (!vis[e]) ret = ret || rec(e, start, true);\n\t\t}\n\t\treturn ret;\n\t};\n\tfor (int i = 0; i < G.size(); i++) {\n\t\tfill(vis.begin(), vis.end(), false);\n\t\tif (rec(i, i, false)) return true;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\ts = vector<string>(n);\n\t\tfor (int i = 0; i < n; i++) cin >> s[i];\n\t\ts.erase(unique(s.begin(), s.end()), s.end()); n = s.size();\n\t\tbool res = ok(0, 0, n);\n\t\tif (!res) cout << \"no\" << endl;\n\t\telse {\n\t\t\tvector<vector<int> > G(26);\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < min(s[i - 1].size(), s[i].size()); j++) {\n\t\t\t\t\tif (s[i - 1][j] != s[i][j]) {\n\t\t\t\t\t\tG[s[i - 1][j] - 97].push_back(s[i][j] - 97);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << (cycle_detection(G) ? \"no\" : \"yes\") << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\n#define N 100\nvector<int> G[N],rG[N],g;\nbool u[N];\nint n,cmp[N];\n  \nvoid add_edge(int x,int y){G[x].push_back(y);rG[y].push_back(x);}\nvoid dfs(int x){u[x]=1;rep(i,G[x].size())if(!u[G[x][i]])dfs(G[x][i]);g.push_back(x);} \nvoid rdfs(int x,int k){u[x]=1;cmp[x]=k;rep(i,rG[x].size())if(!u[rG[x][i]])rdfs(rG[x][i],k);}\nint scc() {\n  mem(u);g.clear();rep(i,n)if(!u[i])dfs(i);mem(u);\n  int k=0;rrep(i,g.size())if(!u[g[i]])rdfs(g[i],k++);return k;\n}\n\nvoid Main() {\n  n=26;\n  int m;\n  while(R m && m) {\n    rep(i,n) G[i].clear(),rG[i].clear();\n    set<int> se;\n    string s[m];\n    rep(i,m) R s[i];\n    rep(i,m-1) {\n      bool f=1;\n      rep(j,min(s[i].size(),s[i+1].size())) {\n        if(s[i][j]!=s[i+1][j]) {\n          add_edge(s[i][j]-'a',s[i+1][j]-'a');\n          f=0;\n          break;\n        }\n      }\n      if(f&&s[i].size()>s[i+1].size()) {\n        pr(\"no\");\n        goto next;\n      }\n    }\n    scc();\n    rep(i,26) se.in(cmp[i]);\n    if(se.size()==n) pr(\"yes\");\n    else pr(\"no\");\n  next:;\n  }\n\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nbool vis[26],now[26];\nvector<int> G[26];\nbool dfs(int v){\n\tvis[v]=1;\n\tnow[v]=1;\n\tfor(int u:G[v]){\n\t\tif(now[u]){\n\t\t\tnow[v]=0;\n\t\t\treturn 1;\n\t\t}\n\t\tif(!vis[u]){\n\t\t\tbool b=dfs(u);\n\t\t\tif(b){\n\t\t\t\tnow[v]=0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tnow[v]=0;\n\treturn 0;\n}\nbool solve(int N){\n\trep(i,26) vis[i]=now[i]=0,G[i].clear();\n\tstring s_[500];\n\trep(i,N) cin>>s_[i];\n\trep(i,N-1){\n\t\tstring s=s_[i],t=s_[i+1];\n\t\tint S=s.size(),T=t.size();\n\t\tint j=0;\n\t\twhile(j<S&&j<T&&s[j]==t[j]) j++;\n\t\tif(j==S) continue;\n\t\tif(j==T) return 0;\n\t\tG[s[j]-'a'].pb(t[j]-'a');\n\t}\n\tbool no=0;\n\trep(i,26){\n\t\tif(!vis[i]) no|=dfs(i);\n\t}\n\treturn !no;\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tif(solve(N)) puts(\"yes\");\n\t\telse puts(\"no\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nbool dfs(int pos, int start, const vector<vector<int>> &graph, vector<bool> &visited) {\n    if(visited[pos]) return false;\n\n    visited[pos] = true;\n    for(int v : graph[pos]) {\n        if(v == start) return true;\n        if(dfs(v, start, graph, visited)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    vector<string> v(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> v[i];\n    }\n    vector<vector<int>> graph(26);\n    for(int i = 0; i < N-1; ++i) {\n        const string &s1 = v[i];\n        const string &s2 = v[i+1];\n        if(s1.size() > s2.size() && s1.substr(0, s2.size()) == s2) {\n            cout << \"no\" << endl;\n            return true;\n        }\n        for(int j = 0; j < s1.size() && j < s2.size(); ++j) {\n            if(s1[j] != s2[j]) {\n                graph[s1[j]-'a'].push_back(s2[j]-'a');\n                break;\n            }\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        vector<bool> visited(26, false);\n        if(dfs(i, i, graph, visited)) {\n            cout << \"no\" << endl;\n            return true;\n        }\n    }\n    cout << \"yes\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nbool solve(vs ss)\n{\n\tss.erase(unique(all(ss)),end(ss));\n\tint n=ss.size();\n\tvvi d(26,vi(26,99));\n\trep(i,26) d[i][i]=0;\n\trep(i,n-1){\n\t\tconst string &s1=ss[i],&s2=ss[i+1];\n\t\tfor(int j=0;;j++){\n\t\t\tif(j==s2.size()) return false;\n\t\t\tif(j==s1.size()) break;\n\t\t\tif(s1[j]!=s2[j]){\n\t\t\t\tint u=s1[j]-'a',v=s2[j]-'a';\n\t\t\t\tif(d[u][v]==1) return false;\n\t\t\t\td[u][v]=-1,d[v][u]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trep(k,26) rep(i,26) rep(j,26) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\trep(i,26) if(d[i][i]<0) return false;\n\treturn true;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvs ss(n);\n\t\trep(i,n) cin>>ss[i];\n\t\tcout<<(solve(ss)?\"yes\":\"no\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int kNumAlphabets = 26;\n\nvi used;\nvvi edge;\nstring res;\n\nvoid dfs(int v){\n    if(used[v]){\n        res = \"no\";\n        return;\n    }\n\n    used[v] = true;\n\n    rep(u, kNumAlphabets){\n        if(edge[v][u]) dfs(u);\n    }\n}\n\nint main(void){\n    for(int n; cin >> n, n; cout << res << endl){\n        res = \"yes\";\n        edge = vvi(kNumAlphabets, vi(kNumAlphabets));\n\n        string pre; cin >> pre;\n        rep(i, n - 1){\n            string cur; cin >> cur;\n\n            rep(j, min(pre.size(), cur.size())){\n                bool same = true;\n\n                if(pre.at(j) != cur.at(j)){\n                    edge[pre.at(j) - 'a'][cur.at(j) - 'a'] = true;\n                    same = false;\n                    break;\n                }\n\n                if(same && cur.size() < pre.size()) res = \"no\";\n            }\n\n            pre = cur;\n        }\n\n        rep(u, kNumAlphabets){\n            used = vi(kNumAlphabets);\n            dfs(u);\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int MAXN = 26;\nconst int MAXM = 1000;\nint N;\nstring str[MAXM];\nint arr[30][30];\nint to[30];\nint topsort()\n{\n    queue<int> que;\n    vector<char> vec;\n    int vis[MAXN] = {0};\n    for(int i = 0; i < MAXN; i++)\n        if(to[i] == 0){\n            que.push(i);\n            vis[i] = 1;\n            vec.push_back(i+'a');\n        }\n    while(!que.empty()){\n        int u = que.front();\n        que.pop();\n        for(int i = 0; i < MAXN; i++) if(arr[u][i] && !vis[i]) {\n            to[i]--;\n            if(to[i] == 0) {\n                que.push(i);\n                vis[i] = 1;\n                vec.push_back(i+'a');\n            }\n        }\n    }\n    for(int i = 0; i < vec.size(); i++) {\n        cout<<vec[i]<<\" \";\n    }\n    cout<<endl;\n    for(int i = 0; i < MAXN; i++) {\n        if(!vis[i])\n            return 0;\n    }\n    return 1;\n}\nint main()\n{\n    while(cin>>N && N) {\n        int flag = 1;\n        memset(arr, 0, sizeof(arr));\n        memset(to, 0, sizeof(to));\n        for(int i = 1; i <= N; i++) {\n            cin>>str[i];\n        }\n        for(int i = 1; i <= N-1; i++) {\n            string a = str[i], b = str[i+1];\n            int len = a.length()<b.length()?a.length():b.length();\n            int j;\n            for(j = 0; j < len; j++) {\n                if(a[j]!=b[j] && arr[a[j]-'a'][b[j]-'a']==0) {\n                    arr[a[j]-'a'][b[j]-'a'] = 1;\n                    to[b[j]-'a']++;\n                    //cout<<a[j]-'a'<<\"     \"<<b[j]-'a'<<endl;\n                    break;\n                }else{\n                    continue;\n                }\n            }\n            if(j == len){\n                if(a.length()>b.length()){\n                    cout<<\"no\"<<endl;\n                    flag = 0;\n                    break;\n                }\n            }\n        }\n        if(N==1){\n            cout<<\"yes\"<<endl;\n            continue;\n        }\n        if(flag == 0){\n            continue;\n        }\n        if(topsort())\n            cout<<\"yes\"<<endl;\n        else\n            cout<<\"no\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nstruct sa\n{\n    char s[507];\n}qq[1007],q[1007],p[1007];\nbool cmp1(sa a,sa b)\n{\n    return strcmp(a.s,b.s)<0;\n}\nbool cmp2(sa a,sa b)\n{\n    return strcmp(a.s,b.s)>0;\n}\nint main()\n{\n    int n;\n    while(scanf(\"%d\",&n),n)\n    {\n          for(int i=0;i<n;i++)\n          {\n              scanf(\"%s\",p[i].s);\n              strcpy(q[i].s,p[i].s);\n              strcpy(qq[i].s,p[i].s);\n          }\n          sort(q,q+n,cmp1);\n          sort(qq,qq+n,cmp2);\n//          for(int i=0;i<n;i++)\n//          {\n//              printf(\"%s \",q[i].s);\n//          }\n//          printf(\"\\n\");\n//           for(int i=0;i<n;i++)\n//          {\n//              printf(\"%s \",qq[i].s);\n//          }\n//          printf(\"\\n\");\n          int flag=1;\n          for(int i=0;i<n;i++)\n            if(strcmp(q[i].s,p[i].s)!=0)\n            {\n                flag=0;\n                break;\n            }\n            if(flag){printf(\"yes\\n\");continue;}\n        flag=1;\n         for(int i=0;i<n;i++)\n            if(strcmp(qq[i].s,p[i].s)!=0)\n            {\n                flag=0;\n                break;\n            }\n            if(!flag)printf(\"no\\n\");\n            else\n            {\n                int flag2=0;\n                for(int i=0;i<n;i++)\n                {\n                    int len=strlen(p[i].s);\n                    for(int  j=i-1;j>=0;j--)\n                    {\n                        int flag1=0;\n                        for(int k=0;k<len;k++)\n                        {\n                            if(p[i].s[k]!=p[j].s[k])\n                            {\n                                flag1=1;\n                                break;\n                            }\n                        }\n                        if(flag1==0)\n                        {\n                            printf(\"no\\n\");\n                            flag2=1;\n                            break;\n                        }\n                    }\n                    if(flag2==1)\n                    break;\n                }\n                if(flag2==0)\n                printf(\"yes\\n\");\n            }\n    }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> edge[150];\nbool come[150];\nint dfs(int x){\n\tif(come[x])return -1;\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tif(dfs(edge[x][i]) == -1)return -1;\n\t}\n\tcome[x] = false;\n\treturn 0;\n}\n\nbool ok(){\n\tfor(int i = 'a';i <= 'z';i++){\n\t\tif(dfs(i) == -1)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tstring str, last;\n\twhile(cin >> n, n){\n\t\tbool fail = false;\n\t\tfor(int i = 'a';i <= 'z';i++)edge[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> str;\n\t\t\tif(i){\n\t\t\t\tfor(int i = 0;i < last.size();i++){\n\t\t\t\t\tif(i == str.size()){\n\t\t\t\t\t\tcout << \"no\" << endl;\n\t\t\t\t\t\tfail = true;\n\t\t\t\t\t\tbreak;\\\n\t\t\t\t\t}\n\t\t\t\t\tif(str[i] != last[i]){\n\t\t\t\t\t\tedge[last[i]].push_back(str[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = str;\n\t\t}\n\t\t\n\t\tcout << ((fail&&ok())?\"yes\":\"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> edge[150];\nbool come[150];\nint dfs(int x, int k, int p = 1){\n\tif(k == x && p != 0)return -1;\n\tif(come[x])return 0;\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tif(dfs(edge[x][i], k) == -1)return -1;\n\t}\n\treturn 0;\n}\n\nbool ok(){\n\tfor(int i = 'a';i <= 'z';i++){\n\t\tfill(come, come + 150, false);\n\t\tif(dfs(i, i, 0) == -1)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tstring str, last;\n\twhile(cin >> n, n){\n\t\n\t\tbool fail = false;\n\t\tfor(int i = 'a';i <= 'z';i++)edge[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> str;\n\t\t\tif(i){\n\t\t\t\tfor(int i = 0;i < last.size();i++){\n\t\t\t\t\tif(i == str.size()){\n\t\t\t\t\t\tfail = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[i] != last[i]){\n\t\t\t\t\t\tedge[last[i]].push_back(str[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = str;\n\t\t}\n\t\t\n\t\tcout << ((!fail&&ok())?\"yes\":\"no\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 文字に適切な順序を定めて、入力が辞書順になるようにできるか\n// 適当に辺を貼って閉路見つける\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring s[500];\nbool f[500][500];\nbool g[27][27];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tmemset(f, 0, sizeof(f));\n\t\tmemset(g, 0, sizeof(g));\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t\ts[i] += 'z' + 1;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= 10; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tfor (int k = j + 1; k < n; k++){\n\t\t\t\t\tif (f[j][k]) continue;\n\t\t\t\t\tif (i >= min(s[j].size(), s[k].size())) continue;\n\t\t\t\t\tif (s[j][i] != s[k][i]){\n\t\t\t\t\t\tcout << s[j][i] << s[k][i] << endl;\n\t\t\t\t\t\tg[s[j][i] - 'a'][s[k][i] - 'a'] = true;\n\t\t\t\t\t\tf[j][k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 27; k++){\n\t\t\tfor (int i = 0; i < 27; i++){\n\t\t\t\tfor (int j = 0; j < 27; j++){\n\t\t\t\t\tg[i][j] |= g[i][k] && g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool res = true;\n\t\tfor (int i = 0; i < 26; i++){\n\t\t\tif (g[i][i]) res = false;\n\t\t}\n\t\t\n\t\tcout << (res ? \"yes\" : \"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint main() {\n    int n;\n    while (cin >> n) {\n        vector<string> s1(n);\n        vector<string> s2(n);\n        int ma = 0;\n        REP(i, n) {\n            cin >> s1[i];\n            ma = max(ma, (int)s1[i].length());\n        }\n        s2 = s1;\n\n        map<char, char> m;\n        map<char, char> m2;\n        char c = 'A';\n        REP(i, ma) {\n            REP(j, n) {\n                if ((int)s1[j].length() > i) {\n                    char cc = s1[j][i];\n                    if (EXIST(m, cc)) {\n                        s2[j][i] = m[cc];\n                    } else {\n                        m[cc] = s2[j][i] = c;\n                        m2[c] = cc;\n                        c++;\n                    }\n                }\n            }\n        }\n\n        SORT(s2);\n        REP(i, n) {\n            REP(j, s2[i].length()) {\n                s2[i][j] = m2[s2[i][j]];\n            }\n        }\n\n        REP(i, n) {\n            if (s1[i] != s2[i]) {\n                cout << \"no\" << endl;\n                goto NEXT;\n            }\n        }\n        cout << \"yes\" << endl;\nNEXT: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2534.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 500;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nstring ss[MAX_N];\n\n/* subroutines */\n\nint cs[26][26];\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n\n    for (int i = 0; i < n; i++) cin >> ss[i];\n\n    memset(cs, 0, sizeof(cs));\n\n    bool ok = true;\n    for (int i = 0; ok && i < n; i++) {\n      for (int j = 0; ok && j < i; j++) {\n\tstring &si = ss[i], &sj = ss[j];\n\n\tint k = 0;\n\twhile (k < si.size() && k < sj.size() && si[k] == sj[k]) k++;\n\tif (k >= si.size()) ok = (k >= sj.size());\n\telse if (k < sj.size()) {\n\t  int ci = si[k] - 'a', cj = sj[k] - 'a';\n\t  if (cs[ci][cj] != 0) {\n\t    if (cs[ci][cj] < 0) ok = false;\n\t  }\n\t  else {\n\t    cs[ci][cj] = 1;\n\t    cs[cj][ci] = -1;\n\t  }\n\t}\n\t\n\t//printf(\"(%d,%d): \", i, j);\n\t//cout << si << ' ' << sj << ' ' << ok << endl;\n      }\n    }\n\n    cout << (ok ? \"yes\" : \"no\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 文字に適切な順序を定めて、入力が辞書順になるようにできるか\n// 適当に辺を貼って閉路見つける\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring s[500];\nbool f[500][500];\nbool g[27][27];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tmemset(f, 0, sizeof(f));\n\t\tmemset(g, 0, sizeof(g));\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t\ts[i] += 'z' + 1;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= 10; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tfor (int k = j + 1; k < n; k++){\n\t\t\t\t\tif (f[j][k]) continue;\n\t\t\t\t\tif (i >= min(s[j].size(), s[k].size())) continue;\n\t\t\t\t\tif (s[j][i] != s[k][i]){\n\t\t\t\t\t\tcout << s[j][i] << s[k][i] << endl;\n\t\t\t\t\t\tg[s[j][i] - 'a'][s[k][i] - 'a'] = true;\n\t\t\t\t\t\tf[j][k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 27; k++){\n\t\t\tfor (int i = 0; i < 27; i++){\n\t\t\t\tfor (int j = 0; j < 27; j++){\n\t\t\t\t\tg[i][j] |= g[i][k] && g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool res = true;\n\t\tfor (int i = 0; i < 27; i++){\n\t\t\tif (g[i][i]) res = false;\n\t\t}\n\t\t\n\t\tcout << (res ? \"yes\" : \"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> G[30];\nbool g[30];\n\nint d[30][30];\nconst int INF = 1e5;\n\n/*bool dfs(int now, int pre){\n\tif(g[now] == true) return false;\n\tbool res = true;\n\t//cout << now << endl;\n\tg[now] = true;\n\tset<int> st;\n\tfor(int i = 0; i < G[now].size(); i++){\n\t\tint next = G[now][i];\n\t\t//if(next == pre) continue;\n\t\tif(st.count(next)) continue;\n\t\tst.insert(next);\n\t\tres &= dfs(next, now);\n\t}\n\treturn res;\n}*/\n\nvoid wf(){\n\tfor(int k = 0; k < 26; k++){\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tG[i].clear();\n\t\t\tfor(int j = 0; j < 26; j++) d[i][j] = INF;\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tvector<string> s(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tbool f = true;\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\t\tif(s[i + 1].size() == j){\n\t\t\t\t\tf = false; break;\n\t\t\t\t}\n\t\t\t\tif(s[i][j] != s[i + \t1][j]){\n\t\t\t\t\tG[s[i][j] - 'a'].push_back(s[i + 1][j] - 'a');\n\t\t\t\t\t//cout << s[i][j] << \"->\" << s[i + 1][j] << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\td[i][G[i][j]] = -1;\n\t\t\t}\n\t\t}\n\t\twf();\n\t\t//int e[26][26] = {};\n\t\t//for(int i = 0; i < 26; i++) for(int j = 0; j < 26; j++) e[i][j] = d[i][j];\n\t\t//wf();\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\t//cout << d[i][i] << endl;\n\t\t\tif(d[i][i] != 0) f = false;\n\t\t\t//for(int j = 0; j < 26; j++){\n\t\t\t//\tif(d[i][j] != e[i][j]) f = false;\n\t\t\t//}\n\t\t}\n\t\t/*for(int j = 0; j < 26; j++){\n\t\t//cout << j << \" \" << f << endl;\n\t\t\tfor(int i = 0; i < 26; i++) g[i] = false;\n\t\t\tf &=  dfs(j, -1);\n\t\t}*/\n\t\tif(f) cout << \"yes\" << endl;\t\n\t\telse cout << \"no\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,used[1<<7],ans;\nstring str[501];\nvector <int> mp[1<<7];\n\nvoid mk_mp(int pos,int i,int j){\n  int ni=-1,ch=str[i][pos];\n  while(i!=j){\n    int a=str[++i][pos];\n    if(ch==a&&ni==-1)ni=i-1;\n    if(ch==a&&ni==-2)ans=0;\n    if(ch==a&&str[i-1].size()>str[i].size())ans=0;\n    if(ch!=a&&ni>=0)mk_mp(pos+1,ni,i-1),ni=-2;\n    if(ch!=a) mk_mp(pos,i,j),mp[ch].push_back(a);\n  }\n\n}\n\nbool check(int pos){\n  if(used[pos]||!ans) return 0;\n  used[pos]=1;\n  int res=1,s=mp[pos].size();\n  for(int i=0;i<s;i++)\n    if(i==s-1||mp[pos][i]!=mp[pos][i+1])res*=check(mp[pos][i]);\n  //used[pos]=0;\n  return res;\n}\n\nint main(){\n\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i='a';i<='z';i++) mp[i].clear();\n    for(int i=0;i<n;i++)cin>>str[i];\n    ans=1;\n    mk_mp(0,0,n-1);\n    \n    for(int i='a';i<='z';i++) {\n      memset(used,0,sizeof(used));    \n      ans*=check(i);\n    }\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    \n    vector<string>v(n);\n    rep(i,n)cin >> v[i];\n\n    map<char,int>od;\n    bool fg=true;\n    int cnt=0;\n    for(int i=0;i<n;i++){\n      if(od.count(v[i][0])&& od[v[i][0]]!=cnt)fg=false;\n      if(!od.count(v[i][0]))od[v[i][0]]=++cnt;\n    }\n    \n    for(int i=1;i<10;i++){\n      for(int j=0;j+1<n;j++){\n\tif(v[j].substr(0,i)==v[j+1].substr(0,i)){\n\t  if(v[j+1].substr(i,max(0,(int)v[j+1].size()-i)).size()==0)fg=false;\n\t  if(od[v[j][i]]==0)od[v[j][i]]=++cnt;\n\t  if(od[v[j+1][i]]==0)od[v[j+1][i]]=++cnt;\n\t  if(od[v[j][i]]>od[v[j+1][i]])fg=false;\n\t}\n      }\n    }\n\n    cout << (fg?\"yes\":\"no\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing std::queue;\n\nconst int N = 500 + 10;\n\nint n;\nchar s[N][20];\nint g[255][255];\nint deg[255];\nqueue<int> Q;\n\nbool topsort()\n{\n\twhile(!Q.empty()) Q.pop();\n\tfor(int i = 0; i < 255; i++) if(deg[i] == 0) Q.push(i);\n\tint cnt = 0;\n\twhile(!Q.empty())\n\t{\n\t\tint x = Q.front(); Q.pop(); cnt++;\n\t\tfor(int i = 0; i < 255; i++)\n\t\t\tif(g[x][i] == 1)\n\t\t\t{\n\t\t\t\tdeg[i]--;\n\t\t\t\tif(deg[i] == 0) Q.push(i);\n\t\t\t}\n\t}\n\t//printf(\"cnt = %d\\n\", cnt);\n\treturn cnt == 255;\n}\n\nbool solve()\n{\n\tmemset(g, 0, sizeof(g));\n\tmemset(deg, 0, sizeof(deg));\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tfor(int j = 0; s[i][j] || s[i-1][j]; j++)\n\t\t{\n\t\t\tif(s[i][j] == s[i-1][j]) continue;\n\t\t\tif(!s[i][j]) return 0;\n\t\t\tchar lesser = s[i-1][j], larger = s[i][j];\n\t\t\tif(g[larger][lesser] == 1) return 0;\n\t\t\tif(g[lesser][larger] == 0)\n\t\t\t{\n\t\t\t\tg[lesser][larger] = 1;\n\t\t\t\tdeg[larger]++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn topsort();\n}\n\nint main()\n{\n\twhile(scanf(\"%d\", &n) == 1 && n)\n\t{\n\t\tmemset(s, 0, sizeof(s));\n\t\tfor(int i = 1; i <= n; i++) scanf(\"%s\", s[i]);\n\t\tif(solve()) puts(\"yes\"); else puts(\"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\nusing namespace std;\nconst char sentinel = 'z' + 1;\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<string> s(n);\n        repeat (i,n) {\n            cin >> s[i];\n            s[i] += sentinel;\n        }\n        array<array<bool, 27>, 27> lt = {};\n        repeat (i,26) lt[26][i] = true;\n        repeat (j,n) repeat (i,j) {\n            auto it = mismatch(s[i].begin(), s[i].end(), s[j].begin(), s[j].end());\n            auto p = it.first;\n            auto q = it.second;\n            if (p == s[i].end()) {\n                assert (q == s[j].end());\n            } else {\n                lt[*p - 'a'][*q - 'a'] = true;\n            }\n        }\n        bool has_cycle = false;\n        array<bool, 27> used = {};\n        function<void (int)> dfs = [&](int i) {\n            if (used[i]) {\n                has_cycle = true;\n                return;\n            }\n            used[i] = true;\n            repeat (j, 27) if (lt[i][j]) {\n                dfs(j);\n                if (has_cycle) break;\n            }\n            used[i] = false;\n        };\n        repeat (i, 27) {\n            dfs(i);\n            if (has_cycle) break;\n        }\n        cout << (has_cycle ? \"no\" : \"yes\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nconst char premark = 'a' - 1;\n\nbool dfs(map<char, vector<char>>& G, vector<bool>& vis, char c) {\n  for(auto& next: G[c]) {\n    if(vis[next-'a']) return false;\n    vis[next-'a'] = 1;\n    if(!dfs(G, vis, next)) return false;\n    vis[next-'a'] = 0;\n  }\n  return true;\n}\n\nvoid NG() {\n  cout << \"no\" << endl;\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    vector<string> v;\n    int L = 1;\n    rep(i, N) {\n      string s; cin >> s;\n      v.push_back(s);\n      maximize(L, s.size());\n    }\n    rep(i, N) {\n      v[i].resize(L, premark);\n    }\n\n    map<char, vector<char>> G;\n    vector<bool> vis;\n\n    rep(i, N-1) {\n      REP(ni, i+1, N) {\n        rep(j, L) {\n          if(v[i][j] == v[ni][j] && v[i][j] == premark) break;\n          if(v[i][j] == premark) break;\n          if(v[ni][j] == premark) { NG(); goto ex; }\n          if(v[i][j] == v[ni][j]) continue;\n          G[v[i][j]].push_back(v[ni][j]);\n          break;\n        }\n      }\n    }\n\n    REP(c, 'a','z'+1) if(!G[c].empty()) {\n      sort(all(G[c]));\n      G[c].erase(unique(all(G[c])), G[c].end());\n    }\n\n    REP(c, 'a','z'+1) {\n      vis.clear(); vis.resize(26);\n      vis[c-'a'] = 1;\n      if(!dfs(G, vis, c)) { NG(); goto ex; }\n    }\n\n    cout << \"yes\" << endl;\n    ex:;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\nstruct Dscc {\npublic:\n\n\t//belongs,newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs2(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n\n}dscc;\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<string>sts;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tsts.push_back(st);\n\t\t}\n\t\tbool ok = true;\n\t\tvector<vector<int>>edges(26);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tstring from = sts[i];\n\t\t\tstring to = sts[i + 1];\n\t\t\t\n\t\t\tif (to.find(from) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(from.find(to)==0){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint num = 0;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (from[num] == to[num]) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tedges[from[num] - 'a'].push_back(to[num] - 'a');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tauto pa=dscc.get(edges);\n\t\t\tif (pa.first.size() == 26) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tcout << \"yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,used[1<<7],ans;\nstring str[501];\nvector <int> mp[1<<7];\n\nvoid mk_mp(int pos,int i,int j){\n  int ni=-1,ch=str[i][pos];\n  while(i!=j){\n    int a=str[++i][pos];\n    if(ch==a&&ni==-1)ni=i-1;\n    if(ch==a&&ni==-2)ans=0;\n    if(ch==a&&str[i-1].size()>str[i].size())ans=0;\n    if(ch!=a&&ni>=0)mk_mp(pos+1,ni,i-1),ni=-2;\n    if(ch!=a) mk_mp(pos,i,j),mp[ch].push_back(a);\n  }\n\n}\n\nbool check(int pos){\n  if(used[pos]) return 0;\n  used[pos]=1;\n  int res=1,s=mp[pos].size();\n  for(int i=0;i<s;i++)\n    if(i==s-1||mp[pos][i]!=mp[pos][i+1])res*=check(mp[pos][i]);\n  used[pos]=0;\n  return res;\n}\n\nint main(){\n\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i='a';i<='z';i++) mp[i].clear();\n    for(int i=0;i<n;i++)cin>>str[i];\n    ans=1;\n    mk_mp(0,0,n-1);\n    memset(used,0,sizeof(used));    \n    for(int i='a';i<='z';i++) ans*=check(i);\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,used[1<<7],ans;\nstring str[501];\nvector <int> mp[1<<7];\n\nvoid mk_mp(int pos,int i,int j){\n  int ni=-1,ch=str[i][pos];\n  while(i!=j){\n    int a=str[++i][pos];\n    if(ch==a&&ni==-1)ni=i-1;\n    if(ch==a&&ni==-2)ans=0;\n    if(ch==a&&str[i-1].size()>str[i].size())ans=0;\n    if(ch!=a&&ni>=0)mk_mp(pos+1,ni,i-1),ni=-2;\n    if(ch!=a) mk_mp(pos,i,j),mp[ch].push_back(a);\n  }\n\n}\n\nbool check(int pos){\n  if(used[pos]||!ans) return 0;\n  used[pos]=1;\n  int res=1,s=mp[pos].size();\n  for(int i=0;i<s;i++)\n    if(i==s-1||mp[pos][i]!=mp[pos][i+1])res*=check(mp[pos][i]);\n  used[pos]=0;\n  return res;\n}\n\nint main(){\n\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i='a';i<='z';i++) mp[i].clear();\n    for(int i=0;i<n;i++)cin>>str[i];\n    ans=1;\n    mk_mp(0,0,n-1);\n    long long sum=1;\n    for(int i='a';i<='z';i++) if(mp[i].size())sum*=mp[i].size();assert((1e6)>sum);\n    memset(used,0,sizeof(used)); \n    for(int i='a';i<='z';i++) ans*=check(i);\n    cout <<(ans? \"yes\":\"no\")<<endl;\n   }\n   return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\n  typedef vector<int> Vector;\n  typedef vector<Vector> Matrix;\n  typedef queue<int> IntQueue;\n  public:\n    Graph(int size): size_(size), next_(size) {\n    }\n    void add_edge(int a, int b) {\n      next_[a].push_back(b);\n    }\n    bool exists_path(int a, int b) {\n      vector<bool> has_visited(size_, false);\n      IntQueue q;\n      q.push(a);\n      has_visited[a] = true;\n      while (not q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (size_t i = 0; i < next_[x].size(); ++i) {\n          int y = next_[x][i];\n          if (not has_visited[y]) {\n            if (y == b) {\n              return true;\n            }\n            has_visited[y] = true;\n            q.push(y);\n          }\n        }\n      }\n      return false;\n    }\n  private:\n    int size_;\n    Matrix next_;\n};\n\nbool solve(int n, string s[]) {\n  Graph g(26);\n  for (int i = 0; i < n - 1; ++i) {\n    size_t pos = 0;\n    while (s[i][pos] == s[i + 1][pos]) {\n      ++pos;\n    }\n    if (pos == s[i].length()) {\n      continue;\n    } else if (pos == s[i + 1].length()) {\n      return false;\n    }\n    g.add_edge(s[i][pos] - 'a', s[i + 1][pos] - 'a');\n    for (int i = 0; i < 26; ++i) {\n      for (int j = i + 1; j < 26; ++j) {\n        if (g.exists_path(i, j) and g.exists_path(j, i)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  string s[500];\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      return 0;\n    }\n    for (int i = 0; i < n; ++i) {\n      cin >> s[i];\n    }\n    if (solve(n, s)) {\n      cout << \"yes\" << endl;\n    } else {\n      cout << \"no\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nbool solve(void){\n\tint n,i,j;cin>>n;\n\tif(n==0){return false;}\n\tstring mae=\"#\";\n\tbool dame=false;\n\tint zyun[26][26]={};\n\tint zi[26]={};\n\tfor(i=0;i<n;i++){\n\t\t\n\t\tstring now;cin>>now;\n\t\tnow.pub('#');\n\t\tj=0;\n\t\twhile(mae[j]!='#'&&mae[j]==now[j]){j++;}\n\t\tif(mae[j]=='#'){mae=now;continue;}\n\t\tif(now[j]=='#'){dame=true;}\n\t\tzyun[mae[j]-'a'][now[j]-'a']=1;\n\t\t\n\t\t\n\t\tmae=now;\n\t\t\n\t}\n\tfor(i=0;i<26;i++){\n\t\tfor(j=0;j<26;j++){\n\t\t\tif(zyun[i][j]){zi[j]++;}\n\t\t}\n\t}\n\tif(dame){cout<<\"no\"<<endl;return true;}\n\tqueue<int>que;\n\tfor(i=0;i<26;i++){\n\t\tif(zi[i]==0){que.push(i);}\n\t}\n\twhile(que.size()){\n\t\tint t=que.front();que.pop();\n\t\tfor(j=0;j<26;j++){\n\t\t\tif(zyun[t][j]){\n\t\t\t\t\n\t\t\t\tzi[j]--;\n\t\t\t\tif(zi[j]==0){que.push(j);}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<26;i++){\n\t\tif(zi[i]>0){cout<<\"no\"<<endl;return true;}\n\t}\n\tcout<<\"yes\"<<endl;\n\treturn true;\n}\n\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> edge[150];\nbool come[150];\nint dfs(int x){\n\tif(come[x])return -1;\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tif(dfs(edge[x][i]) == -1)return -1;\n\t}\n\tcome[x] = false;\n\treturn 0;\n}\n\nbool ok(){\n\tfor(int i = 'a';i <= 'z';i++){\n\t\tif(dfs(i) == -1)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tstring str, last;\n\twhile(cin >> n, n){\n\t\tfor(int i = 'a';i <= 'z';i++)edge[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> str;\n\t\t\tif(i){\n\t\t\t\tfor(int i = 0;i < last.size();i++){\n\t\t\t\t\tif(i == str.size()){\n\t\t\t\t\t\tcout << \"no\" << endl;\n\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[i] != last[i]){\n\t\t\t\t\t\tedge[last[i]].push_back(str[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = str;\n\t\t}\n\t\tcout << (ok()?\"yes\":\"no\") << endl;\nfail:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nchar premark = 'a' - 1;\n\nbool dfs(map<char, vector<char>>& G, vector<bool>& vis, char c, set<char>& st) {\n  for(auto& next: G[c]) {\n    if(st.count(next)) return false;\n    st.insert(next);\n    if(vis[next-'a']) continue;\n    vis[next-'a'] = 1;\n    if(!dfs(G, vis, next, st)) return false;\n    st.erase(next);\n  }\n  return true;\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    vector<string> v;\n    int L = 1;\n    rep(i, N) {\n      string s; cin >> s;\n      v.push_back(s);\n      maximize(L, s.size());\n    }\n    rep(i, N) {\n      v[i].resize(L, premark);\n    }\n\n    map<char, vector<char>> G;\n    vector<bool> vis(26);\n    bool oks[26] = {};\n    vector<char> starts;\n\n    rep(i, N-1) {\n      REP(ni, i+1, N) {\n        rep(j, L) {\n          if(v[i][j] == v[ni][j] && v[i][j] == premark) break;\n          if(v[i][j] == v[ni][j]) continue;\n          if(v[i][j] == premark) break;\n          if(v[ni][j] == premark) goto ng;\n          G[v[i][j]].push_back(v[ni][j]);\n          break;\n        }\n      }\n    }\n\n    rep(i, 26) if(!G['a'+i].empty()) {\n      sort(all(G['a'+i]));\n      G['a'+i].erase(unique(all(G['a'+i])), G['a'+i].end());\n    }\n\n    rep(i, 26) {\n      for(auto k: G[i+'a']) if(k) {\n        oks[k-'a'] = 1;\n      }\n    }\n\n\n    rep(i, 26)\n      if(!oks[i]) starts.push_back(i + 'a');\n\n    for(auto s: starts) {\n      vis[s-'a'] = 1;\n      set<char> st;\n      if(!dfs(G, vis, s, st)) goto ng;\n    }\n\n    cout << \"yes\" << endl;\n    continue;\n\n    ng:;\n    cout << \"no\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\n  typedef vector<int> Vector;\n  typedef vector<Vector> Matrix;\n  typedef queue<int> IntQueue;\n  public:\n    Graph(int size): size_(size), next_(size) {\n    }\n    void add_edge(int a, int b) {\n      next_[a].push_back(b);\n    }\n    bool exists_path(int a, int b) {\n      vector<bool> has_visited(size_, false);\n      IntQueue q;\n      q.push(a);\n      has_visited[a] = true;\n      while (not q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (size_t i = 0; i < next_[x].size(); ++i) {\n          int y = next_[x][i];\n          if (not has_visited[y]) {\n            if (y == b) {\n              return true;\n            }\n            has_visited[y] = true;\n            q.push(y);\n          }\n        }\n      }\n      return false;\n    }\n  private:\n    int size_;\n    Matrix next_;\n};\n\nbool solve(int n, string s[]) {\n  Graph g(26);\n  for (int i = 0; i < n - 1; ++i) {\n    size_t pos = 0;\n    while (s[i][pos] == s[i + 1][pos]) {\n      ++pos;\n    }\n    if (pos == s[i + 1].length()) {\n      if (pos == s[i].length()) {\n        continue;\n      }\n      return false;\n    }\n    g.add_edge(s[i][pos] - 'a', s[i + 1][pos] - 'a');\n    for (int i = 0; i < 26; ++i) {\n      for (int j = i + 1; j < 26; ++j) {\n        if (g.exists_path(i, j) and g.exists_path(j, i)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  string s[500];\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      return 0;\n    }\n    for (int i = 0; i < n; ++i) {\n      cin >> s[i];\n    }\n    if (solve(n, s)) {\n      cout << \"yes\" << endl;\n    } else {\n      cout << \"no\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\nstring s[500];\nbool g[26][26];\nint h[26];\n\nbool cycle(int i){\n\th[i] = 1;\n\trep(j, 26){\n\t\tif(!g[i][j]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(h[j] == 0 && cycle(j) || h[j] == 1){\n\t\t\treturn true;\n\t\t}\n\t}\n\th[i] = 2;\n\treturn false;\n}\n\nbool solve(){\n\trep(i, n - 1){\n\t\tint p = s[i].size();\n\t\tint q = s[i + 1].size();\n\n\t\tbool same = true;\n\t\trep(j, min(p, q)){\n\t\t\tchar k = s[i][j];\n\t\t\tchar l = s[i + 1][j];\n\t\t\tif(k != l){\n\t\t\t\tsame = false;\n\t\t\t\tg[k - 'a'][l - 'a'] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(same && p > q){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn !cycle(0);\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n){\n\t\t\tcin >> s[i];\n\t\t}\n\n\t\tcout << (solve() ? \"yes\" : \"no\") << endl;\n\t\t\n\t\trep(i, 26){\n\t\t\tfill_n(g[i], 26, false);\n\t\t}\n\t\tfill_n(h, 26, 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool f;\nbool e[26][26];\nvoid dfs(int x,int d){\n  //cout << x << \":\" << d << endl;\n  if(d>26) {\n    f=false;\n    return;\n  }\n  if(!f) return;\n  for(int i=0;i<26;i++){\n    if(e[x][i]) dfs(i,d+1);\n  }\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    int i,j,k;\n    vector<string> v;\n    string s;\n    memset(e,false,sizeof(e));\n    for(i=0;i<n;i++){\n      cin >> s;\n      v.push_back(s);\n    }\n    f=true;\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n\tif(v[i].find(v[j])==0&&v[i].size()>v[j].size()) f=false;\n\tint x=min(v[i].size(),v[j].size());\n\tfor(k=0;k<x;k++){\n\t  if(v[i][k]==v[j][k]) continue;\n\t  e[v[i][k]-'a'][v[j][k]-'a']=true;\n\t  break;\n\t}\n      }\n    }\n    for(i=0;i<26;i++){\n      if(f)dfs(i,0);\n    }\n    if(f) cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nbool solve(int N){\n\tstring s_[500];\n\trep(i,N) cin>>s_[i];\n\tbool e[26][26]={};\n\trep(i,N-1){\n\t\tstring s=s_[i],t=s_[i+1];\n\t\tint S=s.size(),T=t.size();\n\t\tint j=0;\n\t\twhile(j<S&&j<T&&s[j]==t[j]) j++;\n\t\tif(j==S) continue;\n\t\tif(j==T) return 0;\n\t\te[s[j]-'a'][t[j]-'a']=1;\n\t}\n\trep(i,26) rep(j,26) rep(k,26) if(e[j][i]&&e[i][k]) e[j][k]=1;\n\trep(i,26) if(e[i][i]) return 0;\n\treturn 1;\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tif(solve(N)) puts(\"yes\");\n\t\telse puts(\"no\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n\n\ntypedef long long ll;\n\nint main(){\n  int n;\n  char s[256][256];\n  while(~scanf(\"%d\", &n) && n){\n        rep(i, n) scanf(\"%s\", s[i]);\n        set<char> st[256];\n        bool ans = true;\n        rep(i, n){\n          REP(j, i+1, n){\n                bool f = true;\n                int li = strlen(s[i]), lj = strlen(s[j]);\n                int l = min(li, lj);\n                rep(k, l){\n                  if(s[i][k] != s[j][k]){\n                        f =false;\n                        if(st[s[j][k]].count(s[i][k])){\n                          ans = false;\n                          break;\n                        }\n                        st[s[i][k]].insert(s[j][k]);\n                        break;\n                  }\n                }\n                if(f && li > lj) ans = false;\n          }\n        }\n        printf(\"%s\\n\", (ans?\"yes\" : \"no\"));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#define rep(i,a,n) for(int i=a; i<n; i++)\nusing namespace std;\n\n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename T>\nvector<int> tpsort_Kahn(const vector< vector< Edge<T> > > &g) {\n    const int V = g.size();\n    vector<int> indeg(V, 0);\n    stack<int> S;\n\n    rep(i,0,V) rep(j,0,g[i].size())\n        indeg[ g[i][j].to ]++;\n    rep(i,0,V) if(indeg[i] == 0) S.push(i);\n\n    vector<int> ans;\n    while(S.size() > 0) {\n        int u = S.top(); S.pop();\n        ans.push_back(u);\n        rep(i,0,g[u].size()) {\n            indeg[ g[u][i].to ]--;\n            if(indeg[ g[u][i].to ] ==  0)\n                S.push( g[u][i].to );\n        }\n    }\n    return ans;\n}\n\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        vector<string> vs(N);\n        for(int i=0; i<N; i++) {\n            cin >> vs[i];\n        }\n\n        bool ok = true;\n        Graph<int> G(26);\n        for(int i=0; i<N; i++) {\n            for(int j=i+1; j<N; j++) {\n                int S = min(vs[i].length(), vs[j].length());\n                bool differ = false;\n                for(int k=0; k<S; k++) {\n                    if(vs[i][k] != vs[j][k]) {\n                        differ = true;\n                        int u = vs[i][k] - 'a', v = vs[j][k] - 'a';\n                        G[u].push_back(Edge<int>(v, 1));\n                        break;\n                    }\n                }\n                if(!differ && vs[i].length() > vs[j].length()) ok = false;\n            }\n        }\n        \n        if(tpsort_Kahn(G).size() == 26 && ok) cout << \"yes\" << endl;\n        else cout << \"no\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint g[30][30];\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> s(n);\n    for(int i=0;i<n;i++)cin >> s[i];\n\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++){\n\t  g[i][j] = 1e9;\n      }\n      g[i][i] = 0;\n    }\n\n    bool f = true;\n    for(int i=1;i<n;i++){\n      int len = min(s[i-1].size(), s[i].size()), j;\n      for(j=0;j<len;j++){\n\tif(s[i-1][j]!=s[i][j])break;\n      }\n\n      if(j==len){\n\tif(s[i-1].size() > s[i].size()){\n\t  f = false;\n\t}\n      }else{\n\tg[s[i-1][j]-'a'][s[i][j]-'a'] = -1;\n      }\n    }\n\n    for(int k=0;k<26;k++){\n      for(int i=0;i<26;i++){\n\tfor(int j=0;j<26;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    for(int i=0;i<26;i++){\n      if(g[i][i] < 0) f = false;\n    }\n\n    cout << (f?\"yes\":\"no\") << endl;\n  }   \n}\n#include<bits/stdc++.h>\nusing namespace std;\n\nint g[30][30];\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> s(n);\n    for(int i=0;i<n;i++)cin >> s[i];\n\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++){\n\t  g[i][j] = 1e9;\n      }\n      g[i][i] = 0;\n    }\n\n    bool f = true;\n    for(int i=1;i<n;i++){\n      int len = min(s[i-1].size(), s[i].size()), j;\n      for(j=0;j<len;j++){\n\tif(s[i-1][j]!=s[i][j])break;\n      }\n\n      if(j==len){\n\tif(s[i-1].size() > s[i].size()){\n\t  f = false;\n\t}\n      }else{\n\tg[s[i-1][j]-'a'][s[i][j]-'a'] = -1;\n      }\n    }\n\n    for(int k=0;k<26;k++){\n      for(int i=0;i<26;i++){\n\tfor(int j=0;j<26;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    for(int i=0;i<26;i++){\n      if(g[i][i] < 0) f = false;\n    }\n\n    cout << (f?\"yes\":\"no\") << endl;\n  }   \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<ll, ll> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vi> g(27);\n\t\tvs v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\twhile (s.size() < 10) s += 'z' + 1;\n\t\t\tv.push_back(s);\n\t\t}\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tstring u = v[i], d = v[j];\n\t\t\tint t = 0;\n\t\t\twhile (u[t] == d[t]&&t<10) t++;\n\t\t\tif (t == 10) continue;\n\t\t\tint un = u[t] - 'a', dn = d[t] - 'a';\n\t\t\tif (un != dn) g[un].push_back(dn);\n\t\t}\n\t\tbool f = true;\n\t\tif (g[26].size() > 0) f = false;\n\t\tREP(i, 26)\n\t\t{\n\t\t\tsort(ALL(g[i]));\n\t\t\tg[i].erase(unique(ALL(g[i])), g[i].end());\n\t\t}\n\t\tvector<bool> vis(26);\n\t\tREP(i, 26)\n\t\t{\n\t\t\tstack<int> st;\n\t\t\tst.push(i);\n\t\t\twhile (st.size())\n\t\t\t{\n\t\t\t\tint tmp = st.top();\n\t\t\t\tst.pop();\n\t\t\t\tREP(j, g[tmp].size())\n\t\t\t\t{\n\t\t\t\t\tif (g[tmp][j] == i)\n\t\t\t\t\t{\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tst.push(g[tmp][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tend:;\n\t\tputs(f ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 500\n\nint main(){\n  int n;\n  string str;\n\n  while(cin >> n, n){\n    map<char,char> bef, aft;\n\n    cin >> str;\n    for(int i = 0 ; i < (int)str.size() ; i++){\n      bef[str[i]] = i + 'a';\n      aft[i + 'a'] = str[i];\n    }\n\n    string s[MAX], t[MAX];\n    for(int i = 0 ; i < n-1 ; i++){\n      cin >> s[i];\n      string change;\n      for(int j = 0 ; j < (int)s[i].size() ; j++){\n\tchange += bef[s[i][j]];\n      }\n      t[i] = change;\n    }\n\n    bool flg = true;\n\n    sort(t,t+n-1);\n    for(int i = 0 ; i < n-1 ; i++){\n      string change;\n      for(int j = 0 ; j < (int)t[i].size() ; j++){\n\tchange += aft[t[i][j]];\n      }\n      if(change != s[i]){\n\tflg = false;\n\tbreak;\n      }\n    }\n\n    if(flg){\n      cout << \"yes\" << endl;\n    }else{\n      cout << \"no\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,used[1<<7],ans;\nstring str[501];\nvector <int> mp[1<<7];\n\nvoid mk_mp(int pos,int i,int j){\n  int ni=-1,ch=str[i][pos];\n  while(i!=j){\n    int a=str[++i][pos];\n    if(ch==a&&ni==-1)ni=i-1;\n    if(ch==a&&ni==-2)ans=0;\n    if(ch==a&&str[i-1].size()>str[i].size())ans=0;\n    if(ch!=a&&ni>=0)mk_mp(pos+1,ni,i-1),ni=-2;\n    if(ch!=a){\n      mk_mp(pos,i,j);\n      mp[ch].push_back(a);\n      mp[ch].insert(mp[ch].end(),mp[a].begin(),mp[a].end());\n      return;\n    }\n  }\n\n}\n\nbool check(int pos){\n  if(used[pos]||!ans) return 0;\n  used[pos]=1;\n  int res=1,s=mp[pos].size();\n  for(int i=0;i<s;i++)\n    if(i==s-1||mp[pos][i]!=mp[pos][i+1])res*=check(mp[pos][i]);\n  used[pos]=0;\n  return res;\n}\n\nint main(){\n\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i='a';i<='z';i++) mp[i].clear();\n    for(int i=0;i<n;i++)cin>>str[i];\n    ans=1;\n    mk_mp(0,0,n-1);\n    memset(used,0,sizeof(used)); \n    for(int i='a';i<='z';i++) {\n      sort(mp[i].begin(),mp[i].end());\n      ans*=check(i);\n    }\n\n    cout <<(ans? \"yes\":\"no\")<<endl;\n   }\n   return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nusing graph = vector<vector<int>>;\n \nvoid dfs(int v, const graph& G, vector<int>& res, vector<int>& used) {\n    used[v] = 1;\n    for (auto to : G[v]) if (used[to] == 0) {\n        dfs(to, G, res, used);\n    }\n    res.push_back(v);\n    //cout<<v<<endl;\n}\n \nvector<int> topo_sort(const graph& G) {\n    int V = G.size();\n    vector<int> ide(V);\n    for (int i = 0; i < V; i++) {\n        for (auto to : G[i]) {\n            //cout<<to<<endl;\n            ide[to]++;\n        }\n    }\n    vector<int> res;\n    vector<int> used(V);\n    for (int i = V - 1; i >= 0; i--) {\n        if (ide[i] == 0) {\n            //cout<<i<<endl;\n            dfs(i, G, res, used);\n        }\n    }\n    if(res.size()==0) res={-1};\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        for(int i=0;i<n;i++) cin>>s[i];\n        graph g(26);\n        for(int i=1;i<n;i++){\n            int len=min(s[i-1].length(),s[i].length());\n            for(int j=0;j<len;j++){\n                if(s[i-1][j]==s[i][j]) continue;\n                int st=s[i-1][j]-'a',gt=s[i][j]-'a';\n                g[st].push_back(gt);\n                break;\n            }\n        }\n        vector<int> res=topo_sort(g);\n        //cout<<res.size()<<endl;\n        if(res.size()!=26){\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        for(int i=0;i<n;i++){\n            int len=s[i].length();\n            for(int j=0;j<len;j++){\n                int idx=s[i][j]-'a';\n                idx=res[idx];\n                s[i][j]='a'+idx;\n            }\n        }\n        bool f=true;\n        for(int i=1;i<n;i++){\n            if(s[i-1]>s[i]) f=false;\n        }\n        if(f) cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N ('z'-'a')\nusing namespace std;\nint n,ans,mp[N+1];\nstring str[501];\n\nvoid mk_mp(int pos,int i,int j){\n  while(i<=j&&pos>=str[i].size())i++;\n  if(i>=j)return;\n  int ni=i,ch=str[i][pos]-'a';\n\n  while(i<j){\n    int a=str[++i][pos]-'a',f=ch==a;\n    if((f&&!ni<0)||(f&&str[i-1].size()>str[i].size()&&!str[i][pos+1]))ans=0;\n\n    if(!f){\n      mk_mp(pos+1,ni,i-1);\n      mk_mp(pos,i,j);\n      mp[ch]|=(1<<a|mp[a]);\n      return ;\n    }\n  }\n  if(ni>=0) mk_mp(pos+1,ni,j);\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>str[i];\n    ans=1;\n    mk_mp(0,0,n-1);\n    for(int i=0;i<=N;mp[i]=0,i++) ans*=!(mp[i]&1<<i);\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool solve(int n)\n{\n  string str[505];\n  for(int i = 0; i < n; i++) cin >> str[i];\n\n  bool G[33][33] = {{false}};\n  for(int i = 0; i < n-1; i++) {\n    bool flag = (str[i].size() <= str[i+1].size());\n    for(int j = 0; j < min(str[i].size(), str[i+1].size()); j++) {\n      if(str[i][j] != str[i+1][j]) {\n\tG[str[i][j]-'a'][str[i+1][j]-'a'] = true;\n\tflag = true;\n\tbreak;\n      }\n    }\n    if(!flag) return true;\n  }\n  \n  for(int i = 0; i < 26; i++) {\n    for(int j = 0; j < 26; j++) {\n      for(int k = 0; k < 26; k++) {\n\tG[j][k] |= G[j][i] & G[i][k];\n      }\n    }\n  }\n  \n  bool ans = false;\n  for(int i = 0; i < 26; i++) ans |= G[i][i];\n\n  return ans;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n, n) {\n    cout << (solve(n) ? \"no\" : \"yes\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nbool isPrefix(const string& a, const string &b){\n    if(a.size() <= b.size()){\n        rep(i, a.size()){\n            if(a[i] == b[i]) continue;\n            else return false;\n        }\n    } else {\n        return false;\n    }\n    return true;\n}\n\nbool solve(int n){\n    vector<string> v(n);\n    int G[26][26] = {};\n    rep(i, n) cin >> v[i];\n    loop(i, 1, n){\n        if(isPrefix(v[i - 1], v[i])){\n            continue;\n        } else if(isPrefix(v[i], v[i - 1])){\n            return false;\n        } else {\n            rep(j, min(v[i].size(), v[i - 1].size())){\n                char a = v[i][j], b = v[i - 1][j];\n                if(a == b){\n                    continue;\n                } else {\n                    G[a - 'a'][b - 'a'] = true;\n                    break;\n                }\n            }\n        }\n    }\n    rep(k, 26) rep(i, 26) rep(j, 26){\n        G[i][j] |= G[i][k] && G[k][j];\n    }\n    \n    rep(i, 26){\n        if(G[i][i])\treturn false;\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        if(solve(n)){\n            cout << \"yes\";\n        } else {\n            cout << \"no\";\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nstring S[555];\nvector<int> G[27];\nvector<int> rG[27];\nbool used[27];\n\nvoid dfs(int v,vector<int>& vs){\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    if( used[G[v][i]] ) continue;\n    dfs( G[v][i] , vs );\n  }\n  vs.push_back( v );\n  return ;\n}\nvoid rdfs(int v,int t){\n  used[v] = true;\n  for(int i=0;i<(int)rG[v].size();i++){\n    if( used[rG[v][i]] ) continue;\n    rdfs( rG[v][i], t );\n  }  \n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vector<int> vs;\n  for(int i=0;i<26;i++)\n    if( !used[i] ) dfs(i,vs);\n  memset(used,0,sizeof(used));\n  int t=0;\n  for(int i=25;i>-1;i--)\n    if( !used[vs[i]] ) rdfs( vs[i], t++ );\n  return t;\n}\n\nvoid init(){\n  for(int i=0;i<26;i++){\n    G[i].clear(); rG[i].clear();\n  }    \n}\n\nvoid add_edge(char u, char v){\n  G[u-'a'].push_back( v-'a' );\n  rG[v-'a'].push_back( u-'a' );\n}\n\nvoid view(){\n  for(int i=0;i<26;i++){\n    char c = i+'a';\n    cout << c << \": \" << endl;\n    for(int j=0;j<(int)G[i].size();j++){\n      cout << \" -> \" << (char)(G[i][j]+'a') << endl;\n    }\n  }\n}\n\nbool makeg(int l,int h,int f){\n  // cout << l<<\" \" << h << \" \" << f<< endl;\n  if( l>=h ) return true;\n  char c='.';\n  int pd;\n  c = S[l][f];\n  pd = l;\n  for(int i=l+1;i<=h;i++){\n    //cout << S[i] << endl;\n    if( S[i][f] == '#' ){\n      if( c != '#' ) return false;\n      if( !makeg(i+1,h,f) ) return false;\n      return true;\n    }\n    //    cout << c << \"  \"<< S[i][f] << endl;\n    if( S[i][f] != c ){\n      if( !makeg(pd,i-1,f+1) ) return false;\n      add_edge( S[i][f], c );\n      c = S[i][f];\n      pd = i;\n    }\n  }\n  return makeg(pd,h,f+1);\n}\n\nbool make_graph(){\n  return makeg(0,N-1,0);\n  view();\n}\n\nint main(){\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++){\n      cin >> S[i];\n      S[i]+=\"#\";\n    }\n    init();\n    if( !make_graph() || scc() < 26 ) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int>> G;\n\nvoid warshall_floyd(int n) {\n    for (int k = 0; k < n; k++){       // 経由する頂点\n        for (int i = 0; i < n; i++) {    // 始点\n            for (int j = 0; j < n; j++) {  // 終点\n                if(G[i][k]!=10&&G[k][j]!=10)G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n            }\n        }\n    }\n}\n\nbool solve(){\n    int n;\n    cin>>n;\n    if(n==0)return false;\n\n    G.assign(26,vector<int>(26,10));\n    for (int i = 0; i < 26; ++i) {\n        G[i][i]=0;\n    }\n    vector<string> vs(n);\n    for (int i = 0; i < n; ++i) {\n        cin>>vs[i];\n    }\n    for (int i = 1; i < n; ++i) {\n        int ind=0;\n        if(vs[i]==vs[i-1])continue;\n        while(vs[i].size()>=ind+1&&vs[i-1].size()>=ind+1&&vs[i][ind]==vs[i-1][ind]){\n            ++ind;\n        }\n        if(vs[i].size()>=ind+1&&vs[i-1].size()>=ind+1){\n            G[vs[i-1][ind]-'a'][vs[i][ind]-'a']=-1;\n            //G[vs[i][ind]-'a'][vs[i-1][ind]-'a']=-1;\n        }\n        else{\n            if(vs[i-1].size()>vs[i].size()&&vs[i].front()==vs[i-1].front()){\n                cout<<\"no\"<<endl;\n                return true;\n            }\n        }\n    }\n    warshall_floyd(26);\n/*\n    for (int i = 0; i < 26; ++i) {\n        for (int j = 0; j < 26; ++j) {\n            cout<<G[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n*/\n    for (int i = 0; i < 26; ++i) {\n        if(G[i][i]<0){\n            cout<<\"no\"<<endl;\n            return true;\n        }\n    }\n    cout<<\"yes\"<<endl;\n    return true;\n}\n\nint main(){\n    while(solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    vector<vector<int>> e(26);\n    vector<int> deg(26,0);\n    vector<string> s(n);\n    queue<int> q;\n    rep(i,n){\n      cin >> s[i];\n    }\n    rep(i,n){\n      rep(j,i){\n        rep(k,min(s[i].length(),s[j].length())){\n          if(s[i][k]!=s[j][k]){\n            e[s[j][k]-'a'].push_back(s[i][k]-'a');\n            deg[s[i][k]-'a']++;\n            goto next;\n          }\n        }\n        if(s[i].length()<s[j].length()){\n          cout << \"no\" << endl;\n          goto nextt;\n        }\n        next:;\n      }\n    }\n    rep(i,26) if(deg[i]==0) q.push(i);\n    while(!q.empty()){\n      int now = q.front();\n      q.pop();\n      for(auto nx:e[now]){\n        deg[nx]--;\n        if(deg[nx]==0) q.push(nx);\n      }\n    }\n    rep(i,26){\n      if(deg[i]!=0){\n        cout << \"no\" << endl;\n        goto nextt;\n      }\n    }\n    cout << \"yes\" << endl;\n    nextt:;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\n  typedef vector<int> Vector;\n  typedef vector<Vector> Matrix;\n  typedef queue<int> IntQueue;\n  public:\n    Graph(int size): size_(size), next_(size) {\n    }\n    void add_edge(int a, int b) {\n      if (0 <= a and a < size_ and 0 <= b and b < size_) {\n        next_[a].push_back(b);\n      } else {\n        Matrix m(100000, Vector(1000000));\n        m[0][0] = 100;\n      }\n    }\n    bool exists_path(int a, int b) {\n      vector<bool> has_visited(size_, false);\n      IntQueue q;\n      q.push(a);\n      has_visited[a] = true;\n      while (not q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (size_t i = 0; i < next_[x].size(); ++i) {\n          int y = next_[x][i];\n          if (not has_visited[y]) {\n            if (y == b) {\n              return true;\n            }\n            has_visited[y] = true;\n            q.push(y);\n          }\n        }\n      }\n      return false;\n    }\n  private:\n    int size_;\n    Matrix next_;\n};\n\nbool solve(int n, string s[]) {\n  Graph g(26);\n  for (int i = 0; i < n - 1; ++i) {\n    size_t pos = 0;\n    while (s[i][pos] == s[i + 1][pos]) {\n      ++pos;\n    }\n    if (pos == s[i].length()) {\n      continue;\n    } else if (pos == s[i + 1].length()) {\n      return false;\n    }\n    g.add_edge(s[i][pos] - 'a', s[i + 1][pos] - 'a');\n    for (int i = 0; i < 26; ++i) {\n      for (int j = i + 1; j < 26; ++j) {\n        if (g.exists_path(i, j) and g.exists_path(j, i)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  string s[500];\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      return 0;\n    }\n    for (int i = 0; i < n; ++i) {\n      cin >> s[i];\n    }\n    if (solve(n, s)) {\n      cout << \"yes\" << endl;\n    } else {\n      cout << \"no\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool dfs(vector< vector<int> > &G, vector<bool> &visited, int v){\n  visited[v] = true;\n  bool ret = false;\n  for(int i = 0; i < G[v].size(); ++i){\n    if(G[v][i] && visited[i]) return true;\n    if(G[v][i]) ret |= dfs(G,visited,i);\n  }\n  return ret;\n}\n\nbool has_loop(vector< vector<int> > &G){\n  int n = G.size();\n  vector<bool> visited(n,false);\n  vector<int> d_in(n,0);\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(G[i][j]) ++d_in[j];\n    }\n  }\n  vector<int> S;\n  for(int i = 0; i < n; ++i){\n    if(d_in[i] == 0) S.push_back(i);\n  }\n  if(S.empty()){\n    return true;\n  }\n  for(int i = 0; i < S.size(); ++i){\n    if((!visited[S[i]]) && dfs(G,visited,S[i])) return true;\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> S(n);\n    for(int i = 0; i < n; ++i){\n      cin >> S[i];\n    }\n    if(n == 1) cout << \"yes\" << endl;\n    vector< vector<int> > G(26, vector<int>(26,0));\n    bool f = true;\n    for(int i = 1; i < n; ++i){\n      if(S[i-1] == S[i]) continue;\n      for(int j = 0; j < min(S[i].length(),S[i-1].length()); ++j){\n        f = true;\n        if(S[i][j] != S[i-1][j]){\n          //G[S[i-1][j] - 'a'].push_back(S[i][j] - 'a');\n          G[S[i-1][j] - 'a'][S[i][j] - 'a'] = 1;\n          f = false;\n          break;\n        }\n      }\n      if(f && S[i-1].size() > S[i].size()){\n        cout << \"no\" << endl;\n        break;\n      }\n    }\n    if(f) continue;\n\n\n    if(has_loop(G)) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 1e9;\n\nbool has_loop(vector< vector<int> > G){\n  int n = G.size();\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i){\n    if(G[i][i] < INF) return true;\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> S(n);\n    for(int i = 0; i < n; ++i){\n      cin >> S[i];\n    }\n    if(n == 1) cout << \"yes\" << endl;\n    vector< vector<int> > G(26, vector<int>(26,INF));\n    bool f = true;\n    for(int i = 1; i < n; ++i){\n      if(S[i-1] == S[i]) continue;\n      for(int j = 0; j < min(S[i].length(),S[i-1].length()); ++j){\n        f = true;\n        if(S[i][j] != S[i-1][j]){\n          //G[S[i-1][j] - 'a'].push_back(S[i][j] - 'a');\n          G[S[i-1][j] - 'a'][S[i][j] - 'a'] = 1;\n          f = false;\n          break;\n        }\n      }\n      if(f && S[i-1].size() > S[i].size()){\n        cout << \"no1\" << endl;\n        break;\n      }else{\n        f = false;\n      }\n    }\n    if(f) continue;\n\n    if(has_loop(G)) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// ex2だとまず先頭1文字だけを見るとb<aが確定\n// 上2つはokだけど下2つでprefixの条件を破ってるからダメ\n// こんな感じで条件を全部列挙して矛盾があったらno\n// ex4の条件は b<c(1個目と2個目より) と c<b(3個目と4個目) で矛盾してるからダメ\n// a<bならa->bに辺をつなげるとかして出来たグラフに閉路があれば矛盾してるとわかる\n\nint n;\nstring s[500];\nvi e[26];\nbool vis[26], hei;\n\nvoid rec(int v, int p) {\n\tvis[v] = 1;\n\trep(i,e[v].size()) {\n\t\tif (e[v][i]==p) hei = 1;\n\t\telse if (!vis[e[v][i]]) rec(e[v][i],p);\n\t}\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\trep(i,26) e[i].clear();\n\t\tbool dame = 0;\n\t\trep(i,n) {\n\t\t\tcin >> s[i];\n\t\t\trep(j,i) if (s[j].size()>s[i].size() && s[j].substr(0,s[i].size())==s[i]) dame = 1; // prefix\n\t\t}\n\t\tif (dame) {\n\t\t\tcout << \"no\" << ln;\n\t\t\tcontinue;\n\t\t}\n\t\t// 条件追加\n\t\trep(i,n) reps(j,i+1,n) {\n\t\t\tif (s[j].size()>=s[i].size() && s[j].substr(0,s[i].size())==s[i]) continue; // prefix\n\t\t\trep(k,min(s[i].size(),s[j].size())) if (s[i][k]!=s[j][k]) {\n\t\t\t\te[s[i][k]-'a'].pb(s[j][k]-'a');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// 閉路検出\n\t\thei = 0;\n\t\trep(i,26) zero(vis), rec(i,i);\n\t\tcout << (hei ? \"no\" : \"yes\") << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main() {\n  for(int n; cin >> n && n; ) {\n    vector<string> v(n);\n    for(int i = 0; i < n; ++i) cin >> v[i];\n    try {\n      vector<int> s, t;\n      for(int i = 0; i+1 < n; ++i) {\n        const string &a = v[i], &b = v[i+1];\n        int l = min(a.size(), b.size());\n        if(a.substr(0, l) == b.substr(0, l) &&\n           a.size() > b.size()) {\n          throw \"no\";\n        }\n        for(int j = 0; j < l; ++j) {\n          if(a[j] != b[j]) {\n            s.push_back(a[j]-'a');\n            t.push_back(b[j]-'a');\n            break;\n          }\n        }\n      }\n      vector<int> w(26, 0);\n      for(int k = 0; k < 26; ++k) {\n        bool update = false;\n        for(int i = 0; i < s.size(); ++i) {\n          if(w[t[i]] > w[s[i]] - 1) {\n            w[t[i]] = w[s[i]] - 1;\n            update = true;\n          }\n        }\n        if(!update) throw \"yes\";\n        if(k+1 == 26) throw \"no\";\n      } \n    } catch(const char *s) {\n      cout << s << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        string s[505];\n        rep(i,n) cin >> s[i];\n\n        map<pair<char,char>,int> m;\n        bool ans = true;\n        rep(i,n - 1){\n            bool f = false;\n            int len = min<int>(s[i].size(), s[i + 1].size());\n            rep(j,len){\n                if(s[i][j] != s[i + 1][j]){\n                    m[ make_pair(s[i][j], s[i + 1][j]) ] = 1;\n                    f = true;\n                    break;\n                }\n            }\n            if(s[i].size() != s[i + 1].size()) ans = f;\n        }\n\n        for(char i = 'a'; i <= 'z'; i++){\n            for(char j = 'a'; j <= 'z'; j++){\n                if(i == j) continue;\n                if(m[make_pair(i,j)] && m[make_pair(j,i)]) ans = false;\n            }\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n \nbool hasCircle;\n \nbool add_edge(string a,string b,set<int> graph[30]){\n    bool flag = true;\n    rep( i , min(a.size(),b.size()) ){\n        if(a[i]!=b[i]){\n            graph[ b[i]-'a' ].insert( a[i]-'a' );\n//            cout<<b[i]<<\">\"<<a[i]<<endl;\n            flag=false;\n            break;\n        }\n    }\n    if(flag){\n        if(a.size()>b.size()){\n            return false;\n        }\n    }\n    return true;\n}\n \n \nvoid dfs(int pos,bool used[30],set<int> graph[30]){\n    if( used[pos] ){    //??¢????????????????????????\n//        cout<<pos<<endl;\n        hasCircle=true; //????????°???true???????????????\n        return ;\n    }\n    \n    used[pos]=true;\n    for(auto &to:graph[pos]){\n        dfs(to,used,graph);\n    }\n    used[pos]=false;\n}\n \n \nint main(){\n    int n;\n    while(cin>>n&&n){\n        vector<string> s(n);\n        rep(i,n){\n            cin>>s[i];\n        }\n        \n        set<int> graph[30];\n        \n        rep(i,n){\n            for(int j=i+1;j<n;j++){\n                if( add_edge(s[i],s[j],graph) == false ){\n                    cout<<\"no\"<<endl;\n                    goto next;\n                }\n            }\n        }\n        \n//        rep(i,26){\n//            for(auto &elm:graph[i]){\n//                cout<<i<<\"->\"<<elm<<endl;\n//            }\n//        }\n        \n        \n        hasCircle = false;\n        rep(i,26){\n            bool used[30];\n            rep(j,30)used[j]=false;\n            dfs(i,used,graph);\n            if(hasCircle)break;\n        }\n        if( hasCircle )cout<<\"no\"<<endl;\n        else cout<<\"yes\"<<endl;\n        \n        next:;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint g[30][30];\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> s(n);\n    for(int i=0;i<n;i++)cin >> s[i];\n\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++){\n\t  g[i][j] = 1e9;\n      }\n      g[i][i] = 0;\n    }\n\n    bool f = true;\n    for(int i=1;i<n;i++){\n      int len = min(s[i-1].size(), s[i].size()), j;\n      for(j=0;j<len;j++){\n\tif(s[i-1][j]!=s[i][j])break;\n      }\n\n      if(j==len){\n\tif(s[i-1].size() > s[i].size()){\n\t  f = false;\n\t}\n      }else{\n\tg[s[i-1][j]-'a'][s[i][j]-'a'] = -1;\n      }\n    }\n\n    for(int k=0;k<26;k++){\n      for(int i=0;i<26;i++){\n\tfor(int j=0;j<26;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    for(int i=0;i<26;i++){\n      if(g[i][i] < 0) f = false;\n    }\n\n    cout << (f?\"yes\":\"no\") << endl;\n  }   \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\n#define ALL(x) x.begin(),x.end()\n#define INS(x) inserter(x,x.begin())\n#define rep(i,j,k) for(int i=j;i<=k;i++)\n#define MAXN 1005\n#define MAXM 40005\n#define INF 0x3fffffff\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n#define clr(x,y) memset(x,y,sizeof(x));\nusing namespace std;\ntypedef long long LL;\nint i,j,k,n,m,x,y,T,ans,big,cas,num,len[505];\nbool flag;\nqueue <int> q;\nint ru[505],G[30][30],vis[30];\nchar s[505][15];\nint main()\n{\n\twhile (scanf(\"%d\",&n),n)\n\t{\n\t\tmemset(ru,0,sizeof(ru));\n\t\tmemset(G,0,sizeof(G));\n\t\tmemset(vis,0,sizeof(vis));\n\t\t\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%s\",&s[i]);\n\t\t\tlen[i]=strlen(s[i]);\n\t\t}\n\t\tint ii=0;\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tfor (j=i+1;j<n;j++)\n\t\t\t{\n\t\t\t\tint mi=min(len[i],len[j]);\n\t\t\t\tflag=false;\n\t\t\t\tfor (k=0;k<mi;k++)\n\t\t\t\t{\n\t\t\t\t\tif (s[i][k]!=s[j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tint p=s[i][k]-'a';\n\t\t\t\t\t\tint q=s[j][k]-'a';\n\t\t\t\t\t\tG[p][q]=1;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag && len[i]>len[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"No\\n\");\n\t\t\t\t\tii=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ii==1) break;\n\t\t}\n\t\tif (ii==1) continue;\n\t\t\n\t\tfor (i=0;i<26;i++)\n\t\t{\n\t\t\tfor (j=0;j<26;j++)\n\t\t\t{\n\t\t\t\tru[j]+=G[i][j];\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) q.pop();\n\t\t//puts(\"sss\");\n\t\tfor (i=0;i<26;i++)\n\t\t{\n\t\t\tif (!ru[i]) \n\t\t\t{\n\t\t\t\tq.push(i);\n\t\t\t\tvis[i]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tfor (i=0;i<26;i++)\n\t\t\t{\n\t\t\t\tif (!vis[i] && G[u][i]) \n\t\t\t\t{\n\t\t\t\t\tru[i]--;\n\t\t\t\t\tif (ru[i]==0) \n\t\t\t\t\t{\n\t\t\t\t\t\tq.push(i);\n\t\t\t\t\t\tvis[i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflag=false;\n\t\tfor (i=0;i<26;i++)\n\t\t{\n\t\t\tif (ru[i]!=0)\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) printf(\"No\\n\");else\n\t\tprintf(\"Yes\\n\");\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nusing graph = vector<vector<int>>;\n \nvoid dfs(int v, const graph& G, vector<int>& res, vector<int>& used) {\n    used[v] = 1;\n    for (auto to : G[v]) if (used[to] == 0) {\n        dfs(to, G, res, used);\n    }\n    res.push_back(v);\n}\n \nvector<int> topo_sort(const graph& G) {\n    int V = G.size();\n    vector<int> ide(V);\n    for (int i = 0; i < V; i++) {\n        for (auto to : G[i]) {\n            ide[to]++;\n        }\n    }\n    vector<int> res;\n    vector<int> used(V);\n    for (int i = V - 1; i >= 0; i--) {\n        if (ide[i] == 0) {\n            dfs(i, G, res, used);\n        }\n    }\n    if(res.size()==0) res={-1};\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        for(int i=0;i<n;i++) cin>>s[i];\n        graph g(26);\n        bool f=true;\n        for(int i=1;i<n;i++){\n            int len=min(s[i-1].length(),s[i].length());\n            bool tmp=true;\n            for(int j=0;j<len;j++){\n                if(s[i-1][j]==s[i][j]) continue;\n                int st=s[i-1][j]-'a',gt=s[i][j]-'a';\n                g[gt].push_back(st);\n                tmp=false;\n                break;\n            }\n            if(tmp && s[i-1]>s[i]) f=false;\n        }\n        vector<int> res=topo_sort(g);\n        //cout<<res.size()<<endl;\n        if(!f){\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        \n        if(res.size()==26) cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nbool solve(vs ss)\n{\n\tss.erase(unique(all(ss)),end(ss));\n\tvvi d(26,vi(26));\n\trep(i,26) d[i][i]=0;\n\trep(i,ss.size()-1){\n\t\tconst string &s1=ss[i],&s2=ss[i+1];\n\t\tfor(int j=0;;j++){\n\t\t\tif(j==s2.size()) return false;\n\t\t\tif(j==s1.size()) break;\n\t\t\tif(s1[j]!=s2[j]){\n\t\t\t\tint u=s1[j]-'a',v=s2[j]-'a';\n\t\t\t\td[u][v]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trep(k,26) rep(i,26) rep(j,26) d[i][j]|=d[i][k]&d[k][j];\n\trep(i,26) if(d[i][i]) return false;\n\treturn true;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvs ss(n);\n\t\trep(i,n) cin>>ss[i];\n\t\tcout<<(solve(ss)?\"yes\":\"no\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        bool ok = true;\n        vector<string> words(N);\n        REP(i, N) cin >> words[i];\n        bool g[30][30] = {};\n        for(int i = 0; i < N; i++){\n            for(int j = i + 1; j < N; j++){\n                for(int k = 0; k < words[i].size(); k++){\n                    if(k == words[j].size()){\n                        ok = false;\n                        break;\n                    }\n                    if(words[i][k] != words[j][k]){\n                        g[ words[i][k] - 'a' ][ words[j][k] - 'a' ] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        REP(k, 26) REP(i, 26) REP(j, 26) g[i][j] |= g[i][k] & g[k][j];\n        REP(i, 26) if(g[i][i]) ok = false;\n        cout << (ok ? \"yes\" : \"no\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint order[128][128];\nvector<string> t;\n\n//[from, to] not [from, to)\nbool check(int x, int from, int to){\n  for(int i = from; i <= to; i++){\n    if(t[i].size() <= x) continue;\n\n    for(int j = i + 1; j <= to; j++){\n      if(t[j].size() <= x) return false;\n\n      char a = t[i][x];\n      char b = t[j][x];\n\n      if(order[a][b] != -1 && order[a][b] == 1){\n        return false;\n      }\n      order[a][b] = -1;\n      order[b][a] = +1;\n    }\n  }\n\n  int i = from;\n  while(i <= to && t[i].size() <= x) i++;\n\n  for( ; i <= to; i++){\n    int j = i;\n    for( ; j <= to && t[i][x] == t[j][x]; j++);\n    if(!check(x + 1, i, j - 1)) return false;\n    i = j - 1;\n  }\n\n  return true;\n}\n\nint main(){\n  while(cin >> n, n){\n    t.clear();\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      t.push_back(s);\n    }\n\n    memset(order, -1, sizeof(order));\n\n    cout << (check(0, 0, n - 1) ? \"yes\" : \"no\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n\nvector<int> G[26];\nvector<int> rG[26];\nvector<int> vs;\nbool used[26];\nint cmp[26];\n\nvoid init(){\n\tfor(int i = 0; i < 26; ++i){\n\t\tG[i].clear();\n\t\trG[i].clear();\n\t\tvs.clear();\n\t\tused[i] = false;\n\t\tcmp[i] = 0;\n\t}\n}\n\n\nvoid add_edge(int f, int t){\n\tG[f].push_back(t);\n\trG[t].push_back(f);\n}\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); ++i){\n\t\tif( !used[G[v][i]] ) dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor(int i = 0; i < rG[v].size(); ++i){\n\t\tif( !used[rG[v][i]] ) rdfs(rG[v][i], k);\n\t}\n}\n\nint scc(){\n\tfor(int i = 0; i < 26; ++i) used[i] = false;\n\tvs.clear();\n\tfor(int v = 0; v < 26; ++v){\n\t\tif( !used[v] ) dfs(v);\n\t}\n\tfor(int i = 0; i < 26; ++i) used[i] = false;\n\tint k = 0;\n\tfor(int i = (int)vs.size() - 1; i >= 0; --i){\n\t\tif( !used[vs[i]] ) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\n\n\nbool solve(const vector<string> &v){\n\tinit();\n\tint n = v.size();\n\t\n\tfor(int i = 0; i < n - 1; ++i){\n\t\tbool f = true;\n\t\tfor(int j = 0; j < v[i].size(); ++j){\n\t\t\tif( j >= v[i+1].size() ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( v[i][j] != v[i+1][j] ){\n\t\t\t\tadd_edge(v[i][j] - 'a', v[i+1][j] - 'a');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tint k = scc();\n\treturn k == 26;\n}\n\n\nint main(){\n\tint n;\n\twhile( cin >> n, n != 0 ){\n\t\tvector<string> v(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> v[i];\n\t\t}\n\n\t\tcout << (solve(v) ? \"yes\\n\" : \"no\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\n  typedef vector<int> Vector;\n  typedef vector<Vector> Matrix;\n  typedef queue<int> IntQueue;\n  public:\n    Graph(int size): size_(size), next_(size) {\n    }\n    void add_edge(int a, int b) {\n      next_[a].push_back(b);\n    }\n    bool exists_path(int a, int b) {\n      vector<bool> has_visited(size_, false);\n      IntQueue q;\n      q.push(a);\n      has_visited[a] = true;\n      while (not q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (size_t i = 0; i < next_[x].size(); ++i) {\n          int y = next_[x][i];\n          if (not has_visited[y]) {\n            if (y == b) {\n              return true;\n            }\n            has_visited[y] = true;\n            q.push(y);\n          }\n        }\n      }\n      return false;\n    }\n  private:\n    int size_;\n    Matrix next_;\n};\n\nbool solve(int n, string s[]) {\n  Graph g(26);\n  for (int i = 0; i < n - 1; ++i) {\n    size_t pos = 0;\n    while (s[i][pos] == s[i + 1][pos]) {\n      ++pos;\n    }\n    if (pos == s[i].length()) {\n      continue;\n    } else if (pos == s[i + 1].length()) {\n      return false;\n    }\n    for (int i = 0; i < 26; ++i) {\n      for (int j = i + 1; j < 26; ++j) {\n        if (g.exists_path(i, j) and g.exists_path(j, i)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  string s[500];\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      return 0;\n    }\n    for (int i = 0; i < n; ++i) {\n      cin >> s[i];\n    }\n    if (solve(n, s)) {\n      cout << \"yes\" << endl;\n    } else {\n      cout << \"no\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<string> d(n);\n    REP(i,n){\n      string w;\n      cin>>w;\n      d[i] = w + string(11-w.size(), '`');\n    }\n    d.erase(unique(begin(d),end(d)),end(d));\n    vector<vector<int>> dst(27,vector<int>(27,0));\n    REP(i,n-1){\n      REP(j,11){\n        if(d[i][j] != d[i+1][j]) {\n          dst[d[i][j]-'`'][d[i+1][j]-'`'] = 1;\n          break;\n        }\n      }\n    }\n    REP(i,27)\n      if(i) dst[0][i] = 1;\n    REP(k,27)REP(i,27)REP(j,27) dst[i][j] = max(dst[i][j], dst[i][k] * dst[k][j]);\n    bool ok = true;\n    REP(i,27)\n      if(dst[i][i]) ok = false;\n    if (ok)\n      cout << \"yes\" << endl;\n    else\n      cout << \"no\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nchar premark = 'a' - 1;\n\nbool dfs(map<char, vector<char>>& G, vector<bool>& vis, char c, set<char>& st) {\n  for(auto& next: G[c]) {\n    if(st.count(next)) return false;\n    st.insert(next);\n    if(vis[next-'a']) continue;\n    vis[next-'a'] = 1;\n    if(!dfs(G, vis, next, st)) return false;\n    st.erase(next);\n  }\n  return true;\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    vector<string> v;\n    int L = 1;\n    rep(i, N) {\n      string s; cin >> s;\n      v.push_back(s);\n      maximize(L, s.size());\n    }\n    rep(i, N) {\n      v[i].resize(L, premark);\n    }\n\n    map<char, vector<char>> G;\n    vector<bool> vis(26);\n    bool oks[26] = {};\n    vector<char> starts;\n\n    rep(i, N-1) {\n      REP(ni, i+1, N) {\n        rep(j, L) {\n          if(v[i][j] == v[ni][j] && v[i][j] == premark) goto ne;\n          if(v[i][j] == v[ni][j]) continue;\n          if(v[i][j] == premark) goto ne;\n          if(v[ni][j] == premark) goto ng;\n          G[v[i][j]].push_back(v[ni][j]);\n          break;\n        }\n      }\n      ne:;\n    }\n\n    rep(i, 26) if(!G['a'+i].empty()) {\n      sort(all(G['a'+i]));\n      G['a'+i].erase(unique(all(G['a'+i])), G['a'+i].end());\n    }\n\n    rep(i, 26) {\n      for(auto k: G[i+'a']) if(k) {\n        oks[k-'a'] = 1;\n      }\n    }\n\n\n    rep(i, 26)\n      if(!oks[i]) starts.push_back(i + 'a');\n\n    for(auto s: starts) {\n      vis[s-'a'] = 1;\n      set<char> st;\n      if(!dfs(G, vis, s, st)) goto ng;\n    }\n\n    cout << \"yes\" << endl;\n    continue;\n\n    ng:;\n    cout << \"no\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint main() {\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<string> strings(n);\n\t\tint maxlen = 0;\n\t\tREP(i, n){\n\t\t\tcin >> strings[i];\n\t\t\tmaxlen = max(maxlen, (int)strings[i].length());\n\t\t}\n\t\tmap<char, char> replaced;\n\t\tchar c = 'a';\n\t\tREP(x, maxlen){\n\t\t\tREP(y, n){\n\t\t\t\tif(x < strings[y].length()){\n\t\t\t\t\tif (!EXIST(replaced, strings[y][x])){\n\t\t\t\t\t\t// printf(\"%c -> %c\\n\", strings[y][x], c);\n\t\t\t\t\t\treplaced[strings[y][x]] = c++;\n\t\t\t\t\t}\n\t\t\t\t\tstrings[y][x] = replaced[strings[y][x]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// REP(i, n){\n\t\t// \tcout << strings[i] << endl;\n\t\t// }\n\t\tvector<string> sorted = strings;\n\t\tSORT(sorted);\n\t\t// cout << \"----------------\" << endl;\n\t\t// REP(i, n){\n\t\t// \tcout << sorted[i] << endl;\n\t\t// }\n\t\tcout << (strings == sorted ? \"yes\" : \"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n4\nabd\nabcd\nc\nb\n0\n=>yes, where a=1,b=4,c=3,d=2\n*/\n\n#include <vector>\n#include <map>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmain(){\n\tint n,i,j;\n\tstring s;\n\tfor(;cin>>n,n;){\n\t\tmap<pair<char,char>,int>m;\n\t\tvector<string>v;\n\t\tfor(;n;n--){\n\t\t\tcin>>s;\n\t\t\tfor(i=0;i<v.size();i++){\n\t\t\t\tfor(j=0;j<min(v[i].length(),s.length());j++){\n\t\t\t\t\tif(v[i][j]==s[j])continue;\n\t\t\t\t\tif(m[make_pair(v[i][j],s[j])])goto fail;\n\t\t\t\t\tm[make_pair(s[j],v[i][j])]=1;break;\n\t\t\t\t}\n\t\t\t\tif(j==s.length()&&v[i].length()>s.length())goto fail;\n\t\t\t}\n\t\t\tv.push_back(s);\n\t\t}\n\t\tcout<<\"yes\"<<endl;continue;\n\t\tfail:\n\t\tfor(n--;n;n--)cin>>s;\n\t\tcout<<\"no\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> cc[30];\nchar a[510][32];\nint n;\nbool vis[26], can[26];\n\nbool init()\n{\n    memset(vis, 0, sizeof(vis));\n    memset(can, 0, sizeof(can));\n    for(int i = 0; i < 26; ++ i) cc[i].clear();\n    for(int i = 1; i < n; ++ i)\n    {\n        int j, len = min(strlen(a[i]), strlen(a[i-1]));\n        for(j = 0; j < len; ++ j)\n            if(a[i][j] != a[i-1][j]) break;\n        if(strlen(a[i-1]) > strlen(a[i])  && j >= len) return false;\n        if(j < len) cc[a[i][j] - 'a'].push_back(a[i-1][j] - 'a');\n    }\n    for(int i = 0; i < 26; ++ i)\n    {\n        sort(cc[i].begin(), cc[i].end());\n        cc[i].erase(unique(cc[i].begin(), cc[i].end() ), cc[i].end());\n    }\n    return true;\n}\n\nbool dfs(int cur)\n{\n    vis[cur] = true;\n    if(can[cur]) return false;\n    can[cur] = true;\n    for(int i = 0; i < (int)cc[cur].size(); ++ i)\n        if(!dfs(cc[cur][i])) return false;\n    can[cur] = false;\n    return true;\n}\n\nint main()\n{\n    while(scanf(\"%d\", &n) == 1 && n)\n    {\n        for(int i = 0; i < n; ++ i)\n            scanf(\"%s\", a[i]);\n        if(!init())\n        {\n            puts(\"no\");\n            continue;\n        }\n        bool flag = 1;\n        for(int i = 0; i < 26; i++)\n        {\n            if(!vis[i] && !dfs(i))\n            {\n                flag = 0;\n                break;\n            }\n        }\n        if(flag) puts(\"yes\");\n        else puts(\"no\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\n\nstring str;\nstring t;\nchar mapp[30][30];\nint n;\nint c[50];\n\nbool dfs(int u){\n    c[u]=-1;\n    for(int v=0;v<26;++v) if(mapp[u][v]==1){\n        if(c[v]<0) return false;\n            else if(!c[v] && !dfs(v)) return false;\n    }\n    c[u]=1;\n    return true;\n}\n\nbool toposort(){\n    memset(c,0,sizeof(c));\n    for(int u=0;u<26;++u) if(!c[u])\n        if(!dfs(u)) return false;\n    return true;\n}\n\nint main(){\n\n    while(scanf(\"%d\",&n)!=EOF){\n        if(n==0) break;\n        cin>>t;\n\n        char flag=0;\n        memset(mapp,0,sizeof(mapp));\n\n        if(n==1) { printf(\"yes\\n\"); continue; }\n        for(int i=2;i<=n;++i){\n            cin>>str;   int L1=t.size(),L2=str.size();\n            for(int j=0;j<min(L1,L2);++j){\n                if(flag) break;\n                if(t[j]!=str[j]){\n                    //cout<<t[j]<<\" \"<<str[j]<<endl;\n                    if(mapp[str[j]-'a'][t[j]-'a']==1) {flag=1; break;}\n                        else { mapp[t[j]-'a'][str[j]-'a']=1; break; }\n                }\n                if(j+1==L2 && L1>L2) {flag=1; break;}\n            }\n            t=str;\n        }\n\n        //for(int i=0;i<=26;++i)\n          //  for(int j=0;j<=26;++j) if(mapp[i][j]==1) cout<<i+'a'-1<<\" \"<<j+'a'-1<<endl;\n\n        if(flag) printf(\"no\\n\");\n            else{\n                if(toposort()) printf(\"yes\\n\"); else printf(\"no\\n\");\n            }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool dfs(int cur, bool m[30][30], bool used[30]){\n    if(used[cur]) return 1;\n    used[cur] = 1;\n\n    bool ret = 0;\n    rep(i,27){\n        if(m[cur][i]) ret |= dfs(i,m,used);\n    }\n    return ret;\n}\n\nbool isDAG(bool m[30][30]){\n    bool used[30] = {0};\n    bool ret = 0;\n\n    rep(i,27) ret |= dfs(i,m,used);\n    return not ret;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        bool m[30][30] = {{0}};\n        char s[505][10];\n        rep(i,505) rep(j,10) s[i][j] = '\\0';\n        rep(i,n) cin >> s[i];\n\n        bool ans = true;\n        rep(i,n - 1){\n            rep(j,10){\n                if(s[i][j] != '\\0' && s[i + 1][j] == '\\0'){\n                    ans = false;\n                    break;\n                }else if(s[i][j] == '\\0' || s[i + 1][j] == '\\0'){\n                    break;\n                }else if(s[i][j] != s[i + 1][j]){\n                    //cout << s[i][j] << ' ' << s[i + 1][j] << endl;\n                    m[s[i][j] - 'a'][s[i + 1][j] - 'a'] = 1;\n                    break;\n                }\n            }\n        }\n\n        cout << (isDAG(m) && ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<string> s(n);\n        REP(i, n) cin >> s[i];\n\n        bool t[26][26] = {};\n\n        REP(i, n-1) {\n            string s1 = s[i];\n            string s2 = s[i+1];\n            REP(j, s1.length()) {\n                if ((int)s2.length() <= j) {\n                    cout << \"no\" << endl;\n                    goto NEXT;\n                }\n                if (s1[j] != s2[j]) {\n//                    LOG(\"--> %c < %c\\n\", s1[j], s2[j]);\n                    t[s1[j]-'a'][s2[j]-'a'] = true;\n                    break;\n                }\n            }\n        }\n\n        REP(i, 26) REP(j, 26) REP(k, 26) t[j][k] |= t[j][i] && t[i][k];\n\n        // ???????????????????????°no\n        REP(i, n) {\n            if (t[i][i]) {\n                cout << \"no\" << endl;\n                goto NEXT;\n            }\n        }\n        cout << \"yes\" << endl;\nNEXT: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef vector<set<int>> Graph;\n\n// false -> \"contains cycle\"\nbool dfs(int now, int start, const Graph &G, vector<bool> &visited) {\n    visited[now] = true;\n    for (auto nxt : G[now]) {\n        if (nxt == start) return false;\n        if (!visited[nxt] && !dfs(nxt, start, G, visited)) return false;\n    }\n    return true;\n}\n\nbool isDAG(const Graph &G) {\n    int n = G.size();\n    rep(i, n) {\n        vector<bool> visited(n);\n        if (!dfs(i, i, G, visited)) return false;\n    }\n    return true;\n}\n\nbool solve(int n) {\n    vector<string> s(n);\n    rep(i, n) cin >> s[i];\n\n    Graph G(26);\n    rep(l, 10) {\n        rep(i, n) {\n            rep2(j, i + 1, n) {\n                if (s[i].size() >= l && s[j].size() >= l && s[i].substr(0, l) == s[j].substr(0, l)) {\n                    if (s[i].size() < l + 1) continue;\n                    if (s[j].size() < l + 1) return false;\n                    if (s[i][l] == s[j][l]) continue;\n                    G[s[i][l] - 'a'].insert(s[j][l] - 'a');\n                }\n            }\n        }\n    }\n\n    return isDAG(G);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        cout << (solve(n) ? \"yes\" : \"no\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[510][20];\nint g[30][30];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tbool ok=true;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tint k;\n\t\t\t\tfor(k=0;str[i][k]&&str[j][k];k++){\n\t\t\t\t\tif(str[i][k]!=str[j][k]){\n\t\t\t\t\t\tg[str[i][k]-'a'][str[j][k]-'a']=1;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[i][k]&&!str[j][k])ok=false;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<26;k++)for(int i=0;i<26;i++)for(int j=0;j<26;j++)\n\t\t\tg[i][j]|=(g[i][k]&g[k][j]);\n\t\t\n\t\tfor(int i=0;i<26;i++)for(int j=0;j<26;j++)if(i!=j&&g[i][j]&&g[j][i])ok=false;\n\t\tif(ok)printf(\"yes\\n\");\n\t\telse printf(\"no\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\nconst int AtoZ = 'z'-'a';\n\nbool check(int n, int b, int e, vector<string> &str, vector<vector<int> > &ord){\n\tchar now=str[b][n];\n\tint s=b;\n\tfor(int i=b; i<=e; i++){\n\t\tif(str[i][n] != now){\n\t\t\tif(str[i][n]=='0') return false;\n\t\t\tif(now!='0'){\n\t\t\t\tord[now-'a'][str[i][n]-'a'] = 0;\n\t\t\t\tif(!check(n+1, s, i-1, str, ord)) return false;\n\t\t\t\ts = i;\n\t\t\t\tnow = str[i][n];\n\t\t\t}\n\t\t}\n\t}\n\tif(now!='0'){\n\t\tif(!check(n+1, s, e, str, ord)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<string> str(n);\n\t\tvector<vector<int> > ord(AtoZ, vector<int>(AtoZ, inf));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> str[i];\n\t\t\tstr[i] += \"0\";\n\t\t}\n\t\tif(!check(0, 0, n-1, str, ord)){\n\t\t\tcout << \"no\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<AtoZ; k++){\n\t\t\tfor(int i=0; i<AtoZ; i++){\n\t\t\t\tfor(int j=0; j<AtoZ; j++){\n\t\t\t\t\tord[i][j] = min(ord[i][j], ord[i][k]+ord[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor(int i=0; i<AtoZ; i++){\n\t\t\tfor(int j=i+1; j<AtoZ; j++){\n\t\t\t\tif(ord[i][j]==0 && ord[j][i]==0){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tcout << \"yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint order[128][128];\nvector<string> t;\n\n//[from, to] not [from, to)\nbool check(int x, int from, int to){\n  for(int i = from; i <= to; i++){\n    if(t[i].size() <= x) continue;\n\n    for(int j = i + 1; j <= to; j++){\n      if(t[j].size() <= x) return false;\n\n      char a = t[i][x];\n      char b = t[j][x];\n\n      if(a != b && order[a][b] != 0 && order[a][b] == 1){\n        return false;\n      }\n      order[a][b] = -1;\n      order[b][a] = +1;\n    }\n  }\n\n  int i = from;\n  while(i <= to && t[i].size() <= x) i++;\n\n  for( ; i <= to; i++){\n    int j = i;\n    for( ; j <= to && t[i][x] == t[j][x]; j++);\n    if(!check(x + 1, i, j - 1)) return false;\n    i = j - 1;\n  }\n\n  return true;\n}\n\nint main(){\n  while(cin >> n, n){\n    t.clear();\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      t.push_back(s);\n    }\n\n    memset(order, 0, sizeof(order));\n\n    cout << (check(0, 0, n - 1) ? \"yes\" : \"no\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cmath>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<numeric>\n#include<vector>\n#include<ctime>\n#include<queue>\n#include<list>\n#include<map>\n#define pi acos(-1)\n#define INF 0x7fffffff\n#define clr(x)  memset(x,0,sizeof(x));\n#define clrto(x,siz,y)  for(int xx=0;xx<=siz;xx++)  x[xx]=y;\n#define clrset(x,siz)  for(int xx=0;xx<=siz;xx++)  x[xx]=xx;\n#define clrvec(x,siz) for(int xx=0;x<=siz;xx++)  x[xx].clear();\n#define fop   freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n#define myprogram By_135678942570\n#define clrcpy(x,siz,y)  for(int xx=0;xx<siz;xx++)  x[xx]=y[xx];\nusing namespace std;\nint cd[1001];\nmap<int,int>mp[10];\nint xx=0;\nint vis[10011];\nstruct card\n{\n   int num;\n   char s;\n}C[100];\nbool cmp(card a,card b)\n{\n    if(a.num<2&&b.num<2||a.num>=2&&b.num>=2)\n       return a.num>b.num;\n    return a.num<2;\n}\nvoid dfs(int cc,int now,int rst,int need,int cont,int sum,int add)\n{\n    if(rst==0)\n    {\n        int sz=mp[cc].size();\n        mp[cc][sum]=sz+1+add;\n     //   printf(\"%d %d %d %d %d\\n\",sum%13,sum%(13*13)/13,sum%(13*13*13)/(13*13),sum%(13*13*13*13)/(13*13*13),sum/(13*13*13*13));\n     //   xx++;\n        return;\n    }\n    for(int i=2;i<now;i++)\n    {\n        if(vis[i])\n           continue;\n        if(i==now-1&&need&&rst==1&&cont||need&&rst==1&&cont&&now==14&&i==5)\n           continue;\n        dfs(cc,i,rst-1,need,cont&&i==now-1||i==5&&now==14,sum*13+(i%13),add);\n    }\n}\nint cntshun=10;\nint cnttong=0;\nint cnt=0;\nint sum[10001];\nvoid ini()\n{\n    for(int i=2;i<10;i++)\n       cd[i+'0']=i;\n    cd['T']=10;\n    cd['A']=1;\n    cd['J']=11;\n    cd['Q']=12;\n    cd['K']=0;\n    clr(vis);\n    for(int i=2;i<=14;i++)\n        dfs(5,i,4,1,1,(i%13),0);\n    cnt+=mp[5].size();\n    sum[0]=cnt;\n    for(int i=2;i<=14;i++)\n    {\n        vis[i]=1;\n        dfs(4,15,3,0,0,13*(i%13)+(i%13),cnt);\n        vis[i]=0;\n    }\n    cnt+=mp[4].size();\n    sum[1]=cnt;\n    for(int i=2;i<=14;i++)\n    {\n       vis[i]=1;\n       for(int j=2;j<i;j++)\n       {\n          vis[j]=1;\n          dfs(3,15,1,0,0,(13*(13*(13*(i%13)+(i%13))+(j%13))+(j%13)),cnt);\n          vis[j]=0;\n       }\n       vis[i]=0;\n    }\n    cnt+=mp[3].size();\n    sum[2]=cnt;\n    for(int i=2;i<=14;i++)\n    {\n       vis[i]=1;\n       dfs(6,15,2,0,0,13*(13*(i%13)+(i%13))+(i%13),cnt);\n       vis[i]=0;\n    }\n    cnt+=mp[6].size();\n    sum[3]=cnt;\n    cnt+=14-5+1;\n    sum[4]=cnt;\n    cnt+=(cnttong=mp[5].size());\n    sum[5]=cnt;\n    for(int i=2;i<=14;i++)\n      for(int j=2;j<=14;j++)\n      if(i!=j)\n      {\n          int sz=mp[7].size();\n          mp[7][13*(13*(13*(13*(i%13)+(i%13))+(i%13))+(j%13))+(j%13)]=cnt+1+sz;\n      }\n    cnt+=mp[7].size();\n    sum[6]=cnt;\n    for(int i=2;i<=14;i++)\n    {\n       vis[i]=1;\n       dfs(2,15,1,0,0,13*(13*(13*(i%13)+(i%13))+(i%13))+(i%13),cnt);\n       vis[i]=0;\n    }\n    cnt+=mp[2].size();\n    sum[7]=cnt;\n    cnt+=cntshun;\n}\nint getrank(char* s1, char* s2, char* s3, char* s4, char* s5)\n{\n     int flag1=1,flag2=1;\n     int times[20]={0};\n     int maxn=0;\n     int doublepair=0;\n     int maxi=0;\n     int singlepair=0;\n     for(int i=0;i<5;i++)\n     {\n         char a,aa[3];\n         if(i == 0) aa[0] = s1[1], aa[1] = s1[0];\n         if(i == 1) aa[0] = s2[1], aa[1] = s2[0];\n         if(i == 2) aa[0] = s3[1], aa[1] = s3[0];\n         if(i == 3) aa[0] = s4[1], aa[1] = s4[0];\n         if(i == 4) aa[0] = s5[1], aa[1] = s5[0];\n         a=aa[0],C[i].s=aa[1];\n         printf(\"%s\\n\", aa);\n         C[i].num=cd[a];\n         times[C[i].num]++;\n         if(times[C[i].num]==2&&maxn==2)\n            doublepair=1;\n         else\n         {\n            if(maxn<times[C[i].num])\n            {\n                maxn=times[C[i].num];\n                if(maxn==3&&maxi==C[i].num&&!doublepair)\n                   singlepair=0;\n                maxi=C[i].num;\n            }\n            if(times[C[i].num]==2)\n               singlepair=1;\n         }\n         if(i!=0&&C[i].s!=C[0].s)\n            flag2=0;\n     }\n     sort(C,C+5,cmp);\n     if(C[0].num>=2&&C[0].num<5)\n        flag1=0;\n     for(int i=1;i<5;i++)\n        if(!(C[i].num==5&&C[i-1].num==1)&&C[i].num!=(C[i-1].num-1+13)%13)\n           flag1=0;\n     if(flag1&&flag2)\n     {\n         if(C[0].num==1&&C[4].num==2)\n            return (sum[7]+1);\n         else if(C[0].num<2)\n            return (sum[7]+9+C[0].num);\n         else return (sum[7]+C[0].num-4);\n     }\n     else if(maxn==4)\n     {\n         int temp;\n         for(int i=0;i<5;i++)\n            if(maxi!=C[i].num)\n               temp=C[i].num;\n         return (mp[2][13*(13*(13*(13*maxi+maxi)+maxi)+maxi)+temp]);\n     }\n     else if(maxn==3&&singlepair)\n     {\n         int temp;\n         for(int i=0;i<5;i++)\n            if(maxi!=C[i].num)\n               temp=C[i].num;\n         return (mp[7][13*(13*(13*(13*maxi+maxi)+maxi)+temp)+temp]);\n     }\n     else if(flag2)\n     {\n         return (sum[4]+mp[5][13*(13*(13*(13*C[0].num+C[1].num)+C[2].num)+C[3].num)+C[4].num]);\n     }\n     else if(flag1)\n     {\n         if(C[0].num==1&&C[4].num==2)\n           return (sum[3]+1);\n         else if(C[0].num<2)\n            return (sum[3]+9+C[0].num);\n         else return (sum[3]+C[0].num-4);\n     }\n     else if(maxn==3)\n     {\n         int cnt=0;\n         int a[2]={0};\n         for(int i=0;i<5;i++)\n            if(maxi!=C[i].num)\n              a[cnt++]=C[i].num;\n         return (mp[6][13*(13*(13*(13*maxi+maxi)+maxi)+a[0])+a[1]]);\n     }\n     else if(doublepair)\n     {\n         int a,b;\n         int temp;\n         for(int i=0;i<5;i++)\n            if(times[C[i].num]==2)\n               b=C[i].num;\n            else temp=C[i].num;\n         for(int i=4;i>=0;i--)\n            if(times[C[i].num]==2)\n               a=C[i].num;\n         return (mp[3][13*(13*(13*(13*a+a)+b)+b)+temp]);\n     }\n     else if(singlepair)\n     {\n         int cnt=0;\n         int a[3]={0};\n         for(int i=0;i<5;i++)\n            if(maxi!=C[i].num)\n               a[cnt++]=C[i].num;\n         return (mp[4][13*(13*(13*(13*maxi+maxi)+a[0])+a[1])+a[2]]);\n     }\n     else\n         return (mp[5][13*(13*(13*(13*C[0].num+C[1].num)+C[2].num)+C[3].num)+C[4].num]);\n}\nmap<string, int>vvv;\nchar getcolor(int p)\n{\n    if(p == 0)\n        return 'S';\n    if(p == 1)\n        return 'H';\n    if(p == 2)\n        return 'D';\n    return 'C';\n}\nchar getid(int p)\n{\n    if(p < 10)\n        return p + '0';\n    if(p == 10)\n        return 'T';\n    if(p == 11)\n        return 'J';\n    if(p == 12)\n        return 'Q';\n    return 'K';\n}\nint main()\n{\n    ini();\n    printf(\"%d\\n\", getrank(\"HA\", \"HK\", \"HQ\", \"HJ\", \"HT\"));\n    while(1)\n    {\n        vvv.clear();\n        char m1[5], m2[5];\n        scanf(\"%s%s\", m1, m2);\n        vvv[m1] = 1, vvv[m2] = 1;\n        if(m1[0] == '#')\n            break;\n        char o1[5], o2[5];\n        scanf(\"%s%s\", o1, o2);\n        vvv[o1] = 1, vvv[o2] = 1;\n        char r[5][5] = {0};\n        scanf(\"%s%s%s\", r[0], r[1], r[2]);\n        vvv[r[0]] = 1;\n        vvv[r[1]] = 1;\n        vvv[r[2]] = 1;\n        int all = 0;\n        int cnt = 0;\n        for(int i = 0; i < 4; i++)\n            for(int j = 0; j < 13; j++)\n            {\n                r[3][0] = getcolor(i);\n                r[3][1] = getid(i);\n                if(vvv[r[3]] == 0)\n                for(int i1 = 0; i1 < 4; i1++)\n                    for(int j1 = 0; j1 < 13; j1++)\n                    {\n                        r[4][0] = getcolor(i1);\n                        r[4][1] = getid(j1);\n                        if(vvv[r[4]] == 0)\n                        {\n                            int maxn1 = 0;\n                            int maxn2 = 0;\n                            for(int a = 0; a < 5; a++)\n                                for(int b = a + 1; b < 5; b++)\n                                    for(int c = b + 1; c < 5; c++)\n                                    {\n                                        int r1 = getrank(m1, m2, r[a], r[b], r[c]);\n                                        int r2 = getrank(o1, o2, r[a], r[b], r[c]);\n                                        maxn1 = max(maxn1, r1);\n                                        maxn2 = max(maxn2, r2);\n                                    }\n                            all++;\n                            if(maxn1 > maxn2)\n                                cnt++;\n                        }\n                    }\n            }\n        printf(\"%.10f\\n\", cnt * 1.0 / all);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint n;\nstring S[512];\nvector<int>G[32];\n\nint dfs(int p, int d){\n  if(d>26) return 0;\n  for(auto g:G[p]){\n    if(!dfs(g, d+1)) return 0;\n  }\n  return 1;\n}\n\nint solve()\n{\n  rep(i, 26) G[31].push_back(i);\n  rep(i, n-1){\n    //    cout << i << endl;\n    int p = 0;\n    string s=S[i], t = S[i+1];\n    while(1){\n      if(s[p] == '\\0') break;\n      if(t[p] == '\\0') return 0;\n      if(s[p] != t[p]){\n\tG[s[p]-'a'].push_back(t[p]-'a');\n\tbreak;\n      }\n      p++;\n    }\n  }\n  return dfs(31, 0);\n}\n\nint main()\n{\n  while(1){\n    cin >> n;\n    if(n == 0) return 0;\n    rep(i, 32) G[i].clear();\n\n    rep(i, n) cin >> S[i];\n\n    cout << (solve()?\"Yes\\n\":\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 30;\n\nvector<int> g[MAX_V]; //????????\nvector<int> tp; //????????????????????????????????????\n\nbool visit(int v, vector<int> &color){\n    color[v] = 1;\n    rep(i,g[v].size()){\n        int d = g[v][i];\n        if(color[d] == 2) continue;\n        if(color[d] == 1) return false;\n        if(not visit(d, color)) return false;\n    }\n    tp.emplace_back(v);\n    color[v] = 2;\n    return true;\n}\n\nbool topologicalSort(int v){\n    vector<int> color(v);\n    rep(i,v){\n        if(not color[i] && not visit(i, color)) return false;\n    }\n    reverse(all(tp));\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        rep(i,MAX_V) g[i].clear();\n        tp.clear();\n        char s[505][15];\n        rep(i,505) rep(j,15) s[i][j] = '\\0';\n        rep(i,n) cin >> s[i];\n\n        bool ans = true;\n        rep(i,n){\n            range(j,i + 1, n){\n                rep(k,15){\n                    if(s[i][k] != '\\0' && s[j][k] == '\\0'){\n                        ans = false;\n                        break;\n                    }else if(s[i][k] == '\\0' || s[j][k] == '\\0'){\n                        break;\n                    }else if(s[i][k] != s[j][k]){\n                        //cout << s[i][k] << ' ' << s[j][k] << endl;\n                        g[s[i][k] - 'a'].emplace_back(s[j][k] - 'a');\n                        break;\n                    }\n                }\n            }\n        }\n\n        cout << (topologicalSort(30) && ans ? \"yes\" : \"no\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <iostream>\n#include <stdlib.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nchar s[505][15];\nstruct edge{\n    int v,next;\n}e[10000];\nint head[30];\nint en;\nvoid add(int u,int v)\n{\n    e[en].v=v;\n    e[en].next=head[u];\n    head[u]=en++;\n}\nbool vis[30];\nbool dfs(int u)\n{\n    vis[u]=true;\n    for(int i=head[u];i!=-1;i=e[i].next)\n    {\n        int v = e[i].v;\n        if(vis[v])return true;\n        if(dfs(v))return true;\n    }\n    vis[u]=false;\n    return false;\n}\nbool has[30][30];\nint main()\n{\n    //freopen(\"a.txt\",\"r\",stdin);\n    int n;\n    while(~scanf(\"%d\",&n)&&n)\n    {\n        if(n==1)\n        {\n            char ss[15];\n            scanf(\"%s\",ss);\n            printf(\"yes\\n\");\n            continue;\n        }\n        int len=0;\n        memset(s,0,sizeof(s));\n        memset(head,-1,sizeof(head));\n        en=0;\n        for(int i=0;i<n;++i){\n            scanf(\"%s\",s[i]);\n            len=max(len,(int)strlen(s[i]));\n        }\n        int same[2][505];\n        bool flag = true;\n        memset(has,false,sizeof(has));\n        memset(same,0,sizeof(same));\n        for(int i=0;i<len;++i)\n        {\n            int q=i&1;\n            int now = 0;\n            for(int j=1;j<n;++j)\n            {\n                if(same[q^1][j-1]==same[q^1][j])\n                {\n                    int a = s[j-1][i] - 'a';\n                    int b = s[j][i] - 'a';\n\n                    if(b<0&&a>=0){\n                        flag=false;\n                        same[q][j]=++now;\n                    }\n                    else if(a<0&&b<0){\n                        same[q][j]=same[q][j-1];\n                    }\n                    else if(a<0&&b>=0)\n                    {\n                        same[q][j]=++now;\n                    }\n                    else if(a==b){\n                        same[q][j]=same[q][j-1];\n                    }\n                    else{\n                        if(!has[a][b])\n                        {\n                            has[a][b]=true;\n                            add(a,b);\n                        }\n                        same[q][j]=++now;\n                    }\n                }\n                else same[q][j]=++now;\n            }\n        }\n        for(int i=0;i<26;++i){\n            memset(vis,false,sizeof(vis));\n            if(dfs(i))\n            {\n                flag=false;\n                break;\n            }\n        }\n        if(!flag)printf(\"no\\n\");\n        else printf(\"yes\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\n  typedef vector<int> Vector;\n  typedef vector<Vector> Matrix;\n  typedef queue<int> IntQueue;\n  public:\n    Graph(int size): size_(size), next_(size) {\n    }\n    void add_edge(int a, int b) {\n      next_[a].push_back(b);\n    }\n    bool exists_path(int a, int b) {\n      vector<bool> has_visited(size_, false);\n      IntQueue q;\n      q.push(a);\n      has_visited[a] = true;\n      while (not q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (size_t i = 0; i < next_[x].size(); ++i) {\n          int y = next_[x][i];\n          if (not has_visited[y]) {\n            if (y == b) {\n              return true;\n            }\n            has_visited[y] = true;\n            q.push(y);\n          }\n        }\n      }\n      return false;\n    }\n  private:\n    int size_;\n    Matrix next_;\n};\n\nbool solve(int n, string s[]) {\n  Graph g(26);\n  for (int i = 0; i < n - 1; ++i) {\n    size_t pos = 0;\n    while (s[i][pos] == s[i + 1][pos]) {\n      ++pos;\n    }\n    if (pos == s[i].length()) {\n      continue;\n    } else if (pos == s[i + 1].length()) {\n      return false;\n    }\n    g.add_edge(s[i][pos] - 'a', s[i + 1][pos] - 'a');\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  string s[500];\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      return 0;\n    }\n    for (int i = 0; i < n; ++i) {\n      cin >> s[i];\n    }\n    if (solve(n, s)) {\n      cout << \"yes\" << endl;\n    } else {\n      cout << \"no\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\n#define maxn 500000\n\nint grap[30][30];\nchar ch1[520][20];\nint c = 1 , n;\nint pre[30];\nint vis[30];\n\nvoid init()\n{\n    memset(grap , 0 , sizeof(grap));\n    memset(vis , 0 , sizeof(vis));\n    memset(pre , 0 , sizeof(pre));\n}\n\nbool panduan(int p)\n{\n    int i;\n    int x = strlen(ch1[p-1]) , y = strlen(ch1[p]);\n    int z = x<y?x:y;\n    for(i = 0; i < z; i++)\n        if(ch1[p-1][i] != ch1[p][i])  break;\n\n    if(i == z)\n    {\n        if(x > y)  return false;\n        return true;\n    }\n    x = ch1[p-1][i]-'a'+1 , y = ch1[p][i]-'a'+1;\n    vis[x] = vis[y] = 1;\n    grap[x][y] = 1;\n    //cout<<x<<\"  \"<<y<<endl;\n    return true;\n}\n\nbool dfs(int u)\n{\n    if(pre[u])  return false;\n    pre[u] = 1;\n    for(int i = 1; i <= 26; i++)\n    {\n        if(grap[u][i])\n        {\n            if(pre[i])  return false;\n            if(!dfs(i))  return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    while(scanf(\"%d\" , &n) && n)\n    {\n        init();\n        int i;\n        bool bz = true;\n\n        scanf(\"%s\" , ch1[0]);\n        /*for(i = 1; i < n; i++)\n        {\n            scanf(\"%s\" , ch1[i]);\n            if(!bz)  continue;\n            bz = panduan(i);\n        }*/\n        for(i = 1; i < n; i++)\n        {\n            scanf(\"%s\", ch1[i]);\n            int len1 = strlen(ch1[i-1]);\n            int len2 = strlen(ch1[i]);\n            int j;\n            for( j = 0; j < len1 && j < len2 ; j++)\n            {\n                if(ch1[i-1][j] != ch1[i][j])\n                {\n                    int a = ch1[i-1][j] - 'a'+1;\n                    int b = ch1[i][j] - 'a'+1;\n                    if(!vis[a])\n                    {\n                        vis[a] = 1;\n                    }\n                    if(!vis[b])\n                    {\n                        vis[b] = 1;\n                    }\n                    if(grap[a][b] == 0)\n                    {\n                        //degree[b]++;\n                        grap[a][b] = 1;\n                    }\n                    break;\n                }\n            }\n            if(j == len2 && j < len1)\n            {\n                bz = false;\n            }\n        }\n        if(n == 1)\n        {\n            cout<<\"yes\"<<endl;\n            continue;\n        }\n        if(!bz)\n        {\n            cout<<\"no\"<<endl;\n            continue;\n        }\n\n        for(i = 1; i < 30; i++)\n            if(!pre[i] && vis[i])\n            {\n                memset(pre , 0 , sizeof(pre));\n                bz = dfs(i);\n                if(!bz)  break;\n            }\n        if(bz)  cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN=555;\nint n;\nchar str[MAXN][22];\nint vis[255][255];\nint in[255];\nqueue<int> q;\n\nbool topsort()\n{\n    while(!q.empty())   q.pop();\n    for(int i='a';i<='z';i++)  if(in[i]==0)   q.push(i);\n    int num=0;\n    while(!q.empty())\n    {\n        int u=q.front();q.pop();num++;\n        for(int i='a';i<='z';i++)\n            if(vis[u][i]==1)\n            {\n                in[i]--;\n                if(in[i]==0)   q.push(i);\n            }\n    }\n    return num==26;\n}\n\nbool check()\n{\n    memset(vis,0,sizeof vis);memset(in,0,sizeof in);\n    for(int i=2;i<=n;i++)\n    {\n        for(int j=0;str[i][j] || str[i-1][j];j++)\n        {\n            if(str[i][j]==str[i-1][j])  continue;\n            if(!str[i][j])    return false;\n            int x=(int)(str[i-1][j]);\n            int y=(int)(str[i][j]);\n            if(vis[y][x])   return false;\n            if(!vis[x][y])\n            {\n                vis[x][y]=1;\n                in[y]++;\n            }\n            break;\n        }\n    }\n    return topsort();\n}\n\n\nint main()\n{\n    //freopen(\"data.txt\",\"r\",stdin);\n    while(scanf(\"%d\",&n)==1 && n)\n    {\n        memset(str,0,sizeof str);\n        for(int i=1;i<=n;i++)\n            scanf(\"%s\",str[i]);\n        if(check())\n            puts(\"yes\");\n        else\n            puts(\"no\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N ('z'-'a')\nusing namespace std;\ntypedef long long ll;\nint n,ans;\nstring str[501];\nll mp[N+1];\n\nvoid mk_mp(int pos,int i,int j){\n  while(i<=j&&pos>=str[i].size())i++;\n  if(i>=j)return;\n  int ni=-1,ch=str[i][pos]-'a',c=1;\n\n  while(i<j&&ans){\n    int a=str[++i][pos]-'a',f=(ch==a);\n    if(f&&ni==-1)ni=i-1;\n    if(!f&&ni>=0)mk_mp(pos+1,ni,i-1),ni=-2;\n    \n    if(!f&&c)mk_mp(pos,i,j),mp[ch]|=((1LL<<a)|mp[a]),c=0;\n    if(f&&!c)ans=0;\n    if(f&&str[i-1].size()>str[i].size()&&str[i][pos+1]==0)ans=0;    \n  }\n  if(ni>=0) mk_mp(pos+1,ni,j);\n  \n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<N;i++) mp[i]=0;\n    for(int i=0;i<n;i++)cin>>str[i];\n    ans=1;\n    mk_mp(0,0,n-1);\n    for(int i=0;i<N;i++) if((mp[i]&(1<<i)))ans=0;\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n  int n;\n  while (cin >> n && n){\n    vector<string> vs(n);\n    REP(i, n) cin >> vs[i];\n    \n    bool ok = true;\n    int g[26][26];\n    memset(g, 0, sizeof(g));\n\n    REP(j, n) REP(i, j){\n      \n      REP(k, min(vs[i].size(), vs[j].size())) {\n        if (vs[i][k] != vs[j][k]){\n          g[vs[i][k] - 'a'][vs[j][k] - 'a'] = 1;\n          break;\n        } else if (k + 1 == min(vs[i].size(), vs[j].size()) && vs[i].size() > vs[j].size()){\n          ok = false;\n        }\n      }\n    }\n\n    REP(k, 26)REP(i, 26)REP(j, 26){\n      g[i][j] = g[i][j] || (g[i][k] * g[k][j]);\n    }\n\n    REP(i, 26)REP(j, i){\n      if (g[i][j] && g[j][i]) ok = false;\n    }\n    if (ok){\n      cout << \"yes\" << endl;\n    } else {\n      cout << \"no\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nmap<char,char> id;\nstring s[555];\nchar idlast;\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tidlast='a';\n\t\tid.clear();\n\t\trep(i,n){\n\t\t\tcin>>s[i];\n\t\t\trep(j,s[i].length()){\n\t\t\t\tif(!id.count(s[i][j]))id[s[i][j]]=idlast++;\n\t\t\t}\n\t\t}\n\t\tstring ss[555];\n\t\trep(i,n)rep(j,s[i].length()){\n\t\t\tss[i]+=id[s[i][j]];\n\t\t}\n\t\tbool ok=true;\n\t\trep(i,n-1){\n\t\t\t//dbg(ss[i]);dbg(ss[i+1]);\n\t\t\tif(ss[i]>ss[i+1])ok=false;\n\t\t}\n\t\tif(ok)cout<<\"yes\"<<endl;\n\t\telse cout<<\"no\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* monkukui 競技プログラミング用のテンプレート  (ここから) */\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nusing ll = long long int;\nusing lnt = long long int;\nusing graph = vector<vector<int>>;\nusing wgraph = vector<vector<pair<int, long long int>>>;\nlong long int INF = 1001001001001001LL;\nint inf = 100100100;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\nlong long int di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nlong long int dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = 1; i <= (n); i++)\n#define drep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define srep(i,s,t) for(int i = s; i < t; i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n\n/* monkukui 競技プログラミング用のテンプレート (ここまで)*/\n\nstruct StronglyConnectedComponents {\npublic:\n  const int n;\n  vector<bool> isthrough;\n  vector<int> vs, cmp;\n  vector< vector<int> > G, rG, H; // グラフ、逆辺グラフ、縮約後のグラフ\n\n  StronglyConnectedComponents(vector<vector<int>> &g) :\n    n(g.size()), isthrough(n, false), cmp(n, 0), G(n), rG(n) {\n    for(int i = 0; i < n; i++) {\n      for(size_t j = 0; j < g[i].size(); j++) {\n        G[i].push_back(g[i][j]);\n        rG[g[i][j]].push_back(i);\n      }\n    }\n  }\n\n  void SccDfsOne(int cur) {\n    isthrough[cur] = true;\n    for(size_t i = 0; i < G[cur].size(); i++) {\n      if(!isthrough[G[cur][i]]) {\n        SccDfsOne(G[cur][i]);\n      }\n    }\n    vs.push_back(cur);\n  }\n\n  void SccDfsTwo(vector<int> &vec, int cur, int k) {\n    cmp[cur] = k;\n    isthrough[cur] = true;\n    vec.push_back(cur);\n    for(size_t i = 0; i < rG[cur].size(); i++) {\n      if(!isthrough[rG[cur][i]]) {\n        SccDfsTwo(vec, rG[cur][i], k);\n      }\n    }\n  }\n\n  // 縮約後のグループ、グループ数\n  pair<vector<int>, int> scc() {\n    // 1回めのDFS\n    for(int i = 0; i < n; i++)\n      if(!isthrough[i]) SccDfsOne(i);\n\n    fill(isthrough.begin(), isthrough.end(), false);\n    reverse(vs.begin(), vs.end());\n    int k = 0; vector<vector<int>> S;\n\n    // 2回めのDFS\n    for(size_t i = 0; i < vs.size(); i++) {\n      if(!isthrough[vs[i]]) {\n        S.push_back(vector<int>());\n        SccDfsTwo(S.back(), vs[i], k++);\n      }\n    }\n\n    H.resize(k);\n    fill(isthrough.begin(), isthrough.end(), false);\n    for(size_t i = 0; i < k; i++) {\n      for(size_t j = 0; j < S[i].size(); j++) {\n        int v = S[i][j];\n        for(size_t x = 0; x < G[v].size(); x++) {\n          int u = G[v][x];\n          if(isthrough[cmp[u]] or cmp[v] == cmp[u]) continue;\n          isthrough[cmp[u]] = true;\n          H[cmp[v]].push_back(cmp[u]);\n        }\n      }\n      for(size_t j=0; j<H[i].size(); j++) isthrough[H[i][j]] = false;\n    }\n    return make_pair(cmp, k);\n  }\n};\n\n// 閉路があるか\nbool func(graph g) {\n  \n  StronglyConnectedComponents scc(g);\n  auto hoge = scc.scc();\n  return (hoge.second != g.size());\n  return false;\n}\n\nint main(){\n  \n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    vector<string> vs(n);\n    for(int i = 0; i < n; i++) {\n      cin >> vs[i];\n      vs[i] = vs[i] + '#';\n    }\n\n    graph g(26);\n\n    bool flag = false;\n    for(int i = 0; i < n; i++) {\n      for(int j = i + 1; j < n; j++) {\n        int u = -1;\n        int v = -1;\n        if(vs[i] == vs[j]) continue;\n\n        for(int k = 0; k < min(vs[i].size(), vs[j].size()); k++) {\n          if(vs[i][k] == vs[j][k]) continue;\n\n          // 不一致\n          if(vs[i][k] == '#') continue;\n          if(vs[j][k] == '#') {\n            cout << \"no\" << endl;\n            i += n;\n            j += n;\n            flag = true;\n            break;\n          }\n\n          u = vs[i][k] - 'a';\n          v = vs[j][k] - 'a';\n\n          // u -> v\n          g[u].push_back(v);\n          break;\n        }\n      }\n    }\n\n    if(flag) continue;\n\n    if(func(g)) cout << \"no\" << endl;\n    else        cout << \"yes\" << endl;\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 1e9;\n\nbool has_loop(vector< vector<int> > G){\n  int n = G.size();\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i){\n    if(G[i][i] < INF) return true;\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> S(n);\n    for(int i = 0; i < n; ++i){\n      cin >> S[i];\n    }\n    if(n == 1){\n      cout << \"yes\" << endl;\n      continue;\n    }\n    vector< vector<int> > G(26, vector<int>(26,INF));\n    bool f = true, g = false;\n    for(int i = 1; i < n; ++i){\n      if(S[i-1] == S[i]) continue;\n      for(int j = 0; j < min(S[i].length(),S[i-1].length()); ++j){\n        f = true;\n        if(S[i][j] != S[i-1][j]){\n          //G[S[i-1][j] - 'a'].push_back(S[i][j] - 'a');\n          G[S[i-1][j] - 'a'][S[i][j] - 'a'] = 1;\n          f = false;\n          break;\n        }\n      }\n      if(f && S[i-1].size() > S[i].size()){\n        cout << \"no\" << endl;\n        g = true;\n        break;\n      }else{\n        f = false;\n      }\n    }\n    if(g) continue;\n\n    if(has_loop(G)) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[500];\nint n;\nint m;\nmap<char,vector<P> > li;\nbool f;\n\nvoid check(vector<char> x){\n  int i,j,k=0;\n  \n  for( map<char,vector<P> >::iterator it=li.begin();it!=li.end();++it){\n    //cout << (it->second).size() << \":\" << endl;\n    for(j=0;j<(it->second).size();j++){\n      //cout << j << endl;\n      s[(it->second)[j].first][(it->second)[j].second]=x[k];\n    }\n    k++;\n  }\n  \n  f=true;\n  for(i=0;i<n-1;i++){\n    if(s[i]>s[i+1]){\n      f=false;\n      break;\n    }\n  }\n  \n}\n\n\nint main(){\n  while(cin>>n,n){\n    int i,j,k,c;\n\n    li.clear();\n\n    for(i=0;i<n;i++){\n      s[i]=\"\";\n      cin >> s[i];\n      for(j=0;j<s[i].size();j++){\n\tli[s[i][j]].push_back(P(i,j));\n      }\n    }\n    \n    m=li.size();\n    \n    \n    f=false;\n    \n    vector<char> v;\n    for(i=0;i<m;i++) v.push_back(i+'0');\n    \n    do{\n      check(v);\n      if(f) break;\n    }while(next_permutation(v.begin(), v.end()));\n    \n    if(f) cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n\n    vector<string> S(N);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<bool>> order(26, vector<bool>(26, false));\n    // order[a][b] => a < b\n\n    for (int i = 0; i < N - 1; ++i) {\n        bool diff = false;\n        for (int j = 0; j < min(S[i].length(), S[i + 1].length()); ++j) {\n            if (S[i][j] != S[i + 1][j]) {\n                order[S[i][j] - 'a'][S[i + 1][j] - 'a'] = true;\n                diff = true;\n                break;\n            }\n        }\n\n        if (!diff && S[i].length() > S[i + 1].length()) {\n            cout << \"no\" << endl;\n            return true;\n        }\n    }\n\n    for (int j = 0; j < 26; ++j) {\n        for (int i = 0; i < 26; ++i) {\n            for (int k = 0; k < 26; ++k) {\n                if (order[i][j] && order[j][k]) order[i][k] = true;\n            }\n        }\n    }\n\n    for (int i = 0; i < 26; ++i) {\n        if (order[i][i]) {\n            cout << \"no\" << endl;\n            return true;\n        }\n    }\n    cout << \"yes\" << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\nusing namespace std;\n\nint n;\nstring s[501],ans;\nvector<int> v[28];\nbool visited[28],checked[28];\n\nvoid init(){\n  for(int i=0;i<28;i++){\n    v[i].clear();\n    visited[i]=false;\n    checked[i]=false;\n  }\n}\n\npair<char,char> func(string a,string b){\n  pair<char,char> pcc;\n  a+='A';b+='A';\n  for(int i=0;i<a.length();i++){\n    if(a[i]!=b[i]){\n      pcc.f=a[i];\n      pcc.s=b[i];\n      break;\n    }\n  }\n  return pcc;\n}\n\nvoid dfs(int num){\n  if(visited[num]){\n    ans=\"no\";\n    return;\n  }\n  visited[num]=true;\n  for(int i=0;i<v[num].size();i++){\n    if(!checked[v[num][i]])dfs(v[num][i]);\n  }\n  checked[num]=true;\n  visited[num]=false;\n}\n\nint main()\n{\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++)cin>>s[i];\n    ans=\"yes\";\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(s[i]==s[j])continue;\n\tpair<char,char> pcc=func(s[i],s[j]);\n\tint a,b;\n\tif(pcc.f=='A')a=27;\n\telse a=pcc.f-'a';\n\tif(pcc.s=='A')b=27;\n\telse b=pcc.s-'a';\n\tif(b==27)ans=\"no\";\n\tv[a].push_back(b);\n      }\n    }\n\n    for(int i=0;i<28;i++){\n      if(!checked[i])dfs(i);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> G[26];\nbool g[26];\n\nbool dfs(int now, int pre){\n\tif(g[now] == true) return false;\n\tbool res = true;\n\t//cout << now << endl;\n\tg[now] = true;\n\tset<int> st;\n\tfor(int i = 0; i < G[now].size(); i++){\n\t\tint next = G[now][i];\n\t\t//if(next == pre) continue;\n\t\tif(st.count(next)) continue;\n\t\tst.insert(next);\n\t\tres &= dfs(next, now);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\tfor(int i = 0; i < 26; i++) G[i].clear();\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tvector<string> s(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tbool f = true;\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\t\tif(s[i + 1].size() == j){\n\t\t\t\t\tf = false; break;\n\t\t\t\t}\n\t\t\t\tif(s[i][j] != s[i + \t1][j]){\n\t\t\t\t\tG[s[i][j] - 'a'].push_back(s[i + 1][j] - 'a');\n\t\t\t\t\t//cout << s[i][j] << \"->\" << s[i + 1][j] << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 26; j++){\n\t\t//cout << j << \" \" << f << endl;\n\t\t\tfor(int i = 0; i < 26; i++) g[i] = false;\n\t\t\tf &=  dfs(j, -1);\n\t\t}\n\t\tif(f) cout << \"yes\" << endl;\t\n\t\telse cout << \"no\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\n#define next nxt\n\nint n;\nstring s[555];\nvector<int> next[33];\nbool vis[33];\nint sch;\n\nbool dfs(int v){\n\tvis[v]=true;\n\tbool res=true;\n\trep(i,next[v].size()){\n\t\tint nv=next[v][i];\n\t\tif(nv==sch)res=false;\n\t\tif(vis[nv])continue;\n\t\tif(!dfs(nv))res=false;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\trep(i,n)cin>>s[i];\n\t\trep(i,33)next[i].clear();\n\t\tbool ok=true;\n\t\trep(i,n-1){\n\t\t\tint j=0;\n\t\t\twhile(j<min(s[i].length(),s[i+1].length())&&s[i][j]==s[i+1][j])j++;\n\t\t\tif(j==s[i].length())continue;\n\t\t\tif(j==s[i+1].length()){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!exist(next[s[i][j]-'a'],s[i+1][j]-'a'))next[s[i][j]-'a'].pb(s[i+1][j]-'a');\n\t\t}\n\t\trep(i,33){\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tsch=i;\n\t\t\tif(!dfs(i)){\n\t\t\t\tok=false;\n\t\t\t\t//dbg(i);\n\t\t\t}\n\t\t}\n\t\tif(!ok)cout<<\"no\"<<endl;\n\t\telse cout<<\"yes\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool f;\nbool e[26][26];\nvoid dfs(int x,int d){\n  //cout << x << \":\" << d << endl;\n  if(d>26) {\n    f=false;\n    return;\n  }\n  if(!f) return;\n  for(int i=0;i<26;i++){\n    if(e[x][i]) dfs(i,d+1);\n  }\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    int i,j,k;\n    vector<string> v;\n    string s;\n    memset(e,false,sizeof(e));\n    for(i=0;i<n;i++){\n      cin >> s;\n      v.push_back(s);\n    }\n    f=true;\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n\tif(v[i].find(v[j])==0&&v[i].size()>v[j].size()) f=false;\n\tint x=min(v[i].size(),v[j].size());\n\tfor(k=0;k<x;k++){\n\t  if(v[i][k]==v[j][k]) continue;\n\t  e[v[i][k]-'a'][v[j][k]-'a']=true;\n\t  break;\n\t}\n      }\n    }\n    for(i=0;i<26;i++){\n      dfs(i,0);\n    }\n    if(f) cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\n  typedef vector<int> Vector;\n  typedef vector<Vector> Matrix;\n  typedef queue<int> IntQueue;\n  public:\n    Graph(int size): size_(size), next_(size) {\n    }\n    void add_edge(int a, int b) {\n      next_[a].push_back(b);\n    }\n    bool exists_path(int a, int b) {\n      vector<bool> has_visited(size_, false);\n      IntQueue q;\n      q.push(a);\n      has_visited[a] = true;\n      while (not q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (size_t i = 0; i < next_[x].size(); ++i) {\n          int y = next_[x][i];\n          if (not has_visited[y]) {\n            if (y == b) {\n              return true;\n            }\n            has_visited[y] = true;\n            q.push(y);\n          }\n        }\n      }\n      return false;\n    }\n  private:\n    int size_;\n    Matrix next_;\n};\n\nbool solve(int n, string s[]) {\n  Graph g(26);\n  for (int i = 0; i < n - 1; ++i) {\n    size_t pos = 0;\n    while (s[i][pos] == s[i + 1][pos]) {\n      ++pos;\n    }\n    if (pos == s[i].length()) {\n      continue;\n    } else if (pos == s[i + 1].length()) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  string s[500];\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      return 0;\n    }\n    for (int i = 0; i < n; ++i) {\n      cin >> s[i];\n    }\n    if (solve(n, s)) {\n      cout << \"yes\" << endl;\n    } else {\n      cout << \"no\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    vector<P> dict;\n    \n    char mapping[256];\n    bool used[256];\n    memset(mapping,-1,sizeof(mapping));\n    memset(used,false,sizeof(used));\n\n    for(int i=0;i<N;i++){\n      string str;      \n      cin >> str;\n\n      for(int j=0;j<str.size();j++){\n        if(mapping[str[j]] == -1){\n          for(char alter='a';alter<='z';alter++){\n            if(!used[alter]){\n              mapping[str[j]] = alter;\n              used[alter] = true;\n              break;\n            }\n          }\n        }\n      }\n      \n      string next = \"\";\n      for(int j=0;j<str.size();j++){\n        next.push_back(mapping[str[j]]);\n      }\n      dict.push_back(P(next,i));\n    }\n\n    sort(dict.begin(),dict.end());\n\n    bool isok = true;\n    for(int i=0;i<dict.size();i++){\n      if(dict[i].second != i){\n              isok = false;\n              break;\n      }\n    }\n\n    printf(\"%s\\n\",isok ? \"yes\" : \"no\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 拓真 on 2018/06/24.\n//\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) FOR(i,0,b)\nstring str[510];\n\nbool has_loop(vector<vector<int>> G){\n    int n=G.size();\n    rep(k,n){\n        rep(i,n){\n            rep(j,n){\n                G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n            }\n        }\n    }\n    rep(i,n){\n        if(G[i][i]<1e9)return true;\n    }\n    return false;\n}\n\nint main(){\n    int n;\n    int max_len=0;\n\n    while(cin>>n,n){\n        vector<string> s(n);\n        rep(i,n)cin>>s[i];\n\n        if(n==1){\n            cout<<\"Yes\"<<endl;\n            continue;\n        }\n\n        vector<vector<int>> G(26,vector<int>(26,1e9));\n        bool f=true;\n        for(int i=1;i<n;i++){\n            if(s[i-1]==s[i])continue;\n            rep(j,min(s[i].size(),s[i-1].size())){\n                f=true;\n                if(s[i][j]!=s[i-1][j]){\n                    G[s[i-1][j]-'a'][s[i][j]-'a']=1;\n                    f=false;\n                    break;\n                }\n            }\n\n            if(f&&s[i-1].size()>s[i].size()){\n                cout<<\"no\"<<endl;\n                goto E;\n            }else{\n                f=false;\n            }\n        }\n        if(has_loop(G))cout<<\"no\"<<endl;\n        else cout<<\"yes\"<<endl;\n        E:;\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nvector<int> G[30];\n\nvector<string> arr;\nvector<ii> edges;\nbool found[30];\nbool used[30];\nbool cycle;\n\nbool inValid(string a,string b) {\n  if( a == b ) return false;\n  int diff = -1;\n  rep(i,min(a.size(),b.size())) if( a[i] != b[i] ) { diff = i; break; }\n  if( diff == -1 && a.size() > b.size() ) return true;\n  return false;\n}\n\nvoid add(string a,string b){\n  if( a == b ) return;\n  int diff = -1;\n  rep(i,min(a.size(),b.size())) if( a[i] != b[i] ) { diff = i; break; }\n  if( diff == -1 ) return;\n  edges.push_back(ii(a[diff]-'a',b[diff]-'a'));\n}\n\nbool visit(int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  rep(i,G[v].size()){\n    int e = G[v][i];\n    if(color[e] == 2)continue;\n    if(color[e] == 1)return false;\n    if(!visit(e,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\nbool topologicalSort(vector<int>& order){\n  vector<int> color(26,0); \n  for(int u=0;u<26;u++) if(!color[u] && !visit(u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    rep(i,n) { G[i].clear(); found[i] = used[i] = false;  }\n    bool fin = false;\n    cycle = false;\n    arr.clear();\n    arr.resize(n);\n    edges.clear();\n    rep(i,n) cin >> arr[i];\n    rep(i,n-1) {\n      if( inValid(arr[i],arr[i+1]) ) { puts(\"no\"); fin = true; break; }\n      add(arr[i],arr[i+1]);\n    }\n    if( fin ) continue;\n    rep(i,edges.size()) {\n      int src = edges[i].first;\n      int dst = edges[i].second;\n      G[src].push_back(dst);\n    }\n    vector<int> order;\n    if( !topologicalSort(order) ) { puts(\"no\"); continue; }\n    puts(\"yes\");\n  }\n  return 0;\n}\n\n// same as http://codeforces.com/contest/512/problem/A"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<string> s(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> s[i];\n\t\t}\n\t\tbool ok = true;\n\t\tvector<vector<int>> d(26, vector<int>(26, 1e9));\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint l1 = s[i - 1].size(), l2 = s[i].size();\n\t\t\tint p = 0;\n\t\t\twhile (p < l1 && p < l2 && s[i - 1][p] == s[i][p]) ++p;\n\t\t\tif (p < l1 && p < l2) {\n\t\t\t\td[s[i - 1][p] - 'a'][s[i][p] - 'a'] = -1;\n\t\t\t}\n\t\t\telse if (p < l1) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < 26; k++) {\n\t\t\tfor (int i = 0; i < 26; i++) {\n\t\t\t\tfor (int j = 0; j < 26; j++) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (d[i][i] < 0) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tputs(ok ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> G[26];\nbool g[26];\n\nint d[26][26];\nconst int INF = 1e5;\n\nbool dfs(int now, int pre){\n\tif(g[now] == true) return false;\n\tbool res = true;\n\t//cout << now << endl;\n\tg[now] = true;\n\tset<int> st;\n\tfor(int i = 0; i < G[now].size(); i++){\n\t\tint next = G[now][i];\n\t\t//if(next == pre) continue;\n\t\tif(st.count(next)) continue;\n\t\tst.insert(next);\n\t\tres &= dfs(next, now);\n\t}\n\treturn res;\n}\n\nint n;\n\nvoid wf(){\n\tfor(int k = 0; k < n; k++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tG[i].clear();\n\t\t\tfor(int j = 0; j < 26; j++) d[i][j] = INF;\n\t\t}\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tvector<string> s(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tbool f = true;\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\t\tif(s[i + 1].size() == j){\n\t\t\t\t\tf = false; break;\n\t\t\t\t}\n\t\t\t\tif(s[i][j] != s[i + \t1][j]){\n\t\t\t\t\tG[s[i][j] - 'a'].push_back(s[i + 1][j] - 'a');\n\t\t\t\t\t//cout << s[i][j] << \"->\" << s[i + 1][j] << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\td[i][G[i][j]] = -1;\n\t\t\t}\n\t\t}\n\t\twf();\n\t\tint e[26][26] = {};\n\t\tfor(int i = 0; i < 26; i++) for(int j = 0; j < 26; j++) e[i][j] = d[i][j];\n\t\twf();\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\t//cout << d[i][i] << endl;\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tif(d[i][j] != e[i][j]) f = false;\n\t\t\t}\n\t\t}\n\t\t/*for(int j = 0; j < 26; j++){\n\t\t//cout << j << \" \" << f << endl;\n\t\t\tfor(int i = 0; i < 26; i++) g[i] = false;\n\t\t\tf &=  dfs(j, -1);\n\t\t}*/\n\t\tif(f) cout << \"yes\" << endl;\t\n\t\telse cout << \"no\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint vis[30];\nvector<int> G[30];\nbool valid;\n\nvoid dfs(int now)\n{\n    if(vis[now]==2)\n    {\n        valid=false;\n        return;\n    }\n    else if(vis[now]==0)\n    {\n        vis[now]=2;\n        rep(i,G[now].size()) dfs(G[now][i]);\n\n        vis[now]=1;\n    }\n}\n\nint main()\n{\n    int n;\n    while(cin >>n,n)\n    {\n        vector<string> s(n);\n        rep(i,n) cin >>s[i];\n\n        rep(i,30)\n        {\n            vis[i]=0;\n            G[i].clear();\n            valid=true;\n        }\n\n        rep(i,n)for(int j=i+1; j<n; ++j)\n        {\n            int I=s[i].size(), J=s[j].size();\n            int S=min(I,J);\n\n            int idx=0;\n            while(idx<S)\n            {\n                if(s[i][idx] != s[j][idx]) break;\n                ++idx;\n            }\n\n            if(idx<S)\n            {\n                int from = s[i][idx]-'a', to = s[j][idx]-'a';\n                G[from].pb(to);\n            }\n            else\n            {\n                if(I>J) valid=false;\n            }\n        }\n\n        rep(i,30) dfs(i);\n\n        cout << (valid?\"yes\":\"no\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) FOR(i,0,b)\nstring str[510];\n\nbool has_loop(vector<vector<int>> G){\n    int n=G.size();\n    rep(k,n){\n        rep(i,n){\n            rep(j,n){\n                G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n            }\n        }\n    }\n    rep(i,n){\n        if(G[i][i]<1e9)return true;\n    }\n    return false;\n}\n\nint main(){\n    int n;\n    int max_len=0;\n\n    while(cin>>n,n){\n        vector<string> s(n);\n        rep(i,n)cin>>s[i];\n\n        if(n==1){\n            cout<<\"yes\"<<endl;\n            continue;\n        }\n\n        vector<vector<int>> G(26,vector<int>(26,1e9));\n        bool f=true;\n        for(int i=1;i<n;i++){\n            if(s[i-1]==s[i])continue;\n            rep(j,min(s[i].size(),s[i-1].size())){\n                f=true;\n                if(s[i][j]!=s[i-1][j]){\n                    G[s[i-1][j]-'a'][s[i][j]-'a']=1;\n                    f=false;\n                    break;\n                }\n            }\n\n            if(f&&s[i-1].size()>s[i].size()){\n                cout<<\"no\"<<endl;\n                goto E;\n            }else{\n                f=false;\n            }\n        }\n        if(has_loop(G))cout<<\"no\"<<endl;\n        else cout<<\"yes\"<<endl;\n        E:;\n    }\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nset<int> G[26];\ntypedef set<int>::iterator it;\nint n;\nstring s[505];\nbool flag;\nbool vis[26];\nint in[26];\nint main()\n{\n\twhile(~scanf(\"%d\",&n)&&n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>s[i];\n\t\tfor(int i=0;i<26;i++)\n\t\t\tG[i].clear(),vis[i] = 0,in[i] = 0;\n\t\tflag = true;\n\t\tfor(int x=1;x<n;x++)\n\t\t\tfor(int y=0;y<x;y++)\n\t\t    {\n\t\t\t    int len1 = s[y].size();\n\t\t\t    int len2 = s[x].size();\n\t\t\t    bool flag1 = true;\n\t\t\t    for(int i=0;i<min(len1,len2);i++)\n\t\t\t\t    if(s[y][i]!=s[x][i])\n\t\t\t        {\n\t\t\t    \t    flag1 = false;\n\t\t\t    \t    G[s[y][i]-'a'].insert(s[x][i]-'a');\n\t\t\t    \t    break;\n\t\t\t        }\n\t\t\t    if(flag1&&len1>len2)\n\t\t\t\t    flag = false;\n\t\t    }\n\t\tint cnt = 0;\n\t\tfor(int i=0;i<26;i++)\n\t\t\tfor(it p = G[i].begin();p!=G[i].end();p++)\n\t\t\t    in[*p]++,cnt++;\n\t\twhile(1)\n\t\t{\n\t\t\tbool flag1 = true;\n\t\t\tfor(int i=0;i<26;i++)\n\t\t\t\tif(in[i]==0&&!vis[i])\n\t\t\t\t{\n\t\t\t\t\tflag1 = false;\n\t\t\t\t\tvis[i] = 1;\n\t\t\t\t    for(it p = G[i].begin();p != G[i].end();p++)\n\t\t\t        {\n\t\t\t        \tint v = *p;\n\t\t\t        \tcnt--;\n\t\t\t        \tin[v]--;\n\t\t\t        }\n\t\t\t\t}\n\t\t\tif(flag1) break;\n\t\t}\n\t\tif(cnt!=0) flag = false;\n\t\tputs(flag?\"yes\":\"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nchar ss[510][20];\nbool map[30][30];\nbool v[30];\nint main(){\n\tint n;\n\twhile (scanf(\"%d\", &n) && n){\n\t\tfor (int i = 0; i < n; i ++){\n\t\t\tscanf(\"%s\", ss[i]);\n\t\t\tfor (int j = 0; ss[i][j]; j ++){\n\t\t\t\tss[i][j] -= 'a' - 1;\n\t\t\t}\n\t\t}\n\t\tbool mark = false;\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (int i = 0; i < n; i ++)\n\t\t\tfor (int j = i + 1; j < n; j ++){\n\t\t\t\tfor (int k = 0; ss[i][k] || ss[j][k]; k ++)\n\t\t\t\t\tif (ss[i][k] != ss[j][k]){\n\t\t\t\t\t\tif (ss[i][k] && !ss[j][k])\n\t\t\t\t\t\t\tmark = true;\n\t\t\t\t\t\tif (ss[i][k] && ss[j][k])\n\t\t\t\t\t\t\tmap[ss[i][k]][ss[j][k]] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\tfor (int k = 1; k <= 26; k ++)\n\t\t\tfor (int i = 1; i <= 26; i ++)\n\t\t\t\tfor (int j = 1; j <= 26; j ++)\n\t\t\t\t\tif (map[i][k] && map[k][j])\n\t\t\t\t\t\tmap[i][j] = true;\n\t\tfor (int i = 1; i <= 26; i ++)\n\t\t\tfor (int j = 1; j <= 26; j ++)\n\t\t\t\tif (map[i][j] && map[j][i])\n\t\t\t\t\tmark = true;\n\t\tif (mark)\n\t\t\tputs(\"no\");\n\t\telse\n\t\t\tputs(\"yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nstring arr[501];\nstring arr2[501],arr3[501];\n\n// a 譏ッ b 逧?燕郛?inline bool startswith(const string &a, const string &b)\n{\n    if (a.size()>b.size()) return false;\n    if (a==b.substr(0,a.size())) return true;\n    return false;\n}\n\nbool cmp(const string &a, const string &b) { if (startswith(a,b)) return true; else  return a>b;}\n\nint main()\n{\n    int n;\n\n//freopen(\"fuck.in\",\"r\",stdin);\n\n    ios::sync_with_stdio(false);\n    while (cin>>n && n!=0)\n    {\n        bool right1=true, right2=true;\n\n        for (int i=0; i<n; i++)\n        {\n            cin>>arr[i];\n            arr2[i]=arr3[i]=arr[i];\n        }\n\n        sort(arr2,arr2+n);\n        sort(arr3,arr3+n,cmp);\n\n        for (int i=0; i<n; i++)\n        {\n            if (arr[i]!=arr2[i]) {right1=false; break;}\n        }\n        for (int i=0; i<n; i++)\n        {\n            if (arr[i]!=arr3[i]) {right2=false; break;}\n        }\n\n        if (right1 || right2)\n        {\n            cout<<\"yes\\n\";\n        }\n        else\n        {\n            cout<<\"no\\n\";\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint n;\nstring str[555];\n\nmap< char, set< char > > arc;\nvector< bool > vis;\n\nbool dfs(char c) {\n\t//cerr << c << endl;\n\tif (vis[c - 'a']) return true;\n\tvis[c - 'a'] = true;\n\t\n\tfor (char nc : arc[c]) if (dfs(nc)) return true;\n\t\n\tvis[c - 'a'] = false;\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tfor_(i,1,n) {\n\t\tfor_(j,0,i) {\n\t\t\tif (str[j].size() <= str[i].size()) continue;\n\t\t\t\n\t\t\tif (str[j].substr(0, str[i].size()) == str[i]) {\n\t\t\t\tcout << \"no\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(k,0,10) {\n\t\tint p = -1;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tif ((int)str[i].size() < k + 1) continue;\n\t\t\t\n\t\t\tif (p != -1) {\n\t\t\t\tif (str[p].substr(0, k) == str[i].substr(0, k)) {\n\t\t\t\t\tif (str[p][k] != str[i][k]) {\n\t\t\t\t\t\tarc[str[i][k]].insert(str[p][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tp = i;\n\t\t}\n\t}\n\t\n\tfor_(i,0,26) {\n\t\t//cerr << \"-----\" << endl;\n\t\tif (dfs('a' + i)) {\n\t\t\tcout << \"no\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tcout << \"yes\" << endl;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor_(i,0,n) cin >> str[i];\n\t\tarc.clear();\n\t\tvis.assign(26, false);\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nvector<int> G[510];\n\nvector<string> arr;\nvector<ii> edges;\nbool found[510];\nbool used[510];\nbool cycle;\n\nbool inValid(string a,string b) {\n  if( a == b ) return false;\n  int diff = -1;\n  rep(i,min(a.size(),b.size())) if( a[i] != b[i] ) { diff = i; break; }\n  if( diff == -1 && a.size() > b.size() ) return true;\n  return false;\n}\n\nvoid add(string a,string b){\n  if( a == b ) return;\n  int diff = -1;\n  rep(i,min(a.size(),b.size())) if( a[i] != b[i] ) { diff = i; break; }\n  if( diff == -1 ) return;\n  edges.push_back(ii(a[diff]-'a',b[diff]-'a'));\n}\n\nbool visit(int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  rep(i,G[v].size()){\n    int e = G[v][i];\n    if(color[e] == 2)continue;\n    if(color[e] == 1)return false;\n    if(!visit(e,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\nbool topologicalSort(vector<int>& order){\n  vector<int> color(26,0); \n  for(int u=0;u<26;u++) if(!color[u] && !visit(u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    rep(i,510) { G[i].clear(); found[i] = used[i] = false;  }\n    bool fin = false;\n    cycle = false;\n    arr.clear();\n    arr.resize(n);\n    edges.clear();\n    rep(i,n) cin >> arr[i];\n    rep(i,n-1) {\n      if( inValid(arr[i],arr[i+1]) ) { puts(\"no\"); fin = true; break; }\n      add(arr[i],arr[i+1]);\n    }\n    if( fin ) continue;\n    rep(i,edges.size()) {\n      int src = edges[i].first;\n      int dst = edges[i].second;\n      G[src].push_back(dst);\n    }\n    vector<int> order;\n    if( !topologicalSort(order) ) { puts(\"no\"); continue; }\n    puts(\"yes\");\n  }\n  return 0;\n}\n\n// same as http://codeforces.com/contest/512/problem/A "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nstring S[500]; bool W[26][26]; int n;\nvector<int>X[26];\nbool SearchingHeiro(int m) {\n\tint dist[1000];\n\tfor (int i = 0; i < m; i++) {\n\t\tqueue<int>Q;\n\t\tfor (int j = 0; j < m; j++)dist[j] = 0;\n\t\tQ.push(i); int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tcnt++; int a1 = Q.front(); Q.pop();\n\t\t\tif (cnt >= 100000) { return true; }\n\t\t\tfor (int j = 0; j < X[a1].size(); j++) {\n\t\t\t\tif (dist[X[a1][j]] > dist[a1] - 1) {\n\t\t\t\t\tdist[X[a1][j]] = dist[a1] - 1;\n\t\t\t\t\tQ.push(X[a1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nbool solve() {\n\tfor (int i = 0; i < 676; i++) { X[i / 26].clear(); W[i / 26][i % 26] = false; }\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint Y = min(S[i].size(), S[j].size());\n\t\t\tfor (int k = 0; k < Y + 1; k++) {\n\t\t\t\tif (k == Y) {\n\t\t\t\t\tif (S[i].size() > S[j].size())return false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (S[i][k] > S[j][k]) { W[S[i][k] - 'a'][S[j][k] - 'a'] = true; break; }\n\t\t\t\tif (S[i][k] < S[j][k]) { W[S[i][k] - 'a'][S[j][k] - 'a'] = true; break; }\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 26; i++) {\n\t\tfor (int j = 0; j < 26; j++) {\n\t\t\tif (W[i][j] == true)X[i].push_back(j);\n\t\t}\n\t}\n\tif (SearchingHeiro(26) == true)return false;\n\treturn true;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)cin >> S[i];\n\t\tbool ans = solve();\n\t\tif (ans == true)cout << \"yes\" << endl;\n\t\tif (ans == false)cout << \"no\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<string,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n\nint gcd(int x,int y){\n\tif(x<y) return gcd(y,x);\n\tif(x==y) return x;\n\tif(x%y==0) return y;\n\treturn gcd(y,x%y);\n}\n class pa2{\n                                            public:\n                                            int x,y;\n                                            pa2(int x=0,int y=0):x(x),y(y) {}\n                                            pa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            pa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            bool operator < (const pa2 &p) const{\n                                                return x != p.x ? x<p.x: y<p.y;\n                                            }\n\t\t\t\t\t\t\t\t\t\t \t bool operator > (const pa2 &p) const{\n                                                return x != p.x ? x>p.x: y>p.y;\n                                            }\n                                            bool operator == (const pa2 &p) const{\n                                                return abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            }\n                                            bool operator != (const pa2 &p) const{\n                                                return !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            }\n                                                 \n                                         \n                                        };\n\n/*　　　---memo---\nadd_edge(始点,終点,youryou ,コスト)で枝追加\nmin_cost_flow(始点,終点,ryou)でhiyouをintで返す\n*/\nint n;\nstring s[510];\nvector<int> G[30];\nint shutu[30];\nint rin[30][30];\nqueue<int> qu;\n     signed main(){\n     \twhile(1){\n     \tcin>>n;\n     \t\tif(n==0) return 0;\n     \t\tfor(int i=0;i<n;i++)cin>>s[i];\n     \t\tif(n==1) {\n     \t\tcout<<\"yes\"<<endl;\n     \t\t\tcontinue;\n     \t\t}\n     \t\t\n bool bo=true;\n     \t\t\n     \t\tfor(int i=0;i<30;i++){\n     \t\t\tG[i].clear();\n     \t\t\tshutu[i]=0;\n     \t\t\tfor(int j=0;j<30;j++)rin[i][j]=0;\n     \t\t}\n     \t\t\n     \t\tfor(int i=0;i<n-1;i++){\n     \t\t\tint l1=s[i].length(),l2=s[i+1].length();\n     \t\t\tif(s[i]==s[i+1]) continue;\n     \t\t\tif(l1<l2){\n     \t\t\t\tif(s[i+1].substr(0,l1)==s[i]) continue;\n     \t\t\t}\n     \t\t\tif(l1>l2){\n     \t\t\t\tif(s[i].substr(0,l2)==s[i+1]){\n     \t\t\t\t\tbo=false;\n     \t\t\t\t\tcontinue;\n     \t\t\t\t}\n     \t\t\t}\n     \t\t\t\n     \t\t\tfor(int j=0;;j++)if(s[i][j]!=s[i+1][j]){\n     \t\t\t\trin[s[i][j]-'a'][s[i+1][j]-'a']=1;\n     \t\t\t\tbreak;\n     \t\t\t}\n     \t\t\t\n     \t\t}\n     \t\tif(!bo) {\n     \t\t\tcout<<\"no\"<<endl;\n     \t\t\tcontinue;\n     \t\t}\n     \t\t\n     \t\tfor(int i=0;i<26;i++)for(int j=0;j<26;j++)if(rin[i][j]){\n     \t\t\tG[i].pb(j);\n     \t\t\tshutu[j]++;\n     \t\t}\n     \t\t\n     \t\tfor(int i=0;i<26;i++)if(shutu[i]==0) qu.push(i);\n     \t\tvector<int> ve;\n     \t\twhile(qu.size()>0){\n     \t\t\tint r=qu.front();\n     \t\t\tqu.pop();\n     \t\t\tve.pb(r);\n     \t\t\tfor(auto v:G[r]){\n     \t\t\t\tshutu[v]--;\n     \t\t\t\tif(shutu[v]==0) qu.push(v);\n     \t\t\t}\n     \t\t}\n     \t\t\n     \t\tif(ve.size()==26) cout<<\"yes\"<<endl;\n     \t\telse cout<<\"no\"<<endl;\n     \t}\n    \n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint degree[30]; // テ暗ォ\nint n;\nint grid[30][30];\nchar str[550][20];\nint vis[30];\nint que[30];\nint main()\n{\n    while(scanf(\"%d\", &n))\n    {\n        if(n == 0)\n            break;\n        memset(degree, 0, sizeof(degree));\n        memset(grid, 0, sizeof(grid));\n        memset(vis, 0, sizeof(vis));\n        scanf(\"%s\", str[0]);\n        bool flag = true;\n        for(int i = 1; i < n; i++)\n        {\n            scanf(\"%s\", str[i]);\n            int len1 = strlen(str[i-1]);\n            int len2 = strlen(str[i]);\n            int j;\n            for( j = 0; j < len1 && j < len2 ; j++)\n            {\n                if(str[i-1][j] != str[i][j])\n                {\n                    int a = str[i-1][j] - 'a';\n                    int b = str[i][j] - 'a';\n                    if(!vis[a])\n                    {\n                        vis[a] = 1;\n                    }\n                    if(!vis[b])\n                    {\n                        vis[b] = 1;\n                    }\n                    if(grid[a][b] == 0)\n                    {\n                        degree[b]++;\n                        grid[a][b] = 1;\n                    }\n                    break;\n                }\n            }\n            if(j == len2 && j< len1)\n            {\n                flag = false;\n            }\n        }\n        if(n == 1)\n        {\n            printf(\"yes\\n\");\n            continue;\n        }\n        if(!flag)\n        {\n            printf(\"no\\n\");\n            continue;\n        }\n        int l = 0, r = 0;\n        for(int i = 0; i < 30; i++)\n            if(vis[i] && degree[i] == 0)\n            {\n                que[r++] = i;\n            }\n        if(r == 0)\n        {\n            printf(\"no\\n\");\n            continue;\n        }\n       // printf(\"---------\\n\");\n        while(l < r)\n        {\n            int u = que[l++];\n            degree[u] = -1;\n            for(int i = 0; i < 30; i++)\n            {\n                if(vis[i] && grid[u][i] && degree[i] != -1)\n                {\n                    degree[i]--;\n                    if(degree[i] == 0)\n                    {\n                        que[r++] = i;\n                    }\n                }\n            }\n        }\n        for(int i = 0; i < 30; i++)\n            {\n                if(degree[i] != -1  && vis[i])\n                {\n                    flag = false;\n                    break;\n                }\n            }\n        if(!flag)\n            printf(\"no\\n\");\n        else\n            printf(\"yes\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nvoid solve(){\n\twhile (true){\n\t\tstarter:;\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return;\n\t\tint dist[27][27] = {};\n\t\tvector<string> inputs;\n\t\tREP(i, n) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tinputs.push_back(s);\n\t\t}\n\t\tfor (int i = 1; i < inputs.size(); ++i) {\n\t\t\tint ok = 0;\n\t\t\tREP(q, min(inputs[i-1].size(),inputs[i].size())) {\n\t\t\t\tif (inputs[i][q] != inputs[i - 1][q]) {\n\t\t\t\t\tdist[inputs[i - 1][q] - 'a'][inputs[i][q] - 'a'] = 1;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok == 0) {\n\t\t\t\tif (inputs[i - 1].length() > inputs[i].length()) {\n\t\t\t\t\tcout << \"no\" << endl;\n\t\t\t\t\tgoto starter;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(t, 3) {\n\t\t\tREP(i, 26) {\n\t\t\t\tREP(q, 26) {\n\t\t\t\t\tREP(j, 26) {\n\t\t\t\t\t\tif(dist[i][j] != 0&&dist[j][q] != 0)\n\t\t\t\t\t\tdist[i][q] = max(dist[i][q], dist[i][j] + dist[j][q]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint copy_dist[27][27];\n\t\tREP(i, 27) {\n\t\t\tREP(q, 27) {\n\t\t\t\tcopy_dist[i][q] = dist[i][q];\n\t\t\t}\n\t\t}\n\t\tREP(t, 3) {\n\t\t\tREP(i, 26) {\n\t\t\t\tREP(q, 26) {\n\t\t\t\t\tREP(j, 26) {\n\t\t\t\t\t\tif (dist[i][j] != 0 && dist[j][q] != 0)\n\t\t\t\t\t\t\tdist[i][q] = max(dist[i][q], dist[i][j] + dist[j][q]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ok = 1;\n\t\tREP(i, 26) {\n\t\t\tREP(q, 26) {\n\t\t\t\tif (dist[i][q] != copy_dist[i][q]) ok = 0;\n\t\t\t}\n\t\t}\n\t\tstring ans[2] = { \"no\",\"yes\" };\n\t\tcout << ans[ok] << endl;\n\t}\n}\n\n#undef int\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nconst int SIZE='z'-'a'+1;\nbool solve(int n){\n    vector<string> s(n);\n    for(int i=0;i<n;i++) cin>>s[i];\n    Graph g(SIZE);\n    for(int i=0;i+1<n;i++){\n        for(int j=0;j<=min(s[i].size(),s[i+1].size());j++){\n\n            if(j==min(s[i].size(),s[i+1].size())){\n                if(s[i].size()<=s[i+1].size()){\n                    break;\n                }\n                else{\n                    return false;\n                }\n            }\n            if(s[i][j]!=s[i+1][j]){\n                g[s[i][j]-'a'].push_back(s[i+1][j]-'a');\n                break;\n            }\n        }\n    }\n\n    queue<int> que;\n    vector<int> d(SIZE);\n    for(int i=0;i<SIZE;i++) for(int j=0;j<g[i].size();j++) d[g[i][j]]++;\n    for(int i=0;i<SIZE;i++) if(d[i]==0) que.push(i);\n    int cnt=0;\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        cnt++;\n        for(int i=0;i<g[v].size();i++){\n            d[g[v][i]]--;\n            if(d[g[v][i]]==0){\n                que.push(g[v][i]);\n            }\n        }\n    }\n    return cnt==SIZE;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<(solve(n) ? \"yes\" : \"no\")<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nstring arr[501];\nstring arr2[501],arr3[501];\n\n\n\nbool cmp(const string &a, const string &b)\n{\n    if (a.size()>b.size()) return a>b;\n    if (a==b.substr(0,a.size())) return true;\n  return a>b;\n }\n\nint main()\n{\n    int n;\n\n//freopen(\"fuck.in\",\"r\",stdin);\n\n    ios::sync_with_stdio(false);\n    while (cin>>n and n!=0)\n    {\n        bool right1=true, right2=true;\n\n        for (int i=0; i<n; i++)\n        {\n            cin>>arr[i];\n            arr2[i]=arr3[i]=arr[i];\n        }\n\n        sort(arr2,arr2+n);\n        sort(arr3,arr3+n,cmp);\n\n        for (int i=0; i<n; i++)\n        {\n            if (arr[i]!=arr2[i]) {right1=false; break;}\n        }\n        for (int i=0; i<n; i++)\n        {\n            if (arr[i]!=arr3[i]) {right2=false; break;}\n        }\n\n        if (right1 or right2)\n        {\n            cout<<\"yes\\n\";\n        }\n        else\n        {\n            cout<<\"no\\n\";\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\n  typedef vector<int> Vector;\n  typedef vector<Vector> Matrix;\n  typedef queue<int> IntQueue;\n  public:\n    Graph(int size): size_(size), next_(size) {\n    }\n    void add_edge(int a, int b) {\n      if (0 <= a and a < size_ and 0 <= b and b < size_) {\n        next_[a].push_back(b);\n      } else {\n        while (true) {\n          a += 1;\n        }\n      }\n    }\n    bool exists_path(int a, int b) {\n      vector<bool> has_visited(size_, false);\n      IntQueue q;\n      q.push(a);\n      has_visited[a] = true;\n      while (not q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (size_t i = 0; i < next_[x].size(); ++i) {\n          int y = next_[x][i];\n          if (not has_visited[y]) {\n            if (y == b) {\n              return true;\n            }\n            has_visited[y] = true;\n            q.push(y);\n          }\n        }\n      }\n      return false;\n    }\n  private:\n    int size_;\n    Matrix next_;\n};\n\nbool solve(int n, string s[]) {\n  Graph g(26);\n  for (int i = 0; i < n - 1; ++i) {\n    size_t pos = 0;\n    while (s[i][pos] == s[i + 1][pos]) {\n      ++pos;\n    }\n    if (pos == s[i].length()) {\n      continue;\n    } else if (pos == s[i + 1].length()) {\n      return false;\n    }\n    g.add_edge(s[i][pos] - 'a', s[i + 1][pos] - 'a');\n    for (int i = 0; i < 26; ++i) {\n      for (int j = i + 1; j < 26; ++j) {\n        if (g.exists_path(i, j) and g.exists_path(j, i)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  string s[500];\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      return 0;\n    }\n    for (int i = 0; i < n; ++i) {\n      cin >> s[i];\n    }\n    if (solve(n, s)) {\n      cout << \"yes\" << endl;\n    } else {\n      cout << \"no\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nusing graph = vector<vector<int>>;\n \nvoid dfs(int v, const graph& G, vector<int>& res, vector<int>& used) {\n    used[v] = 1;\n    for (auto to : G[v]) if (used[to] == 0) {\n        dfs(to, G, res, used);\n    }\n    res.push_back(v);\n    //cout<<v<<endl;\n}\n \nvector<int> topo_sort(const graph& G) {\n    int V = G.size();\n    vector<int> ide(V);\n    for (int i = 0; i < V; i++) {\n        for (auto to : G[i]) {\n            //cout<<to<<endl;\n            ide[to]++;\n        }\n    }\n    vector<int> res;\n    vector<int> used(V);\n    for (int i = V - 1; i >= 0; i--) {\n        if (ide[i] == 0) {\n            //cout<<i<<endl;\n            dfs(i, G, res, used);\n        }\n    }\n    if(res.size()==0) res={-1};\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        if(n==1){\n            cout<<\"yes\"<<endl;\n            continue;\n        }\n        vector<string> s(n);\n        for(int i=0;i<n;i++) cin>>s[i];\n        graph g(26);\n        for(int i=1;i<n;i++){\n            int len=min(s[i-1].length(),s[i].length());\n            for(int j=0;j<len;j++){\n                if(s[i-1][j]==s[i][j]) continue;\n                int st=s[i-1][j]-'a',gt=s[i][j]-'a';\n                g[st].push_back(gt);\n                break;\n            }\n        }\n        vector<int> res=topo_sort(g);\n        //cout<<res.size()<<endl;\n        if(res.size()!=26){\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        map<int,int> mp;\n        for(int i=0;i<26;i++){\n            mp[res[i]]=i;\n        }\n        for(int i=0;i<n;i++){\n            int len=s[i].length();\n            for(int j=0;j<len;j++){\n                int idx=s[i][j]-'a';\n                idx=mp[idx];\n                s[i][j]='a'+idx;\n            }\n        }\n        bool f=true;\n        for(int i=1;i<n;i++){\n            if(s[i-1]>s[i]) f=false;\n        }\n        if(f) cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[501];\nint d[26][26],n;\nint main(){\n  while(cin>>n,n){\n    int ans=0,f=0;\n    memset(d,0,sizeof(d));\n    r(i,n)cin>>s[i];\n    r(i,n-1){\n      r(j,s[i].size()){\n        if(j>=s[i+1].size()){f++;break;}\n        if(s[i][j]!=s[i+1][j]){\n            d[s[i][j]-'a'][s[i+1][j]-'a']=-1;\n            break;\n        }\n      }\n    }\n    r(k,26)r(i,26)r(j,26)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    r(i,26)if(d[i][i]<0)ans++;\n    cout<<(ans||f?\"no\":\"yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        vector<string> S(N);\n        for(auto &s:S) cin>>s;\n        int G[N][N];\n        fill(G[0],G[N],0);\n        bool flag=true;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                string s1=S[i], s2=S[j];\n                if(s1==s2) continue;\n                for(int ite=0;ite<max(s1.size(),s2.size());ite++){\n                    if(ite>=s2.size()){\n                        flag=false;\n                        break;\n                    }else{\n                        if(ite>=s1.size()) break;\n                        else{\n                            if(s1[ite]==s2[ite]) continue;\n                            else{\n                                G[s1[ite]-'a'][s2[ite]-'a']=1;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    G[i][j]|=G[i][k]&G[k][j];\n                }\n            }\n        }\n        for(int i=0;i<N;i++){\n            if(G[i][i]) flag=false;\n        }\n        cout<<(flag?\"yes\":\"no\")<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nvector<bool> m1, m2;\nvector<bool> reached;\nvector< vector<int> > G;\nbool dp(int v) {\n\tbool res = false;\n\tif (m1[v]) return m2[v];\n\tif (reached[v]) res = true;\n\telse {\n\t\treached[v] = true;\n\t\tEACH(to, G[v]) {\n\t\t\tres |= dp(to);\n\t\t}\n\t\treached[v] = false;\n\t}\n\treturn m1[v] = true, m2[v] = res;\n}\nbool check(const vector<string>& s) {\n\tmap<char, int> tbl;\n\tfor (char c = 'a'; c <= 'z'; ++c) tbl[c] = (int)(c-'a');\n\tint N = 26;\n\tG = vector< vector<int> >(N);\n\tREP(i, s.size()) FOR(j, i+1, s.size()) {\n\t\tif (s[i] == s[j]) continue;\n\t\tif (s[i].size() > s[j].size() && s[i].substr(0, s[j].size()) == s[j]) return false;\n\t\tREP(k, min(s[i].size(), s[j].size())) {\n\t\t\tif (s[i][k] != s[j][k]) {\n\t\t\t\tG[tbl[s[i][k]]].pb(tbl[s[j][k]]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tm1 = vector<bool>(N, false);\n\tm2 = vector<bool>(N, false);\n\treached = vector<bool>(N, false);\n\tREP(i, N) if ( dp(i) ) return false;\n\treturn true;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<string> s(N); cin >> s;\n\t\tvector<string> ss = s; reverse(ALL(ss));\n\t\tif ( check(s) ) cout << \"yes\" << endl;\n\t\telse cout << \"no\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    vector<P> dict;\n    \n    char mapping[256];\n    bool used[256];\n    memset(mapping,0,sizeof(mapping));\n    memset(used,false,sizeof(used));\n\n    for(int i=0;i<N;i++){\n      string str;      \n      cin >> str;\n\n      for(int j=0;j<str.size();j++){\n        if(mapping[str[j]] == 0){\n          for(char alter='a';alter<='z';alter++){\n            if(!used[alter]){\n              mapping[str[j]] = alter;\n              used[alter] = true;\n              break;\n            }\n          }\n        }\n      }\n      \n      string next = \"\";\n      for(int j=0;j<str.size();j++){\n        next.push_back(mapping[str[j]]);\n      }\n      dict.push_back(P(next,i));\n    }\n\n    sort(dict.begin(),dict.end());\n\n    bool isok = true;\n    for(int i=0;i<dict.size();i++){\n      if(dict[i].second != i){\n              isok = false;\n              break;\n      }\n    }\n\n    printf(\"%s\\n\",isok ? \"yes\" : \"no\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN=555;\nint n;\nchar str[MAXN][22];\nint vis[255][255];\nint in[255];\nqueue<int> q;\n\nbool topsort()\n{\n    while(!q.empty())   q.pop();\n    for(int i=0;i<255;i++)  if(in[i]==0)   q.push(i);\n    int num=0;\n    while(!q.empty())\n    {\n        int u=q.front();q.pop();num++;\n        for(int i=0;i<255;i++)\n            if(vis[u][i]==1)\n            {\n                in[i]--;\n                if(in[i]==0)   q.push(i);\n            }\n    }\n    return num==255;\n}\n\nbool check()\n{\n    memset(vis,0,sizeof vis);memset(in,0,sizeof in);\n    for(int i=2;i<=n;i++)\n    {\n        for(int j=0;str[i][j] || str[i-1][j];j++)\n        {\n            if(str[i][j]==str[i-1][j])  continue;\n            if(!str[i][j])    return false;\n            int x=(int)(str[i-1][j]-'a');\n            int y=(int)(str[i][j]-'a');\n            if(x>30 || y>30)    while(1){}\n            if(vis[y][x])   return false;\n            if(!vis[x][y])\n            {\n                vis[x][y]=1;\n                in[y]++;\n            }\n            break;\n        }\n    }\n    return topsort();\n}\n\n\nint main()\n{\n    //freopen(\"data.txt\",\"r\",stdin);\n    while(scanf(\"%d\",&n)==1 && n)\n    {\n        memset(str,0,sizeof str);\n        for(int i=1;i<=n;i++)\n            scanf(\"%s\",str[i]);\n        if(check())\n            puts(\"yes\");\n        else\n            puts(\"no\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N ('z'-'a')\nusing namespace std;\nint n,ans,mp[N+1];\nstring str[501];\n\nvoid mk_mp(int pos,int i,int j){\n  while(i<=j&&!str[i][pos])i++;\n  if(i>=j)return;\n  int ni=i,ch=str[i][pos]-'a';\n\n  while(i<j&&ch==str[++i][pos]-'a')if(str[i-1][pos+1]&&!str[i][pos+1])ans=0;\n  mk_mp(pos+1,ni,i-1);\n\n  int a=str[i][pos]-'a';\n  if(ch!=a){\n    mk_mp(pos,i,j);\n    mp[ch]|=(1<<a|mp[a]);\n    ans*=!(mp[ch]&1<<ch);\n  }\n\n}\n\nint main(){\n  while(cin>>n,n){\n    memset(mp,0,sizeof(mp));\n    for(int i=0;i<n;i++)cin>>str[i];\n    ans=1;\n    mk_mp(0,0,n-1);\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <string>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAXN = 500 + 10;\n\nstring str[MAXN];\nstring temp[MAXN];\nint c[30][30];\n\nvoid input()\n{\n    int n;\n\n    while (scanf(\"%d\", &n) != EOF)\n    {\n        if (n == 0) break;\n        memset(c, 0, sizeof(c));\n\n        for (int i = 0; i < n; i++)\n        {\n            cin >> str[i];\n        }\n\n        bool flag = true;\n\n        for (int i = 0; i < n - 1; i++)\n        {\n            int len1 = str[i].length(), len2 = str[i + 1].length();\n\n            if (flag == false) break;\n\n\n            int k;\n            for (k = 0; k < len1 && k < len2; k++)\n            {\n                if (str[i][k] != str[i + 1][k])\n                {\n                    if (c[str[i + 1][k] - 'a'][str[i][k] - 'a'])\n                    {\n                        flag = false;\n                        break;\n                    }\n                    c[str[i][k] - 'a'][str[i + 1][k] - 'a'] = 1;\n                    break;\n                }\n            }\n            if (k == len2 && k < len1)\n            {\n                flag = 0;\n                break;\n            }\n            //cout << (str[i][k] - 'a') << ' ' << (str[i + 1][k] - 'a') << endl;\n        }\n\n        printf(\"%s\\n\", flag ? \"yes\" : \"no\");\n    }\n}\n\nint main()\n{\n    input();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 文字に適切な順序を定めて、入力が辞書順になるようにできるか\n// 適当に辺を貼って閉路見つける\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring s[500];\nbool f[500][500];\nbool g[27][27];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tmemset(f, 0, sizeof(f));\n\t\tmemset(g, 0, sizeof(g));\n\t\tfor (int i = 1; i < 27; i++){\n\t\t\tg[0][i] = true;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t\ts[i] += 'a' - 1;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= 10; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tfor (int k = j + 1; k < n; k++){\n\t\t\t\t\tif (f[j][k]) continue;\n\t\t\t\t\tif (i >= min(s[j].size(), s[k].size())) continue;\n\t\t\t\t\tif (s[j][i] != s[k][i]){\n\t\t\t\t\t\tg[s[j][i] - 'a' + 1][s[k][i] - 'a' + 1] = true;\n\t\t\t\t\t\tf[j][k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 27; k++){\n\t\t\tfor (int i = 0; i < 27; i++){\n\t\t\t\tfor (int j = 0; j < 27; j++){\n\t\t\t\t\tg[i][j] |= g[i][k] && g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool res = true;\n\t\tfor (int i = 0; i < 27; i++){\n\t\t\tif (g[i][i]) res = false;\n\t\t}\n\t\t\n\t\tcout << (res ? \"yes\" : \"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint n;\nstring S[512];\nvector<int>G[32];\n\nint dfs(int p, int d){\n  if(d>26) return 0;\n  for(auto g:G[p]){\n    if(!dfs(g, d+1)) return 0;\n  }\n  return 1;\n}\n\nint solve()\n{\n  rep(i, 26) G[31].push_back(i);\n  rep(i, n-1){\n    //    cout << i << endl;\n    int p = 0;\n    string s=S[i], t = S[i+1];\n    while(1){\n      if(s[p] == '\\0') break;\n      if(t[p] == '\\0') return 0;\n      if(s[p] != t[p]){\n\tif(find(begin(G[s[p]-'a']), end(G[s[p]-'a']), t[p]-'a')\n\t   == end(G[s[p]-'a']))\n\t   G[s[p]-'a'].push_back(t[p]-'a');\n\tbreak;\n      }\n      p++;\n    }\n  }\n  return dfs(31, 0);\n}\n\nint main()\n{\n  while(1){\n    cin >> n;\n    if(n == 0) return 0;\n    rep(i, 32) G[i].clear();\n\n    rep(i, n) cin >> S[i];\n\n    cout << (solve()?\"Yes\\n\":\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nvector<vector<bool>> edge(27,vector<bool>(27,false));\n\n//強連結成分分解\nclass SCC{\npublic:\n    vector<vector<ll>> E;\n    vector<vector<ll>> rev;\n    ll V;\n    vector<ll> v;\n    vector<ll> group;\n    \n    void dfs(ll where,ll &count){\n        v[where]=-2;\n        for(int i=0;i<E[where].size();i++){\n            ll t=E[where][i];\n            if(v[t]!=-1){continue;}\n            dfs(t,count);\n        }\n        v[where]=count;\n        count++;\n    }\n    \n    void first(){\n        ll count=0;\n        for(int i=0;i<V;i++){\n            if(v[i]==-1){dfs(i,count);}\n        }\n    }\n    \n    void rev_dfs(ll where,ll count){\n        group[where]=count;\n        for(int i=0;i<rev[where].size();i++){\n            ll t=rev[where][i];\n            if(group[t]!=-1){continue;}\n            rev_dfs(t,count);\n        }\n    }\n    \n    void second(){\n        vector<pll> number;\n        for(int i=0;i<V;i++){\n            number.push_back({v[i],i});\n        }\n        sort(number.begin(),number.end(),greater<pll>());\n        ll count=0;\n        for(int i=0;i<V;i++){\n            ll where=number[i].S;\n            if(group[where]==-1){\n                rev_dfs(where,count);\n                count++;\n            }\n        }\n    }\n    \n    void clear(ll a){\n        for(ll i=a;i<V;i++){\n            v[i]=-1;\n            group[i]=-1;\n        }\n    }\n    \n\n    SCC(ll V=0):V(V){\n        v.resize(V,-1);\n        E.resize(V);\n        rev.resize(V);\n        group.resize(V,-1);\n    }\n    \n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n        rev[to].push_back(from);\n    }\n    \n    void add_node(){\n        V++;\n        v.resize(V);\n        E.resize(V);\n        rev.resize(V);\n        group.resize(V);\n    }\n    \n    void add_node(ll number){\n        V+=number;\n        v.resize(V);\n        E.resize(V);\n        rev.resize(V);\n        group.resize(V);\n    }\n    \n    vector<ll> solve(){\n        clear();\n        first();\n        second();\n        return group;\n    }\n    \n    //グラフの形を保ったまま初期化\n    void clear(){\n        for(int i=0;i<V;i++){\n            v[i]=-1;\n            group[i]=-1;\n        }\n    }\n};\n\n\n\nint main(){\n    while(1){\n    for(int i=0;i<27;i++){\n        for(int t=0;t<27;t++){\n            edge[i][t]=false;\n        }\n    }\n    ll n;\n    cin>>n;\n        if(n==0){break;}\n    vector<string> a(n);\n    for(auto &i:a){cin>>i;}\n    for(int i=0;i<26;i++){\n        edge[26][i]=true;\n    }\n    for(int i=1;i<n;i++){\n        if(a[i]==a[i-1]){continue;}\n        int t=0;\n        while(t<a[i].size() && t<a[i-1].size() && a[i][t]==a[i-1][t]){t++;}\n        if(t==a[i].size()){edge[a[i-1][t]-'a'][26]=true;}\n        else if(t==a[i-1].size()){edge[26][a[i][t]-'a']=true;}\n        else{edge[a[i-1][t]-'a'][a[i][t]-'a']=true;}\n    }\n    SCC G(27);\n    for(int i=0;i<27;i++){\n        for(int t=0;t<27;t++){\n            if(edge[i][t]){G.add_edge(i,t);}\n        }\n    }\n    G.solve();\n    vector<ll> count(27,0);\n    bool j=true;\n    for(auto &i:G.group){\n        count[i]++;\n        if(count[i]>=2){j=false; break;}\n    }\n    cout<<(j?\"yes\":\"no\")<<endl;\n    }\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    vector<string> dict;\n    int prior[256][256]; // prior[A][B] ::= A is prior to B or not\n    memset(prior,-1,sizeof(prior));\n\n    bool isok = true;\n    bool res = true;\n    for(int current_idx=0;current_idx<N;current_idx++){\n      string current;\n      cin >> current;\n\n      for(int prev_idx=0;prev_idx<dict.size();prev_idx++){\n        for(int char_idx=0;\n            char_idx < current.size() && char_idx < dict[prev_idx].size();\n            char_idx++){\n          if(current[char_idx] == dict[prev_idx][char_idx]) continue;\n\n          if(prior[dict[prev_idx][char_idx]][current[char_idx]] == 1){\n            break;\n          }\n\n          if(prior[dict[prev_idx][char_idx]][current[char_idx]] == -1){\n            prior[dict[prev_idx][char_idx]][current[char_idx]] = 1;\n            prior[current[char_idx]][dict[prev_idx][char_idx]] = 0;\n            break;\n          }\n        }\n\n        bool isok = true;\n        bool is_first = true;\n        for(int char_idx=0;\n            char_idx < current.size() && char_idx < dict[prev_idx].size();\n            char_idx++){\n          if(current[char_idx] == dict[prev_idx][char_idx]) continue;\n          if(is_first && prior[current[char_idx]][dict[prev_idx][char_idx]] == 1){\n            isok = false;\n            break;\n          }\n          is_first = false;\n        }\n\n        if(isok){\n          if(current.size() < dict[prev_idx].size()\n             && dict[prev_idx].substr(0,current.size()) == current){\n            isok = false;\n          }\n        }\n\n        res &= isok;\n        if(!res) goto found;\n      }\n\n      dict.push_back(current);\n    }\n  found:;\n    printf(\"%s\\n\",res ? \"yes\" : \"no\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint edge[26][26];\nvector<string> s;\n\nint dfs(int l, int r, int dep) {\n    int prev = l, ret = 1;\n    for (int i = l; i < r - 1; ++i) {\n        if (s[i][dep] != s[i + 1][dep]) {\n            if (s[i][dep] != '$' && s[i + 1][dep] == '$') return 0;\n            if (s[i][dep] != '$' && s[i + 1][dep] != '$') {\n                edge[s[i][dep] - 'a'][s[i + 1][dep] - 'a'] = 1;\n                ret &= dfs(prev, i + 1, dep + 1);\n            }\n            prev = i + 1;\n        }\n    }\n    if (s[r - 1][dep] != '$')\n        ret &= dfs(prev, r, dep + 1);\n\n    return ret;\n}\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        for (int i = 0; i < 26; ++i) {\n            for (int j = 0; j < 26; ++j) {\n                edge[i][j] = 0;\n            }\n        }\n\n        s.clear();\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> s[i];\n            int c = s[i].size();\n            while (c++ < 100) {\n                s[i] += \"$\";\n            }\n        }\n        if (!dfs(0, n, 0)) {\n            cout << \"no\\n\";\n            continue;\n        }\n        int ok = 1;\n        for (int i = 0; i < 26; ++i) {\n            vector<int> vis(26, 0);\n            queue<int> q;\n            q.push(i);\n            vis[i] = 1;\n            while (!q.empty()) {\n                int p = q.front();\n                q.pop();\n                for (int j = 0; j < 26; ++j) {\n                    if (edge[p][j]) {\n                        if (vis[j]) {\n                            ok = 0;\n                            goto A;\n                        }\n                        vis[j] = 1;\n                        q.push(j);\n                    }\n                }\n            }\n        }\n        A:\n        cout << (ok ? \"yes\\n\" : \"no\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nstring s[500], t[500];\nvector<int>E[26];\nint in[26], d[26], p;\nbool used[26];\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tmemset(used, 1, sizeof(used));\n\t\tmemset(in, 0, sizeof(in));\n\t\trep(i, 26)E[i].clear();\n\t\trep(i, n) {\n\t\t\tcin >> s[i]; t[i] = s[i];\n\t\t\tfor (char c : s[i])used[c - 'a'] = false;\n\t\t}\n\t\trep(i, 10) {\n\t\t\trep(j, n)for (int k = j + 1; k < n; k++) {\n\t\t\t\tif (i < s[j].size() && i < s[k].size() && s[j][i] != s[k][i] && s[j].substr(0, i) == s[k].substr(0, i)) {\n\t\t\t\t\tin[s[k][i] - 'a']++; E[s[j][i] - 'a'].push_back(s[k][i] - 'a');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<int>Q;\n\t\tp = 0;\n\t\trep(i, 26) {\n\t\t\tif (!in[i] && !used[i])Q.push(i);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint u = Q.front(); Q.pop();\n\t\t\t\tused[u] = true; d[u] = p++;\n\t\t\t\tfor (int v : E[u]) {\n\t\t\t\t\tin[v]--; if (!in[v])Q.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 26) {\n\t\t\tif (!used[i]) {\n\t\t\t\tputs(\"no\"); goto g;\n\t\t\t}\n\t\t}\n\t\tsort(t, t + n, [&](string a, string b) {\n\t\t\trep(i, min(a.size(), b.size())) {\n\t\t\t\tif (a[i] != b[i])return d[a[i] - 'a'] < d[b[i] - 'a'];\n\t\t\t}\n\t\t\treturn a.size() < b.size();\n\t\t});\n\t\trep(i, n) {\n\t\t\tif (s[i] != t[i]) {\n\t\t\t\tputs(\"no\"); goto g;\n\t\t\t}\n\t\t}\n\t\tputs(\"yes\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nvector<int> topological_sort(const vector<vector<int>>& G)\n{\n    int n = G.size();\n    vector<int> num(n), ord;\n    for (int i = 0; i < n; ++i) {\n        for (int u : G[i]) ++num[u];\n    }\n    stack<int> st;\n    for(int i = 0; i < n; ++i) {\n        if (num[i] == 0) st.push(i);\n    }\n    while (!st.empty()) {\n        int i = st.top(); st.pop();\n        ord.push_back(i);\n        for (int u : G[i]) {\n            --num[u];\n            if (num[u] == 0) st.push(u);\n        }\n    }\n    return ord;\n}\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        vector<string> s(n); cin >> s;\n\n        bool valid = true;\n\n        vector<vector<int>> G(26);\n        for (int i = 0; i < n-1; ++i) {\n            if (s[i+1].substr(0, s[i].size()) == s[i]) {\n                continue;\n            }\n            if (s[i].substr(0, s[i+1].size()) == s[i+1]) {\n                valid = false;\n                break;\n            }\n            for (int j = 0; j < s[i].size(); ++j) {\n                if (s[i][j] != s[i+1][j]) {\n                    G[s[i][j] - 'a'].push_back(s[i+1][j] - 'a');\n                    break;\n                }\n            }\n        }\n\n        if (!valid) {\n            cout << \"no\" << endl;\n            continue;\n        }\n\n        auto ord = topological_sort(G);\n        if (ord.size() == 26) {\n            cout << \"yes\" << endl;\n        } else {\n            cout << \"no\" << endl;\n        }\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nint n;\nvector<int> s[500];\nvector<int> e[30];\nbool saw[500];\n\nbool f(int p){\n\tif(saw[p]) return false;\n\tsaw[p] = true;\n\tbool ret = true;\n\trep(i,e[p].size()){\n\t\tif(!f(e[p][i])) return false;\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\trep(i,500) saw[i] = false;\n\trep(i,500) s[i].clear();\n\trep(i,30) e[i].clear();\n\trep(i,n){\n\t\tstring str;\n\t\tcin >> str;\n\t\trep(j,str.size()){\n\t\t\tint x = str[j]-'a';\n\t\t\ts[i].push_back(x);\n\t\t}\n\t}\n\tfor(int i = 0; i < n-1; i++){\n\t\tint t = min(s[i].size(),s[i+1].size());\n\t\tbool ok = false;\n\t\trep(j,t){\n\t\t\tif(s[i][j] != s[i+1][j]){\n\t\t\t\te[s[i][j]].push_back(s[i+1][j]);\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tif(s[i].size() > s[i+1].size()){\n\t\t\t\tputs(\"no\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,30) sort(e[i].begin(),e[i].end());\n\trep(i,30) e[i].erase(unique(e[i].begin(),e[i].end()),e[i].end());\n\trep(i,30){\n\t\trep(j,500) saw[j] = false;\n\t\tif(!f(i)){\n\t\t\tputs(\"no\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"yes\");\n\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nbool foo(vector< vector<int> >& a, int x, int y) {\n\ta[x][y] = 1;\n\tfor (int u = 0; u < 26; u++)\n\t\tfor (int v = 0; v < 26; v++)\n\t\t\ta[u][v] |= a[u][x] & a[x][v];\n\tfor (int u = 0; u < 26; u++)\n\t\tif (a[u][u]) return false;\n\treturn true;\n}\n\nbool bar(string& s, string& t, vector< vector<int> >& a) {\n\tint S = s.length(), T = t.length();\n\tint i;\n\tfor (i = 0; i < S && i < T && s[i] == t[i]; i++);\n\tif (i == S) return true;\n\tif (i == T) return false;\n\treturn foo(a, s[i] - 'a', t[i] - 'a');\n}\n\nint main() {\n\tfor (;;) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<string> s(n);\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcin >> s[j];\n\t\tvector< vector<int> > a(26, vector<int>(26));\n\t\tbool flag = true;\n\t\tfor (int j = 0; j + 1 < n; j++) {\n\t\t\tif (!bar(s[j], s[j + 1], a)) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (flag ? \"yes\" : \"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    vector<string> dict;\n    int prior[256][256]; // prior[A][B] ::= A is prior to B or not\n    memset(prior,-1,sizeof(prior));\n\n    bool isok = true;\n    bool res = true;\n    for(int current_idx = 0;current_idx<N;current_idx++){\n      string current;\n      cin >> current;\n\n      for(int prev_idx=0;prev_idx<dict.size();prev_idx++){\n        for(int char_idx=0;\n            char_idx < current.size() && char_idx < dict[prev_idx].size();\n            char_idx++){\n          if(current[char_idx] == dict[prev_idx][char_idx]) continue;\n\n          if(prior[dict[prev_idx][char_idx]][current[char_idx]] == 1){\n            break;\n          }\n\n          if(prior[dict[prev_idx][char_idx]][current[char_idx]] == -1){\n            prior[dict[prev_idx][char_idx]][current[char_idx]] = 1;\n            prior[current[char_idx]][dict[prev_idx][char_idx]] = 0;\n            break;\n          }\n        }\n\n        bool isok = true;\n        bool is_first = true;\n        for(int char_idx=0;\n            char_idx < current.size() && char_idx < dict[prev_idx].size();\n            char_idx++){\n          if(current[char_idx] == dict[prev_idx][char_idx]) continue;\n          if(is_first && prior[current[char_idx]][dict[prev_idx][char_idx]] == 1){\n            isok = false;\n            break;\n          }\n          is_first = false;\n        }\n\n        if(isok){\n          if(current.size() < dict[prev_idx].size()\n             && dict[prev_idx].substr(0,current.size()) == current){\n            isok = false;\n          }\n        }\n\n        res &= isok;\n        if(!res){\n          current_idx++;\n          for(;current_idx < N;current_idx++){\n            cin >> current;\n          }\n          goto found;\n        }\n      }\n\n      dict.push_back(current);\n    }\n  found:;\n    printf(\"%s\\n\",res ? \"yes\" : \"no\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint n;\nstring s[510];\nvector<int> G[26];\nint indeg[26];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> n, n) {\n    for (int i = 0; i < 26; i++) {\n      G[i].clear();\n      indeg[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n      cin >> s[i];\n    }\n    bool no = false;\n    for (int i = 0; i + 1 < n; i++) {\n      if (s[i] == s[i + 1]) continue;\n      int w = 0, lim = min(s[i].size(), s[i + 1].size());\n      while (w < lim && s[i][w] == s[i + 1][w]) {\n        w++;\n      }\n      no |= s[i].substr(0, s[i + 1].size()) == s[i + 1];\n      if (w < lim) G[s[i][w] - 'a'].emplace_back(s[i + 1][w] - 'a');\n    }\n    for (int i = 0; i < 26; i++) {\n      auto &v = G[i];\n      sort(v.begin(), v.end());\n      v.erase(unique(v.begin(), v.end()), v.end());\n      for (int next : G[i]) {\n        if (next != i) indeg[next]++;\n      }\n    }\n    stack<int> st;\n    int num = 0;\n    for (int i = 0; i < 26; i++) {\n      if (!indeg[i]) st.emplace(i);\n    }\n    while (!st.empty()) {\n      int curr = st.top();\n      st.pop();\n      num++;\n      for (int next : G[curr]) {\n        if (--indeg[next]) continue;\n        st.emplace(next);\n      }\n    }\n    cout << (!no && num == 26 ? \"yes\" : \"no\") << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\nusing namespace std;\nint order[30],n,cnt;\nstring a,b;\nint num[30],num1[30];\nbool solve()\n{\n    int la,lb,ax,bx;\n    bool flag=true;\n    for(int i=2;i<=n;i++)\n    {\n        cin>>b;\n        if(!flag)continue;\n        la=a.size(),lb=b.size();\n        ax=bx=0;\n        while(ax<la&&bx<lb)\n        {\n            int p=a[ax]-'a',q=b[bx]-'a';\n            if(order[p]<0&&order[q]<0)\n            {\n                if(p==q){ax++,bx++;continue;}\n                cnt+=30;order[p]=cnt;\n                if(p!=q){cnt+=30;order[q]=cnt;break;}\n            }\n            else if(order[p]>=0&&order[q]<0){num1[p]++;order[q]=order[p]+num1[p];break;}\n            else if(order[p]<0&&order[q]>=0){num[q]--;order[p]=order[q]-num[q];break;}\n            if(order[p]<order[q])break;\n            else if(order[p]>order[q]){flag=false;break;}\n            ax++,bx++;\n        }\n        if(bx==lb&&la>lb){flag=false;}\n        a=b;\n    }\n    if(flag)return true;\n    return false;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    while(scanf(\"%d\",&n)!=EOF&&n)\n    {\n        cin>>a;\n        int len=a.size();\n        memset(order,-1,sizeof(order));\n        for(int i=0;i<=30;i++)num[i]=30;\n        memset(num1,0,sizeof(num1));\n        cnt=0;\n        if(solve())printf(\"yes\\n\");\n        else printf(\"no\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint order[128][128];\nvector<string> t;\n\n//[from, to] not [from, to)\nbool check(int x, int from, int to){\n  for(int i = from; i <= to; i++){\n    if(t[i].size() <= x) continue;\n\n    for(int j = i + 1; j <= to; j++){\n      if(t[j].size() <= x) return false;\n\n      char a = t[i][x];\n      char b = t[j][x];\n\n      if(a != b && order[a][b] != 0 && order[a][b] == 1){\n        return false;\n      }\n      order[a][b] = -1;\n      order[b][a] = +1;\n    }\n  }\n\n  int i = from;\n  while(i <= to && t[i].size() <= x) i++;\n\n  for( ; i <= to; i++){\n    int j = i;\n    for( ; j <= to && t[i][x] == t[j][x]; j++);\n    if(!check(x + 1, i, j - 1)) return false;\n    i = j - 1;\n  }\n\n  return true;\n}\n\nint main(){\n  while(cin >> n, n){\n    t.clear();\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      t.push_back(s);\n    }\n\n    memset(order, 0, sizeof(order));\n\n    cout << (check(0, 0, n - 1) ? \"yes\" : \"no\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\nbool ok = true;\nvoid dfs(vvi& g, vi &visited,int i) {\n\tif (!ok)return;\n\tif (visited[i])ok = false;\n\tvisited[i] = 1;\n\tREP(j, g[i].size())dfs(g, visited, g[i][j]);\n\tvisited[i] = 0;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<string> v(n);\n\t\tREP(i, n)cin >> v[i];\n\t\tvvi g(26);\n\t\tok = true;\n\t\tREP(i, n - 1) {\n\t\t\tbool done = false;\n\t\t\tREP(j, min(v[i].size(), v[i + 1].size())) {\n\n\t\t\t\tif (v[i][j] != v[i + 1][j]) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tg[v[i][j] - 'a'].push_back(v[i + 1][j] - 'a');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\tif (v[i].size() > v[i + 1].size())ok = false;\n\t\t\t}\n\t\t}\n\t\tREP(i, 26) {\n\t\t\tsort(ALL(g[i]));\n\t\t\tUNIQUE(g[i]);\n\t\t}\n\t\tvi visited(26, 0);\n\t\tREP(i, 26) {\n\t\t\tREP(j, 26)visited[j] = 0;\n\t\t\tdfs(g, visited, i);\n\t\t}\n\t\tif (ok)cout << \"yes\" << endl;\n\t\telse cout << \"no\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> G[26];\nbool g[26];\n\nint d[26][26];\nconst int INF = 1e5;\n\nbool dfs(int now, int pre){\n\tif(g[now] == true) return false;\n\tbool res = true;\n\t//cout << now << endl;\n\tg[now] = true;\n\tset<int> st;\n\tfor(int i = 0; i < G[now].size(); i++){\n\t\tint next = G[now][i];\n\t\t//if(next == pre) continue;\n\t\tif(st.count(next)) continue;\n\t\tst.insert(next);\n\t\tres &= dfs(next, now);\n\t}\n\treturn res;\n}\n\nint n;\n\nvoid wf(){\n\tfor(int k = 0; k < n; k++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tG[i].clear();\n\t\t\tfor(int j = 0; j < 26; j++) d[i][j] = INF;\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tvector<string> s(n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tbool f = true;\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\t\tif(s[i + 1].size() == j){\n\t\t\t\t\tf = false; break;\n\t\t\t\t}\n\t\t\t\tif(s[i][j] != s[i + \t1][j]){\n\t\t\t\t\tG[s[i][j] - 'a'].push_back(s[i + 1][j] - 'a');\n\t\t\t\t\t//cout << s[i][j] << \"->\" << s[i + 1][j] << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\td[i][G[i][j]] = -1;\n\t\t\t}\n\t\t}\n\t\twf();\n\t\t//int e[26][26] = {};\n\t\t//for(int i = 0; i < 26; i++) for(int j = 0; j < 26; j++) e[i][j] = d[i][j];\n\t\t//wf();\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\t//cout << d[i][i] << endl;\n\t\t\tif(d[i][i] != 0) f = false;\n\t\t\t//for(int j = 0; j < 26; j++){\n\t\t\t//\tif(d[i][j] != e[i][j]) f = false;\n\t\t\t//}\n\t\t}\n\t\t/*for(int j = 0; j < 26; j++){\n\t\t//cout << j << \" \" << f << endl;\n\t\t\tfor(int i = 0; i < 26; i++) g[i] = false;\n\t\t\tf &=  dfs(j, -1);\n\t\t}*/\n\t\tif(f) cout << \"yes\" << endl;\t\n\t\telse cout << \"no\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN=555;\nint n;\nchar str[MAXN][22];\nint vis[255][255];\nint in[255];\nqueue<int> q;\n\nbool topsort()\n{\n    while(!q.empty())   q.pop();\n    for(int i=0;i<255;i++)  if(in[i]==0)   q.push(i);\n    int num=0;\n    while(!q.empty())\n    {\n        int u=q.front();q.pop();num++;\n        for(int i=0;i<255;i++)\n            if(vis[u][i]==1)\n            {\n                in[i]--;\n                if(in[i]==0)   q.push(i);\n            }\n    }\n    return num==255;\n}\n\nbool check()\n{\n    memset(vis,0,sizeof vis);memset(in,0,sizeof in);\n    for(int i=2;i<=n;i++)\n    {\n        for(int j=0;str[i][j] || str[i-1][j];j++)\n        {\n            if(str[i][j]==str[i-1][j])  continue;\n            if(!str[i][j])    return false;\n            int x=(int)(str[i-1][j]);\n            int y=(int)(str[i][j]);\n            if(vis[y][x])   return false;\n            if(!vis[x][y])\n            {\n                vis[x][y]=1;\n                in[y]++;\n            }\n            break;\n        }\n    }\n    return topsort();\n}\n\n\nint main()\n{\n    //freopen(\"data.txt\",\"r\",stdin);\n    while(cin>>n && n)\n    {\n        memset(str,0,sizeof str);\n        for(int i=1;i<=n;i++)\n            scanf(\"%s\",str[i]);\n//        for(int i=1;i<=n;i++)\n//        {\n//            int len=strlen(str[i]);\n//            for(int j=0;j<len;j++)\n//                if(str[i][j]>= 'a' && str[i][j]<='z')\n//                    continue;\n//                else\n//                    while(1){}\n//        }\n        if(check())\n            puts(\"yes\");\n        else\n            puts(\"no\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#define llint long long\n\nusing namespace std;\n\nbool les[26][26];\nchar s[105][15];\n\nvoid analyse(char* x, char* y) {\n\tint len = min(strlen(x), strlen(y));\n\tfor (int i = 0; i < len; ++i) {\n\t\tif (x[i] != y[i]) {\n\t\t\tles[x[i] - 'a'][y[i] - 'a'] = true;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nbool illegal(char* x, char* y) {\n\tint l1 = strlen(x);\n\tint l2 = strlen(y);\n\tif (l1 <= l2) return false;\n\tfor (int i = 0; i < l2; ++i) {\n\t\tif (x[i] != y[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n) && n) {\n\t\tgetchar();\n\t\tmemset(les, 0, sizeof(les));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tgets(s[i]);\n\t\t}\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tanalyse(s[i], s[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < 26; ++k) {\n\t\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\t\tfor (int j = 0; j < 26; ++j) {\n\t\t\t\t\tif (les[i][k] && les[k][j]) {\n\t\t\t\t\t\tles[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tfor (int j = i + 1; j < 26; ++j) {\n\t\t\t\tif (les[i][j] && les[j][i]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (illegal(s[i], s[j])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) puts(\"yes\");\n\t\telse puts(\"no\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nbool solve() {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n    vector<string> v(N);\n    int maxlen = 0;\n    for(int i = 0; i < N; ++i) {\n        cin >> v[i];\n        maxlen = max(maxlen, (int)v[i].size());\n    }\n    map<char, int> dict;\n    for(int i = 0; i < maxlen; ++i) {\n        for(string &s : v) {\n            if(s.size() <= i) continue;\n            if(dict.count(s[i])) {\n                s[i] = dict[s[i]];\n            } else {\n                const int idx = dict.size();\n                s[i] = dict[s[i]] = idx + 'a';\n            }\n        }\n    }\n    /*\n    for(string s : v) {\n        cout << s << endl;\n    }\n    */\n    vector<string> tmp = v;\n    sort(tmp.begin(), tmp.end());\n    cout << (v == tmp ? \"yes\" : \"no\") << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nusing graph = vector<vector<int>>;\n \nvoid dfs(int v, const graph& G, vector<int>& res, vector<int>& used) {\n    used[v] = 1;\n    for (auto to : G[v]) if (used[to] == 0) {\n        dfs(to, G, res, used);\n    }\n    res.push_back(v);\n    //cout<<v<<endl;\n}\n \nvector<int> topo_sort(const graph& G) {\n    int V = G.size();\n    vector<int> ide(V);\n    for (int i = 0; i < V; i++) {\n        for (auto to : G[i]) {\n            //cout<<to<<endl;\n            ide[to]++;\n        }\n    }\n    vector<int> res;\n    vector<int> used(V);\n    for (int i = V - 1; i >= 0; i--) {\n        if (ide[i] == 0) {\n            //cout<<i<<endl;\n            dfs(i, G, res, used);\n        }\n    }\n    if(res.size()==0) res={-1};\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        if(n==1){\n            cout<<\"yes\"<<endl;\n            continue;\n        }\n        vector<string> s(n);\n        for(int i=0;i<n;i++) cin>>s[i];\n        graph g(26);\n        for(int i=1;i<n;i++){\n            int len=min(s[i-1].length(),s[i].length());\n            for(int j=0;j<len;j++){\n                if(s[i-1][j]==s[i][j]) continue;\n                int st=s[i-1][j]-'a',gt=s[i][j]-'a';\n                g[st].push_back(gt);\n                break;\n            }\n        }\n        vector<int> res=topo_sort(g);\n        //cout<<res.size()<<endl;\n        if(res.size()!=26){\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        for(int i=0;i<n;i++){\n            int len=s[i].length();\n            for(int j=0;j<len;j++){\n                int idx=s[i][j]-'a';\n                idx=res[idx];\n                s[i][j]='a'+idx;\n            }\n        }\n        bool f=true;\n        for(int i=1;i<n;i++){\n            if(s[i-1]>s[i]) f=false;\n        }\n        if(f) cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint order[128];\nvector<string> t;\n\n\nbool cmp(string a, string b){\n  for(int i = 0; i < min(a.size(), b.size()); i++){\n    if(order[a[i]] < order[b[i]]){\n      return true;\n    }\n    if(order[a[i]] > order[b[i]]){\n      return false;\n    }\n  }\n  return a.size() < b.size();\n}\n\nbool check(){\n  vector<string> tb = t;\n  sort(tb.begin(), tb.end(), cmp);\n  return t == tb;\n}\n\nint main(){\n  while(cin >> n, n){\n    t.clear();\n\n    bool flg[128] = {0};\n    vector<char> alpha;\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      t.push_back(s);\n\n      for(int j = 0; j < s.size(); j++){\n        if(flg[s[j]]) continue;\n        flg[s[j]] = true;\n        alpha.push_back(s[j]);\n      }\n    }\n\n    sort(alpha.begin(), alpha.end());\n\n    bool yes = false;\n\n    do{\n      for(int i = 0; i < alpha.size(); i++){\n        order[alpha[i]] = i;\n      }\n      if(check()){\n        yes = true;\n        break;\n      }\n    } while(next_permutation(alpha.begin(), alpha.end()));\n\n    cout << (yes ? \"yes\" : \"no\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 26\n\nint res;\nbool found;\nvector<int> G[MAX_V];\nint visited[MAX_V],num[MAX_V];\n\nvoid dfs(int v,int c){\n  visited[v] = 0; num[v] = c;\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    int to = G[v][i];\n    if(visited[to] == -1){\n      dfs(to,c+1);\n    }else if(visited[to] == 0){\n      res = max(res,num[v]-num[to]+1);\n    }\n  }\n  visited[v] = 1;\n}\n\nint getLargestCycle(){\n  res = 0;\n  memset(num,-1,sizeof(num));\n  memset(visited,-1,sizeof(visited));\n  for(int i = 0 ; i < 26 ; i++){\n    if(visited[i] == -1){\n      dfs(i,1);\n    }\n  }\n  return res;\n}\n\nvoid init(){\n    found = false;\n    for(int i = 0 ; i < MAX_V ; i++){\n        G[i].clear();\n    }\n}\n\nbool valid(string &a, string &b){\n    int A = a.size(),B = b.size();\n    if(A <= B) return true;\n    for(int i = 0 ; i < B ; i++){\n        if(a[i] != b[i]) return true;\n    }\n    return false;\n}\n\nbool check(vector<string> &v){\n    int N = v.size();\n    for(int i = 0 ; i < N-1 ; i++){\n        if(!valid(v[i],v[i+1])) return false;\n        int a = v[i].size(),b = v[i+1].size();\n        for(int j = 0 ; j < min(a,b) ; j++){\n            if(v[i][j] != v[i+1][j]){\n                G[v[i][j]-'a'].push_back(v[i+1][j]-'a');\n                break;\n            }\n        }\n    }\n    return (getLargestCycle() < 2);\n}\n\nint main(){\n    int N;\n    while(cin >> N, N){\n        vector<string> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i];\n        }\n        init();\n        cout << (check(v) ? \"yes\" : \"no\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    vector<string> dict;\n    int prior[256][256]; // prior[A][B] ::= A is prior to B or not\n    memset(prior,-1,sizeof(prior));\n\n    bool isok = true;\n    bool res = true;\n    for(int current_idx=0;current_idx<N;current_idx++){\n      string current;\n      cin >> current;\n\n      for(int prev_idx=0;prev_idx<dict.size();prev_idx++){\n        for(int char_idx=0;\n            char_idx < current.size() && char_idx < dict[prev_idx].size();\n            char_idx++){\n          if(current[char_idx] == dict[prev_idx][char_idx]) continue;\n\n          if(prior[dict[prev_idx][char_idx]][current[char_idx]] == -1){\n            prior[dict[prev_idx][char_idx]][current[char_idx]] = 1;\n            prior[current[char_idx]][dict[prev_idx][char_idx]] = 0;\n          }\n        }\n\n        bool isok = true;\n        bool is_first = true;\n        for(int char_idx=0;\n            char_idx < current.size() && char_idx < dict[prev_idx].size();\n            char_idx++){\n          if(current[char_idx] == dict[prev_idx][char_idx]) continue;\n          if(is_first && prior[current[char_idx]][dict[prev_idx][char_idx]] == 1){\n            isok = false;\n            break;\n          }\n          is_first = false;\n        }\n\n        if(isok){\n          if(current.size() < dict[prev_idx].size()\n             && dict[prev_idx].substr(0,current.size()) == current){\n            isok = false;\n          }\n        }\n\n        res &= isok;\n      }\n\n      dict.push_back(current);\n    }\n  found:;\n    printf(\"%s\\n\",res ? \"yes\" : \"no\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        int dp[26][26] = {};\n        string b;\n        cin >> b;\n        bool ng = false;\n        for(int i = 1; i < n; i++){\n            string s;   cin >> s;\n            int j;\n            for(j = 0; j < min(b.length(), s.length()); j++){\n                if(b[j] != s[j])    break;\n            }\n            if(j < min(b.length(), s.length())){\n                dp[b[j]-'a'][s[j]-'a'] = -1;\n            }else if(j == s.length() && j < b.length()){\n                ng = true;\n            }\n            b = s;\n        }\n        for(int k = 0; k < 26; k++){\n            for(int i = 0; i < 26; i++){\n                for(int j = 0; j < 26; j++){\n                    if(dp[i][k] == 0 || dp[k][j] == 0)  continue;\n                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);\n                }\n            }\n        }\n        for(int i = 0; i < 26; i++){\n            ng |= (dp[i][i] < 0);\n        }\n        cout << (ng ? \"no\" : \"yes\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n// >>> scc\n\nconstexpr int dst(int v) { return v; }\ntemplate <class E, class = decltype(E().to)>\nconstexpr int dst(E const& e) { return e.to; }\n\ntemplate <class E> struct SCC {\n    vector<vector<E> > const& g;\n    vector<int32_t> ord, low, st;\n    int32_t time = 0, pos = 0, sz = 0;\n    SCC(vector<vector<E> > const& g) : g(g), ord(g.size()), low(g.size()), st(g.size()) {\n        rep (v,g.size()) if (ord[v] == 0) dfs(v);\n        for (auto &x : ord) x += sz;\n    }\n    void dfs(int v) {\n        low[v] = ord[v] = ++time; st[pos++] = v;\n        for (auto const& e : g[v]) {\n            if (ord[dst(e)] == 0) {\n                dfs(dst(e));\n                chmin(low[v], low[dst(e)]);\n            } else if (ord[dst(e)] > 0) {\n                chmin(low[v], ord[dst(e)]);\n            }\n        }\n        if (low[v] == ord[v]) {\n            sz++; do ord[st[--pos]] = -sz; while (st[pos] != v);\n        }\n    }\n\n    // t-sorted id\n    int id(int v) const { return ord[v]; }\n    int size() const { return sz; }\n    vector<vector<int>> groups() const {\n        vector<vector<int> > grp(sz);\n        rep (v,g.size()) grp[ord[v]].push_back(v);\n        return grp;\n    }\n\n    // no multiple edges, no self-loops\n    // no edge information\n    vector<vector<int>> graph() const {\n        vector<vector<int>> ret(size());\n        rep (v,g.size()) {\n            for (auto const& e : g[v]) {\n                int x = id(v), y = id(dst(e));\n                if (x != y) ret[x].push_back(y);\n            }\n        }\n        for (auto &ls : ret) {\n            sort(ls.begin(), ls.end());\n            ls.erase(unique(ls.begin(), ls.end()), ls.end());\n        }\n        return ret;\n    }\n};\ntemplate <class E> auto get_scc(vector<vector<E> > const& g) { return SCC<E>(g); }\n\n// <<<\n\nvoid solve(int n) {\n    vector<string> ss(n); cin >> ss;\n\n    vector<vector<int>> g(26);\n    rep (i,n-1) {\n        auto s = ss[i], t = ss[i+1];\n        int j = 0;\n        for ( ; j < min(sz(s),sz(t)); ++j) {\n            if (s[j] != t[j]) {\n                g[s[j]-'a'].eb(t[j]-'a');\n                break;\n            }\n        }\n        if (j == min(sz(s),sz(t))) {\n            if (sz(s) == sz(t)) continue;\n            if (sz(s) > sz(t)) {\n                cout << \"no\\n\";\n                return;\n            }\n        }\n    }\n\n    auto scc = get_scc(g);\n    cout << (scc.size() == 26 ? \"yes\" : \"no\") << \"\\n\";\n\n}\n\nint32_t main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tVS vs(N);\n\tREP(i,N) cin >> vs[i];\n\tint dist[32][32];\n\tfill((int*)dist, (int*)dist+32*32, 100);\n\n\tbool ans = true;\n\tfor(int i=0;i<N;++i)\n\t  for(int j=i+1;j<N;++j){\n\t\tint k;\n\t\tfor(k=0;k<min(SZ(vs[i]),SZ(vs[j]));++k){\n\t\t  if(vs[i][k] != vs[j][k]){\n\t\t\tdist[vs[i][k]-'a'][vs[j][k]-'a'] = 0;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t\tif(k == SZ(vs[j]) && SZ(vs[i]) > SZ(vs[j])) ans = false;\n\t  }\n\n\tREP(k,32) REP(i,32) REP(j,32)\n\t  dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tREP(i,32) if(!dist[i][i]) ans = false;\n\t\n\tcout << (ans? \"yes\": \"no\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G,rG,tG;\n\tvector<bool>used;\n\tvi vs,cmp;\n\tSCC(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n\tvoid make(int size){\n\t\tint N=size;\n\t\ttG=vvi(N);\n\t\trep(i,n)rep(j,G[i].size())if(cmp[i]!=cmp[G[i][j]]){\n\t\t\ttG[cmp[i]].pb(cmp[G[i][j]]);\n//\t\t\ttG[cmp[G[i][j]]].pb(cmp[i]);\n\t\t}\n\t}\n};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvs in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tSCC scc(26);\n\t\trep(i,n-1){\n\t\t\tint t=min(in[i].size(),in[i+1].size());\n\t\t\tif(in[i].substr(0,t)==in[i+1].substr(0,t)){\n\t\t\t\tif(in[i].size()>in[i+1].size()){\n\t\t\t\t\tcout<<\"no\"<<endl;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(j,t)if(in[i][j]!=in[i+1][j]){\n\t\t\t\t\tscc.add_edge(in[i][j]-'a',in[i+1][j]-'a');\n//\t\t\t\t\tcout<<in[i][j]-'a'<<\" \"<<in[i+1][j]-'a'<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(scc.scc()==26)cout<<\"yes\"<<endl;\n\t\telse cout<<\"no\"<<endl;\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 11000\n\nint V;\nvector<int> G[MAX_V]; // グラフの隣接リスト表現\nvector<int> rG[MAX_V];// 辺の向きを逆にしたグラフ\nvector<int> vs;       // 帰りがけ順の並び\nbool used[MAX_V];     // すでに調べたか\nint cmp[MAX_V];       // 属する強連結成分のトポロジカル順序\n\n// from から to への辺を張る関数\nvoid add_edge(int from, int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor(int i = 0; i < rG[v].size(); i++){\n\t\tif(!used[rG[v][i]]){\n\t\t\trdfs(rG[v][i], k);\n\t\t}\n\t}\n}\n\n// 強連結成分分解を行う関数、返り値は強連結成分の個数\nint scc(){\n\tmemset(used, 0, sizeof(used));\n\tvs.clear();\n\tfor(int v = 0; v < V; v++){\n\t\tif(!used[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tmemset(used, 0, sizeof(used));\n\tint k = 0;\n\tfor(int i = vs.size() - 1; i >= 0; i--){\n\t\tif(!used[vs[i]]){\n\t\t\trdfs(vs[i], k++);\n\t\t}\n\t}\n\treturn k;\n}\n\nint main(){\n\t\n\twhile(true){\n\t\t\n\t\tint n;\n\t\tcin >> n;\n\t\t\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tV = 26;\n\t\tfor(int i = 0; i < MAX_V; i++){\n\t\t\tG[i].clear();\n\t\t\trG[i].clear();\n\t\t}\n\t\t\n\t\tstring str, str_pre;\n\t\tcin >> str_pre;\n\t\t\n\t\tbool flag = true;\n\t\t\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tcin >> str;\n\t\t\tfor(int j = 0; j <= min(str.size(), str_pre.size()); j++){\n\t\t\t\tif(j == min(str.size(), str_pre.size())){\n\t\t\t\t\tif(str.size() < str_pre.size()){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(str[j] != str_pre[j]){\n\t\t\t\t\tadd_edge(str_pre[j] - 'a', str[j] - 'a');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr_pre = str;\n\t\t}\n\t\t\n\t\tflag &= (scc() == 26);\n\t\t\n\t\tif(flag){\n\t\t\tcout << \"yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 26\n\nint res;\nbool found;\nvector<int> G[MAX_V];\nint visited[MAX_V],num[MAX_V];\n\nvoid dfs(int v,int c){\n  visited[v] = 0; num[v] = c;\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    int to = G[v][i];\n    if(visited[to] == -1){\n      dfs(to,c+1);\n    }else if(visited[to] == 0){\n      res = max(res,num[v]-num[to]+1);\n    }\n  }\n  visited[v] = 1;\n}\n\nint getLargestCycle(){\n  res = 0;\n  memset(num,-1,sizeof(num));\n  memset(visited,-1,sizeof(visited));\n  for(int i = 0 ; i < 26 ; i++){\n    if(visited[i] == -1){\n      dfs(i,1);\n    }\n  }\n  return res;\n}\n\nvoid init(){\n    found = false;\n    for(int i = 0 ; i < MAX_V ; i++){\n        G[i].clear();\n    }\n}\n\nbool valid(string &a, string &b){\n    int A = a.size(),B = b.size();\n    if(A <= B) return true;\n    for(int i = 0 ; i < B ; i++){\n        if(a[i] != b[i]) return true;\n    }\n    return false;\n}\n\nbool check(vector<string> &v){\n    int N = v.size();\n    for(int i = 0 ; i < N-1 ; i++){\n        if(!valid(v[i],v[i+1])) return false;\n        int a = v[i].size(),b = v[i+1].size();\n        for(int j = 0 ; j < min(a,b) ; j++){\n            if(v[i][j] != v[i+1][j]){\n                G[v[i][j]-'a'].push_back(v[i+1][j]-'a');\n                break;\n            }\n        }\n    }\n    return (getLargestCycle() == 0);\n}\n\nint main(){\n    int N;\n    while(cin >> N, N){\n        vector<string> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i];\n        }\n        init();\n        cout << (check(v) ? \"yes\" : \"no\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<string> vs(n);\n\t\tvector<set<int>> alp(26);\n\t\tstring ans = \"yes\";\n\t\tREP(i, n)\n\t\t\tcin >> vs[i];\n\t\tREP(i, n-1) {\n\t\t\tint si1=vs[i].length();\n\t\t\tint si2 = vs[i+1].length();\n\t\t\tREP (j,min(si1,si2)) {\n\t\t\t\tif (vs[i][j] == vs[i + 1][j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (alp[vs[i + 1][j] - 'a'].find(vs[i][j] - 'a') != alp[vs[i + 1][j] - 'a'].end()) {\n\t\t\t\t\tans = \"no\";\n\t\t\t\t\tgoto res;\n\t\t\t\t}\n\t\t\t\talp[vs[i][j] - 'a'].insert(vs[i + 1][j]-'a');\n\t\t\t\tREP(k, 26) {\n\t\t\t\t\tif (alp[k].find(vs[i][j] - 'a') != alp[k].end()) {\n\t\t\t\t\t\tif (alp[vs[i + 1][j] - 'a'].find(k) != alp[vs[i + 1][j] - 'a'].end()) {\n\t\t\t\t\t\t\tans = \"no\";\n\t\t\t\t\t\t\tgoto res;\n\t\t\t\t\t\t}\n\t\t\t\t\t\talp[k].insert(vs[i + 1][j] - 'a');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (si1 > si2&&vs[i].substr(0, vs[i + 1].length()) == vs[i + 1]) {\n\t\t\t\tans = \"no\";\n\t\t\t\tgoto res;\n\t\t\t}\n\t\t}\n\tres:\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nbool G[26][26];\nbool f[26];\nbool ans;\n\nvoid dfs(int now){\n    // cout << now << \" \" << G[now].size() << endl;\n    if(f[now]){\n        ans = false;\n        return;\n    }\n    f[now] = true;\n    rep(i, 0, 26){\n        if(G[now][i]) dfs(i);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(cin >> n, n){\n        vector<string> s(n);\n        ans = true;\n        rep(i, 0, 26) rep(j, 0, 26) G[i][j] = false;\n        rep(i, 0, n){\n            cin >> s[i];\n        } \n        rep(i, 0, n - 1){\n            int lm = min(s[i].size(), s[i + 1].size());\n            bool same = true;\n            rep(j, 0, lm){\n                if(s[i][j] == s[i + 1][j]) continue;\n                else{\n                    same = false;\n                    G[s[i][j] - 'a'][s[i + 1][j] - 'a'] = true;\n                    break;\n                }\n            }\n            if(same){\n                if(s[i].size() > s[i + 1].size()){\n                    ans = false;\n                    break;\n                }\n            }\n        }\n        rep(i, 0, 26){\n            memset(f, false, sizeof(f));\n            dfs(i);\n        }\n        if(ans) cout << \"yes\" << endl;\n        else cout << \"no\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nbool calc(const vector<string> &words) {\n\tconst int n = words.size();\n\tbool mat[26][26] = {};\n\n\tfor(int i = 0; i < n - 1; ++i) {\n\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\tif(words[i] != words[j] && words[i].find(words[j]) == 0)\n\t\t\t\treturn false;\n\n\t\t\tconst int l = min(words[i].size(), words[j].size());\n\t\t\tfor(int k = 0; k < l; ++k) {\n\t\t\t\tif(words[i][k] != words[j][k]) {\n\t\t\t\t\tmat[words[i][k] - 'a'][words[j][k] - 'a'] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint in[26] = {};\n\tfor(int i = 0; i < 26; ++i) {\n\t\tfor(int j = 0; j < 26; ++j) {\n\t\t\tif(mat[i][j]) ++in[j];\n\t\t}\n\t}\n\n\tqueue<int> que;\n\tfor(int i = 0; i < 26; ++i) if(in[i] == 0) que.push(i);\n\n\tint cnt = 0;\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\t\t++cnt;\n\n\t\tfor(int i = 0; i < 26; ++i) {\n\t\t\tif(mat[v][i] && --in[i] == 0)\n\t\t\t\tque.push(i);\n\t\t}\n\t}\n\n\treturn cnt == 26;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tvector<string> words(n);\n\t\tfor(auto &word : words) {\n\t\t\tcin >> word;\n\t\t}\n\n\t\tcout << (calc(words) ? \"yes\" : \"no\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstring in[510];\nbool graph[30][30];\n\nbool insert(string a,string b){\n\tint n=min(a.size(),b.size());\n\trep(i,n){\n\t\tif(a[i]==b[i])\n\t\t\tcontinue;\n\t\tint aa=a[i]-'a';\n\t\tint bb=b[i]-'a';\n\t\tgraph[aa][bb]=true;\n\t\treturn true;\n\t}\n\tif(a.size()<=b.size())\n\t\treturn true;\n\treturn false;\n}\n\nvi ans;\nbool visited[30];\nvoid dfs(int i){\n\tvisited[i]=true;\n\trep(j,26) if(graph[i][j]&&!visited[j]) dfs(j);\n\tans.pb(i);\n}\n\nbool check(){\n\tans.clear();\n\trep(i,26) visited[i]=false;\n\trep(i,26) if(!visited[i]) dfs(i);\n\treverse(ans.begin(),ans.end());\n\tbool ok=true;\n\trep(i,ans.size())rep(j,i) if(graph[ans[i]][ans[j]]) ok=false;\n\treturn ok;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\trep(i,28)rep(j,28) graph[i][j]=false;\n\t\trep(i,n) cin >> in[i];\n\t\tbool ok=true;\n\t\trep(i,n)rep(j,n){\n\t\t\tif(i>=j) continue;\n\t\t\tok&=insert(in[i],in[j]);\n\t\t}\n\t\tok&=check();\n\t\tif(ok)\n\t\t\tputs(\"yes\");\n\t\telse\n\t\t\tputs(\"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,flg,t[26][26];\nstring str[500];\nvoid check(int x,int y){\n  //cout<<str[x]<<' '<<str[y]<<endl;\n  int v = str[x].size();\n  int w = str[y].size();\n  for(int i=0;i<min(v,w);i++){\n    if(str[x][i]==str[y][i])continue;\n    if(t[str[x][i]-'a'][str[y][i]-'a']==-1)flg=0;\n    t[str[x][i]-'a'][str[y][i]-'a']=1;\n    t[str[y][i]-'a'][str[x][i]-'a']=-1;\n    return;\n  }\n  if(w<v)flg=0;\n}\nint main(){\n  while(cin>>n&&n){\n \n    for(int i=0;i<26;i++)\n      for(int j=0;j<26;j++)\n    t[i][j]=0;\n \n    flg=1;\n    cin>>str[0];\n    for(int i=1;i<n;i++){\n      cin>>str[i];\n      for(int j=i-1;j>=0;j--)check(j,i);\n    }\n    cout<<(flg?\"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool solve(int n)\n{\n  string str[505];\n  for(int i = 0; i < n; i++) cin >> str[i];\n\n  bool G[33][33] = {{false}};\n  for(int i = 0; i < n-1; i++) {\n    if(str[i].size() < str[i+1].size()) return true;\n    for(int j = 0; j < str[i].size(); j++) {\n      if(str[i][j] != str[i+1][j]) {\n\tif(G[str[i+1][j]-'a'][str[i][j]-'a']) return true;\n\tG[str[i][j]-'a'][str[i+1][j]-'a'] = true;\n\tbreak;\n      }\n    }\n  }\n  \n  for(int i = 0; i < 26; i++) {\n    for(int j = 0; j < 26; j++) {\n      for(int k = 0; k < 26; k++) {\n\tG[j][k] |= G[j][i] & G[i][k];\n      }\n    }\n  }\n  \n  bool ans = false;\n  for(int i = 0; i < 26; i++) ans |= G[i][i];\n\n  return ans;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n, n) {\n    cout << (solve(n) ? \"no\" : \"yes\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <tuple>\n\nbool includes(std::string const& s, std::string const& t) {\n  // s == \"ab\", t == \"a\"  => true\n  // s == \"a\",  t == \"a\"  => false\n  // s == \"a\",  t == \"ab\" => false\n  if (s.length() <= t.length()) return false;\n  return (s.compare(0, t.length(), t) == 0);\n}\n\nstd::pair<char, char> critical(std::string const& s, std::string const& t) {\n  size_t n = std::min(s.length(), t.length());\n  for (size_t i = 0; i <= n; ++i) {\n    if (s[i] == t[i]) continue;\n    if (s[i] == 0 || t[i] == 0) return {0, 0};  // no constraints\n    return {s[i]-'a', t[i]-'a'};\n  }\n  return {0, 0};  // no constraints\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<std::string> s(n);\n  for (size_t i = 0; i < n; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n  }\n\n  size_t sigma = 26;\n  std::vector<std::vector<int>> g0(sigma, std::vector<int>(sigma));\n\n  for (size_t i = 0; i < n; ++i)\n    for (size_t j = i+1; j < n; ++j) {\n      size_t lc, gc;\n      if (includes(s[i], s[j])) return puts(\"no\"), 0;\n      std::tie(lc, gc) = critical(s[i], s[j]);\n      g0[lc][gc] = 1;\n    }\n\n  std::vector<std::vector<size_t>> g(sigma);\n  std::vector<size_t> indeg(sigma);\n  for (size_t i = 0; i < sigma; ++i)\n    for (size_t j = 0; j < sigma; ++j)\n      if (i != j && g0[i][j]) {\n        g[i].push_back(j);\n        // fprintf(stderr, \"%c -> %c\\n\", char(i+'a'), char(j+'a'));\n        ++indeg[j];\n      }\n\n  std::queue<size_t> q;\n  for (size_t i = 0; i < sigma; ++i)\n    if (indeg[i] == 0) q.push(i);\n\n  while (!q.empty()) {\n    size_t v = q.front();\n    // fprintf(stderr, \"pop: %c\\n\", char(v+'a'));\n    q.pop();\n    for (auto u: g[v]) {\n      // fprintf(stderr, \"reached: %c\\n\", char(u+'a'));\n      if (--indeg[u] == 0) q.push(u);\n    }\n  }\n\n  if (*std::max_element(indeg.begin(), indeg.end()) != 0) {\n    puts(\"no\");\n  } else {\n    puts(\"yes\");\n  }\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint degree[30]; // テ暗ォ\nint n;\nint grid[30][30];\nchar str[2][20];\nint vis[30];\nint que[30];\nint main()\n{\n    while(scanf(\"%d\", &n))\n    {\n        if(n == 0)\n            break;\n        int ans = 0;\n        int cnt = 0;\n        memset(degree, 0, sizeof(degree));\n        memset(grid, 0, sizeof(grid));\n        memset(vis, 0, sizeof(vis));\n        scanf(\"%s\", str[ans]);\n        bool flag = true;\n        for(int i = 1; i < n; i++)\n        {\n            scanf(\"%s\", str[ans^1]);\n            int len1 = strlen(str[ans]);\n            int len2 = strlen(str[ans^1]);\n            int j;\n            for( j = 0; j < len1 && j < len2 ; j++)\n            {\n                if(str[ans][j] != str[ans^1][j])\n                {\n                    int a = str[ans][j] - 'a';\n                    int b = str[ans^1][j] - 'a';\n                    if(!vis[a])\n                    {\n                        vis[a] = 1;\n                        cnt++;\n                    }\n                    if(!vis[b])\n                    {\n                        vis[b] = 1;\n                        cnt++;\n                    }\n                    if(grid[a][b] == 0)\n                    {\n                        degree[b]++;\n                        grid[a][b] = 1;\n                    }\n                    break;\n                }\n            }\n            if(j == len2 && j< len1)\n            {\n                flag = false;\n            }\n            ans = ans^1;\n        }\n        /*\n        for(int i = 0; i <= 5; i++)\n        {\n            printf(\"%d\\n\", degree[i]);\n            for(int j = 0; j <= 5; j++)\n            {\n                printf(\"%d  \", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        */\n        if(!flag)\n        {\n            printf(\"no\\n\");\n            continue;\n        }\n        int l = 0, r = 0;\n        for(int i = 0; i < 30; i++)\n            if(vis[i] && degree[i] == 0)\n            {\n                que[r++] = i;\n            }\n        if(r == 0)\n        {\n            printf(\"no\\n\");\n            continue;\n        }\n       // printf(\"---------\\n\");\n        while(l < r && flag)\n        {\n            int u = que[l++];\n            cnt--;\n            if(cnt == 0)\n                break;\n            //printf(\"%c\\n\", u+'a');\n            degree[u] = -1;\n            for(int i = 0; i < 30; i++)\n            {\n                if(vis[i] && grid[u][i] && degree[i] != -1)\n                {\n                    degree[i]--;\n                    if(degree[i] == 0)\n                    {\n                        que[r++] = i;\n                    }\n                }\n            }\n            flag = false;\n            for(int i = 0; i < 30; i++)\n            {\n                if(degree[i] == 0  && vis[i])\n                {\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        if(!flag)\n            printf(\"no\\n\");\n        else\n            printf(\"yes\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tbool no = false;\n\t\tint dag[128][128]={};\n\t\tstring p;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif(i){\n\t\t\t\tint j = 0;\n\t\t\t\twhile( j < min(p.size(),s.size()) && s[j] == p[j] ) j++;\n\t\t\t\t\n\t\t\t\tif( j != p.size() && j != s.size() ){\n\t\t\t\t\tdag[p[j]][s[j]] = true;\n\t\t\t\t}else{\n\t\t\t\t\tif( p.size() > s.size() )\n\t\t\t\t\t\tno = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = s;\n\t\t}\n\t\tif( no ){\n\t\t\tcout << \"no\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++){\n\t\t\t\tfor(int k = 'a' ; k <= 'z' ; k++){\n\t\t\t\t\tdag[j][k] |= dag[j][i] & dag[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring yes = \"yes\";\n\t\tfor(int i = 'a' ; i <= 'z' ; i++)\n\t\t\tif( dag[i][i] ) yes = \"no\";\n\t\tcout << yes << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n// Inserted snippets: io, root\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntemplate<typename H> bool chmin(H& v1, const H v2) { if (v1 > v2) { v1 = v2; return true; } return false; }\ntemplate<typename H> bool chmax(H& v1, const H v2) { if (v1 < v2) { v1 = v2; return true; } return false; }\ntemplate<typename H> void read(H& head) { cin >> head; }\ntemplate<typename H, typename ...T> void read(H& head, T& ...tail) { cin >> head; read(tail...); }\ntemplate<typename H> void write(H head) { cout << head << '\\n'; }\ntemplate<typename H, typename ...T> void write(H head, T ...tail) { cout << head << \" \"; write(tail...); }\ntemplate<typename ...T> void die(T ...tok) { write(tok...); exit(0); }\n// End snippets\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(cin.failbit);\n\n\tint n;\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\tstring s; read(s);\n\t\tbool done = false;\n\n\t\tvector<int> indeg(26);\n\t\tvector<vi> g(26);\n\n\t\trep(i, 1, n) {\n\t\t\tstring t; read(t);\n\t\t\tif (done) continue;\n\n\t\t\tif (s == t || t.substr(0, sz(s)) == s) {\n\t\t\t\ts = t; continue;\n\t\t\t}\n\n\t\t\tif (s.substr(0, sz(t)) == t) {\n\t\t\t\twrite(\"no\"); done = true; continue;\n\t\t\t}\n\n\t\t\t// build edge\n\t\t\tint id = 0;\n\t\t\twhile (s[id] == t[id]) ++id;\n\t\t\tint p = s[id] - 'a', q = t[id] - 'a';\n\t\t\tif (find(all(g[p]), q) == g[p].end()) {\n\t\t\t\tg[p].push_back(q);\n\t\t\t\tindeg[q]++;\n\t\t\t}\n\n\t\t\ts = t;\n\t\t}\n\n\t\tif (!done) {\n\t\t\tvector<int> ord;\n\t\t\tqueue<int> q;\n\t\t\trep(i, 0, 26) if (!indeg[i]) q.push(i);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint h = q.front(); q.pop();\n\t\t\t\tord.push_back(h);\n\t\t\t\tfor (int e : g[h]) {\n\t\t\t\t\tindeg[e]--;\n\t\t\t\t\tif (!indeg[e])\n\t\t\t\t\t\tq.push(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twrite(sz(ord) == 26 ? \"yes\" : \"no\");\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 100000\nstruct SCC{\n  int V; \n  vector<int> G[MAX_V];  //グラフの隣接リスト\n  vector<int> rG[MAX_V]; //逆に辺を貼ったグラフの隣接リスト\n  vector<int> vs;        //帰り掛け順の並び\n  bool used[MAX_V];      //すでに調べたか\n  int cmp[MAX_V];        //属する強連結成分のトポロジカル順序\n\n  SCC(int v){\n    V=v;\n    fill_n(used,MAX_V,0);\n    fill_n(cmp,MAX_V,0);\n  }\n  \n  void add_edge(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n\n  void dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++)\n      if(!used[G[v][i]])dfs(G[v][i]);\n    vs.push_back(v); //探索終了したものから追加\n  }\n\n  void rdfs(int v,int k){\n    used[v]=true;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++)\n      if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n\n  int scc(){\n    memset(used,0,sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++)\n      if(!used[v])dfs(v);\n\n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--)\n      if(!used[vs[i]])rdfs(vs[i],k++);\n\n    return k;\n  }\n};\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string s[555];\n    int ans=1;\n    SCC sc(33);\n    for(int i=0;i<n;i++)cin>>s[i];\n    \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tstring a=s[i],b=s[j];\n\tint l=min(a.size(),b.size());\n\tif(a==b)continue;\n\tint flg=1;\n\tfor(int k=0;k<l;k++){\n\t  if(a[k]==b[k])continue;\n\t  flg=0;\n\t  sc.add_edge(a[k]-'a',b[k]-'a');\n\t  break;\n\t}\n\tif(flg)ans=0;\n      }\n    }\n    int tmp=sc.scc();\n    if(tmp==33&&ans)cout<<\"yes\"<<endl;\n    else cout<<\"no\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<int> edge[100];\n\nint dfs(int x, int d = 0){\n\tif(d > 30)return -1;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tif(dfs(edge[x][i], d + 1) == -1)return -1;\n\t}\n\treturn 0;\n}\n\nbool ok(){\n\tfor(int i = 'a';i <= 'z';i++){\n\t\tif(dfs(i) == -1)return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tstring str, last;\n\twhile(cin >> n, n){\n\t\tfor(int i = 'a';i <= 'z';i++)edge[i].clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> str;\n\t\t\tif(i){\n\t\t\t\tfor(int i = 0;i < last.size();i++){\n\t\t\t\t\tif(i == str.size()){\n\t\t\t\t\t\tcout << \"no\" << endl;\n\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[i] != last[i]){\n\t\t\t\t\t\tedge[last[i]].push_back(str[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = str;\n\t\t}\n\t\tcout << (ok()?\"yes\":\"no\") << endl;\nfail:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nchar a[502][12];\nint main()\n{\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        if(n==0)\n        break;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",a[i]);\n            //printf(\"%s\\n\",a[i]);\n        }\n        //蛻、譁ュ譏ッ蜷ヲ譏ッ豁」蠎?        int flag=0;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(strcmp(a[i],a[j])==0)\n                {\n                    continue;\n                }\n                else if(strcmp(a[i],a[j])<0)\n                {\n                    int len=strlen(a[j]);\n                    int flag1=0;\n                    for(int k=0;k<len;k++)\n                    {\n                        if(a[i][k]!=a[j][k])\n                        {\n                            flag1=1;\n                            break;\n                        }\n                    }\n                    if(flag1==0)\n                    {\n                        flag=1;\n                        break;\n                    }\n                }\n                else\n                {\n                    int len=strlen(a[j]);\n                    int flag5=0;\n                    for(int k=0;k<len;k++)\n                    {\n                        if(a[i][k]!=a[j][k])\n                        {\n                            flag5=1;\n                            break;\n                        }\n                    }\n                    if(flag5==0)\n                    continue;\n                    else\n                    {\n                        flag=1;\n                     break;\n                    }\n\n                }\n\n            }\n            if(flag==1)\n            break;\n        }\n        if(flag==0)\n        printf(\"yes\\n\");\n        else\n        {\n            int flag1=0;\n            int flag3=0,flag2=0;\n            for(int i=0;i<n;i++)\n            {\n                for(int j=i+1;j<n;j++)\n                {\n                    if(strcmp(a[i],a[j])==0)\n                    continue;\n                    else if(strcmp(a[i],a[j])<0)\n                    {\n                        int len=strlen(a[i]);\n                        int flag4=0;\n                        for(int k=0;k<len;k++)\n                        {\n                            if(a[i][k]!=a[j][k])\n                            {\n                                flag4=1;\n                                break;\n                            }\n                        }\n                        if(flag4==0)\n                        continue;\n                        else\n                        {\n                            flag1=1;\n                            flag3=1;\n                            printf(\"no\\n\");\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        int len=strlen(a[j]);\n                        flag2=0;\n                       for(int k=0;k<len;k++)\n                       {\n                           if(a[j][k]!=a[i][k])\n                           {\n                               flag2=1;\n\n                               break;\n                           }\n                       }\n                       if(flag2==0)\n                       {\n                           flag3=1;\n                           printf(\"no\\n\");\n                           break;\n                       }\n                    }\n                }\n                if(flag1==1)\n                {\n                    break;\n                }\n                if(flag2==0)\n                {\n                    break;\n                }\n            }\n            if(flag3==0)\n            printf(\"yes\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        char s[505][10];\n        rep(i,505) rep(j,10) s[i][j] = '\\0';\n        rep(i,n) cin >> s[i];\n\n        map<pair<char,char>,int> m;\n        bool ans = true;\n        rep(i,n - 1){\n            rep(j,10){\n                if(s[i][j] != '\\0' && s[i + 1][j] == '\\0'){\n                    ans = false;\n                    break;\n                }else if(s[i][j] == '\\0' || s[i + 1][j] == '\\0'){\n                    break;\n                }else if(s[i][j] != s[i + 1][j]){\n                    m[ make_pair(s[i][j], s[i + 1][j]) ] = 1;\n                    break;\n                }\n            }\n        }\n\n        for(char i = 'a'; i <= 'z'; i++){\n            for(char j = 'a'; j <= 'z'; j++){\n                if(i == j) continue;\n                if(m[make_pair(i,j)] && m[make_pair(j,i)]) ans = false;\n            }\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nbool dfs(int pos, int start, const vector<vector<int>> &graph, vector<bool> &visited) {\n    if(visited[pos]) return false;\n\n    visited[pos] = true;\n    for(int v : graph[pos]) {\n        if(v == start) return true;\n        if(dfs(v, start, graph, visited)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    vector<string> v(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> v[i];\n    }\n    vector<vector<int>> graph(26);\n    for(int i = 0; i < N-1; ++i) {\n        const string &s1 = v[i];\n        const string &s2 = v[i+1];\n        if(s1.size() > s2.size() && s1.substr(0, s2.size()) == s2) {\n            cout << \"no\" << endl;\n            return true;\n        }\n        for(int j = 0; j < s1.size() && j < s2.size(); ++j) {\n            if(s1[j] != s2[j]) {\n                graph[s1[j]-'a'].push_back(s2[j]-'a');\n                break;\n            }\n        }\n    }\n    for(int i = 0; i < 26; ++i) {\n        vector<bool> visited(26, false);\n        if(dfs(i, i, graph, visited)) {\n            cout << \"no\" << endl;\n            return true;\n        }\n    }\n    cout << \"yes\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 1e9;\n\nbool has_loop(vector< vector<int> > G){\n  int n = G.size();\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i){\n    if(G[i][i] < INF) return true;\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> S(n);\n    for(int i = 0; i < n; ++i){\n      cin >> S[i];\n    }\n    if(n == 1) cout << \"yes\" << endl;\n    vector< vector<int> > G(26, vector<int>(26,INF));\n    bool f = true;\n    for(int i = 1; i < n; ++i){\n      if(S[i-1] == S[i]) continue;\n      for(int j = 0; j < min(S[i].length(),S[i-1].length()); ++j){\n        f = true;\n        if(S[i][j] != S[i-1][j]){\n          //G[S[i-1][j] - 'a'].push_back(S[i][j] - 'a');\n          G[S[i-1][j] - 'a'][S[i][j] - 'a'] = 1;\n          f = false;\n          break;\n        }\n      }\n      if(f && S[i-1].size() > S[i].size()){\n        cout << \"no\" << endl;\n        break;\n      }else{\n        f = false;\n      }\n    }\n    if(f) continue;\n\n    if(has_loop(G)) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nstring S[500];\n\nvint G[26];\nvoid solve(){\n    rep(i,26)G[i].clear();\n    rep(i,N)reps(j,i+1,N){\n        int k=0;\n        while(k<S[i].size()&&k<S[j].size()&&S[i][k]==S[j][k])k++;\n        if(k==S[i].size()||k==S[j].size()){\n            if(S[i].size()>S[j].size()){\n                cout<<\"no\"<<endl;\n                return;\n            }\n            continue;\n        }\n        G[S[i][k]-'a'].pb(S[j][k]-'a');\n    }\n    rep(i,26){\n        sort(all(G[i]));\n        G[i].erase(unique(all(G[i])),G[i].end());\n    }\n\n    vint deg(26);\n    rep(i,26)rep(j,G[i].size())deg[G[i][j]]++;\n    queue<int>que;\n    rep(i,26)if(deg[i]==0)que.push(i);\n    while(que.size()){\n        int v=que.front();\n        que.pop();\n        for(auto u:G[v]){\n            if(--deg[u]==0)que.push(u);\n        }\n    }\n    rep(i,26)if(deg[i]){\n    cout<<\"no\"<<endl;return;}\n    cout<<\"yes\"<<endl;\n}\n\nsigned main(){\n    while(cin>>N,N){\n        rep(i,N)cin>>S[i];\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN=555;\nint n;\nchar str[MAXN][22];\nint vis[26][26];\nint in[26];\nqueue<int> q;\n\nbool topsort()\n{\n    while(!q.empty())   q.pop();\n    for(int i=0;i<26;i++)  if(in[i]==0)   q.push(i);\n    int num=0;\n    while(!q.empty())\n    {\n        int u=q.front();q.pop();num++;\n        for(int i=0;i<26;i++)\n            if(vis[u][i]==1)\n            {\n                in[i]--;\n                if(in[i]==0)   q.push(i);\n            }\n    }\n    return num==26;\n}\n\nbool check()\n{\n    memset(vis,0,sizeof vis);memset(in,0,sizeof in);\n    for(int i=2;i<=n;i++)\n    {\n        for(int j=0;str[i][j] || str[i-1][j];j++)\n        {\n            if(str[i][j]==str[i-1][j])  continue;\n            if(!str[i][j])    return false;\n            char x=str[i-1][j]-'a',y=str[i][j]-'a';\n            if(vis[y][x])   return false;\n            if(!vis[x][y])\n            {\n                vis[x][y]=1;\n                in[y]++;\n            }\n            break;\n        }\n    }\n    return topsort();\n}\n\n\nint main()\n{\n    //freopen(\"data.txt\",\"r\",stdin);\n    while(scanf(\"%d\",&n)==1 && n)\n    {\n        memset(str,0,sizeof str);\n        for(int i=1;i<=n;i++)\n            scanf(\"%s\",str[i]);\n        if(check())\n            puts(\"yes\");\n        else\n            puts(\"no\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<string> s(n);\n        REP(i, n) cin >> s[i];\n\n        bool t[26][26] = {};\n\n        REP(i, n-1) {\n            string s1 = s[i];\n            string s2 = s[i+1];\n            REP(j, s1.length()) {\n                if ((int)s2.length() <= j) {\n                    cout << \"no\" << endl;\n                    goto NEXT;\n                }\n                if (s1[j] != s2[j]) {\n//                    LOG(\"--> %c < %c\\n\", s1[j], s2[j]);\n                    t[s1[j]-'a'][s2[j]-'a'] = true;\n                    break;\n                }\n            }\n        }\n\n        REP(i, 26) REP(j, 26) REP(k, 26) t[j][k] |= t[j][i] && t[i][k];\n\n        // ???????????????????????°no\n        REP(i, 26) {\n            if (t[i][i]) {\n                cout << \"no\" << endl;\n                goto NEXT;\n            }\n        }\n        cout << \"yes\" << endl;\nNEXT: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<int> G[26]; bool f = true;\n\t\tstring s, t;\n\t\tcin >> t;\n\t\trep(i, n - 1) {\n\t\t\ts = t; cin >> t;\n\t\t\tif (!f)continue;\n\t\t\tint len1 = s.length();\n\t\t\tint len2 = t.length();\n\t\t\tint len = min(len1, len2);\n\t\t\tif (s.substr(0, len) == t.substr(0, len)) {\n\t\t\t\tif (len1 > len2)f = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(j, len) {\n\t\t\t\t\tif (s[j] != t[j]) {\n\t\t\t\t\t\tG[s[j] - 'a'].push_back(t[j] - 'a'); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 26) {\n\t\t\tint used[26] = {}; used[i] = 1;\n\t\t\tqueue<int> q; q.push(i);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint v = q.front(); q.pop();\n\t\t\t\tint len = G[v].size();\n\t\t\t\trep(j, len) {\n\t\t\t\t\tif (G[v][j] == i) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!used[G[v][j]]) {\n\t\t\t\t\t\tused[G[v][j]] = 1;\n\t\t\t\t\t\tq.push(G[v][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f)break;\n\t\t}\n\t\tif (f) cout << \"yes\" << endl;\n\t\telse cout << \"no\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int kNumAlphabets = 26;\n\nvi used;\nvvi edge;\nstring res;\n\nvoid dfs(int v){\n    if(used[v]){\n        res = \"no\";\n        return;\n    }\n\n    used[v] = true;\n\n    rep(u, kNumAlphabets){\n        if(edge[v][u]) dfs(u);\n    }\n}\n\nint main(void){\n    for(int n; cin >> n, n; cout << res << endl){\n        res = \"yes\";\n        edge = vvi(kNumAlphabets, vi(kNumAlphabets));\n\n        string pre; cin >> pre;\n        rep(i, n - 1){\n            string cur; cin >> cur;\n\n            bool same = true;\n            rep(j, min(pre.size(), cur.size())){\n                if(pre.at(j) != cur.at(j)){\n                    edge[pre.at(j) - 'a'][cur.at(j) - 'a'] = true;\n                    same = false;\n                    break;\n                }\n            }\n            if(same && cur.size() < pre.size()) res = \"no\";\n\n            pre = cur;\n        }\n\n        rep(u, kNumAlphabets){\n            used = vi(kNumAlphabets);\n            dfs(u);\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint g[30][30];\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> s(n);\n    for(int i=0;i<n;i++)cin >> s[i];\n\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++){\n\t  g[i][j] = 1e9;\n      }\n      g[i][i] = 0;\n    }\n\n    bool f = true;\n    for(int i=1;i<n;i++){\n      int len = min(s[i-1].size(), s[i].size()), j;\n      for(j=0;j<len;j++){\n\tif(s[i-1][j]!=s[i][j])break;\n      }\n\n      if(j==len){\n\tif(s[i-1].size() > s[i].size()){\n\t  f = false;\n\t}\n      }else{\n\tg[s[i-1][j]-'a'][s[i][j]-'a'] = -1;\n      }\n    }\n\n    for(int k=0;k<26;k++){\n      for(int i=0;i<26;i++){\n\tfor(int j=0;j<26;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    for(int i=0;i<26;i++){\n      if(g[i][i] < 0) f = false;\n    }\n\n    cout << (f?\"yes\":\"no\") << endl;\n  }   \n}\n#include<bits/stdc++.h>\nusing namespace std;\n\nint g[30][30];\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> s(n);\n    for(int i=0;i<n;i++)cin >> s[i];\n\n    for(int i=0;i<26;i++){\n      for(int j=0;j<26;j++){\n\t  g[i][j] = 1e9;\n      }\n      g[i][i] = 0;\n    }\n\n    bool f = true;\n    for(int i=1;i<n;i++){\n      int len = min(s[i-1].size(), s[i].size()), j;\n      for(j=0;j<len;j++){\n\tif(s[i-1][j]!=s[i][j])break;\n      }\n\n      if(j==len){\n\tif(s[i-1].size() > s[i].size()){\n\t  f = false;\n\t}\n      }else{\n\tg[s[i-1][j]-'a'][s[i][j]-'a'] = -1;\n      }\n    }\n\n    for(int k=0;k<26;k++){\n      for(int i=0;i<26;i++){\n\tfor(int j=0;j<26;j++){\n\t  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t}\n      }\n    }\n\n    for(int i=0;i<26;i++){\n      if(g[i][i] < 0) f = false;\n    }\n\n    cout << (f?\"yes\":\"no\") << endl;\n  }   \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nusing graph = vector<vector<int>>;\n \nvoid dfs(int v, const graph& G, vector<int>& res, vector<int>& used) {\n    used[v] = 1;\n    for (auto to : G[v]) if (used[to] == 0) {\n        dfs(to, G, res, used);\n    }\n    res.push_back(v);\n    //cout<<v<<endl;\n}\n \nvector<int> topo_sort(const graph& G) {\n    int V = G.size();\n    vector<int> ide(V);\n    for (int i = 0; i < V; i++) {\n        for (auto to : G[i]) {\n            //cout<<to<<endl;\n            ide[to]++;\n        }\n    }\n    vector<int> res;\n    vector<int> used(V);\n    for (int i = V - 1; i >= 0; i--) {\n        if (ide[i] == 0) {\n            //cout<<i<<endl;\n            dfs(i, G, res, used);\n        }\n    }\n    if(res.size()==0) res={-1};\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        for(int i=0;i<n;i++) cin>>s[i];\n        if(n==1){\n            cout<<\"yes\"<<endl;\n            continue;\n        }\n        graph g(26);\n        for(int i=1;i<n;i++){\n            int len=min(s[i-1].length(),s[i].length());\n            for(int j=0;j<len;j++){\n                if(s[i-1][j]==s[i][j]) continue;\n                int st=s[i-1][j]-'a',gt=s[i][j]-'a';\n                g[st].push_back(gt);\n                break;\n            }\n        }\n        vector<int> res=topo_sort(g);\n        //cout<<res.size()<<endl;\n        if(res.size()!=26){\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        map<int,int> mp;\n        for(int i=0;i<26;i++){\n            mp[res[i]]=i;\n        }\n        for(int i=0;i<n;i++){\n            int len=s[i].length();\n            for(int j=0;j<len;j++){\n                int idx=s[i][j]-'a';\n                idx=mp[idx];\n                s[i][j]='a'+idx;\n            }\n        }\n        bool f=true;\n        for(int i=1;i<n;i++){\n            if(s[i-1]>s[i]) f=false;\n        }\n        if(f) cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nbool dfs(int pos, int start, const vector<vector<int>> &graph, vector<bool> &visited) {\n    if(visited[pos]) return false;\n\n    visited[pos] = true;\n    for(int v : graph[pos]) {\n        if(v == start) return true;\n        if(dfs(v, start, graph, visited)) return true;\n    }\n    return false;\n}\n\nbool solve() {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    vector<string> v(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> v[i];\n    }\n    vector<vector<int>> graph(26);\n    for(int i = 0; i < N-1; ++i) {\n        const string &s1 = v[i];\n        const string &s2 = v[i+1];\n        if(s1.size() > s2.size() && s1.substr(0, s2.size()) == s2) {\n            cout << \"no\" << endl;\n            return true;\n        }\n        for(int j = 0; j < s1.size() && j < s2.size(); ++j) {\n            if(s1[j] != s2[j]) {\n                graph[s1[j]-'a'].push_back(s2[j]-'a');\n                break;\n            }\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        vector<bool> visited(26, false);\n        if(dfs(i, i, graph, visited)) {\n            cout << \"no\" << endl;\n            return true;\n        }\n    }\n    cout << \"yes\" << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <complex>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef vector<string> vst;\ntypedef pair<int,int> pint;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define all(s) (s).begin(),(s).end()\n#define each(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define debug(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\ntemplate<class T> void print(T P[], int n) {cout<<\"{ \";for(int i=0;i<n;++i){if(i>0)cout<<\", \";cout<<P[i];}cout<<\" }\"<<'\\n';}\ntemplate<class T> void print(T P[][30], int n, int m) {for(int i=0;i<n;++i){cout<<i<<\" : \";print(P[i],m);}}\n\n\n\nint n;\nvst str;\n\nbool d[30][30];\n\nstring solve() {\n    map<char,int> ma;\n    for (int i = 0; i < 26; ++i) ma[(char)('a'+i)] = i;\n\n    memset(d, 0, sizeof(d));\n    for (int i = 1; i < str.size(); ++i) {\n        string s1 = str[i-1];\n        string s2 = str[i];\n        \n        for (int j = 0; j < min((int)s1.size(), (int)s2.size()); ++j) {\n            if (s1[j] != s2[j]) {\n                d[ma[s1[j]]][ma[s2[j]]] = true;\n                break;\n            }\n            else if (j == min((int)s1.size(), (int)s2.size())-1 && s1.size() > s2.size()) {\n                return \"no\";\n            }\n        }\n    }\n    \n    bool ok = true;\n    for (int k = 0; k < 26; ++k) {\n        for (int i = 0; i < 26; ++i) {\n            for (int j = 0; j < 26; ++j) {\n                d[i][j] |= d[i][k] & d[k][j];\n            }\n        }\n    }\n    \n    for (int i = 0; i < 26; ++i) {\n        if (d[i][i]) ok = false;\n    }\n    \n    //print(d, 26, 26);\n    \n    return ok ? \"yes\" : \"no\";\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/JAG Practice Asia 2012 A - Dictionary.in\", \"r\", stdin );\n    \n    while (cin >> n) {\n        if (n == 0) break;\n        str.clear();\n        for (int i = 0; i < n; ++i) {\n            string temp;\n            cin >> temp;\n            str.pb(temp);\n        }\n        cout << solve() << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 文字に適切な順序を定めて、入力が辞書順になるようにできるか\n// 適当に辺を貼って閉路見つける\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring s[500];\nbool f[500][500];\nbool g[27][27];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tmemset(f, 0, sizeof(f));\n\t\tmemset(g, 0, sizeof(g));\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t\ts[i] += 'a' - 1;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= 10; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tfor (int k = j + 1; k < n; k++){\n\t\t\t\t\tif (f[j][k]) continue;\n\t\t\t\t\tif (i >= min(s[j].size(), s[k].size())) continue;\n\t\t\t\t\tif (s[j][i] != s[k][i]){\n\t\t\t\t\t\tg[s[j][i] - 'a' + 1][s[k][i] - 'a' + 1] = true;\n\t\t\t\t\t\tf[j][k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 27; k++){\n\t\t\tfor (int i = 0; i < 27; i++){\n\t\t\t\tfor (int j = 0; j < 27; j++){\n\t\t\t\t\tg[i][j] |= g[i][k] && g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool res = true;\n\t\tfor (int i = 0; i < 27; i++){\n\t\t\tif (g[i][i]) res = false;\n\t\t}\n\t\t\n\t\tcout << (res ? \"yes\" : \"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_V 26\n \nint res;\nbool found;\nvector<int> G[MAX_V];\nint visited[MAX_V],num[MAX_V];\n \nvoid dfs(int v,int c){\n  visited[v] = 0; num[v] = c;\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    int to = G[v][i];\n    if(visited[to] == -1){\n      dfs(to,c+1);\n    }else if(visited[to] == 0){\n      res = max(res,num[v]-num[to]+1);\n    }\n  }\n  visited[v] = 1;\n}\n \nint getLargestCycle(){\n  res = 0;\n  memset(num,-1,sizeof(num));\n  memset(visited,-1,sizeof(visited));\n  for(int i = 0 ; i < 26 ; i++){\n    if(visited[i] == -1){\n      dfs(i,1);\n    }\n  }\n  return res;\n}\n \nvoid init(){\n    found = false;\n    for(int i = 0 ; i < MAX_V ; i++){\n        G[i].clear();\n    }\n}\n \nbool valid(string &a, string &b){\n    int A = a.size(),B = b.size();\n    if(A <= B) return true;\n    for(int i = 0 ; i < B ; i++){\n        if(a[i] != b[i]) return true;\n    }\n    return false;\n}\n \nbool check(vector<string> &v){\n    int N = v.size();\n    for(int i = 0 ; i < N-1 ; i++){\n        if(!valid(v[i],v[i+1])) return false;\n        int a = v[i].size(),b = v[i+1].size();\n        for(int j = 0 ; j < min(a,b) ; j++){\n            if(v[i][j] != v[i+1][j]){\n                G[v[i][j]-'a'].push_back(v[i+1][j]-'a');\n                break;\n            }\n        }\n    }\n    return (getLargestCycle() < 2);\n}\n \nint main(){\n    int N;\n    while(cin >> N, N){\n        vector<string> v(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> v[i];\n        }\n        init();\n        cout << (check(v) ? \"yes\" : \"no\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// トポソ\n// O(V + E)\n// [入力] 重みなし有効グラフ\n// [出力] ソートされた頂点列(0-indexed) DAG じゃ無い場合は空列を返す\nvector<int> toposort(vector<vector<int>> &g){\n    int n = (int)g.size();\n    vector<int> d(n, 0);     // 入次数\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < (int)g[i].size(); j++){\n            d[g[i][j]]++;\n        }\n    }\n    \n    // 入次数が 0 の頂点を queue に入れる\n    queue<int> que;\n    for(int i = 0; i < n; i++){\n        if(d[i] == 0) que.push(i);\n    }\n\n    vector<int> ret;\n    while(!que.empty()){\n        int cur = que.front();\n        que.pop();\n        ret.push_back(cur);\n\n        for(int i = 0; i < (int)g[cur].size(); i++){\n            int nxt = g[cur][i];\n            d[nxt]--;\n            if(d[nxt] == 0) que.push(nxt);\n        }\n    }\n\n    // DAG じゃなかったら、頂点列が不足しているはず\n    if(ret.size() == n) return ret;\n    else return vector<int>();\n\n}\n\nsigned main(){\n    \n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        vector<string> vs(n);\n        for(int i = 0; i < n; i++) cin >> vs[i];\n        \n        vector<vector<int>> g(26);\n    \n        // a -> b\n        bool end = false;\n        for(int i = 0; i < n - 1; i++){\n            //cout << i << endl;\n            int x = (int)vs[i].size();\n            int y = (int)vs[i + 1].size();\n\n            bool change = false;\n            for(int si = 0; si < min(x, y); si++){\n                if(vs[i][si] == vs[i + 1][si]) continue;\n                \n                change = true;\n                int from = vs[i + 1][si] - 'a';\n                int to = vs[i][si] - 'a';\n                g[from].push_back(to);\n                break;\n            }\n\n            if(!change){\n                if(x > y){\n                    cout << \"no\" << endl;\n                    end = true;\n                    break;\n                }\n            }\n        }\n        if(end) continue;\n    \n        \n        // 閉路判定\n        \n        if(toposort(g).size() != 0) cout << \"yes\" << endl;\n        else cout << \"no\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nvoid solve(int n){\n    string s[n];\n    rep(i,n)cin>>s[i];\n    vector<int> v[26];\n    vector<int> cnt(26);\n    rep(i,n-1){\n        int m=min(s[i].size(),s[i+1].size());\n        bool used=0;\n        rep(j,m){\n            if(s[i][j]!=s[i+1][j]){\n                v[s[i][j]-'a'].push_back(s[i+1][j]-'a');\n                cnt[s[i+1][j]-'a']++;\n                used=true;\n                break;\n            }\n        }\n        if(!used&&s[i].size()>m){\n            cout<<\"no\"<<endl;\n            return;\n        }\n    }\n    queue<int> q;\n    int ans=0;\n    rep(i,26){\n        if(!cnt[i])++ans,q.push(i);\n    }\n    while(q.size()){\n        int x=q.front();q.pop();\n        for(auto to : v[x]){\n            if(--cnt[to]==0)++ans,q.push(to);\n        }\n    }\n    if(ans==26)cout<<\"yes\"<<endl;\n    else cout<<\"no\"<<endl;\n}\nint main(){\n    int n;\n    while(cin>>n,n)solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nbool G[26][26];\nbool f[26];\nbool ans;\n\nvoid dfs(int now, int root){\n    // cout << now << endl;\n    if(f[now]){\n        if(now == root) ans = false;\n        return;\n    }\n    f[now] = true;\n    rep(i, 0, 26){\n        if(G[now][i]) dfs(i, root);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(cin >> n, n){\n        vector<string> s(n);\n        ans = true;\n        rep(i, 0, 26) rep(j, 0, 26) G[i][j] = false;\n        rep(i, 0, n){\n            cin >> s[i];\n        } \n        rep(i, 0, n - 1){\n            int lm = min(s[i].size(), s[i + 1].size());\n            bool same = true;\n            rep(j, 0, lm){\n                if(s[i][j] == s[i + 1][j]) continue;\n                else{\n                    same = false;\n                    G[s[i][j] - 'a'][s[i + 1][j] - 'a'] = true;\n                    break;\n                }\n            }\n            if(same){\n                if(s[i].size() > s[i + 1].size()){\n                    ans = false;\n                    break;\n                }\n            }\n        }\n        rep(i, 0, 26){\n            memset(f, false, sizeof(f));\n            dfs(i, i);\n        }\n        if(ans) cout << \"yes\" << endl;\n        else cout << \"no\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define eps 1e-8\n#define maxn 100005\n#define mod 1000000009\n\nchar s[505][15];\nvector<int>g[30];\nint deg[30];\nbool v[30];\nvoid topo()\n{\n    queue<int>q;\n    for(int i=0;i<26;i++)   if(deg[i]==0)   q.push(i);\n    int all=0;\n    while(!q.empty())\n    {\n        int now=q.front();\n        if(v[now]==1)\n        {\n            q.pop();\n            continue;\n        }\n        v[now]=1;\n        all++;\n        q.pop();\n        for(int i=0;i<g[now].size();i++)\n        {\n            int temp=g[now][i];\n            deg[temp]--;\n            if(deg[temp]==0)    q.push(temp);\n        }\n    }\n    if(all==26) printf(\"yes\\n\");\n    else printf(\"no\\n\");\n}\nint main()\n{\n    while(1)\n    {\n        int n;\n        scanf(\"%d\",&n);\n        if(n==0)    break;\n        bool flag=0;\n        for(int i=0;i<26;i++)   g[i].clear();\n        for(int i=0;i<26;i++)\n        {\n            deg[i]=0;\n            v[i]=0;\n        }\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",s[i]);\n        }\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                int leni=strlen(s[i]),lenj=strlen(s[j]);\n                bool sign=0;\n                for(int k=0;k<min(leni,lenj);k++)\n                {\n                    if(s[i][k]!=s[j][k])\n                    {\n                        g[s[i][k]-'a'].push_back(s[j][k]-'a');\n                        deg[s[j][k]-'a']++;\n                        sign=1;\n                        break;\n                    }\n                }\n                if(sign==0)\n                {\n                    if(leni>lenj)\n                    {\n                        flag=1;\n                        break;\n                    }\n                }\n            }\n            if(flag==1) break;\n        }\n        if(flag==1) printf(\"no\\n\");\n        else topo();\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    vector<P> dict;\n    \n    char mapping[256];\n    bool used[256];\n    memset(mapping,0,sizeof(mapping));\n    memset(used,false,sizeof(used));\n\n    for(int i=0;i<N;i++){\n      string str;      \n      cin >> str;\n\n      for(int j=0;j<str.size();j++){\n        if(mapping[str[j]] == 0){\n          for(char alter='a';alter<='z';alter++){\n            if(!used[alter]){\n              mapping[str[j]] = alter;\n              used[alter] = true;\n              break;\n            }\n          }\n        }\n      }\n      \n      string next = \"\";\n      for(int j=0;j<str.size();j++){\n        next.push_back(mapping[str[j]]);\n      }\n      dict.push_back(P(next,i));\n    }\n\n    stable_sort(dict.begin(),dict.end());\n\n    bool isok = true;\n    for(int i=0;i<dict.size();i++){\n      if(dict[i].second != i){\n              isok = false;\n              break;\n      }\n    }\n\n    printf(\"%s\\n\",isok ? \"yes\" : \"no\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\nint dp[55][55][55][55],reach[55][55][55][55];\nchar maz[55][55];\nint n,m;\nvoid dfs(int x,int y,int nx,int ny)\n{\n    cout<<x<<\" \"<<y<<\" \"<<nx<<\" \"<<ny<<endl;\n    if(nx>n||ny>m) return;\n    reach[x][y][nx][ny]=1;\n    if(maz[nx+1][ny]!='#'&&!reach[x][y][nx][ny])\n        dfs(x,y,nx+1,ny);\n    if(maz[nx][ny+1]!='#'&&!reach[x][y][nx][ny])\n        dfs(x,y,nx,ny+1);\n}\nconst int inf=1000000;\nbool check(int x,int y)\n{\n    return maz[x][y]!='#';\n}\nint DP(int x1,int y1,int x2,int y2)\n{\n    if(x1>x2||y1>y2)\n    {\n        return -inf;\n    }\n    if(!reach[x1][y1][x2][y2])\n    {\n        return -inf;\n    }\n    if(x1==x2&&y1==y2) return 0;\n    if((maz[x1][y1]-'a'+'A')==maz[x2][y2])\n    {\n        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1+1,y1,x2-1,y2));\n        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1+1,y1,x2,y2-1));\n        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1,y1+1,x2-1,y2));\n        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1,y1+1,x2,y2-1));\n        return dp[x1][y1][x2][y2]=dp[x1][y1][x2][y2]+1;\n    }\n    else\n    {\n        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1,y1,x2-1,y2));\n        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1,y1,x2,y2-1));\n        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1+1,y1,x2,y2));\n        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1,y1+1,x2,y2));\n        return dp[x1][y1][x2][y2];\n    }\n}\nint main()\n{\n    freopen(\"data.in\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&m)&&n&&m)\n    {\n        for(int i=1;i<=n;i++)\n            scanf(\"%s\",maz[i]+1);\n        memset(dp,-1,sizeof(dp));\n        memset(reach,0,sizeof(reach));\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=m;j++) if(maz[i][j]!='#')\n            {\n                cout<<\"  cao  \"<<endl;\n                dfs(i,j,i,j);\n            }\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=m;j++)\n                for(int k=1;k<=n;k++)\n                    for(int q=1;k<=m;k++)\n                        cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<q<<\" \"<<reach[i][j][k][q]<<endl;\n        cout<<DP(1,1,n,m)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    vector<string> dict;\n    int prior[256][256]; // prior[A][B] ::= A is prior to B or not\n    memset(prior,-1,sizeof(prior));\n\n    bool isok = true;\n    bool res = true;\n    for(int current_idx=0;current_idx<N;current_idx++){\n      string current;\n      cin >> current;\n\n      for(int prev_idx=0;prev_idx<dict.size();prev_idx++){\n        for(int char_idx=0;\n            char_idx < current.size() && char_idx < dict[prev_idx].size();\n            char_idx++){\n          if(current[char_idx] == dict[prev_idx][char_idx]) continue;\n\n          if(prior[dict[prev_idx][char_idx]][current[char_idx]] == 1){\n            break;\n          }\n\n          if(prior[dict[prev_idx][char_idx]][current[char_idx]] == -1){\n            prior[dict[prev_idx][char_idx]][current[char_idx]] = 1;\n            prior[current[char_idx]][dict[prev_idx][char_idx]] = 0;\n            break;\n          }\n        }\n\n        bool isok = true;\n        bool is_first = true;\n        for(int char_idx=0;\n            char_idx < current.size() && char_idx < dict[prev_idx].size();\n            char_idx++){\n          if(current[char_idx] == dict[prev_idx][char_idx]) continue;\n          if(is_first && prior[current[char_idx]][dict[prev_idx][char_idx]] == 1){\n            isok = false;\n            break;\n          }\n          is_first = false;\n        }\n\n        if(isok){\n          if(current.size() < dict[prev_idx].size()\n             && dict[prev_idx].substr(0,current.size()) == current){\n            isok = false;\n          }\n        }\n\n        res &= isok;\n      }\n\n      dict.push_back(current);\n    }\n  found:;\n    printf(\"%s\\n\",res ? \"yes\" : \"no\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    string str[500];\n    int d[128][128];\n    int INF=1<<29;\n    fill(d[0],d[128],INF);\n    for(int i=0;i<128;i++){\n      d[i][i]=0;\n    }\n    bool f=false;\n    for(int i=0;i<n;i++){\n      cin>>str[i];\n      for(int j=0;j<i;j++){\n\tint mm=min(str[i].size(),str[j].size());\n\tif(str[i].compare(0,mm,str[j],0,mm)==0){\n\t  f|=str[i].size()<str[j].size();\n\t}else{\n\t  auto x=mismatch(begin(str[i]),end(str[i]),begin(str[j]));\n\t  d[*x.first][*x.second]=-1;\n\t}\n      }\n    }\n    for(int i=0;i<128;i++){\n      for(int j=0;j<128;j++){\n\tfor(int k=0;k<128;k++){\n\t  if(d[j][i]!=INF&&d[i][k]!=INF){\n\t    d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<128;i++){\n      f|=d[i][i]<0;\n    }\n    cout<<(f?\"no\":\"yes\")<<endl;\n  }\n}\n\n\t   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\nusing namespace std;\nint n;\nstring S[505];\nint G[30][30];\nint main()\n{\n    //freopen(\"data.in\",\"r\",stdin);\n    while(cin>>n)\n    {\n        if(n==0) break;\n\n        for(int i=1;i<=n;i++) cin>>S[i];\n\n        memset(G,0,sizeof(G));\n        bool ok=true;\n        for(int i=1;i<=n;i++)\n            for(int j=i+1;j<=n;j++)\n        {\n            bool t=true;\n\n            for(int k=0;(k<S[i].size())&&(k<S[j].size());k++)\n            {\n                if(S[i][k]!=S[j][k])\n                {\n                    t=false;\n                    G[S[j][k]-'a'][S[i][k]-'a']=1;\n                    break;\n                }\n            }\n            if(t&&(S[i].size()>S[j].size())) ok=false;\n        }\n\n        for(int i=0;i<26;i++)\n            for(int j=0;j<26;j++)\n                if(i!=j)\n            {\n                if(G[i][j]==1&&G[j][i]==1) ok=false;\n            }\n        if(ok) cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int M = 26;\n\nchar g[M + 1][M + 1]; // g[i][j] char[i] > char[j]\nint visit[M + 1];\n\nbool dfs(int i) {\n\tvisit[i] = 1;\n\tfor(int j = 0;j <= M;++j){\n\t\tif(g[i][j]) {\n\t\t\tif(visit[j] == 2) continue;\n\t\t\tif(visit[j] == 1) return false;\n\t\t\tif(!dfs(j)) return false;\n\t\t}\n\t}\n\tvisit[i] = 2;\n\treturn true;\n}\n\nvoid ordering(string &a, string &b){\n\tint len = max(a.length(), b.length());\n\tfor(int i = 0;i < len;++i){\n\t\tif(a.length() == i){\n\t\t\tbreak;\n\t\t}\n\t\telse if(b.length() == i){\n\t\t\tg[M][a[i] - 'a'] = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if(a[i] != b[i]){\n\t\t\tg[b[i] - 'a'][a[i] - 'a'] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tstring s;\n\tbool judge;\n\twhile(cin >> n, n) {\n\t\tvector<string> seq;\n\t\tset<char> m;\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tjudge = true;\n\t\tfor(int i = 0;i < n;++i){\n\t\t\tcin >> s;\n\t\t\tseq.emplace_back(s);\n\t\t}\n\t\tg[seq[0][0] - 'a'][M] = 1;\n\t\tfor(int i = 1;i < n;++i){\n\t\t\tordering(seq[i - 1], seq[i]);\n\t\t}\n\t\tfor(int i = 0;i <= M;++i){\n\t\t\tjudge = judge && dfs(i);\n\t\t}\n\t\tif(judge){\n\t\t\tcout << \"yes\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<deque>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef deque<int> di;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\nsigned main(void) {\n    int n;\n    while(cin >> n, n){\n        vs s(n);\n        rep(i,n)cin >> s[i];\n        vector<vi> g(26);\n        bool ans = true;\n        rep(i,n-1){\n            int j = 0;\n            while(j < s[i].size() && j < s[i+1].size() && s[i][j] == s[i+1][j])j++;\n            if(j == s[i+1].size() && j < s[i].size()){\n                ans = false;\n                break;\n            }\n            if(j == s[i].size() || j == s[i+1].size())continue;\n            //cout << s[i][j] << \" \" << s[i+1][j] << endl;\n            g[s[i][j]-'a'].push_back(s[i+1][j]-'a');\n        }\n        rep(i,26){\n            queue<int> q;\n            rep(j,g[i].size())q.push(g[i][j]);\n            vi used(26);\n            while(q.size() && ans){\n                int v = q.front();\n                q.pop();\n                used[v]++;\n                rep(j,g[v].size()){\n                    int ne = g[v][j];\n                    if(ne == i){\n                        ans = false;\n                    }\n                    if(used[ne] == 0){\n                        q.push(ne);\n                    }\n                }\n            }\n        }\n        if(ans)cout << \"yes\" << endl;\n        else cout << \"no\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n;\nstring ss[500];\nvector<int>G[26];\nbool used[26];\nvoid dfs(int u)\n{\n\tfor(int a:G[u])\n\t{\n\t\tif(!used[a])\n\t\t{\n\t\t\tused[a]=1;\n\t\t\tdfs(a);\n\t\t}\n\t}\n}\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tfor(int i=0;i<n;i++)cin>>ss[i];\n\t\tbool flag=1;\n\t\tfor(int i=0;i<26;i++)G[i].clear();\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tstring s=ss[i],t=ss[i+1];\n\t\t\tint id=0;\n\t\t\twhile(id<s.size()&&id<t.size()&&s[id]==t[id])id++;\n\t\t\tif(id>=s.size());\n\t\t\telse if(id>=t.size())\n\t\t\t{\n\t\t\t\tflag=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tG[s[id]-'a'].push_back(t[id]-'a');\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tfor(int i=0;i<26;i++)\n\t\t\t{\n\t\t\t\tG[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\t\t\t\tfor(int j=0;j<26;j++)used[j]=0;\n\t\t\t\tdfs(i);\n\t\t\t\tflag&=!used[i];\n\t\t\t}\n\t\t}\n\t\tcout<<(flag?\"yes\":\"no\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector< string > s(N);\n    \n    bool flag = true;\n    for(int i = 0; i < N; i++) cin >> s[i];\n    bool graph[26][26] = {{}};\n    for(int i = 1; i < N; i++) {\n      bool update = false;\n      for(int j = 0; j < min(s[i - 1].size(), s[i].size()); j++) {\n        if(s[i - 1][j] != s[i][j]) {\n          graph[s[i - 1][j] - 'a'][s[i][j] - 'a'] = true;\n          update = true;\n          break;\n        }\n      }\n      flag &= update | (s[i - 1].size() <= s[i].size());\n    }\n    for(int k = 0; k < 26; k++) {\n      for(int i = 0; i < 26; i++) {\n        for(int j = 0; j < 26; j++) {\n          graph[i][j] |= graph[i][k] & graph[k][j];\n        }\n        flag &= !graph[i][i];\n      }\n    }\n    if(flag) cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int MAXN = 30;\nconst int MAXM = 1000;\nint N;\nstring str[MAXM];\nint arr[MAXN][MAXN];\nint to[MAXN];\nint is_app[MAXN];\nint topsort()\n{\n    queue<int> que;\n    int vis[MAXN];\n    memset(vis, 0, sizeof(vis));\n    for(int i = 0; i < MAXN; i++)\n        if(to[i]==0 && is_app[i]){\n            que.push(i);\n            vis[i] = 1;\n        }\n    while(!que.empty()){\n        int u = que.front();\n        que.pop();\n\n        for(int i = 0; i < MAXN; i++) if(arr[u][i] && !vis[i] && is_app[i]) {\n            to[i]--;\n            if(to[i] == 0) {\n                que.push(i);\n                vis[i] = 1;\n            }\n        }\n    }\n    /*for(int i = 0; i < MAXN; i++)\n        cout<<is_app[i]<<endl;*/\n    for(int i = 0; i < MAXN; i++) {\n        if(is_app[i])\n            return 0;\n    }\n    return 1;\n}\nint main()\n{\n    while(cin>>N && N) {\n        int flag = 1;\n        memset(is_app, 0, sizeof(is_app));\n        memset(arr, 0, sizeof(arr));\n        memset(to, 0, sizeof(to));\n        for(int i = 1; i <= N; i++) {\n            cin>>str[i];\n        }\n        if(N==1){\n            cout<<\"yes\"<<endl;\n            continue;\n        }\n        for(int i = 1; i <= N-1; i++) {\n            string a = str[i], b = str[i+1];\n            int len_1 = a.length(), len_2 = b.length();\n            int j;\n            for(j = 0; j<len_1 && j<len_2; j++) {\n                if(a[j] != b[j]) {\n                    is_app[a[j]-'a'] = 1;\n                    is_app[b[j]-'a'] = 1;\n                    if(arr[a[j]-'a'][b[j]-'a']==0) {\n                        arr[a[j]-'a'][b[j]-'a'] = 1;\n                        to[b[j]-'a']++;\n                    }\n                    break;\n                }\n            }\n            if(j == len_2 && j< len_1){\n                flag = 0;\n            }\n        }\n        if(flag == 0){\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        if(topsort())\n            cout<<\"yes\"<<endl;\n        else\n            cout<<\"no\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 100000\nstruct SCC{\n  int V; \n  vector<int> G[MAX_V];  //グラフの隣接リスト\n  vector<int> rG[MAX_V]; //逆に辺を貼ったグラフの隣接リスト\n  vector<int> vs;        //帰り掛け順の並び\n  bool used[MAX_V];      //すでに調べたか\n  int cmp[MAX_V];        //属する強連結成分のトポロジカル順序\n\n  SCC(){\n    fill_n(used,MAX_V,0);\n    fill_n(cmp,MAX_V,0);\n    V=33;\n  }\n  \n  void add_edge(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n\n  void dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++)\n      if(!used[G[v][i]])dfs(G[v][i]);\n    vs.push_back(v); //探索終了したものから追加\n  }\n\n  void rdfs(int v,int k){\n    used[v]=true;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++)\n      if(!used[rG[v][i]])rdfs(rG[v][i],k);\n  }\n\n  int scc(){\n    memset(used,0,sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++)\n      if(!used[v])dfs(v);\n\n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n    \n      if(!used[vs[i]])rdfs(vs[i],k++);\n      //cout<<\"d\"<<endl;\n    }\n    return k;\n  }\n\n};\nint main(){\n  int n;\n  while(cin>>n,n){\n  string s[555];\n  int use[33]={};\n  int cnt=0;\n  int ans=1;\n  SCC sc;\n  for(int i=0;i<n;i++)cin>>s[i];\n  int ma[33][33]={};\n  \n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      \n      string a=s[i],b=s[j];\n      int l=min((int)a.size(),(int)b.size());\n      if(a==b)continue;\n      int flg=1;\n      for(int k=0;k<l;k++){\n\tif(a[k]==b[k])continue;\n\tflg=0;\n\t//cout<<'A'<<endl;\n\tsc.add_edge(a[k]-'a',b[k]-'a');\n\t\n\tif(use[a[k]-'a']==0){\n\t  use[a[k]-'a']=1;\n\t  cnt++;\n\t}\n\tif(use[b[k]-'a']==0){\n\t  use[b[k]-'a']=1;\n\t  cnt++;\n\t}\n\tbreak;\n      }\n      if(flg)ans=0;\n    }\n  }\n  int tmp=sc.scc();\n  //  cout<<cnt<<\" \"<<tmp<<endl;\n  if(tmp==33&&ans)cout<<\"yes\"<<endl;\n  else cout<<\"no\"<<endl;\n}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nint n;\nvector<int> s[500];\nvector<int> e[30];\nbool saw[500];\n\nbool f(int p, int ori){\n\tif(saw[p] && p == ori) return false;\n\tif(saw[p]) return true;\n\tsaw[p] = true;\n\trep(i,e[p].size()){\n\t\tif(!f(e[p][i],ori)) return false;\n\t}\n\treturn true;\n}\n\nvoid solve(){\n\trep(i,500) saw[i] = false;\n\trep(i,500) s[i].clear();\n\trep(i,30) e[i].clear();\n\trep(i,n){\n\t\tstring str;\n\t\tcin >> str;\n\t\trep(j,str.size()){\n\t\t\tint x = str[j]-'a';\n\t\t\ts[i].push_back(x);\n\t\t}\n\t}\n\tfor(int i = 0; i < n-1; i++){\n\t\tint t = min(s[i].size(),s[i+1].size());\n\t\tbool ok = false;\n\t\trep(j,t){\n\t\t\tif(s[i][j] != s[i+1][j]){\n\t\t\t\te[s[i][j]].push_back(s[i+1][j]);\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tif(s[i].size() > s[i+1].size()){\n\t\t\t\tputs(\"no\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,30) sort(e[i].begin(),e[i].end());\n\trep(i,30) e[i].erase(unique(e[i].begin(),e[i].end()),e[i].end());\n\trep(i,30){\n\t\trep(j,500) saw[j] = false;\n\t\tif(!f(i,i)){\n\t\t\tputs(\"no\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"yes\");\n\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 文字に適切な順序を定めて、入力が辞書順になるようにできるか\n// 適当に辺を貼って閉路見つける\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring s[500];\nbool f[500][500];\nbool g[26][26];\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tmemset(f, 0, sizeof(f));\n\t\tmemset(g, 0, sizeof(g));\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tfor (int k = j + 1; k < n; k++){\n\t\t\t\t\tif (f[j][k]) continue;\n\t\t\t\t\tif (s[j][i] != '\\0' && s[k][i] == '\\0'){\n\t\t\t\t\t\tcout << \"no\\n\";\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= min(s[j].size(), s[k].size())) continue;\n\t\t\t\t\tif (s[j][i] != s[k][i]){\n\t\t\t\t\t\tcout << s[j][i] << s[k][i] << endl;\n\t\t\t\t\t\tg[s[j][i] - 'a'][s[k][i] - 'a'] = true;\n\t\t\t\t\t\tf[j][k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 26; k++){\n\t\t\tfor (int i = 0; i < 26; i++){\n\t\t\t\tfor (int j = 0; j < 26; j++){\n\t\t\t\t\tg[i][j] |= g[i][k] && g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool res = true;\n\t\tfor (int i = 0; i < 26; i++){\n\t\t\tif (g[i][i]) res = false;\n\t\t}\n\t\t\n\t\tcout << (res ? \"yes\" : \"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\nint mp[30][30],du[30],vis[30],have[30],tot;\n\nchar s[505][15];\n\ninline void add(char a,char b)\n{\n    tot++;\n    mp[a-'a'][b-'a'] = 1;\n    have[a-'a'] = 1;have[b-'a'] = 1;\n    //printf(\"a=%d,b=%d\\n\",a-'a',b-'a');\n    du[b-'a']++;\n}\n\nbool dfs(int x)\n{\n    //printf(\"x=%d\\n\",x);\n    if(vis[x])\n        return 1;\n    vis[x] = 1;\n    for(int i=0;i<26;i++)\n    {\n        if(mp[x][i]==0)\n            continue;\n        if(dfs(i))\n            return 1;\n    }\n    return 0;\n}\n\nint q[30],bdu[30];\nbool topo()\n{\n    if(tot==0)\n        return 1;\n    memcpy(bdu,du,sizeof(du));\n    int front = 1,tail = 0;\n    for(int i=0;i<26;i++)\n    {\n        if(have[i]&&du[i]==0)\n            q[++tail] = i;\n    }\n    while(tail>=front)\n    {\n        int t =q[front++];\n        for(int i=0;i<26;i++)\n        {\n            if(mp[t][i])\n            {\n                bdu[i]--;\n                if(bdu[i]==0)\n                    q[++tail] =i;\n            }\n        }\n    }\n    for(int i=0;i<26;i++)\n        if(bdu[i])\n            return 0;\n    return 1;\n}\nbool bi(int a,int b)\n{\n    //printf(\"b=%d,now\\n\",b);\n    int la = strlen(s[a]);\n    int lb = strlen(s[b]),dif=0;\n    for(int i=0;i<min(la,lb);i++)\n    {\n        if(s[a][i]!=s[b][i])\n        {\n            dif = 1;\n            add(s[a][i],s[b][i]);\n            break;\n        }\n    }\n    if(la>lb&&dif==0)\n        return 1;\n    if(topo())\n        return 0;\n    return 1;\n}\n\nint main()\n{\n    int n;\n    while(scanf(\"%d\",&n)&&n)\n    {\n        memset(du,0,sizeof(du));tot = 0;\n        memset(mp,0,sizeof(mp));\n        memset(have,0,sizeof(have));\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",*(s+i));\n        }\n        int flag =0;\n        for(int i=1;i<n;i++)\n        {\n            if(bi(i-1,i))\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if(flag)\n            puts(\"no\");\n        else\n            puts(\"yes\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nint n;\nvector<int> s[500];\nvector<int> e[30];\nbool saw[500];\n\nbool f(int p){\n\tif(saw[p]) return false;\n\tsaw[p] = true;\n\tbool ret = true;\n\trep(i,e[p].size()){\n\t\tif(!f(e[p][i])) return false;\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\trep(i,500) saw[i] = false;\n\trep(i,500) s[i].clear();\n\trep(i,30) e[i].clear();\n\trep(i,n){\n\t\tstring str;\n\t\tcin >> str;\n\t\trep(j,str.size()){\n\t\t\tint x = str[j]-'a';\n\t\t\ts[i].push_back(x);\n\t\t}\n\t}\n\tfor(int i = 0; i < n-1; i++){\n\t\tint t = min(s[i].size(),s[i+1].size());\n\t\tbool ok = false;\n\t\trep(j,t){\n\t\t\tif(s[i][j] != s[i+1][j]){\n\t\t\t\te[s[i][j]].push_back(s[i+1][j]);\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tif(s[i].size() > s[i+1].size()){\n\t\t\t\tputs(\"no\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,30) sort(e[i].begin(),e[i].end());\n\trep(i,30) e[i].erase(unique(e[i].begin(),e[i].end()),e[i].end());\n\trep(i,30){\n\t\trep(j,500) saw[j] = false;\n\t\tif(!f(i)){\n\t\t\tputs(\"no\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"yes\");\n\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring a[500], b[500], c[500];\n\nint main()\n{\n\tint n, k;\n\twhile(cin >> n) {\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> a[i];\n\t\t\tb[i] = a[i];\n//\t\t\tc[i] = a[i];\n\t\t}\n\t\tsort(b, b+n);\n//\t\tsort(c, c+n);\n\t\tfor(k = 0; k < n; k++) {\n\t\t\tcout << b[k] << endl;\n\t\t\tif(a[k] != b[k]) break;\n\t\t}\n\t\tif(k >= n) {\n\t\t\tcout << \"yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(k = 0; k < n; k++) {\n//\t\t\tcout << c[k] << endl;\n\t\t\tif(a[k] != b[n - k - 1]) break;\n\t\t}\n\t\tif(k >= n) {\n\t\t\tcout << \"yes\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"no\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<string> v(n);\n        int max_len = 0;\n        for(int i=0; i<n; ++i) {\n            string s;\n            cin >> s;\n            v[i] = '0' + s;\n            max_len = max(max_len, (int)v[i].length());\n        }\n        vector<vector<bool>> f(26, vector<bool>(26, false));\n        bool ok = true;\n        for(int i=1; i<max_len; ++i) {\n            string prev;\n            for(int j=0; j<n; ++j) {\n                if(j != 0 && i == v[j].length() && prev == v[j].substr(0, i)) {\n                    if(v[j-1].length() > v[j].length()) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if(i >= v[j].length()) {\n                    continue;\n                }\n                if(j == 0) {\n                    prev = v[j].substr(0, i);\n                } else if(prev == v[j].substr(0, i)) {\n                    if(v[j][i] != v[j-1][i]) {\n                        f[v[j-1][i] - 'a'][v[j][i] - 'a'] = true;\n                    }\n                } else {\n                    prev = v[j].substr(0, i);\n                }\n            }\n            if(!ok) break;\n        }\n        for(int k=0; k<26; ++k) {\n            for(int i=0; i<26; ++i) {\n                for(int j=0; j<26; ++j) {\n                    f[i][j] = (bool)f[i][j] || (bool)f[i][k] && (bool)f[k][j];\n                }\n            }\n        }\n        for(int i=0; i<26; ++i) {\n            for(int j=0; j<26; ++j) {\n                ok &= !((bool)f[i][j] && (bool)f[j][i]);\n            }\n        }\n        cout << (ok ? \"yes\" : \"no\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int kNumAlphabets = 26;\n\nvi used;\nvvi edge;\nstring res;\n\nvoid dfs(int v, set<int> from){\n    if(used[v]){\n        if(from.find(v) != from.end()) res = \"no\";\n        return;\n    }\n\n    used[v] = true;\n    from.insert(v);\n\n    rep(u, kNumAlphabets){\n        if(edge[v][u]) dfs(u, from);\n    }\n}\n\nint main(void){\n    for(int n; cin >> n, n; cout << res << endl){\n        res = \"yes\";\n        edge = vvi(kNumAlphabets, vi(kNumAlphabets));\n\n        string pre; cin >> pre;\n        rep(i, n - 1){\n            string cur; cin >> cur;\n\n            bool same = true;\n            rep(j, min(pre.size(), cur.size())){\n                if(pre.at(j) != cur.at(j)){\n                    edge[pre.at(j) - 'a'][cur.at(j) - 'a'] = true;\n                    same = false;\n                    break;\n                }\n            }\n            if(same && cur.size() < pre.size()) res = \"no\";\n\n            pre = cur;\n        }\n\n        rep(u, kNumAlphabets){\n            used = vi(kNumAlphabets);\n            dfs(u, set<int>());\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    \n    vector<string>v(n);\n    rep(i,n)cin >> v[i];\n\n    map<char,int>od;\n    bool fg=true;\n    int cnt=0;\n    for(int i=0;i<n;i++){\n      if(od.count(v[i][0])&& od[v[i][0]]!=cnt)fg=false;\n      if(!od.count(v[i][0]))od[v[i][0]]=++cnt;\n    }\n    \n    for(int i=1;i<10;i++){\n      for(int j=0;j+1<n;j++){\n\tif(v[j].substr(0,i)==v[j+1].substr(0,i)){\n\t  if(v[j].size()>v[j+1].size())fg=false;\n\t  if(od[v[j][i]]==0)od[v[j][i]]=++cnt;\n\t  if(od[v[j+1][i]]==0)od[v[j+1][i]]=++cnt;\n\t  if(od[v[j][i]]>od[v[j+1][i]])fg=false;\n\t}\n      }\n    }\n\n    cout << (fg?\"yes\":\"no\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nvector<int> G[510];\n\nvector<string> arr;\nvector<ii> edges;\nbool found[510];\nbool used[510];\nbool cycle;\n\nbool inValid(string a,string b) {\n  if( a == b ) return false;\n  int diff = -1;\n  rep(i,min(a.size(),b.size())) if( a[i] != b[i] ) { diff = i; break; }\n  if( diff == -1 && a.size() > b.size() ) return true;\n  return false;\n}\n\nvoid add(string a,string b){\n  if( a == b ) return;\n  int diff = -1;\n  rep(i,min(a.size(),b.size())) if( a[i] != b[i] ) { diff = i; break; }\n  if( diff == -1 ) return;\n  edges.push_back(ii(a[diff]-'a',b[diff]-'a'));\n}\n\nbool visit(int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  rep(i,G[v].size()){\n    int e = G[v][i];\n    if(color[e] == 2)continue;\n    if(color[e] == 1)return false;\n    if(!visit(e,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\nbool topologicalSort(vector<int>& order){\n  vector<int> color(26,0); \n  for(int u=0;u<26;u++) if(!color[u] && !visit(u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    rep(i,n) { G[i].clear(); found[i] = used[i] = false;  }\n    bool fin = false;\n    cycle = false;\n    arr.clear();\n    arr.resize(n);\n    edges.clear();\n    rep(i,n) cin >> arr[i];\n    rep(i,n-1) {\n      if( inValid(arr[i],arr[i+1]) ) { puts(\"no\"); fin = true; break; }\n      add(arr[i],arr[i+1]);\n    }\n    if( fin ) continue;\n    rep(i,edges.size()) {\n      int src = edges[i].first;\n      int dst = edges[i].second;\n      G[src].push_back(dst);\n    }\n    vector<int> order;\n    if( !topologicalSort(order) ) { puts(\"no\"); continue; }\n    puts(\"yes\");\n  }\n  return 0;\n}\n\n// same as http://codeforces.com/contest/512/problem/A"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate<typename T>\nstd::vector<int> topological_sort(const Graph<T> &graph) {\n    Graph<T> g = graph;\n    int n = g.size();\n    std::vector<int> res;\n    std::queue<int> que;\n    std::vector<int> in(n);\n    std::vector<bool> used(n, false);\n    for(int i=0;i<n;++i) {\n        for(int j=0;j<(int)(g[i].size());++j) {\n            in[g[i][j].to]++;\n        }\n    }\n    for(int i=0;i<n;++i) {\n        if(in[i] == 0) que.push(i);\n    }\n    if((int)(que.size()) == 0) res.push_back(-1);\n    while(!que.empty()) {\n        int now = que.front(); que.pop();\n        if(used[now]) {\n            res.clear();\n            res.push_back(-1);\n            return res;\n        }\n        used[now] = true;\n        res.push_back(now);\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            if(in[next] == 1) {\n                que.push(next);\n        }\n            in[next]--;\n        }\n    }\n    return res;\n}\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    Graph<int> g(26);\n    map<P, bool> sel;\n    vector<string> vs(n);\n    for(int i=0;i<n;++i) {\n      cin >> vs[i];\n    }\n    if(n == 1) {\n      cout << \"yes\" << endl;\n      continue;\n    }\n    string s1 = vs[0];\n    bool ok = true;\n    for(int i=1;i<n;++i) {\n      string s2 = vs[i];\n      bool upd = false;\n      for(int j=0;j<min((int)(s1.size()), (int)(s2.size()));++j) {\n        if(s1[j] != s2[j]) {\n          int a = (int)(s1[j] - 'a'), b = (int)(s2[j] - 'a');\n          upd = true;\n          if(!sel[{a, b}]) {\n            sel[{a, b}] = true;\n            g[a].push_back(Edge<int>(a, b, 1));\n          }\n          break;\n        }\n      }\n      if(!upd && (int)(s1.size()) > (int)(s2.size())) {\n        ok = false;\n        break;\n      }\n      s1 = s2;\n    }\n    if(!ok) {\n      cout << \"no\" << endl;\n      continue;\n    }\n    vector<int> tmp = topological_sort(g);\n    if((int)(tmp.size()) < 26) {\n      cout << \"no\" << endl;\n    } else {\n      cout << \"yes\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N ('z'-'a')\nusing namespace std;\ntypedef long long ll;\nint n,ans;\nstring str[501];\nll mp[N+1];\n\nvoid mk_mp(int pos,int i,int j){\n  while(i<=j&&pos>=str[i].size())i++;\n  if(i>=j)return;\n  int ni=-1,ch=str[i][pos]-'a',c=1;\n\n  while(i<j&&ans){\n    int a=str[++i][pos]-'a',f=(ch==a);\n    if(f&&ni==-1)ni=i-1;\n    if(!f&&ni>=0)mk_mp(pos+1,ni,i-1),ni=-2;\n    \n    if(!f&&c)mk_mp(pos,i,j),mp[ch]|=((1LL<<a)|mp[a]),c=0;\n    if(f&&!c)ans=0;\n    if(f&&str[i-1].size()>str[i].size()&&str[i][pos+1]==0)ans=0;    \n  }\n  if(ni>=0) mk_mp(pos+1,ni,j);\n  \n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<=N;i++) mp[i]=0;\n    for(int i=0;i<n;i++)cin>>str[i];\n    ans=1;\n    mk_mp(0,0,n-1);\n    for(int i=0;i<N;i++) if((mp[i]&(1<<i)))ans=0;\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint n;\nstring S[512];\nvector<int>G[32];\n\nint dfs(int p, int d){\n  if(d>26) return 0;\n  for(auto g:G[p]){\n    if(!dfs(g, d+1)) return 0;\n  }\n  return 1;\n}\n\nint solve()\n{\n  rep(i, 26) G[31].push_back(i);\n  rep(i, n-1){\n    //    cout << i << endl;\n    int p = 0;\n    string s=S[i], t = S[i+1];\n    while(1){\n      if(s[p] == '\\0') break;\n      if(t[p] == '\\0') return 0;\n      if(s[p] != t[p]){\n\tif(find(begin(G[s[p]-'a']), end(G[s[p]-'a']), t[p]-'a')\n\t   == end(G[s[p]-'a']))\n\t   G[s[p]-'a'].push_back(t[p]-'a');\n\tbreak;\n      }\n      p++;\n    }\n  }\n  return dfs(31, 0);\n}\n\nint main()\n{\n  while(1){\n    cin >> n;\n    if(n == 0) return 0;\n    rep(i, 32) G[i].clear();\n\n    rep(i, n) cin >> S[i];\n\n    cout << (solve()?\"yes\\n\":\"no\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tchar s[500][11];\n\t\trep(i,n) scanf(\"%s\",s[i]);\n\n\t\tbool ok=true;\n\t\tbool adj[26][26]={};\n\t\trep(i,n-1){\n\t\t\tfor(int j=0;;j++){\n\t\t\t\tif(s[i][j]=='\\0') break;\n\t\t\t\tif(s[i+1][j]=='\\0'){ ok=false; break; }\n\t\t\t\tif(s[i][j]!=s[i+1][j]){\n\t\t\t\t\tadj[s[i][j]-'a'][s[i+1][j]-'a']=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(k,26) rep(i,26) rep(j,26) adj[i][j]|=adj[i][k]&&adj[k][j];\n\n\t\trep(i,26) if(adj[i][i]) ok=false;\n\t\tputs(ok?\"yes\":\"no\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[501];\nint d[26][26],n;\nint main(){\n  while(cin>>n,n){\n    int ans=0,f=0;\n    r(i,26)r(j,26)d[i][j]=1e8;\n    r(i,n)cin>>s[i];\n    r(i,n-1){\n      r(j,s[i].size()){\n        if(j>=s[i+1].size()){f++;break;}\n        if(s[i][j]!=s[i+1][j]){\n            d[s[i][j]-'a'][s[i+1][j]-'a']=-1;\n            break;\n        }\n      }\n    }\n    r(k,26)r(i,26)r(j,26)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    r(i,26)if(d[i][i]<0)ans++;\n    cout<<(ans||f?\"no\":\"yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint solve(int n){\n    int M = 26;\n    vector<int> deg(M);\n    vector<set<int>> G(M);\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n    for (int i = 0; i < n-1; ++i) {\n        int cur = 0;\n        while(s[i][cur] == s[i+1][cur] &&\n              cur < min(s[i].size(), s[i+1].size())) cur++;\n        if(cur == min(s[i].size(), s[i+1].size())){\n            if(s[i].size() <= s[i+1].size()) continue;\n            else return 0;\n        }\n        G[s[i][cur]-'a'].emplace(s[i+1][cur]-'a');\n        if(G[s[i+1][cur]-'a'].count(s[i][cur]-'a')) return 0;\n    }\n    for (int i = 0; i < M; ++i) {\n        for (auto &&j : G[i]) {\n            deg[j]++;\n        }\n    }\n    vector<int> visited(M);\n    stack<int> Q;\n    for (int i = 0; i < M; ++i) {\n        if(!deg[i]) Q.emplace(i);\n    }\n    while(!Q.empty()){\n        int i = Q.top(); Q.pop();\n        visited[i] = 1;\n        for (auto &&j : G[i]) {\n            deg[j]--;\n            if(!deg[j]){\n                Q.emplace(j);\n            }\n        }\n        G[i].clear();\n    }\n    for (int i = 0; i < M; ++i) {\n        if(!visited[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        puts(solve(n) ? \"yes\" : \"no\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring s[1011];\nvector<int> V[33];\nint main()\n{\n    int n;\n    while(1)\n    {\n        for(int i = 0; i <= 26; i++)\n            V[i].clear();\n        scanf(\"%d\", &n);\n        if(n == 0)\n            break;\n        for(int i = 0; i < n; i++)\n            cin>>s[i];\n        int cnt = 0;\n        int in[33] = {0};\n        for(int i = 0; i < n; i++)\n            for(int j = i + 1; j < n; j++)\n            {\n                int l1 = s[i].size();\n                int l2 = s[j].size();\n                int flag = 0;\n                for(int k = 0; k < max(l1, l2); k++)\n                {\n                    if(k >= l1 && k <= l2)\n                    {\n                        break;\n                    }\n                    if(k >= l2 && k < l1)\n                    {\n                        puts(\"no\");\n                        goto loop;\n                    }\n                    if(s[i][k] != s[j][k])\n                    {\n                        V[s[i][k] - 'a'].push_back(s[j][k] - 'a');\n                        in[s[j][k] - 'a']++;\n                        break;\n                    }\n                }\n            }\n        while(1)\n        {\n            int nxt = -1;\n            for(int i = 0; i < 26; i++)\n                if(in[i] == 0)\n                {\n                    nxt = i;\n                    break;\n                }\n            if(nxt == -1)\n                break;\n            in[nxt]--;\n            cnt++;\n            for(int i = 0; i < V[nxt].size(); i++)\n                in[V[nxt][i]]--;\n        }\n        if(cnt == 26)\n            puts(\"yes\");\n        else puts(\"no\");\n        loop:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  while (1){\n    int n;\n    cin >> n;\n    if (n == 0){\n      break;\n    }\n    vector<string> s(n);\n    for (int i = 0; i < n; i++){\n      cin >> s[i];\n      s[i] += '{';\n    }\n    vector<set<int>> E(26);\n    bool ok = true;\n    for (int i = 0; i < n - 1; i++){\n      if (s[i] != s[i + 1]){\n        int c = 0;\n        while (s[i][c] == s[i + 1][c]){\n          c++;\n        }\n        if (s[i + 1][c] == '{'){\n          ok = false;\n        } else if (s[i][c] != '{'){\n          E[s[i][c] - 'a'].insert(s[i + 1][c] - 'a');\n        }\n      }\n    }\n    if (!ok){\n      cout << \"no\" << endl;\n    } else {\n      vector<int> deg(26, 0);\n      for (int i = 0; i < 26; i++){\n        for (int j : E[i]){\n          deg[j]++;\n        }\n      }\n      queue<int> Q;\n      for (int i = 0; i < 26; i++){\n        if (deg[i] == 0){\n          Q.push(i);\n        }\n      }\n      while (!Q.empty()){\n        int v = Q.front();\n        Q.pop();\n        for (int w : E[v]){\n          deg[w]--;\n          if (deg[w] == 0){\n            Q.push(w);\n          }\n        }\n      }\n      for (int i = 0; i < 26; i++){\n        if (deg[i] != 0){\n          ok = false;\n        }\n      }\n      if (!ok){\n        cout << \"no\" << endl;\n      } else {\n        cout << \"yes\" << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n// F\nstring arr[801];\n\nbool startwith(const string &a, const string &b)\n{\n    if (a.size()>b.size()) return false;\n\n    for (int i=0; i<min(a.size(),b.size()); i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n\n    return true;\n}\n\nbool cmp1(const string &a, const string &b)\n{\n    if (a==b) return true;\n    if (startwith(a,b)) return true;\n    if (startwith(b,a)) return false;\n    return a<b;\n}\n\nbool cmp2(const string &a, const string &b)\n{\n    if (a==b) return true;\n    if (startwith(a,b)) return true;\n    if (startwith(b,a)) return false;\n    return a>b;\n}\n\nint main()\n{\n    int n;\n//freopen(\"fuck.in\",\"r\",stdin);\n\n    //ios::sync_with_stdio(false);\n    while (cin>>n and n!=0)\n    {\n        bool right1=true, right2=true;\n\n        for (int i=0; i<n; i++) cin>>arr[i];\n\n        for (int i=0; i<n-1; i++)\n        {\n            if (cmp1(arr[i],arr[i+1])==false)\n            {\n                right1=false;\n                break;\n            }\n        }\n\n        for (int i=0; i<n-1; i++)\n        {\n            if (cmp2(arr[i],arr[i+1])==false)\n            {\n                right2=false;\n                break;\n            }\n        }\n\n        if (right1 or right2) cout<<\"yes\\n\"; else cout<<\"no\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\ntemplate<typename T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c): from(f), to(t), cost(c){}\n};\n \ntemplate<typename T> struct Graph{\n    vector<vector<edge<T>>> G;\n    int n;\n \n    Graph(int n_): n(n_){\n        G.resize(n);\n    }\n \n    void add_edge(int f, int t, T c){\n        G[f].emplace_back(f, t, c);\n    }\n};\n\ntemplate<typename T> \npair<bool, vector<int>> topological_sort(Graph<T> &gr){\n    vector<int> ret(gr.n, -1), in(gr.n, 0);\n    rep(i, gr.n)for(edge<T> &e: gr.G[i]) ++in[e.to];\n    int cur = 0;\n    stack<int> st;\n    rep(i, gr.n)if(!in[i]) st.push(i);\n    if(st.empty()) return make_pair(false, ret);\n    while(!st.empty()){\n        int v = st.top(); st.pop();\n        ret[cur++] = v;\n        for(edge<T> &e: gr.G[v]){\n            if(!in[e.to]) return make_pair(false, ret);\n            --in[e.to];\n            if(!in[e.to]) st.push(e.to);\n        }\n    }\n    return make_pair(cur == gr.n, ret);\n}\n\ntemplate<typename T>\nbool has_cycle(Graph<T> &gr){\n    return !topological_sort(gr).fi;\n}\n\nint n;\n\nvoid solve(){\n    string s[n];\n    rep(i, n) cin >> s[i];\n    Graph<int> gr(26);\n    bool adj[26][26];\n    rep(i, 26)rep(j, 26) adj[i][j] = false;\n    rep(i, n)For(j, i+1, n){\n        if(s[i] == s[j]) continue;\n        if(s[i].substr(0, s[j].size()) == s[j]){\n            puts(\"no\");\n            return;\n        }\n        rep(k, 20)if(s[i][k] != s[j][k]){\n            int x = s[i][k] - 'a', y = s[j][k] - 'a';\n            if(!adj[x][y]){\n                gr.add_edge(x, y, 1);\n                adj[x][y] = true;\n            }\n            break;\n        }\n    }\n    puts(!has_cycle(gr) ? \"yes\" : \"no\");\n}\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nstring S[555];\nvector<int> G[30];\nvector<int> rG[30];\nbool used[30];\n\nvoid dfs(int v,vector<int>& vs){\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    if( used[G[v][i]] ) continue;\n    dfs( G[v][i] , vs );\n  }\n  vs.push_back( v );\n  return ;\n}\nvoid rdfs(int v,int t){\n  used[v] = true;\n  for(int i=0;i<(int)rG[v].size();i++){\n    if( used[rG[v][i]] ) continue;\n    rdfs( rG[v][i], t );\n  }  \n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vector<int> vs;\n  for(int i=0;i<26;i++)\n    if( !used[i] ) dfs(i,vs);\n  memset(used,0,sizeof(used));\n  int t=0;\n  for(int i=25;i>-1;i--)\n    if( !used[vs[i]] ) rdfs( vs[i], t++ );\n  return t;\n}\n\nvoid init(){\n  for(int i=0;i<26;i++){\n    G[i].clear(); rG[i].clear();\n  }    \n}\n\nvoid add_edge(char u, char v){\n  if( u == '#' || v == '#' ) return;\n  G[u-'a'].push_back( v-'a' );\n  rG[v-'a'].push_back( u-'a' );\n}\n\nvoid view(){\n  for(int i=0;i<26;i++){\n    char c = i+'a';\n    cout << c << \": \" << endl;\n    for(int j=0;j<(int)G[i].size();j++){\n      cout << \" -> \" << (char)(G[i][j]+'a') << endl;\n    }\n  }\n}\n\nbool makeg(int l,int h,int f){\n  // cout << l<<\" \" << h << \" \" << f<< endl;\n  if( l>=h ) return true;\n  char c=S[l][f];\n  int pd = l;\n  if( c == '#' )\n    return makeg(l+1,h,f);  \n  for(int i=l+1;i<=h;i++){\n    //cout << S[i] << endl;\n    if( S[i][f] == '#' ){\n      if( c != '#' ) return false;\n      return makeg(i+1,h,f);\n    }\n    //    cout << c << \"  \"<< S[i][f] << endl;\n    if( S[i][f] != c ){\n      if( !makeg(pd,i-1,f+1) ) return false;\n      add_edge( S[i][f], c );\n      c = S[i][f];\n      pd = i;\n    }\n  }\n  return makeg(pd,h,f+1);\n}\n\nbool make_graph(){\n  return makeg(0,N-1,0);\n  view();\n}\n\nint main(){\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++){\n      cin >> S[i];\n      S[i]+=\"#\";\n    }\n    init();\n    if( !make_graph() || scc() < 26 ) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=505;\nchar str[MAXN][15];\nint in[26];\nbool used[26][26];\nint main(){\n    int n, cnt;\n    queue<int> q;\n    while(cin>>n&&n){\n        memset(in,0,sizeof in);\n        memset(used,0,sizeof used);\n        bool flag=true;\n        for(int i=0; i<n; i++){\n            scanf(\"%s\",str[i]);\n            int len=strlen(str[i]);\n            if(i&&flag){\n                for(int k=0; k<len; k++){\n                    if(str[i][k]==str[i-1][k]){\n                        continue;\n                    }\n                    if(!str[i][k]) goto ok;\n                    int s1=str[i-1][k]-'a', s2=str[i][k]-'a';\n//                    assert(s1>=0);assert(s2>=0);\n                    if(used[s2][s1]) flag=false;\n                    if(!used[s1][s2]){\n                        used[s1][s2]=true;\n                        in[s2]++;\n                    }\n                    goto ok;\n                }\n                if(str[i-1][len]) flag=false;\n                ok:;\n            }\n        }\n        if(!flag) goto failed;\n        while(!q.empty()) q.pop();\n        for(int i=0; i<26; i++){\n            if(in[i]==0){\n                q.push(i);\n            }\n        }\n        cnt=0;\n        while(!q.empty()){\n            int now=q.front(); q.pop();\n            for(int i=0; i<26; i++){\n                if(used[now][i]){\n                    in[i]--;\n                    if(in[i]==0){\n                        q.push(i);\n                    }\n                }\n            }\n            cnt++;\n        }\n        if(cnt!=26) goto failed;\n        puts(\"yes\");\n        continue;\n        failed:;\n        puts(\"no\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s[505];\n//??°???????????£??\\?????????\nVI g[30];\n//???????????\\?¬???°?????????\nint h[30];\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    REP(i, n) cin >> s[i];\n    memset(h, 0, sizeof(h));\n    REP(i, 30) g[i].clear();\n\n    bool flg = false;\n    REP(i, n-1) {\n      int sz = min(s[i].size(), s[i+1].size());\n      bool update = false;\n      REP(j, sz) {\n        if(s[i][j] != s[i+1][j]) {\n          // s[i][j] ?????? s[i+1][j]???????????????\n          g[s[i][j]-'a'].PB(s[i+1][j]-'a');\n          h[s[i+1][j]-'a']++;\n          update = true;\n          break;\n        }\n      }\n      if(!update && s[i].size() > s[i+1].size()) {\n        cout << \"no\" << endl;\n        flg = true;\n        break;\n      }\n    }\n    if(flg) continue;\n\n    //??\\?¬???°???0??????????????????\n    stack<int> st;\n    //??\\?¬???°???0???????????§????????°st?????????\n    REP(i, 26) if(h[i] == 0) st.push(i);\n\n    //??????????????????????????°??????\n    VI ans;\n    //st????????????????????§?????????\n    while(st.size()) {\n      //st????????????????????????????????????\n      int i = st.top(); st.pop();\n      ans.push_back(i);\n      for(auto& j: g[i]) {\n        //??£??\\?????????????????\\?¬???°???????????????1\n        h[j]--;\n        //??????????????£?????\\?¬???°???0???????????°st?????????\n        if(h[j] == 0) st.push(j);\n      }\n    }\n\n    if(ans.size() == 26) cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,flg,t[26][26];\nstring str[500];\nvoid check(int x,int y){\n  //cout<<str[x]<<' '<<str[y]<<endl;\n  int v = str[x].size();\n  int w = str[y].size();\n  for(int i=0;i<min(v,w);i++){\n    if(str[x][i]==str[y][i])continue;\n    if(t[str[x][i]-'a'][str[y][i]-'a']==-1)flg=0;\n    t[str[x][i]-'a'][str[y][i]-'a']=1;\n    t[str[y][i]-'a'][str[x][i]-'a']=-1;\n    return;\n  }\n  if(w<v)flg=0;\n}\nint main(){\n  while(cin>>n&&n){\n\n    for(int i=0;i<26;i++)\n      for(int j=0;j<26;j++)\n\tt[i][j]=0;\n\n    flg=1;\n    cin>>str[0];\n    for(int i=1;i<n;i++){\n      cin>>str[i];\n      for(int j=i-1;j>=0;j--)check(j,i);\n    }\n    cout<<(flg?\"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n;\nmap<char, char> nxt;\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\tnxt.clear();\n\t\tvector<bool> f(n, 0);\n\t\tvector<string> vs;\n\t\trep(i, n) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\trep(j, s.size())nxt[s[j]] = -1;\n\t\t\twhile (s.size() < 10)s += \"@\";\n\t\t\tvs.push_back(s);\n\t\t}\n\t\trep(i, 10) {\n\t\t\trep(j, n - 1) {\n\t\t\t\tif (vs[j][i] == '@' || vs[j + 1][i] == '@')f[j] = 1;\n\t\t\t\tif (!f[j]) {\n\t\t\t\t\tif (vs[j][i] != vs[j + 1][i]) {\n\t\t\t\t\t\tnxt[vs[j][i]] = vs[j + 1][i];\n\t\t\t\t\t\tf[j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tfor (auto it = nxt.begin(); it != nxt.end(); it++) {\n\t\t\tset<char> sc;\n\t\t\tll cnt = 0;\n\t\t\tchar c = it->first;\n\t\t\tsc.insert(c);\n\t\t\twhile (c != -1) {\n\t\t\t\tc = nxt[c];\n\t\t\t\tif (sc.find(c) != sc.end())break;\n\t\t\t\tsc.insert(c);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (cnt == nxt.size())ok = true;\n\t\t}\n\t\tif (ok)cout << \"yes\" << endl;\n\t\telse cout << \"no\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\nstring s[500];\nbool g[26][26];\nint h[26];\n\nbool cycle(int i){\n\th[i] = 1;\n\trep(j, 26){\n\t\tif(!g[i][j]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(h[j] == 0 && cycle(j) || h[j] == 1){\n\t\t\treturn true;\n\t\t}\n\t}\n\th[i] = 2;\n\treturn false;\n}\n\nbool solve(){\n\trep(i, n - 1){\n\t\tint p = s[i].size();\n\t\tint q = s[i + 1].size();\n\n\t\tbool same = true;\n\t\trep(j, min(p, q)){\n\t\t\tchar k = s[i][j];\n\t\t\tchar l = s[i + 1][j];\n\t\t\tif(k != l){\n\t\t\t\tsame = false;\n\t\t\t\tg[k - 'a'][l - 'a'] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(same && p > q){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\trep(i, 26){\n\t\tfill_n(h, 26, 0);\n\t\tif(cycle(i)){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n){\n\t\t\tcin >> s[i];\n\t\t}\n\n\t\tcout << (solve() ? \"yes\" : \"no\") << endl;\n\t\t\n\t\trep(i, 26){\n\t\t\tfill_n(g[i], 26, false);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\n  typedef vector<int> Vector;\n  typedef vector<Vector> Matrix;\n  typedef queue<int> IntQueue;\n  public:\n    Graph(int size): size_(size), next_(size) {\n    }\n    void add_edge(int a, int b) {\n      next_[a].push_back(b);\n    }\n    bool exists_path(int a, int b) {\n      vector<bool> has_visited(size_, false);\n      IntQueue q;\n      q.push(a);\n      has_visited[a] = true;\n      while (not q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (size_t i = 0; i < next_[x].size(); ++i) {\n          int y = next_[x][i];\n          if (not has_visited[y]) {\n            if (y == b) {\n              return true;\n            }\n            has_visited[y] = true;\n            q.push(y);\n          }\n        }\n      }\n      return false;\n    }\n  private:\n    int size_;\n    Matrix next_;\n};\n\nbool solve(int n, string s[]) {\n  Graph g(26);\n  for (int i = 0; i < n - 1; ++i) {\n    size_t pos = 0;\n    while (pos < s[i].length() and s[i][pos] == s[i + 1][pos]) {\n      ++pos;\n    }\n    if (pos == s[i].length()) {\n      continue;\n    } else if (pos == s[i + 1].length()) {\n      return false;\n    }\n    g.add_edge(s[i][pos] - 'a', s[i + 1][pos] - 'a');\n    for (int i = 0; i < 26; ++i) {\n      for (int j = i + 1; j < 26; ++j) {\n        if (g.exists_path(i, j) and g.exists_path(j, i)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  string s[500];\n  while (true) {\n    cin >> n;\n    if (n == 0) {\n      return 0;\n    }\n    for (int i = 0; i < n; ++i) {\n      cin >> s[i];\n    }\n    if (solve(n, s)) {\n      cout << \"yes\" << endl;\n    } else {\n      cout << \"no\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\n#define REP(i, x, y) for(ll i = x; i < y; i++)\n#define PER(i, x, y) for(ll i = x; i > y; i--)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nstruct edge {\n    ll to, cost;\n};\n\nint V;\nvector<edge> G[30];\n\nvoid addedge(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\nint h[30];\nvector<int> tsorted;\n\n//トポロジカルソート。結果はtsortedに入る。\nbool tsort() {\n    fill(h, h + V, 0);\n    tsorted.clear();\n    for (int i = 0; i < V; i++) {\n        int len = G[i].size();\n        for (int j = 0; j < len; j++) {\n            h[G[i][j].to]++;\n        }\n    }\n    queue<int> que;\n    for (int i = 0; i < V; i++) {\n        if (h[i] == 0) {\n            que.push(i);\n            tsorted.push_back(i);\n        }\n    }\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        int len = G[p].size();\n        for (int i = 0; i < len; i++) {\n            int mark = G[p][i].to;\n            h[mark]--;\n            if (h[mark] == 0) {\n                que.push(mark);\n                tsorted.push_back(mark);\n            }\n        }\n    }\n    int sortedsize = tsorted.size();\n    if (sortedsize == V) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool ed[30][30];\n\nint main() {\n    while (1) {\n        ll n;\n        cin >> n;\n        V = 26;\n        REP(i, 0, V) {\n            G[i].clear();\n        }\n        if (n == 0) {\n            break;\n        }\n        string s[n];\n        REP(i, 0, n) {\n            cin >> s[i];\n        }\n        REP(i, 0, V) {\n            fill(ed[i], ed[i] + V, false);\n        }\n        bool ok = true;\n        REP(i, 0, n - 1) {\n            string s1 = s[i];\n            string s2 = s[i + 1];\n            ll len1 = s1.size();\n            ll len2 = s2.size();\n            bool tmp = false;\n            REP(i, 0, min(len1, len2)) {\n                if (s1[i] != s2[i]) {\n                    ed[s1[i] - 'a'][s2[i] - 'a'] = true;\n                    tmp = true;\n                    break;\n                }\n            }\n            if (!tmp) {\n                if (len1 > len2) {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n        REP(i, 0, V) {\n            REP(j, 0, V) {\n                if (ed[i][j]) {\n                    addedge(i, j, 1);\n                }\n            }\n        }\n        bool tmp2 = tsort();\n        if (!tmp2) {\n            ok = false;\n        }\n        if (ok) {\n            cout << \"yes\" << endl;\n        } else {\n            cout << \"no\" << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<char,char> P;\ntypedef pair<int,int> Pii;\n\nconst int MAX = 30;\nvector<Pii> E;\n\nP comp(string a, string b){\n  for(int i = 0; i < (int)min(a.length(), b.length()); i++)\n    if(a[i] != b[i]) return P(a[i], b[i]);\n\n  if(a.length() > b.length()) return P(a[b.length()], '?');\n  if(a.length() < b.length()) return P('?', b[a.length()]);\n  return P('?','?');\n}\n\nbool add_edge(const vector<string>& v){\n  E.clear();\n\n  for(int i = 0; i+1 < (int)v.size(); i++){\n    P p = comp(v[i], v[i+1]);\n    if(p == P('?', '?')) continue;\n    if(p.second == '?') return false;\n    if(p.first != '?') E.push_back(P(p.first-'a', p.second-'a'));\n  }\n  return true;\n}\n\nbool hasCircle(int N){\n  \n  vector<int> d(MAX, 0);\n  for(int i = 0; i <= N; i++){\n    bool update = false;\n    for(int j = 0; j < (int)E.size(); j++)\n      if(d[E[j].second] < d[E[j].first] + 1){\n\td[E[j].second] = d[E[j].first]+1;\n\tupdate = true;\n      }\n    if(i == N && update) return true;\n    if(!update) break;\n  }\n  return false;\n}\n\nbool solve(const vector<string>& v){\n  if(!add_edge(v)) return false;\n  return !hasCircle(v.size());\n}\n\nint main(){\n  \n  int N;\n  while(cin >> N && N){\n    vector<string> v(N);\n    for(int i = 0; i < N; i++) cin >> v[i];\n    cout << (solve(v)?\"yes\":\"no\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\twhile (N) {\n\t\tvector<string>s(N);\n\t\tfor (auto &i : s) {\n\t\t\tcin >> i;\n\t\t\twhile (i.size() < 10) {\n\t\t\t\ti.push_back('z' + 1);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>edge(27, vector<int>(27));\n\t\tfor (int i = 0; i < 26; i++)edge[26][i] = 1;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = 0; j < min(s[i - 1].size(), s[i].size()); j++) {\n\t\t\t\tif (s[i][j] != s[i - 1][j]) {\n\t\t\t\t\tedge[s[i - 1][j] - 'a'][s[i][j] - 'a'] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < 27; i++) {\n\t\t\tvector<int>to(27);\n\t\t\tqueue<int>Q;\n\t\t\tQ.push(i);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint cn = Q.front();\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int j = 0; j < 27; j++) {\n\t\t\t\t\tif (edge[cn][j]) {\n\t\t\t\t\t\tif (!to[j]) {\n\t\t\t\t\t\t\tto[j] = 1;\n\t\t\t\t\t\t\tQ.push(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (to[i])flag = false;\n\t\t}\n\t\tif (flag)cout << \"yes\\n\";\n\t\telse cout << \"no\\n\";\n\t\tcin >> N;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint n;\nint ma;\n\nbool checkv(vector<string> &s1) {\n    vector<string> s2 = s1;\n    map<char, char> m;\n    map<char, char> m2;\n    char c = 'A';\n    REP(i, ma) {\n        REP(j, n) {\n            if ((int)s1[j].length() > i) {\n                char cc = s1[j][i];\n                if (EXIST(m, cc)) {\n                    s2[j][i] = m[cc];\n                } else {\n                    m[cc] = s2[j][i] = c;\n                    m2[c] = cc;\n                    c++;\n                }\n            }\n        }\n    }\n    SORT(s2);\n    REP(i, n) {\n        REP(j, s2[i].length()) {\n            s2[i][j] = m2[s2[i][j]];\n        }\n    }\n    REP(i, n) {\n        if (s1[i] != s2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool checkh(vector<string> &s1) {\n    vector<string> s2 = s1;\n    map<char, char> m;\n    map<char, char> m2;\n    char c = 'A';\n    REP(i, n) {\n        REP(j, ma) {\n            if ((int)s1[i].length() > j) {\n                char cc = s1[i][j];\n                if (EXIST(m, cc)) {\n                    s2[i][j] = m[cc];\n                } else {\n                    m[cc] = s2[i][j] = c;\n                    m2[c] = cc;\n                    c++;\n                }\n            }\n        }\n    }\n    SORT(s2);\n    REP(i, n) {\n        REP(j, s2[i].length()) {\n            s2[i][j] = m2[s2[i][j]];\n        }\n    }\n    REP(i, n) {\n        if (s1[i] != s2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    while (cin >> n) {\n        vector<string> s1(n);\n        REP(i, n) {\n            cin >> s1[i];\n            ma = max(ma, (int)s1[i].length());\n        }\n\n        if (checkv(s1) || checkh(s1)) {\n            cout << \"yes\" << endl;\n        } else {\n            cout << \"no\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N ('z'-'a')\nusing namespace std;\nint n,ans;\nstring str[501];\nlong long mp[N+1];\n\nvoid mk_mp(int pos,int i,int j){\n  while(i<=j&&pos>=str[i].size())i++;\n  if(i>=j)return;\n  int ni=-1,ch=str[i][pos]-'a',c=1;\n\n  while(i<j){\n    int a=str[++i][pos]-'a',f=(ch==a);\n    if(f&&ni==-1)ni=i-1;\n    if(!f&&ni>=0)mk_mp(pos+1,ni,i-1),ni=-2;\n    if(!f&&c)mk_mp(pos,i,j),mp[ch]|=((1LL<<a)|mp[a]),c=0;\n    ans*=!(f&&!c)&!(f&&str[i-1].size()>str[i].size()&&!str[i][pos+1]);\n  }\n  if(ni>=0) mk_mp(pos+1,ni,j);\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>str[i];\n    ans=1;\n    mk_mp(0,0,n-1);\n    for(int i=0;i<=N;mp[i]=0,i++) ans*=!(mp[i]&(1<<i));\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nconst char premark = 'a' - 1;\n\nbool dfs(map<char, vector<char>>& G, vector<bool>& vis, char c) {\n  for(auto& next: G[c]) {\n    if(vis[next-'a']) return false;\n    vis[next-'a'] = 1;\n    if(!dfs(G, vis, next)) return false;\n    vis[next-'a'] = 0;\n  }\n  return true;\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    vector<string> v;\n    int L = 1;\n    rep(i, N) {\n      string s; cin >> s;\n      v.push_back(s);\n      maximize(L, s.size());\n    }\n    rep(i, N) {\n      v[i].resize(L, premark);\n    }\n\n    map<char, vector<char>> G;\n    vector<bool> vis(26);\n    bool oks[26] = {};\n    vector<char> starts;\n\n    rep(i, N-1) {\n      REP(ni, i+1, N) {\n        rep(j, L) {\n          if(v[i][j] == v[ni][j] && v[i][j] == premark) break;\n          if(v[i][j] == premark) break;\n          if(v[ni][j] == premark) goto ng;\n          if(v[i][j] == v[ni][j]) continue;\n          G[v[i][j]].push_back(v[ni][j]);\n          break;\n        }\n      }\n    }\n\n    rep(i, 26) if(!G['a'+i].empty()) {\n      sort(all(G['a'+i]));\n      G['a'+i].erase(unique(all(G['a'+i])), G['a'+i].end());\n    }\n\n    rep(i, 26) {\n      for(auto c: G[i+'a']) {\n        oks[c-'a'] = 1;\n      }\n    }\n\n\n    rep(i, 26)\n      if(!oks[i]) starts.push_back(i + 'a');\n\n    for(auto s: starts) {\n      vis.clear(); vis.resize(26);\n      vis[s-'a'] = 1;\n      if(!dfs(G, vis, s)) goto ng;\n    }\n\n    cout << \"yes\" << endl;\n    continue;\n\n    ng:;\n    cout << \"no\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500\n#define C 26\nusing namespace std;\nint n,slen[N],edge[C][C],f[N][N];\nint ans;\nstring s[N];\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    ans=1;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      slen[i]=s[i].size();\n    }\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)f[i][j]=0;\n    for(int i=0;i<C;i++)\n      for(int j=0;j<C;j++)\n\tedge[i][j]=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<10;j++){\n\tif(slen[i]<j+1)continue;\n\tfor(int k=i+1;k<n;k++){\n\t  if(f[i][k]){\n\t    if(slen[k]==j+1&&slen[i]>slen[k])\n\t      ans=0;\n\t    continue;\n\t  }\n\t  if(slen[k]<j+1)continue;\n\t  int i1=s[i][j]-'a';\n\t  int i2=s[k][j]-'a';\n\t  if(i1==i2)continue;\n\t  if(i1!=i2)f[i][k]=1;\n\t  edge[i1][i2]=1;\n\t}\n      }\n    }\n    for(int i=0;i<C;i++)\n      for(int j=0;j<C;j++)\n\tif(edge[i][j]&&edge[j][i])\n\t  ans=0;\n    if(ans)cout<<\"yes\"<<endl;\n    else cout<<\"no\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        vector<string> S(N);\n        for(auto &s:S) cin>>s;\n        int G[26][26];\n        fill(G[0],G[26],0);\n        bool flag=true;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++){\n                string s1=S[i], s2=S[j];\n                if(s1==s2) continue;\n                int ite=0;\n                while(ite<min(s1.size(),s2.size())&&s1[ite]==s2[ite]) ite++;\n                if(ite==s1.size()) continue;\n                if(ite==s2.size()){\n                    flag=false;\n                    continue;\n                }\n                G[s1[ite]-'a'][s2[ite]-'a']=1;\n            }\n        }\n        for(int k=0;k<26;k++){\n            for(int i=0;i<26;i++){\n                for(int j=0;j<26;j++){\n                    G[i][j]|=G[i][k]&G[k][j];\n                }\n            }\n        }\n        for(int i=0;i<26;i++){\n            if(G[i][i]) flag=false;\n        }\n        cout<<(flag?\"yes\":\"no\")<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<char,char> P;\ntypedef pair<int,int> Pii;\n\nconst int MAX = 30;\nvector<Pii> E;\n\nP comp(string a, string b){\n  for(int i = 0; i < (int)min(a.length(), b.length()); i++)\n    if(a[i] != b[i]) return P(a[i], b[i]);\n\n  if(a.length() > b.length()) return P(a[b.length()], '?');\n  if(a.length() < b.length()) return P('?', b[a.length()]);\n  return P('?','?');\n}\n\nbool add_edge(const vector<string>& v){\n  E.clear();\n\n  for(int i = 0; i+1 < (int)v.size(); i++){\n    P p = comp(v[i], v[i+1]);\n    if(p == P('?', '?')) continue;\n    if(p.second == '?') return false;\n    if(p.first != '?') E.push_back(P(p.first-'a', p.second-'a'));\n  }\n  return true;\n}\n\nbool hasCircle(int N){\n  \n  vector<int> d(N, 0);\n  for(int i = 0; i <= N; i++){\n    bool update = false;\n    for(int j = 0; j < (int)E.size(); j++)\n      if(d[E[j].second] < d[E[j].first] + 1){\n\td[E[j].second] = d[E[j].first]+1;\n\tupdate = true;\n      }\n    if(i == N && update) return true;\n    if(!update) break;\n  }\n  return false;\n}\n\nbool solve(const vector<string>& v){\n  if(!add_edge(v)) return false;\n  return !hasCircle(v.size());\n}\n\nint main(){\n  \n  int N;\n  while(cin >> N && N){\n    vector<string> v(N);\n    for(int i = 0; i < N; i++) cin >> v[i];\n    cout << (solve(v)?\"yes\":\"no\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <map>\n#include <queue>\n#include <list>\n#include <utility>\n\nusing namespace std;\n\nstring str[505];\n\nint rank[30];\n\nint c(char x)\n{\n    return x-'a';\n}\nbool is_ok(int x,int y)\n{\n    while(y!=rank[y])\n    if(rank[y]==x)\n        return false;\n    else y=rank[y];\n    if(y==x)\n        return false;\n    return true;\n}\nbool check(char x1,char x2)\n{\n    int t1=c(x1),t2=c(x2);\n    if(!is_ok(t1,t2))\n        return false;\n    int tmp=rank[t1];\n    rank[t1]=t2;\n    rank[t2]=tmp;\n    return true;\n}\nint main()\n{\n    int n;\n    while(cin>>n,n)\n    {\n        cin>>str[0];\n        int maxlen=str[0].size();\n        bool ok=true;\n        for(int i=1;i<n;i++)\n        {\n            cin>>str[i];\n            int len=str[i].size();\n            maxlen=max(maxlen,len);\n            if(str[i-1]!=str[i]&&str[i-1].find(str[i])==0)\n                ok=false;\n        }\n\n        if(!ok) {cout<<\"no\"<<endl;continue;}\n\n        for(int i=0;i<30;i++) rank[i]=i;\n\n        int i;\n        for(i=0;i<maxlen;i++)\n        {\n            char tmp1=0,tmp2=0;\n            bool ok1=true;\n            for(int j=0;j<n;j++)\n            {\n                if(i<str[j].size())\n                {\n                    if(!tmp1)\n                        tmp1=str[j][i];\n                    else if(!tmp2)\n                    {\n                        if(str[j][i]!=tmp1)\n                            tmp2=str[j][i];\n                    }\n                    else\n                    {\n                        if(!check(tmp1,tmp2))\n                        {\n                            ok1=false; break;\n                        }\n                        tmp1=tmp2=0;\n                    }\n                }\n\n            }\n            if(!ok1) break;\n        }\n        if(i==maxlen) cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nchar premark = 'a' - 1;\n\nbool dfs(map<char, vector<char>>& G, vector<bool>& vis, char c, set<char>& st) {\n  for(auto& next: G[c]) {\n    if(st.count(next)) return false;\n    if(vis[next-'a']) continue;\n    st.insert(next);\n    vis[next-'a'] = 1;\n    if(!dfs(G, vis, next, st)) return false;\n    st.erase(next);\n  }\n  return true;\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    vector<string> v;\n    int L = 1;\n    rep(i, N) {\n      string s; cin >> s;\n      v.push_back(s);\n      maximize(L, s.size());\n    }\n    rep(i, N) {\n      v[i].resize(L, premark);\n    }\n\n    map<char, vector<char>> G;\n    vector<bool> vis(26);\n    bool oks[26] = {};\n    vector<char> starts;\n\n    rep(i, N-1) {\n      REP(ni, i+1, N) {\n        rep(j, L) {\n          if(v[i][j] == v[ni][j] && v[i][j] == premark) break;\n          if(v[i][j] == premark) break;\n          if(v[ni][j] == premark) goto ng;\n          if(v[i][j] == v[ni][j]) continue;\n          G[v[i][j]].push_back(v[ni][j]);\n          break;\n        }\n      }\n    }\n\n    rep(i, 26) if(!G['a'+i].empty()) {\n      sort(all(G['a'+i]));\n      G['a'+i].erase(unique(all(G['a'+i])), G['a'+i].end());\n    }\n\n    rep(i, 26) {\n      for(auto c: G[i+'a']) {\n        oks[c-'a'] = 1;\n      }\n    }\n\n\n    rep(i, 26)\n      if(!oks[i]) starts.push_back(i + 'a');\n\n    for(auto s: starts) {\n      vis[s-'a'] = 1;\n      set<char> st = {s};\n      if(!dfs(G, vis, s, st)) goto ng;\n    }\n\n    cout << \"yes\" << endl;\n    continue;\n\n    ng:;\n    cout << \"no\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T>& V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> >& Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T>& mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\ntemplate<typename T>vector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2534>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint n;\ntemplate<class Type>\nType solve(Type res = Type()){\n    while(cin >> n,n){\n        // preprocessing\n        vector<string> s(n);\n        for(auto& in:s) cin >> in;\n        \n        for(auto& each_s:s){\n            each_s += string(10-each_s.length(),(char)('a'-1));\n            for(auto& c:each_s) c -= 'a'-1;\n        }\n        // main processing\n        bool ok = true;\n        int dist[27][27] = {0};\n        for(int i = 0; i < n;i++){\n            for(int j = i+1; j < n; j++){\n                int k = 0;\n                while(k<10&&s[i][k]==s[j][k]) k++;\n                if(k==10) continue;\n                if(dist[s[j][k]][s[i][k]]) ok = false;\n                dist[s[i][k]][s[j][k]] = 1;\n            }\n        }\n        for(int i = 0; i < 27;i++) if(dist[i][0]) ok = false;\n        \n        if(!ok){\n            cout << \"no\" << endl;\n            continue;\n        }\n        \n        function<bool(int,int)> rec = [&](int k,int cnt){\n            if(cnt >= 27) return false;\n            bool f = true;\n            for(int i = 0; i < 27;i++){\n                if(dist[k][i]) f = false;\n            }\n            if(f) return true;\n            \n            f = true;\n            for(int i = 0; i < 27;i++){\n                if(dist[k][i]){\n                    f &= rec(i,cnt+1);\n                }\n            }\n            return f;\n        };\n        \n        if(rec(0,0)) cout << \"yes\" << endl;\n        else cout << \"no\" << endl;\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve(0);\n    //cout << fixed << setprecision(15) << solve<ll>() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 1e9;\n\nbool has_loop(vector< vector<int> > G){\n  int n = G.size();\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i){\n    if(G[i][i] < INF) return true;\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    vector<string> S(n);\n    for(int i = 0; i < n; ++i){\n      cin >> S[i];\n    }\n    if(n == 1) cout << \"yes\" << endl;\n    vector< vector<int> > G(26, vector<int>(26,INF));\n    bool f = true;\n    for(int i = 1; i < n; ++i){\n      if(S[i-1] == S[i]) continue;\n      for(int j = 0; j < min(S[i].length(),S[i-1].length()); ++j){\n        f = true;\n        if(S[i][j] != S[i-1][j]){\n          //G[S[i-1][j] - 'a'].push_back(S[i][j] - 'a');\n          G[S[i-1][j] - 'a'][S[i][j] - 'a'] = 1;\n          f = false;\n          break;\n        }\n      }\n      if(f && S[i-1].size() > S[i].size()){\n        cout << \"no\" << endl;\n        break;\n      }\n    }\n    if(f) continue;\n\n\n    if(has_loop(G)) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,i,j,k,G[30][30],f;\nchar S[501][11],*s,*t;\nint main()\n{\n\tfor(;scanf(\"%d\\n\",&N),N;)\n\t{\n\t\tf=0;\n\t\tmemset(G,0,sizeof(G));\n\t\tfor(i=0;i<N;i++)\n\t\t\tgets(S[i]);\n\t\tfor(i=1;i<N;i++)\n\t\t{\n\t\t\ts=S[i-1],t=S[i];\n\t\t\tfor(j=0;s[j]&&s[j]==t[j];j++);\n\t\t\tif(s[j]&&!t[j])\n\t\t\t\tf=1;\n\t\t\telse if(s[j]&&t[j]&&s[j]!=t[j])\n\t\t\t\tG[s[j]-'a'][t[j]-'a']=1;\n\t\t}\n\t\tfor(k=0;k<26;k++)\n\t\t\tfor(i=0;i<26;i++)\n\t\t\t\tfor(j=0;j<26;j++)\n\t\t\t\t\tG[i][j]|=G[i][k]&&G[k][j];\n\t\tfor(i=0;i<26;i++)\n\t\t\tf|=G[i][i];\n\t\tputs(f?\"no\":\"yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2534\n  Title:Dictionary\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint n;\nchar seq[26][26];\nchar word[11];\nchar prev_word[11];\n\nint set_seq(char prev[],char word[])\n{\n  char p,c;\n  int i;\n\n  while(*prev==*word && *prev && *word)\n    prev++,word++;\n  p=*prev;c=*word;\n  if(!p && c)\n    return(0);\n  else if(p && !c)\n    return(1);  // gyaku\n  if(p && c)\n    {\n      p -= 'a';\n      c -= 'a';\n      if(seq[p][c]==-1)\n\treturn(1);\n      for(i=0;i<26;i++)\n\t{\n\t  if(seq[p][i]==1 && seq[i][c]==1 && seq[p][c]==-1)\n\t    return(0);\n\t  if(seq[i][c]==1 && seq[c][p]==1 && seq[i][p]==-1)\n\t    return(0);\n\t  if(seq[c][i]==1 && seq[i][p]==1 && seq[c][p]==-1)\n\t    return(0);\n\t}\n      seq[p][c]=1;\n      seq[c][p]=-1;\n    }\n  return(0);\n}\n\n\nmain()\n{\n  int i,ret;\n  \n\n  while(scanf(\"%d\",&n) && n)\n    {\n      memset(seq,0,sizeof(seq));\n      scanf(\"%s\",prev_word);\n      ret=0;\n      for(i=0;i<n-1;i++)\n\t{\n\t  scanf(\"%s\",word);\n\t  if(ret==0)\n\t    ret=set_seq(prev_word,word);\n\t  strcpy(prev_word,word);\n\t}\n      printf(\"%s\\n\",((ret==0)?\"yes\":\"no\"));\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint n;\n\twhile(scanf(\"%d\",&n)==1 && n!=0) {\n\t\tchar input[500][12];\n\t\tint P[26][26]={{0}}; /* [] > [] */\n\t\tint i,j,k;\n\t\tint ok=1;\n\t\tfor(i=0;i<n;i++)scanf(\"%s\",input[i]);\n\t\t/* zyunzyho kankei wo chuusyutu suru */\n\t\tfor(i=0;i<n;i++) {\n\t\t\tfor(j=i+1;j<n;j++) {\n\t\t\t\tint k;\n\t\t\t\tfor(k=0;input[i][k]!='\\0' || input[j][k]!='\\0';k++) {\n\t\t\t\t\tif(input[i][k]!=input[j][k]) {\n\t\t\t\t\t\tif(input[i][k]!='\\0') {\n\t\t\t\t\t\t\tif(input[j][k]!='\\0') {\n\t\t\t\t\t\t\t\tP[input[j][k]-'a'][input[i][k]-'a']=1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* no way, example: ab < a */\n\t\t\t\t\t\t\t\tok=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* suiiritu */\n\t\tfor(k=0;k<n;k++) {\n\t\t\tfor(i=0;i<n;i++) {\n\t\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\t\tif(P[i][k]!=0 && P[k][j]!=0)P[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* check */\n\t\tfor(i=0;i<26;i++) {\n\t\t\tif(P[i][i]!=0)ok=0;\n\t\t}\n\t\tputs(ok?\"yes\":\"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tint n;\n\twhile(scanf(\"%d\",&n)==1 && n!=0) {\n\t\tchar input[500][12];\n\t\tint P[26][26]={{0}}; /* [] > [] */\n\t\tint i,j,k;\n\t\tint ok=1;\n\t\tfor(i=0;i<n;i++)scanf(\"%s\",input[i]);\n\t\t/* zyunzyho kankei wo chuusyutu suru */\n\t\tfor(i=0;i<n;i++) {\n\t\t\tfor(j=i+1;j<n;j++) {\n\t\t\t\tint k;\n\t\t\t\tfor(k=0;input[i][k]!='\\0' || input[j][k]!='\\0';k++) {\n\t\t\t\t\tif(input[i][k]!=input[j][k]) {\n\t\t\t\t\t\tif(input[i][k]!='\\0') {\n\t\t\t\t\t\t\tif(input[j][k]!='\\0') {\n\t\t\t\t\t\t\t\tP[input[j][k]-'a'][input[i][k]-'a']=1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* no way, example: ab < a */\n\t\t\t\t\t\t\t\tok=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* suiiritu */\n\t\tfor(k=0;k<26;k++) {\n\t\t\tfor(i=0;i<26;i++) {\n\t\t\t\tfor(j=0;j<26;j++) {\n\t\t\t\t\tif(P[i][k]!=0 && P[k][j]!=0)P[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* check */\n\t\tfor(i=0;i<26;i++) {\n\t\t\tif(P[i][i]!=0)ok=0;\n\t\t}\n\t\tputs(ok?\"yes\":\"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2534: Dictionary\n// 2017.10.7 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define SIZE 26\n\nchar wd[502][12];\nchar mk[SIZE][SIZE];\n\nint  q[SIZE], top, tail;\nint  count[SIZE];\n\nvoid push(int n) { q[tail++] = n; }\nint  pop(int *n) { if (top == tail) return 0; *n = q[top++]; return 1; }\nint topological_sort(int size)\n{\n    int i, j, k;\n\n    memset(count, 0, sizeof(count));\n    top = tail = 0;\n    for (i = 0; i < size; i++) for (j = 0; j < size; j++)\n        if (mk[i][j]) count[j]++;\n\n    for (i = 0; i < size; i++) {\n        if (count[i] == 0) push(i);\n    }\n\n    k = 0;\n    while (pop(&i)) {\n        for (j = 0; j < size; j++) if (mk[i][j])\n\t\t\tif (--count[j] == 0) push(j);\n\t\tk++;\n    }\n\treturn k;\n}\n\nint main()\n{\n\tint n, i, a, b;\n\tchar *p, *q;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (i = 0; i < n; i++) scanf(\"%s\", wd[i]);\n\t\tif (n == 1) { puts(\"yes\"); continue; }\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tq = wd[i-1], p = wd[i];\n\t\t\twhile (*p && *q == *p) q++, p++;\n\t\t\tif (!*q) continue;\n\t\t\tif (!*p) goto NO;\n\t\t\ta = *p - 'a', b = *q - 'a';\n\t\t\tif (mk[b][a]) goto NO;\n\t\t\tmk[a][b] = 1;\n\t\t}\n\n\t\tif (topological_sort(SIZE) == SIZE) puts(\"yes\");\n\t\telse {\nNO:\t\t\tputs(\"no\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    //comparator[a][b] => a.compareTo(b)\n    val comparator = Array(26){IntArray(26){0}}\n    while(true){\n        val n = readLine()!!.trim().toInt()\n        if (n == 0) return\n        comparator.forEach { it.fill(0) }\n        var fail = false\n        val words = Array(n){readLine()!!.trim()}\n        for (i in 1 until n){\n            val prev = words[i - 1]\n            val next = words[i]\n            for (j in prev.indices){\n                if (j !in next.indices){\n                    fail = true\n                }else if (prev[j] != next[j] && comparator[prev[j].toIndex][next[j].toIndex] == 1){\n                    fail = true\n                }else if (prev[j] != next[j] && comparator[prev[j].toIndex][next[j].toIndex] == 0){\n                    comparator[prev[j].toIndex][next[j].toIndex] = -1\n                    comparator[next[j].toIndex][prev[j].toIndex] = 1\n                }\n                if (j !in next.indices || prev[j] != next[j]) break\n            }\n        }\n        if (!fail){\n            outer@for (next in 1 until 26){\n                for (prev in 0 until next) {\n                    for (mid in 0 until 26) if (comparator[prev][mid] == comparator[mid][next] && comparator[prev][mid] != 0){\n                        if (comparator[prev][next] == 0){\n                            comparator[prev][next] = comparator[prev][mid]\n                            comparator[next][prev] = comparator[mid][prev]\n                        }else if (comparator[prev][next] != comparator[prev][mid]) {\n                            fail = true\n                            break@outer\n                        }\n                    }\n                }\n            }\n        }\n        println(\n                if (fail) \"no\" else \"yes\"\n        )\n    }\n}\nval Char.toIndex: Int\n        get() = this - 'a'\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint YET = -1;\n\tint CON = 1;\n\tint NOT_CON = 2;\n\tint MAX_STR_LEN = 10;\n\tint[][] g = new int[26][26];\n\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tString[] str = in.nextStringArray(n);\n\t\t\t\n\t\t\tboolean[] ok = new boolean[n];\n\t\t\tfor (int i = 0; i < 26; i++) {\n\t\t\t\tArrays.fill(g[i], YET);\n\t\t\t\tg[i][i] = CON;\n\t\t\t}\n\t\t\t\n\t\t\tboolean res = true;\n\t\t\tmain : \n\t\t\tfor (int j = 0; j < MAX_STR_LEN; j++) {\n\t\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\t\tif (ok[i]) continue;\n\t\t\t\t\tif (str[i].length() == j) {\n\t\t\t\t\t\tif (str[i+1].length() >= j) {\n\t\t\t\t\t\t\tok[i] = true;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = false;\n\t\t\t\t\t\t\tbreak main;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (str[i+1].length() == j) {\n\t\t\t\t\t\tres = false;\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint c1 = str[i].charAt(j) - 'a', c2 = str[i+1].charAt(j) - 'a';\n\t\t\t\t\tif (g[c1][c2] == YET) {\n\t\t\t\t\t\tfor (int u = 0; u < 26; u++) if (c1 != u && c2 != u) {\n\t\t\t\t\t\t\tif (g[c2][u] == CON && g[u][c1] == CON) {\n\t\t\t\t\t\t\t\tres = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println(\"con : \" + str[i].charAt(j) + \" \" + str[i+1].charAt(j));\n\t\t\t\t\t\tg[c1][c2] = CON;\n\t\t\t\t\t\tg[c2][c1] = NOT_CON;\n\t\t\t\t\t\tfor (int u = 0; u < 26; u++) if (c1 != u && c2 != u) {\n\t\t\t\t\t\t\tif (g[u][c1] == CON) {\n//\t\t\t\t\t\t\t\tSystem.out.println(\"con1 : \" + (char)(u + 'a') + \" \" + (char)(c2 + 'a'));\n\t\t\t\t\t\t\t\tg[u][c2] = CON;\n\t\t\t\t\t\t\t\tg[c2][u] = NOT_CON;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (g[c2][u] == CON) {\n//\t\t\t\t\t\t\t\tSystem.out.println(\"con2 : \" + (char)(c1 + 'a') + \" \" + (char)(u + 'a'));\n\t\t\t\t\t\t\t\tg[c1][u] = CON;\t\t\t\n\t\t\t\t\t\t\t\tg[u][c1] = NOT_CON;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (g[c1][c2] == NOT_CON) {\n\t\t\t\t\t\tres = false;\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (c1 != c2) ok[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res ? \"yes\" : \"no\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic String[] str;\n\tstatic int N;\n\tstatic boolean[][] g;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tstr = new String[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tstr[i] = sc.next();\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"yes\" : \"no\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tg = new boolean[26][26];\n\t\tif (!construct(0, N, 0)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tboolean[] visited = new boolean[26];\n\t\t\tif (!dfs(i, visited)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean dfs(int pos, boolean[] visited) {\n\t\tif (visited[pos]) return false;\n\t\tvisited[pos] = true;\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (g[pos][i]) {\n\t\t\t\tif (!dfs(i, visited)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisited[pos] = false;\n\t\treturn true;\n\t}\n\n\tstatic boolean construct(int s, int e, int pos) {\n\t\t// System.out.println(s + \" \" + e + \" \" + pos);\n\t\tif (e - s == 1) return true;\n\t\twhile (s < e && str[s].length() == pos) {\n\t\t\t++s;\n\t\t}\n\t\tif (s >= e - 1) return true;\n\t\tint prev = s;\n\t\tfor (int i = s + 1;; ++i) {\n\t\t\tif (i == e) {\n\t\t\t\tif (!construct(prev, i, pos + 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str[i].length() == pos) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (str[i].charAt(pos) != str[prev].charAt(pos)) {\n\t\t\t\tg[str[prev].charAt(pos) - 'a'][str[i].charAt(pos) - 'a'] = true;\n\t\t\t\t// System.out.println(s + \" \" + e + \" \" + pos + \" \" + str[prev].charAt(pos) + \" \" + str[i].charAt(pos));\n\t\t\t\tif (!construct(prev, i, pos + 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tprev = i;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N;\n    static String[] S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n\n        while(true) {\n            N = sc.nextInt();\n            if( N == 0 ) break;\n\n            S = new String[N];\n            for (int i = 0; i < N; i++) {\n                S[i] = sc.next();\n            }\n\n            System.out.println(solve() ? \"yes\" : \"no\");\n        }\n    }\n\n    static boolean solve() {\n        // a < b -> dic[a][b] = -1\n        int[][] dic = new int[26][26];\n        lo:\n        for (int i = 0; i < N-1; i++) {\n            String s = S[i];\n            String t = S[i+1];\n\n            int n = Math.min(s.length(), t.length());\n            for (int j = 0; j < n; j++) {\n                int a = s.charAt(j) - 'a';\n                int b = t.charAt(j) - 'a';\n\n                if( a == b ) continue;\n\n                if( dic[a][b] == 0 ) {\n                    dic[a][b] = -1;\n                    dic[b][a] = 1;\n                    continue lo;\n\n                } else if( dic[a][b] == -1 ) {\n                    continue lo;\n\n                } else {\n                    return false;\n                }\n            }\n\n            // 最後まで同じだったので長さ勝負\n            if( s.length() > t.length() ) return false;\n        }\n\n        // 循環チェック\n        List<Edge> E = new ArrayList<>();\n        for (int i = 0; i < 26; i++) {\n            for (int j = 0; j < 26; j++) {\n                if( dic[i][j] == -1 ) {\n                    E.add( new Edge(i, j) );\n                }\n            }\n        }\n\n        int[][] G = adjD(26, E);\n        return khan(26, G) != null;\n    }\n\n    static int[] khan(int V, int[][] G) {\n        int[] deg = new int[V];\n        for (int[] tos : G) {\n            for (int to : tos) {\n                deg[to]++;\n            }\n        }\n\n        int[] q = new int[V];\n        int a = 0, b = 0;\n        for (int v = 0; v < V; v++) {\n            if( deg[v] == 0 ) q[b++] = v;\n        }\n\n        int[] ret = new int[V];\n        int idx = 0;\n        while( a != b ) {\n            int v = q[a++];\n            ret[idx++] = v;\n            for (int to : G[v]) {\n                deg[to]--;\n                if( deg[to] == 0 ) {\n                    q[b++] = to;\n                }\n            }\n        }\n\n        for (int v = 0; v < V; v++) {\n            if( deg[v] != 0 ) return null;\n        }\n        return ret;\n    }\n\n    static class Edge {\n        int a, b;\n\n        public Edge(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    static int[][] adjD(int n, List<Edge> es) {\n        int[][] adj = new int[n][];\n        int[] cnt = new int[n];\n\n        for (Edge e : es) {\n            cnt[e.a]++;\n        }\n        for (int i = 0; i < n; i++) {\n            adj[i] = new int[cnt[i]];\n        }\n        for (Edge e : es) {\n            adj[e.a][--cnt[e.a]] = e.b;\n        }\n        return adj;\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'tsort'\nrequire 'set'\n\nclass Hash\n\tinclude TSort\n\talias :tsort_each_node :each_key\n\tdef tsort_each_child(u)\n\t\tself[u].each {|v| yield v}\n\tend\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\twords = (1..n).map { gets.chomp }\n\tgraph = {}\n\t(?a..?z).each {|c| graph[c] = Set.new }\n\n\tok = true\n\twords.each_cons(2) do |w1, w2|\n\t\tif w1 != w2 && w1 =~ /^#{w2}/\n\t\t\tok = false\n\t\t\tbreak\n\t\tend\n\t\t(0..[w1.size, w2.size].min-1).each do |i|\n\t\t\tnext if w1[i] == w2[i]\n\t\t\tgraph[w1[i]] << w2[i]\n\t\t\tbreak\n\t\tend\n\tend\n\n\tif ok\n\t\tbegin\n\t\t\tgraph.tsort\n\t\trescue TSort::Cyclic\n\t\t\tok = false\n\t\tend\n\tend\n\n\tputs ok ? 'yes' : 'no'\nend"
  },
  {
    "language": "Ruby",
    "code": "# Header {{{\n\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\n# Requires {{{\nrequire 'set'\n# }}}\n\n# Constants {{{\nINF = 10**9\n# }}}\n\n# IO {{{\nclass MyIO\n  def initialize\n    @input = $stdin\n    @output = $stdout\n  end\n\n  # @param filename [String]\n  def set_input(filename)\n    @input = File.open(filename, 'r')\n  end\n\n  def set_output(filename)\n    @output = File.open(filename, 'w')\n  end\n\n  def int\n    gets.to_i\n  end\n\n  def ints\n    split.map(&:to_i)\n  end\n\n  def split\n    @input.gets.chomp.split(' ')\n  end\n  alias_method :strings, :split\n\n  def gets\n    @input.gets.chomp\n  end\n\n  def puts(*args)\n    @output.puts(*args)\n  end\nend\n\nio = MyIO.new\n# }}}\n\n# Algorithms {{{\n\ndef lower_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] < val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] >= val\n    low\n  else\n    high\n  end\nend\n\ndef upper_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] <= val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] > val\n    low\n  else\n    high\n  end\nend\n\n# }}}\n\n# }}}\n\nio.set_input('inputs/0.txt')\n\nwhile true\n  n = io.int\n  break if n == 0\n  bigger_chars = Hash.new { |h, k| h[k] = Set.new }\n  prev_word = ''\n  ok = true\n  n.times do |i|\n    word = io.gets\n    [prev_word.length, word.length].min.times do |j|\n      if prev_word[j] == word[j]\n        next\n      elsif bigger_chars[word[j]].include?(prev_word[j])\n        ok = false and break\n      else\n        bigger_chars[prev_word[j]] << word[j]\n        break\n      end\n    end\n    if prev_word.start_with?(word) && prev_word != word\n      ok = false\n    end\n    prev_word = word\n  end\n  puts ok ? 'yes' : 'no'\nend\n\n# vim: foldmethod=marker"
  },
  {
    "language": "Ruby",
    "code": "# Header {{{\n\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\n# Requires {{{\nrequire 'set'\n# }}}\n\n# Constants {{{\nINF = 10**9\n# }}}\n\n# IO {{{\nclass MyIO\n  def initialize\n    @input = $stdin\n    @output = $stdout\n  end\n\n  # @param filename [String]\n  def set_input(filename)\n    @input = File.open(filename, 'r')\n  end\n\n  def set_output(filename)\n    @output = File.open(filename, 'w')\n  end\n\n  def int\n    gets.to_i\n  end\n\n  def ints\n    split.map(&:to_i)\n  end\n\n  def split\n    @input.gets.chomp.split(' ')\n  end\n  alias_method :strings, :split\n\n  def gets\n    @input.gets.chomp\n  end\n\n  def puts(*args)\n    @output.puts(*args)\n  end\nend\n\nio = MyIO.new\n# }}}\n\n# Algorithms {{{\n\ndef lower_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] < val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] >= val\n    low\n  else\n    high\n  end\nend\n\ndef upper_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] <= val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] > val\n    low\n  else\n    high\n  end\nend\n\n# }}}\n\n# }}}\n\n# io.set_input('inputs/0.txt')\n\nwhile true\n  n = io.int\n  break if n == 0\n  bigger_chars = Hash.new { |h, k| h[k] = Set.new }\n  prev_word = ''\n  ok = true\n  n.times do |i|\n    word = io.gets\n    [prev_word.length, word.length].min.times do |j|\n      if prev_word[j] == word[j]\n        next\n      elsif bigger_chars[word[j]].include?(prev_word[j])\n        ok = false and break\n      else\n        bigger_chars[prev_word[j]] << word[j]\n        break\n      end\n    end\n    if prev_word.start_with?(word) && prev_word != word\n      ok = false\n    end\n    prev_word = word\n  end\n  puts ok ? 'yes' : 'no'\nend\n\n# vim: foldmethod=marker"
  },
  {
    "language": "Ruby",
    "code": "# Header {{{\n\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\n# Requires {{{\nrequire 'set'\n# }}}\n\n# Constants {{{\nINF = 10**9\n# }}}\n\n# IO {{{\nclass MyIO\n  def initialize\n    @input = $stdin\n    @output = $stdout\n  end\n\n  # @param filename [String]\n  def set_input(filename)\n    @input = File.open(filename, 'r')\n  end\n\n  def set_output(filename)\n    @output = File.open(filename, 'w')\n  end\n\n  def int\n    gets.to_i\n  end\n\n  def ints\n    split.map(&:to_i)\n  end\n\n  def split\n    @input.gets.chomp.split(' ')\n  end\n  alias_method :strings, :split\n\n  def gets\n    @input.gets.chomp\n  end\n\n  def puts(*args)\n    @output.puts(*args)\n  end\nend\n\nio = MyIO.new\n# }}}\n\n# Algorithms {{{\n\ndef lower_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] < val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] >= val\n    low\n  else\n    high\n  end\nend\n\ndef upper_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] <= val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] > val\n    low\n  else\n    high\n  end\nend\n\n# }}}\n\n# }}}\n\n# io.set_input('inputs/2.txt')\n# io.set_output('my_outputs/2.txt')\n\nwhile true\n  n = io.int\n  break if n == 0\n  bigger_chars = Hash.new { |h, k| h[k] = Set.new }\n  prev_word = ''\n  ok = true\n  n.times do |i|\n    word = io.gets\n    [prev_word.length, word.length].min.times do |j|\n      if prev_word[j] == word[j]\n        next\n      elsif bigger_chars[word[j]].include?(prev_word[j])\n        ok = false and break\n      else\n        bigger_chars[prev_word[j]] << word[j]\n        q = [word[j]]\n        while !q.empty?\n          c = q.pop\n          bigger_chars[prev_word[j]] << c\n          q += bigger_chars[c].to_a\n        end\n        break\n      end\n    end\n    if prev_word.start_with?(word) && prev_word != word\n      ok = false\n    end\n    prev_word = word\n  end\n  io.puts ok ? 'yes' : 'no'\nend\n\n# vim: foldmethod=marker"
  },
  {
    "language": "Ruby",
    "code": "while (inp = gets) && inp.chomp! != '0'\n  ss = []\n  n = inp.to_i\n  n.times{ss << gets.chomp}\n  g = Array.new(26){Array.new(26,false)}\n  ng = false\n  n.times{|i|\n    i.times{|j|\n      if [ss[i].size,ss[j].size].min.times{|k|\n          if ss[i][k] != ss[j][k]\n            g[ss[j][k].ord-'a'.ord][ss[i][k].ord-'a'.ord] = true\n            break\n          end\n        }\n        ng = true if ss[i].size < ss[j].size\n      end\n    }\n  }\n  26.times{|k|\n    26.times{|i|\n      26.times{|j|\n        g[i][j] |= g[i][k]&&g[k][j]\n        ng |= i==j && g[i][j]\n      }\n    }\n  }\n  puts ng ? 'no' : 'yes'\nend"
  },
  {
    "language": "Ruby",
    "code": "# Header {{{\n\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\n# Requires {{{\nrequire 'set'\n# }}}\n\n# Constants {{{\nINF = 10**9\n# }}}\n\n# IO {{{\nclass MyIO\n  def initialize\n    @input = $stdin\n    @output = $stdout\n  end\n\n  # @param filename [String]\n  def set_input(filename)\n    @input = File.open(filename, 'r')\n  end\n\n  def set_output(filename)\n    @output = File.open(filename, 'w')\n  end\n\n  def int\n    gets.to_i\n  end\n\n  def ints\n    split.map(&:to_i)\n  end\n\n  def split\n    @input.gets.chomp.split(' ')\n  end\n  alias_method :strings, :split\n\n  def gets\n    @input.gets.chomp\n  end\n\n  def puts(*args)\n    @output.puts(*args)\n  end\nend\n\nio = MyIO.new\n# }}}\n\n# Algorithms {{{\n\ndef lower_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] < val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] >= val\n    low\n  else\n    high\n  end\nend\n\ndef upper_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] <= val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] > val\n    low\n  else\n    high\n  end\nend\n\n# }}}\n\n# }}}\n\n# io.set_input('inputs/2.txt')\n# io.set_output('my_outputs/2.txt')\n\nwhile true\n  n = io.int\n  break if n == 0\n  bigger_chars = Hash.new { |h, k| h[k] = Set.new }\n  prev_word = ''\n  ok = true\n  n.times do |i|\n    word = io.gets\n    [prev_word.length, word.length].min.times do |j|\n      if prev_word[j] == word[j]\n        next\n      elsif bigger_chars[word[j]].include?(prev_word[j])\n        ok = false and break\n      else\n        bigger_chars[prev_word[j]] << word[j]\n        # Update dependencies\n        ('a'..'z').each do |c|\n          q = bigger_chars[c].to_a\n          while !q.empty?\n            tc = q.pop\n            bigger_chars[c] << tc\n            q += (bigger_chars[tc] - bigger_chars[c]).to_a\n          end\n        end\n        break\n      end\n    end\n    if prev_word.start_with?(word) && prev_word != word\n      ok = false\n    end\n    prev_word = word\n  end\n  io.puts ok ? 'yes' : 'no'\nend\n\n# vim: foldmethod=marker"
  },
  {
    "language": "Ruby",
    "code": "while (inp = gets) && inp != '0'\n  ss = []\n  n = inp.to_i\n  n.times{ss << gets.chomp}\n  g = Array.new(26){Array.new(26,false)}\n  ng = false\n  n.times{|i|\n    i.times{|j|\n      if [ss[i].size,ss[j].size].min.times{|k|\n          if ss[i][k] != ss[j][k]\n            g[ss[j][k].ord-'a'.ord][ss[i][k].ord-'a'.ord] = true\n            break\n          end\n        }\n        ng = true if ss[i] != ss[j]\n      end\n    }\n  }\n  26.times{|k|\n    26.times{|i|\n      26.times{|j|\n        g[i][j] |= g[i][k]&&g[k][j]\n        ng |= i==j && g[i][j]\n      }\n    }\n  }\n  puts ng ? 'no' : 'yes'\nend"
  },
  {
    "language": "Ruby",
    "code": "while (inp = gets) && inp != '0'\n  ss = []\n  n = inp.to_i\n  n.times{ss << gets.chomp}\n  g = Array.new(26){Array.new(26,false)}\n  ng = false\n  n.times{|i|\n    i.times{|j|\n      if [ss[i].size,ss[j].size].min.times{|k|\n          if ss[i][k] != ss[j][k]\n            g[ss[j][k].ord-'a'.ord][ss[i][k].ord-'a'.ord] = true\n            break\n          end\n        }\n        ng = true if ss[i].size < ss[j].size\n      end\n    }\n  }\n  26.times{|k|\n    26.times{|i|\n      26.times{|j|\n        g[i][j] |= g[i][k]&&g[k][j]\n        ng |= i==j && g[i][j]\n      }\n    }\n  }\n  puts ng ? 'no' : 'yes'\nend"
  },
  {
    "language": "Ruby",
    "code": "# Header {{{\n\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\n# Requires {{{\nrequire 'set'\n# }}}\n\n# Constants {{{\nINF = 10**9\n# }}}\n\n# IO {{{\nclass MyIO\n  def initialize\n    @input = $stdin\n    @output = $stdout\n  end\n\n  # @param filename [String]\n  def set_input(filename)\n    @input = File.open(filename, 'r')\n  end\n\n  def set_output(filename)\n    @output = File.open(filename, 'w')\n  end\n\n  def int\n    gets.to_i\n  end\n\n  def ints\n    split.map(&:to_i)\n  end\n\n  def split\n    @input.gets.chomp.split(' ')\n  end\n  alias_method :strings, :split\n\n  def gets\n    @input.gets.chomp\n  end\n\n  def puts(*args)\n    @output.puts(*args)\n  end\nend\n\nio = MyIO.new\n# }}}\n\n# Algorithms {{{\n\ndef lower_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] < val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] >= val\n    low\n  else\n    high\n  end\nend\n\ndef upper_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] <= val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] > val\n    low\n  else\n    high\n  end\nend\n\n# }}}\n\n# }}}\n\n# io.set_input('inputs/2.txt')\n# io.set_output('my_outputs/2.txt')\n\nwhile true\n  n = io.int\n  break if n == 0\n  bigger_chars = Hash.new { |h, k| h[k] = Set.new }\n  prev_word = ''\n  ok = true\n  n.times do |i|\n    word = io.gets\n    [prev_word.length, word.length].min.times do |j|\n      if prev_word[j] == word[j]\n        next\n      elsif bigger_chars[word[j]].include?(prev_word[j])\n        ok = false and break\n      else\n        pc = prev_word[j]\n        q = [word[j]]\n        while !q.empty?\n          c = q.pop\n          bigger_chars[pc] << c\n          q += (bigger_chars[c] - bigger_chars[pc]).to_a\n        end\n        break\n      end\n    end\n    if prev_word.start_with?(word) && prev_word != word\n      ok = false\n    end\n    prev_word = word\n  end\n  io.puts ok ? 'yes' : 'no'\nend\n\n# vim: foldmethod=marker"
  },
  {
    "language": "Ruby",
    "code": "def solve(ss)\n  g = Array.new(26){Array.new(26,false)}\n  ss[0...-1].zip(ss[1..-1]).each{|a,b|\n    if [a.size,b.size].min.times{|k|\n        if a[k] != b[k]\n          g[a[k].ord-'a'.ord][b[k].ord-'a'.ord] = true\n          break\n        end\n      }\n      return false if a.size > b.size\n    end\n  }\n  26.times{|k|\n    26.times{|i|\n      26.times{|j|\n        g[i][j] |= g[i][k]&&g[k][j]\n      }\n      return false if g[i][i]\n    }\n  }\nend  \n  \nwhile (inp = gets) && inp.chomp != '0'\n  ss = []\n  n = inp.to_i\n  n.times{ss << gets.chomp}\n  puts solve(ss) ? 'yes' : 'no'\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N;\n    string[] s;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        s = new string[N];\n        foreach (i; 0 .. N) {\n            s[i] = readln.chomp;\n        }\n        return true;\n    }\n    void solve() {\n        auto F = new int[][](26, 26);\n        foreach (ref L; F) L[] = -1;\n        bool C(in string A, in string B) {\n            auto L = min(A.length, B.length);\n            if (B.startsWith(A)) return true;\n            if (A.startsWith(B)) return false;\n            foreach (i; 0 .. L) {\n                if (A[i] == B[i]) continue;\n                char a = A[i],\n                     b = B[i];\n                int ai = cast(int)(a - 'a'),\n                    bi = cast(int)(b - 'a');\n                if (F[ai][bi] == 0) return false;\n                if (F[ai][bi] < 0) {\n                    F[ai][bi] = 1;\n                    F[bi][ai] = 0;\n                }\n                break;\n            }\n            return true;\n        }\n        bool check() {\n            foreach (i; 0 .. N - 1) {\n                //writeln(s[i], \" \", s[i + 1]);\n                if (!C(s[i], s[i + 1])) return false;\n            }\n            return true;\n        }\n        writeln(check ? \"yes\" : \"no\");\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N;\n    string[] s;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        s = new string[N];\n        foreach (i; 0 .. N) {\n            s[i] = readln.chomp;\n        }\n        return true;\n    }\n    void solve() {\n        auto G = new int[][26];\n        auto rG = new int[][26];\n        bool dfs(int[][] g, int a, int b) {\n            if (a == b) return true;\n            foreach (n; g[a]) {\n                if (dfs(g, n, b)) return true;\n            }\n            return false;\n        }\n        bool C(in string A, in string B) {\n            auto L = min(A.length, B.length);\n            if (B.startsWith(A)) return true;\n            if (A.startsWith(B)) return false;\n            foreach (i; 0 .. L) {\n                char a = A[i],\n                     b = B[i];\n                if (a == b) continue;\n                int ai = cast(int)(a - 'a'),\n                    bi = cast(int)(b - 'a');\n                if (dfs(G, ai, bi)) return true;\n                if (dfs(rG, ai, bi)) return false;\n                G[ai] ~= bi;\n                rG[bi] ~= ai;\n                return true;\n            }\n            return true;\n        }\n        bool check() {\n            foreach (i; 0 .. N - 1) {\n                //writeln(s[i], \" \", s[i + 1]);\n                if (!C(s[i], s[i + 1])) return false;\n            }\n            return true;\n        }\n        writeln(check ? \"yes\" : \"no\");\n        //foreach (L; F) writeln(L.map!((a) => a < 0 ? '?' : a == 0 ? 'x' : 'o'));\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N;\n    string[] s;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        s = new string[N];\n        foreach (i; 0 .. N) {\n            s[i] = readln.chomp;\n        }\n        return true;\n    }\n    void solve() {\n        auto G = new int[][N];\n        auto rG = new int[][N];\n        bool dfs(int[][] g, int a, int b) {\n            if (a == b) return true;\n            foreach (n; g[a]) {\n                if (dfs(g, n, b)) return true;\n            }\n            return false;\n        }\n        bool C(in string A, in string B) {\n            auto L = min(A.length, B.length);\n            if (B.startsWith(A)) return true;\n            if (A.startsWith(B)) return false;\n            foreach (i; 0 .. L) {\n                char a = A[i],\n                     b = B[i];\n                if (a == b) continue;\n                int ai = cast(int)(a - 'a'),\n                    bi = cast(int)(b - 'a');\n                if (dfs(G, ai, bi)) return true;\n                if (dfs(rG, ai, bi)) return false;\n                G[ai] ~= bi;\n                rG[bi] ~= ai;\n                return true;\n            }\n            return true;\n        }\n        bool check() {\n            foreach (i; 0 .. N - 1) {\n                //writeln(s[i], \" \", s[i + 1]);\n                if (!C(s[i], s[i + 1])) return false;\n            }\n            return true;\n        }\n        writeln(check ? \"yes\" : \"no\");\n        //foreach (L; F) writeln(L.map!((a) => a < 0 ? '?' : a == 0 ? 'x' : 'o'));\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "graph = []\n\ndef init():\n    global graph\n    graph = [[False] * 26 + [True] for _ in xrange(27)]\n    graph[26][26] = False\n\ndef atoi(c):#index\n    if c == \"#\":\n        return 26\n    return ord(c) - ord(\"a\")\n\ndef make_graph(L):\n    global graph\n    tmp = []\n    while \"\" in L:\n        L.remove(\"\")\n    for s1, s2 in zip(L, L[1:]):\n        if s1[0] == s2[0]:\n            tmp += [s1[1:], s2[1:]]\n        else:\n            if not tmp == []:\n                make_graph(tmp)\n            tmp = []\n            graph[atoi(s2[0])][atoi(s1[0])] = True\n    if not tmp == []:\n        make_graph(tmp)\n\ndef check(start):\n    stack = set([start])\n    visited = [False] * 27\n    while len(stack) != 0:\n        cur = stack.pop()\n        visited[cur] = True\n        if graph[cur][start]:\n            return False\n        for i in xrange(27):\n            if graph[cur][i] and not visited[i]:\n                stack.add(i)\n    return True\n\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    L = [raw_input() + \"#\" for _ in xrange(n)]\n    init()\n    make_graph(L)\n    for i in xrange(27):\n        if not check(i):\n            print \"no\"\n            break\n    else:\n        print \"yes\""
  },
  {
    "language": "Python",
    "code": "def add_edge(node, adj_lst, adj_rev, s1, s2):\n  ind = 0\n  max_len = min(len(s1), len(s2))\n  while ind < max_len and s1[ind] == s2[ind]:\n    ind += 1\n  if ind == max_len:\n    if max_len < len(s1):\n      return True\n    return False\n  c1 = ord(s1[ind]) - ord(\"a\")\n  c2 = ord(s2[ind]) - ord(\"a\")\n  adj_lst[c1].add(c2)\n  adj_rev[c2].add(c1)\n  node.add(c1)\n  node.add(c2)\n  return False\ndef main():\n  while True:\n    n = int(input())\n    if n == 0:\n      break\n    \n    lst = [input() for _ in range(n)]\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    adj_rev = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n      for j in range(i + 1, n):\n        blank_flag = blank_flag or add_edge(node, adj_lst, adj_rev, lst[i], lst[j])\n    \n    L = []\n    visited = [False] * 26\n    cycle_flag = False\n  \n    def visit(n):\n      global cycle_flag\n      if cycle_flag: return\n      if visited[n] == 2:\n        cycle_flag = True\n      elif visited[n] == 0:\n        visited[n] = 2\n        for to in adj_lst[n]:\n          visit(to)\n        visited[n] = 1\n        L.append(n)\n    \n    L = []\n    for n in node:\n      visit(n)\n    if cycle_flag or blank_flag:\n      print(\"no\")\n    else:\n      print(\"yes\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def add_edge(node, adj_lst, adj_rev, s1, s2):\n  ind = 0\n  max_len = min(len(s1), len(s2))\n  while ind < max_len and s1[ind] == s2[ind]:\n    ind += 1\n  if ind == max_len:\n    if max_len < len(s1):\n      return True\n    return False\n  c1 = ord(s1[ind]) - ord(\"a\")\n  c2 = ord(s2[ind]) - ord(\"a\")\n  adj_lst[c1].add(c2)\n  adj_rev[c2].add(c1)\n  node.add(c1)\n  node.add(c2)\n  return False\ndef main():\n  while True:\n    n = int(input())\n    if n == 0:\n      break\n    \n    lst = [input() for _ in range(n)]\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    adj_rev = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n      for j in range(i + 1, n):\n        blank_flag = blank_flag or add_edge(node, adj_lst, adj_rev, lst[i], lst[j])\n    \n    visited = [False] * 26\n    cycle_flag = False\n  \n    def visit(n):\n      ret = False\n      if visited[n] == 2:\n        return True\n      elif visited[n] == 0:\n        visited[n] = 2\n        for to in adj_lst[n]:\n          ret = ret or visit(to)\n        visited[n] = 1\n      return ret\n    \n    for n in node:\n      cycle_flag = cycle_flag or visit(n)\n    if cycle_flag or blank_flag:\n      print(\"no\")\n    else:\n      print(\"yes\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def add_edge(node, adj_lst, s1, s2):\n  ind = 0\n  max_len = min(len(s1), len(s2))\n  while ind < max_len and s1[ind] == s2[ind]:\n    ind += 1\n  if ind == max_len:\n    return max_len < len(s1)\n\n  c1 = ord(s1[ind]) - ord(\"a\")\n  c2 = ord(s2[ind]) - ord(\"a\")\n  adj_lst[c1].add(c2)\n  node.add(c1)\n  node.add(c2)\n  return False\n\ndef visit(n, visited, adj_lst):\n  ret = False\n  if visited[n] == 2:\n    return True\n  elif visited[n] == 0:\n    visited[n] = 2\n    for to in adj_lst[n]:\n      ret = ret or visit(to, visited, adj_lst)\n    visited[n] = 1\n  return ret\n \ndef main():\n  while True:\n    n = int(input())\n    if n == 0:\n      break\n    \n    lst = [input() for _ in range(n)]\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n      for j in range(i + 1, n):\n        blank_flag = blank_flag or add_edge(node, adj_lst, lst[i], lst[j])\n    if blank_flag:\n      print(\"no\")\n      continue\n    \n    visited = [0] * 26\n    cycle_flag = False\n  \n    for n in node:\n      cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    if cycle_flag:\n      print(\"no\")\n    else:\n      print(\"yes\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "graph = []\n\ndef init():\n    global graph\n    graph = [[False] * 26 + [True] for _ in xrange(27)]\n    graph[26][26] = False\n\ndef atoi(c):#index\n    if c == \"#\":\n        return 26\n    return ord(c) - ord(\"a\")\n\ndef make_graph(L):\n    global graph, count\n    cur = 0\n    L = [L[0]] + [L[i] for i in xrange(1, len(L)) if L[i] != L[i-1]]\n    tmp = []\n    for s1, s2 in zip(L, L[1:]):\n        if s1[0] == s2[0]:\n            tmp += [s1[1:], s2[1:]]\n        else:\n            if not tmp == []:\n                make_graph(tmp)\n            tmp = []\n            graph[atoi(s2[0])][atoi(s1[0])] = True\n    if not tmp == []:\n        make_graph(tmp)\n\ndef check(start):\n    stack = set([start])\n    visited = [False] * 27\n    while len(stack) != 0:\n        cur = stack.pop()\n        visited[cur] = True\n        if graph[cur][start]:\n            return False\n        for i in xrange(27):\n            if graph[cur][i] and not visited[i]:\n                stack.add(i)\n    return True\n\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    L = [raw_input() + \"#\" for _ in xrange(n)]\n    init()\n    make_graph(L)\n    for i in xrange(27):\n        if not check(i):\n            print \"no\"\n            break\n    else:\n        print \"yes\""
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n\n        a = [S() for _ in range(n)]\n        e = collections.defaultdict(set)\n        for c in string.ascii_lowercase:\n            e[''].add(c)\n\n        f = True\n        for i in range(n):\n            ai = a[i]\n            for j in range(i+1,n):\n                aj = a[j]\n                for k in range(len(ai)):\n                    if len(aj) <= k:\n                        f = False\n                        break\n                    if ai[k] == aj[k]:\n                        continue\n                    e[ai[k]].add(aj[k])\n                    break\n        if not f:\n            rr.append('no')\n            continue\n\n        v = collections.defaultdict(bool)\n        v[''] = True\n\n        def g(c):\n            if v[c] == 2:\n                return True\n            if v[c] == 1:\n                return False\n            v[c] = 1\n            for nc in e[c]:\n                if not g(nc):\n                    return False\n            v[c] = 2\n            return True\n\n        for c in list(e.keys()):\n            if v[c]:\n                continue\n            if not g(c):\n                f = False\n                break\n\n        if f:\n            rr.append('yes')\n        else:\n            rr.append('no')\n\n\n    return '\\n'.join(map(str,rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def add_edge(node, adj_lst, adj_rev, s1, s2):\n  ind = 0\n  max_len = min(len(s1), len(s2))\n  while ind < max_len and s1[ind] == s2[ind]:\n    ind += 1\n  if ind == max_len:\n    if max_len < len(s1):\n      return True\n    return False\n  c1 = ord(s1[ind]) - ord(\"a\")\n  c2 = ord(s2[ind]) - ord(\"a\")\n  adj_lst[c1].add(c2)\n  adj_rev[c2].add(c1)\n  node.add(c1)\n  node.add(c2)\n  return False\n\"\"\"\ndef dfs(x, visited, adj_lst, order):\n  visited[x] = True\n  for to in adj_lst[x]:\n    if not visited[to]:\n      dfs(to, visited, adj_lst, order)\n  order.append(x)\n\ndef dfs_rev(x, used, adj_rev):\n  used.append(x)\n  for to in adj_rev[x]:\n    if not to in used:\n      dfs_rev(x, used, adj_rev)\n\"\"\"\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  \n  lst = [input() for _ in range(n)]\n  node = set()\n  adj_lst = [set() for _ in range(26)]\n  adj_rev = [set() for _ in range(26)]\n  brunk_flag = False\n  for i in range(n):\n    for j in range(i + 1, n):\n      brunk_flag = brunk_flag or add_edge(node, adj_lst, adj_rev, lst[i], lst[j])\n  \n  L = []\n  visited = [False] * 26\n  cycle_flag = False\n  def visit(n):\n    global cycle_flag\n    if cycle_flag: return\n    if visited[n] == 2:\n      cycle_flag = True\n    elif visited[n] == 0:\n      visited[n] = 2\n      for to in adj_lst[n]:\n        visit(to)\n      visited[n] = 1\n      L.append(n)\n  \n  L = []\n  for n in node:\n    visit(n)\n  if cycle_flag or brunk_flag:\n    print(\"no\")\n  else:\n    print(\"yes\")\n"
  },
  {
    "language": "Python",
    "code": "graph = []\n\ndef init():\n    global graph\n    graph = [[False] * 26 + [True] for _ in xrange(27)]\n    graph[26][26] = False\n\ndef atoi(c):#index\n    if c == \"#\":\n        return 26\n    return ord(c) - ord(\"a\")\n\ndef make_graph(L):\n    global graph\n    cur = 0\n    L = [L[0]] + [L[i] for i in xrange(1, len(L)) if L[i] != L[i-1]] #\n    #while \"\" in L:\n    #    L.remove(\"\")\n    tmp = []\n    for s1, s2 in zip(L, L[1:]):\n        if s1[0] == s2[0]:\n            tmp += [s1[1:], s2[1:]]\n        else:\n            if not tmp == []:\n                make_graph(tmp)\n            tmp = []\n            graph[atoi(s2[0])][atoi(s1[0])] = True\n    if not tmp == []:\n        make_graph(tmp)\n\ndef check(start):\n    stack = set([start])\n    visited = [False] * 27\n    while len(stack) != 0:\n        cur = stack.pop()\n        visited[cur] = True\n        if graph[cur][start]:\n            return False\n        for i in xrange(27):\n            if graph[cur][i] and not visited[i]:\n                stack.add(i)\n    return True\n\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    L = [raw_input() + \"#\" for _ in xrange(n)]\n    init()\n    make_graph(L)\n    for i in xrange(27):\n        if not check(i):\n            print \"no\"\n            break\n    else:\n        print \"yes\""
  },
  {
    "language": "Python",
    "code": "graph = []\n\ndef init():\n    global graph\n    graph = [[False] * 26 + [True] for _ in xrange(27)]\n    graph[26][26] = False\n\ndef atoi(c):#index\n    if c == \"#\":\n        return 26\n    return ord(c) - ord(\"a\")\n\ndef make_graph(L):\n    global graph\n    cur = 0\n    L = [L[0]] + [L[i] for i in xrange(1, len(L)) if L[i] != L[i-1]]\n    tmp = []\n    for s1, s2 in zip(L, L[1:]):\n        if s1[0] == s2[0]:\n            tmp += [s1[1:], s2[1:]]\n        else:\n            if not tmp == []:\n                make_graph(tmp)\n            tmp = []\n            graph[atoi(s2[0])][atoi(s1[0])] = True\n    if not tmp == []:\n        make_graph(tmp)\n\ndef check(start):\n    stack = set([start])\n    visited = [False] * 27\n    while len(stack) != 0:\n        cur = stack.pop()\n        visited[cur] = True\n        if graph[cur][start]:\n            return False\n        for i in xrange(27):\n            if graph[cur][i] and not visited[i]:\n                stack.add(i)\n    return True\n\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    L = [raw_input() + \"#\" for _ in xrange(n)]\n    init()\n    make_graph(L)\n    for i in xrange(27):\n        if not check(i):\n            print \"no\"\n            break\n    else:\n        print \"yes\""
  },
  {
    "language": "Python",
    "code": "graph = []\n\ndef init():\n    global graph\n    graph = [[False] * 26 + [True] for _ in xrange(27)]\n    graph[26][26] = False\n\ndef atoi(c):#index\n    if c == \"#\":\n        return 26\n    return ord(c) - ord(\"a\")\n\ndef make_graph(L):\n    global graph\n    tmp = []\n    while \"\" in L:\n        L.remove(\"\")\n    for s1, s2 in zip(L, L[1:]):\n        if s1[0] == s2[0]:\n            tmp += [s1[1:], s2[1:]]\n        else:\n            if not tmp == [] and not make_graph(tmp):\n                return False\n            tmp = []\n            graph[atoi(s2[0])][atoi(s1[0])] = True\n    if not tmp == [] and not make_graph(tmp):\n        return False\n    return True\n\ndef check(start):\n    stack = set([start])\n    visited = [False] * 27\n    while len(stack) != 0:\n        cur = stack.pop()\n        visited[cur] = True\n        if graph[cur][start]:\n            return False\n        for i in xrange(27):\n            if graph[cur][i] and not visited[i]:\n                stack.add(i)\n    return True\n\nwhile True:\n    n = input()\n    if n == 0:\n        break\n    L = [raw_input() + \"#\" for _ in xrange(n)]\n    init()\n    make_graph(L)\n    for i in xrange(27):\n        if not check(i):\n            print \"no\"\n            break\n    else:\n        print \"yes\""
  }
]